// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTriArray
#include <pi_xy/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__GradientShape_GradientShape_Impl_
#include <pi_xy/imageAbstracts/_GradientShape/GradientShape_Impl_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_pixel__TwoGrad_TwoGrad_
#include <pi_xy/pixel/_TwoGrad/TwoGrad_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_16__new,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","_new",0x09d1d429,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_._new","pi_xy/imageAbstracts/GradientShape.hx",16,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_29_triangle,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","triangle",0xe3d38190,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.triangle","pi_xy/imageAbstracts/GradientShape.hx",29,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_38_rectangle,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","rectangle",0x0f798067,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.rectangle","pi_xy/imageAbstracts/GradientShape.hx",38,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_62_quad,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","quad",0x15bcf78f,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.quad","pi_xy/imageAbstracts/GradientShape.hx",62,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_75_line,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","line",0x1265d6bc,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.line","pi_xy/imageAbstracts/GradientShape.hx",75,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_93_radialPolyon,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","radialPolyon",0xe7ccf572,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.radialPolyon","pi_xy/imageAbstracts/GradientShape.hx",93,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_112_radialEllipseTri,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","radialEllipseTri",0xc299b974,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.radialEllipseTri","pi_xy/imageAbstracts/GradientShape.hx",112,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_130_sweepTri,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","sweepTri",0x2ffd4967,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.sweepTri","pi_xy/imageAbstracts/GradientShape.hx",130,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_148_pie,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","pie",0x23ae8a84,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.pie","pi_xy/imageAbstracts/GradientShape.hx",148,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_192_radialRectangle,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","radialRectangle",0x20e74788,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.radialRectangle","pi_xy/imageAbstracts/GradientShape.hx",192,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_218_thickArrow,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","thickArrow",0x26553ef4,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.thickArrow","pi_xy/imageAbstracts/GradientShape.hx",218,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_235_thickArrowBoth,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","thickArrowBoth",0xf6867d95,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.thickArrowBoth","pi_xy/imageAbstracts/GradientShape.hx",235,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_251_thickFixArrow,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","thickFixArrow",0xe7c6eb69,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.thickFixArrow","pi_xy/imageAbstracts/GradientShape.hx",251,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_268_thickFixArrowBoth,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","thickFixArrowBoth",0x0e20088a,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.thickFixArrowBoth","pi_xy/imageAbstracts/GradientShape.hx",268,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_289_RoundRectangle,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","RoundRectangle",0x7d00dee9,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.RoundRectangle","pi_xy/imageAbstracts/GradientShape.hx",289,0xdfcf8cde)
HX_LOCAL_STACK_FRAME(_hx_pos_70834771d18fdc01_303_lineRoundRectangle,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_","lineRoundRectangle",0x37ea7ddd,"pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_.lineRoundRectangle","pi_xy/imageAbstracts/GradientShape.hx",303,0xdfcf8cde)
namespace pi_xy{
namespace imageAbstracts{
namespace _GradientShape{

void GradientShape_Impl__obj::__construct() { }

Dynamic GradientShape_Impl__obj::__CreateEmpty() { return new GradientShape_Impl__obj; }

void *GradientShape_Impl__obj::_hx_vtable = 0;

Dynamic GradientShape_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< GradientShape_Impl__obj > _hx_result = new GradientShape_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool GradientShape_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x46d86002;
}

 ::pi_xy::ImageStruct GradientShape_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_16__new)
HXLINE(  18)		 ::Dynamic imageType = null();
HXDLIN(  18)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  18)		if (::hx::IsNull( imageType )) {
HXLINE(  18)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  18)		::Dynamic this2;
HXDLIN(  18)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  18)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  18)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  18)				{
HXLINE(  18)					b->width = w;
HXDLIN(  18)					b->height = h;
HXDLIN(  18)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  18)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  18)					{
HXLINE(  18)						int len = b->length;
HXDLIN(  18)						int w1 = 0;
HXDLIN(  18)						{
HXLINE(  18)							int _g = 0;
HXDLIN(  18)							int _g1 = b->height;
HXDLIN(  18)							while((_g < _g1)){
HXLINE(  18)								_g = (_g + 1);
HXDLIN(  18)								int y = (_g - 1);
HXDLIN(  18)								{
HXLINE(  18)									int _g2 = 0;
HXDLIN(  18)									int _g3 = b->width;
HXDLIN(  18)									while((_g2 < _g3)){
HXLINE(  18)										_g2 = (_g2 + 1);
HXDLIN(  18)										int x = (_g2 - 1);
HXDLIN(  18)										{
HXLINE(  18)											w1 = (w1 + 1);
HXDLIN(  18)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  18)										{
HXLINE(  18)											w1 = (w1 + 1);
HXDLIN(  18)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  18)										{
HXLINE(  18)											w1 = (w1 + 1);
HXDLIN(  18)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  18)										{
HXLINE(  18)											w1 = (w1 + 1);
HXDLIN(  18)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  18)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  18)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  18)				{
HXLINE(  18)					a->width = w;
HXDLIN(  18)					a->height = h;
HXDLIN(  18)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  18)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  18)					{
HXLINE(  18)						int _g4 = 0;
HXDLIN(  18)						int _g5 = a->length;
HXDLIN(  18)						while((_g4 < _g5)){
HXLINE(  18)							_g4 = (_g4 + 1);
HXDLIN(  18)							int i = (_g4 - 1);
HXDLIN(  18)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  18)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  18)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  18)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  18)				{
HXLINE(  18)					b1->width = w;
HXDLIN(  18)					b1->height = h;
HXDLIN(  18)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  18)					int size = (b1->length * 4);
HXDLIN(  18)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  18)					{
HXLINE(  18)						int _g6 = 0;
HXDLIN(  18)						int _g7 = b1->length;
HXDLIN(  18)						while((_g6 < _g7)){
HXLINE(  18)							_g6 = (_g6 + 1);
HXDLIN(  18)							int i1 = (_g6 - 1);
HXDLIN(  18)							{
HXLINE(  18)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  18)								bool this4;
HXDLIN(  18)								if ((i1 >= 0)) {
HXLINE(  18)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  18)									this4 = false;
            								}
HXDLIN(  18)								if (this4) {
HXLINE(  18)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  18)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  18)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  18)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  18)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  18)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  18)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  18)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  18)				{
HXLINE(  18)					v->width = w;
HXDLIN(  18)					v->height = h;
HXDLIN(  18)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  18)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  18)					{
HXLINE(  18)						int _g8 = 0;
HXDLIN(  18)						int _g9 = v->length;
HXDLIN(  18)						while((_g8 < _g9)){
HXLINE(  18)							_g8 = (_g8 + 1);
HXDLIN(  18)							int i2 = (_g8 - 1);
HXDLIN(  18)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  18)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  18)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  18)				{
HXLINE(  18)					b2->width = w;
HXDLIN(  18)					b2->height = h;
HXDLIN(  18)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  18)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  18)					{
HXLINE(  18)						int len1 = b2->length;
HXDLIN(  18)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  18)						if (::hx::IsNull( d->head )) {
HXLINE(  18)							int _g10 = 0;
HXDLIN(  18)							int _g11 = len1;
HXDLIN(  18)							while((_g10 < _g11)){
HXLINE(  18)								_g10 = (_g10 + 1);
HXDLIN(  18)								int i3 = (_g10 - 1);
HXDLIN(  18)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  18)							int _g12 = 0;
HXDLIN(  18)							int _g13 = len1;
HXDLIN(  18)							while((_g12 < _g13)){
HXLINE(  18)								_g12 = (_g12 + 1);
HXDLIN(  18)								int i4 = (_g12 - 1);
HXDLIN(  18)								{
HXLINE(  18)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  18)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  18)									{
HXLINE(  18)										int _g14 = 0;
HXDLIN(  18)										int _g15 = i4;
HXDLIN(  18)										while((_g14 < _g15)){
HXLINE(  18)											_g14 = (_g14 + 1);
HXDLIN(  18)											int i5 = (_g14 - 1);
HXDLIN(  18)											prev = l;
HXDLIN(  18)											l = l->next;
            										}
            									}
HXDLIN(  18)									if (::hx::IsNull( prev )) {
HXLINE(  18)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  18)										l = null();
            									}
            									else {
HXLINE(  18)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  18)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  18)				this2 = b2;
            			}
            			break;
            		}
HXDLIN(  18)		this1->image = this2;
HXDLIN(  18)		this1->width = w;
HXDLIN(  18)		this1->height = h;
HXDLIN(  18)		this1->imageType = ( (int)(imageType) );
HXLINE(  16)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GradientShape_Impl__obj,_new,return )

 ::pi_xy::algo::HitTri GradientShape_Impl__obj::triangle( ::pi_xy::ImageStruct this1,Float ax,Float ay,int colA,Float bx,Float by,int colB,Float cx,Float cy,int colC,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_29_triangle)
HXDLIN(  29)		bool hasHit1 = false;
HXDLIN(  29)		bool hasUndo = false;
HXDLIN(  29)		int aA = ((colB >> 24) & 255);
HXDLIN(  29)		int rA = ((colB >> 16) & 255);
HXDLIN(  29)		int gA = ((colB >> 8) & 255);
HXDLIN(  29)		int bA = (colB & 255);
HXDLIN(  29)		int aB = ((colA >> 24) & 255);
HXDLIN(  29)		int rB = ((colA >> 16) & 255);
HXDLIN(  29)		int gB = ((colA >> 8) & 255);
HXDLIN(  29)		int bB = (colA & 255);
HXDLIN(  29)		int aC = ((colC >> 24) & 255);
HXDLIN(  29)		int rC = ((colC >> 16) & 255);
HXDLIN(  29)		int gC = ((colC >> 8) & 255);
HXDLIN(  29)		int bC = (colC & 255);
HXDLIN(  29)		Float bcx = (bx - cx);
HXDLIN(  29)		Float bcy = (by - cy);
HXDLIN(  29)		Float acx = (ax - cx);
HXDLIN(  29)		Float acy = (ay - cy);
HXDLIN(  29)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  29)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  29)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  29)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  29)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  29)		if ((ax > bx)) {
HXDLIN(  29)			if ((ax > cx)) {
HXDLIN(  29)				int min;
HXDLIN(  29)				if ((bx > cx)) {
HXDLIN(  29)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXDLIN(  29)					min = ::Math_obj::floor(bx);
            				}
HXDLIN(  29)				int ii_min = min;
HXDLIN(  29)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  29)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN(  29)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  29)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN(  29)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN(  29)			if ((bx > cx)) {
HXDLIN(  29)				int min1;
HXDLIN(  29)				if ((ax > cx)) {
HXDLIN(  29)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXDLIN(  29)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN(  29)				int ii_min2 = min1;
HXDLIN(  29)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  29)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN(  29)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  29)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN(  29)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN(  29)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  29)		if ((ay > by)) {
HXDLIN(  29)			if ((ay > cy)) {
HXDLIN(  29)				int min2;
HXDLIN(  29)				if ((by > cy)) {
HXDLIN(  29)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXDLIN(  29)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN(  29)				int ii_min4 = min2;
HXDLIN(  29)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  29)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN(  29)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  29)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN(  29)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN(  29)			if ((by > cy)) {
HXDLIN(  29)				int min3;
HXDLIN(  29)				if ((ay > cy)) {
HXDLIN(  29)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXDLIN(  29)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN(  29)				int ii_min6 = min3;
HXDLIN(  29)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  29)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN(  29)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  29)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN(  29)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN(  29)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  29)		if (hasUndo) {
HXDLIN(  29)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  29)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  29)			 ::Dynamic imageType = null();
HXDLIN(  29)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  29)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  29)			::Dynamic undoImage1;
HXDLIN(  29)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN(  29)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  29)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  29)					{
HXDLIN(  29)						b->width = width;
HXDLIN(  29)						b->height = height;
HXDLIN(  29)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  29)						{
HXDLIN(  29)							int len = b->length;
HXDLIN(  29)							int w = 0;
HXDLIN(  29)							{
HXDLIN(  29)								int _g = 0;
HXDLIN(  29)								int _g1 = b->height;
HXDLIN(  29)								while((_g < _g1)){
HXDLIN(  29)									_g = (_g + 1);
HXDLIN(  29)									int y = (_g - 1);
HXDLIN(  29)									{
HXDLIN(  29)										int _g2 = 0;
HXDLIN(  29)										int _g3 = b->width;
HXDLIN(  29)										while((_g2 < _g3)){
HXDLIN(  29)											_g2 = (_g2 + 1);
HXDLIN(  29)											int x = (_g2 - 1);
HXDLIN(  29)											{
HXDLIN(  29)												w = (w + 1);
HXDLIN(  29)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  29)											{
HXDLIN(  29)												w = (w + 1);
HXDLIN(  29)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  29)											{
HXDLIN(  29)												w = (w + 1);
HXDLIN(  29)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  29)											{
HXDLIN(  29)												w = (w + 1);
HXDLIN(  29)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  29)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN(  29)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  29)					{
HXDLIN(  29)						a->width = width;
HXDLIN(  29)						a->height = height;
HXDLIN(  29)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  29)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)						{
HXDLIN(  29)							int _g4 = 0;
HXDLIN(  29)							int _g5 = a->length;
HXDLIN(  29)							while((_g4 < _g5)){
HXDLIN(  29)								_g4 = (_g4 + 1);
HXDLIN(  29)								int i = (_g4 - 1);
HXDLIN(  29)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  29)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN(  29)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  29)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  29)					{
HXDLIN(  29)						b1->width = width;
HXDLIN(  29)						b1->height = height;
HXDLIN(  29)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)						int size = (b1->length * 4);
HXDLIN(  29)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  29)						{
HXDLIN(  29)							int _g6 = 0;
HXDLIN(  29)							int _g7 = b1->length;
HXDLIN(  29)							while((_g6 < _g7)){
HXDLIN(  29)								_g6 = (_g6 + 1);
HXDLIN(  29)								int i1 = (_g6 - 1);
HXDLIN(  29)								{
HXDLIN(  29)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  29)									bool undoImage2;
HXDLIN(  29)									if ((i1 >= 0)) {
HXDLIN(  29)										undoImage2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXDLIN(  29)										undoImage2 = false;
            									}
HXDLIN(  29)									if (undoImage2) {
HXDLIN(  29)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  29)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  29)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  29)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  29)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  29)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  29)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN(  29)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  29)					{
HXDLIN(  29)						v->width = width;
HXDLIN(  29)						v->height = height;
HXDLIN(  29)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  29)						{
HXDLIN(  29)							int _g8 = 0;
HXDLIN(  29)							int _g9 = v->length;
HXDLIN(  29)							while((_g8 < _g9)){
HXDLIN(  29)								_g8 = (_g8 + 1);
HXDLIN(  29)								int i2 = (_g8 - 1);
HXDLIN(  29)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  29)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN(  29)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  29)					{
HXDLIN(  29)						b2->width = width;
HXDLIN(  29)						b2->height = height;
HXDLIN(  29)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  29)						{
HXDLIN(  29)							int len1 = b2->length;
HXDLIN(  29)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  29)							if (::hx::IsNull( d->head )) {
HXDLIN(  29)								int _g10 = 0;
HXDLIN(  29)								int _g11 = len1;
HXDLIN(  29)								while((_g10 < _g11)){
HXDLIN(  29)									_g10 = (_g10 + 1);
HXDLIN(  29)									int i3 = (_g10 - 1);
HXDLIN(  29)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN(  29)								int _g12 = 0;
HXDLIN(  29)								int _g13 = len1;
HXDLIN(  29)								while((_g12 < _g13)){
HXDLIN(  29)									_g12 = (_g12 + 1);
HXDLIN(  29)									int i4 = (_g12 - 1);
HXDLIN(  29)									{
HXDLIN(  29)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  29)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  29)										{
HXDLIN(  29)											int _g14 = 0;
HXDLIN(  29)											int _g15 = i4;
HXDLIN(  29)											while((_g14 < _g15)){
HXDLIN(  29)												_g14 = (_g14 + 1);
HXDLIN(  29)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  29)										if (::hx::IsNull( prev )) {
HXDLIN(  29)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  29)											l = null();
            										}
            										else {
HXDLIN(  29)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  29)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  29)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN(  29)			this2->image = undoImage1;
HXDLIN(  29)			this2->width = width;
HXDLIN(  29)			this2->height = height;
HXDLIN(  29)			this2->imageType = ( (int)(imageType) );
HXDLIN(  29)			undoImage = this2;
HXDLIN(  29)			{
HXDLIN(  29)				int rectLeft = xIter3->start;
HXDLIN(  29)				int rectTop = yIter3->start;
HXDLIN(  29)				int rectRight = xIter3->max;
HXDLIN(  29)				bool forceClear = false;
HXDLIN(  29)				{
HXDLIN(  29)					int _g16 = rectTop;
HXDLIN(  29)					int _g17 = yIter3->max;
HXDLIN(  29)					while((_g16 < _g17)){
HXDLIN(  29)						_g16 = (_g16 + 1);
HXDLIN(  29)						int dy = (_g16 - 1);
HXDLIN(  29)						{
HXDLIN(  29)							int _g18 = rectLeft;
HXDLIN(  29)							int _g19 = rectRight;
HXDLIN(  29)							while((_g18 < _g19)){
HXDLIN(  29)								_g18 = (_g18 + 1);
HXDLIN(  29)								int dx = (_g18 - 1);
HXDLIN(  29)								::Dynamic this4 = this1->image;
HXDLIN(  29)								int index;
HXDLIN(  29)								if (this1->useVirtualPos) {
HXDLIN(  29)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXDLIN(  29)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  29)								int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  29)								int col;
HXDLIN(  29)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN(  29)									col = c;
            								}
HXDLIN(  29)								bool _hx_tmp;
HXDLIN(  29)								if (this1->useMask) {
HXDLIN(  29)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN(  29)									_hx_tmp = false;
            								}
HXDLIN(  29)								if (_hx_tmp) {
HXDLIN(  29)									 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  29)									::Dynamic this6 = this5->image;
HXDLIN(  29)									int index1;
HXDLIN(  29)									if (this5->useVirtualPos) {
HXDLIN(  29)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            									}
            									else {
HXDLIN(  29)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            									}
HXDLIN(  29)									int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  29)									int v1;
HXDLIN(  29)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN(  29)										v1 = c1;
            									}
HXDLIN(  29)									int maskPixel = v1;
HXDLIN(  29)									int this7 = col;
HXDLIN(  29)									if ((maskPixel == 0)) {
HXDLIN(  29)										col = this7;
            									}
            									else {
HXDLIN(  29)										Float m0;
HXDLIN(  29)										int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  29)										if ((this8 == 0)) {
HXDLIN(  29)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float m1;
HXDLIN(  29)										int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  29)										if ((this9 == 0)) {
HXDLIN(  29)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float m2;
HXDLIN(  29)										int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  29)										if ((this10 == 0)) {
HXDLIN(  29)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float m3;
HXDLIN(  29)										int this11 = (maskPixel & 255);
HXDLIN(  29)										if ((this11 == 0)) {
HXDLIN(  29)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  29)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  29)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  29)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  29)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  29)								if ((col != 0)) {
HXDLIN(  29)									int x1 = (dx - rectLeft);
HXDLIN(  29)									int y1 = (dy - rectTop);
HXDLIN(  29)									int c2 = col;
HXDLIN(  29)									bool _hx_tmp1;
HXDLIN(  29)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  29)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN(  29)										_hx_tmp1 = false;
            									}
HXDLIN(  29)									if (_hx_tmp1) {
HXDLIN(  29)										int location;
HXDLIN(  29)										if (undoImage->useVirtualPos) {
HXDLIN(  29)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  29)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  29)										int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  29)										int this13;
HXDLIN(  29)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)											this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            										}
            										else {
HXDLIN(  29)											this13 = this12;
            										}
HXDLIN(  29)										Float a1;
HXDLIN(  29)										int this14 = ((this13 >> 24) & 255);
HXDLIN(  29)										if ((this14 == 0)) {
HXDLIN(  29)											a1 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float r1;
HXDLIN(  29)										int this15 = ((this13 >> 16) & 255);
HXDLIN(  29)										if ((this15 == 0)) {
HXDLIN(  29)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float g1;
HXDLIN(  29)										int this16 = ((this13 >> 8) & 255);
HXDLIN(  29)										if ((this16 == 0)) {
HXDLIN(  29)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float b11;
HXDLIN(  29)										int this17 = (this13 & 255);
HXDLIN(  29)										if ((this17 == 0)) {
HXDLIN(  29)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float a2;
HXDLIN(  29)										int this18 = ((col >> 24) & 255);
HXDLIN(  29)										if ((this18 == 0)) {
HXDLIN(  29)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float r2;
HXDLIN(  29)										int this19 = ((col >> 16) & 255);
HXDLIN(  29)										if ((this19 == 0)) {
HXDLIN(  29)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float g2;
HXDLIN(  29)										int this20 = ((col >> 8) & 255);
HXDLIN(  29)										if ((this20 == 0)) {
HXDLIN(  29)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float b21;
HXDLIN(  29)										int this21 = (col & 255);
HXDLIN(  29)										if ((this21 == 0)) {
HXDLIN(  29)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN(  29)											b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN(  29)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  29)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  29)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  29)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  29)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  29)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  29)										{
HXDLIN(  29)											int _hx_tmp2;
HXDLIN(  29)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN(  29)												_hx_tmp2 = blended;
            											}
HXDLIN(  29)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN(  29)										::Dynamic this22 = undoImage->image;
HXDLIN(  29)										int index2;
HXDLIN(  29)										if (undoImage->useVirtualPos) {
HXDLIN(  29)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  29)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  29)										int _hx_tmp3;
HXDLIN(  29)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN(  29)											_hx_tmp3 = c2;
            										}
HXDLIN(  29)										::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN(  29)									if (forceClear) {
HXDLIN(  29)										::Dynamic this23 = undoImage->image;
HXDLIN(  29)										int x2 = (dx - rectLeft);
HXDLIN(  29)										int y2 = (dy - rectTop);
HXDLIN(  29)										int index3;
HXDLIN(  29)										if (undoImage->useVirtualPos) {
HXDLIN(  29)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  29)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(  29)										::iterMagic::Iimg_obj::set(this23,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  29)		{
HXDLIN(  29)			int _g_min = xIter3->start;
HXDLIN(  29)			int _g_max = xIter3->max;
HXDLIN(  29)			while((_g_min < _g_max)){
HXDLIN(  29)				_g_min = (_g_min + 1);
HXDLIN(  29)				int px = (_g_min - 1);
HXDLIN(  29)				Float pcx = (( (Float)(px) ) - cx);
HXDLIN(  29)				{
HXDLIN(  29)					int _g_min1 = yIter3->start;
HXDLIN(  29)					int _g_max1 = yIter3->max;
HXDLIN(  29)					while((_g_min1 < _g_max1)){
HXDLIN(  29)						_g_min1 = (_g_min1 + 1);
HXDLIN(  29)						int py = (_g_min1 - 1);
HXDLIN(  29)						Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  29)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  29)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  29)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  29)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  29)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  29)						bool _hx_tmp4;
HXDLIN(  29)						bool _hx_tmp5;
HXDLIN(  29)						if ((ratioA >= 0)) {
HXDLIN(  29)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXDLIN(  29)							_hx_tmp5 = false;
            						}
HXDLIN(  29)						if (_hx_tmp5) {
HXDLIN(  29)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXDLIN(  29)							_hx_tmp4 = false;
            						}
HXDLIN(  29)						if (_hx_tmp4) {
HXDLIN(  29)							int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  29)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE(  29)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE(  29)							int a5 = i6;
HXDLIN(  29)							int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  29)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE(  29)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE(  29)							int r3 = i7;
HXDLIN(  29)							int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  29)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE(  29)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE(  29)							int g3 = i8;
HXDLIN(  29)							int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  29)							if ((i9 > 255)) {
HXLINE(  24)								i9 = 255;
            							}
HXLINE(  29)							if ((i9 < 0)) {
HXLINE(  25)								i9 = 0;
            							}
HXLINE(  29)							int b4 = i9;
HXDLIN(  29)							{
HXDLIN(  29)								int location1;
HXDLIN(  29)								if (this1->useVirtualPos) {
HXDLIN(  29)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            								}
            								else {
HXDLIN(  29)									location1 = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            								}
HXDLIN(  29)								bool _hx_tmp6;
HXDLIN(  29)								if (this1->transparent) {
HXDLIN(  29)									_hx_tmp6 = (a5 < 254);
            								}
            								else {
HXDLIN(  29)									_hx_tmp6 = false;
            								}
HXDLIN(  29)								if (_hx_tmp6) {
HXDLIN(  29)									int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  29)									int old;
HXDLIN(  29)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)										old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXDLIN(  29)										old = this24;
            									}
HXDLIN(  29)									int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  29)									Float a11;
HXDLIN(  29)									int this25 = ((old >> 24) & 255);
HXDLIN(  29)									if ((this25 == 0)) {
HXDLIN(  29)										a11 = ((Float)0.);
            									}
            									else {
HXDLIN(  29)										a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN(  29)									Float r11;
HXDLIN(  29)									int this26 = ((old >> 16) & 255);
HXDLIN(  29)									if ((this26 == 0)) {
HXDLIN(  29)										r11 = ((Float)0.);
            									}
            									else {
HXDLIN(  29)										r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN(  29)									Float g11;
HXDLIN(  29)									int this27 = ((old >> 8) & 255);
HXDLIN(  29)									if ((this27 == 0)) {
HXDLIN(  29)										g11 = ((Float)0.);
            									}
            									else {
HXDLIN(  29)										g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN(  29)									Float b12;
HXDLIN(  29)									int this28 = (old & 255);
HXDLIN(  29)									if ((this28 == 0)) {
HXDLIN(  29)										b12 = ((Float)0.);
            									}
            									else {
HXDLIN(  29)										b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN(  29)									Float a21;
HXDLIN(  29)									int this29 = ((rhs >> 24) & 255);
HXDLIN(  29)									if ((this29 == 0)) {
HXDLIN(  29)										a21 = ((Float)0.);
            									}
            									else {
HXDLIN(  29)										a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN(  29)									Float r21;
HXDLIN(  29)									int this30 = ((rhs >> 16) & 255);
HXDLIN(  29)									if ((this30 == 0)) {
HXDLIN(  29)										r21 = ((Float)0.);
            									}
            									else {
HXDLIN(  29)										r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN(  29)									Float g21;
HXDLIN(  29)									int this31 = ((rhs >> 8) & 255);
HXDLIN(  29)									if ((this31 == 0)) {
HXDLIN(  29)										g21 = ((Float)0.);
            									}
            									else {
HXDLIN(  29)										g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN(  29)									Float b22;
HXDLIN(  29)									int this32 = (rhs & 255);
HXDLIN(  29)									if ((this32 == 0)) {
HXDLIN(  29)										b22 = ((Float)0.);
            									}
            									else {
HXDLIN(  29)										b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN(  29)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  29)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  29)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  29)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  29)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  29)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  29)									{
HXDLIN(  29)										int _hx_tmp7;
HXDLIN(  29)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXDLIN(  29)											_hx_tmp7 = blended1;
            										}
HXDLIN(  29)										::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN(  29)									int value;
HXDLIN(  29)									if (this1->isLittle) {
HXDLIN(  29)										value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            									}
            									else {
HXDLIN(  29)										value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            									}
HXDLIN(  29)									::iterMagic::Iimg_obj::set(this1->image,location1,value);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  29)		if ((hasHit1 == false)) {
HXDLIN(  29)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN(  29)			if (hasUndo) {
HXDLIN(  29)				v2->undoImage = undoImage;
HXDLIN(  29)				v2->undoX = xIter3->start;
HXDLIN(  29)				v2->undoY = yIter3->start;
            			}
HXDLIN(  29)			return v2;
            		}
            		else {
HXDLIN(  29)			return null();
            		}
HXDLIN(  29)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(GradientShape_Impl__obj,triangle,return )

 ::Dynamic GradientShape_Impl__obj::rectangle( ::pi_xy::ImageStruct this1,Float x,Float y,Float wid,Float hi,int colorA,int colorB,int colorC,int colorD){
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_38_rectangle)
HXLINE(  39)		Float bx = (x + wid);
HXLINE(  40)		Float cy = (y + hi);
HXLINE(  41)		{
HXLINE(  41)			bool hasHit = true;
HXDLIN(  41)			{
HXLINE(  41)				{
HXLINE(  41)					bool hasUndo = false;
HXDLIN(  41)					int aA = ((colorB >> 24) & 255);
HXDLIN(  41)					int rA = ((colorB >> 16) & 255);
HXDLIN(  41)					int gA = ((colorB >> 8) & 255);
HXDLIN(  41)					int bA = (colorB & 255);
HXDLIN(  41)					int aB = ((colorA >> 24) & 255);
HXDLIN(  41)					int rB = ((colorA >> 16) & 255);
HXDLIN(  41)					int gB = ((colorA >> 8) & 255);
HXDLIN(  41)					int bB = (colorA & 255);
HXDLIN(  41)					int aC = ((colorD >> 24) & 255);
HXDLIN(  41)					int rC = ((colorD >> 16) & 255);
HXDLIN(  41)					int gC = ((colorD >> 8) & 255);
HXDLIN(  41)					int bC = (colorD & 255);
HXDLIN(  41)					Float bcx = (bx - x);
HXDLIN(  41)					Float bcy = (y - cy);
HXDLIN(  41)					Float acx = (x - x);
HXDLIN(  41)					Float acy = (y - cy);
HXDLIN(  41)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  41)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  41)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  41)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  41)					 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  41)					if ((x > bx)) {
HXLINE(  41)						if ((x > x)) {
HXLINE(  41)							int min;
HXDLIN(  41)							if ((bx > x)) {
HXLINE(  41)								min = ::Math_obj::floor(x);
            							}
            							else {
HXLINE(  41)								min = ::Math_obj::floor(bx);
            							}
HXDLIN(  41)							int ii_min = min;
HXDLIN(  41)							int ii_max = ::Math_obj::ceil(x);
HXDLIN(  41)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXLINE(  41)							int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  41)							int ii_max1 = ::Math_obj::ceil(x);
HXDLIN(  41)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            						}
            					}
            					else {
HXLINE(  41)						if ((bx > x)) {
HXLINE(  41)							int min1;
HXDLIN(  41)							if ((x > x)) {
HXLINE(  41)								min1 = ::Math_obj::floor(x);
            							}
            							else {
HXLINE(  41)								min1 = ::Math_obj::ceil(x);
            							}
HXDLIN(  41)							int ii_min2 = min1;
HXDLIN(  41)							int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  41)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            						}
            						else {
HXLINE(  41)							int ii_min3 = ::Math_obj::floor(x);
HXDLIN(  41)							int ii_max3 = ::Math_obj::ceil(x);
HXDLIN(  41)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            					}
HXDLIN(  41)					 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  41)					if ((y > y)) {
HXLINE(  41)						if ((y > cy)) {
HXLINE(  41)							int min2;
HXDLIN(  41)							if ((y > cy)) {
HXLINE(  41)								min2 = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  41)								min2 = ::Math_obj::floor(y);
            							}
HXDLIN(  41)							int ii_min4 = min2;
HXDLIN(  41)							int ii_max4 = ::Math_obj::ceil(y);
HXDLIN(  41)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
            						else {
HXLINE(  41)							int ii_min5 = ::Math_obj::floor(y);
HXDLIN(  41)							int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN(  41)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            						}
            					}
            					else {
HXLINE(  41)						if ((y > cy)) {
HXLINE(  41)							int min3;
HXDLIN(  41)							if ((y > cy)) {
HXLINE(  41)								min3 = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  41)								min3 = ::Math_obj::ceil(y);
            							}
HXDLIN(  41)							int ii_min6 = min3;
HXDLIN(  41)							int ii_max6 = ::Math_obj::ceil(y);
HXDLIN(  41)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            						}
            						else {
HXLINE(  41)							int ii_min7 = ::Math_obj::floor(y);
HXDLIN(  41)							int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN(  41)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            						}
            					}
HXDLIN(  41)					 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  41)					if (hasUndo) {
HXLINE(  41)						int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  41)						int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  41)						 ::Dynamic imageType = null();
HXDLIN(  41)						 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  41)						if (::hx::IsNull( imageType )) {
HXLINE(  54)							imageType = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  41)						::Dynamic undoImage1;
HXDLIN(  41)						switch((int)(( (int)(imageType) ))){
            							case (int)0: {
HXLINE(  41)								 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::BytesImg b = byt;
HXDLIN(  41)								{
HXLINE(  41)									b->width = width;
HXDLIN(  41)									b->height = height;
HXDLIN(  41)									b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)									b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  41)									{
HXLINE(  41)										int len = b->length;
HXDLIN(  41)										int w = 0;
HXDLIN(  41)										{
HXLINE(  41)											int _g = 0;
HXDLIN(  41)											int _g1 = b->height;
HXDLIN(  41)											while((_g < _g1)){
HXLINE(  41)												_g = (_g + 1);
HXDLIN(  41)												int y1 = (_g - 1);
HXDLIN(  41)												{
HXLINE(  41)													int _g2 = 0;
HXDLIN(  41)													int _g3 = b->width;
HXDLIN(  41)													while((_g2 < _g3)){
HXLINE(  41)														_g2 = (_g2 + 1);
HXDLIN(  41)														int x1 = (_g2 - 1);
HXDLIN(  41)														{
HXLINE(  41)															w = (w + 1);
HXDLIN(  41)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  41)														{
HXLINE(  41)															w = (w + 1);
HXDLIN(  41)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  41)														{
HXLINE(  41)															w = (w + 1);
HXDLIN(  41)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  41)														{
HXLINE(  41)															w = (w + 1);
HXDLIN(  41)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  41)								undoImage1 = b;
            							}
            							break;
            							case (int)1: {
HXLINE(  41)								 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  41)								{
HXLINE(  41)									a->width = width;
HXDLIN(  41)									a->height = height;
HXDLIN(  41)									a->data = ::Array_obj< int >::__new(0);
HXDLIN(  41)									a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)									{
HXLINE(  41)										int _g4 = 0;
HXDLIN(  41)										int _g5 = a->length;
HXDLIN(  41)										while((_g4 < _g5)){
HXLINE(  41)											_g4 = (_g4 + 1);
HXDLIN(  41)											int i = (_g4 - 1);
HXDLIN(  41)											a->data[i] = 0;
            										}
            									}
            								}
HXDLIN(  41)								undoImage1 = a;
            							}
            							break;
            							case (int)2: {
HXLINE(  41)								 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  41)								{
HXLINE(  41)									b1->width = width;
HXDLIN(  41)									b1->height = height;
HXDLIN(  41)									b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)									int size = (b1->length * 4);
HXDLIN(  41)									b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  41)									{
HXLINE(  41)										int _g6 = 0;
HXDLIN(  41)										int _g7 = b1->length;
HXDLIN(  41)										while((_g6 < _g7)){
HXLINE(  41)											_g6 = (_g6 + 1);
HXDLIN(  41)											int i1 = (_g6 - 1);
HXDLIN(  41)											{
HXLINE(  41)												 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  41)												bool undoImage2;
HXDLIN(  41)												if ((i1 >= 0)) {
HXLINE(  41)													undoImage2 = (i1 < (this3->byteLength >> 2));
            												}
            												else {
HXLINE(  41)													undoImage2 = false;
            												}
HXDLIN(  41)												if (undoImage2) {
HXLINE(  41)													 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  41)													int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  41)													_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  41)													_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  41)													_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  41)													_this->b[(pos + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  41)								undoImage1 = b1;
            							}
            							break;
            							case (int)3: {
HXLINE(  41)								 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::VecIntImg v = vec;
HXDLIN(  41)								{
HXLINE(  41)									v->width = width;
HXDLIN(  41)									v->height = height;
HXDLIN(  41)									v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)									v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  41)									{
HXLINE(  41)										int _g8 = 0;
HXDLIN(  41)										int _g9 = v->length;
HXDLIN(  41)										while((_g8 < _g9)){
HXLINE(  41)											_g8 = (_g8 + 1);
HXDLIN(  41)											int i2 = (_g8 - 1);
HXDLIN(  41)											v->data->__unsafe_set(i2,0);
            										}
            									}
            								}
HXDLIN(  41)								undoImage1 = v;
            							}
            							break;
            							case (int)4: {
HXLINE(  41)								 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  41)								{
HXLINE(  41)									b2->width = width;
HXDLIN(  41)									b2->height = height;
HXDLIN(  41)									b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  41)									b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  41)									{
HXLINE(  41)										int len1 = b2->length;
HXDLIN(  41)										 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  41)										if (::hx::IsNull( d->head )) {
HXLINE(  41)											int _g10 = 0;
HXDLIN(  41)											int _g11 = len1;
HXDLIN(  41)											while((_g10 < _g11)){
HXLINE(  41)												_g10 = (_g10 + 1);
HXDLIN(  41)												int i3 = (_g10 - 1);
HXDLIN(  41)												d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            											}
            										}
            										else {
HXLINE(  41)											int _g12 = 0;
HXDLIN(  41)											int _g13 = len1;
HXDLIN(  41)											while((_g12 < _g13)){
HXLINE(  41)												_g12 = (_g12 + 1);
HXDLIN(  41)												int i4 = (_g12 - 1);
HXDLIN(  41)												{
HXLINE(  41)													 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  41)													 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  41)													{
HXLINE(  41)														int _g14 = 0;
HXDLIN(  41)														int _g15 = i4;
HXDLIN(  41)														while((_g14 < _g15)){
HXLINE(  41)															_g14 = (_g14 + 1);
HXDLIN(  41)															int i5 = (_g14 - 1);
HXLINE( 345)															prev = l;
HXLINE( 346)															l = l->next;
            														}
            													}
HXLINE(  41)													if (::hx::IsNull( prev )) {
HXLINE(  41)														b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  41)														l = null();
            													}
            													else {
HXLINE(  41)														prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  41)														l = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  41)								undoImage1 = b2;
            							}
            							break;
            						}
HXDLIN(  41)						this2->image = undoImage1;
HXDLIN(  41)						this2->width = width;
HXDLIN(  41)						this2->height = height;
HXDLIN(  41)						this2->imageType = ( (int)(imageType) );
HXDLIN(  41)						undoImage = this2;
HXDLIN(  41)						{
HXLINE(  41)							int rectLeft = xIter3->start;
HXDLIN(  41)							int rectTop = yIter3->start;
HXDLIN(  41)							int rectRight = xIter3->max;
HXDLIN(  41)							bool forceClear = false;
HXDLIN(  41)							{
HXLINE(  41)								int _g16 = rectTop;
HXDLIN(  41)								int _g17 = yIter3->max;
HXDLIN(  41)								while((_g16 < _g17)){
HXLINE(  41)									_g16 = (_g16 + 1);
HXDLIN(  41)									int dy = (_g16 - 1);
HXDLIN(  41)									{
HXLINE(  41)										int _g18 = rectLeft;
HXDLIN(  41)										int _g19 = rectRight;
HXDLIN(  41)										while((_g18 < _g19)){
HXLINE(  41)											_g18 = (_g18 + 1);
HXDLIN(  41)											int dx = (_g18 - 1);
HXDLIN(  41)											::Dynamic this4 = this1->image;
HXDLIN(  41)											int index;
HXDLIN(  41)											if (this1->useVirtualPos) {
HXLINE(  41)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            											}
            											else {
HXLINE(  41)												index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            											}
HXDLIN(  41)											int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  41)											int col;
HXDLIN(  41)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  41)												col = c;
            											}
HXDLIN(  41)											bool _hx_tmp;
HXDLIN(  41)											if (this1->useMask) {
HXLINE(  41)												_hx_tmp = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXLINE(  41)												_hx_tmp = false;
            											}
HXDLIN(  41)											if (_hx_tmp) {
HXLINE(  41)												 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  41)												::Dynamic this6 = this5->image;
HXDLIN(  41)												int index1;
HXDLIN(  41)												if (this5->useVirtualPos) {
HXLINE(  41)													index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            												}
            												else {
HXLINE(  41)													index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            												}
HXDLIN(  41)												int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  41)												int v1;
HXDLIN(  41)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)													v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            												}
            												else {
HXLINE(  41)													v1 = c1;
            												}
HXDLIN(  41)												int maskPixel = v1;
HXDLIN(  41)												int this7 = col;
HXDLIN(  41)												if ((maskPixel == 0)) {
HXLINE(  41)													col = this7;
            												}
            												else {
HXLINE(  41)													Float m0;
HXDLIN(  41)													int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  41)													if ((this8 == 0)) {
HXLINE(  41)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float m1;
HXDLIN(  41)													int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  41)													if ((this9 == 0)) {
HXLINE(  41)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float m2;
HXDLIN(  41)													int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  41)													if ((this10 == 0)) {
HXLINE(  41)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float m3;
HXDLIN(  41)													int this11 = (maskPixel & 255);
HXDLIN(  41)													if ((this11 == 0)) {
HXLINE(  41)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  41)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  41)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  41)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  41)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  41)											if ((col != 0)) {
HXLINE(  41)												int x2 = (dx - rectLeft);
HXDLIN(  41)												int y2 = (dy - rectTop);
HXDLIN(  41)												int c2 = col;
HXDLIN(  41)												bool _hx_tmp1;
HXDLIN(  41)												if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  41)													_hx_tmp1 = undoImage->transparent;
            												}
            												else {
HXLINE(  41)													_hx_tmp1 = false;
            												}
HXDLIN(  41)												if (_hx_tmp1) {
HXLINE(  41)													int location;
HXDLIN(  41)													if (undoImage->useVirtualPos) {
HXLINE(  41)														location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            													}
            													else {
HXLINE(  41)														location = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            													}
HXDLIN(  41)													int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  41)													int this13;
HXDLIN(  41)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)														this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            													}
            													else {
HXLINE(  41)														this13 = this12;
            													}
HXDLIN(  41)													Float a1;
HXDLIN(  41)													int this14 = ((this13 >> 24) & 255);
HXDLIN(  41)													if ((this14 == 0)) {
HXLINE(  41)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float r1;
HXDLIN(  41)													int this15 = ((this13 >> 16) & 255);
HXDLIN(  41)													if ((this15 == 0)) {
HXLINE(  41)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float g1;
HXDLIN(  41)													int this16 = ((this13 >> 8) & 255);
HXDLIN(  41)													if ((this16 == 0)) {
HXLINE(  41)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float b11;
HXDLIN(  41)													int this17 = (this13 & 255);
HXDLIN(  41)													if ((this17 == 0)) {
HXLINE(  41)														b11 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float a2;
HXDLIN(  41)													int this18 = ((col >> 24) & 255);
HXDLIN(  41)													if ((this18 == 0)) {
HXLINE(  41)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float r2;
HXDLIN(  41)													int this19 = ((col >> 16) & 255);
HXDLIN(  41)													if ((this19 == 0)) {
HXLINE(  41)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float g2;
HXDLIN(  41)													int this20 = ((col >> 8) & 255);
HXDLIN(  41)													if ((this20 == 0)) {
HXLINE(  41)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float b21;
HXDLIN(  41)													int this21 = (col & 255);
HXDLIN(  41)													if ((this21 == 0)) {
HXLINE(  41)														b21 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  41)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  41)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  41)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  41)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  41)													int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  41)													{
HXLINE(  41)														int _hx_tmp2;
HXDLIN(  41)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)															_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  41)															_hx_tmp2 = blended;
            														}
HXDLIN(  41)														::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            													}
            												}
            												else {
HXLINE(  41)													::Dynamic this22 = undoImage->image;
HXDLIN(  41)													int index2;
HXDLIN(  41)													if (undoImage->useVirtualPos) {
HXLINE(  41)														index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            													}
            													else {
HXLINE(  41)														index2 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            													}
HXDLIN(  41)													int _hx_tmp3;
HXDLIN(  41)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)														_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            													}
            													else {
HXLINE(  41)														_hx_tmp3 = c2;
            													}
HXDLIN(  41)													::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            												}
            											}
            											else {
HXLINE(  41)												if (forceClear) {
HXLINE(  41)													::Dynamic this23 = undoImage->image;
HXDLIN(  41)													int x3 = (dx - rectLeft);
HXDLIN(  41)													int y3 = (dy - rectTop);
HXDLIN(  41)													int index3;
HXDLIN(  41)													if (undoImage->useVirtualPos) {
HXLINE(  41)														index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            													}
            													else {
HXLINE(  41)														index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            													}
HXDLIN(  41)													::iterMagic::Iimg_obj::set(this23,index3,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  41)					{
HXLINE(  41)						int _g_min = xIter3->start;
HXDLIN(  41)						int _g_max = xIter3->max;
HXDLIN(  41)						while((_g_min < _g_max)){
HXLINE(  41)							_g_min = (_g_min + 1);
HXDLIN(  41)							int px = (_g_min - 1);
HXDLIN(  41)							Float pcx = (( (Float)(px) ) - x);
HXDLIN(  41)							{
HXLINE(  41)								int _g_min1 = yIter3->start;
HXDLIN(  41)								int _g_max1 = yIter3->max;
HXDLIN(  41)								while((_g_min1 < _g_max1)){
HXLINE(  41)									_g_min1 = (_g_min1 + 1);
HXDLIN(  41)									int py = (_g_min1 - 1);
HXDLIN(  41)									Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  41)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  41)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  41)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  41)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  41)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  41)									bool _hx_tmp4;
HXDLIN(  41)									bool _hx_tmp5;
HXDLIN(  41)									if ((ratioA >= 0)) {
HXLINE(  41)										_hx_tmp5 = (ratioB >= 0);
            									}
            									else {
HXLINE(  41)										_hx_tmp5 = false;
            									}
HXDLIN(  41)									if (_hx_tmp5) {
HXLINE(  41)										_hx_tmp4 = (ratioC >= 0);
            									}
            									else {
HXLINE(  41)										_hx_tmp4 = false;
            									}
HXDLIN(  41)									if (_hx_tmp4) {
HXLINE(  41)										int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  41)										if ((i6 > 255)) {
HXLINE(  24)											i6 = 255;
            										}
HXLINE(  41)										if ((i6 < 0)) {
HXLINE(  25)											i6 = 0;
            										}
HXLINE(  41)										int a5 = i6;
HXDLIN(  41)										int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  41)										if ((i7 > 255)) {
HXLINE(  24)											i7 = 255;
            										}
HXLINE(  41)										if ((i7 < 0)) {
HXLINE(  25)											i7 = 0;
            										}
HXLINE(  41)										int r3 = i7;
HXDLIN(  41)										int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  41)										if ((i8 > 255)) {
HXLINE(  24)											i8 = 255;
            										}
HXLINE(  41)										if ((i8 < 0)) {
HXLINE(  25)											i8 = 0;
            										}
HXLINE(  41)										int g3 = i8;
HXDLIN(  41)										int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  41)										if ((i9 > 255)) {
HXLINE(  24)											i9 = 255;
            										}
HXLINE(  41)										if ((i9 < 0)) {
HXLINE(  25)											i9 = 0;
            										}
HXLINE(  41)										int b4 = i9;
HXDLIN(  41)										{
HXLINE(  41)											int location1;
HXDLIN(  41)											if (this1->useVirtualPos) {
HXLINE(  41)												location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            											}
            											else {
HXLINE(  41)												location1 = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            											}
HXDLIN(  41)											bool _hx_tmp6;
HXDLIN(  41)											if (this1->transparent) {
HXLINE(  41)												_hx_tmp6 = (a5 < 254);
            											}
            											else {
HXLINE(  41)												_hx_tmp6 = false;
            											}
HXDLIN(  41)											if (_hx_tmp6) {
HXLINE(  41)												int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  41)												int old;
HXDLIN(  41)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)													old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXLINE(  41)													old = this24;
            												}
HXDLIN(  41)												int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  41)												Float a11;
HXDLIN(  41)												int this25 = ((old >> 24) & 255);
HXDLIN(  41)												if ((this25 == 0)) {
HXLINE(  41)													a11 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float r11;
HXDLIN(  41)												int this26 = ((old >> 16) & 255);
HXDLIN(  41)												if ((this26 == 0)) {
HXLINE(  41)													r11 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float g11;
HXDLIN(  41)												int this27 = ((old >> 8) & 255);
HXDLIN(  41)												if ((this27 == 0)) {
HXLINE(  41)													g11 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float b12;
HXDLIN(  41)												int this28 = (old & 255);
HXDLIN(  41)												if ((this28 == 0)) {
HXLINE(  41)													b12 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float a21;
HXDLIN(  41)												int this29 = ((rhs >> 24) & 255);
HXDLIN(  41)												if ((this29 == 0)) {
HXLINE(  41)													a21 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float r21;
HXDLIN(  41)												int this30 = ((rhs >> 16) & 255);
HXDLIN(  41)												if ((this30 == 0)) {
HXLINE(  41)													r21 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float g21;
HXDLIN(  41)												int this31 = ((rhs >> 8) & 255);
HXDLIN(  41)												if ((this31 == 0)) {
HXLINE(  41)													g21 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float b22;
HXDLIN(  41)												int this32 = (rhs & 255);
HXDLIN(  41)												if ((this32 == 0)) {
HXLINE(  41)													b22 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  41)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  41)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  41)												int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  41)												int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  41)												int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  41)												{
HXLINE(  41)													int _hx_tmp7;
HXDLIN(  41)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)														_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE(  41)														_hx_tmp7 = blended1;
            													}
HXDLIN(  41)													::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            												}
            											}
            											else {
HXLINE(  41)												int value;
HXDLIN(  41)												if (this1->isLittle) {
HXLINE(  41)													value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            												}
            												else {
HXLINE(  41)													value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            												}
HXDLIN(  41)												::iterMagic::Iimg_obj::set(this1->image,location1,value);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  41)					if ((hasHit == false)) {
HXLINE(  41)						 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x,y,bx,y,x,cy,true);
HXDLIN(  41)						if (hasUndo) {
HXLINE(  41)							v2->undoImage = undoImage;
HXDLIN(  41)							v2->undoX = xIter3->start;
HXDLIN(  41)							v2->undoY = yIter3->start;
            						}
            					}
            				}
HXDLIN(  41)				{
HXLINE(  41)					bool hasHit1 = false;
HXDLIN(  41)					bool hasUndo1 = false;
HXDLIN(  41)					int aA1 = ((colorC >> 24) & 255);
HXDLIN(  41)					int rA1 = ((colorC >> 16) & 255);
HXDLIN(  41)					int gA1 = ((colorC >> 8) & 255);
HXDLIN(  41)					int bA1 = (colorC & 255);
HXDLIN(  41)					int aB1 = ((colorB >> 24) & 255);
HXDLIN(  41)					int rB1 = ((colorB >> 16) & 255);
HXDLIN(  41)					int gB1 = ((colorB >> 8) & 255);
HXDLIN(  41)					int bB1 = (colorB & 255);
HXDLIN(  41)					int aC1 = ((colorD >> 24) & 255);
HXDLIN(  41)					int rC1 = ((colorD >> 16) & 255);
HXDLIN(  41)					int gC1 = ((colorD >> 8) & 255);
HXDLIN(  41)					int bC1 = (colorD & 255);
HXDLIN(  41)					Float bcx1 = (bx - x);
HXDLIN(  41)					Float bcy1 = (cy - cy);
HXDLIN(  41)					Float acx1 = (bx - x);
HXDLIN(  41)					Float acy1 = (y - cy);
HXDLIN(  41)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  41)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  41)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  41)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  41)					 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  41)					if ((bx > bx)) {
HXLINE(  41)						if ((bx > x)) {
HXLINE(  41)							int min4;
HXDLIN(  41)							if ((bx > x)) {
HXLINE(  41)								min4 = ::Math_obj::floor(x);
            							}
            							else {
HXLINE(  41)								min4 = ::Math_obj::floor(bx);
            							}
HXDLIN(  41)							int ii_min8 = min4;
HXDLIN(  41)							int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN(  41)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            						}
            						else {
HXLINE(  41)							int ii_min9 = ::Math_obj::floor(bx);
HXDLIN(  41)							int ii_max9 = ::Math_obj::ceil(x);
HXDLIN(  41)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            						}
            					}
            					else {
HXLINE(  41)						if ((bx > x)) {
HXLINE(  41)							int min5;
HXDLIN(  41)							if ((bx > x)) {
HXLINE(  41)								min5 = ::Math_obj::floor(x);
            							}
            							else {
HXLINE(  41)								min5 = ::Math_obj::ceil(bx);
            							}
HXDLIN(  41)							int ii_min10 = min5;
HXDLIN(  41)							int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN(  41)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXLINE(  41)							int ii_min11 = ::Math_obj::floor(bx);
HXDLIN(  41)							int ii_max11 = ::Math_obj::ceil(x);
HXDLIN(  41)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
HXDLIN(  41)					 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  41)					if ((y > cy)) {
HXLINE(  41)						if ((y > cy)) {
HXLINE(  41)							int min6;
HXDLIN(  41)							if ((cy > cy)) {
HXLINE(  41)								min6 = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  41)								min6 = ::Math_obj::floor(cy);
            							}
HXDLIN(  41)							int ii_min12 = min6;
HXDLIN(  41)							int ii_max12 = ::Math_obj::ceil(y);
HXDLIN(  41)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXLINE(  41)							int ii_min13 = ::Math_obj::floor(cy);
HXDLIN(  41)							int ii_max13 = ::Math_obj::ceil(cy);
HXDLIN(  41)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
            					else {
HXLINE(  41)						if ((cy > cy)) {
HXLINE(  41)							int min7;
HXDLIN(  41)							if ((y > cy)) {
HXLINE(  41)								min7 = ::Math_obj::floor(cy);
            							}
            							else {
HXLINE(  41)								min7 = ::Math_obj::ceil(y);
            							}
HXDLIN(  41)							int ii_min14 = min7;
HXDLIN(  41)							int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN(  41)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXLINE(  41)							int ii_min15 = ::Math_obj::floor(y);
HXDLIN(  41)							int ii_max15 = ::Math_obj::ceil(cy);
HXDLIN(  41)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
HXDLIN(  41)					 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  41)					if (hasUndo1) {
HXLINE(  41)						int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  41)						int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  41)						 ::Dynamic imageType1 = null();
HXDLIN(  41)						 ::pi_xy::ImageStruct this33 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  41)						if (::hx::IsNull( imageType1 )) {
HXLINE(  54)							imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  41)						::Dynamic undoImage4;
HXDLIN(  41)						switch((int)(( (int)(imageType1) ))){
            							case (int)0: {
HXLINE(  41)								 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::BytesImg b6 = byt1;
HXDLIN(  41)								{
HXLINE(  41)									b6->width = width1;
HXDLIN(  41)									b6->height = height1;
HXDLIN(  41)									b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  41)									b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  41)									{
HXLINE(  41)										int len2 = b6->length;
HXDLIN(  41)										int w1 = 0;
HXDLIN(  41)										{
HXLINE(  41)											int _g20 = 0;
HXDLIN(  41)											int _g21 = b6->height;
HXDLIN(  41)											while((_g20 < _g21)){
HXLINE(  41)												_g20 = (_g20 + 1);
HXDLIN(  41)												int y4 = (_g20 - 1);
HXDLIN(  41)												{
HXLINE(  41)													int _g22 = 0;
HXDLIN(  41)													int _g23 = b6->width;
HXDLIN(  41)													while((_g22 < _g23)){
HXLINE(  41)														_g22 = (_g22 + 1);
HXDLIN(  41)														int x4 = (_g22 - 1);
HXDLIN(  41)														{
HXLINE(  41)															w1 = (w1 + 1);
HXDLIN(  41)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  41)														{
HXLINE(  41)															w1 = (w1 + 1);
HXDLIN(  41)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  41)														{
HXLINE(  41)															w1 = (w1 + 1);
HXDLIN(  41)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  41)														{
HXLINE(  41)															w1 = (w1 + 1);
HXDLIN(  41)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  41)								undoImage4 = b6;
            							}
            							break;
            							case (int)1: {
HXLINE(  41)								 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN(  41)								{
HXLINE(  41)									a7->width = width1;
HXDLIN(  41)									a7->height = height1;
HXDLIN(  41)									a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  41)									a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  41)									{
HXLINE(  41)										int _g24 = 0;
HXDLIN(  41)										int _g25 = a7->length;
HXDLIN(  41)										while((_g24 < _g25)){
HXLINE(  41)											_g24 = (_g24 + 1);
HXDLIN(  41)											int i10 = (_g24 - 1);
HXDLIN(  41)											a7->data[i10] = 0;
            										}
            									}
            								}
HXDLIN(  41)								undoImage4 = a7;
            							}
            							break;
            							case (int)2: {
HXLINE(  41)								 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN(  41)								{
HXLINE(  41)									b7->width = width1;
HXDLIN(  41)									b7->height = height1;
HXDLIN(  41)									b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  41)									int size1 = (b7->length * 4);
HXDLIN(  41)									b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  41)									{
HXLINE(  41)										int _g26 = 0;
HXDLIN(  41)										int _g27 = b7->length;
HXDLIN(  41)										while((_g26 < _g27)){
HXLINE(  41)											_g26 = (_g26 + 1);
HXDLIN(  41)											int i11 = (_g26 - 1);
HXDLIN(  41)											{
HXLINE(  41)												 ::haxe::io::ArrayBufferViewImpl this34 = b7->data;
HXDLIN(  41)												bool undoImage5;
HXDLIN(  41)												if ((i11 >= 0)) {
HXLINE(  41)													undoImage5 = (i11 < (this34->byteLength >> 2));
            												}
            												else {
HXLINE(  41)													undoImage5 = false;
            												}
HXDLIN(  41)												if (undoImage5) {
HXLINE(  41)													 ::haxe::io::Bytes _this1 = this34->bytes;
HXDLIN(  41)													int pos1 = ((i11 << 2) + this34->byteOffset);
HXDLIN(  41)													_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  41)													_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  41)													_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  41)													_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  41)								undoImage4 = b7;
            							}
            							break;
            							case (int)3: {
HXLINE(  41)								 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  41)								{
HXLINE(  41)									v3->width = width1;
HXDLIN(  41)									v3->height = height1;
HXDLIN(  41)									v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  41)									v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  41)									{
HXLINE(  41)										int _g28 = 0;
HXDLIN(  41)										int _g29 = v3->length;
HXDLIN(  41)										while((_g28 < _g29)){
HXLINE(  41)											_g28 = (_g28 + 1);
HXDLIN(  41)											int i12 = (_g28 - 1);
HXDLIN(  41)											v3->data->__unsafe_set(i12,0);
            										}
            									}
            								}
HXDLIN(  41)								undoImage4 = v3;
            							}
            							break;
            							case (int)4: {
HXLINE(  41)								 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)								 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN(  41)								{
HXLINE(  41)									b8->width = width1;
HXDLIN(  41)									b8->height = height1;
HXDLIN(  41)									b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  41)									b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  41)									{
HXLINE(  41)										int len3 = b8->length;
HXDLIN(  41)										 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN(  41)										if (::hx::IsNull( d1->head )) {
HXLINE(  41)											int _g30 = 0;
HXDLIN(  41)											int _g31 = len3;
HXDLIN(  41)											while((_g30 < _g31)){
HXLINE(  41)												_g30 = (_g30 + 1);
HXDLIN(  41)												int i13 = (_g30 - 1);
HXDLIN(  41)												d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            											}
            										}
            										else {
HXLINE(  41)											int _g32 = 0;
HXDLIN(  41)											int _g33 = len3;
HXDLIN(  41)											while((_g32 < _g33)){
HXLINE(  41)												_g32 = (_g32 + 1);
HXDLIN(  41)												int i14 = (_g32 - 1);
HXDLIN(  41)												{
HXLINE(  41)													 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN(  41)													 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  41)													{
HXLINE(  41)														int _g34 = 0;
HXDLIN(  41)														int _g35 = i14;
HXDLIN(  41)														while((_g34 < _g35)){
HXLINE(  41)															_g34 = (_g34 + 1);
HXDLIN(  41)															int i15 = (_g34 - 1);
HXLINE( 345)															prev1 = l1;
HXLINE( 346)															l1 = l1->next;
            														}
            													}
HXLINE(  41)													if (::hx::IsNull( prev1 )) {
HXLINE(  41)														b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  41)														l1 = null();
            													}
            													else {
HXLINE(  41)														prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  41)														l1 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  41)								undoImage4 = b8;
            							}
            							break;
            						}
HXDLIN(  41)						this33->image = undoImage4;
HXDLIN(  41)						this33->width = width1;
HXDLIN(  41)						this33->height = height1;
HXDLIN(  41)						this33->imageType = ( (int)(imageType1) );
HXDLIN(  41)						undoImage3 = this33;
HXDLIN(  41)						{
HXLINE(  41)							int rectLeft1 = xIter31->start;
HXDLIN(  41)							int rectTop1 = yIter31->start;
HXDLIN(  41)							int rectRight1 = xIter31->max;
HXDLIN(  41)							bool forceClear1 = false;
HXDLIN(  41)							{
HXLINE(  41)								int _g36 = rectTop1;
HXDLIN(  41)								int _g37 = yIter31->max;
HXDLIN(  41)								while((_g36 < _g37)){
HXLINE(  41)									_g36 = (_g36 + 1);
HXDLIN(  41)									int dy1 = (_g36 - 1);
HXDLIN(  41)									{
HXLINE(  41)										int _g38 = rectLeft1;
HXDLIN(  41)										int _g39 = rectRight1;
HXDLIN(  41)										while((_g38 < _g39)){
HXLINE(  41)											_g38 = (_g38 + 1);
HXDLIN(  41)											int dx1 = (_g38 - 1);
HXDLIN(  41)											::Dynamic this35 = this1->image;
HXDLIN(  41)											int index4;
HXDLIN(  41)											if (this1->useVirtualPos) {
HXLINE(  41)												index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            											}
            											else {
HXLINE(  41)												index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            											}
HXDLIN(  41)											int c3 = ::iterMagic::Iimg_obj::get(this35,index4);
HXDLIN(  41)											int col1;
HXDLIN(  41)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)												col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            											}
            											else {
HXLINE(  41)												col1 = c3;
            											}
HXDLIN(  41)											bool _hx_tmp8;
HXDLIN(  41)											if (this1->useMask) {
HXLINE(  41)												_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXLINE(  41)												_hx_tmp8 = false;
            											}
HXDLIN(  41)											if (_hx_tmp8) {
HXLINE(  41)												 ::pi_xy::ImageStruct this36 = this1->mask;
HXDLIN(  41)												::Dynamic this37 = this36->image;
HXDLIN(  41)												int index5;
HXDLIN(  41)												if (this36->useVirtualPos) {
HXLINE(  41)													index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            												}
            												else {
HXLINE(  41)													index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            												}
HXDLIN(  41)												int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN(  41)												int v4;
HXDLIN(  41)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)													v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE(  41)													v4 = c4;
            												}
HXDLIN(  41)												int maskPixel1 = v4;
HXDLIN(  41)												int this38 = col1;
HXDLIN(  41)												if ((maskPixel1 == 0)) {
HXLINE(  41)													col1 = this38;
            												}
            												else {
HXLINE(  41)													Float m01;
HXDLIN(  41)													int this39 = ((maskPixel1 >> 24) & 255);
HXDLIN(  41)													if ((this39 == 0)) {
HXLINE(  41)														m01 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														m01 = (( (Float)(this39) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float m11;
HXDLIN(  41)													int this40 = ((maskPixel1 >> 16) & 255);
HXDLIN(  41)													if ((this40 == 0)) {
HXLINE(  41)														m11 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														m11 = (( (Float)(this40) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float m21;
HXDLIN(  41)													int this41 = ((maskPixel1 >> 8) & 255);
HXDLIN(  41)													if ((this41 == 0)) {
HXLINE(  41)														m21 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														m21 = (( (Float)(this41) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float m31;
HXDLIN(  41)													int this42 = (maskPixel1 & 255);
HXDLIN(  41)													if ((this42 == 0)) {
HXLINE(  41)														m31 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														m31 = (( (Float)(this42) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this38 >> 24) & 255)) )));
HXDLIN(  41)													int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this38 >> 16) & 255)) )));
HXDLIN(  41)													int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this38 >> 8) & 255)) )));
HXDLIN(  41)													int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this38 & 255)) )));
HXDLIN(  41)													col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  41)											if ((col1 != 0)) {
HXLINE(  41)												int x5 = (dx1 - rectLeft1);
HXDLIN(  41)												int y5 = (dy1 - rectTop1);
HXDLIN(  41)												int c5 = col1;
HXDLIN(  41)												bool _hx_tmp9;
HXDLIN(  41)												if ((((c5 >> 24) & 255) < 254)) {
HXLINE(  41)													_hx_tmp9 = undoImage3->transparent;
            												}
            												else {
HXLINE(  41)													_hx_tmp9 = false;
            												}
HXDLIN(  41)												if (_hx_tmp9) {
HXLINE(  41)													int location2;
HXDLIN(  41)													if (undoImage3->useVirtualPos) {
HXLINE(  41)														location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  41)														location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            													}
HXDLIN(  41)													int this43 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  41)													int this44;
HXDLIN(  41)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)														this44 = ((((((this43 >> 24) & 255) << 24) | ((this43 & 255) << 16)) | (((this43 >> 8) & 255) << 8)) | ((this43 >> 16) & 255));
            													}
            													else {
HXLINE(  41)														this44 = this43;
            													}
HXDLIN(  41)													Float a12;
HXDLIN(  41)													int this45 = ((this44 >> 24) & 255);
HXDLIN(  41)													if ((this45 == 0)) {
HXLINE(  41)														a12 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														a12 = (( (Float)(this45) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float r12;
HXDLIN(  41)													int this46 = ((this44 >> 16) & 255);
HXDLIN(  41)													if ((this46 == 0)) {
HXLINE(  41)														r12 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														r12 = (( (Float)(this46) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float g12;
HXDLIN(  41)													int this47 = ((this44 >> 8) & 255);
HXDLIN(  41)													if ((this47 == 0)) {
HXLINE(  41)														g12 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														g12 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float b13;
HXDLIN(  41)													int this48 = (this44 & 255);
HXDLIN(  41)													if ((this48 == 0)) {
HXLINE(  41)														b13 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														b13 = (( (Float)(this48) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float a22;
HXDLIN(  41)													int this49 = ((col1 >> 24) & 255);
HXDLIN(  41)													if ((this49 == 0)) {
HXLINE(  41)														a22 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														a22 = (( (Float)(this49) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float r22;
HXDLIN(  41)													int this50 = ((col1 >> 16) & 255);
HXDLIN(  41)													if ((this50 == 0)) {
HXLINE(  41)														r22 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														r22 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float g22;
HXDLIN(  41)													int this51 = ((col1 >> 8) & 255);
HXDLIN(  41)													if ((this51 == 0)) {
HXLINE(  41)														g22 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														g22 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float b23;
HXDLIN(  41)													int this52 = (col1 & 255);
HXDLIN(  41)													if ((this52 == 0)) {
HXLINE(  41)														b23 = ((Float)0.);
            													}
            													else {
HXLINE(  41)														b23 = (( (Float)(this52) ) / ( (Float)(255) ));
            													}
HXDLIN(  41)													Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  41)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  41)													int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  41)													int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  41)													int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  41)													int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  41)													{
HXLINE(  41)														int _hx_tmp10;
HXDLIN(  41)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)															_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXLINE(  41)															_hx_tmp10 = blended2;
            														}
HXDLIN(  41)														::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            													}
            												}
            												else {
HXLINE(  41)													::Dynamic this53 = undoImage3->image;
HXDLIN(  41)													int index6;
HXDLIN(  41)													if (undoImage3->useVirtualPos) {
HXLINE(  41)														index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  41)														index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            													}
HXDLIN(  41)													int _hx_tmp11;
HXDLIN(  41)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)														_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXLINE(  41)														_hx_tmp11 = c5;
            													}
HXDLIN(  41)													::iterMagic::Iimg_obj::set(this53,index6,_hx_tmp11);
            												}
            											}
            											else {
HXLINE(  41)												if (forceClear1) {
HXLINE(  41)													::Dynamic this54 = undoImage3->image;
HXDLIN(  41)													int x6 = (dx1 - rectLeft1);
HXDLIN(  41)													int y6 = (dy1 - rectTop1);
HXDLIN(  41)													int index7;
HXDLIN(  41)													if (undoImage3->useVirtualPos) {
HXLINE(  41)														index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  41)														index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            													}
HXDLIN(  41)													::iterMagic::Iimg_obj::set(this54,index7,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  41)					{
HXLINE(  41)						int _g_min2 = xIter31->start;
HXDLIN(  41)						int _g_max2 = xIter31->max;
HXDLIN(  41)						while((_g_min2 < _g_max2)){
HXLINE(  41)							_g_min2 = (_g_min2 + 1);
HXDLIN(  41)							int px1 = (_g_min2 - 1);
HXDLIN(  41)							Float pcx1 = (( (Float)(px1) ) - x);
HXDLIN(  41)							{
HXLINE(  41)								int _g_min3 = yIter31->start;
HXDLIN(  41)								int _g_max3 = yIter31->max;
HXDLIN(  41)								while((_g_min3 < _g_max3)){
HXLINE(  41)									_g_min3 = (_g_min3 + 1);
HXDLIN(  41)									int py1 = (_g_min3 - 1);
HXDLIN(  41)									Float pcy1 = (( (Float)(py1) ) - cy);
HXDLIN(  41)									Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  41)									Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  41)									Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  41)									Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  41)									Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  41)									bool _hx_tmp12;
HXDLIN(  41)									bool _hx_tmp13;
HXDLIN(  41)									if ((ratioA1 >= 0)) {
HXLINE(  41)										_hx_tmp13 = (ratioB1 >= 0);
            									}
            									else {
HXLINE(  41)										_hx_tmp13 = false;
            									}
HXDLIN(  41)									if (_hx_tmp13) {
HXLINE(  41)										_hx_tmp12 = (ratioC1 >= 0);
            									}
            									else {
HXLINE(  41)										_hx_tmp12 = false;
            									}
HXDLIN(  41)									if (_hx_tmp12) {
HXLINE(  41)										int i16 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN(  41)										if ((i16 > 255)) {
HXLINE(  24)											i16 = 255;
            										}
HXLINE(  41)										if ((i16 < 0)) {
HXLINE(  25)											i16 = 0;
            										}
HXLINE(  41)										int a9 = i16;
HXDLIN(  41)										int i17 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN(  41)										if ((i17 > 255)) {
HXLINE(  24)											i17 = 255;
            										}
HXLINE(  41)										if ((i17 < 0)) {
HXLINE(  25)											i17 = 0;
            										}
HXLINE(  41)										int r6 = i17;
HXDLIN(  41)										int i18 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN(  41)										if ((i18 > 255)) {
HXLINE(  24)											i18 = 255;
            										}
HXLINE(  41)										if ((i18 < 0)) {
HXLINE(  25)											i18 = 0;
            										}
HXLINE(  41)										int g6 = i18;
HXDLIN(  41)										int i19 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN(  41)										if ((i19 > 255)) {
HXLINE(  24)											i19 = 255;
            										}
HXLINE(  41)										if ((i19 < 0)) {
HXLINE(  25)											i19 = 0;
            										}
HXLINE(  41)										int b10 = i19;
HXDLIN(  41)										{
HXLINE(  41)											int location3;
HXDLIN(  41)											if (this1->useVirtualPos) {
HXLINE(  41)												location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this1->virtualY) * ( (Float)(this1->width) )) + px1) - this1->virtualX));
            											}
            											else {
HXLINE(  41)												location3 = ::Std_obj::_hx_int(( (Float)(((py1 * this1->width) + px1)) ));
            											}
HXDLIN(  41)											bool _hx_tmp14;
HXDLIN(  41)											if (this1->transparent) {
HXLINE(  41)												_hx_tmp14 = (a9 < 254);
            											}
            											else {
HXLINE(  41)												_hx_tmp14 = false;
            											}
HXDLIN(  41)											if (_hx_tmp14) {
HXLINE(  41)												int this55 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  41)												int old1;
HXDLIN(  41)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)													old1 = ((((((this55 >> 24) & 255) << 24) | ((this55 & 255) << 16)) | (((this55 >> 8) & 255) << 8)) | ((this55 >> 16) & 255));
            												}
            												else {
HXLINE(  41)													old1 = this55;
            												}
HXDLIN(  41)												int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN(  41)												Float a13;
HXDLIN(  41)												int this56 = ((old1 >> 24) & 255);
HXDLIN(  41)												if ((this56 == 0)) {
HXLINE(  41)													a13 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													a13 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float r13;
HXDLIN(  41)												int this57 = ((old1 >> 16) & 255);
HXDLIN(  41)												if ((this57 == 0)) {
HXLINE(  41)													r13 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float g13;
HXDLIN(  41)												int this58 = ((old1 >> 8) & 255);
HXDLIN(  41)												if ((this58 == 0)) {
HXLINE(  41)													g13 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float b14;
HXDLIN(  41)												int this59 = (old1 & 255);
HXDLIN(  41)												if ((this59 == 0)) {
HXLINE(  41)													b14 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float a23;
HXDLIN(  41)												int this60 = ((rhs1 >> 24) & 255);
HXDLIN(  41)												if ((this60 == 0)) {
HXLINE(  41)													a23 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float r23;
HXDLIN(  41)												int this61 = ((rhs1 >> 16) & 255);
HXDLIN(  41)												if ((this61 == 0)) {
HXLINE(  41)													r23 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float g23;
HXDLIN(  41)												int this62 = ((rhs1 >> 8) & 255);
HXDLIN(  41)												if ((this62 == 0)) {
HXLINE(  41)													g23 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float b24;
HXDLIN(  41)												int this63 = (rhs1 & 255);
HXDLIN(  41)												if ((this63 == 0)) {
HXLINE(  41)													b24 = ((Float)0.);
            												}
            												else {
HXLINE(  41)													b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  41)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  41)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  41)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  41)												int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  41)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  41)												int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN(  41)												{
HXLINE(  41)													int _hx_tmp15;
HXDLIN(  41)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)														_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE(  41)														_hx_tmp15 = blended3;
            													}
HXDLIN(  41)													::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp15);
            												}
            											}
            											else {
HXLINE(  41)												int value1;
HXDLIN(  41)												if (this1->isLittle) {
HXLINE(  41)													value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            												}
            												else {
HXLINE(  41)													value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            												}
HXDLIN(  41)												::iterMagic::Iimg_obj::set(this1->image,location3,value1);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  41)					if ((hasHit1 == false)) {
HXLINE(  41)						 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,y,bx,cy,x,cy,true);
HXDLIN(  41)						if (hasUndo1) {
HXLINE(  41)							v5->undoImage = undoImage3;
HXDLIN(  41)							v5->undoX = xIter31->start;
HXDLIN(  41)							v5->undoY = yIter31->start;
            						}
            					}
            				}
HXDLIN(  41)				if ((hasHit == true)) {
HXLINE(  41)					 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x,y,bx,y,bx,cy,x,cy,true);
            				}
            			}
            		}
HXLINE(  45)		return  ::Dynamic(::hx::Anon_obj::Create(8)
            			->setFixed(0,HX_("x",78,00,00,00),x)
            			->setFixed(1,HX_("y",79,00,00,00),y)
            			->setFixed(2,HX_("ax",f7,54,00,00),x)
            			->setFixed(3,HX_("ay",f8,54,00,00),y)
            			->setFixed(4,HX_("bx",d6,55,00,00),bx)
            			->setFixed(5,HX_("cx",b5,56,00,00),bx)
            			->setFixed(6,HX_("cy",b6,56,00,00),cy)
            			->setFixed(7,HX_("dy",95,57,00,00),cy));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(GradientShape_Impl__obj,rectangle,return )

 ::pi_xy::algo::HitQuad GradientShape_Impl__obj::quad( ::pi_xy::ImageStruct this1,Float ax,Float ay,int colorA,Float bx,Float by,int colorB,Float cx,Float cy,int colorC,Float dx,Float dy,int colorD,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_62_quad)
HXDLIN(  62)		{
HXDLIN(  62)			bool hasUndo = false;
HXDLIN(  62)			int aA = ((colorB >> 24) & 255);
HXDLIN(  62)			int rA = ((colorB >> 16) & 255);
HXDLIN(  62)			int gA = ((colorB >> 8) & 255);
HXDLIN(  62)			int bA = (colorB & 255);
HXDLIN(  62)			int aB = ((colorA >> 24) & 255);
HXDLIN(  62)			int rB = ((colorA >> 16) & 255);
HXDLIN(  62)			int gB = ((colorA >> 8) & 255);
HXDLIN(  62)			int bB = (colorA & 255);
HXDLIN(  62)			int aC = ((colorD >> 24) & 255);
HXDLIN(  62)			int rC = ((colorD >> 16) & 255);
HXDLIN(  62)			int gC = ((colorD >> 8) & 255);
HXDLIN(  62)			int bC = (colorD & 255);
HXDLIN(  62)			Float bcx = (bx - dx);
HXDLIN(  62)			Float bcy = (by - dy);
HXDLIN(  62)			Float acx = (ax - dx);
HXDLIN(  62)			Float acy = (ay - dy);
HXDLIN(  62)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  62)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  62)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  62)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  62)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  62)			if ((ax > bx)) {
HXDLIN(  62)				if ((ax > dx)) {
HXDLIN(  62)					int min;
HXDLIN(  62)					if ((bx > dx)) {
HXDLIN(  62)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN(  62)						min = ::Math_obj::floor(bx);
            					}
HXDLIN(  62)					int ii_min = min;
HXDLIN(  62)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  62)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXDLIN(  62)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  62)					int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN(  62)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXDLIN(  62)				if ((bx > dx)) {
HXDLIN(  62)					int min1;
HXDLIN(  62)					if ((ax > dx)) {
HXDLIN(  62)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN(  62)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN(  62)					int ii_min2 = min1;
HXDLIN(  62)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  62)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXDLIN(  62)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  62)					int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN(  62)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN(  62)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  62)			if ((ay > by)) {
HXDLIN(  62)				if ((ay > dy)) {
HXDLIN(  62)					int min2;
HXDLIN(  62)					if ((by > dy)) {
HXDLIN(  62)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN(  62)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN(  62)					int ii_min4 = min2;
HXDLIN(  62)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  62)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXDLIN(  62)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  62)					int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN(  62)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXDLIN(  62)				if ((by > dy)) {
HXDLIN(  62)					int min3;
HXDLIN(  62)					if ((ay > dy)) {
HXDLIN(  62)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN(  62)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN(  62)					int ii_min6 = min3;
HXDLIN(  62)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  62)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXDLIN(  62)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  62)					int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN(  62)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN(  62)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  62)			if (hasUndo) {
HXDLIN(  62)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  62)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  62)				 ::Dynamic imageType = null();
HXDLIN(  62)				 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  62)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  62)				::Dynamic undoImage1;
HXDLIN(  62)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXDLIN(  62)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::BytesImg b = byt;
HXDLIN(  62)						{
HXDLIN(  62)							b->width = width;
HXDLIN(  62)							b->height = height;
HXDLIN(  62)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  62)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  62)							{
HXDLIN(  62)								int len = b->length;
HXDLIN(  62)								int w = 0;
HXDLIN(  62)								{
HXDLIN(  62)									int _g = 0;
HXDLIN(  62)									int _g1 = b->height;
HXDLIN(  62)									while((_g < _g1)){
HXDLIN(  62)										_g = (_g + 1);
HXDLIN(  62)										int y = (_g - 1);
HXDLIN(  62)										{
HXDLIN(  62)											int _g2 = 0;
HXDLIN(  62)											int _g3 = b->width;
HXDLIN(  62)											while((_g2 < _g3)){
HXDLIN(  62)												_g2 = (_g2 + 1);
HXDLIN(  62)												int x = (_g2 - 1);
HXDLIN(  62)												{
HXDLIN(  62)													w = (w + 1);
HXDLIN(  62)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  62)												{
HXDLIN(  62)													w = (w + 1);
HXDLIN(  62)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  62)												{
HXDLIN(  62)													w = (w + 1);
HXDLIN(  62)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  62)												{
HXDLIN(  62)													w = (w + 1);
HXDLIN(  62)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  62)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXDLIN(  62)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  62)						{
HXDLIN(  62)							a->width = width;
HXDLIN(  62)							a->height = height;
HXDLIN(  62)							a->data = ::Array_obj< int >::__new(0);
HXDLIN(  62)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  62)							{
HXDLIN(  62)								int _g4 = 0;
HXDLIN(  62)								int _g5 = a->length;
HXDLIN(  62)								while((_g4 < _g5)){
HXDLIN(  62)									_g4 = (_g4 + 1);
HXDLIN(  62)									int i = (_g4 - 1);
HXDLIN(  62)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN(  62)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXDLIN(  62)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  62)						{
HXDLIN(  62)							b1->width = width;
HXDLIN(  62)							b1->height = height;
HXDLIN(  62)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  62)							int size = (b1->length * 4);
HXDLIN(  62)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  62)							{
HXDLIN(  62)								int _g6 = 0;
HXDLIN(  62)								int _g7 = b1->length;
HXDLIN(  62)								while((_g6 < _g7)){
HXDLIN(  62)									_g6 = (_g6 + 1);
HXDLIN(  62)									int i1 = (_g6 - 1);
HXDLIN(  62)									{
HXDLIN(  62)										 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  62)										bool undoImage2;
HXDLIN(  62)										if ((i1 >= 0)) {
HXDLIN(  62)											undoImage2 = (i1 < (this3->byteLength >> 2));
            										}
            										else {
HXDLIN(  62)											undoImage2 = false;
            										}
HXDLIN(  62)										if (undoImage2) {
HXDLIN(  62)											 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  62)											int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  62)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  62)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  62)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  62)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  62)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXDLIN(  62)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::VecIntImg v = vec;
HXDLIN(  62)						{
HXDLIN(  62)							v->width = width;
HXDLIN(  62)							v->height = height;
HXDLIN(  62)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  62)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  62)							{
HXDLIN(  62)								int _g8 = 0;
HXDLIN(  62)								int _g9 = v->length;
HXDLIN(  62)								while((_g8 < _g9)){
HXDLIN(  62)									_g8 = (_g8 + 1);
HXDLIN(  62)									int i2 = (_g8 - 1);
HXDLIN(  62)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN(  62)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXDLIN(  62)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  62)						{
HXDLIN(  62)							b2->width = width;
HXDLIN(  62)							b2->height = height;
HXDLIN(  62)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  62)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  62)							{
HXDLIN(  62)								int len1 = b2->length;
HXDLIN(  62)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  62)								if (::hx::IsNull( d->head )) {
HXDLIN(  62)									int _g10 = 0;
HXDLIN(  62)									int _g11 = len1;
HXDLIN(  62)									while((_g10 < _g11)){
HXDLIN(  62)										_g10 = (_g10 + 1);
HXDLIN(  62)										int i3 = (_g10 - 1);
HXDLIN(  62)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXDLIN(  62)									int _g12 = 0;
HXDLIN(  62)									int _g13 = len1;
HXDLIN(  62)									while((_g12 < _g13)){
HXDLIN(  62)										_g12 = (_g12 + 1);
HXDLIN(  62)										int i4 = (_g12 - 1);
HXDLIN(  62)										{
HXDLIN(  62)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  62)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  62)											{
HXDLIN(  62)												int _g14 = 0;
HXDLIN(  62)												int _g15 = i4;
HXDLIN(  62)												while((_g14 < _g15)){
HXDLIN(  62)													_g14 = (_g14 + 1);
HXDLIN(  62)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE(  62)											if (::hx::IsNull( prev )) {
HXDLIN(  62)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  62)												l = null();
            											}
            											else {
HXDLIN(  62)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  62)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  62)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN(  62)				this2->image = undoImage1;
HXDLIN(  62)				this2->width = width;
HXDLIN(  62)				this2->height = height;
HXDLIN(  62)				this2->imageType = ( (int)(imageType) );
HXDLIN(  62)				undoImage = this2;
HXDLIN(  62)				{
HXDLIN(  62)					int rectLeft = xIter3->start;
HXDLIN(  62)					int rectTop = yIter3->start;
HXDLIN(  62)					int rectRight = xIter3->max;
HXDLIN(  62)					bool forceClear = false;
HXDLIN(  62)					{
HXDLIN(  62)						int _g16 = rectTop;
HXDLIN(  62)						int _g17 = yIter3->max;
HXDLIN(  62)						while((_g16 < _g17)){
HXDLIN(  62)							_g16 = (_g16 + 1);
HXDLIN(  62)							int dy1 = (_g16 - 1);
HXDLIN(  62)							{
HXDLIN(  62)								int _g18 = rectLeft;
HXDLIN(  62)								int _g19 = rectRight;
HXDLIN(  62)								while((_g18 < _g19)){
HXDLIN(  62)									_g18 = (_g18 + 1);
HXDLIN(  62)									int dx1 = (_g18 - 1);
HXDLIN(  62)									::Dynamic this4 = this1->image;
HXDLIN(  62)									int index;
HXDLIN(  62)									if (this1->useVirtualPos) {
HXDLIN(  62)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            									}
            									else {
HXDLIN(  62)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            									}
HXDLIN(  62)									int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  62)									int col;
HXDLIN(  62)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXDLIN(  62)										col = c;
            									}
HXDLIN(  62)									bool _hx_tmp;
HXDLIN(  62)									if (this1->useMask) {
HXDLIN(  62)										_hx_tmp = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN(  62)										_hx_tmp = false;
            									}
HXDLIN(  62)									if (_hx_tmp) {
HXDLIN(  62)										 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  62)										::Dynamic this6 = this5->image;
HXDLIN(  62)										int index1;
HXDLIN(  62)										if (this5->useVirtualPos) {
HXDLIN(  62)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            										}
            										else {
HXDLIN(  62)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            										}
HXDLIN(  62)										int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  62)										int v1;
HXDLIN(  62)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXDLIN(  62)											v1 = c1;
            										}
HXDLIN(  62)										int maskPixel = v1;
HXDLIN(  62)										int this7 = col;
HXDLIN(  62)										if ((maskPixel == 0)) {
HXDLIN(  62)											col = this7;
            										}
            										else {
HXDLIN(  62)											Float m0;
HXDLIN(  62)											int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  62)											if ((this8 == 0)) {
HXDLIN(  62)												m0 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float m1;
HXDLIN(  62)											int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  62)											if ((this9 == 0)) {
HXDLIN(  62)												m1 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float m2;
HXDLIN(  62)											int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  62)											if ((this10 == 0)) {
HXDLIN(  62)												m2 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float m3;
HXDLIN(  62)											int this11 = (maskPixel & 255);
HXDLIN(  62)											if ((this11 == 0)) {
HXDLIN(  62)												m3 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  62)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  62)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  62)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  62)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  62)									if ((col != 0)) {
HXDLIN(  62)										int x1 = (dx1 - rectLeft);
HXDLIN(  62)										int y1 = (dy1 - rectTop);
HXDLIN(  62)										int c2 = col;
HXDLIN(  62)										bool _hx_tmp1;
HXDLIN(  62)										if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  62)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXDLIN(  62)											_hx_tmp1 = false;
            										}
HXDLIN(  62)										if (_hx_tmp1) {
HXDLIN(  62)											int location;
HXDLIN(  62)											if (undoImage->useVirtualPos) {
HXDLIN(  62)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXDLIN(  62)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN(  62)											int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  62)											int this13;
HXDLIN(  62)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)												this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            											}
            											else {
HXDLIN(  62)												this13 = this12;
            											}
HXDLIN(  62)											Float a1;
HXDLIN(  62)											int this14 = ((this13 >> 24) & 255);
HXDLIN(  62)											if ((this14 == 0)) {
HXDLIN(  62)												a1 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float r1;
HXDLIN(  62)											int this15 = ((this13 >> 16) & 255);
HXDLIN(  62)											if ((this15 == 0)) {
HXDLIN(  62)												r1 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float g1;
HXDLIN(  62)											int this16 = ((this13 >> 8) & 255);
HXDLIN(  62)											if ((this16 == 0)) {
HXDLIN(  62)												g1 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float b11;
HXDLIN(  62)											int this17 = (this13 & 255);
HXDLIN(  62)											if ((this17 == 0)) {
HXDLIN(  62)												b11 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float a2;
HXDLIN(  62)											int this18 = ((col >> 24) & 255);
HXDLIN(  62)											if ((this18 == 0)) {
HXDLIN(  62)												a2 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float r2;
HXDLIN(  62)											int this19 = ((col >> 16) & 255);
HXDLIN(  62)											if ((this19 == 0)) {
HXDLIN(  62)												r2 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float g2;
HXDLIN(  62)											int this20 = ((col >> 8) & 255);
HXDLIN(  62)											if ((this20 == 0)) {
HXDLIN(  62)												g2 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float b21;
HXDLIN(  62)											int this21 = (col & 255);
HXDLIN(  62)											if ((this21 == 0)) {
HXDLIN(  62)												b21 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  62)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  62)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  62)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  62)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  62)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  62)											{
HXDLIN(  62)												int _hx_tmp2;
HXDLIN(  62)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXDLIN(  62)													_hx_tmp2 = blended;
            												}
HXDLIN(  62)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXDLIN(  62)											::Dynamic this22 = undoImage->image;
HXDLIN(  62)											int index2;
HXDLIN(  62)											if (undoImage->useVirtualPos) {
HXDLIN(  62)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXDLIN(  62)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN(  62)											int _hx_tmp3;
HXDLIN(  62)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXDLIN(  62)												_hx_tmp3 = c2;
            											}
HXDLIN(  62)											::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            										}
            									}
            									else {
HXDLIN(  62)										if (forceClear) {
HXDLIN(  62)											::Dynamic this23 = undoImage->image;
HXDLIN(  62)											int x2 = (dx1 - rectLeft);
HXDLIN(  62)											int y2 = (dy1 - rectTop);
HXDLIN(  62)											int index3;
HXDLIN(  62)											if (undoImage->useVirtualPos) {
HXDLIN(  62)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXDLIN(  62)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN(  62)											::iterMagic::Iimg_obj::set(this23,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  62)			{
HXDLIN(  62)				int _g_min = xIter3->start;
HXDLIN(  62)				int _g_max = xIter3->max;
HXDLIN(  62)				while((_g_min < _g_max)){
HXDLIN(  62)					_g_min = (_g_min + 1);
HXDLIN(  62)					int px = (_g_min - 1);
HXDLIN(  62)					Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  62)					{
HXDLIN(  62)						int _g_min1 = yIter3->start;
HXDLIN(  62)						int _g_max1 = yIter3->max;
HXDLIN(  62)						while((_g_min1 < _g_max1)){
HXDLIN(  62)							_g_min1 = (_g_min1 + 1);
HXDLIN(  62)							int py = (_g_min1 - 1);
HXDLIN(  62)							Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  62)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  62)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  62)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  62)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  62)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  62)							bool _hx_tmp4;
HXDLIN(  62)							bool _hx_tmp5;
HXDLIN(  62)							if ((ratioA >= 0)) {
HXDLIN(  62)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXDLIN(  62)								_hx_tmp5 = false;
            							}
HXDLIN(  62)							if (_hx_tmp5) {
HXDLIN(  62)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXDLIN(  62)								_hx_tmp4 = false;
            							}
HXDLIN(  62)							if (_hx_tmp4) {
HXDLIN(  62)								int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  62)								if ((i6 > 255)) {
HXLINE(  24)									i6 = 255;
            								}
HXLINE(  62)								if ((i6 < 0)) {
HXLINE(  25)									i6 = 0;
            								}
HXLINE(  62)								int a5 = i6;
HXDLIN(  62)								int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  62)								if ((i7 > 255)) {
HXLINE(  24)									i7 = 255;
            								}
HXLINE(  62)								if ((i7 < 0)) {
HXLINE(  25)									i7 = 0;
            								}
HXLINE(  62)								int r3 = i7;
HXDLIN(  62)								int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  62)								if ((i8 > 255)) {
HXLINE(  24)									i8 = 255;
            								}
HXLINE(  62)								if ((i8 < 0)) {
HXLINE(  25)									i8 = 0;
            								}
HXLINE(  62)								int g3 = i8;
HXDLIN(  62)								int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  62)								if ((i9 > 255)) {
HXLINE(  24)									i9 = 255;
            								}
HXLINE(  62)								if ((i9 < 0)) {
HXLINE(  25)									i9 = 0;
            								}
HXLINE(  62)								int b4 = i9;
HXDLIN(  62)								{
HXDLIN(  62)									int location1;
HXDLIN(  62)									if (this1->useVirtualPos) {
HXDLIN(  62)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            									}
            									else {
HXDLIN(  62)										location1 = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            									}
HXDLIN(  62)									bool _hx_tmp6;
HXDLIN(  62)									if (this1->transparent) {
HXDLIN(  62)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXDLIN(  62)										_hx_tmp6 = false;
            									}
HXDLIN(  62)									if (_hx_tmp6) {
HXDLIN(  62)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  62)										int old;
HXDLIN(  62)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)											old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXDLIN(  62)											old = this24;
            										}
HXDLIN(  62)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  62)										Float a11;
HXDLIN(  62)										int this25 = ((old >> 24) & 255);
HXDLIN(  62)										if ((this25 == 0)) {
HXDLIN(  62)											a11 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float r11;
HXDLIN(  62)										int this26 = ((old >> 16) & 255);
HXDLIN(  62)										if ((this26 == 0)) {
HXDLIN(  62)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float g11;
HXDLIN(  62)										int this27 = ((old >> 8) & 255);
HXDLIN(  62)										if ((this27 == 0)) {
HXDLIN(  62)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float b12;
HXDLIN(  62)										int this28 = (old & 255);
HXDLIN(  62)										if ((this28 == 0)) {
HXDLIN(  62)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float a21;
HXDLIN(  62)										int this29 = ((rhs >> 24) & 255);
HXDLIN(  62)										if ((this29 == 0)) {
HXDLIN(  62)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float r21;
HXDLIN(  62)										int this30 = ((rhs >> 16) & 255);
HXDLIN(  62)										if ((this30 == 0)) {
HXDLIN(  62)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float g21;
HXDLIN(  62)										int this31 = ((rhs >> 8) & 255);
HXDLIN(  62)										if ((this31 == 0)) {
HXDLIN(  62)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float b22;
HXDLIN(  62)										int this32 = (rhs & 255);
HXDLIN(  62)										if ((this32 == 0)) {
HXDLIN(  62)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  62)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  62)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  62)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  62)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  62)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  62)										{
HXDLIN(  62)											int _hx_tmp7;
HXDLIN(  62)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN(  62)												_hx_tmp7 = blended1;
            											}
HXDLIN(  62)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXDLIN(  62)										int value;
HXDLIN(  62)										if (this1->isLittle) {
HXDLIN(  62)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXDLIN(  62)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN(  62)										::iterMagic::Iimg_obj::set(this1->image,location1,value);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  62)			if ((hasHit == false)) {
HXDLIN(  62)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  62)				if (hasUndo) {
HXDLIN(  62)					v2->undoImage = undoImage;
HXDLIN(  62)					v2->undoX = xIter3->start;
HXDLIN(  62)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXDLIN(  62)		{
HXDLIN(  62)			bool hasHit1 = false;
HXDLIN(  62)			bool hasUndo1 = false;
HXDLIN(  62)			int aA1 = ((colorC >> 24) & 255);
HXDLIN(  62)			int rA1 = ((colorC >> 16) & 255);
HXDLIN(  62)			int gA1 = ((colorC >> 8) & 255);
HXDLIN(  62)			int bA1 = (colorC & 255);
HXDLIN(  62)			int aB1 = ((colorB >> 24) & 255);
HXDLIN(  62)			int rB1 = ((colorB >> 16) & 255);
HXDLIN(  62)			int gB1 = ((colorB >> 8) & 255);
HXDLIN(  62)			int bB1 = (colorB & 255);
HXDLIN(  62)			int aC1 = ((colorD >> 24) & 255);
HXDLIN(  62)			int rC1 = ((colorD >> 16) & 255);
HXDLIN(  62)			int gC1 = ((colorD >> 8) & 255);
HXDLIN(  62)			int bC1 = (colorD & 255);
HXDLIN(  62)			Float bcx1 = (cx - dx);
HXDLIN(  62)			Float bcy1 = (cy - dy);
HXDLIN(  62)			Float acx1 = (bx - dx);
HXDLIN(  62)			Float acy1 = (by - dy);
HXDLIN(  62)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  62)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  62)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  62)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  62)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  62)			if ((bx > cx)) {
HXDLIN(  62)				if ((bx > dx)) {
HXDLIN(  62)					int min4;
HXDLIN(  62)					if ((cx > dx)) {
HXDLIN(  62)						min4 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN(  62)						min4 = ::Math_obj::floor(cx);
            					}
HXDLIN(  62)					int ii_min8 = min4;
HXDLIN(  62)					int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN(  62)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXDLIN(  62)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN(  62)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN(  62)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXDLIN(  62)				if ((cx > dx)) {
HXDLIN(  62)					int min5;
HXDLIN(  62)					if ((bx > dx)) {
HXDLIN(  62)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN(  62)						min5 = ::Math_obj::ceil(bx);
            					}
HXDLIN(  62)					int ii_min10 = min5;
HXDLIN(  62)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN(  62)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXDLIN(  62)					int ii_min11 = ::Math_obj::floor(bx);
HXDLIN(  62)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN(  62)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN(  62)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  62)			if ((by > cy)) {
HXDLIN(  62)				if ((by > dy)) {
HXDLIN(  62)					int min6;
HXDLIN(  62)					if ((cy > dy)) {
HXDLIN(  62)						min6 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN(  62)						min6 = ::Math_obj::floor(cy);
            					}
HXDLIN(  62)					int ii_min12 = min6;
HXDLIN(  62)					int ii_max12 = ::Math_obj::ceil(by);
HXDLIN(  62)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXDLIN(  62)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN(  62)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN(  62)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXDLIN(  62)				if ((cy > dy)) {
HXDLIN(  62)					int min7;
HXDLIN(  62)					if ((by > dy)) {
HXDLIN(  62)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN(  62)						min7 = ::Math_obj::ceil(by);
            					}
HXDLIN(  62)					int ii_min14 = min7;
HXDLIN(  62)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN(  62)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXDLIN(  62)					int ii_min15 = ::Math_obj::floor(by);
HXDLIN(  62)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN(  62)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN(  62)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  62)			if (hasUndo1) {
HXDLIN(  62)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  62)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  62)				 ::Dynamic imageType1 = null();
HXDLIN(  62)				 ::pi_xy::ImageStruct this33 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  62)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  62)				::Dynamic undoImage4;
HXDLIN(  62)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN(  62)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::BytesImg b6 = byt1;
HXDLIN(  62)						{
HXDLIN(  62)							b6->width = width1;
HXDLIN(  62)							b6->height = height1;
HXDLIN(  62)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  62)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  62)							{
HXDLIN(  62)								int len2 = b6->length;
HXDLIN(  62)								int w1 = 0;
HXDLIN(  62)								{
HXDLIN(  62)									int _g20 = 0;
HXDLIN(  62)									int _g21 = b6->height;
HXDLIN(  62)									while((_g20 < _g21)){
HXDLIN(  62)										_g20 = (_g20 + 1);
HXDLIN(  62)										int y3 = (_g20 - 1);
HXDLIN(  62)										{
HXDLIN(  62)											int _g22 = 0;
HXDLIN(  62)											int _g23 = b6->width;
HXDLIN(  62)											while((_g22 < _g23)){
HXDLIN(  62)												_g22 = (_g22 + 1);
HXDLIN(  62)												int x3 = (_g22 - 1);
HXDLIN(  62)												{
HXDLIN(  62)													w1 = (w1 + 1);
HXDLIN(  62)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  62)												{
HXDLIN(  62)													w1 = (w1 + 1);
HXDLIN(  62)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  62)												{
HXDLIN(  62)													w1 = (w1 + 1);
HXDLIN(  62)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  62)												{
HXDLIN(  62)													w1 = (w1 + 1);
HXDLIN(  62)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  62)						undoImage4 = b6;
            					}
            					break;
            					case (int)1: {
HXDLIN(  62)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN(  62)						{
HXDLIN(  62)							a7->width = width1;
HXDLIN(  62)							a7->height = height1;
HXDLIN(  62)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  62)							a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  62)							{
HXDLIN(  62)								int _g24 = 0;
HXDLIN(  62)								int _g25 = a7->length;
HXDLIN(  62)								while((_g24 < _g25)){
HXDLIN(  62)									_g24 = (_g24 + 1);
HXDLIN(  62)									int i10 = (_g24 - 1);
HXDLIN(  62)									a7->data[i10] = 0;
            								}
            							}
            						}
HXDLIN(  62)						undoImage4 = a7;
            					}
            					break;
            					case (int)2: {
HXDLIN(  62)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN(  62)						{
HXDLIN(  62)							b7->width = width1;
HXDLIN(  62)							b7->height = height1;
HXDLIN(  62)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  62)							int size1 = (b7->length * 4);
HXDLIN(  62)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  62)							{
HXDLIN(  62)								int _g26 = 0;
HXDLIN(  62)								int _g27 = b7->length;
HXDLIN(  62)								while((_g26 < _g27)){
HXDLIN(  62)									_g26 = (_g26 + 1);
HXDLIN(  62)									int i11 = (_g26 - 1);
HXDLIN(  62)									{
HXDLIN(  62)										 ::haxe::io::ArrayBufferViewImpl this34 = b7->data;
HXDLIN(  62)										bool undoImage5;
HXDLIN(  62)										if ((i11 >= 0)) {
HXDLIN(  62)											undoImage5 = (i11 < (this34->byteLength >> 2));
            										}
            										else {
HXDLIN(  62)											undoImage5 = false;
            										}
HXDLIN(  62)										if (undoImage5) {
HXDLIN(  62)											 ::haxe::io::Bytes _this1 = this34->bytes;
HXDLIN(  62)											int pos1 = ((i11 << 2) + this34->byteOffset);
HXDLIN(  62)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  62)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  62)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  62)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  62)						undoImage4 = b7;
            					}
            					break;
            					case (int)3: {
HXDLIN(  62)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  62)						{
HXDLIN(  62)							v3->width = width1;
HXDLIN(  62)							v3->height = height1;
HXDLIN(  62)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  62)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  62)							{
HXDLIN(  62)								int _g28 = 0;
HXDLIN(  62)								int _g29 = v3->length;
HXDLIN(  62)								while((_g28 < _g29)){
HXDLIN(  62)									_g28 = (_g28 + 1);
HXDLIN(  62)									int i12 = (_g28 - 1);
HXDLIN(  62)									v3->data->__unsafe_set(i12,0);
            								}
            							}
            						}
HXDLIN(  62)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXDLIN(  62)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  62)						 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN(  62)						{
HXDLIN(  62)							b8->width = width1;
HXDLIN(  62)							b8->height = height1;
HXDLIN(  62)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  62)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  62)							{
HXDLIN(  62)								int len3 = b8->length;
HXDLIN(  62)								 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN(  62)								if (::hx::IsNull( d1->head )) {
HXDLIN(  62)									int _g30 = 0;
HXDLIN(  62)									int _g31 = len3;
HXDLIN(  62)									while((_g30 < _g31)){
HXDLIN(  62)										_g30 = (_g30 + 1);
HXDLIN(  62)										int i13 = (_g30 - 1);
HXDLIN(  62)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN(  62)									int _g32 = 0;
HXDLIN(  62)									int _g33 = len3;
HXDLIN(  62)									while((_g32 < _g33)){
HXDLIN(  62)										_g32 = (_g32 + 1);
HXDLIN(  62)										int i14 = (_g32 - 1);
HXDLIN(  62)										{
HXDLIN(  62)											 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN(  62)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  62)											{
HXDLIN(  62)												int _g34 = 0;
HXDLIN(  62)												int _g35 = i14;
HXDLIN(  62)												while((_g34 < _g35)){
HXDLIN(  62)													_g34 = (_g34 + 1);
HXDLIN(  62)													int i15 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  62)											if (::hx::IsNull( prev1 )) {
HXDLIN(  62)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  62)												l1 = null();
            											}
            											else {
HXDLIN(  62)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  62)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  62)						undoImage4 = b8;
            					}
            					break;
            				}
HXDLIN(  62)				this33->image = undoImage4;
HXDLIN(  62)				this33->width = width1;
HXDLIN(  62)				this33->height = height1;
HXDLIN(  62)				this33->imageType = ( (int)(imageType1) );
HXDLIN(  62)				undoImage3 = this33;
HXDLIN(  62)				{
HXDLIN(  62)					int rectLeft1 = xIter31->start;
HXDLIN(  62)					int rectTop1 = yIter31->start;
HXDLIN(  62)					int rectRight1 = xIter31->max;
HXDLIN(  62)					bool forceClear1 = false;
HXDLIN(  62)					{
HXDLIN(  62)						int _g36 = rectTop1;
HXDLIN(  62)						int _g37 = yIter31->max;
HXDLIN(  62)						while((_g36 < _g37)){
HXDLIN(  62)							_g36 = (_g36 + 1);
HXDLIN(  62)							int dy2 = (_g36 - 1);
HXDLIN(  62)							{
HXDLIN(  62)								int _g38 = rectLeft1;
HXDLIN(  62)								int _g39 = rectRight1;
HXDLIN(  62)								while((_g38 < _g39)){
HXDLIN(  62)									_g38 = (_g38 + 1);
HXDLIN(  62)									int dx2 = (_g38 - 1);
HXDLIN(  62)									::Dynamic this35 = this1->image;
HXDLIN(  62)									int index4;
HXDLIN(  62)									if (this1->useVirtualPos) {
HXDLIN(  62)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            									}
            									else {
HXDLIN(  62)										index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            									}
HXDLIN(  62)									int c3 = ::iterMagic::Iimg_obj::get(this35,index4);
HXDLIN(  62)									int col1;
HXDLIN(  62)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXDLIN(  62)										col1 = c3;
            									}
HXDLIN(  62)									bool _hx_tmp8;
HXDLIN(  62)									if (this1->useMask) {
HXDLIN(  62)										_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN(  62)										_hx_tmp8 = false;
            									}
HXDLIN(  62)									if (_hx_tmp8) {
HXDLIN(  62)										 ::pi_xy::ImageStruct this36 = this1->mask;
HXDLIN(  62)										::Dynamic this37 = this36->image;
HXDLIN(  62)										int index5;
HXDLIN(  62)										if (this36->useVirtualPos) {
HXDLIN(  62)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx2) - this36->virtualX));
            										}
            										else {
HXDLIN(  62)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this36->width) + dx2)) ));
            										}
HXDLIN(  62)										int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN(  62)										int v4;
HXDLIN(  62)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)											v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN(  62)											v4 = c4;
            										}
HXDLIN(  62)										int maskPixel1 = v4;
HXDLIN(  62)										int this38 = col1;
HXDLIN(  62)										if ((maskPixel1 == 0)) {
HXDLIN(  62)											col1 = this38;
            										}
            										else {
HXDLIN(  62)											Float m01;
HXDLIN(  62)											int this39 = ((maskPixel1 >> 24) & 255);
HXDLIN(  62)											if ((this39 == 0)) {
HXDLIN(  62)												m01 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												m01 = (( (Float)(this39) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float m11;
HXDLIN(  62)											int this40 = ((maskPixel1 >> 16) & 255);
HXDLIN(  62)											if ((this40 == 0)) {
HXDLIN(  62)												m11 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												m11 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float m21;
HXDLIN(  62)											int this41 = ((maskPixel1 >> 8) & 255);
HXDLIN(  62)											if ((this41 == 0)) {
HXDLIN(  62)												m21 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												m21 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float m31;
HXDLIN(  62)											int this42 = (maskPixel1 & 255);
HXDLIN(  62)											if ((this42 == 0)) {
HXDLIN(  62)												m31 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												m31 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this38 >> 24) & 255)) )));
HXDLIN(  62)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this38 >> 16) & 255)) )));
HXDLIN(  62)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this38 >> 8) & 255)) )));
HXDLIN(  62)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this38 & 255)) )));
HXDLIN(  62)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  62)									if ((col1 != 0)) {
HXDLIN(  62)										int x4 = (dx2 - rectLeft1);
HXDLIN(  62)										int y4 = (dy2 - rectTop1);
HXDLIN(  62)										int c5 = col1;
HXDLIN(  62)										bool _hx_tmp9;
HXDLIN(  62)										if ((((c5 >> 24) & 255) < 254)) {
HXDLIN(  62)											_hx_tmp9 = undoImage3->transparent;
            										}
            										else {
HXDLIN(  62)											_hx_tmp9 = false;
            										}
HXDLIN(  62)										if (_hx_tmp9) {
HXDLIN(  62)											int location2;
HXDLIN(  62)											if (undoImage3->useVirtualPos) {
HXDLIN(  62)												location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXDLIN(  62)												location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN(  62)											int this43 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  62)											int this44;
HXDLIN(  62)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)												this44 = ((((((this43 >> 24) & 255) << 24) | ((this43 & 255) << 16)) | (((this43 >> 8) & 255) << 8)) | ((this43 >> 16) & 255));
            											}
            											else {
HXDLIN(  62)												this44 = this43;
            											}
HXDLIN(  62)											Float a12;
HXDLIN(  62)											int this45 = ((this44 >> 24) & 255);
HXDLIN(  62)											if ((this45 == 0)) {
HXDLIN(  62)												a12 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												a12 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float r12;
HXDLIN(  62)											int this46 = ((this44 >> 16) & 255);
HXDLIN(  62)											if ((this46 == 0)) {
HXDLIN(  62)												r12 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												r12 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float g12;
HXDLIN(  62)											int this47 = ((this44 >> 8) & 255);
HXDLIN(  62)											if ((this47 == 0)) {
HXDLIN(  62)												g12 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												g12 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float b13;
HXDLIN(  62)											int this48 = (this44 & 255);
HXDLIN(  62)											if ((this48 == 0)) {
HXDLIN(  62)												b13 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												b13 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float a22;
HXDLIN(  62)											int this49 = ((col1 >> 24) & 255);
HXDLIN(  62)											if ((this49 == 0)) {
HXDLIN(  62)												a22 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												a22 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float r22;
HXDLIN(  62)											int this50 = ((col1 >> 16) & 255);
HXDLIN(  62)											if ((this50 == 0)) {
HXDLIN(  62)												r22 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												r22 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float g22;
HXDLIN(  62)											int this51 = ((col1 >> 8) & 255);
HXDLIN(  62)											if ((this51 == 0)) {
HXDLIN(  62)												g22 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												g22 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float b23;
HXDLIN(  62)											int this52 = (col1 & 255);
HXDLIN(  62)											if ((this52 == 0)) {
HXDLIN(  62)												b23 = ((Float)0.);
            											}
            											else {
HXDLIN(  62)												b23 = (( (Float)(this52) ) / ( (Float)(255) ));
            											}
HXDLIN(  62)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  62)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  62)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  62)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  62)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  62)											int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  62)											{
HXDLIN(  62)												int _hx_tmp10;
HXDLIN(  62)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)													_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXDLIN(  62)													_hx_tmp10 = blended2;
            												}
HXDLIN(  62)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            											}
            										}
            										else {
HXDLIN(  62)											::Dynamic this53 = undoImage3->image;
HXDLIN(  62)											int index6;
HXDLIN(  62)											if (undoImage3->useVirtualPos) {
HXDLIN(  62)												index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXDLIN(  62)												index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN(  62)											int _hx_tmp11;
HXDLIN(  62)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)												_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXDLIN(  62)												_hx_tmp11 = c5;
            											}
HXDLIN(  62)											::iterMagic::Iimg_obj::set(this53,index6,_hx_tmp11);
            										}
            									}
            									else {
HXDLIN(  62)										if (forceClear1) {
HXDLIN(  62)											::Dynamic this54 = undoImage3->image;
HXDLIN(  62)											int x5 = (dx2 - rectLeft1);
HXDLIN(  62)											int y5 = (dy2 - rectTop1);
HXDLIN(  62)											int index7;
HXDLIN(  62)											if (undoImage3->useVirtualPos) {
HXDLIN(  62)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXDLIN(  62)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN(  62)											::iterMagic::Iimg_obj::set(this54,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  62)			{
HXDLIN(  62)				int _g_min2 = xIter31->start;
HXDLIN(  62)				int _g_max2 = xIter31->max;
HXDLIN(  62)				while((_g_min2 < _g_max2)){
HXDLIN(  62)					_g_min2 = (_g_min2 + 1);
HXDLIN(  62)					int px1 = (_g_min2 - 1);
HXDLIN(  62)					Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN(  62)					{
HXDLIN(  62)						int _g_min3 = yIter31->start;
HXDLIN(  62)						int _g_max3 = yIter31->max;
HXDLIN(  62)						while((_g_min3 < _g_max3)){
HXDLIN(  62)							_g_min3 = (_g_min3 + 1);
HXDLIN(  62)							int py1 = (_g_min3 - 1);
HXDLIN(  62)							Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN(  62)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  62)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  62)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  62)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  62)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  62)							bool _hx_tmp12;
HXDLIN(  62)							bool _hx_tmp13;
HXDLIN(  62)							if ((ratioA1 >= 0)) {
HXDLIN(  62)								_hx_tmp13 = (ratioB1 >= 0);
            							}
            							else {
HXDLIN(  62)								_hx_tmp13 = false;
            							}
HXDLIN(  62)							if (_hx_tmp13) {
HXDLIN(  62)								_hx_tmp12 = (ratioC1 >= 0);
            							}
            							else {
HXDLIN(  62)								_hx_tmp12 = false;
            							}
HXDLIN(  62)							if (_hx_tmp12) {
HXDLIN(  62)								int i16 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN(  62)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE(  62)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE(  62)								int a9 = i16;
HXDLIN(  62)								int i17 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN(  62)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE(  62)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE(  62)								int r6 = i17;
HXDLIN(  62)								int i18 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN(  62)								if ((i18 > 255)) {
HXLINE(  24)									i18 = 255;
            								}
HXLINE(  62)								if ((i18 < 0)) {
HXLINE(  25)									i18 = 0;
            								}
HXLINE(  62)								int g6 = i18;
HXDLIN(  62)								int i19 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN(  62)								if ((i19 > 255)) {
HXLINE(  24)									i19 = 255;
            								}
HXLINE(  62)								if ((i19 < 0)) {
HXLINE(  25)									i19 = 0;
            								}
HXLINE(  62)								int b10 = i19;
HXDLIN(  62)								{
HXDLIN(  62)									int location3;
HXDLIN(  62)									if (this1->useVirtualPos) {
HXDLIN(  62)										location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this1->virtualY) * ( (Float)(this1->width) )) + px1) - this1->virtualX));
            									}
            									else {
HXDLIN(  62)										location3 = ::Std_obj::_hx_int(( (Float)(((py1 * this1->width) + px1)) ));
            									}
HXDLIN(  62)									bool _hx_tmp14;
HXDLIN(  62)									if (this1->transparent) {
HXDLIN(  62)										_hx_tmp14 = (a9 < 254);
            									}
            									else {
HXDLIN(  62)										_hx_tmp14 = false;
            									}
HXDLIN(  62)									if (_hx_tmp14) {
HXDLIN(  62)										int this55 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  62)										int old1;
HXDLIN(  62)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)											old1 = ((((((this55 >> 24) & 255) << 24) | ((this55 & 255) << 16)) | (((this55 >> 8) & 255) << 8)) | ((this55 >> 16) & 255));
            										}
            										else {
HXDLIN(  62)											old1 = this55;
            										}
HXDLIN(  62)										int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN(  62)										Float a13;
HXDLIN(  62)										int this56 = ((old1 >> 24) & 255);
HXDLIN(  62)										if ((this56 == 0)) {
HXDLIN(  62)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											a13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float r13;
HXDLIN(  62)										int this57 = ((old1 >> 16) & 255);
HXDLIN(  62)										if ((this57 == 0)) {
HXDLIN(  62)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float g13;
HXDLIN(  62)										int this58 = ((old1 >> 8) & 255);
HXDLIN(  62)										if ((this58 == 0)) {
HXDLIN(  62)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float b14;
HXDLIN(  62)										int this59 = (old1 & 255);
HXDLIN(  62)										if ((this59 == 0)) {
HXDLIN(  62)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float a23;
HXDLIN(  62)										int this60 = ((rhs1 >> 24) & 255);
HXDLIN(  62)										if ((this60 == 0)) {
HXDLIN(  62)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float r23;
HXDLIN(  62)										int this61 = ((rhs1 >> 16) & 255);
HXDLIN(  62)										if ((this61 == 0)) {
HXDLIN(  62)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float g23;
HXDLIN(  62)										int this62 = ((rhs1 >> 8) & 255);
HXDLIN(  62)										if ((this62 == 0)) {
HXDLIN(  62)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float b24;
HXDLIN(  62)										int this63 = (rhs1 & 255);
HXDLIN(  62)										if ((this63 == 0)) {
HXDLIN(  62)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN(  62)											b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            										}
HXDLIN(  62)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  62)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  62)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  62)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  62)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  62)										int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN(  62)										{
HXDLIN(  62)											int _hx_tmp15;
HXDLIN(  62)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  62)												_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN(  62)												_hx_tmp15 = blended3;
            											}
HXDLIN(  62)											::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp15);
            										}
            									}
            									else {
HXDLIN(  62)										int value1;
HXDLIN(  62)										if (this1->isLittle) {
HXDLIN(  62)											value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            										}
            										else {
HXDLIN(  62)											value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            										}
HXDLIN(  62)										::iterMagic::Iimg_obj::set(this1->image,location3,value1);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  62)			if ((hasHit1 == false)) {
HXDLIN(  62)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  62)				if (hasUndo1) {
HXDLIN(  62)					v5->undoImage = undoImage3;
HXDLIN(  62)					v5->undoX = xIter31->start;
HXDLIN(  62)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXDLIN(  62)		if ((hasHit == true)) {
HXDLIN(  62)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  62)			return v6;
            		}
            		else {
HXDLIN(  62)			return null();
            		}
HXDLIN(  62)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(GradientShape_Impl__obj,quad,return )

 ::pi_xy::algo::HitQuad GradientShape_Impl__obj::line( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float thick,int colorA,int colorB,int colorC,int colorD,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_75_line)
HXLINE(  76)		Float o = (qy - py);
HXLINE(  77)		Float a = (qx - px);
HXLINE(  78)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXLINE(  79)		Float theta = ::Math_obj::atan2(o,a);
HXLINE(  80)		 ::Dynamic debugCorners1 = debugCorners;
HXLINE(  81)		if (::hx::IsNull( debugCorners1 )) {
HXLINE(  81)			debugCorners1 = false;
            		}
HXLINE(  80)		Float sin = ::Math_obj::sin(theta);
HXDLIN(  80)		Float cos = ::Math_obj::cos(theta);
HXDLIN(  80)		Float radius = (thick / ( (Float)(2) ));
HXDLIN(  80)		Float dx = ((Float)0.1);
HXDLIN(  80)		Float dy = radius;
HXDLIN(  80)		Float cx = h;
HXDLIN(  80)		Float cy = radius;
HXDLIN(  80)		Float bx = h;
HXDLIN(  80)		Float by = -(radius);
HXDLIN(  80)		Float ax = ((Float)0.1);
HXDLIN(  80)		Float ay = -(radius);
HXDLIN(  80)		Float temp = ((Float)0.);
HXLINE( 474)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 475)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 476)		ax = temp;
HXLINE( 478)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 479)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 480)		bx = temp;
HXLINE( 482)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 483)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 484)		cx = temp;
HXLINE( 486)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 487)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 488)		dx = temp;
HXLINE(  80)		if (( (bool)(debugCorners1) )) {
HXLINE(  80)			{
HXLINE(  80)				 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  80)				{
HXLINE(  80)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN(  80)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN(  80)					int r_w = 12;
HXDLIN(  80)					int r_h = 12;
HXDLIN(  80)					int xmax = ((r_x + r_w) + 1);
HXDLIN(  80)					int ymax = ((r_y + r_h) + 1);
HXDLIN(  80)					int ii_min = r_x;
HXDLIN(  80)					int ii_max = xmax;
HXDLIN(  80)					int xRange__start = ii_min;
HXDLIN(  80)					int xRange__max = ii_max;
HXDLIN(  80)					int ii_min1 = r_y;
HXDLIN(  80)					int ii_max1 = ymax;
HXDLIN(  80)					int yRange__start = ii_min1;
HXDLIN(  80)					int yRange__max = ii_max1;
HXDLIN(  80)					int range_x = xRange__start;
HXDLIN(  80)					int range_y = (yRange__start - 1);
HXDLIN(  80)					int range_xReset = range_x;
HXDLIN(  80)					int range_yReset = range_y;
HXDLIN(  80)					int range_xMax = (xRange__max - 2);
HXDLIN(  80)					int range_yMax = (yRange__max - 2);
HXDLIN(  80)					int _this_min = 0;
HXDLIN(  80)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  80)					while((_this_min < _this_max)){
HXLINE(  80)						_this_min = (_this_min + 1);
HXDLIN(  80)						int i = (_this_min - 1);
HXDLIN(  80)						if ((range_y > range_yMax)) {
HXLINE(  80)							range_y = range_yReset;
HXDLIN(  80)							range_x = (range_x + 1);
            						}
HXDLIN(  80)						range_y = (range_y + 1);
HXDLIN(  80)						int i1 = i;
HXDLIN(  80)						{
HXLINE(  80)							int x = range_x;
HXDLIN(  80)							int y = range_y;
HXDLIN(  80)							int c = colorA;
HXDLIN(  80)							bool _hx_tmp;
HXDLIN(  80)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  80)								_hx_tmp = this2->transparent;
            							}
            							else {
HXLINE(  80)								_hx_tmp = false;
            							}
HXDLIN(  80)							if (_hx_tmp) {
HXLINE(  80)								int location;
HXDLIN(  80)								if (this2->useVirtualPos) {
HXLINE(  80)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            								}
            								else {
HXLINE(  80)									location = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            								}
HXDLIN(  80)								int this3 = ::iterMagic::Iimg_obj::get(this2->image,location);
HXDLIN(  80)								int this4;
HXDLIN(  80)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  80)									this4 = this3;
            								}
HXDLIN(  80)								Float a1;
HXDLIN(  80)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  80)								if ((this5 == 0)) {
HXLINE(  80)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float r1;
HXDLIN(  80)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  80)								if ((this6 == 0)) {
HXLINE(  80)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float g1;
HXDLIN(  80)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  80)								if ((this7 == 0)) {
HXLINE(  80)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float b1;
HXDLIN(  80)								int this8 = (this4 & 255);
HXDLIN(  80)								if ((this8 == 0)) {
HXLINE(  80)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float a2;
HXDLIN(  80)								int this9 = ((colorA >> 24) & 255);
HXDLIN(  80)								if ((this9 == 0)) {
HXLINE(  80)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float r2;
HXDLIN(  80)								int this10 = ((colorA >> 16) & 255);
HXDLIN(  80)								if ((this10 == 0)) {
HXLINE(  80)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float g2;
HXDLIN(  80)								int this11 = ((colorA >> 8) & 255);
HXDLIN(  80)								if ((this11 == 0)) {
HXLINE(  80)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float b2;
HXDLIN(  80)								int this12 = (colorA & 255);
HXDLIN(  80)								if ((this12 == 0)) {
HXLINE(  80)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  80)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  80)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  80)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  80)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  80)								int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  80)								{
HXLINE(  80)									int _hx_tmp1;
HXDLIN(  80)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  80)										_hx_tmp1 = blended;
            									}
HXDLIN(  80)									::iterMagic::Iimg_obj::set(this2->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE(  80)								::Dynamic this13 = this2->image;
HXDLIN(  80)								int index;
HXDLIN(  80)								if (this2->useVirtualPos) {
HXLINE(  80)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            								}
            								else {
HXLINE(  80)									index = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            								}
HXDLIN(  80)								int _hx_tmp2;
HXDLIN(  80)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  80)									_hx_tmp2 = c;
            								}
HXDLIN(  80)								::iterMagic::Iimg_obj::set(this13,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  80)			{
HXLINE(  80)				 ::pi_xy::ImageStruct this14 = this1;
HXDLIN(  80)				{
HXLINE(  80)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN(  80)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN(  80)					int r_w1 = 12;
HXDLIN(  80)					int r_h1 = 12;
HXDLIN(  80)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN(  80)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN(  80)					int ii_min2 = r_x1;
HXDLIN(  80)					int ii_max2 = xmax1;
HXDLIN(  80)					int xRange__start1 = ii_min2;
HXDLIN(  80)					int xRange__max1 = ii_max2;
HXDLIN(  80)					int ii_min3 = r_y1;
HXDLIN(  80)					int ii_max3 = ymax1;
HXDLIN(  80)					int yRange__start1 = ii_min3;
HXDLIN(  80)					int yRange__max1 = ii_max3;
HXDLIN(  80)					int range_x1 = xRange__start1;
HXDLIN(  80)					int range_y1 = (yRange__start1 - 1);
HXDLIN(  80)					int range_xReset1 = range_x1;
HXDLIN(  80)					int range_yReset1 = range_y1;
HXDLIN(  80)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  80)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  80)					int _this_min1 = 0;
HXDLIN(  80)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  80)					while((_this_min1 < _this_max1)){
HXLINE(  80)						_this_min1 = (_this_min1 + 1);
HXDLIN(  80)						int i2 = (_this_min1 - 1);
HXDLIN(  80)						if ((range_y1 > range_yMax1)) {
HXLINE(  80)							range_y1 = range_yReset1;
HXDLIN(  80)							range_x1 = (range_x1 + 1);
            						}
HXDLIN(  80)						range_y1 = (range_y1 + 1);
HXDLIN(  80)						int i3 = i2;
HXDLIN(  80)						{
HXLINE(  80)							int x1 = range_x1;
HXDLIN(  80)							int y1 = range_y1;
HXDLIN(  80)							int c1 = colorB;
HXDLIN(  80)							bool _hx_tmp3;
HXDLIN(  80)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  80)								_hx_tmp3 = this14->transparent;
            							}
            							else {
HXLINE(  80)								_hx_tmp3 = false;
            							}
HXDLIN(  80)							if (_hx_tmp3) {
HXLINE(  80)								int location1;
HXDLIN(  80)								if (this14->useVirtualPos) {
HXLINE(  80)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this14->virtualY) * ( (Float)(this14->width) )) + x1) - this14->virtualX));
            								}
            								else {
HXLINE(  80)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this14->width) + x1)) ));
            								}
HXDLIN(  80)								int this15 = ::iterMagic::Iimg_obj::get(this14->image,location1);
HXDLIN(  80)								int this16;
HXDLIN(  80)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)									this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            								}
            								else {
HXLINE(  80)									this16 = this15;
            								}
HXDLIN(  80)								Float a11;
HXDLIN(  80)								int this17 = ((this16 >> 24) & 255);
HXDLIN(  80)								if ((this17 == 0)) {
HXLINE(  80)									a11 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float r11;
HXDLIN(  80)								int this18 = ((this16 >> 16) & 255);
HXDLIN(  80)								if ((this18 == 0)) {
HXLINE(  80)									r11 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									r11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float g11;
HXDLIN(  80)								int this19 = ((this16 >> 8) & 255);
HXDLIN(  80)								if ((this19 == 0)) {
HXLINE(  80)									g11 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									g11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float b11;
HXDLIN(  80)								int this20 = (this16 & 255);
HXDLIN(  80)								if ((this20 == 0)) {
HXLINE(  80)									b11 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float a21;
HXDLIN(  80)								int this21 = ((colorB >> 24) & 255);
HXDLIN(  80)								if ((this21 == 0)) {
HXLINE(  80)									a21 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									a21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float r21;
HXDLIN(  80)								int this22 = ((colorB >> 16) & 255);
HXDLIN(  80)								if ((this22 == 0)) {
HXLINE(  80)									r21 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									r21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float g21;
HXDLIN(  80)								int this23 = ((colorB >> 8) & 255);
HXDLIN(  80)								if ((this23 == 0)) {
HXLINE(  80)									g21 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									g21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float b21;
HXDLIN(  80)								int this24 = (colorB & 255);
HXDLIN(  80)								if ((this24 == 0)) {
HXLINE(  80)									b21 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  80)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  80)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  80)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN(  80)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  80)								int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  80)								{
HXLINE(  80)									int _hx_tmp4;
HXDLIN(  80)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE(  80)										_hx_tmp4 = blended1;
            									}
HXDLIN(  80)									::iterMagic::Iimg_obj::set(this14->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE(  80)								::Dynamic this25 = this14->image;
HXDLIN(  80)								int index1;
HXDLIN(  80)								if (this14->useVirtualPos) {
HXLINE(  80)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this14->virtualY) * ( (Float)(this14->width) )) + x1) - this14->virtualX));
            								}
            								else {
HXLINE(  80)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this14->width) + x1)) ));
            								}
HXDLIN(  80)								int _hx_tmp5;
HXDLIN(  80)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  80)									_hx_tmp5 = c1;
            								}
HXDLIN(  80)								::iterMagic::Iimg_obj::set(this25,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  80)			{
HXLINE(  80)				 ::pi_xy::ImageStruct this26 = this1;
HXDLIN(  80)				{
HXLINE(  80)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN(  80)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN(  80)					int r_w2 = 12;
HXDLIN(  80)					int r_h2 = 12;
HXDLIN(  80)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN(  80)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN(  80)					int ii_min4 = r_x2;
HXDLIN(  80)					int ii_max4 = xmax2;
HXDLIN(  80)					int xRange__start2 = ii_min4;
HXDLIN(  80)					int xRange__max2 = ii_max4;
HXDLIN(  80)					int ii_min5 = r_y2;
HXDLIN(  80)					int ii_max5 = ymax2;
HXDLIN(  80)					int yRange__start2 = ii_min5;
HXDLIN(  80)					int yRange__max2 = ii_max5;
HXDLIN(  80)					int range_x2 = xRange__start2;
HXDLIN(  80)					int range_y2 = (yRange__start2 - 1);
HXDLIN(  80)					int range_xReset2 = range_x2;
HXDLIN(  80)					int range_yReset2 = range_y2;
HXDLIN(  80)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  80)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  80)					int _this_min2 = 0;
HXDLIN(  80)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  80)					while((_this_min2 < _this_max2)){
HXLINE(  80)						_this_min2 = (_this_min2 + 1);
HXDLIN(  80)						int i4 = (_this_min2 - 1);
HXDLIN(  80)						if ((range_y2 > range_yMax2)) {
HXLINE(  80)							range_y2 = range_yReset2;
HXDLIN(  80)							range_x2 = (range_x2 + 1);
            						}
HXDLIN(  80)						range_y2 = (range_y2 + 1);
HXDLIN(  80)						int i5 = i4;
HXDLIN(  80)						{
HXLINE(  80)							int x2 = range_x2;
HXDLIN(  80)							int y2 = range_y2;
HXDLIN(  80)							int c2 = colorC;
HXDLIN(  80)							bool _hx_tmp6;
HXDLIN(  80)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  80)								_hx_tmp6 = this26->transparent;
            							}
            							else {
HXLINE(  80)								_hx_tmp6 = false;
            							}
HXDLIN(  80)							if (_hx_tmp6) {
HXLINE(  80)								int location2;
HXDLIN(  80)								if (this26->useVirtualPos) {
HXLINE(  80)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this26->virtualY) * ( (Float)(this26->width) )) + x2) - this26->virtualX));
            								}
            								else {
HXLINE(  80)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this26->width) + x2)) ));
            								}
HXDLIN(  80)								int this27 = ::iterMagic::Iimg_obj::get(this26->image,location2);
HXDLIN(  80)								int this28;
HXDLIN(  80)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)									this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            								}
            								else {
HXLINE(  80)									this28 = this27;
            								}
HXDLIN(  80)								Float a12;
HXDLIN(  80)								int this29 = ((this28 >> 24) & 255);
HXDLIN(  80)								if ((this29 == 0)) {
HXLINE(  80)									a12 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									a12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float r12;
HXDLIN(  80)								int this30 = ((this28 >> 16) & 255);
HXDLIN(  80)								if ((this30 == 0)) {
HXLINE(  80)									r12 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									r12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float g12;
HXDLIN(  80)								int this31 = ((this28 >> 8) & 255);
HXDLIN(  80)								if ((this31 == 0)) {
HXLINE(  80)									g12 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									g12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float b12;
HXDLIN(  80)								int this32 = (this28 & 255);
HXDLIN(  80)								if ((this32 == 0)) {
HXLINE(  80)									b12 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									b12 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float a22;
HXDLIN(  80)								int this33 = ((colorC >> 24) & 255);
HXDLIN(  80)								if ((this33 == 0)) {
HXLINE(  80)									a22 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									a22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float r22;
HXDLIN(  80)								int this34 = ((colorC >> 16) & 255);
HXDLIN(  80)								if ((this34 == 0)) {
HXLINE(  80)									r22 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									r22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float g22;
HXDLIN(  80)								int this35 = ((colorC >> 8) & 255);
HXDLIN(  80)								if ((this35 == 0)) {
HXLINE(  80)									g22 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									g22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float b22;
HXDLIN(  80)								int this36 = (colorC & 255);
HXDLIN(  80)								if ((this36 == 0)) {
HXLINE(  80)									b22 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									b22 = (( (Float)(this36) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  80)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  80)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  80)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN(  80)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  80)								int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN(  80)								{
HXLINE(  80)									int _hx_tmp7;
HXDLIN(  80)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE(  80)										_hx_tmp7 = blended2;
            									}
HXDLIN(  80)									::iterMagic::Iimg_obj::set(this26->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE(  80)								::Dynamic this37 = this26->image;
HXDLIN(  80)								int index2;
HXDLIN(  80)								if (this26->useVirtualPos) {
HXLINE(  80)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this26->virtualY) * ( (Float)(this26->width) )) + x2) - this26->virtualX));
            								}
            								else {
HXLINE(  80)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this26->width) + x2)) ));
            								}
HXDLIN(  80)								int _hx_tmp8;
HXDLIN(  80)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE(  80)									_hx_tmp8 = c2;
            								}
HXDLIN(  80)								::iterMagic::Iimg_obj::set(this37,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  80)			{
HXLINE(  80)				 ::pi_xy::ImageStruct this38 = this1;
HXDLIN(  80)				{
HXLINE(  80)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN(  80)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN(  80)					int r_w3 = 12;
HXDLIN(  80)					int r_h3 = 12;
HXDLIN(  80)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN(  80)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN(  80)					int ii_min6 = r_x3;
HXDLIN(  80)					int ii_max6 = xmax3;
HXDLIN(  80)					int xRange__start3 = ii_min6;
HXDLIN(  80)					int xRange__max3 = ii_max6;
HXDLIN(  80)					int ii_min7 = r_y3;
HXDLIN(  80)					int ii_max7 = ymax3;
HXDLIN(  80)					int yRange__start3 = ii_min7;
HXDLIN(  80)					int yRange__max3 = ii_max7;
HXDLIN(  80)					int range_x3 = xRange__start3;
HXDLIN(  80)					int range_y3 = (yRange__start3 - 1);
HXDLIN(  80)					int range_xReset3 = range_x3;
HXDLIN(  80)					int range_yReset3 = range_y3;
HXDLIN(  80)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN(  80)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN(  80)					int _this_min3 = 0;
HXDLIN(  80)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN(  80)					while((_this_min3 < _this_max3)){
HXLINE(  80)						_this_min3 = (_this_min3 + 1);
HXDLIN(  80)						int i6 = (_this_min3 - 1);
HXDLIN(  80)						if ((range_y3 > range_yMax3)) {
HXLINE(  80)							range_y3 = range_yReset3;
HXDLIN(  80)							range_x3 = (range_x3 + 1);
            						}
HXDLIN(  80)						range_y3 = (range_y3 + 1);
HXDLIN(  80)						int i7 = i6;
HXDLIN(  80)						{
HXLINE(  80)							int x3 = range_x3;
HXDLIN(  80)							int y3 = range_y3;
HXDLIN(  80)							int c3 = colorD;
HXDLIN(  80)							bool _hx_tmp9;
HXDLIN(  80)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  80)								_hx_tmp9 = this38->transparent;
            							}
            							else {
HXLINE(  80)								_hx_tmp9 = false;
            							}
HXDLIN(  80)							if (_hx_tmp9) {
HXLINE(  80)								int location3;
HXDLIN(  80)								if (this38->useVirtualPos) {
HXLINE(  80)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this38->virtualY) * ( (Float)(this38->width) )) + x3) - this38->virtualX));
            								}
            								else {
HXLINE(  80)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this38->width) + x3)) ));
            								}
HXDLIN(  80)								int this39 = ::iterMagic::Iimg_obj::get(this38->image,location3);
HXDLIN(  80)								int this40;
HXDLIN(  80)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)									this40 = ((((((this39 >> 24) & 255) << 24) | ((this39 & 255) << 16)) | (((this39 >> 8) & 255) << 8)) | ((this39 >> 16) & 255));
            								}
            								else {
HXLINE(  80)									this40 = this39;
            								}
HXDLIN(  80)								Float a13;
HXDLIN(  80)								int this41 = ((this40 >> 24) & 255);
HXDLIN(  80)								if ((this41 == 0)) {
HXLINE(  80)									a13 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									a13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float r13;
HXDLIN(  80)								int this42 = ((this40 >> 16) & 255);
HXDLIN(  80)								if ((this42 == 0)) {
HXLINE(  80)									r13 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									r13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float g13;
HXDLIN(  80)								int this43 = ((this40 >> 8) & 255);
HXDLIN(  80)								if ((this43 == 0)) {
HXLINE(  80)									g13 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									g13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float b13;
HXDLIN(  80)								int this44 = (this40 & 255);
HXDLIN(  80)								if ((this44 == 0)) {
HXLINE(  80)									b13 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									b13 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float a23;
HXDLIN(  80)								int this45 = ((colorD >> 24) & 255);
HXDLIN(  80)								if ((this45 == 0)) {
HXLINE(  80)									a23 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									a23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float r23;
HXDLIN(  80)								int this46 = ((colorD >> 16) & 255);
HXDLIN(  80)								if ((this46 == 0)) {
HXLINE(  80)									r23 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									r23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float g23;
HXDLIN(  80)								int this47 = ((colorD >> 8) & 255);
HXDLIN(  80)								if ((this47 == 0)) {
HXLINE(  80)									g23 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									g23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float b23;
HXDLIN(  80)								int this48 = (colorD & 255);
HXDLIN(  80)								if ((this48 == 0)) {
HXLINE(  80)									b23 = ((Float)0.);
            								}
            								else {
HXLINE(  80)									b23 = (( (Float)(this48) ) / ( (Float)(255) ));
            								}
HXDLIN(  80)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  80)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  80)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  80)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN(  80)								int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  80)								int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN(  80)								{
HXLINE(  80)									int _hx_tmp10;
HXDLIN(  80)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE(  80)										_hx_tmp10 = blended3;
            									}
HXDLIN(  80)									::iterMagic::Iimg_obj::set(this38->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE(  80)								::Dynamic this49 = this38->image;
HXDLIN(  80)								int index3;
HXDLIN(  80)								if (this38->useVirtualPos) {
HXLINE(  80)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this38->virtualY) * ( (Float)(this38->width) )) + x3) - this38->virtualX));
            								}
            								else {
HXLINE(  80)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this38->width) + x3)) ));
            								}
HXDLIN(  80)								int _hx_tmp11;
HXDLIN(  80)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE(  80)									_hx_tmp11 = c3;
            								}
HXDLIN(  80)								::iterMagic::Iimg_obj::set(this49,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  80)		{
HXLINE(  80)			bool hasUndo = false;
HXDLIN(  80)			int aA = ((colorB >> 24) & 255);
HXDLIN(  80)			int rA = ((colorB >> 16) & 255);
HXDLIN(  80)			int gA = ((colorB >> 8) & 255);
HXDLIN(  80)			int bA = (colorB & 255);
HXDLIN(  80)			int aB = ((colorA >> 24) & 255);
HXDLIN(  80)			int rB = ((colorA >> 16) & 255);
HXDLIN(  80)			int gB = ((colorA >> 8) & 255);
HXDLIN(  80)			int bB = (colorA & 255);
HXDLIN(  80)			int aC = ((colorD >> 24) & 255);
HXDLIN(  80)			int rC = ((colorD >> 16) & 255);
HXDLIN(  80)			int gC = ((colorD >> 8) & 255);
HXDLIN(  80)			int bC = (colorD & 255);
HXDLIN(  80)			Float bcx = (bx - dx);
HXDLIN(  80)			Float bcy = (by - dy);
HXDLIN(  80)			Float acx = (ax - dx);
HXDLIN(  80)			Float acy = (ay - dy);
HXDLIN(  80)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  80)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  80)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  80)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  80)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  80)			if ((ax > bx)) {
HXLINE(  80)				if ((ax > dx)) {
HXLINE(  80)					int min;
HXDLIN(  80)					if ((bx > dx)) {
HXLINE(  80)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  80)						min = ::Math_obj::floor(bx);
            					}
HXDLIN(  80)					int ii_min8 = min;
HXDLIN(  80)					int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN(  80)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE(  80)					int ii_min9 = ::Math_obj::floor(bx);
HXDLIN(  80)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN(  80)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE(  80)				if ((bx > dx)) {
HXLINE(  80)					int min1;
HXDLIN(  80)					if ((ax > dx)) {
HXLINE(  80)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  80)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN(  80)					int ii_min10 = min1;
HXDLIN(  80)					int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN(  80)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE(  80)					int ii_min11 = ::Math_obj::floor(ax);
HXDLIN(  80)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN(  80)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN(  80)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  80)			if ((ay > by)) {
HXLINE(  80)				if ((ay > dy)) {
HXLINE(  80)					int min2;
HXDLIN(  80)					if ((by > dy)) {
HXLINE(  80)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  80)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN(  80)					int ii_min12 = min2;
HXDLIN(  80)					int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN(  80)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE(  80)					int ii_min13 = ::Math_obj::floor(by);
HXDLIN(  80)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN(  80)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE(  80)				if ((by > dy)) {
HXLINE(  80)					int min3;
HXDLIN(  80)					if ((ay > dy)) {
HXLINE(  80)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  80)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN(  80)					int ii_min14 = min3;
HXDLIN(  80)					int ii_max14 = ::Math_obj::ceil(by);
HXDLIN(  80)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE(  80)					int ii_min15 = ::Math_obj::floor(ay);
HXDLIN(  80)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN(  80)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN(  80)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  80)			if (hasUndo) {
HXLINE(  80)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  80)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  80)				 ::Dynamic imageType = null();
HXDLIN(  80)				 ::pi_xy::ImageStruct this50 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  80)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  80)				::Dynamic undoImage1;
HXDLIN(  80)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE(  80)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::BytesImg b6 = byt;
HXDLIN(  80)						{
HXLINE(  80)							b6->width = width;
HXDLIN(  80)							b6->height = height;
HXDLIN(  80)							b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  80)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  80)							{
HXLINE(  80)								int len = b6->length;
HXDLIN(  80)								int w = 0;
HXDLIN(  80)								{
HXLINE(  80)									int _g = 0;
HXDLIN(  80)									int _g1 = b6->height;
HXDLIN(  80)									while((_g < _g1)){
HXLINE(  80)										_g = (_g + 1);
HXDLIN(  80)										int y4 = (_g - 1);
HXDLIN(  80)										{
HXLINE(  80)											int _g2 = 0;
HXDLIN(  80)											int _g3 = b6->width;
HXDLIN(  80)											while((_g2 < _g3)){
HXLINE(  80)												_g2 = (_g2 + 1);
HXDLIN(  80)												int x4 = (_g2 - 1);
HXDLIN(  80)												{
HXLINE(  80)													w = (w + 1);
HXDLIN(  80)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  80)												{
HXLINE(  80)													w = (w + 1);
HXDLIN(  80)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  80)												{
HXLINE(  80)													w = (w + 1);
HXDLIN(  80)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  80)												{
HXLINE(  80)													w = (w + 1);
HXDLIN(  80)													b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  80)						undoImage1 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE(  80)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::ArrIntImg a8 = arrI;
HXDLIN(  80)						{
HXLINE(  80)							a8->width = width;
HXDLIN(  80)							a8->height = height;
HXDLIN(  80)							a8->data = ::Array_obj< int >::__new(0);
HXDLIN(  80)							a8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  80)							{
HXLINE(  80)								int _g4 = 0;
HXDLIN(  80)								int _g5 = a8->length;
HXDLIN(  80)								while((_g4 < _g5)){
HXLINE(  80)									_g4 = (_g4 + 1);
HXDLIN(  80)									int i8 = (_g4 - 1);
HXDLIN(  80)									a8->data[i8] = 0;
            								}
            							}
            						}
HXDLIN(  80)						undoImage1 = a8;
            					}
            					break;
            					case (int)2: {
HXLINE(  80)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN(  80)						{
HXLINE(  80)							b7->width = width;
HXDLIN(  80)							b7->height = height;
HXDLIN(  80)							b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  80)							int size = (b7->length * 4);
HXDLIN(  80)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  80)							{
HXLINE(  80)								int _g6 = 0;
HXDLIN(  80)								int _g7 = b7->length;
HXDLIN(  80)								while((_g6 < _g7)){
HXLINE(  80)									_g6 = (_g6 + 1);
HXDLIN(  80)									int i9 = (_g6 - 1);
HXDLIN(  80)									{
HXLINE(  80)										 ::haxe::io::ArrayBufferViewImpl this51 = b7->data;
HXDLIN(  80)										bool undoImage2;
HXDLIN(  80)										if ((i9 >= 0)) {
HXLINE(  80)											undoImage2 = (i9 < (this51->byteLength >> 2));
            										}
            										else {
HXLINE(  80)											undoImage2 = false;
            										}
HXDLIN(  80)										if (undoImage2) {
HXLINE(  80)											 ::haxe::io::Bytes _this = this51->bytes;
HXDLIN(  80)											int pos = ((i9 << 2) + this51->byteOffset);
HXDLIN(  80)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  80)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  80)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  80)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  80)						undoImage1 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE(  80)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::VecIntImg v = vec;
HXDLIN(  80)						{
HXLINE(  80)							v->width = width;
HXDLIN(  80)							v->height = height;
HXDLIN(  80)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  80)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  80)							{
HXLINE(  80)								int _g8 = 0;
HXDLIN(  80)								int _g9 = v->length;
HXDLIN(  80)								while((_g8 < _g9)){
HXLINE(  80)									_g8 = (_g8 + 1);
HXDLIN(  80)									int i10 = (_g8 - 1);
HXDLIN(  80)									v->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN(  80)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE(  80)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN(  80)						{
HXLINE(  80)							b8->width = width;
HXDLIN(  80)							b8->height = height;
HXDLIN(  80)							b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  80)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  80)							{
HXLINE(  80)								int len1 = b8->length;
HXDLIN(  80)								 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN(  80)								if (::hx::IsNull( d->head )) {
HXLINE(  80)									int _g10 = 0;
HXDLIN(  80)									int _g11 = len1;
HXDLIN(  80)									while((_g10 < _g11)){
HXLINE(  80)										_g10 = (_g10 + 1);
HXDLIN(  80)										int i11 = (_g10 - 1);
HXDLIN(  80)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE(  80)									int _g12 = 0;
HXDLIN(  80)									int _g13 = len1;
HXDLIN(  80)									while((_g12 < _g13)){
HXLINE(  80)										_g12 = (_g12 + 1);
HXDLIN(  80)										int i12 = (_g12 - 1);
HXDLIN(  80)										{
HXLINE(  80)											 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN(  80)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  80)											{
HXLINE(  80)												int _g14 = 0;
HXDLIN(  80)												int _g15 = i12;
HXDLIN(  80)												while((_g14 < _g15)){
HXLINE(  80)													_g14 = (_g14 + 1);
HXDLIN(  80)													int i13 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE(  80)											if (::hx::IsNull( prev )) {
HXLINE(  80)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  80)												l = null();
            											}
            											else {
HXLINE(  80)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  80)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  80)						undoImage1 = b8;
            					}
            					break;
            				}
HXDLIN(  80)				this50->image = undoImage1;
HXDLIN(  80)				this50->width = width;
HXDLIN(  80)				this50->height = height;
HXDLIN(  80)				this50->imageType = ( (int)(imageType) );
HXDLIN(  80)				undoImage = this50;
HXDLIN(  80)				{
HXLINE(  80)					int rectLeft = xIter3->start;
HXDLIN(  80)					int rectTop = yIter3->start;
HXDLIN(  80)					int rectRight = xIter3->max;
HXDLIN(  80)					bool forceClear = false;
HXDLIN(  80)					{
HXLINE(  80)						int _g16 = rectTop;
HXDLIN(  80)						int _g17 = yIter3->max;
HXDLIN(  80)						while((_g16 < _g17)){
HXLINE(  80)							_g16 = (_g16 + 1);
HXDLIN(  80)							int dy1 = (_g16 - 1);
HXDLIN(  80)							{
HXLINE(  80)								int _g18 = rectLeft;
HXDLIN(  80)								int _g19 = rectRight;
HXDLIN(  80)								while((_g18 < _g19)){
HXLINE(  80)									_g18 = (_g18 + 1);
HXDLIN(  80)									int dx1 = (_g18 - 1);
HXDLIN(  80)									::Dynamic this52 = this1->image;
HXDLIN(  80)									int index4;
HXDLIN(  80)									if (this1->useVirtualPos) {
HXLINE(  80)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            									}
            									else {
HXLINE(  80)										index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            									}
HXDLIN(  80)									int c4 = ::iterMagic::Iimg_obj::get(this52,index4);
HXDLIN(  80)									int col;
HXDLIN(  80)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)										col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE(  80)										col = c4;
            									}
HXDLIN(  80)									bool _hx_tmp12;
HXDLIN(  80)									if (this1->useMask) {
HXLINE(  80)										_hx_tmp12 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  80)										_hx_tmp12 = false;
            									}
HXDLIN(  80)									if (_hx_tmp12) {
HXLINE(  80)										 ::pi_xy::ImageStruct this53 = this1->mask;
HXDLIN(  80)										::Dynamic this54 = this53->image;
HXDLIN(  80)										int index5;
HXDLIN(  80)										if (this53->useVirtualPos) {
HXLINE(  80)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this53->virtualY) * ( (Float)(this53->width) )) + dx1) - this53->virtualX));
            										}
            										else {
HXLINE(  80)											index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this53->width) + dx1)) ));
            										}
HXDLIN(  80)										int c5 = ::iterMagic::Iimg_obj::get(this54,index5);
HXDLIN(  80)										int v1;
HXDLIN(  80)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)											v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE(  80)											v1 = c5;
            										}
HXDLIN(  80)										int maskPixel = v1;
HXDLIN(  80)										int this55 = col;
HXDLIN(  80)										if ((maskPixel == 0)) {
HXLINE(  80)											col = this55;
            										}
            										else {
HXLINE(  80)											Float m0;
HXDLIN(  80)											int this56 = ((maskPixel >> 24) & 255);
HXDLIN(  80)											if ((this56 == 0)) {
HXLINE(  80)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												m0 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float m1;
HXDLIN(  80)											int this57 = ((maskPixel >> 16) & 255);
HXDLIN(  80)											if ((this57 == 0)) {
HXLINE(  80)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												m1 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float m2;
HXDLIN(  80)											int this58 = ((maskPixel >> 8) & 255);
HXDLIN(  80)											if ((this58 == 0)) {
HXLINE(  80)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												m2 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float m3;
HXDLIN(  80)											int this59 = (maskPixel & 255);
HXDLIN(  80)											if ((this59 == 0)) {
HXLINE(  80)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												m3 = (( (Float)(this59) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this55 >> 24) & 255)) )));
HXDLIN(  80)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this55 >> 16) & 255)) )));
HXDLIN(  80)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this55 >> 8) & 255)) )));
HXDLIN(  80)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this55 & 255)) )));
HXDLIN(  80)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  80)									if ((col != 0)) {
HXLINE(  80)										int x5 = (dx1 - rectLeft);
HXDLIN(  80)										int y5 = (dy1 - rectTop);
HXDLIN(  80)										int c6 = col;
HXDLIN(  80)										bool _hx_tmp13;
HXDLIN(  80)										if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  80)											_hx_tmp13 = undoImage->transparent;
            										}
            										else {
HXLINE(  80)											_hx_tmp13 = false;
            										}
HXDLIN(  80)										if (_hx_tmp13) {
HXLINE(  80)											int location4;
HXDLIN(  80)											if (undoImage->useVirtualPos) {
HXLINE(  80)												location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE(  80)												location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN(  80)											int this60 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN(  80)											int this61;
HXDLIN(  80)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)												this61 = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            											}
            											else {
HXLINE(  80)												this61 = this60;
            											}
HXDLIN(  80)											Float a14;
HXDLIN(  80)											int this62 = ((this61 >> 24) & 255);
HXDLIN(  80)											if ((this62 == 0)) {
HXLINE(  80)												a14 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												a14 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float r14;
HXDLIN(  80)											int this63 = ((this61 >> 16) & 255);
HXDLIN(  80)											if ((this63 == 0)) {
HXLINE(  80)												r14 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												r14 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float g14;
HXDLIN(  80)											int this64 = ((this61 >> 8) & 255);
HXDLIN(  80)											if ((this64 == 0)) {
HXLINE(  80)												g14 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												g14 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float b14;
HXDLIN(  80)											int this65 = (this61 & 255);
HXDLIN(  80)											if ((this65 == 0)) {
HXLINE(  80)												b14 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												b14 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float a24;
HXDLIN(  80)											int this66 = ((col >> 24) & 255);
HXDLIN(  80)											if ((this66 == 0)) {
HXLINE(  80)												a24 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												a24 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float r24;
HXDLIN(  80)											int this67 = ((col >> 16) & 255);
HXDLIN(  80)											if ((this67 == 0)) {
HXLINE(  80)												r24 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												r24 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float g24;
HXDLIN(  80)											int this68 = ((col >> 8) & 255);
HXDLIN(  80)											if ((this68 == 0)) {
HXLINE(  80)												g24 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												g24 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float b24;
HXDLIN(  80)											int this69 = (col & 255);
HXDLIN(  80)											if ((this69 == 0)) {
HXLINE(  80)												b24 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												b24 = (( (Float)(this69) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  80)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  80)											int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  80)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN(  80)											int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  80)											int blended4 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN(  80)											{
HXLINE(  80)												int _hx_tmp14;
HXDLIN(  80)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)													_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE(  80)													_hx_tmp14 = blended4;
            												}
HXDLIN(  80)												::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            											}
            										}
            										else {
HXLINE(  80)											::Dynamic this70 = undoImage->image;
HXDLIN(  80)											int index6;
HXDLIN(  80)											if (undoImage->useVirtualPos) {
HXLINE(  80)												index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            											}
            											else {
HXLINE(  80)												index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            											}
HXDLIN(  80)											int _hx_tmp15;
HXDLIN(  80)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)												_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE(  80)												_hx_tmp15 = c6;
            											}
HXDLIN(  80)											::iterMagic::Iimg_obj::set(this70,index6,_hx_tmp15);
            										}
            									}
            									else {
HXLINE(  80)										if (forceClear) {
HXLINE(  80)											::Dynamic this71 = undoImage->image;
HXDLIN(  80)											int x6 = (dx1 - rectLeft);
HXDLIN(  80)											int y6 = (dy1 - rectTop);
HXDLIN(  80)											int index7;
HXDLIN(  80)											if (undoImage->useVirtualPos) {
HXLINE(  80)												index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            											}
            											else {
HXLINE(  80)												index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            											}
HXDLIN(  80)											::iterMagic::Iimg_obj::set(this71,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  80)			{
HXLINE(  80)				int _g_min = xIter3->start;
HXDLIN(  80)				int _g_max = xIter3->max;
HXDLIN(  80)				while((_g_min < _g_max)){
HXLINE(  80)					_g_min = (_g_min + 1);
HXDLIN(  80)					int px1 = (_g_min - 1);
HXDLIN(  80)					Float pcx = (( (Float)(px1) ) - dx);
HXDLIN(  80)					{
HXLINE(  80)						int _g_min1 = yIter3->start;
HXDLIN(  80)						int _g_max1 = yIter3->max;
HXDLIN(  80)						while((_g_min1 < _g_max1)){
HXLINE(  80)							_g_min1 = (_g_min1 + 1);
HXDLIN(  80)							int py1 = (_g_min1 - 1);
HXDLIN(  80)							Float pcy = (( (Float)(py1) ) - dy);
HXDLIN(  80)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  80)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  80)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  80)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  80)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  80)							bool _hx_tmp16;
HXDLIN(  80)							bool _hx_tmp17;
HXDLIN(  80)							if ((ratioA >= 0)) {
HXLINE(  80)								_hx_tmp17 = (ratioB >= 0);
            							}
            							else {
HXLINE(  80)								_hx_tmp17 = false;
            							}
HXDLIN(  80)							if (_hx_tmp17) {
HXLINE(  80)								_hx_tmp16 = (ratioC >= 0);
            							}
            							else {
HXLINE(  80)								_hx_tmp16 = false;
            							}
HXDLIN(  80)							if (_hx_tmp16) {
HXLINE(  80)								int i14 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  80)								if ((i14 > 255)) {
HXLINE(  24)									i14 = 255;
            								}
HXLINE(  80)								if ((i14 < 0)) {
HXLINE(  25)									i14 = 0;
            								}
HXLINE(  80)								int a10 = i14;
HXDLIN(  80)								int i15 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  80)								if ((i15 > 255)) {
HXLINE(  24)									i15 = 255;
            								}
HXLINE(  80)								if ((i15 < 0)) {
HXLINE(  25)									i15 = 0;
            								}
HXLINE(  80)								int r7 = i15;
HXDLIN(  80)								int i16 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  80)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE(  80)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE(  80)								int g7 = i16;
HXDLIN(  80)								int i17 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  80)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE(  80)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE(  80)								int b10 = i17;
HXDLIN(  80)								{
HXLINE(  80)									int location5;
HXDLIN(  80)									if (this1->useVirtualPos) {
HXLINE(  80)										location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this1->virtualY) * ( (Float)(this1->width) )) + px1) - this1->virtualX));
            									}
            									else {
HXLINE(  80)										location5 = ::Std_obj::_hx_int(( (Float)(((py1 * this1->width) + px1)) ));
            									}
HXDLIN(  80)									bool _hx_tmp18;
HXDLIN(  80)									if (this1->transparent) {
HXLINE(  80)										_hx_tmp18 = (a10 < 254);
            									}
            									else {
HXLINE(  80)										_hx_tmp18 = false;
            									}
HXDLIN(  80)									if (_hx_tmp18) {
HXLINE(  80)										int this72 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN(  80)										int old;
HXDLIN(  80)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)											old = ((((((this72 >> 24) & 255) << 24) | ((this72 & 255) << 16)) | (((this72 >> 8) & 255) << 8)) | ((this72 >> 16) & 255));
            										}
            										else {
HXLINE(  80)											old = this72;
            										}
HXDLIN(  80)										int rhs = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN(  80)										Float a15;
HXDLIN(  80)										int this73 = ((old >> 24) & 255);
HXDLIN(  80)										if ((this73 == 0)) {
HXLINE(  80)											a15 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											a15 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float r15;
HXDLIN(  80)										int this74 = ((old >> 16) & 255);
HXDLIN(  80)										if ((this74 == 0)) {
HXLINE(  80)											r15 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											r15 = (( (Float)(this74) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float g15;
HXDLIN(  80)										int this75 = ((old >> 8) & 255);
HXDLIN(  80)										if ((this75 == 0)) {
HXLINE(  80)											g15 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											g15 = (( (Float)(this75) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float b15;
HXDLIN(  80)										int this76 = (old & 255);
HXDLIN(  80)										if ((this76 == 0)) {
HXLINE(  80)											b15 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											b15 = (( (Float)(this76) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float a25;
HXDLIN(  80)										int this77 = ((rhs >> 24) & 255);
HXDLIN(  80)										if ((this77 == 0)) {
HXLINE(  80)											a25 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											a25 = (( (Float)(this77) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float r25;
HXDLIN(  80)										int this78 = ((rhs >> 16) & 255);
HXDLIN(  80)										if ((this78 == 0)) {
HXLINE(  80)											r25 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											r25 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float g25;
HXDLIN(  80)										int this79 = ((rhs >> 8) & 255);
HXDLIN(  80)										if ((this79 == 0)) {
HXLINE(  80)											g25 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											g25 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float b25;
HXDLIN(  80)										int this80 = (rhs & 255);
HXDLIN(  80)										if ((this80 == 0)) {
HXLINE(  80)											b25 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											b25 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  80)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  80)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  80)										int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN(  80)										int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  80)										int blended5 = ((((a16 << 24) | (r8 << 16)) | (g8 << 8)) | b16);
HXDLIN(  80)										{
HXLINE(  80)											int _hx_tmp19;
HXDLIN(  80)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)												_hx_tmp19 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXLINE(  80)												_hx_tmp19 = blended5;
            											}
HXDLIN(  80)											::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp19);
            										}
            									}
            									else {
HXLINE(  80)										int value;
HXDLIN(  80)										if (this1->isLittle) {
HXLINE(  80)											value = ((((a10 << 24) | (b10 << 16)) | (g7 << 8)) | r7);
            										}
            										else {
HXLINE(  80)											value = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
            										}
HXDLIN(  80)										::iterMagic::Iimg_obj::set(this1->image,location5,value);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  80)			if ((hasHit == false)) {
HXLINE(  80)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  80)				if (hasUndo) {
HXLINE(  80)					v2->undoImage = undoImage;
HXDLIN(  80)					v2->undoX = xIter3->start;
HXDLIN(  80)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXDLIN(  80)		{
HXLINE(  80)			bool hasHit1 = false;
HXDLIN(  80)			bool hasUndo1 = false;
HXDLIN(  80)			int aA1 = ((colorC >> 24) & 255);
HXDLIN(  80)			int rA1 = ((colorC >> 16) & 255);
HXDLIN(  80)			int gA1 = ((colorC >> 8) & 255);
HXDLIN(  80)			int bA1 = (colorC & 255);
HXDLIN(  80)			int aB1 = ((colorB >> 24) & 255);
HXDLIN(  80)			int rB1 = ((colorB >> 16) & 255);
HXDLIN(  80)			int gB1 = ((colorB >> 8) & 255);
HXDLIN(  80)			int bB1 = (colorB & 255);
HXDLIN(  80)			int aC1 = ((colorD >> 24) & 255);
HXDLIN(  80)			int rC1 = ((colorD >> 16) & 255);
HXDLIN(  80)			int gC1 = ((colorD >> 8) & 255);
HXDLIN(  80)			int bC1 = (colorD & 255);
HXDLIN(  80)			Float bcx1 = (cx - dx);
HXDLIN(  80)			Float bcy1 = (cy - dy);
HXDLIN(  80)			Float acx1 = (bx - dx);
HXDLIN(  80)			Float acy1 = (by - dy);
HXDLIN(  80)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  80)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  80)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  80)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  80)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  80)			if ((bx > cx)) {
HXLINE(  80)				if ((bx > dx)) {
HXLINE(  80)					int min4;
HXDLIN(  80)					if ((cx > dx)) {
HXLINE(  80)						min4 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  80)						min4 = ::Math_obj::floor(cx);
            					}
HXDLIN(  80)					int ii_min16 = min4;
HXDLIN(  80)					int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN(  80)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            				}
            				else {
HXLINE(  80)					int ii_min17 = ::Math_obj::floor(cx);
HXDLIN(  80)					int ii_max17 = ::Math_obj::ceil(dx);
HXDLIN(  80)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            				}
            			}
            			else {
HXLINE(  80)				if ((cx > dx)) {
HXLINE(  80)					int min5;
HXDLIN(  80)					if ((bx > dx)) {
HXLINE(  80)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  80)						min5 = ::Math_obj::ceil(bx);
            					}
HXDLIN(  80)					int ii_min18 = min5;
HXDLIN(  80)					int ii_max18 = ::Math_obj::ceil(cx);
HXDLIN(  80)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            				}
            				else {
HXLINE(  80)					int ii_min19 = ::Math_obj::floor(bx);
HXDLIN(  80)					int ii_max19 = ::Math_obj::ceil(dx);
HXDLIN(  80)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            				}
            			}
HXDLIN(  80)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  80)			if ((by > cy)) {
HXLINE(  80)				if ((by > dy)) {
HXLINE(  80)					int min6;
HXDLIN(  80)					if ((cy > dy)) {
HXLINE(  80)						min6 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  80)						min6 = ::Math_obj::floor(cy);
            					}
HXDLIN(  80)					int ii_min20 = min6;
HXDLIN(  80)					int ii_max20 = ::Math_obj::ceil(by);
HXDLIN(  80)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            				}
            				else {
HXLINE(  80)					int ii_min21 = ::Math_obj::floor(cy);
HXDLIN(  80)					int ii_max21 = ::Math_obj::ceil(dy);
HXDLIN(  80)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            				}
            			}
            			else {
HXLINE(  80)				if ((cy > dy)) {
HXLINE(  80)					int min7;
HXDLIN(  80)					if ((by > dy)) {
HXLINE(  80)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  80)						min7 = ::Math_obj::ceil(by);
            					}
HXDLIN(  80)					int ii_min22 = min7;
HXDLIN(  80)					int ii_max22 = ::Math_obj::ceil(cy);
HXDLIN(  80)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            				}
            				else {
HXLINE(  80)					int ii_min23 = ::Math_obj::floor(by);
HXDLIN(  80)					int ii_max23 = ::Math_obj::ceil(dy);
HXDLIN(  80)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            				}
            			}
HXDLIN(  80)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  80)			if (hasUndo1) {
HXLINE(  80)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  80)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  80)				 ::Dynamic imageType1 = null();
HXDLIN(  80)				 ::pi_xy::ImageStruct this81 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  80)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  80)				::Dynamic undoImage4;
HXDLIN(  80)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE(  80)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::BytesImg b17 = byt1;
HXDLIN(  80)						{
HXLINE(  80)							b17->width = width1;
HXDLIN(  80)							b17->height = height1;
HXDLIN(  80)							b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  80)							b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN(  80)							{
HXLINE(  80)								int len2 = b17->length;
HXDLIN(  80)								int w1 = 0;
HXDLIN(  80)								{
HXLINE(  80)									int _g20 = 0;
HXDLIN(  80)									int _g21 = b17->height;
HXDLIN(  80)									while((_g20 < _g21)){
HXLINE(  80)										_g20 = (_g20 + 1);
HXDLIN(  80)										int y7 = (_g20 - 1);
HXDLIN(  80)										{
HXLINE(  80)											int _g22 = 0;
HXDLIN(  80)											int _g23 = b17->width;
HXDLIN(  80)											while((_g22 < _g23)){
HXLINE(  80)												_g22 = (_g22 + 1);
HXDLIN(  80)												int x7 = (_g22 - 1);
HXDLIN(  80)												{
HXLINE(  80)													w1 = (w1 + 1);
HXDLIN(  80)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  80)												{
HXLINE(  80)													w1 = (w1 + 1);
HXDLIN(  80)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  80)												{
HXLINE(  80)													w1 = (w1 + 1);
HXDLIN(  80)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  80)												{
HXLINE(  80)													w1 = (w1 + 1);
HXDLIN(  80)													b17->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  80)						undoImage4 = b17;
            					}
            					break;
            					case (int)1: {
HXLINE(  80)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::ArrIntImg a17 = arrI1;
HXDLIN(  80)						{
HXLINE(  80)							a17->width = width1;
HXDLIN(  80)							a17->height = height1;
HXDLIN(  80)							a17->data = ::Array_obj< int >::__new(0);
HXDLIN(  80)							a17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  80)							{
HXLINE(  80)								int _g24 = 0;
HXDLIN(  80)								int _g25 = a17->length;
HXDLIN(  80)								while((_g24 < _g25)){
HXLINE(  80)									_g24 = (_g24 + 1);
HXDLIN(  80)									int i18 = (_g24 - 1);
HXDLIN(  80)									a17->data[i18] = 0;
            								}
            							}
            						}
HXDLIN(  80)						undoImage4 = a17;
            					}
            					break;
            					case (int)2: {
HXLINE(  80)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::U32ArrImg b18 = u32a1;
HXDLIN(  80)						{
HXLINE(  80)							b18->width = width1;
HXDLIN(  80)							b18->height = height1;
HXDLIN(  80)							b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  80)							int size1 = (b18->length * 4);
HXDLIN(  80)							b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  80)							{
HXLINE(  80)								int _g26 = 0;
HXDLIN(  80)								int _g27 = b18->length;
HXDLIN(  80)								while((_g26 < _g27)){
HXLINE(  80)									_g26 = (_g26 + 1);
HXDLIN(  80)									int i19 = (_g26 - 1);
HXDLIN(  80)									{
HXLINE(  80)										 ::haxe::io::ArrayBufferViewImpl this82 = b18->data;
HXDLIN(  80)										bool undoImage5;
HXDLIN(  80)										if ((i19 >= 0)) {
HXLINE(  80)											undoImage5 = (i19 < (this82->byteLength >> 2));
            										}
            										else {
HXLINE(  80)											undoImage5 = false;
            										}
HXDLIN(  80)										if (undoImage5) {
HXLINE(  80)											 ::haxe::io::Bytes _this1 = this82->bytes;
HXDLIN(  80)											int pos1 = ((i19 << 2) + this82->byteOffset);
HXDLIN(  80)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  80)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  80)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  80)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  80)						undoImage4 = b18;
            					}
            					break;
            					case (int)3: {
HXLINE(  80)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  80)						{
HXLINE(  80)							v3->width = width1;
HXDLIN(  80)							v3->height = height1;
HXDLIN(  80)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  80)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  80)							{
HXLINE(  80)								int _g28 = 0;
HXDLIN(  80)								int _g29 = v3->length;
HXDLIN(  80)								while((_g28 < _g29)){
HXLINE(  80)									_g28 = (_g28 + 1);
HXDLIN(  80)									int i20 = (_g28 - 1);
HXDLIN(  80)									v3->data->__unsafe_set(i20,0);
            								}
            							}
            						}
HXDLIN(  80)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE(  80)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  80)						 ::iterMagic::StackIntImg b19 = sInt1;
HXDLIN(  80)						{
HXLINE(  80)							b19->width = width1;
HXDLIN(  80)							b19->height = height1;
HXDLIN(  80)							b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  80)							b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  80)							{
HXLINE(  80)								int len3 = b19->length;
HXDLIN(  80)								 ::haxe::ds::GenericStack_Int d1 = b19->data;
HXDLIN(  80)								if (::hx::IsNull( d1->head )) {
HXLINE(  80)									int _g30 = 0;
HXDLIN(  80)									int _g31 = len3;
HXDLIN(  80)									while((_g30 < _g31)){
HXLINE(  80)										_g30 = (_g30 + 1);
HXDLIN(  80)										int i21 = (_g30 - 1);
HXDLIN(  80)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE(  80)									int _g32 = 0;
HXDLIN(  80)									int _g33 = len3;
HXDLIN(  80)									while((_g32 < _g33)){
HXLINE(  80)										_g32 = (_g32 + 1);
HXDLIN(  80)										int i22 = (_g32 - 1);
HXDLIN(  80)										{
HXLINE(  80)											 ::haxe::ds::GenericCell_Int l1 = b19->data->head;
HXDLIN(  80)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  80)											{
HXLINE(  80)												int _g34 = 0;
HXDLIN(  80)												int _g35 = i22;
HXDLIN(  80)												while((_g34 < _g35)){
HXLINE(  80)													_g34 = (_g34 + 1);
HXDLIN(  80)													int i23 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  80)											if (::hx::IsNull( prev1 )) {
HXLINE(  80)												b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  80)												l1 = null();
            											}
            											else {
HXLINE(  80)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  80)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  80)						undoImage4 = b19;
            					}
            					break;
            				}
HXDLIN(  80)				this81->image = undoImage4;
HXDLIN(  80)				this81->width = width1;
HXDLIN(  80)				this81->height = height1;
HXDLIN(  80)				this81->imageType = ( (int)(imageType1) );
HXDLIN(  80)				undoImage3 = this81;
HXDLIN(  80)				{
HXLINE(  80)					int rectLeft1 = xIter31->start;
HXDLIN(  80)					int rectTop1 = yIter31->start;
HXDLIN(  80)					int rectRight1 = xIter31->max;
HXDLIN(  80)					bool forceClear1 = false;
HXDLIN(  80)					{
HXLINE(  80)						int _g36 = rectTop1;
HXDLIN(  80)						int _g37 = yIter31->max;
HXDLIN(  80)						while((_g36 < _g37)){
HXLINE(  80)							_g36 = (_g36 + 1);
HXDLIN(  80)							int dy2 = (_g36 - 1);
HXDLIN(  80)							{
HXLINE(  80)								int _g38 = rectLeft1;
HXDLIN(  80)								int _g39 = rectRight1;
HXDLIN(  80)								while((_g38 < _g39)){
HXLINE(  80)									_g38 = (_g38 + 1);
HXDLIN(  80)									int dx2 = (_g38 - 1);
HXDLIN(  80)									::Dynamic this83 = this1->image;
HXDLIN(  80)									int index8;
HXDLIN(  80)									if (this1->useVirtualPos) {
HXLINE(  80)										index8 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            									}
            									else {
HXLINE(  80)										index8 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            									}
HXDLIN(  80)									int c7 = ::iterMagic::Iimg_obj::get(this83,index8);
HXDLIN(  80)									int col1;
HXDLIN(  80)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)										col1 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXLINE(  80)										col1 = c7;
            									}
HXDLIN(  80)									bool _hx_tmp20;
HXDLIN(  80)									if (this1->useMask) {
HXLINE(  80)										_hx_tmp20 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  80)										_hx_tmp20 = false;
            									}
HXDLIN(  80)									if (_hx_tmp20) {
HXLINE(  80)										 ::pi_xy::ImageStruct this84 = this1->mask;
HXDLIN(  80)										::Dynamic this85 = this84->image;
HXDLIN(  80)										int index9;
HXDLIN(  80)										if (this84->useVirtualPos) {
HXLINE(  80)											index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this84->virtualY) * ( (Float)(this84->width) )) + dx2) - this84->virtualX));
            										}
            										else {
HXLINE(  80)											index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * this84->width) + dx2)) ));
            										}
HXDLIN(  80)										int c8 = ::iterMagic::Iimg_obj::get(this85,index9);
HXDLIN(  80)										int v4;
HXDLIN(  80)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)											v4 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE(  80)											v4 = c8;
            										}
HXDLIN(  80)										int maskPixel1 = v4;
HXDLIN(  80)										int this86 = col1;
HXDLIN(  80)										if ((maskPixel1 == 0)) {
HXLINE(  80)											col1 = this86;
            										}
            										else {
HXLINE(  80)											Float m01;
HXDLIN(  80)											int this87 = ((maskPixel1 >> 24) & 255);
HXDLIN(  80)											if ((this87 == 0)) {
HXLINE(  80)												m01 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												m01 = (( (Float)(this87) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float m11;
HXDLIN(  80)											int this88 = ((maskPixel1 >> 16) & 255);
HXDLIN(  80)											if ((this88 == 0)) {
HXLINE(  80)												m11 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												m11 = (( (Float)(this88) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float m21;
HXDLIN(  80)											int this89 = ((maskPixel1 >> 8) & 255);
HXDLIN(  80)											if ((this89 == 0)) {
HXLINE(  80)												m21 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												m21 = (( (Float)(this89) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float m31;
HXDLIN(  80)											int this90 = (maskPixel1 & 255);
HXDLIN(  80)											if ((this90 == 0)) {
HXLINE(  80)												m31 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												m31 = (( (Float)(this90) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this86 >> 24) & 255)) )));
HXDLIN(  80)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this86 >> 16) & 255)) )));
HXDLIN(  80)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this86 >> 8) & 255)) )));
HXDLIN(  80)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this86 & 255)) )));
HXDLIN(  80)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  80)									if ((col1 != 0)) {
HXLINE(  80)										int x8 = (dx2 - rectLeft1);
HXDLIN(  80)										int y8 = (dy2 - rectTop1);
HXDLIN(  80)										int c9 = col1;
HXDLIN(  80)										bool _hx_tmp21;
HXDLIN(  80)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE(  80)											_hx_tmp21 = undoImage3->transparent;
            										}
            										else {
HXLINE(  80)											_hx_tmp21 = false;
            										}
HXDLIN(  80)										if (_hx_tmp21) {
HXLINE(  80)											int location6;
HXDLIN(  80)											if (undoImage3->useVirtualPos) {
HXLINE(  80)												location6 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  80)												location6 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            											}
HXDLIN(  80)											int this91 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN(  80)											int this92;
HXDLIN(  80)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)												this92 = ((((((this91 >> 24) & 255) << 24) | ((this91 & 255) << 16)) | (((this91 >> 8) & 255) << 8)) | ((this91 >> 16) & 255));
            											}
            											else {
HXLINE(  80)												this92 = this91;
            											}
HXDLIN(  80)											Float a18;
HXDLIN(  80)											int this93 = ((this92 >> 24) & 255);
HXDLIN(  80)											if ((this93 == 0)) {
HXLINE(  80)												a18 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												a18 = (( (Float)(this93) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float r16;
HXDLIN(  80)											int this94 = ((this92 >> 16) & 255);
HXDLIN(  80)											if ((this94 == 0)) {
HXLINE(  80)												r16 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												r16 = (( (Float)(this94) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float g16;
HXDLIN(  80)											int this95 = ((this92 >> 8) & 255);
HXDLIN(  80)											if ((this95 == 0)) {
HXLINE(  80)												g16 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												g16 = (( (Float)(this95) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float b110;
HXDLIN(  80)											int this96 = (this92 & 255);
HXDLIN(  80)											if ((this96 == 0)) {
HXLINE(  80)												b110 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												b110 = (( (Float)(this96) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float a26;
HXDLIN(  80)											int this97 = ((col1 >> 24) & 255);
HXDLIN(  80)											if ((this97 == 0)) {
HXLINE(  80)												a26 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												a26 = (( (Float)(this97) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float r26;
HXDLIN(  80)											int this98 = ((col1 >> 16) & 255);
HXDLIN(  80)											if ((this98 == 0)) {
HXLINE(  80)												r26 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												r26 = (( (Float)(this98) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float g26;
HXDLIN(  80)											int this99 = ((col1 >> 8) & 255);
HXDLIN(  80)											if ((this99 == 0)) {
HXLINE(  80)												g26 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												g26 = (( (Float)(this99) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float b26;
HXDLIN(  80)											int this100 = (col1 & 255);
HXDLIN(  80)											if ((this100 == 0)) {
HXLINE(  80)												b26 = ((Float)0.);
            											}
            											else {
HXLINE(  80)												b26 = (( (Float)(this100) ) / ( (Float)(255) ));
            											}
HXDLIN(  80)											Float a36 = (a18 * (( (Float)(1) ) - a26));
HXDLIN(  80)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  80)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  80)											int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b26 * a26))));
HXDLIN(  80)											int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  80)											int blended6 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN(  80)											{
HXLINE(  80)												int _hx_tmp22;
HXDLIN(  80)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)													_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXLINE(  80)													_hx_tmp22 = blended6;
            												}
HXDLIN(  80)												::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            											}
            										}
            										else {
HXLINE(  80)											::Dynamic this101 = undoImage3->image;
HXDLIN(  80)											int index10;
HXDLIN(  80)											if (undoImage3->useVirtualPos) {
HXLINE(  80)												index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  80)												index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            											}
HXDLIN(  80)											int _hx_tmp23;
HXDLIN(  80)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)												_hx_tmp23 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE(  80)												_hx_tmp23 = c9;
            											}
HXDLIN(  80)											::iterMagic::Iimg_obj::set(this101,index10,_hx_tmp23);
            										}
            									}
            									else {
HXLINE(  80)										if (forceClear1) {
HXLINE(  80)											::Dynamic this102 = undoImage3->image;
HXDLIN(  80)											int x9 = (dx2 - rectLeft1);
HXDLIN(  80)											int y9 = (dy2 - rectTop1);
HXDLIN(  80)											int index11;
HXDLIN(  80)											if (undoImage3->useVirtualPos) {
HXLINE(  80)												index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  80)												index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            											}
HXDLIN(  80)											::iterMagic::Iimg_obj::set(this102,index11,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  80)			{
HXLINE(  80)				int _g_min2 = xIter31->start;
HXDLIN(  80)				int _g_max2 = xIter31->max;
HXDLIN(  80)				while((_g_min2 < _g_max2)){
HXLINE(  80)					_g_min2 = (_g_min2 + 1);
HXDLIN(  80)					int px2 = (_g_min2 - 1);
HXDLIN(  80)					Float pcx1 = (( (Float)(px2) ) - dx);
HXDLIN(  80)					{
HXLINE(  80)						int _g_min3 = yIter31->start;
HXDLIN(  80)						int _g_max3 = yIter31->max;
HXDLIN(  80)						while((_g_min3 < _g_max3)){
HXLINE(  80)							_g_min3 = (_g_min3 + 1);
HXDLIN(  80)							int py2 = (_g_min3 - 1);
HXDLIN(  80)							Float pcy1 = (( (Float)(py2) ) - dy);
HXDLIN(  80)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  80)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  80)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  80)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  80)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  80)							bool _hx_tmp24;
HXDLIN(  80)							bool _hx_tmp25;
HXDLIN(  80)							if ((ratioA1 >= 0)) {
HXLINE(  80)								_hx_tmp25 = (ratioB1 >= 0);
            							}
            							else {
HXLINE(  80)								_hx_tmp25 = false;
            							}
HXDLIN(  80)							if (_hx_tmp25) {
HXLINE(  80)								_hx_tmp24 = (ratioC1 >= 0);
            							}
            							else {
HXLINE(  80)								_hx_tmp24 = false;
            							}
HXDLIN(  80)							if (_hx_tmp24) {
HXLINE(  80)								int i24 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN(  80)								if ((i24 > 255)) {
HXLINE(  24)									i24 = 255;
            								}
HXLINE(  80)								if ((i24 < 0)) {
HXLINE(  25)									i24 = 0;
            								}
HXLINE(  80)								int a20 = i24;
HXDLIN(  80)								int i25 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN(  80)								if ((i25 > 255)) {
HXLINE(  24)									i25 = 255;
            								}
HXLINE(  80)								if ((i25 < 0)) {
HXLINE(  25)									i25 = 0;
            								}
HXLINE(  80)								int r10 = i25;
HXDLIN(  80)								int i26 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN(  80)								if ((i26 > 255)) {
HXLINE(  24)									i26 = 255;
            								}
HXLINE(  80)								if ((i26 < 0)) {
HXLINE(  25)									i26 = 0;
            								}
HXLINE(  80)								int g10 = i26;
HXDLIN(  80)								int i27 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN(  80)								if ((i27 > 255)) {
HXLINE(  24)									i27 = 255;
            								}
HXLINE(  80)								if ((i27 < 0)) {
HXLINE(  25)									i27 = 0;
            								}
HXLINE(  80)								int b27 = i27;
HXDLIN(  80)								{
HXLINE(  80)									int location7;
HXDLIN(  80)									if (this1->useVirtualPos) {
HXLINE(  80)										location7 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this1->virtualY) * ( (Float)(this1->width) )) + px2) - this1->virtualX));
            									}
            									else {
HXLINE(  80)										location7 = ::Std_obj::_hx_int(( (Float)(((py2 * this1->width) + px2)) ));
            									}
HXDLIN(  80)									bool _hx_tmp26;
HXDLIN(  80)									if (this1->transparent) {
HXLINE(  80)										_hx_tmp26 = (a20 < 254);
            									}
            									else {
HXLINE(  80)										_hx_tmp26 = false;
            									}
HXDLIN(  80)									if (_hx_tmp26) {
HXLINE(  80)										int this103 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN(  80)										int old1;
HXDLIN(  80)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)											old1 = ((((((this103 >> 24) & 255) << 24) | ((this103 & 255) << 16)) | (((this103 >> 8) & 255) << 8)) | ((this103 >> 16) & 255));
            										}
            										else {
HXLINE(  80)											old1 = this103;
            										}
HXDLIN(  80)										int rhs1 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b27);
HXDLIN(  80)										Float a110;
HXDLIN(  80)										int this104 = ((old1 >> 24) & 255);
HXDLIN(  80)										if ((this104 == 0)) {
HXLINE(  80)											a110 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											a110 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float r17;
HXDLIN(  80)										int this105 = ((old1 >> 16) & 255);
HXDLIN(  80)										if ((this105 == 0)) {
HXLINE(  80)											r17 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											r17 = (( (Float)(this105) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float g17;
HXDLIN(  80)										int this106 = ((old1 >> 8) & 255);
HXDLIN(  80)										if ((this106 == 0)) {
HXLINE(  80)											g17 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											g17 = (( (Float)(this106) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float b111;
HXDLIN(  80)										int this107 = (old1 & 255);
HXDLIN(  80)										if ((this107 == 0)) {
HXLINE(  80)											b111 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											b111 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float a27;
HXDLIN(  80)										int this108 = ((rhs1 >> 24) & 255);
HXDLIN(  80)										if ((this108 == 0)) {
HXLINE(  80)											a27 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											a27 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float r27;
HXDLIN(  80)										int this109 = ((rhs1 >> 16) & 255);
HXDLIN(  80)										if ((this109 == 0)) {
HXLINE(  80)											r27 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											r27 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float g27;
HXDLIN(  80)										int this110 = ((rhs1 >> 8) & 255);
HXDLIN(  80)										if ((this110 == 0)) {
HXLINE(  80)											g27 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											g27 = (( (Float)(this110) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float b28;
HXDLIN(  80)										int this111 = (rhs1 & 255);
HXDLIN(  80)										if ((this111 == 0)) {
HXLINE(  80)											b28 = ((Float)0.);
            										}
            										else {
HXLINE(  80)											b28 = (( (Float)(this111) ) / ( (Float)(255) ));
            										}
HXDLIN(  80)										Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN(  80)										int r18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  80)										int g18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  80)										int b29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b28 * a27))));
HXDLIN(  80)										int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  80)										int blended7 = ((((a28 << 24) | (r18 << 16)) | (g18 << 8)) | b29);
HXDLIN(  80)										{
HXLINE(  80)											int _hx_tmp27;
HXDLIN(  80)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  80)												_hx_tmp27 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXLINE(  80)												_hx_tmp27 = blended7;
            											}
HXDLIN(  80)											::iterMagic::Iimg_obj::set(this1->image,location7,_hx_tmp27);
            										}
            									}
            									else {
HXLINE(  80)										int value1;
HXDLIN(  80)										if (this1->isLittle) {
HXLINE(  80)											value1 = ((((a20 << 24) | (b27 << 16)) | (g10 << 8)) | r10);
            										}
            										else {
HXLINE(  80)											value1 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b27);
            										}
HXDLIN(  80)										::iterMagic::Iimg_obj::set(this1->image,location7,value1);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  80)			if ((hasHit1 == false)) {
HXLINE(  80)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  80)				if (hasUndo1) {
HXLINE(  80)					v5->undoImage = undoImage3;
HXDLIN(  80)					v5->undoX = xIter31->start;
HXDLIN(  80)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXDLIN(  80)		if ((hasHit == true)) {
HXLINE(  80)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  80)			return v6;
            		}
            		else {
HXLINE(  80)			return null();
            		}
HXDLIN(  80)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(GradientShape_Impl__obj,line,return )

void GradientShape_Impl__obj::radialPolyon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int colorIn,int colorOut,::hx::Null< Float >  __o_gx,::hx::Null< Float >  __o_gy, ::Dynamic __o_phi, ::Dynamic __o_sides,::hx::Null< bool >  __o_cornerUp){
            		Float gx = __o_gx.Default(((Float)0.));
            		Float gy = __o_gy.Default(((Float)0.));
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		bool cornerUp = __o_cornerUp.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_93_radialPolyon)
HXDLIN(  93)		 ::Dynamic gx1 = gx;
HXDLIN(  93)		 ::Dynamic gy1 = gy;
HXDLIN(  93)		 ::Dynamic phi1 = phi;
HXDLIN(  93)		 ::Dynamic sides1 = sides;
HXLINE(  98)		if (::hx::IsNull( sides1 )) {
HXLINE(  98)			sides1 = 36;
            		}
HXDLIN(  98)		if (::hx::IsNull( phi1 )) {
HXLINE(  98)			phi1 = ((Float)0.);
            		}
HXLINE(  97)		if (::hx::IsNull( gy1 )) {
HXLINE(  97)			gy1 = 0;
            		}
HXDLIN(  97)		if (::hx::IsNull( gx1 )) {
HXLINE(  97)			gx1 = 0;
            		}
HXLINE(  93)		if (::hx::IsLess( gx1,((Float)-1.) )) {
HXLINE( 193)			gx1 = -1;
            		}
HXLINE(  93)		if (::hx::IsGreater( gx1,((Float)1.) )) {
HXLINE( 194)			gx1 = 1;
            		}
HXLINE(  93)		if (::hx::IsLess( gy1,((Float)-1.) )) {
HXLINE( 195)			gy1 = ((Float)-1.);
            		}
HXLINE(  93)		if (::hx::IsGreater( gy1,((Float)1.) )) {
HXLINE( 196)			gy1 = 1;
            		}
HXLINE(  93)		Float mx = (cx + (( (Float)(gx1) ) * rx));
HXDLIN(  93)		Float my = (cy + (( (Float)(gy1) ) * ry));
HXDLIN(  93)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  93)		Float omega;
HXDLIN(  93)		if (cornerUp) {
HXDLIN(  93)			omega = ((Float)0.);
            		}
            		else {
HXDLIN(  93)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN(  93)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN(  93)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN(  93)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN(  93)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  93)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
            		}
HXDLIN(  93)		Float lastX = ((Float)0.);
HXDLIN(  93)		Float lastY = ((Float)0.);
HXDLIN(  93)		if (::hx::IsNotEq( phi1,0 )) {
HXLINE( 221)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi1) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi1) )))) + cx);
HXLINE( 222)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi1) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi1) )))) + cy);
            		}
            		else {
HXLINE( 224)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE( 225)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            		}
HXLINE(  93)		if (::hx::IsNotEq( phi1,0 )) {
HXDLIN(  93)			Float cphi = ::Math_obj::cos(( (Float)(phi1) ));
HXDLIN(  93)			Float sphi = ::Math_obj::sin(( (Float)(phi1) ));
HXDLIN(  93)			{
HXDLIN(  93)				int _g = 0;
HXDLIN(  93)				int _g1 = (sides1 + 1);
HXDLIN(  93)				while((_g < _g1)){
HXDLIN(  93)					_g = (_g + 1);
HXDLIN(  93)					int i = (_g - 1);
HXDLIN(  93)					Float stheta = ::Math_obj::sin(((( (Float)(i) ) * theta) + omega));
HXDLIN(  93)					Float ctheta = ::Math_obj::cos(((( (Float)(i) ) * theta) + omega));
HXDLIN(  93)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN(  93)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN(  93)					{
HXDLIN(  93)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  93)						{
HXDLIN(  93)							bool hasHit = false;
HXDLIN(  93)							bool hasUndo = false;
HXDLIN(  93)							int aA = ((colorOut >> 24) & 255);
HXDLIN(  93)							int rA = ((colorOut >> 16) & 255);
HXDLIN(  93)							int gA = ((colorOut >> 8) & 255);
HXDLIN(  93)							int bA = (colorOut & 255);
HXDLIN(  93)							int aB = ((colorIn >> 24) & 255);
HXDLIN(  93)							int rB = ((colorIn >> 16) & 255);
HXDLIN(  93)							int gB = ((colorIn >> 8) & 255);
HXDLIN(  93)							int bB = (colorIn & 255);
HXDLIN(  93)							int aC = ((colorOut >> 24) & 255);
HXDLIN(  93)							int rC = ((colorOut >> 16) & 255);
HXDLIN(  93)							int gC = ((colorOut >> 8) & 255);
HXDLIN(  93)							int bC = (colorOut & 255);
HXDLIN(  93)							Float bcx = (lastX - nextX);
HXDLIN(  93)							Float bcy = (lastY - nextY);
HXDLIN(  93)							Float acx = (mx - nextX);
HXDLIN(  93)							Float acy = (my - nextY);
HXDLIN(  93)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  93)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  93)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  93)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  93)							 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  93)							if ((mx > lastX)) {
HXDLIN(  93)								if ((mx > nextX)) {
HXDLIN(  93)									int min;
HXDLIN(  93)									if ((lastX > nextX)) {
HXDLIN(  93)										min = ::Math_obj::floor(nextX);
            									}
            									else {
HXDLIN(  93)										min = ::Math_obj::floor(lastX);
            									}
HXDLIN(  93)									int ii_min = min;
HXDLIN(  93)									int ii_max = ::Math_obj::ceil(mx);
HXDLIN(  93)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            								}
            								else {
HXDLIN(  93)									int ii_min1 = ::Math_obj::floor(lastX);
HXDLIN(  93)									int ii_max1 = ::Math_obj::ceil(nextX);
HXDLIN(  93)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            								}
            							}
            							else {
HXDLIN(  93)								if ((lastX > nextX)) {
HXDLIN(  93)									int min1;
HXDLIN(  93)									if ((mx > nextX)) {
HXDLIN(  93)										min1 = ::Math_obj::floor(nextX);
            									}
            									else {
HXDLIN(  93)										min1 = ::Math_obj::ceil(mx);
            									}
HXDLIN(  93)									int ii_min2 = min1;
HXDLIN(  93)									int ii_max2 = ::Math_obj::ceil(lastX);
HXDLIN(  93)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            								}
            								else {
HXDLIN(  93)									int ii_min3 = ::Math_obj::floor(mx);
HXDLIN(  93)									int ii_max3 = ::Math_obj::ceil(nextX);
HXDLIN(  93)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            								}
            							}
HXDLIN(  93)							 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  93)							if ((my > lastY)) {
HXDLIN(  93)								if ((my > nextY)) {
HXDLIN(  93)									int min2;
HXDLIN(  93)									if ((lastY > nextY)) {
HXDLIN(  93)										min2 = ::Math_obj::floor(nextY);
            									}
            									else {
HXDLIN(  93)										min2 = ::Math_obj::floor(lastY);
            									}
HXDLIN(  93)									int ii_min4 = min2;
HXDLIN(  93)									int ii_max4 = ::Math_obj::ceil(my);
HXDLIN(  93)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            								}
            								else {
HXDLIN(  93)									int ii_min5 = ::Math_obj::floor(lastY);
HXDLIN(  93)									int ii_max5 = ::Math_obj::ceil(nextY);
HXDLIN(  93)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            								}
            							}
            							else {
HXDLIN(  93)								if ((lastY > nextY)) {
HXDLIN(  93)									int min3;
HXDLIN(  93)									if ((my > nextY)) {
HXDLIN(  93)										min3 = ::Math_obj::floor(nextY);
            									}
            									else {
HXDLIN(  93)										min3 = ::Math_obj::ceil(my);
            									}
HXDLIN(  93)									int ii_min6 = min3;
HXDLIN(  93)									int ii_max6 = ::Math_obj::ceil(lastY);
HXDLIN(  93)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            								}
            								else {
HXDLIN(  93)									int ii_min7 = ::Math_obj::floor(my);
HXDLIN(  93)									int ii_max7 = ::Math_obj::ceil(nextY);
HXDLIN(  93)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            								}
            							}
HXDLIN(  93)							 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  93)							if (hasUndo) {
HXDLIN(  93)								int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  93)								int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  93)								 ::Dynamic imageType = null();
HXDLIN(  93)								 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  93)								if (::hx::IsNull( imageType )) {
HXLINE(  54)									imageType = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  93)								::Dynamic undoImage1;
HXDLIN(  93)								switch((int)(( (int)(imageType) ))){
            									case (int)0: {
HXDLIN(  93)										 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  93)										 ::iterMagic::BytesImg b = byt;
HXDLIN(  93)										{
HXDLIN(  93)											b->width = width;
HXDLIN(  93)											b->height = height;
HXDLIN(  93)											b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)											b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  93)											{
HXDLIN(  93)												int len = b->length;
HXDLIN(  93)												int w = 0;
HXDLIN(  93)												{
HXDLIN(  93)													int _g2 = 0;
HXDLIN(  93)													int _g3 = b->height;
HXDLIN(  93)													while((_g2 < _g3)){
HXDLIN(  93)														_g2 = (_g2 + 1);
HXDLIN(  93)														int y = (_g2 - 1);
HXDLIN(  93)														{
HXDLIN(  93)															int _g4 = 0;
HXDLIN(  93)															int _g5 = b->width;
HXDLIN(  93)															while((_g4 < _g5)){
HXDLIN(  93)																_g4 = (_g4 + 1);
HXDLIN(  93)																int x = (_g4 - 1);
HXDLIN(  93)																{
HXDLIN(  93)																	w = (w + 1);
HXDLIN(  93)																	b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  93)																{
HXDLIN(  93)																	w = (w + 1);
HXDLIN(  93)																	b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  93)																{
HXDLIN(  93)																	w = (w + 1);
HXDLIN(  93)																	b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  93)																{
HXDLIN(  93)																	w = (w + 1);
HXDLIN(  93)																	b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  93)										undoImage1 = b;
            									}
            									break;
            									case (int)1: {
HXDLIN(  93)										 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)										 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  93)										{
HXDLIN(  93)											a->width = width;
HXDLIN(  93)											a->height = height;
HXDLIN(  93)											a->data = ::Array_obj< int >::__new(0);
HXDLIN(  93)											a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)											{
HXDLIN(  93)												int _g6 = 0;
HXDLIN(  93)												int _g7 = a->length;
HXDLIN(  93)												while((_g6 < _g7)){
HXDLIN(  93)													_g6 = (_g6 + 1);
HXDLIN(  93)													int i1 = (_g6 - 1);
HXDLIN(  93)													a->data[i1] = 0;
            												}
            											}
            										}
HXDLIN(  93)										undoImage1 = a;
            									}
            									break;
            									case (int)2: {
HXDLIN(  93)										 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  93)										 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  93)										{
HXDLIN(  93)											b1->width = width;
HXDLIN(  93)											b1->height = height;
HXDLIN(  93)											b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)											int size = (b1->length * 4);
HXDLIN(  93)											b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)											{
HXDLIN(  93)												int _g8 = 0;
HXDLIN(  93)												int _g9 = b1->length;
HXDLIN(  93)												while((_g8 < _g9)){
HXDLIN(  93)													_g8 = (_g8 + 1);
HXDLIN(  93)													int i2 = (_g8 - 1);
HXDLIN(  93)													{
HXDLIN(  93)														 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN(  93)														bool undoImage2;
HXDLIN(  93)														if ((i2 >= 0)) {
HXDLIN(  93)															undoImage2 = (i2 < (this4->byteLength >> 2));
            														}
            														else {
HXDLIN(  93)															undoImage2 = false;
            														}
HXDLIN(  93)														if (undoImage2) {
HXDLIN(  93)															 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN(  93)															int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN(  93)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  93)										undoImage1 = b1;
            									}
            									break;
            									case (int)3: {
HXDLIN(  93)										 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)										 ::iterMagic::VecIntImg v1 = vec;
HXDLIN(  93)										{
HXDLIN(  93)											v1->width = width;
HXDLIN(  93)											v1->height = height;
HXDLIN(  93)											v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)											v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(  93)											{
HXDLIN(  93)												int _g10 = 0;
HXDLIN(  93)												int _g11 = v1->length;
HXDLIN(  93)												while((_g10 < _g11)){
HXDLIN(  93)													_g10 = (_g10 + 1);
HXDLIN(  93)													int i3 = (_g10 - 1);
HXDLIN(  93)													v1->data->__unsafe_set(i3,0);
            												}
            											}
            										}
HXDLIN(  93)										undoImage1 = v1;
            									}
            									break;
            									case (int)4: {
HXDLIN(  93)										 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)										 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  93)										{
HXDLIN(  93)											b2->width = width;
HXDLIN(  93)											b2->height = height;
HXDLIN(  93)											b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)											b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  93)											{
HXDLIN(  93)												int len1 = b2->length;
HXDLIN(  93)												 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  93)												if (::hx::IsNull( d->head )) {
HXDLIN(  93)													int _g12 = 0;
HXDLIN(  93)													int _g13 = len1;
HXDLIN(  93)													while((_g12 < _g13)){
HXDLIN(  93)														_g12 = (_g12 + 1);
HXDLIN(  93)														int i4 = (_g12 - 1);
HXDLIN(  93)														d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            													}
            												}
            												else {
HXDLIN(  93)													int _g14 = 0;
HXDLIN(  93)													int _g15 = len1;
HXDLIN(  93)													while((_g14 < _g15)){
HXDLIN(  93)														_g14 = (_g14 + 1);
HXDLIN(  93)														int i5 = (_g14 - 1);
HXDLIN(  93)														{
HXDLIN(  93)															 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  93)															 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  93)															{
HXDLIN(  93)																int _g16 = 0;
HXDLIN(  93)																int _g17 = i5;
HXDLIN(  93)																while((_g16 < _g17)){
HXDLIN(  93)																	_g16 = (_g16 + 1);
HXDLIN(  93)																	int i6 = (_g16 - 1);
HXLINE( 345)																	prev = l;
HXLINE( 346)																	l = l->next;
            																}
            															}
HXLINE(  93)															if (::hx::IsNull( prev )) {
HXDLIN(  93)																b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  93)																l = null();
            															}
            															else {
HXDLIN(  93)																prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  93)																l = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  93)										undoImage1 = b2;
            									}
            									break;
            								}
HXDLIN(  93)								this3->image = undoImage1;
HXDLIN(  93)								this3->width = width;
HXDLIN(  93)								this3->height = height;
HXDLIN(  93)								this3->imageType = ( (int)(imageType) );
HXDLIN(  93)								undoImage = this3;
HXDLIN(  93)								{
HXDLIN(  93)									int rectLeft = xIter3->start;
HXDLIN(  93)									int rectTop = yIter3->start;
HXDLIN(  93)									int rectRight = xIter3->max;
HXDLIN(  93)									bool forceClear = false;
HXDLIN(  93)									{
HXDLIN(  93)										int _g18 = rectTop;
HXDLIN(  93)										int _g19 = yIter3->max;
HXDLIN(  93)										while((_g18 < _g19)){
HXDLIN(  93)											_g18 = (_g18 + 1);
HXDLIN(  93)											int dy = (_g18 - 1);
HXDLIN(  93)											{
HXDLIN(  93)												int _g20 = rectLeft;
HXDLIN(  93)												int _g21 = rectRight;
HXDLIN(  93)												while((_g20 < _g21)){
HXDLIN(  93)													_g20 = (_g20 + 1);
HXDLIN(  93)													int dx = (_g20 - 1);
HXDLIN(  93)													::Dynamic this5 = this2->image;
HXDLIN(  93)													int index;
HXDLIN(  93)													if (this2->useVirtualPos) {
HXDLIN(  93)														index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            													}
            													else {
HXDLIN(  93)														index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            													}
HXDLIN(  93)													int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN(  93)													int col;
HXDLIN(  93)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)														col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            													}
            													else {
HXDLIN(  93)														col = c;
            													}
HXDLIN(  93)													bool _hx_tmp;
HXDLIN(  93)													if (this2->useMask) {
HXDLIN(  93)														_hx_tmp = ::hx::IsNotNull( this2->mask );
            													}
            													else {
HXDLIN(  93)														_hx_tmp = false;
            													}
HXDLIN(  93)													if (_hx_tmp) {
HXDLIN(  93)														 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN(  93)														::Dynamic this7 = this6->image;
HXDLIN(  93)														int index1;
HXDLIN(  93)														if (this6->useVirtualPos) {
HXDLIN(  93)															index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            														}
            														else {
HXDLIN(  93)															index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            														}
HXDLIN(  93)														int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN(  93)														int v2;
HXDLIN(  93)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)															v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            														}
            														else {
HXDLIN(  93)															v2 = c1;
            														}
HXDLIN(  93)														int maskPixel = v2;
HXDLIN(  93)														int this8 = col;
HXDLIN(  93)														if ((maskPixel == 0)) {
HXDLIN(  93)															col = this8;
            														}
            														else {
HXDLIN(  93)															Float m0;
HXDLIN(  93)															int this9 = ((maskPixel >> 24) & 255);
HXDLIN(  93)															if ((this9 == 0)) {
HXDLIN(  93)																m0 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float m1;
HXDLIN(  93)															int this10 = ((maskPixel >> 16) & 255);
HXDLIN(  93)															if ((this10 == 0)) {
HXDLIN(  93)																m1 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float m2;
HXDLIN(  93)															int this11 = ((maskPixel >> 8) & 255);
HXDLIN(  93)															if ((this11 == 0)) {
HXDLIN(  93)																m2 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float m3;
HXDLIN(  93)															int this12 = (maskPixel & 255);
HXDLIN(  93)															if ((this12 == 0)) {
HXDLIN(  93)																m3 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN(  93)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN(  93)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN(  93)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN(  93)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  93)													if ((col != 0)) {
HXDLIN(  93)														int x1 = (dx - rectLeft);
HXDLIN(  93)														int y1 = (dy - rectTop);
HXDLIN(  93)														int c2 = col;
HXDLIN(  93)														bool _hx_tmp1;
HXDLIN(  93)														if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  93)															_hx_tmp1 = undoImage->transparent;
            														}
            														else {
HXDLIN(  93)															_hx_tmp1 = false;
            														}
HXDLIN(  93)														if (_hx_tmp1) {
HXDLIN(  93)															int location;
HXDLIN(  93)															if (undoImage->useVirtualPos) {
HXDLIN(  93)																location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  93)																location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            															}
HXDLIN(  93)															int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  93)															int this14;
HXDLIN(  93)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)																this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            															}
            															else {
HXDLIN(  93)																this14 = this13;
            															}
HXDLIN(  93)															Float a1;
HXDLIN(  93)															int this15 = ((this14 >> 24) & 255);
HXDLIN(  93)															if ((this15 == 0)) {
HXDLIN(  93)																a1 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float r1;
HXDLIN(  93)															int this16 = ((this14 >> 16) & 255);
HXDLIN(  93)															if ((this16 == 0)) {
HXDLIN(  93)																r1 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float g1;
HXDLIN(  93)															int this17 = ((this14 >> 8) & 255);
HXDLIN(  93)															if ((this17 == 0)) {
HXDLIN(  93)																g1 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float b11;
HXDLIN(  93)															int this18 = (this14 & 255);
HXDLIN(  93)															if ((this18 == 0)) {
HXDLIN(  93)																b11 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float a2;
HXDLIN(  93)															int this19 = ((col >> 24) & 255);
HXDLIN(  93)															if ((this19 == 0)) {
HXDLIN(  93)																a2 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float r2;
HXDLIN(  93)															int this20 = ((col >> 16) & 255);
HXDLIN(  93)															if ((this20 == 0)) {
HXDLIN(  93)																r2 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float g2;
HXDLIN(  93)															int this21 = ((col >> 8) & 255);
HXDLIN(  93)															if ((this21 == 0)) {
HXDLIN(  93)																g2 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float b21;
HXDLIN(  93)															int this22 = (col & 255);
HXDLIN(  93)															if ((this22 == 0)) {
HXDLIN(  93)																b21 = ((Float)0.);
            															}
            															else {
HXDLIN(  93)																b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            															}
HXDLIN(  93)															Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  93)															int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)															int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)															int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  93)															int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)															int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  93)															{
HXDLIN(  93)																int _hx_tmp2;
HXDLIN(  93)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)																	_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																}
            																else {
HXDLIN(  93)																	_hx_tmp2 = blended;
            																}
HXDLIN(  93)																::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            															}
            														}
            														else {
HXDLIN(  93)															::Dynamic this23 = undoImage->image;
HXDLIN(  93)															int index2;
HXDLIN(  93)															if (undoImage->useVirtualPos) {
HXDLIN(  93)																index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  93)																index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            															}
HXDLIN(  93)															int _hx_tmp3;
HXDLIN(  93)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)																_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            															}
            															else {
HXDLIN(  93)																_hx_tmp3 = c2;
            															}
HXDLIN(  93)															::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            														}
            													}
            													else {
HXDLIN(  93)														if (forceClear) {
HXDLIN(  93)															::Dynamic this24 = undoImage->image;
HXDLIN(  93)															int x2 = (dx - rectLeft);
HXDLIN(  93)															int y2 = (dy - rectTop);
HXDLIN(  93)															int index3;
HXDLIN(  93)															if (undoImage->useVirtualPos) {
HXDLIN(  93)																index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  93)																index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            															}
HXDLIN(  93)															::iterMagic::Iimg_obj::set(this24,index3,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							{
HXDLIN(  93)								int _g_min = xIter3->start;
HXDLIN(  93)								int _g_max = xIter3->max;
HXDLIN(  93)								while((_g_min < _g_max)){
HXDLIN(  93)									_g_min = (_g_min + 1);
HXDLIN(  93)									int px = (_g_min - 1);
HXDLIN(  93)									Float pcx = (( (Float)(px) ) - nextX);
HXDLIN(  93)									{
HXDLIN(  93)										int _g_min1 = yIter3->start;
HXDLIN(  93)										int _g_max1 = yIter3->max;
HXDLIN(  93)										while((_g_min1 < _g_max1)){
HXDLIN(  93)											_g_min1 = (_g_min1 + 1);
HXDLIN(  93)											int py = (_g_min1 - 1);
HXDLIN(  93)											Float pcy = (( (Float)(py) ) - nextY);
HXDLIN(  93)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  93)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  93)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  93)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  93)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  93)											bool _hx_tmp4;
HXDLIN(  93)											bool _hx_tmp5;
HXDLIN(  93)											if ((ratioA >= 0)) {
HXDLIN(  93)												_hx_tmp5 = (ratioB >= 0);
            											}
            											else {
HXDLIN(  93)												_hx_tmp5 = false;
            											}
HXDLIN(  93)											if (_hx_tmp5) {
HXDLIN(  93)												_hx_tmp4 = (ratioC >= 0);
            											}
            											else {
HXDLIN(  93)												_hx_tmp4 = false;
            											}
HXDLIN(  93)											if (_hx_tmp4) {
HXDLIN(  93)												int i7 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  93)												if ((i7 > 255)) {
HXLINE(  24)													i7 = 255;
            												}
HXLINE(  93)												if ((i7 < 0)) {
HXLINE(  25)													i7 = 0;
            												}
HXLINE(  93)												int a5 = i7;
HXDLIN(  93)												int i8 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  93)												if ((i8 > 255)) {
HXLINE(  24)													i8 = 255;
            												}
HXLINE(  93)												if ((i8 < 0)) {
HXLINE(  25)													i8 = 0;
            												}
HXLINE(  93)												int r3 = i8;
HXDLIN(  93)												int i9 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  93)												if ((i9 > 255)) {
HXLINE(  24)													i9 = 255;
            												}
HXLINE(  93)												if ((i9 < 0)) {
HXLINE(  25)													i9 = 0;
            												}
HXLINE(  93)												int g3 = i9;
HXDLIN(  93)												int i10 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  93)												if ((i10 > 255)) {
HXLINE(  24)													i10 = 255;
            												}
HXLINE(  93)												if ((i10 < 0)) {
HXLINE(  25)													i10 = 0;
            												}
HXLINE(  93)												int b4 = i10;
HXDLIN(  93)												{
HXDLIN(  93)													int location1;
HXDLIN(  93)													if (this2->useVirtualPos) {
HXDLIN(  93)														location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this2->virtualY) * ( (Float)(this2->width) )) + px) - this2->virtualX));
            													}
            													else {
HXDLIN(  93)														location1 = ::Std_obj::_hx_int(( (Float)(((py * this2->width) + px)) ));
            													}
HXDLIN(  93)													bool _hx_tmp6;
HXDLIN(  93)													if (this2->transparent) {
HXDLIN(  93)														_hx_tmp6 = (a5 < 254);
            													}
            													else {
HXDLIN(  93)														_hx_tmp6 = false;
            													}
HXDLIN(  93)													if (_hx_tmp6) {
HXDLIN(  93)														int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN(  93)														int old;
HXDLIN(  93)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)															old = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            														}
            														else {
HXDLIN(  93)															old = this25;
            														}
HXDLIN(  93)														int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  93)														Float a11;
HXDLIN(  93)														int this26 = ((old >> 24) & 255);
HXDLIN(  93)														if ((this26 == 0)) {
HXDLIN(  93)															a11 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float r11;
HXDLIN(  93)														int this27 = ((old >> 16) & 255);
HXDLIN(  93)														if ((this27 == 0)) {
HXDLIN(  93)															r11 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float g11;
HXDLIN(  93)														int this28 = ((old >> 8) & 255);
HXDLIN(  93)														if ((this28 == 0)) {
HXDLIN(  93)															g11 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float b12;
HXDLIN(  93)														int this29 = (old & 255);
HXDLIN(  93)														if ((this29 == 0)) {
HXDLIN(  93)															b12 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float a21;
HXDLIN(  93)														int this30 = ((rhs >> 24) & 255);
HXDLIN(  93)														if ((this30 == 0)) {
HXDLIN(  93)															a21 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float r21;
HXDLIN(  93)														int this31 = ((rhs >> 16) & 255);
HXDLIN(  93)														if ((this31 == 0)) {
HXDLIN(  93)															r21 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float g21;
HXDLIN(  93)														int this32 = ((rhs >> 8) & 255);
HXDLIN(  93)														if ((this32 == 0)) {
HXDLIN(  93)															g21 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float b22;
HXDLIN(  93)														int this33 = (rhs & 255);
HXDLIN(  93)														if ((this33 == 0)) {
HXDLIN(  93)															b22 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  93)														int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  93)														int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  93)														int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  93)														int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  93)														int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  93)														{
HXDLIN(  93)															int _hx_tmp7;
HXDLIN(  93)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)																_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            															}
            															else {
HXDLIN(  93)																_hx_tmp7 = blended1;
            															}
HXDLIN(  93)															::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp7);
            														}
            													}
            													else {
HXDLIN(  93)														int value;
HXDLIN(  93)														if (this2->isLittle) {
HXDLIN(  93)															value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            														}
            														else {
HXDLIN(  93)															value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            														}
HXDLIN(  93)														::iterMagic::Iimg_obj::set(this2->image,location1,value);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							if ((hasHit == false)) {
HXDLIN(  93)								 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX,nextY,true);
HXDLIN(  93)								if (hasUndo) {
HXDLIN(  93)									v3->undoImage = undoImage;
HXDLIN(  93)									v3->undoX = xIter3->start;
HXDLIN(  93)									v3->undoY = yIter3->start;
            								}
            							}
            						}
            					}
HXLINE( 236)					lastX = nextX;
HXLINE( 237)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN(  93)			int _g22 = 0;
HXDLIN(  93)			int _g23 = (sides1 + 1);
HXDLIN(  93)			while((_g22 < _g23)){
HXDLIN(  93)				_g22 = (_g22 + 1);
HXDLIN(  93)				int i11 = (_g22 - 1);
HXDLIN(  93)				Float nextX1 = (cx + (rx * ::Math_obj::cos(((( (Float)(i11) ) * theta) + omega))));
HXDLIN(  93)				Float nextY1 = (cy + (ry * ::Math_obj::sin(((( (Float)(i11) ) * theta) + omega))));
HXDLIN(  93)				{
HXDLIN(  93)					 ::pi_xy::ImageStruct this34 = this1;
HXDLIN(  93)					{
HXDLIN(  93)						bool hasHit1 = false;
HXDLIN(  93)						bool hasUndo1 = false;
HXDLIN(  93)						int aA1 = ((colorOut >> 24) & 255);
HXDLIN(  93)						int rA1 = ((colorOut >> 16) & 255);
HXDLIN(  93)						int gA1 = ((colorOut >> 8) & 255);
HXDLIN(  93)						int bA1 = (colorOut & 255);
HXDLIN(  93)						int aB1 = ((colorIn >> 24) & 255);
HXDLIN(  93)						int rB1 = ((colorIn >> 16) & 255);
HXDLIN(  93)						int gB1 = ((colorIn >> 8) & 255);
HXDLIN(  93)						int bB1 = (colorIn & 255);
HXDLIN(  93)						int aC1 = ((colorOut >> 24) & 255);
HXDLIN(  93)						int rC1 = ((colorOut >> 16) & 255);
HXDLIN(  93)						int gC1 = ((colorOut >> 8) & 255);
HXDLIN(  93)						int bC1 = (colorOut & 255);
HXDLIN(  93)						Float bcx1 = (lastX - nextX1);
HXDLIN(  93)						Float bcy1 = (lastY - nextY1);
HXDLIN(  93)						Float acx1 = (mx - nextX1);
HXDLIN(  93)						Float acy1 = (my - nextY1);
HXDLIN(  93)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  93)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  93)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  93)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  93)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  93)						if ((mx > lastX)) {
HXDLIN(  93)							if ((mx > nextX1)) {
HXDLIN(  93)								int min4;
HXDLIN(  93)								if ((lastX > nextX1)) {
HXDLIN(  93)									min4 = ::Math_obj::floor(nextX1);
            								}
            								else {
HXDLIN(  93)									min4 = ::Math_obj::floor(lastX);
            								}
HXDLIN(  93)								int ii_min8 = min4;
HXDLIN(  93)								int ii_max8 = ::Math_obj::ceil(mx);
HXDLIN(  93)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            							else {
HXDLIN(  93)								int ii_min9 = ::Math_obj::floor(lastX);
HXDLIN(  93)								int ii_max9 = ::Math_obj::ceil(nextX1);
HXDLIN(  93)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            						}
            						else {
HXDLIN(  93)							if ((lastX > nextX1)) {
HXDLIN(  93)								int min5;
HXDLIN(  93)								if ((mx > nextX1)) {
HXDLIN(  93)									min5 = ::Math_obj::floor(nextX1);
            								}
            								else {
HXDLIN(  93)									min5 = ::Math_obj::ceil(mx);
            								}
HXDLIN(  93)								int ii_min10 = min5;
HXDLIN(  93)								int ii_max10 = ::Math_obj::ceil(lastX);
HXDLIN(  93)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            							else {
HXDLIN(  93)								int ii_min11 = ::Math_obj::floor(mx);
HXDLIN(  93)								int ii_max11 = ::Math_obj::ceil(nextX1);
HXDLIN(  93)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            						}
HXDLIN(  93)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  93)						if ((my > lastY)) {
HXDLIN(  93)							if ((my > nextY1)) {
HXDLIN(  93)								int min6;
HXDLIN(  93)								if ((lastY > nextY1)) {
HXDLIN(  93)									min6 = ::Math_obj::floor(nextY1);
            								}
            								else {
HXDLIN(  93)									min6 = ::Math_obj::floor(lastY);
            								}
HXDLIN(  93)								int ii_min12 = min6;
HXDLIN(  93)								int ii_max12 = ::Math_obj::ceil(my);
HXDLIN(  93)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            							else {
HXDLIN(  93)								int ii_min13 = ::Math_obj::floor(lastY);
HXDLIN(  93)								int ii_max13 = ::Math_obj::ceil(nextY1);
HXDLIN(  93)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            						}
            						else {
HXDLIN(  93)							if ((lastY > nextY1)) {
HXDLIN(  93)								int min7;
HXDLIN(  93)								if ((my > nextY1)) {
HXDLIN(  93)									min7 = ::Math_obj::floor(nextY1);
            								}
            								else {
HXDLIN(  93)									min7 = ::Math_obj::ceil(my);
            								}
HXDLIN(  93)								int ii_min14 = min7;
HXDLIN(  93)								int ii_max14 = ::Math_obj::ceil(lastY);
HXDLIN(  93)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            							else {
HXDLIN(  93)								int ii_min15 = ::Math_obj::floor(my);
HXDLIN(  93)								int ii_max15 = ::Math_obj::ceil(nextY1);
HXDLIN(  93)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            						}
HXDLIN(  93)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  93)						if (hasUndo1) {
HXDLIN(  93)							int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  93)							int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  93)							 ::Dynamic imageType1 = null();
HXDLIN(  93)							 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  93)							if (::hx::IsNull( imageType1 )) {
HXLINE(  54)								imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  93)							::Dynamic undoImage4;
HXDLIN(  93)							switch((int)(( (int)(imageType1) ))){
            								case (int)0: {
HXDLIN(  93)									 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  93)									 ::iterMagic::BytesImg b6 = byt1;
HXDLIN(  93)									{
HXDLIN(  93)										b6->width = width1;
HXDLIN(  93)										b6->height = height1;
HXDLIN(  93)										b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)										b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  93)										{
HXDLIN(  93)											int len2 = b6->length;
HXDLIN(  93)											int w1 = 0;
HXDLIN(  93)											{
HXDLIN(  93)												int _g24 = 0;
HXDLIN(  93)												int _g25 = b6->height;
HXDLIN(  93)												while((_g24 < _g25)){
HXDLIN(  93)													_g24 = (_g24 + 1);
HXDLIN(  93)													int y3 = (_g24 - 1);
HXDLIN(  93)													{
HXDLIN(  93)														int _g26 = 0;
HXDLIN(  93)														int _g27 = b6->width;
HXDLIN(  93)														while((_g26 < _g27)){
HXDLIN(  93)															_g26 = (_g26 + 1);
HXDLIN(  93)															int x3 = (_g26 - 1);
HXDLIN(  93)															{
HXDLIN(  93)																w1 = (w1 + 1);
HXDLIN(  93)																b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  93)															{
HXDLIN(  93)																w1 = (w1 + 1);
HXDLIN(  93)																b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  93)															{
HXDLIN(  93)																w1 = (w1 + 1);
HXDLIN(  93)																b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  93)															{
HXDLIN(  93)																w1 = (w1 + 1);
HXDLIN(  93)																b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  93)									undoImage4 = b6;
            								}
            								break;
            								case (int)1: {
HXDLIN(  93)									 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)									 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN(  93)									{
HXDLIN(  93)										a7->width = width1;
HXDLIN(  93)										a7->height = height1;
HXDLIN(  93)										a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  93)										a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)										{
HXDLIN(  93)											int _g28 = 0;
HXDLIN(  93)											int _g29 = a7->length;
HXDLIN(  93)											while((_g28 < _g29)){
HXDLIN(  93)												_g28 = (_g28 + 1);
HXDLIN(  93)												int i12 = (_g28 - 1);
HXDLIN(  93)												a7->data[i12] = 0;
            											}
            										}
            									}
HXDLIN(  93)									undoImage4 = a7;
            								}
            								break;
            								case (int)2: {
HXDLIN(  93)									 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  93)									 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN(  93)									{
HXDLIN(  93)										b7->width = width1;
HXDLIN(  93)										b7->height = height1;
HXDLIN(  93)										b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)										int size1 = (b7->length * 4);
HXDLIN(  93)										b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  93)										{
HXDLIN(  93)											int _g30 = 0;
HXDLIN(  93)											int _g31 = b7->length;
HXDLIN(  93)											while((_g30 < _g31)){
HXDLIN(  93)												_g30 = (_g30 + 1);
HXDLIN(  93)												int i13 = (_g30 - 1);
HXDLIN(  93)												{
HXDLIN(  93)													 ::haxe::io::ArrayBufferViewImpl this36 = b7->data;
HXDLIN(  93)													bool undoImage5;
HXDLIN(  93)													if ((i13 >= 0)) {
HXDLIN(  93)														undoImage5 = (i13 < (this36->byteLength >> 2));
            													}
            													else {
HXDLIN(  93)														undoImage5 = false;
            													}
HXDLIN(  93)													if (undoImage5) {
HXDLIN(  93)														 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN(  93)														int pos1 = ((i13 << 2) + this36->byteOffset);
HXDLIN(  93)														_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  93)														_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)														_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)														_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  93)									undoImage4 = b7;
            								}
            								break;
            								case (int)3: {
HXDLIN(  93)									 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)									 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN(  93)									{
HXDLIN(  93)										v4->width = width1;
HXDLIN(  93)										v4->height = height1;
HXDLIN(  93)										v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)										v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  93)										{
HXDLIN(  93)											int _g32 = 0;
HXDLIN(  93)											int _g33 = v4->length;
HXDLIN(  93)											while((_g32 < _g33)){
HXDLIN(  93)												_g32 = (_g32 + 1);
HXDLIN(  93)												int i14 = (_g32 - 1);
HXDLIN(  93)												v4->data->__unsafe_set(i14,0);
            											}
            										}
            									}
HXDLIN(  93)									undoImage4 = v4;
            								}
            								break;
            								case (int)4: {
HXDLIN(  93)									 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)									 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN(  93)									{
HXDLIN(  93)										b8->width = width1;
HXDLIN(  93)										b8->height = height1;
HXDLIN(  93)										b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)										b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  93)										{
HXDLIN(  93)											int len3 = b8->length;
HXDLIN(  93)											 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN(  93)											if (::hx::IsNull( d1->head )) {
HXDLIN(  93)												int _g34 = 0;
HXDLIN(  93)												int _g35 = len3;
HXDLIN(  93)												while((_g34 < _g35)){
HXDLIN(  93)													_g34 = (_g34 + 1);
HXDLIN(  93)													int i15 = (_g34 - 1);
HXDLIN(  93)													d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            												}
            											}
            											else {
HXDLIN(  93)												int _g36 = 0;
HXDLIN(  93)												int _g37 = len3;
HXDLIN(  93)												while((_g36 < _g37)){
HXDLIN(  93)													_g36 = (_g36 + 1);
HXDLIN(  93)													int i16 = (_g36 - 1);
HXDLIN(  93)													{
HXDLIN(  93)														 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN(  93)														 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  93)														{
HXDLIN(  93)															int _g38 = 0;
HXDLIN(  93)															int _g39 = i16;
HXDLIN(  93)															while((_g38 < _g39)){
HXDLIN(  93)																_g38 = (_g38 + 1);
HXDLIN(  93)																int i17 = (_g38 - 1);
HXLINE( 345)																prev1 = l1;
HXLINE( 346)																l1 = l1->next;
            															}
            														}
HXLINE(  93)														if (::hx::IsNull( prev1 )) {
HXDLIN(  93)															b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  93)															l1 = null();
            														}
            														else {
HXDLIN(  93)															prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  93)															l1 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  93)									undoImage4 = b8;
            								}
            								break;
            							}
HXDLIN(  93)							this35->image = undoImage4;
HXDLIN(  93)							this35->width = width1;
HXDLIN(  93)							this35->height = height1;
HXDLIN(  93)							this35->imageType = ( (int)(imageType1) );
HXDLIN(  93)							undoImage3 = this35;
HXDLIN(  93)							{
HXDLIN(  93)								int rectLeft1 = xIter31->start;
HXDLIN(  93)								int rectTop1 = yIter31->start;
HXDLIN(  93)								int rectRight1 = xIter31->max;
HXDLIN(  93)								bool forceClear1 = false;
HXDLIN(  93)								{
HXDLIN(  93)									int _g40 = rectTop1;
HXDLIN(  93)									int _g41 = yIter31->max;
HXDLIN(  93)									while((_g40 < _g41)){
HXDLIN(  93)										_g40 = (_g40 + 1);
HXDLIN(  93)										int dy1 = (_g40 - 1);
HXDLIN(  93)										{
HXDLIN(  93)											int _g42 = rectLeft1;
HXDLIN(  93)											int _g43 = rectRight1;
HXDLIN(  93)											while((_g42 < _g43)){
HXDLIN(  93)												_g42 = (_g42 + 1);
HXDLIN(  93)												int dx1 = (_g42 - 1);
HXDLIN(  93)												::Dynamic this37 = this34->image;
HXDLIN(  93)												int index4;
HXDLIN(  93)												if (this34->useVirtualPos) {
HXDLIN(  93)													index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this34->virtualY) * ( (Float)(this34->width) )) + dx1) - this34->virtualX));
            												}
            												else {
HXDLIN(  93)													index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this34->width) + dx1)) ));
            												}
HXDLIN(  93)												int c3 = ::iterMagic::Iimg_obj::get(this37,index4);
HXDLIN(  93)												int col1;
HXDLIN(  93)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)													col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXDLIN(  93)													col1 = c3;
            												}
HXDLIN(  93)												bool _hx_tmp8;
HXDLIN(  93)												if (this34->useMask) {
HXDLIN(  93)													_hx_tmp8 = ::hx::IsNotNull( this34->mask );
            												}
            												else {
HXDLIN(  93)													_hx_tmp8 = false;
            												}
HXDLIN(  93)												if (_hx_tmp8) {
HXDLIN(  93)													 ::pi_xy::ImageStruct this38 = this34->mask;
HXDLIN(  93)													::Dynamic this39 = this38->image;
HXDLIN(  93)													int index5;
HXDLIN(  93)													if (this38->useVirtualPos) {
HXDLIN(  93)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx1) - this38->virtualX));
            													}
            													else {
HXDLIN(  93)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this38->width) + dx1)) ));
            													}
HXDLIN(  93)													int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN(  93)													int v5;
HXDLIN(  93)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)														v5 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXDLIN(  93)														v5 = c4;
            													}
HXDLIN(  93)													int maskPixel1 = v5;
HXDLIN(  93)													int this40 = col1;
HXDLIN(  93)													if ((maskPixel1 == 0)) {
HXDLIN(  93)														col1 = this40;
            													}
            													else {
HXDLIN(  93)														Float m01;
HXDLIN(  93)														int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN(  93)														if ((this41 == 0)) {
HXDLIN(  93)															m01 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float m11;
HXDLIN(  93)														int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN(  93)														if ((this42 == 0)) {
HXDLIN(  93)															m11 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float m21;
HXDLIN(  93)														int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN(  93)														if ((this43 == 0)) {
HXDLIN(  93)															m21 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float m31;
HXDLIN(  93)														int this44 = (maskPixel1 & 255);
HXDLIN(  93)														if ((this44 == 0)) {
HXDLIN(  93)															m31 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN(  93)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN(  93)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN(  93)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN(  93)														col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  93)												if ((col1 != 0)) {
HXDLIN(  93)													int x4 = (dx1 - rectLeft1);
HXDLIN(  93)													int y4 = (dy1 - rectTop1);
HXDLIN(  93)													int c5 = col1;
HXDLIN(  93)													bool _hx_tmp9;
HXDLIN(  93)													if ((((c5 >> 24) & 255) < 254)) {
HXDLIN(  93)														_hx_tmp9 = undoImage3->transparent;
            													}
            													else {
HXDLIN(  93)														_hx_tmp9 = false;
            													}
HXDLIN(  93)													if (_hx_tmp9) {
HXDLIN(  93)														int location2;
HXDLIN(  93)														if (undoImage3->useVirtualPos) {
HXDLIN(  93)															location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            														}
            														else {
HXDLIN(  93)															location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            														}
HXDLIN(  93)														int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  93)														int this46;
HXDLIN(  93)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)															this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            														}
            														else {
HXDLIN(  93)															this46 = this45;
            														}
HXDLIN(  93)														Float a12;
HXDLIN(  93)														int this47 = ((this46 >> 24) & 255);
HXDLIN(  93)														if ((this47 == 0)) {
HXDLIN(  93)															a12 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float r12;
HXDLIN(  93)														int this48 = ((this46 >> 16) & 255);
HXDLIN(  93)														if ((this48 == 0)) {
HXDLIN(  93)															r12 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float g12;
HXDLIN(  93)														int this49 = ((this46 >> 8) & 255);
HXDLIN(  93)														if ((this49 == 0)) {
HXDLIN(  93)															g12 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float b13;
HXDLIN(  93)														int this50 = (this46 & 255);
HXDLIN(  93)														if ((this50 == 0)) {
HXDLIN(  93)															b13 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float a22;
HXDLIN(  93)														int this51 = ((col1 >> 24) & 255);
HXDLIN(  93)														if ((this51 == 0)) {
HXDLIN(  93)															a22 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float r22;
HXDLIN(  93)														int this52 = ((col1 >> 16) & 255);
HXDLIN(  93)														if ((this52 == 0)) {
HXDLIN(  93)															r22 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float g22;
HXDLIN(  93)														int this53 = ((col1 >> 8) & 255);
HXDLIN(  93)														if ((this53 == 0)) {
HXDLIN(  93)															g22 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float b23;
HXDLIN(  93)														int this54 = (col1 & 255);
HXDLIN(  93)														if ((this54 == 0)) {
HXDLIN(  93)															b23 = ((Float)0.);
            														}
            														else {
HXDLIN(  93)															b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            														}
HXDLIN(  93)														Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  93)														int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  93)														int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  93)														int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  93)														int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  93)														int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  93)														{
HXDLIN(  93)															int _hx_tmp10;
HXDLIN(  93)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)																_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            															}
            															else {
HXDLIN(  93)																_hx_tmp10 = blended2;
            															}
HXDLIN(  93)															::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            														}
            													}
            													else {
HXDLIN(  93)														::Dynamic this55 = undoImage3->image;
HXDLIN(  93)														int index6;
HXDLIN(  93)														if (undoImage3->useVirtualPos) {
HXDLIN(  93)															index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            														}
            														else {
HXDLIN(  93)															index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            														}
HXDLIN(  93)														int _hx_tmp11;
HXDLIN(  93)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)															_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXDLIN(  93)															_hx_tmp11 = c5;
            														}
HXDLIN(  93)														::iterMagic::Iimg_obj::set(this55,index6,_hx_tmp11);
            													}
            												}
            												else {
HXDLIN(  93)													if (forceClear1) {
HXDLIN(  93)														::Dynamic this56 = undoImage3->image;
HXDLIN(  93)														int x5 = (dx1 - rectLeft1);
HXDLIN(  93)														int y5 = (dy1 - rectTop1);
HXDLIN(  93)														int index7;
HXDLIN(  93)														if (undoImage3->useVirtualPos) {
HXDLIN(  93)															index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            														}
            														else {
HXDLIN(  93)															index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            														}
HXDLIN(  93)														::iterMagic::Iimg_obj::set(this56,index7,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  93)						{
HXDLIN(  93)							int _g_min2 = xIter31->start;
HXDLIN(  93)							int _g_max2 = xIter31->max;
HXDLIN(  93)							while((_g_min2 < _g_max2)){
HXDLIN(  93)								_g_min2 = (_g_min2 + 1);
HXDLIN(  93)								int px1 = (_g_min2 - 1);
HXDLIN(  93)								Float pcx1 = (( (Float)(px1) ) - nextX1);
HXDLIN(  93)								{
HXDLIN(  93)									int _g_min3 = yIter31->start;
HXDLIN(  93)									int _g_max3 = yIter31->max;
HXDLIN(  93)									while((_g_min3 < _g_max3)){
HXDLIN(  93)										_g_min3 = (_g_min3 + 1);
HXDLIN(  93)										int py1 = (_g_min3 - 1);
HXDLIN(  93)										Float pcy1 = (( (Float)(py1) ) - nextY1);
HXDLIN(  93)										Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  93)										Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  93)										Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  93)										Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  93)										Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  93)										bool _hx_tmp12;
HXDLIN(  93)										bool _hx_tmp13;
HXDLIN(  93)										if ((ratioA1 >= 0)) {
HXDLIN(  93)											_hx_tmp13 = (ratioB1 >= 0);
            										}
            										else {
HXDLIN(  93)											_hx_tmp13 = false;
            										}
HXDLIN(  93)										if (_hx_tmp13) {
HXDLIN(  93)											_hx_tmp12 = (ratioC1 >= 0);
            										}
            										else {
HXDLIN(  93)											_hx_tmp12 = false;
            										}
HXDLIN(  93)										if (_hx_tmp12) {
HXDLIN(  93)											int i18 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN(  93)											if ((i18 > 255)) {
HXLINE(  24)												i18 = 255;
            											}
HXLINE(  93)											if ((i18 < 0)) {
HXLINE(  25)												i18 = 0;
            											}
HXLINE(  93)											int a9 = i18;
HXDLIN(  93)											int i19 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN(  93)											if ((i19 > 255)) {
HXLINE(  24)												i19 = 255;
            											}
HXLINE(  93)											if ((i19 < 0)) {
HXLINE(  25)												i19 = 0;
            											}
HXLINE(  93)											int r6 = i19;
HXDLIN(  93)											int i20 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN(  93)											if ((i20 > 255)) {
HXLINE(  24)												i20 = 255;
            											}
HXLINE(  93)											if ((i20 < 0)) {
HXLINE(  25)												i20 = 0;
            											}
HXLINE(  93)											int g6 = i20;
HXDLIN(  93)											int i21 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN(  93)											if ((i21 > 255)) {
HXLINE(  24)												i21 = 255;
            											}
HXLINE(  93)											if ((i21 < 0)) {
HXLINE(  25)												i21 = 0;
            											}
HXLINE(  93)											int b10 = i21;
HXDLIN(  93)											{
HXDLIN(  93)												int location3;
HXDLIN(  93)												if (this34->useVirtualPos) {
HXDLIN(  93)													location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this34->virtualY) * ( (Float)(this34->width) )) + px1) - this34->virtualX));
            												}
            												else {
HXDLIN(  93)													location3 = ::Std_obj::_hx_int(( (Float)(((py1 * this34->width) + px1)) ));
            												}
HXDLIN(  93)												bool _hx_tmp14;
HXDLIN(  93)												if (this34->transparent) {
HXDLIN(  93)													_hx_tmp14 = (a9 < 254);
            												}
            												else {
HXDLIN(  93)													_hx_tmp14 = false;
            												}
HXDLIN(  93)												if (_hx_tmp14) {
HXDLIN(  93)													int this57 = ::iterMagic::Iimg_obj::get(this34->image,location3);
HXDLIN(  93)													int old1;
HXDLIN(  93)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)														old1 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            													}
            													else {
HXDLIN(  93)														old1 = this57;
            													}
HXDLIN(  93)													int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN(  93)													Float a13;
HXDLIN(  93)													int this58 = ((old1 >> 24) & 255);
HXDLIN(  93)													if ((this58 == 0)) {
HXDLIN(  93)														a13 = ((Float)0.);
            													}
            													else {
HXDLIN(  93)														a13 = (( (Float)(this58) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float r13;
HXDLIN(  93)													int this59 = ((old1 >> 16) & 255);
HXDLIN(  93)													if ((this59 == 0)) {
HXDLIN(  93)														r13 = ((Float)0.);
            													}
            													else {
HXDLIN(  93)														r13 = (( (Float)(this59) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float g13;
HXDLIN(  93)													int this60 = ((old1 >> 8) & 255);
HXDLIN(  93)													if ((this60 == 0)) {
HXDLIN(  93)														g13 = ((Float)0.);
            													}
            													else {
HXDLIN(  93)														g13 = (( (Float)(this60) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float b14;
HXDLIN(  93)													int this61 = (old1 & 255);
HXDLIN(  93)													if ((this61 == 0)) {
HXDLIN(  93)														b14 = ((Float)0.);
            													}
            													else {
HXDLIN(  93)														b14 = (( (Float)(this61) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float a23;
HXDLIN(  93)													int this62 = ((rhs1 >> 24) & 255);
HXDLIN(  93)													if ((this62 == 0)) {
HXDLIN(  93)														a23 = ((Float)0.);
            													}
            													else {
HXDLIN(  93)														a23 = (( (Float)(this62) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float r23;
HXDLIN(  93)													int this63 = ((rhs1 >> 16) & 255);
HXDLIN(  93)													if ((this63 == 0)) {
HXDLIN(  93)														r23 = ((Float)0.);
            													}
            													else {
HXDLIN(  93)														r23 = (( (Float)(this63) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float g23;
HXDLIN(  93)													int this64 = ((rhs1 >> 8) & 255);
HXDLIN(  93)													if ((this64 == 0)) {
HXDLIN(  93)														g23 = ((Float)0.);
            													}
            													else {
HXDLIN(  93)														g23 = (( (Float)(this64) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float b24;
HXDLIN(  93)													int this65 = (rhs1 & 255);
HXDLIN(  93)													if ((this65 == 0)) {
HXDLIN(  93)														b24 = ((Float)0.);
            													}
            													else {
HXDLIN(  93)														b24 = (( (Float)(this65) ) / ( (Float)(255) ));
            													}
HXDLIN(  93)													Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  93)													int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  93)													int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  93)													int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  93)													int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  93)													int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN(  93)													{
HXDLIN(  93)														int _hx_tmp15;
HXDLIN(  93)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)															_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            														}
            														else {
HXDLIN(  93)															_hx_tmp15 = blended3;
            														}
HXDLIN(  93)														::iterMagic::Iimg_obj::set(this34->image,location3,_hx_tmp15);
            													}
            												}
            												else {
HXDLIN(  93)													int value1;
HXDLIN(  93)													if (this34->isLittle) {
HXDLIN(  93)														value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            													}
            													else {
HXDLIN(  93)														value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            													}
HXDLIN(  93)													::iterMagic::Iimg_obj::set(this34->image,location3,value1);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  93)						if ((hasHit1 == false)) {
HXDLIN(  93)							 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX1,nextY1,true);
HXDLIN(  93)							if (hasUndo1) {
HXDLIN(  93)								v6->undoImage = undoImage3;
HXDLIN(  93)								v6->undoX = xIter31->start;
HXDLIN(  93)								v6->undoY = yIter31->start;
            							}
            						}
            					}
            				}
HXLINE( 244)				lastX = nextX1;
HXLINE( 245)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(GradientShape_Impl__obj,radialPolyon,(void))

void GradientShape_Impl__obj::radialEllipseTri( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int colorIn,int colorOut,::hx::Null< Float >  __o_gx,::hx::Null< Float >  __o_gy, ::Dynamic __o_phi, ::Dynamic __o_printSides, ::Dynamic __o_targetError){
            		Float gx = __o_gx.Default(((Float)0.));
            		Float gy = __o_gy.Default(((Float)0.));
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            		 ::Dynamic printSides = __o_printSides;
            		if (::hx::IsNull(__o_printSides)) printSides = false;
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_112_radialEllipseTri)
HXLINE( 113)		Float rSmall;
HXDLIN( 113)		if ((rx > ry)) {
HXLINE( 113)			rSmall = ry;
            		}
            		else {
HXLINE( 113)			rSmall = rx;
            		}
HXLINE( 114)		 ::Dynamic targetE = targetError;
HXDLIN( 114)		if (::hx::IsNull( targetE )) {
HXLINE( 114)			targetE = ((Float)1.05);
            		}
HXDLIN( 114)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 114)		int noSides;
HXDLIN( 114)		if ((result < 12)) {
HXLINE( 114)			noSides = 12;
            		}
            		else {
HXLINE( 114)			if ((result > 500)) {
HXLINE( 114)				noSides = 500;
            			}
            			else {
HXLINE( 114)				noSides = result;
            			}
            		}
HXLINE( 115)		if (( (bool)(printSides) )) {
HXLINE( 115)			::haxe::Log_obj::trace(noSides,::hx::SourceInfo(HX_("src/pi_xy/imageAbstracts/GradientShape.hx",33,e0,a4,0e),115,HX_("pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_",a6,16,aa,02),HX_("radialEllipseTri",ac,ee,5f,59)));
            		}
HXLINE( 116)		{
HXLINE( 116)			 ::Dynamic gx1 = gx;
HXDLIN( 116)			 ::Dynamic gy1 = gy;
HXDLIN( 116)			 ::Dynamic phi1 = phi;
HXDLIN( 116)			 ::Dynamic sides = noSides;
HXLINE( 122)			if (::hx::IsNull( sides )) {
HXLINE( 122)				sides = 36;
            			}
HXLINE( 121)			if (::hx::IsNull( phi1 )) {
HXLINE( 121)				phi1 = ((Float)0.);
            			}
HXLINE( 120)			if (::hx::IsNull( gy1 )) {
HXLINE( 120)				gy1 = 0;
            			}
HXDLIN( 120)			if (::hx::IsNull( gx1 )) {
HXLINE( 120)				gx1 = 0;
            			}
HXLINE( 116)			if (::hx::IsLess( gx1,((Float)-1.) )) {
HXLINE( 193)				gx1 = -1;
            			}
HXLINE( 116)			if (::hx::IsGreater( gx1,((Float)1.) )) {
HXLINE( 194)				gx1 = 1;
            			}
HXLINE( 116)			if (::hx::IsLess( gy1,((Float)-1.) )) {
HXLINE( 195)				gy1 = ((Float)-1.);
            			}
HXLINE( 116)			if (::hx::IsGreater( gy1,((Float)1.) )) {
HXLINE( 196)				gy1 = 1;
            			}
HXLINE( 116)			Float mx = (cx + (( (Float)(gx1) ) * rx));
HXDLIN( 116)			Float my = (cy + (( (Float)(gy1) ) * ry));
HXDLIN( 116)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 116)			Float omega = ((Float)0.);
HXDLIN( 116)			Float lastX = ((Float)0.);
HXDLIN( 116)			Float lastY = ((Float)0.);
HXDLIN( 116)			if (::hx::IsNotEq( phi1,0 )) {
HXLINE( 221)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi1) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi1) )))) + cx);
HXLINE( 222)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi1) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi1) )))) + cy);
            			}
            			else {
HXLINE( 224)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE( 225)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            			}
HXLINE( 116)			if (::hx::IsNotEq( phi1,0 )) {
HXLINE( 116)				Float cphi = ::Math_obj::cos(( (Float)(phi1) ));
HXDLIN( 116)				Float sphi = ::Math_obj::sin(( (Float)(phi1) ));
HXDLIN( 116)				{
HXLINE( 116)					int _g = 0;
HXDLIN( 116)					int _g1 = (sides + 1);
HXDLIN( 116)					while((_g < _g1)){
HXLINE( 116)						_g = (_g + 1);
HXDLIN( 116)						int i = (_g - 1);
HXDLIN( 116)						Float stheta = ::Math_obj::sin(((( (Float)(i) ) * theta) + omega));
HXDLIN( 116)						Float ctheta = ::Math_obj::cos(((( (Float)(i) ) * theta) + omega));
HXDLIN( 116)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 116)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 116)						{
HXLINE( 116)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 116)							{
HXLINE( 116)								bool hasHit = false;
HXDLIN( 116)								bool hasUndo = false;
HXDLIN( 116)								int aA = ((colorOut >> 24) & 255);
HXDLIN( 116)								int rA = ((colorOut >> 16) & 255);
HXDLIN( 116)								int gA = ((colorOut >> 8) & 255);
HXDLIN( 116)								int bA = (colorOut & 255);
HXDLIN( 116)								int aB = ((colorIn >> 24) & 255);
HXDLIN( 116)								int rB = ((colorIn >> 16) & 255);
HXDLIN( 116)								int gB = ((colorIn >> 8) & 255);
HXDLIN( 116)								int bB = (colorIn & 255);
HXDLIN( 116)								int aC = ((colorOut >> 24) & 255);
HXDLIN( 116)								int rC = ((colorOut >> 16) & 255);
HXDLIN( 116)								int gC = ((colorOut >> 8) & 255);
HXDLIN( 116)								int bC = (colorOut & 255);
HXDLIN( 116)								Float bcx = (lastX - nextX);
HXDLIN( 116)								Float bcy = (lastY - nextY);
HXDLIN( 116)								Float acx = (mx - nextX);
HXDLIN( 116)								Float acy = (my - nextY);
HXDLIN( 116)								Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 116)								Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 116)								Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 116)								Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 116)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 116)								if ((mx > lastX)) {
HXLINE( 116)									if ((mx > nextX)) {
HXLINE( 116)										int min;
HXDLIN( 116)										if ((lastX > nextX)) {
HXLINE( 116)											min = ::Math_obj::floor(nextX);
            										}
            										else {
HXLINE( 116)											min = ::Math_obj::floor(lastX);
            										}
HXDLIN( 116)										int ii_min = min;
HXDLIN( 116)										int ii_max = ::Math_obj::ceil(mx);
HXDLIN( 116)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXLINE( 116)										int ii_min1 = ::Math_obj::floor(lastX);
HXDLIN( 116)										int ii_max1 = ::Math_obj::ceil(nextX);
HXDLIN( 116)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXLINE( 116)									if ((lastX > nextX)) {
HXLINE( 116)										int min1;
HXDLIN( 116)										if ((mx > nextX)) {
HXLINE( 116)											min1 = ::Math_obj::floor(nextX);
            										}
            										else {
HXLINE( 116)											min1 = ::Math_obj::ceil(mx);
            										}
HXDLIN( 116)										int ii_min2 = min1;
HXDLIN( 116)										int ii_max2 = ::Math_obj::ceil(lastX);
HXDLIN( 116)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXLINE( 116)										int ii_min3 = ::Math_obj::floor(mx);
HXDLIN( 116)										int ii_max3 = ::Math_obj::ceil(nextX);
HXDLIN( 116)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 116)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 116)								if ((my > lastY)) {
HXLINE( 116)									if ((my > nextY)) {
HXLINE( 116)										int min2;
HXDLIN( 116)										if ((lastY > nextY)) {
HXLINE( 116)											min2 = ::Math_obj::floor(nextY);
            										}
            										else {
HXLINE( 116)											min2 = ::Math_obj::floor(lastY);
            										}
HXDLIN( 116)										int ii_min4 = min2;
HXDLIN( 116)										int ii_max4 = ::Math_obj::ceil(my);
HXDLIN( 116)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXLINE( 116)										int ii_min5 = ::Math_obj::floor(lastY);
HXDLIN( 116)										int ii_max5 = ::Math_obj::ceil(nextY);
HXDLIN( 116)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXLINE( 116)									if ((lastY > nextY)) {
HXLINE( 116)										int min3;
HXDLIN( 116)										if ((my > nextY)) {
HXLINE( 116)											min3 = ::Math_obj::floor(nextY);
            										}
            										else {
HXLINE( 116)											min3 = ::Math_obj::ceil(my);
            										}
HXDLIN( 116)										int ii_min6 = min3;
HXDLIN( 116)										int ii_max6 = ::Math_obj::ceil(lastY);
HXDLIN( 116)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXLINE( 116)										int ii_min7 = ::Math_obj::floor(my);
HXDLIN( 116)										int ii_max7 = ::Math_obj::ceil(nextY);
HXDLIN( 116)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 116)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 116)								if (hasUndo) {
HXLINE( 116)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 116)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 116)									 ::Dynamic imageType = null();
HXDLIN( 116)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 116)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 116)									::Dynamic undoImage1;
HXDLIN( 116)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXLINE( 116)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 116)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 116)											{
HXLINE( 116)												b->width = width;
HXDLIN( 116)												b->height = height;
HXDLIN( 116)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 116)												{
HXLINE( 116)													int len = b->length;
HXDLIN( 116)													int w = 0;
HXDLIN( 116)													{
HXLINE( 116)														int _g2 = 0;
HXDLIN( 116)														int _g3 = b->height;
HXDLIN( 116)														while((_g2 < _g3)){
HXLINE( 116)															_g2 = (_g2 + 1);
HXDLIN( 116)															int y = (_g2 - 1);
HXDLIN( 116)															{
HXLINE( 116)																int _g4 = 0;
HXDLIN( 116)																int _g5 = b->width;
HXDLIN( 116)																while((_g4 < _g5)){
HXLINE( 116)																	_g4 = (_g4 + 1);
HXDLIN( 116)																	int x = (_g4 - 1);
HXDLIN( 116)																	{
HXLINE( 116)																		w = (w + 1);
HXDLIN( 116)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 116)																	{
HXLINE( 116)																		w = (w + 1);
HXDLIN( 116)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 116)																	{
HXLINE( 116)																		w = (w + 1);
HXDLIN( 116)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 116)																	{
HXLINE( 116)																		w = (w + 1);
HXDLIN( 116)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 116)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXLINE( 116)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 116)											{
HXLINE( 116)												a->width = width;
HXDLIN( 116)												a->height = height;
HXDLIN( 116)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 116)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)												{
HXLINE( 116)													int _g6 = 0;
HXDLIN( 116)													int _g7 = a->length;
HXDLIN( 116)													while((_g6 < _g7)){
HXLINE( 116)														_g6 = (_g6 + 1);
HXDLIN( 116)														int i1 = (_g6 - 1);
HXDLIN( 116)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 116)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXLINE( 116)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 116)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 116)											{
HXLINE( 116)												b1->width = width;
HXDLIN( 116)												b1->height = height;
HXDLIN( 116)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)												int size = (b1->length * 4);
HXDLIN( 116)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 116)												{
HXLINE( 116)													int _g8 = 0;
HXDLIN( 116)													int _g9 = b1->length;
HXDLIN( 116)													while((_g8 < _g9)){
HXLINE( 116)														_g8 = (_g8 + 1);
HXDLIN( 116)														int i2 = (_g8 - 1);
HXDLIN( 116)														{
HXLINE( 116)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 116)															bool undoImage2;
HXDLIN( 116)															if ((i2 >= 0)) {
HXLINE( 116)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXLINE( 116)																undoImage2 = false;
            															}
HXDLIN( 116)															if (undoImage2) {
HXLINE( 116)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 116)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 116)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 116)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 116)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 116)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 116)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXLINE( 116)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 116)											{
HXLINE( 116)												v->width = width;
HXDLIN( 116)												v->height = height;
HXDLIN( 116)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 116)												{
HXLINE( 116)													int _g10 = 0;
HXDLIN( 116)													int _g11 = v->length;
HXDLIN( 116)													while((_g10 < _g11)){
HXLINE( 116)														_g10 = (_g10 + 1);
HXDLIN( 116)														int i3 = (_g10 - 1);
HXDLIN( 116)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 116)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXLINE( 116)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 116)											{
HXLINE( 116)												b2->width = width;
HXDLIN( 116)												b2->height = height;
HXDLIN( 116)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 116)												{
HXLINE( 116)													int len1 = b2->length;
HXDLIN( 116)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 116)													if (::hx::IsNull( d->head )) {
HXLINE( 116)														int _g12 = 0;
HXDLIN( 116)														int _g13 = len1;
HXDLIN( 116)														while((_g12 < _g13)){
HXLINE( 116)															_g12 = (_g12 + 1);
HXDLIN( 116)															int i4 = (_g12 - 1);
HXDLIN( 116)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXLINE( 116)														int _g14 = 0;
HXDLIN( 116)														int _g15 = len1;
HXDLIN( 116)														while((_g14 < _g15)){
HXLINE( 116)															_g14 = (_g14 + 1);
HXDLIN( 116)															int i5 = (_g14 - 1);
HXDLIN( 116)															{
HXLINE( 116)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 116)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 116)																{
HXLINE( 116)																	int _g16 = 0;
HXDLIN( 116)																	int _g17 = i5;
HXDLIN( 116)																	while((_g16 < _g17)){
HXLINE( 116)																		_g16 = (_g16 + 1);
HXDLIN( 116)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 116)																if (::hx::IsNull( prev )) {
HXLINE( 116)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 116)																	l = null();
            																}
            																else {
HXLINE( 116)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 116)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 116)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 116)									this3->image = undoImage1;
HXDLIN( 116)									this3->width = width;
HXDLIN( 116)									this3->height = height;
HXDLIN( 116)									this3->imageType = ( (int)(imageType) );
HXDLIN( 116)									undoImage = this3;
HXDLIN( 116)									{
HXLINE( 116)										int rectLeft = xIter3->start;
HXDLIN( 116)										int rectTop = yIter3->start;
HXDLIN( 116)										int rectRight = xIter3->max;
HXDLIN( 116)										bool forceClear = false;
HXDLIN( 116)										{
HXLINE( 116)											int _g18 = rectTop;
HXDLIN( 116)											int _g19 = yIter3->max;
HXDLIN( 116)											while((_g18 < _g19)){
HXLINE( 116)												_g18 = (_g18 + 1);
HXDLIN( 116)												int dy = (_g18 - 1);
HXDLIN( 116)												{
HXLINE( 116)													int _g20 = rectLeft;
HXDLIN( 116)													int _g21 = rectRight;
HXDLIN( 116)													while((_g20 < _g21)){
HXLINE( 116)														_g20 = (_g20 + 1);
HXDLIN( 116)														int dx = (_g20 - 1);
HXDLIN( 116)														::Dynamic this5 = this2->image;
HXDLIN( 116)														int index;
HXDLIN( 116)														if (this2->useVirtualPos) {
HXLINE( 116)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXLINE( 116)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 116)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 116)														int col;
HXDLIN( 116)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 116)															col = c;
            														}
HXDLIN( 116)														bool _hx_tmp;
HXDLIN( 116)														if (this2->useMask) {
HXLINE( 116)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXLINE( 116)															_hx_tmp = false;
            														}
HXDLIN( 116)														if (_hx_tmp) {
HXLINE( 116)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 116)															::Dynamic this7 = this6->image;
HXDLIN( 116)															int index1;
HXDLIN( 116)															if (this6->useVirtualPos) {
HXLINE( 116)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXLINE( 116)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 116)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 116)															int v1;
HXDLIN( 116)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE( 116)																v1 = c1;
            															}
HXDLIN( 116)															int maskPixel = v1;
HXDLIN( 116)															int this8 = col;
HXDLIN( 116)															if ((maskPixel == 0)) {
HXLINE( 116)																col = this8;
            															}
            															else {
HXLINE( 116)																Float m0;
HXDLIN( 116)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 116)																if ((this9 == 0)) {
HXLINE( 116)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float m1;
HXDLIN( 116)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 116)																if ((this10 == 0)) {
HXLINE( 116)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float m2;
HXDLIN( 116)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 116)																if ((this11 == 0)) {
HXLINE( 116)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float m3;
HXDLIN( 116)																int this12 = (maskPixel & 255);
HXDLIN( 116)																if ((this12 == 0)) {
HXLINE( 116)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 116)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 116)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 116)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 116)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 116)														if ((col != 0)) {
HXLINE( 116)															int x1 = (dx - rectLeft);
HXDLIN( 116)															int y1 = (dy - rectTop);
HXDLIN( 116)															int c2 = col;
HXDLIN( 116)															bool _hx_tmp1;
HXDLIN( 116)															if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 116)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXLINE( 116)																_hx_tmp1 = false;
            															}
HXDLIN( 116)															if (_hx_tmp1) {
HXLINE( 116)																int location;
HXDLIN( 116)																if (undoImage->useVirtualPos) {
HXLINE( 116)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE( 116)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 116)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 116)																int this14;
HXDLIN( 116)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXLINE( 116)																	this14 = this13;
            																}
HXDLIN( 116)																Float a1;
HXDLIN( 116)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 116)																if ((this15 == 0)) {
HXLINE( 116)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float r1;
HXDLIN( 116)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 116)																if ((this16 == 0)) {
HXLINE( 116)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float g1;
HXDLIN( 116)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 116)																if ((this17 == 0)) {
HXLINE( 116)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float b11;
HXDLIN( 116)																int this18 = (this14 & 255);
HXDLIN( 116)																if ((this18 == 0)) {
HXLINE( 116)																	b11 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float a2;
HXDLIN( 116)																int this19 = ((col >> 24) & 255);
HXDLIN( 116)																if ((this19 == 0)) {
HXLINE( 116)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float r2;
HXDLIN( 116)																int this20 = ((col >> 16) & 255);
HXDLIN( 116)																if ((this20 == 0)) {
HXLINE( 116)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float g2;
HXDLIN( 116)																int this21 = ((col >> 8) & 255);
HXDLIN( 116)																if ((this21 == 0)) {
HXLINE( 116)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float b21;
HXDLIN( 116)																int this22 = (col & 255);
HXDLIN( 116)																if ((this22 == 0)) {
HXLINE( 116)																	b21 = ((Float)0.);
            																}
            																else {
HXLINE( 116)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 116)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 116)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 116)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 116)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 116)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 116)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 116)																{
HXLINE( 116)																	int _hx_tmp2;
HXDLIN( 116)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE( 116)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 116)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXLINE( 116)																::Dynamic this23 = undoImage->image;
HXDLIN( 116)																int index2;
HXDLIN( 116)																if (undoImage->useVirtualPos) {
HXLINE( 116)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE( 116)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 116)																int _hx_tmp3;
HXDLIN( 116)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXLINE( 116)																	_hx_tmp3 = c2;
            																}
HXDLIN( 116)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXLINE( 116)															if (forceClear) {
HXLINE( 116)																::Dynamic this24 = undoImage->image;
HXDLIN( 116)																int x2 = (dx - rectLeft);
HXDLIN( 116)																int y2 = (dy - rectTop);
HXDLIN( 116)																int index3;
HXDLIN( 116)																if (undoImage->useVirtualPos) {
HXLINE( 116)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXLINE( 116)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 116)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 116)								{
HXLINE( 116)									int _g_min = xIter3->start;
HXDLIN( 116)									int _g_max = xIter3->max;
HXDLIN( 116)									while((_g_min < _g_max)){
HXLINE( 116)										_g_min = (_g_min + 1);
HXDLIN( 116)										int px = (_g_min - 1);
HXDLIN( 116)										Float pcx = (( (Float)(px) ) - nextX);
HXDLIN( 116)										{
HXLINE( 116)											int _g_min1 = yIter3->start;
HXDLIN( 116)											int _g_max1 = yIter3->max;
HXDLIN( 116)											while((_g_min1 < _g_max1)){
HXLINE( 116)												_g_min1 = (_g_min1 + 1);
HXDLIN( 116)												int py = (_g_min1 - 1);
HXDLIN( 116)												Float pcy = (( (Float)(py) ) - nextY);
HXDLIN( 116)												Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 116)												Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 116)												Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 116)												Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 116)												Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 116)												bool _hx_tmp4;
HXDLIN( 116)												bool _hx_tmp5;
HXDLIN( 116)												if ((ratioA >= 0)) {
HXLINE( 116)													_hx_tmp5 = (ratioB >= 0);
            												}
            												else {
HXLINE( 116)													_hx_tmp5 = false;
            												}
HXDLIN( 116)												if (_hx_tmp5) {
HXLINE( 116)													_hx_tmp4 = (ratioC >= 0);
            												}
            												else {
HXLINE( 116)													_hx_tmp4 = false;
            												}
HXDLIN( 116)												if (_hx_tmp4) {
HXLINE( 116)													int i7 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 116)													if ((i7 > 255)) {
HXLINE(  24)														i7 = 255;
            													}
HXLINE( 116)													if ((i7 < 0)) {
HXLINE(  25)														i7 = 0;
            													}
HXLINE( 116)													int a5 = i7;
HXDLIN( 116)													int i8 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 116)													if ((i8 > 255)) {
HXLINE(  24)														i8 = 255;
            													}
HXLINE( 116)													if ((i8 < 0)) {
HXLINE(  25)														i8 = 0;
            													}
HXLINE( 116)													int r3 = i8;
HXDLIN( 116)													int i9 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 116)													if ((i9 > 255)) {
HXLINE(  24)														i9 = 255;
            													}
HXLINE( 116)													if ((i9 < 0)) {
HXLINE(  25)														i9 = 0;
            													}
HXLINE( 116)													int g3 = i9;
HXDLIN( 116)													int i10 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 116)													if ((i10 > 255)) {
HXLINE(  24)														i10 = 255;
            													}
HXLINE( 116)													if ((i10 < 0)) {
HXLINE(  25)														i10 = 0;
            													}
HXLINE( 116)													int b4 = i10;
HXDLIN( 116)													{
HXLINE( 116)														int location1;
HXDLIN( 116)														if (this2->useVirtualPos) {
HXLINE( 116)															location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this2->virtualY) * ( (Float)(this2->width) )) + px) - this2->virtualX));
            														}
            														else {
HXLINE( 116)															location1 = ::Std_obj::_hx_int(( (Float)(((py * this2->width) + px)) ));
            														}
HXDLIN( 116)														bool _hx_tmp6;
HXDLIN( 116)														if (this2->transparent) {
HXLINE( 116)															_hx_tmp6 = (a5 < 254);
            														}
            														else {
HXLINE( 116)															_hx_tmp6 = false;
            														}
HXDLIN( 116)														if (_hx_tmp6) {
HXLINE( 116)															int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 116)															int old;
HXDLIN( 116)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																old = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            															}
            															else {
HXLINE( 116)																old = this25;
            															}
HXDLIN( 116)															int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 116)															Float a11;
HXDLIN( 116)															int this26 = ((old >> 24) & 255);
HXDLIN( 116)															if ((this26 == 0)) {
HXLINE( 116)																a11 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float r11;
HXDLIN( 116)															int this27 = ((old >> 16) & 255);
HXDLIN( 116)															if ((this27 == 0)) {
HXLINE( 116)																r11 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float g11;
HXDLIN( 116)															int this28 = ((old >> 8) & 255);
HXDLIN( 116)															if ((this28 == 0)) {
HXLINE( 116)																g11 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float b12;
HXDLIN( 116)															int this29 = (old & 255);
HXDLIN( 116)															if ((this29 == 0)) {
HXLINE( 116)																b12 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float a21;
HXDLIN( 116)															int this30 = ((rhs >> 24) & 255);
HXDLIN( 116)															if ((this30 == 0)) {
HXLINE( 116)																a21 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float r21;
HXDLIN( 116)															int this31 = ((rhs >> 16) & 255);
HXDLIN( 116)															if ((this31 == 0)) {
HXLINE( 116)																r21 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float g21;
HXDLIN( 116)															int this32 = ((rhs >> 8) & 255);
HXDLIN( 116)															if ((this32 == 0)) {
HXLINE( 116)																g21 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float b22;
HXDLIN( 116)															int this33 = (rhs & 255);
HXDLIN( 116)															if ((this33 == 0)) {
HXLINE( 116)																b22 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 116)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 116)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 116)															int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 116)															int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 116)															int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 116)															{
HXLINE( 116)																int _hx_tmp7;
HXDLIN( 116)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																	_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																}
            																else {
HXLINE( 116)																	_hx_tmp7 = blended1;
            																}
HXDLIN( 116)																::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp7);
            															}
            														}
            														else {
HXLINE( 116)															int value;
HXDLIN( 116)															if (this2->isLittle) {
HXLINE( 116)																value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            															}
            															else {
HXLINE( 116)																value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            															}
HXDLIN( 116)															::iterMagic::Iimg_obj::set(this2->image,location1,value);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 116)								if ((hasHit == false)) {
HXLINE( 116)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX,nextY,true);
HXDLIN( 116)									if (hasUndo) {
HXLINE( 116)										v2->undoImage = undoImage;
HXDLIN( 116)										v2->undoX = xIter3->start;
HXDLIN( 116)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
HXLINE( 236)						lastX = nextX;
HXLINE( 237)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXLINE( 116)				int _g22 = 0;
HXDLIN( 116)				int _g23 = (sides + 1);
HXDLIN( 116)				while((_g22 < _g23)){
HXLINE( 116)					_g22 = (_g22 + 1);
HXDLIN( 116)					int i11 = (_g22 - 1);
HXDLIN( 116)					Float nextX1 = (cx + (rx * ::Math_obj::cos(((( (Float)(i11) ) * theta) + omega))));
HXDLIN( 116)					Float nextY1 = (cy + (ry * ::Math_obj::sin(((( (Float)(i11) ) * theta) + omega))));
HXDLIN( 116)					{
HXLINE( 116)						 ::pi_xy::ImageStruct this34 = this1;
HXDLIN( 116)						{
HXLINE( 116)							bool hasHit1 = false;
HXDLIN( 116)							bool hasUndo1 = false;
HXDLIN( 116)							int aA1 = ((colorOut >> 24) & 255);
HXDLIN( 116)							int rA1 = ((colorOut >> 16) & 255);
HXDLIN( 116)							int gA1 = ((colorOut >> 8) & 255);
HXDLIN( 116)							int bA1 = (colorOut & 255);
HXDLIN( 116)							int aB1 = ((colorIn >> 24) & 255);
HXDLIN( 116)							int rB1 = ((colorIn >> 16) & 255);
HXDLIN( 116)							int gB1 = ((colorIn >> 8) & 255);
HXDLIN( 116)							int bB1 = (colorIn & 255);
HXDLIN( 116)							int aC1 = ((colorOut >> 24) & 255);
HXDLIN( 116)							int rC1 = ((colorOut >> 16) & 255);
HXDLIN( 116)							int gC1 = ((colorOut >> 8) & 255);
HXDLIN( 116)							int bC1 = (colorOut & 255);
HXDLIN( 116)							Float bcx1 = (lastX - nextX1);
HXDLIN( 116)							Float bcy1 = (lastY - nextY1);
HXDLIN( 116)							Float acx1 = (mx - nextX1);
HXDLIN( 116)							Float acy1 = (my - nextY1);
HXDLIN( 116)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 116)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 116)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 116)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 116)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 116)							if ((mx > lastX)) {
HXLINE( 116)								if ((mx > nextX1)) {
HXLINE( 116)									int min4;
HXDLIN( 116)									if ((lastX > nextX1)) {
HXLINE( 116)										min4 = ::Math_obj::floor(nextX1);
            									}
            									else {
HXLINE( 116)										min4 = ::Math_obj::floor(lastX);
            									}
HXDLIN( 116)									int ii_min8 = min4;
HXDLIN( 116)									int ii_max8 = ::Math_obj::ceil(mx);
HXDLIN( 116)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXLINE( 116)									int ii_min9 = ::Math_obj::floor(lastX);
HXDLIN( 116)									int ii_max9 = ::Math_obj::ceil(nextX1);
HXDLIN( 116)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXLINE( 116)								if ((lastX > nextX1)) {
HXLINE( 116)									int min5;
HXDLIN( 116)									if ((mx > nextX1)) {
HXLINE( 116)										min5 = ::Math_obj::floor(nextX1);
            									}
            									else {
HXLINE( 116)										min5 = ::Math_obj::ceil(mx);
            									}
HXDLIN( 116)									int ii_min10 = min5;
HXDLIN( 116)									int ii_max10 = ::Math_obj::ceil(lastX);
HXDLIN( 116)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXLINE( 116)									int ii_min11 = ::Math_obj::floor(mx);
HXDLIN( 116)									int ii_max11 = ::Math_obj::ceil(nextX1);
HXDLIN( 116)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 116)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 116)							if ((my > lastY)) {
HXLINE( 116)								if ((my > nextY1)) {
HXLINE( 116)									int min6;
HXDLIN( 116)									if ((lastY > nextY1)) {
HXLINE( 116)										min6 = ::Math_obj::floor(nextY1);
            									}
            									else {
HXLINE( 116)										min6 = ::Math_obj::floor(lastY);
            									}
HXDLIN( 116)									int ii_min12 = min6;
HXDLIN( 116)									int ii_max12 = ::Math_obj::ceil(my);
HXDLIN( 116)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXLINE( 116)									int ii_min13 = ::Math_obj::floor(lastY);
HXDLIN( 116)									int ii_max13 = ::Math_obj::ceil(nextY1);
HXDLIN( 116)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXLINE( 116)								if ((lastY > nextY1)) {
HXLINE( 116)									int min7;
HXDLIN( 116)									if ((my > nextY1)) {
HXLINE( 116)										min7 = ::Math_obj::floor(nextY1);
            									}
            									else {
HXLINE( 116)										min7 = ::Math_obj::ceil(my);
            									}
HXDLIN( 116)									int ii_min14 = min7;
HXDLIN( 116)									int ii_max14 = ::Math_obj::ceil(lastY);
HXDLIN( 116)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXLINE( 116)									int ii_min15 = ::Math_obj::floor(my);
HXDLIN( 116)									int ii_max15 = ::Math_obj::ceil(nextY1);
HXDLIN( 116)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 116)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 116)							if (hasUndo1) {
HXLINE( 116)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 116)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 116)								 ::Dynamic imageType1 = null();
HXDLIN( 116)								 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 116)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 116)								::Dynamic undoImage4;
HXDLIN( 116)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXLINE( 116)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 116)										 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 116)										{
HXLINE( 116)											b6->width = width1;
HXDLIN( 116)											b6->height = height1;
HXDLIN( 116)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 116)											b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 116)											{
HXLINE( 116)												int len2 = b6->length;
HXDLIN( 116)												int w1 = 0;
HXDLIN( 116)												{
HXLINE( 116)													int _g24 = 0;
HXDLIN( 116)													int _g25 = b6->height;
HXDLIN( 116)													while((_g24 < _g25)){
HXLINE( 116)														_g24 = (_g24 + 1);
HXDLIN( 116)														int y3 = (_g24 - 1);
HXDLIN( 116)														{
HXLINE( 116)															int _g26 = 0;
HXDLIN( 116)															int _g27 = b6->width;
HXDLIN( 116)															while((_g26 < _g27)){
HXLINE( 116)																_g26 = (_g26 + 1);
HXDLIN( 116)																int x3 = (_g26 - 1);
HXDLIN( 116)																{
HXLINE( 116)																	w1 = (w1 + 1);
HXDLIN( 116)																	b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 116)																{
HXLINE( 116)																	w1 = (w1 + 1);
HXDLIN( 116)																	b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 116)																{
HXLINE( 116)																	w1 = (w1 + 1);
HXDLIN( 116)																	b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 116)																{
HXLINE( 116)																	w1 = (w1 + 1);
HXDLIN( 116)																	b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 116)										undoImage4 = b6;
            									}
            									break;
            									case (int)1: {
HXLINE( 116)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)										 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 116)										{
HXLINE( 116)											a7->width = width1;
HXDLIN( 116)											a7->height = height1;
HXDLIN( 116)											a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 116)											a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 116)											{
HXLINE( 116)												int _g28 = 0;
HXDLIN( 116)												int _g29 = a7->length;
HXDLIN( 116)												while((_g28 < _g29)){
HXLINE( 116)													_g28 = (_g28 + 1);
HXDLIN( 116)													int i12 = (_g28 - 1);
HXDLIN( 116)													a7->data[i12] = 0;
            												}
            											}
            										}
HXDLIN( 116)										undoImage4 = a7;
            									}
            									break;
            									case (int)2: {
HXLINE( 116)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 116)										 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 116)										{
HXLINE( 116)											b7->width = width1;
HXDLIN( 116)											b7->height = height1;
HXDLIN( 116)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 116)											int size1 = (b7->length * 4);
HXDLIN( 116)											b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 116)											{
HXLINE( 116)												int _g30 = 0;
HXDLIN( 116)												int _g31 = b7->length;
HXDLIN( 116)												while((_g30 < _g31)){
HXLINE( 116)													_g30 = (_g30 + 1);
HXDLIN( 116)													int i13 = (_g30 - 1);
HXDLIN( 116)													{
HXLINE( 116)														 ::haxe::io::ArrayBufferViewImpl this36 = b7->data;
HXDLIN( 116)														bool undoImage5;
HXDLIN( 116)														if ((i13 >= 0)) {
HXLINE( 116)															undoImage5 = (i13 < (this36->byteLength >> 2));
            														}
            														else {
HXLINE( 116)															undoImage5 = false;
            														}
HXDLIN( 116)														if (undoImage5) {
HXLINE( 116)															 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 116)															int pos1 = ((i13 << 2) + this36->byteOffset);
HXDLIN( 116)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 116)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 116)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 116)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 116)										undoImage4 = b7;
            									}
            									break;
            									case (int)3: {
HXLINE( 116)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 116)										{
HXLINE( 116)											v3->width = width1;
HXDLIN( 116)											v3->height = height1;
HXDLIN( 116)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 116)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 116)											{
HXLINE( 116)												int _g32 = 0;
HXDLIN( 116)												int _g33 = v3->length;
HXDLIN( 116)												while((_g32 < _g33)){
HXLINE( 116)													_g32 = (_g32 + 1);
HXDLIN( 116)													int i14 = (_g32 - 1);
HXDLIN( 116)													v3->data->__unsafe_set(i14,0);
            												}
            											}
            										}
HXDLIN( 116)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXLINE( 116)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)										 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 116)										{
HXLINE( 116)											b8->width = width1;
HXDLIN( 116)											b8->height = height1;
HXDLIN( 116)											b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 116)											b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 116)											{
HXLINE( 116)												int len3 = b8->length;
HXDLIN( 116)												 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 116)												if (::hx::IsNull( d1->head )) {
HXLINE( 116)													int _g34 = 0;
HXDLIN( 116)													int _g35 = len3;
HXDLIN( 116)													while((_g34 < _g35)){
HXLINE( 116)														_g34 = (_g34 + 1);
HXDLIN( 116)														int i15 = (_g34 - 1);
HXDLIN( 116)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXLINE( 116)													int _g36 = 0;
HXDLIN( 116)													int _g37 = len3;
HXDLIN( 116)													while((_g36 < _g37)){
HXLINE( 116)														_g36 = (_g36 + 1);
HXDLIN( 116)														int i16 = (_g36 - 1);
HXDLIN( 116)														{
HXLINE( 116)															 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 116)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 116)															{
HXLINE( 116)																int _g38 = 0;
HXDLIN( 116)																int _g39 = i16;
HXDLIN( 116)																while((_g38 < _g39)){
HXLINE( 116)																	_g38 = (_g38 + 1);
HXDLIN( 116)																	int i17 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 116)															if (::hx::IsNull( prev1 )) {
HXLINE( 116)																b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 116)																l1 = null();
            															}
            															else {
HXLINE( 116)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 116)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 116)										undoImage4 = b8;
            									}
            									break;
            								}
HXDLIN( 116)								this35->image = undoImage4;
HXDLIN( 116)								this35->width = width1;
HXDLIN( 116)								this35->height = height1;
HXDLIN( 116)								this35->imageType = ( (int)(imageType1) );
HXDLIN( 116)								undoImage3 = this35;
HXDLIN( 116)								{
HXLINE( 116)									int rectLeft1 = xIter31->start;
HXDLIN( 116)									int rectTop1 = yIter31->start;
HXDLIN( 116)									int rectRight1 = xIter31->max;
HXDLIN( 116)									bool forceClear1 = false;
HXDLIN( 116)									{
HXLINE( 116)										int _g40 = rectTop1;
HXDLIN( 116)										int _g41 = yIter31->max;
HXDLIN( 116)										while((_g40 < _g41)){
HXLINE( 116)											_g40 = (_g40 + 1);
HXDLIN( 116)											int dy1 = (_g40 - 1);
HXDLIN( 116)											{
HXLINE( 116)												int _g42 = rectLeft1;
HXDLIN( 116)												int _g43 = rectRight1;
HXDLIN( 116)												while((_g42 < _g43)){
HXLINE( 116)													_g42 = (_g42 + 1);
HXDLIN( 116)													int dx1 = (_g42 - 1);
HXDLIN( 116)													::Dynamic this37 = this34->image;
HXDLIN( 116)													int index4;
HXDLIN( 116)													if (this34->useVirtualPos) {
HXLINE( 116)														index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this34->virtualY) * ( (Float)(this34->width) )) + dx1) - this34->virtualX));
            													}
            													else {
HXLINE( 116)														index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this34->width) + dx1)) ));
            													}
HXDLIN( 116)													int c3 = ::iterMagic::Iimg_obj::get(this37,index4);
HXDLIN( 116)													int col1;
HXDLIN( 116)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)														col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            													}
            													else {
HXLINE( 116)														col1 = c3;
            													}
HXDLIN( 116)													bool _hx_tmp8;
HXDLIN( 116)													if (this34->useMask) {
HXLINE( 116)														_hx_tmp8 = ::hx::IsNotNull( this34->mask );
            													}
            													else {
HXLINE( 116)														_hx_tmp8 = false;
            													}
HXDLIN( 116)													if (_hx_tmp8) {
HXLINE( 116)														 ::pi_xy::ImageStruct this38 = this34->mask;
HXDLIN( 116)														::Dynamic this39 = this38->image;
HXDLIN( 116)														int index5;
HXDLIN( 116)														if (this38->useVirtualPos) {
HXLINE( 116)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx1) - this38->virtualX));
            														}
            														else {
HXLINE( 116)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this38->width) + dx1)) ));
            														}
HXDLIN( 116)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 116)														int v4;
HXDLIN( 116)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)															v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXLINE( 116)															v4 = c4;
            														}
HXDLIN( 116)														int maskPixel1 = v4;
HXDLIN( 116)														int this40 = col1;
HXDLIN( 116)														if ((maskPixel1 == 0)) {
HXLINE( 116)															col1 = this40;
            														}
            														else {
HXLINE( 116)															Float m01;
HXDLIN( 116)															int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 116)															if ((this41 == 0)) {
HXLINE( 116)																m01 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float m11;
HXDLIN( 116)															int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 116)															if ((this42 == 0)) {
HXLINE( 116)																m11 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float m21;
HXDLIN( 116)															int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 116)															if ((this43 == 0)) {
HXLINE( 116)																m21 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float m31;
HXDLIN( 116)															int this44 = (maskPixel1 & 255);
HXDLIN( 116)															if ((this44 == 0)) {
HXLINE( 116)																m31 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 116)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 116)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 116)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 116)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 116)													if ((col1 != 0)) {
HXLINE( 116)														int x4 = (dx1 - rectLeft1);
HXDLIN( 116)														int y4 = (dy1 - rectTop1);
HXDLIN( 116)														int c5 = col1;
HXDLIN( 116)														bool _hx_tmp9;
HXDLIN( 116)														if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 116)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXLINE( 116)															_hx_tmp9 = false;
            														}
HXDLIN( 116)														if (_hx_tmp9) {
HXLINE( 116)															int location2;
HXDLIN( 116)															if (undoImage3->useVirtualPos) {
HXLINE( 116)																location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 116)																location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            															}
HXDLIN( 116)															int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 116)															int this46;
HXDLIN( 116)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            															}
            															else {
HXLINE( 116)																this46 = this45;
            															}
HXDLIN( 116)															Float a12;
HXDLIN( 116)															int this47 = ((this46 >> 24) & 255);
HXDLIN( 116)															if ((this47 == 0)) {
HXLINE( 116)																a12 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float r12;
HXDLIN( 116)															int this48 = ((this46 >> 16) & 255);
HXDLIN( 116)															if ((this48 == 0)) {
HXLINE( 116)																r12 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float g12;
HXDLIN( 116)															int this49 = ((this46 >> 8) & 255);
HXDLIN( 116)															if ((this49 == 0)) {
HXLINE( 116)																g12 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float b13;
HXDLIN( 116)															int this50 = (this46 & 255);
HXDLIN( 116)															if ((this50 == 0)) {
HXLINE( 116)																b13 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float a22;
HXDLIN( 116)															int this51 = ((col1 >> 24) & 255);
HXDLIN( 116)															if ((this51 == 0)) {
HXLINE( 116)																a22 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float r22;
HXDLIN( 116)															int this52 = ((col1 >> 16) & 255);
HXDLIN( 116)															if ((this52 == 0)) {
HXLINE( 116)																r22 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float g22;
HXDLIN( 116)															int this53 = ((col1 >> 8) & 255);
HXDLIN( 116)															if ((this53 == 0)) {
HXLINE( 116)																g22 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float b23;
HXDLIN( 116)															int this54 = (col1 & 255);
HXDLIN( 116)															if ((this54 == 0)) {
HXLINE( 116)																b23 = ((Float)0.);
            															}
            															else {
HXLINE( 116)																b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 116)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 116)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 116)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 116)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 116)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 116)															int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 116)															{
HXLINE( 116)																int _hx_tmp10;
HXDLIN( 116)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXLINE( 116)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 116)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXLINE( 116)															::Dynamic this55 = undoImage3->image;
HXDLIN( 116)															int index6;
HXDLIN( 116)															if (undoImage3->useVirtualPos) {
HXLINE( 116)																index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 116)																index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            															}
HXDLIN( 116)															int _hx_tmp11;
HXDLIN( 116)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXLINE( 116)																_hx_tmp11 = c5;
            															}
HXDLIN( 116)															::iterMagic::Iimg_obj::set(this55,index6,_hx_tmp11);
            														}
            													}
            													else {
HXLINE( 116)														if (forceClear1) {
HXLINE( 116)															::Dynamic this56 = undoImage3->image;
HXDLIN( 116)															int x5 = (dx1 - rectLeft1);
HXDLIN( 116)															int y5 = (dy1 - rectTop1);
HXDLIN( 116)															int index7;
HXDLIN( 116)															if (undoImage3->useVirtualPos) {
HXLINE( 116)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXLINE( 116)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 116)															::iterMagic::Iimg_obj::set(this56,index7,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 116)							{
HXLINE( 116)								int _g_min2 = xIter31->start;
HXDLIN( 116)								int _g_max2 = xIter31->max;
HXDLIN( 116)								while((_g_min2 < _g_max2)){
HXLINE( 116)									_g_min2 = (_g_min2 + 1);
HXDLIN( 116)									int px1 = (_g_min2 - 1);
HXDLIN( 116)									Float pcx1 = (( (Float)(px1) ) - nextX1);
HXDLIN( 116)									{
HXLINE( 116)										int _g_min3 = yIter31->start;
HXDLIN( 116)										int _g_max3 = yIter31->max;
HXDLIN( 116)										while((_g_min3 < _g_max3)){
HXLINE( 116)											_g_min3 = (_g_min3 + 1);
HXDLIN( 116)											int py1 = (_g_min3 - 1);
HXDLIN( 116)											Float pcy1 = (( (Float)(py1) ) - nextY1);
HXDLIN( 116)											Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 116)											Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 116)											Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 116)											Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 116)											Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 116)											bool _hx_tmp12;
HXDLIN( 116)											bool _hx_tmp13;
HXDLIN( 116)											if ((ratioA1 >= 0)) {
HXLINE( 116)												_hx_tmp13 = (ratioB1 >= 0);
            											}
            											else {
HXLINE( 116)												_hx_tmp13 = false;
            											}
HXDLIN( 116)											if (_hx_tmp13) {
HXLINE( 116)												_hx_tmp12 = (ratioC1 >= 0);
            											}
            											else {
HXLINE( 116)												_hx_tmp12 = false;
            											}
HXDLIN( 116)											if (_hx_tmp12) {
HXLINE( 116)												int i18 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 116)												if ((i18 > 255)) {
HXLINE(  24)													i18 = 255;
            												}
HXLINE( 116)												if ((i18 < 0)) {
HXLINE(  25)													i18 = 0;
            												}
HXLINE( 116)												int a9 = i18;
HXDLIN( 116)												int i19 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 116)												if ((i19 > 255)) {
HXLINE(  24)													i19 = 255;
            												}
HXLINE( 116)												if ((i19 < 0)) {
HXLINE(  25)													i19 = 0;
            												}
HXLINE( 116)												int r6 = i19;
HXDLIN( 116)												int i20 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 116)												if ((i20 > 255)) {
HXLINE(  24)													i20 = 255;
            												}
HXLINE( 116)												if ((i20 < 0)) {
HXLINE(  25)													i20 = 0;
            												}
HXLINE( 116)												int g6 = i20;
HXDLIN( 116)												int i21 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 116)												if ((i21 > 255)) {
HXLINE(  24)													i21 = 255;
            												}
HXLINE( 116)												if ((i21 < 0)) {
HXLINE(  25)													i21 = 0;
            												}
HXLINE( 116)												int b10 = i21;
HXDLIN( 116)												{
HXLINE( 116)													int location3;
HXDLIN( 116)													if (this34->useVirtualPos) {
HXLINE( 116)														location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this34->virtualY) * ( (Float)(this34->width) )) + px1) - this34->virtualX));
            													}
            													else {
HXLINE( 116)														location3 = ::Std_obj::_hx_int(( (Float)(((py1 * this34->width) + px1)) ));
            													}
HXDLIN( 116)													bool _hx_tmp14;
HXDLIN( 116)													if (this34->transparent) {
HXLINE( 116)														_hx_tmp14 = (a9 < 254);
            													}
            													else {
HXLINE( 116)														_hx_tmp14 = false;
            													}
HXDLIN( 116)													if (_hx_tmp14) {
HXLINE( 116)														int this57 = ::iterMagic::Iimg_obj::get(this34->image,location3);
HXDLIN( 116)														int old1;
HXDLIN( 116)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)															old1 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            														}
            														else {
HXLINE( 116)															old1 = this57;
            														}
HXDLIN( 116)														int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 116)														Float a13;
HXDLIN( 116)														int this58 = ((old1 >> 24) & 255);
HXDLIN( 116)														if ((this58 == 0)) {
HXLINE( 116)															a13 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															a13 = (( (Float)(this58) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float r13;
HXDLIN( 116)														int this59 = ((old1 >> 16) & 255);
HXDLIN( 116)														if ((this59 == 0)) {
HXLINE( 116)															r13 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															r13 = (( (Float)(this59) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float g13;
HXDLIN( 116)														int this60 = ((old1 >> 8) & 255);
HXDLIN( 116)														if ((this60 == 0)) {
HXLINE( 116)															g13 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															g13 = (( (Float)(this60) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float b14;
HXDLIN( 116)														int this61 = (old1 & 255);
HXDLIN( 116)														if ((this61 == 0)) {
HXLINE( 116)															b14 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															b14 = (( (Float)(this61) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float a23;
HXDLIN( 116)														int this62 = ((rhs1 >> 24) & 255);
HXDLIN( 116)														if ((this62 == 0)) {
HXLINE( 116)															a23 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															a23 = (( (Float)(this62) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float r23;
HXDLIN( 116)														int this63 = ((rhs1 >> 16) & 255);
HXDLIN( 116)														if ((this63 == 0)) {
HXLINE( 116)															r23 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															r23 = (( (Float)(this63) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float g23;
HXDLIN( 116)														int this64 = ((rhs1 >> 8) & 255);
HXDLIN( 116)														if ((this64 == 0)) {
HXLINE( 116)															g23 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															g23 = (( (Float)(this64) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float b24;
HXDLIN( 116)														int this65 = (rhs1 & 255);
HXDLIN( 116)														if ((this65 == 0)) {
HXLINE( 116)															b24 = ((Float)0.);
            														}
            														else {
HXLINE( 116)															b24 = (( (Float)(this65) ) / ( (Float)(255) ));
            														}
HXDLIN( 116)														Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 116)														int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 116)														int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 116)														int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 116)														int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 116)														int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 116)														{
HXLINE( 116)															int _hx_tmp15;
HXDLIN( 116)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)																_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            															}
            															else {
HXLINE( 116)																_hx_tmp15 = blended3;
            															}
HXDLIN( 116)															::iterMagic::Iimg_obj::set(this34->image,location3,_hx_tmp15);
            														}
            													}
            													else {
HXLINE( 116)														int value1;
HXDLIN( 116)														if (this34->isLittle) {
HXLINE( 116)															value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            														}
            														else {
HXLINE( 116)															value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            														}
HXDLIN( 116)														::iterMagic::Iimg_obj::set(this34->image,location3,value1);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 116)							if ((hasHit1 == false)) {
HXLINE( 116)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX1,nextY1,true);
HXDLIN( 116)								if (hasUndo1) {
HXLINE( 116)									v5->undoImage = undoImage3;
HXDLIN( 116)									v5->undoX = xIter31->start;
HXDLIN( 116)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
HXLINE( 244)					lastX = nextX1;
HXLINE( 245)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(GradientShape_Impl__obj,radialEllipseTri,(void))

 ::pi_xy::algo::HitTri GradientShape_Impl__obj::sweepTri( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float rx,Float ry,Float startRadian,Float sweepRadian,int colA,int colB,int colC,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_130_sweepTri)
HXLINE( 131)		Float currAngle = startRadian;
HXLINE( 132)		Float bx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 133)		Float by = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 135)		currAngle = (startRadian + sweepRadian);
HXLINE( 136)		Float cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 137)		Float cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 138)		bool hasHit1 = false;
HXDLIN( 138)		bool hasUndo = false;
HXDLIN( 138)		int aA = ((colB >> 24) & 255);
HXDLIN( 138)		int rA = ((colB >> 16) & 255);
HXDLIN( 138)		int gA = ((colB >> 8) & 255);
HXDLIN( 138)		int bA = (colB & 255);
HXDLIN( 138)		int aB = ((colA >> 24) & 255);
HXDLIN( 138)		int rB = ((colA >> 16) & 255);
HXDLIN( 138)		int gB = ((colA >> 8) & 255);
HXDLIN( 138)		int bB = (colA & 255);
HXDLIN( 138)		int aC = ((colC >> 24) & 255);
HXDLIN( 138)		int rC = ((colC >> 16) & 255);
HXDLIN( 138)		int gC = ((colC >> 8) & 255);
HXDLIN( 138)		int bC = (colC & 255);
HXDLIN( 138)		Float bcx = (bx - cx);
HXDLIN( 138)		Float bcy = (by - cy);
HXDLIN( 138)		Float acx = (ax - cx);
HXDLIN( 138)		Float acy = (ay - cy);
HXDLIN( 138)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 138)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 138)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 138)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 138)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 138)		if ((ax > bx)) {
HXLINE( 138)			if ((ax > cx)) {
HXLINE( 138)				int min;
HXDLIN( 138)				if ((bx > cx)) {
HXLINE( 138)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 138)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 138)				int ii_min = min;
HXDLIN( 138)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 138)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 138)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 138)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 138)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 138)			if ((bx > cx)) {
HXLINE( 138)				int min1;
HXDLIN( 138)				if ((ax > cx)) {
HXLINE( 138)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 138)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 138)				int ii_min2 = min1;
HXDLIN( 138)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 138)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 138)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 138)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 138)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 138)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 138)		if ((ay > by)) {
HXLINE( 138)			if ((ay > cy)) {
HXLINE( 138)				int min2;
HXDLIN( 138)				if ((by > cy)) {
HXLINE( 138)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 138)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 138)				int ii_min4 = min2;
HXDLIN( 138)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 138)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 138)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 138)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 138)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 138)			if ((by > cy)) {
HXLINE( 138)				int min3;
HXDLIN( 138)				if ((ay > cy)) {
HXLINE( 138)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 138)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 138)				int ii_min6 = min3;
HXDLIN( 138)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 138)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 138)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 138)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 138)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 138)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 138)		if (hasUndo) {
HXLINE( 138)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 138)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 138)			 ::Dynamic imageType = null();
HXDLIN( 138)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 138)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 138)			::Dynamic undoImage1;
HXDLIN( 138)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 138)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 138)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 138)					{
HXLINE( 138)						b->width = width;
HXDLIN( 138)						b->height = height;
HXDLIN( 138)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 138)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 138)						{
HXLINE( 138)							int len = b->length;
HXDLIN( 138)							int w = 0;
HXDLIN( 138)							{
HXLINE( 138)								int _g = 0;
HXDLIN( 138)								int _g1 = b->height;
HXDLIN( 138)								while((_g < _g1)){
HXLINE( 138)									_g = (_g + 1);
HXDLIN( 138)									int y = (_g - 1);
HXDLIN( 138)									{
HXLINE( 138)										int _g2 = 0;
HXDLIN( 138)										int _g3 = b->width;
HXDLIN( 138)										while((_g2 < _g3)){
HXLINE( 138)											_g2 = (_g2 + 1);
HXDLIN( 138)											int x = (_g2 - 1);
HXDLIN( 138)											{
HXLINE( 138)												w = (w + 1);
HXDLIN( 138)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 138)											{
HXLINE( 138)												w = (w + 1);
HXDLIN( 138)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 138)											{
HXLINE( 138)												w = (w + 1);
HXDLIN( 138)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 138)											{
HXLINE( 138)												w = (w + 1);
HXDLIN( 138)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 138)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 138)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 138)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 138)					{
HXLINE( 138)						a->width = width;
HXDLIN( 138)						a->height = height;
HXDLIN( 138)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 138)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 138)						{
HXLINE( 138)							int _g4 = 0;
HXDLIN( 138)							int _g5 = a->length;
HXDLIN( 138)							while((_g4 < _g5)){
HXLINE( 138)								_g4 = (_g4 + 1);
HXDLIN( 138)								int i = (_g4 - 1);
HXDLIN( 138)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 138)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 138)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 138)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 138)					{
HXLINE( 138)						b1->width = width;
HXDLIN( 138)						b1->height = height;
HXDLIN( 138)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 138)						int size = (b1->length * 4);
HXDLIN( 138)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 138)						{
HXLINE( 138)							int _g6 = 0;
HXDLIN( 138)							int _g7 = b1->length;
HXDLIN( 138)							while((_g6 < _g7)){
HXLINE( 138)								_g6 = (_g6 + 1);
HXDLIN( 138)								int i1 = (_g6 - 1);
HXDLIN( 138)								{
HXLINE( 138)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 138)									bool undoImage2;
HXDLIN( 138)									if ((i1 >= 0)) {
HXLINE( 138)										undoImage2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXLINE( 138)										undoImage2 = false;
            									}
HXDLIN( 138)									if (undoImage2) {
HXLINE( 138)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 138)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 138)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 138)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 138)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 138)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 138)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 138)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 138)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 138)					{
HXLINE( 138)						v->width = width;
HXDLIN( 138)						v->height = height;
HXDLIN( 138)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 138)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 138)						{
HXLINE( 138)							int _g8 = 0;
HXDLIN( 138)							int _g9 = v->length;
HXDLIN( 138)							while((_g8 < _g9)){
HXLINE( 138)								_g8 = (_g8 + 1);
HXDLIN( 138)								int i2 = (_g8 - 1);
HXDLIN( 138)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 138)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 138)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 138)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 138)					{
HXLINE( 138)						b2->width = width;
HXDLIN( 138)						b2->height = height;
HXDLIN( 138)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 138)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 138)						{
HXLINE( 138)							int len1 = b2->length;
HXDLIN( 138)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 138)							if (::hx::IsNull( d->head )) {
HXLINE( 138)								int _g10 = 0;
HXDLIN( 138)								int _g11 = len1;
HXDLIN( 138)								while((_g10 < _g11)){
HXLINE( 138)									_g10 = (_g10 + 1);
HXDLIN( 138)									int i3 = (_g10 - 1);
HXDLIN( 138)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 138)								int _g12 = 0;
HXDLIN( 138)								int _g13 = len1;
HXDLIN( 138)								while((_g12 < _g13)){
HXLINE( 138)									_g12 = (_g12 + 1);
HXDLIN( 138)									int i4 = (_g12 - 1);
HXDLIN( 138)									{
HXLINE( 138)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 138)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 138)										{
HXLINE( 138)											int _g14 = 0;
HXDLIN( 138)											int _g15 = i4;
HXDLIN( 138)											while((_g14 < _g15)){
HXLINE( 138)												_g14 = (_g14 + 1);
HXDLIN( 138)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 138)										if (::hx::IsNull( prev )) {
HXLINE( 138)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 138)											l = null();
            										}
            										else {
HXLINE( 138)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 138)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 138)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 138)			this2->image = undoImage1;
HXDLIN( 138)			this2->width = width;
HXDLIN( 138)			this2->height = height;
HXDLIN( 138)			this2->imageType = ( (int)(imageType) );
HXDLIN( 138)			undoImage = this2;
HXDLIN( 138)			{
HXLINE( 138)				int rectLeft = xIter3->start;
HXDLIN( 138)				int rectTop = yIter3->start;
HXDLIN( 138)				int rectRight = xIter3->max;
HXDLIN( 138)				bool forceClear = false;
HXDLIN( 138)				{
HXLINE( 138)					int _g16 = rectTop;
HXDLIN( 138)					int _g17 = yIter3->max;
HXDLIN( 138)					while((_g16 < _g17)){
HXLINE( 138)						_g16 = (_g16 + 1);
HXDLIN( 138)						int dy = (_g16 - 1);
HXDLIN( 138)						{
HXLINE( 138)							int _g18 = rectLeft;
HXDLIN( 138)							int _g19 = rectRight;
HXDLIN( 138)							while((_g18 < _g19)){
HXLINE( 138)								_g18 = (_g18 + 1);
HXDLIN( 138)								int dx = (_g18 - 1);
HXDLIN( 138)								::Dynamic this4 = this1->image;
HXDLIN( 138)								int index;
HXDLIN( 138)								if (this1->useVirtualPos) {
HXLINE( 138)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE( 138)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN( 138)								int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 138)								int col;
HXDLIN( 138)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 138)									col = c;
            								}
HXDLIN( 138)								bool _hx_tmp;
HXDLIN( 138)								if (this1->useMask) {
HXLINE( 138)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE( 138)									_hx_tmp = false;
            								}
HXDLIN( 138)								if (_hx_tmp) {
HXLINE( 138)									 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 138)									::Dynamic this6 = this5->image;
HXDLIN( 138)									int index1;
HXDLIN( 138)									if (this5->useVirtualPos) {
HXLINE( 138)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            									}
            									else {
HXLINE( 138)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            									}
HXDLIN( 138)									int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 138)									int v1;
HXDLIN( 138)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 138)										v1 = c1;
            									}
HXDLIN( 138)									int maskPixel = v1;
HXDLIN( 138)									int this7 = col;
HXDLIN( 138)									if ((maskPixel == 0)) {
HXLINE( 138)										col = this7;
            									}
            									else {
HXLINE( 138)										Float m0;
HXDLIN( 138)										int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 138)										if ((this8 == 0)) {
HXLINE( 138)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float m1;
HXDLIN( 138)										int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 138)										if ((this9 == 0)) {
HXLINE( 138)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float m2;
HXDLIN( 138)										int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 138)										if ((this10 == 0)) {
HXLINE( 138)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float m3;
HXDLIN( 138)										int this11 = (maskPixel & 255);
HXDLIN( 138)										if ((this11 == 0)) {
HXLINE( 138)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 138)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 138)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 138)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 138)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 138)								if ((col != 0)) {
HXLINE( 138)									int x1 = (dx - rectLeft);
HXDLIN( 138)									int y1 = (dy - rectTop);
HXDLIN( 138)									int c2 = col;
HXDLIN( 138)									bool _hx_tmp1;
HXDLIN( 138)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 138)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 138)										_hx_tmp1 = false;
            									}
HXDLIN( 138)									if (_hx_tmp1) {
HXLINE( 138)										int location;
HXDLIN( 138)										if (undoImage->useVirtualPos) {
HXLINE( 138)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 138)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 138)										int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 138)										int this13;
HXDLIN( 138)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)											this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            										}
            										else {
HXLINE( 138)											this13 = this12;
            										}
HXDLIN( 138)										Float a1;
HXDLIN( 138)										int this14 = ((this13 >> 24) & 255);
HXDLIN( 138)										if ((this14 == 0)) {
HXLINE( 138)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float r1;
HXDLIN( 138)										int this15 = ((this13 >> 16) & 255);
HXDLIN( 138)										if ((this15 == 0)) {
HXLINE( 138)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float g1;
HXDLIN( 138)										int this16 = ((this13 >> 8) & 255);
HXDLIN( 138)										if ((this16 == 0)) {
HXLINE( 138)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float b11;
HXDLIN( 138)										int this17 = (this13 & 255);
HXDLIN( 138)										if ((this17 == 0)) {
HXLINE( 138)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float a2;
HXDLIN( 138)										int this18 = ((col >> 24) & 255);
HXDLIN( 138)										if ((this18 == 0)) {
HXLINE( 138)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float r2;
HXDLIN( 138)										int this19 = ((col >> 16) & 255);
HXDLIN( 138)										if ((this19 == 0)) {
HXLINE( 138)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float g2;
HXDLIN( 138)										int this20 = ((col >> 8) & 255);
HXDLIN( 138)										if ((this20 == 0)) {
HXLINE( 138)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float b21;
HXDLIN( 138)										int this21 = (col & 255);
HXDLIN( 138)										if ((this21 == 0)) {
HXLINE( 138)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 138)											b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN( 138)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 138)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 138)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 138)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 138)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 138)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 138)										{
HXLINE( 138)											int _hx_tmp2;
HXDLIN( 138)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 138)												_hx_tmp2 = blended;
            											}
HXDLIN( 138)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 138)										::Dynamic this22 = undoImage->image;
HXDLIN( 138)										int index2;
HXDLIN( 138)										if (undoImage->useVirtualPos) {
HXLINE( 138)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 138)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 138)										int _hx_tmp3;
HXDLIN( 138)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 138)											_hx_tmp3 = c2;
            										}
HXDLIN( 138)										::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 138)									if (forceClear) {
HXLINE( 138)										::Dynamic this23 = undoImage->image;
HXDLIN( 138)										int x2 = (dx - rectLeft);
HXDLIN( 138)										int y2 = (dy - rectTop);
HXDLIN( 138)										int index3;
HXDLIN( 138)										if (undoImage->useVirtualPos) {
HXLINE( 138)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 138)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 138)										::iterMagic::Iimg_obj::set(this23,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 138)		{
HXLINE( 138)			int _g_min = xIter3->start;
HXDLIN( 138)			int _g_max = xIter3->max;
HXDLIN( 138)			while((_g_min < _g_max)){
HXLINE( 138)				_g_min = (_g_min + 1);
HXDLIN( 138)				int px = (_g_min - 1);
HXDLIN( 138)				Float pcx = (( (Float)(px) ) - cx);
HXDLIN( 138)				{
HXLINE( 138)					int _g_min1 = yIter3->start;
HXDLIN( 138)					int _g_max1 = yIter3->max;
HXDLIN( 138)					while((_g_min1 < _g_max1)){
HXLINE( 138)						_g_min1 = (_g_min1 + 1);
HXDLIN( 138)						int py = (_g_min1 - 1);
HXDLIN( 138)						Float pcy = (( (Float)(py) ) - cy);
HXDLIN( 138)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 138)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 138)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 138)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 138)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 138)						bool _hx_tmp4;
HXDLIN( 138)						bool _hx_tmp5;
HXDLIN( 138)						if ((ratioA >= 0)) {
HXLINE( 138)							_hx_tmp5 = (ratioB >= 0);
            						}
            						else {
HXLINE( 138)							_hx_tmp5 = false;
            						}
HXDLIN( 138)						if (_hx_tmp5) {
HXLINE( 138)							_hx_tmp4 = (ratioC >= 0);
            						}
            						else {
HXLINE( 138)							_hx_tmp4 = false;
            						}
HXDLIN( 138)						if (_hx_tmp4) {
HXLINE( 138)							int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 138)							if ((i6 > 255)) {
HXLINE(  24)								i6 = 255;
            							}
HXLINE( 138)							if ((i6 < 0)) {
HXLINE(  25)								i6 = 0;
            							}
HXLINE( 138)							int a5 = i6;
HXDLIN( 138)							int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 138)							if ((i7 > 255)) {
HXLINE(  24)								i7 = 255;
            							}
HXLINE( 138)							if ((i7 < 0)) {
HXLINE(  25)								i7 = 0;
            							}
HXLINE( 138)							int r3 = i7;
HXDLIN( 138)							int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 138)							if ((i8 > 255)) {
HXLINE(  24)								i8 = 255;
            							}
HXLINE( 138)							if ((i8 < 0)) {
HXLINE(  25)								i8 = 0;
            							}
HXLINE( 138)							int g3 = i8;
HXDLIN( 138)							int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 138)							if ((i9 > 255)) {
HXLINE(  24)								i9 = 255;
            							}
HXLINE( 138)							if ((i9 < 0)) {
HXLINE(  25)								i9 = 0;
            							}
HXLINE( 138)							int b4 = i9;
HXDLIN( 138)							{
HXLINE( 138)								int location1;
HXDLIN( 138)								if (this1->useVirtualPos) {
HXLINE( 138)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            								}
            								else {
HXLINE( 138)									location1 = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            								}
HXDLIN( 138)								bool _hx_tmp6;
HXDLIN( 138)								if (this1->transparent) {
HXLINE( 138)									_hx_tmp6 = (a5 < 254);
            								}
            								else {
HXLINE( 138)									_hx_tmp6 = false;
            								}
HXDLIN( 138)								if (_hx_tmp6) {
HXLINE( 138)									int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 138)									int old;
HXDLIN( 138)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)										old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            									}
            									else {
HXLINE( 138)										old = this24;
            									}
HXDLIN( 138)									int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 138)									Float a11;
HXDLIN( 138)									int this25 = ((old >> 24) & 255);
HXDLIN( 138)									if ((this25 == 0)) {
HXLINE( 138)										a11 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r11;
HXDLIN( 138)									int this26 = ((old >> 16) & 255);
HXDLIN( 138)									if ((this26 == 0)) {
HXLINE( 138)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g11;
HXDLIN( 138)									int this27 = ((old >> 8) & 255);
HXDLIN( 138)									if ((this27 == 0)) {
HXLINE( 138)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b12;
HXDLIN( 138)									int this28 = (old & 255);
HXDLIN( 138)									if ((this28 == 0)) {
HXLINE( 138)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a21;
HXDLIN( 138)									int this29 = ((rhs >> 24) & 255);
HXDLIN( 138)									if ((this29 == 0)) {
HXLINE( 138)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float r21;
HXDLIN( 138)									int this30 = ((rhs >> 16) & 255);
HXDLIN( 138)									if ((this30 == 0)) {
HXLINE( 138)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float g21;
HXDLIN( 138)									int this31 = ((rhs >> 8) & 255);
HXDLIN( 138)									if ((this31 == 0)) {
HXLINE( 138)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float b22;
HXDLIN( 138)									int this32 = (rhs & 255);
HXDLIN( 138)									if ((this32 == 0)) {
HXLINE( 138)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 138)										b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            									}
HXDLIN( 138)									Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 138)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 138)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 138)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 138)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 138)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 138)									{
HXLINE( 138)										int _hx_tmp7;
HXDLIN( 138)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 138)											_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 138)											_hx_tmp7 = blended1;
            										}
HXDLIN( 138)										::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            									}
            								}
            								else {
HXLINE( 138)									int value;
HXDLIN( 138)									if (this1->isLittle) {
HXLINE( 138)										value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            									}
            									else {
HXLINE( 138)										value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            									}
HXDLIN( 138)									::iterMagic::Iimg_obj::set(this1->image,location1,value);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 138)		if ((hasHit1 == false)) {
HXLINE( 138)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 138)			if (hasUndo) {
HXLINE( 138)				v2->undoImage = undoImage;
HXDLIN( 138)				v2->undoX = xIter3->start;
HXDLIN( 138)				v2->undoY = yIter3->start;
            			}
HXDLIN( 138)			return v2;
            		}
            		else {
HXLINE( 138)			return null();
            		}
HXDLIN( 138)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(GradientShape_Impl__obj,sweepTri,return )

 ::pi_xy::algo::HitTriArray GradientShape_Impl__obj::pie( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float rx,Float ry,Float startRadian,Float sweepRadian,int centreColor,int outerColor,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_targetError){
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_148_pie)
HXLINE( 149)		Float rSmall;
HXDLIN( 149)		if ((rx > ry)) {
HXLINE( 149)			rSmall = ry;
            		}
            		else {
HXLINE( 149)			rSmall = rx;
            		}
HXLINE( 150)		 ::Dynamic targetE = targetError;
HXDLIN( 150)		if (::hx::IsNull( targetE )) {
HXLINE( 150)			targetE = ((Float)1.05);
            		}
HXDLIN( 150)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 150)		int noSides;
HXDLIN( 150)		if ((result < 12)) {
HXLINE( 150)			noSides = 12;
            		}
            		else {
HXLINE( 150)			if ((result > 500)) {
HXLINE( 150)				noSides = 500;
            			}
            			else {
HXLINE( 150)				noSides = result;
            			}
            		}
HXLINE( 151)		Float theta = (::Math_obj::PI / ( (Float)(noSides) ));
HXLINE( 152)		Float currAngle = startRadian;
HXLINE( 153)		int tot = ::Math_obj::floor((sweepRadian / theta));
HXLINE( 154)		theta = (theta + (((sweepRadian / theta) - ( (Float)(tot) )) / ( (Float)(noSides) )));
HXLINE( 155)		Float bx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 156)		Float by = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 157)		Float cx = ((Float)0.);
HXLINE( 158)		Float cy = ((Float)0.);
HXLINE( 159)		::Array< ::Dynamic> arrTri = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 160)		{
HXLINE( 160)			int _g = 1;
HXDLIN( 160)			int _g1 = (tot + 1);
HXDLIN( 160)			while((_g < _g1)){
HXLINE( 160)				_g = (_g + 1);
HXDLIN( 160)				int i = (_g - 1);
HXLINE( 161)				currAngle = (startRadian + (( (Float)(i) ) * theta));
HXLINE( 162)				cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 163)				cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 164)				bool hasHit1 = false;
HXDLIN( 164)				bool hasUndo = false;
HXDLIN( 164)				int aA = ((outerColor >> 24) & 255);
HXDLIN( 164)				int rA = ((outerColor >> 16) & 255);
HXDLIN( 164)				int gA = ((outerColor >> 8) & 255);
HXDLIN( 164)				int bA = (outerColor & 255);
HXDLIN( 164)				int aB = ((centreColor >> 24) & 255);
HXDLIN( 164)				int rB = ((centreColor >> 16) & 255);
HXDLIN( 164)				int gB = ((centreColor >> 8) & 255);
HXDLIN( 164)				int bB = (centreColor & 255);
HXDLIN( 164)				int aC = ((outerColor >> 24) & 255);
HXDLIN( 164)				int rC = ((outerColor >> 16) & 255);
HXDLIN( 164)				int gC = ((outerColor >> 8) & 255);
HXDLIN( 164)				int bC = (outerColor & 255);
HXDLIN( 164)				Float bcx = (bx - cx);
HXDLIN( 164)				Float bcy = (by - cy);
HXDLIN( 164)				Float acx = (ax - cx);
HXDLIN( 164)				Float acy = (ay - cy);
HXDLIN( 164)				Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 164)				Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 164)				Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 164)				Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 164)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 164)				if ((ax > bx)) {
HXLINE( 164)					if ((ax > cx)) {
HXLINE( 164)						int min;
HXDLIN( 164)						if ((bx > cx)) {
HXLINE( 164)							min = ::Math_obj::floor(cx);
            						}
            						else {
HXLINE( 164)							min = ::Math_obj::floor(bx);
            						}
HXDLIN( 164)						int ii_min = min;
HXDLIN( 164)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 164)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE( 164)						int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 164)						int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 164)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE( 164)					if ((bx > cx)) {
HXLINE( 164)						int min1;
HXDLIN( 164)						if ((ax > cx)) {
HXLINE( 164)							min1 = ::Math_obj::floor(cx);
            						}
            						else {
HXLINE( 164)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 164)						int ii_min2 = min1;
HXDLIN( 164)						int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 164)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 164)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 164)						int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 164)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 164)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 164)				if ((ay > by)) {
HXLINE( 164)					if ((ay > cy)) {
HXLINE( 164)						int min2;
HXDLIN( 164)						if ((by > cy)) {
HXLINE( 164)							min2 = ::Math_obj::floor(cy);
            						}
            						else {
HXLINE( 164)							min2 = ::Math_obj::floor(by);
            						}
HXDLIN( 164)						int ii_min4 = min2;
HXDLIN( 164)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 164)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 164)						int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 164)						int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 164)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE( 164)					if ((by > cy)) {
HXLINE( 164)						int min3;
HXDLIN( 164)						if ((ay > cy)) {
HXLINE( 164)							min3 = ::Math_obj::floor(cy);
            						}
            						else {
HXLINE( 164)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 164)						int ii_min6 = min3;
HXDLIN( 164)						int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 164)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 164)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 164)						int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 164)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 164)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 164)				if (hasUndo) {
HXLINE( 164)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 164)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 164)					 ::Dynamic imageType = null();
HXDLIN( 164)					 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 164)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 164)					::Dynamic undoImage1;
HXDLIN( 164)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 164)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 164)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 164)							{
HXLINE( 164)								b->width = width;
HXDLIN( 164)								b->height = height;
HXDLIN( 164)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 164)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 164)								{
HXLINE( 164)									int len = b->length;
HXDLIN( 164)									int w = 0;
HXDLIN( 164)									{
HXLINE( 164)										int _g2 = 0;
HXDLIN( 164)										int _g3 = b->height;
HXDLIN( 164)										while((_g2 < _g3)){
HXLINE( 164)											_g2 = (_g2 + 1);
HXDLIN( 164)											int y = (_g2 - 1);
HXDLIN( 164)											{
HXLINE( 164)												int _g4 = 0;
HXDLIN( 164)												int _g5 = b->width;
HXDLIN( 164)												while((_g4 < _g5)){
HXLINE( 164)													_g4 = (_g4 + 1);
HXDLIN( 164)													int x = (_g4 - 1);
HXDLIN( 164)													{
HXLINE( 164)														w = (w + 1);
HXDLIN( 164)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 164)													{
HXLINE( 164)														w = (w + 1);
HXDLIN( 164)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 164)													{
HXLINE( 164)														w = (w + 1);
HXDLIN( 164)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 164)													{
HXLINE( 164)														w = (w + 1);
HXDLIN( 164)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 164)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE( 164)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 164)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 164)							{
HXLINE( 164)								a->width = width;
HXDLIN( 164)								a->height = height;
HXDLIN( 164)								a->data = ::Array_obj< int >::__new(0);
HXDLIN( 164)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 164)								{
HXLINE( 164)									int _g6 = 0;
HXDLIN( 164)									int _g7 = a->length;
HXDLIN( 164)									while((_g6 < _g7)){
HXLINE( 164)										_g6 = (_g6 + 1);
HXDLIN( 164)										int i1 = (_g6 - 1);
HXDLIN( 164)										a->data[i1] = 0;
            									}
            								}
            							}
HXDLIN( 164)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE( 164)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 164)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 164)							{
HXLINE( 164)								b1->width = width;
HXDLIN( 164)								b1->height = height;
HXDLIN( 164)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 164)								int size = (b1->length * 4);
HXDLIN( 164)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 164)								{
HXLINE( 164)									int _g8 = 0;
HXDLIN( 164)									int _g9 = b1->length;
HXDLIN( 164)									while((_g8 < _g9)){
HXLINE( 164)										_g8 = (_g8 + 1);
HXDLIN( 164)										int i2 = (_g8 - 1);
HXDLIN( 164)										{
HXLINE( 164)											 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 164)											bool undoImage2;
HXDLIN( 164)											if ((i2 >= 0)) {
HXLINE( 164)												undoImage2 = (i2 < (this3->byteLength >> 2));
            											}
            											else {
HXLINE( 164)												undoImage2 = false;
            											}
HXDLIN( 164)											if (undoImage2) {
HXLINE( 164)												 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 164)												int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN( 164)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 164)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 164)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 164)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 164)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE( 164)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 164)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 164)							{
HXLINE( 164)								v->width = width;
HXDLIN( 164)								v->height = height;
HXDLIN( 164)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 164)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 164)								{
HXLINE( 164)									int _g10 = 0;
HXDLIN( 164)									int _g11 = v->length;
HXDLIN( 164)									while((_g10 < _g11)){
HXLINE( 164)										_g10 = (_g10 + 1);
HXDLIN( 164)										int i3 = (_g10 - 1);
HXDLIN( 164)										v->data->__unsafe_set(i3,0);
            									}
            								}
            							}
HXDLIN( 164)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 164)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 164)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 164)							{
HXLINE( 164)								b2->width = width;
HXDLIN( 164)								b2->height = height;
HXDLIN( 164)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 164)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 164)								{
HXLINE( 164)									int len1 = b2->length;
HXDLIN( 164)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 164)									if (::hx::IsNull( d->head )) {
HXLINE( 164)										int _g12 = 0;
HXDLIN( 164)										int _g13 = len1;
HXDLIN( 164)										while((_g12 < _g13)){
HXLINE( 164)											_g12 = (_g12 + 1);
HXDLIN( 164)											int i4 = (_g12 - 1);
HXDLIN( 164)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 164)										int _g14 = 0;
HXDLIN( 164)										int _g15 = len1;
HXDLIN( 164)										while((_g14 < _g15)){
HXLINE( 164)											_g14 = (_g14 + 1);
HXDLIN( 164)											int i5 = (_g14 - 1);
HXDLIN( 164)											{
HXLINE( 164)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 164)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 164)												{
HXLINE( 164)													int _g16 = 0;
HXDLIN( 164)													int _g17 = i5;
HXDLIN( 164)													while((_g16 < _g17)){
HXLINE( 164)														_g16 = (_g16 + 1);
HXDLIN( 164)														int i6 = (_g16 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 164)												if (::hx::IsNull( prev )) {
HXLINE( 164)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 164)													l = null();
            												}
            												else {
HXLINE( 164)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 164)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 164)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 164)					this2->image = undoImage1;
HXDLIN( 164)					this2->width = width;
HXDLIN( 164)					this2->height = height;
HXDLIN( 164)					this2->imageType = ( (int)(imageType) );
HXDLIN( 164)					undoImage = this2;
HXDLIN( 164)					{
HXLINE( 164)						int rectLeft = xIter3->start;
HXDLIN( 164)						int rectTop = yIter3->start;
HXDLIN( 164)						int rectRight = xIter3->max;
HXDLIN( 164)						bool forceClear = false;
HXDLIN( 164)						{
HXLINE( 164)							int _g18 = rectTop;
HXDLIN( 164)							int _g19 = yIter3->max;
HXDLIN( 164)							while((_g18 < _g19)){
HXLINE( 164)								_g18 = (_g18 + 1);
HXDLIN( 164)								int dy = (_g18 - 1);
HXDLIN( 164)								{
HXLINE( 164)									int _g20 = rectLeft;
HXDLIN( 164)									int _g21 = rectRight;
HXDLIN( 164)									while((_g20 < _g21)){
HXLINE( 164)										_g20 = (_g20 + 1);
HXDLIN( 164)										int dx = (_g20 - 1);
HXDLIN( 164)										::Dynamic this4 = this1->image;
HXDLIN( 164)										int index;
HXDLIN( 164)										if (this1->useVirtualPos) {
HXLINE( 164)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            										}
            										else {
HXLINE( 164)											index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            										}
HXDLIN( 164)										int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 164)										int col;
HXDLIN( 164)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 164)											col = c;
            										}
HXDLIN( 164)										bool _hx_tmp;
HXDLIN( 164)										if (this1->useMask) {
HXLINE( 164)											_hx_tmp = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE( 164)											_hx_tmp = false;
            										}
HXDLIN( 164)										if (_hx_tmp) {
HXLINE( 164)											 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 164)											::Dynamic this6 = this5->image;
HXDLIN( 164)											int index1;
HXDLIN( 164)											if (this5->useVirtualPos) {
HXLINE( 164)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            											}
            											else {
HXLINE( 164)												index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            											}
HXDLIN( 164)											int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 164)											int v1;
HXDLIN( 164)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 164)												v1 = c1;
            											}
HXDLIN( 164)											int maskPixel = v1;
HXDLIN( 164)											int this7 = col;
HXDLIN( 164)											if ((maskPixel == 0)) {
HXLINE( 164)												col = this7;
            											}
            											else {
HXLINE( 164)												Float m0;
HXDLIN( 164)												int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 164)												if ((this8 == 0)) {
HXLINE( 164)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float m1;
HXDLIN( 164)												int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 164)												if ((this9 == 0)) {
HXLINE( 164)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float m2;
HXDLIN( 164)												int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 164)												if ((this10 == 0)) {
HXLINE( 164)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float m3;
HXDLIN( 164)												int this11 = (maskPixel & 255);
HXDLIN( 164)												if ((this11 == 0)) {
HXLINE( 164)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 164)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 164)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 164)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 164)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 164)										if ((col != 0)) {
HXLINE( 164)											int x1 = (dx - rectLeft);
HXDLIN( 164)											int y1 = (dy - rectTop);
HXDLIN( 164)											int c2 = col;
HXDLIN( 164)											bool _hx_tmp1;
HXDLIN( 164)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 164)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE( 164)												_hx_tmp1 = false;
            											}
HXDLIN( 164)											if (_hx_tmp1) {
HXLINE( 164)												int location;
HXDLIN( 164)												if (undoImage->useVirtualPos) {
HXLINE( 164)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 164)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 164)												int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 164)												int this13;
HXDLIN( 164)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)													this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            												}
            												else {
HXLINE( 164)													this13 = this12;
            												}
HXDLIN( 164)												Float a1;
HXDLIN( 164)												int this14 = ((this13 >> 24) & 255);
HXDLIN( 164)												if ((this14 == 0)) {
HXLINE( 164)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float r1;
HXDLIN( 164)												int this15 = ((this13 >> 16) & 255);
HXDLIN( 164)												if ((this15 == 0)) {
HXLINE( 164)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float g1;
HXDLIN( 164)												int this16 = ((this13 >> 8) & 255);
HXDLIN( 164)												if ((this16 == 0)) {
HXLINE( 164)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float b11;
HXDLIN( 164)												int this17 = (this13 & 255);
HXDLIN( 164)												if ((this17 == 0)) {
HXLINE( 164)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float a2;
HXDLIN( 164)												int this18 = ((col >> 24) & 255);
HXDLIN( 164)												if ((this18 == 0)) {
HXLINE( 164)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float r2;
HXDLIN( 164)												int this19 = ((col >> 16) & 255);
HXDLIN( 164)												if ((this19 == 0)) {
HXLINE( 164)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float g2;
HXDLIN( 164)												int this20 = ((col >> 8) & 255);
HXDLIN( 164)												if ((this20 == 0)) {
HXLINE( 164)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float b21;
HXDLIN( 164)												int this21 = (col & 255);
HXDLIN( 164)												if ((this21 == 0)) {
HXLINE( 164)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 164)													b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN( 164)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 164)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 164)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 164)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 164)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 164)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 164)												{
HXLINE( 164)													int _hx_tmp2;
HXDLIN( 164)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 164)														_hx_tmp2 = blended;
            													}
HXDLIN( 164)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE( 164)												::Dynamic this22 = undoImage->image;
HXDLIN( 164)												int index2;
HXDLIN( 164)												if (undoImage->useVirtualPos) {
HXLINE( 164)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 164)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 164)												int _hx_tmp3;
HXDLIN( 164)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 164)													_hx_tmp3 = c2;
            												}
HXDLIN( 164)												::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE( 164)											if (forceClear) {
HXLINE( 164)												::Dynamic this23 = undoImage->image;
HXDLIN( 164)												int x2 = (dx - rectLeft);
HXDLIN( 164)												int y2 = (dy - rectTop);
HXDLIN( 164)												int index3;
HXDLIN( 164)												if (undoImage->useVirtualPos) {
HXLINE( 164)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 164)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 164)												::iterMagic::Iimg_obj::set(this23,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 164)				{
HXLINE( 164)					int _g_min = xIter3->start;
HXDLIN( 164)					int _g_max = xIter3->max;
HXDLIN( 164)					while((_g_min < _g_max)){
HXLINE( 164)						_g_min = (_g_min + 1);
HXDLIN( 164)						int px = (_g_min - 1);
HXDLIN( 164)						Float pcx = (( (Float)(px) ) - cx);
HXDLIN( 164)						{
HXLINE( 164)							int _g_min1 = yIter3->start;
HXDLIN( 164)							int _g_max1 = yIter3->max;
HXDLIN( 164)							while((_g_min1 < _g_max1)){
HXLINE( 164)								_g_min1 = (_g_min1 + 1);
HXDLIN( 164)								int py = (_g_min1 - 1);
HXDLIN( 164)								Float pcy = (( (Float)(py) ) - cy);
HXDLIN( 164)								Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 164)								Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 164)								Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 164)								Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 164)								Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 164)								bool _hx_tmp4;
HXDLIN( 164)								bool _hx_tmp5;
HXDLIN( 164)								if ((ratioA >= 0)) {
HXLINE( 164)									_hx_tmp5 = (ratioB >= 0);
            								}
            								else {
HXLINE( 164)									_hx_tmp5 = false;
            								}
HXDLIN( 164)								if (_hx_tmp5) {
HXLINE( 164)									_hx_tmp4 = (ratioC >= 0);
            								}
            								else {
HXLINE( 164)									_hx_tmp4 = false;
            								}
HXDLIN( 164)								if (_hx_tmp4) {
HXLINE( 164)									int i7 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 164)									if ((i7 > 255)) {
HXLINE(  24)										i7 = 255;
            									}
HXLINE( 164)									if ((i7 < 0)) {
HXLINE(  25)										i7 = 0;
            									}
HXLINE( 164)									int a5 = i7;
HXDLIN( 164)									int i8 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 164)									if ((i8 > 255)) {
HXLINE(  24)										i8 = 255;
            									}
HXLINE( 164)									if ((i8 < 0)) {
HXLINE(  25)										i8 = 0;
            									}
HXLINE( 164)									int r3 = i8;
HXDLIN( 164)									int i9 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 164)									if ((i9 > 255)) {
HXLINE(  24)										i9 = 255;
            									}
HXLINE( 164)									if ((i9 < 0)) {
HXLINE(  25)										i9 = 0;
            									}
HXLINE( 164)									int g3 = i9;
HXDLIN( 164)									int i10 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 164)									if ((i10 > 255)) {
HXLINE(  24)										i10 = 255;
            									}
HXLINE( 164)									if ((i10 < 0)) {
HXLINE(  25)										i10 = 0;
            									}
HXLINE( 164)									int b4 = i10;
HXDLIN( 164)									{
HXLINE( 164)										int location1;
HXDLIN( 164)										if (this1->useVirtualPos) {
HXLINE( 164)											location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this1->virtualY) * ( (Float)(this1->width) )) + px) - this1->virtualX));
            										}
            										else {
HXLINE( 164)											location1 = ::Std_obj::_hx_int(( (Float)(((py * this1->width) + px)) ));
            										}
HXDLIN( 164)										bool _hx_tmp6;
HXDLIN( 164)										if (this1->transparent) {
HXLINE( 164)											_hx_tmp6 = (a5 < 254);
            										}
            										else {
HXLINE( 164)											_hx_tmp6 = false;
            										}
HXDLIN( 164)										if (_hx_tmp6) {
HXLINE( 164)											int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 164)											int old;
HXDLIN( 164)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)												old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            											}
            											else {
HXLINE( 164)												old = this24;
            											}
HXDLIN( 164)											int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 164)											Float a11;
HXDLIN( 164)											int this25 = ((old >> 24) & 255);
HXDLIN( 164)											if ((this25 == 0)) {
HXLINE( 164)												a11 = ((Float)0.);
            											}
            											else {
HXLINE( 164)												a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            											}
HXDLIN( 164)											Float r11;
HXDLIN( 164)											int this26 = ((old >> 16) & 255);
HXDLIN( 164)											if ((this26 == 0)) {
HXLINE( 164)												r11 = ((Float)0.);
            											}
            											else {
HXLINE( 164)												r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            											}
HXDLIN( 164)											Float g11;
HXDLIN( 164)											int this27 = ((old >> 8) & 255);
HXDLIN( 164)											if ((this27 == 0)) {
HXLINE( 164)												g11 = ((Float)0.);
            											}
            											else {
HXLINE( 164)												g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            											}
HXDLIN( 164)											Float b12;
HXDLIN( 164)											int this28 = (old & 255);
HXDLIN( 164)											if ((this28 == 0)) {
HXLINE( 164)												b12 = ((Float)0.);
            											}
            											else {
HXLINE( 164)												b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            											}
HXDLIN( 164)											Float a21;
HXDLIN( 164)											int this29 = ((rhs >> 24) & 255);
HXDLIN( 164)											if ((this29 == 0)) {
HXLINE( 164)												a21 = ((Float)0.);
            											}
            											else {
HXLINE( 164)												a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            											}
HXDLIN( 164)											Float r21;
HXDLIN( 164)											int this30 = ((rhs >> 16) & 255);
HXDLIN( 164)											if ((this30 == 0)) {
HXLINE( 164)												r21 = ((Float)0.);
            											}
            											else {
HXLINE( 164)												r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN( 164)											Float g21;
HXDLIN( 164)											int this31 = ((rhs >> 8) & 255);
HXDLIN( 164)											if ((this31 == 0)) {
HXLINE( 164)												g21 = ((Float)0.);
            											}
            											else {
HXLINE( 164)												g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN( 164)											Float b22;
HXDLIN( 164)											int this32 = (rhs & 255);
HXDLIN( 164)											if ((this32 == 0)) {
HXLINE( 164)												b22 = ((Float)0.);
            											}
            											else {
HXLINE( 164)												b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            											}
HXDLIN( 164)											Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 164)											int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 164)											int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 164)											int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 164)											int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 164)											int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 164)											{
HXLINE( 164)												int _hx_tmp7;
HXDLIN( 164)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 164)													_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXLINE( 164)													_hx_tmp7 = blended1;
            												}
HXDLIN( 164)												::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            											}
            										}
            										else {
HXLINE( 164)											int value;
HXDLIN( 164)											if (this1->isLittle) {
HXLINE( 164)												value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            											}
            											else {
HXLINE( 164)												value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            											}
HXDLIN( 164)											::iterMagic::Iimg_obj::set(this1->image,location1,value);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 164)				 ::pi_xy::algo::HitTri triHit;
HXDLIN( 164)				if ((hasHit1 == false)) {
HXLINE( 164)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 164)					if (hasUndo) {
HXLINE( 164)						v2->undoImage = undoImage;
HXDLIN( 164)						v2->undoX = xIter3->start;
HXDLIN( 164)						v2->undoY = yIter3->start;
            					}
HXDLIN( 164)					triHit = v2;
            				}
            				else {
HXLINE( 164)					triHit = null();
            				}
HXLINE( 165)				if (hasHit) {
HXLINE( 165)					arrTri[arrTri->length] = triHit;
            				}
HXLINE( 166)				bx = cx;
HXLINE( 167)				by = cy;
            			}
            		}
HXLINE( 170)		currAngle = (startRadian + sweepRadian);
HXLINE( 171)		cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 172)		cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 173)		bool hasHit2 = false;
HXDLIN( 173)		bool hasUndo1 = false;
HXDLIN( 173)		int aA1 = ((outerColor >> 24) & 255);
HXDLIN( 173)		int rA1 = ((outerColor >> 16) & 255);
HXDLIN( 173)		int gA1 = ((outerColor >> 8) & 255);
HXDLIN( 173)		int bA1 = (outerColor & 255);
HXDLIN( 173)		int aB1 = ((centreColor >> 24) & 255);
HXDLIN( 173)		int rB1 = ((centreColor >> 16) & 255);
HXDLIN( 173)		int gB1 = ((centreColor >> 8) & 255);
HXDLIN( 173)		int bB1 = (centreColor & 255);
HXDLIN( 173)		int aC1 = ((outerColor >> 24) & 255);
HXDLIN( 173)		int rC1 = ((outerColor >> 16) & 255);
HXDLIN( 173)		int gC1 = ((outerColor >> 8) & 255);
HXDLIN( 173)		int bC1 = (outerColor & 255);
HXDLIN( 173)		Float bcx1 = (bx - cx);
HXDLIN( 173)		Float bcy1 = (by - cy);
HXDLIN( 173)		Float acx1 = (ax - cx);
HXDLIN( 173)		Float acy1 = (ay - cy);
HXDLIN( 173)		Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 173)		Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 173)		Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 173)		Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 173)		 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 173)		if ((ax > bx)) {
HXLINE( 173)			if ((ax > cx)) {
HXLINE( 173)				int min4;
HXDLIN( 173)				if ((bx > cx)) {
HXLINE( 173)					min4 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 173)					min4 = ::Math_obj::floor(bx);
            				}
HXDLIN( 173)				int ii_min8 = min4;
HXDLIN( 173)				int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 173)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            			}
            			else {
HXLINE( 173)				int ii_min9 = ::Math_obj::floor(bx);
HXDLIN( 173)				int ii_max9 = ::Math_obj::ceil(cx);
HXDLIN( 173)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            			}
            		}
            		else {
HXLINE( 173)			if ((bx > cx)) {
HXLINE( 173)				int min5;
HXDLIN( 173)				if ((ax > cx)) {
HXLINE( 173)					min5 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 173)					min5 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 173)				int ii_min10 = min5;
HXDLIN( 173)				int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN( 173)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            			}
            			else {
HXLINE( 173)				int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 173)				int ii_max11 = ::Math_obj::ceil(cx);
HXDLIN( 173)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            			}
            		}
HXDLIN( 173)		 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 173)		if ((ay > by)) {
HXLINE( 173)			if ((ay > cy)) {
HXLINE( 173)				int min6;
HXDLIN( 173)				if ((by > cy)) {
HXLINE( 173)					min6 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 173)					min6 = ::Math_obj::floor(by);
            				}
HXDLIN( 173)				int ii_min12 = min6;
HXDLIN( 173)				int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 173)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            			}
            			else {
HXLINE( 173)				int ii_min13 = ::Math_obj::floor(by);
HXDLIN( 173)				int ii_max13 = ::Math_obj::ceil(cy);
HXDLIN( 173)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            			}
            		}
            		else {
HXLINE( 173)			if ((by > cy)) {
HXLINE( 173)				int min7;
HXDLIN( 173)				if ((ay > cy)) {
HXLINE( 173)					min7 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 173)					min7 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 173)				int ii_min14 = min7;
HXDLIN( 173)				int ii_max14 = ::Math_obj::ceil(by);
HXDLIN( 173)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            			}
            			else {
HXLINE( 173)				int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 173)				int ii_max15 = ::Math_obj::ceil(cy);
HXDLIN( 173)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            			}
            		}
HXDLIN( 173)		 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 173)		if (hasUndo1) {
HXLINE( 173)			int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 173)			int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 173)			 ::Dynamic imageType1 = null();
HXDLIN( 173)			 ::pi_xy::ImageStruct this33 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 173)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 173)			::Dynamic undoImage4;
HXDLIN( 173)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXLINE( 173)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 173)					 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 173)					{
HXLINE( 173)						b6->width = width1;
HXDLIN( 173)						b6->height = height1;
HXDLIN( 173)						b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 173)						b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 173)						{
HXLINE( 173)							int len2 = b6->length;
HXDLIN( 173)							int w1 = 0;
HXDLIN( 173)							{
HXLINE( 173)								int _g22 = 0;
HXDLIN( 173)								int _g23 = b6->height;
HXDLIN( 173)								while((_g22 < _g23)){
HXLINE( 173)									_g22 = (_g22 + 1);
HXDLIN( 173)									int y3 = (_g22 - 1);
HXDLIN( 173)									{
HXLINE( 173)										int _g24 = 0;
HXDLIN( 173)										int _g25 = b6->width;
HXDLIN( 173)										while((_g24 < _g25)){
HXLINE( 173)											_g24 = (_g24 + 1);
HXDLIN( 173)											int x3 = (_g24 - 1);
HXDLIN( 173)											{
HXLINE( 173)												w1 = (w1 + 1);
HXDLIN( 173)												b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 173)											{
HXLINE( 173)												w1 = (w1 + 1);
HXDLIN( 173)												b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 173)											{
HXLINE( 173)												w1 = (w1 + 1);
HXDLIN( 173)												b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 173)											{
HXLINE( 173)												w1 = (w1 + 1);
HXDLIN( 173)												b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 173)					undoImage4 = b6;
            				}
            				break;
            				case (int)1: {
HXLINE( 173)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 173)					 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 173)					{
HXLINE( 173)						a7->width = width1;
HXDLIN( 173)						a7->height = height1;
HXDLIN( 173)						a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 173)						a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 173)						{
HXLINE( 173)							int _g26 = 0;
HXDLIN( 173)							int _g27 = a7->length;
HXDLIN( 173)							while((_g26 < _g27)){
HXLINE( 173)								_g26 = (_g26 + 1);
HXDLIN( 173)								int i11 = (_g26 - 1);
HXDLIN( 173)								a7->data[i11] = 0;
            							}
            						}
            					}
HXDLIN( 173)					undoImage4 = a7;
            				}
            				break;
            				case (int)2: {
HXLINE( 173)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 173)					 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 173)					{
HXLINE( 173)						b7->width = width1;
HXDLIN( 173)						b7->height = height1;
HXDLIN( 173)						b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 173)						int size1 = (b7->length * 4);
HXDLIN( 173)						b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 173)						{
HXLINE( 173)							int _g28 = 0;
HXDLIN( 173)							int _g29 = b7->length;
HXDLIN( 173)							while((_g28 < _g29)){
HXLINE( 173)								_g28 = (_g28 + 1);
HXDLIN( 173)								int i12 = (_g28 - 1);
HXDLIN( 173)								{
HXLINE( 173)									 ::haxe::io::ArrayBufferViewImpl this34 = b7->data;
HXDLIN( 173)									bool undoImage5;
HXDLIN( 173)									if ((i12 >= 0)) {
HXLINE( 173)										undoImage5 = (i12 < (this34->byteLength >> 2));
            									}
            									else {
HXLINE( 173)										undoImage5 = false;
            									}
HXDLIN( 173)									if (undoImage5) {
HXLINE( 173)										 ::haxe::io::Bytes _this1 = this34->bytes;
HXDLIN( 173)										int pos1 = ((i12 << 2) + this34->byteOffset);
HXDLIN( 173)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 173)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 173)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 173)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 173)					undoImage4 = b7;
            				}
            				break;
            				case (int)3: {
HXLINE( 173)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 173)					 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 173)					{
HXLINE( 173)						v3->width = width1;
HXDLIN( 173)						v3->height = height1;
HXDLIN( 173)						v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 173)						v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 173)						{
HXLINE( 173)							int _g30 = 0;
HXDLIN( 173)							int _g31 = v3->length;
HXDLIN( 173)							while((_g30 < _g31)){
HXLINE( 173)								_g30 = (_g30 + 1);
HXDLIN( 173)								int i13 = (_g30 - 1);
HXDLIN( 173)								v3->data->__unsafe_set(i13,0);
            							}
            						}
            					}
HXDLIN( 173)					undoImage4 = v3;
            				}
            				break;
            				case (int)4: {
HXLINE( 173)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 173)					 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 173)					{
HXLINE( 173)						b8->width = width1;
HXDLIN( 173)						b8->height = height1;
HXDLIN( 173)						b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 173)						b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 173)						{
HXLINE( 173)							int len3 = b8->length;
HXDLIN( 173)							 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 173)							if (::hx::IsNull( d1->head )) {
HXLINE( 173)								int _g32 = 0;
HXDLIN( 173)								int _g33 = len3;
HXDLIN( 173)								while((_g32 < _g33)){
HXLINE( 173)									_g32 = (_g32 + 1);
HXDLIN( 173)									int i14 = (_g32 - 1);
HXDLIN( 173)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXLINE( 173)								int _g34 = 0;
HXDLIN( 173)								int _g35 = len3;
HXDLIN( 173)								while((_g34 < _g35)){
HXLINE( 173)									_g34 = (_g34 + 1);
HXDLIN( 173)									int i15 = (_g34 - 1);
HXDLIN( 173)									{
HXLINE( 173)										 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 173)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 173)										{
HXLINE( 173)											int _g36 = 0;
HXDLIN( 173)											int _g37 = i15;
HXDLIN( 173)											while((_g36 < _g37)){
HXLINE( 173)												_g36 = (_g36 + 1);
HXDLIN( 173)												int i16 = (_g36 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE( 173)										if (::hx::IsNull( prev1 )) {
HXLINE( 173)											b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 173)											l1 = null();
            										}
            										else {
HXLINE( 173)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 173)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 173)					undoImage4 = b8;
            				}
            				break;
            			}
HXDLIN( 173)			this33->image = undoImage4;
HXDLIN( 173)			this33->width = width1;
HXDLIN( 173)			this33->height = height1;
HXDLIN( 173)			this33->imageType = ( (int)(imageType1) );
HXDLIN( 173)			undoImage3 = this33;
HXDLIN( 173)			{
HXLINE( 173)				int rectLeft1 = xIter31->start;
HXDLIN( 173)				int rectTop1 = yIter31->start;
HXDLIN( 173)				int rectRight1 = xIter31->max;
HXDLIN( 173)				bool forceClear1 = false;
HXDLIN( 173)				{
HXLINE( 173)					int _g38 = rectTop1;
HXDLIN( 173)					int _g39 = yIter31->max;
HXDLIN( 173)					while((_g38 < _g39)){
HXLINE( 173)						_g38 = (_g38 + 1);
HXDLIN( 173)						int dy1 = (_g38 - 1);
HXDLIN( 173)						{
HXLINE( 173)							int _g40 = rectLeft1;
HXDLIN( 173)							int _g41 = rectRight1;
HXDLIN( 173)							while((_g40 < _g41)){
HXLINE( 173)								_g40 = (_g40 + 1);
HXDLIN( 173)								int dx1 = (_g40 - 1);
HXDLIN( 173)								::Dynamic this35 = this1->image;
HXDLIN( 173)								int index4;
HXDLIN( 173)								if (this1->useVirtualPos) {
HXLINE( 173)									index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            								}
            								else {
HXLINE( 173)									index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            								}
HXDLIN( 173)								int c3 = ::iterMagic::Iimg_obj::get(this35,index4);
HXDLIN( 173)								int col1;
HXDLIN( 173)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 173)									col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 173)									col1 = c3;
            								}
HXDLIN( 173)								bool _hx_tmp8;
HXDLIN( 173)								if (this1->useMask) {
HXLINE( 173)									_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE( 173)									_hx_tmp8 = false;
            								}
HXDLIN( 173)								if (_hx_tmp8) {
HXLINE( 173)									 ::pi_xy::ImageStruct this36 = this1->mask;
HXDLIN( 173)									::Dynamic this37 = this36->image;
HXDLIN( 173)									int index5;
HXDLIN( 173)									if (this36->useVirtualPos) {
HXLINE( 173)										index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            									}
            									else {
HXLINE( 173)										index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            									}
HXDLIN( 173)									int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 173)									int v4;
HXDLIN( 173)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 173)										v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE( 173)										v4 = c4;
            									}
HXDLIN( 173)									int maskPixel1 = v4;
HXDLIN( 173)									int this38 = col1;
HXDLIN( 173)									if ((maskPixel1 == 0)) {
HXLINE( 173)										col1 = this38;
            									}
            									else {
HXLINE( 173)										Float m01;
HXDLIN( 173)										int this39 = ((maskPixel1 >> 24) & 255);
HXDLIN( 173)										if ((this39 == 0)) {
HXLINE( 173)											m01 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											m01 = (( (Float)(this39) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float m11;
HXDLIN( 173)										int this40 = ((maskPixel1 >> 16) & 255);
HXDLIN( 173)										if ((this40 == 0)) {
HXLINE( 173)											m11 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											m11 = (( (Float)(this40) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float m21;
HXDLIN( 173)										int this41 = ((maskPixel1 >> 8) & 255);
HXDLIN( 173)										if ((this41 == 0)) {
HXLINE( 173)											m21 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											m21 = (( (Float)(this41) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float m31;
HXDLIN( 173)										int this42 = (maskPixel1 & 255);
HXDLIN( 173)										if ((this42 == 0)) {
HXLINE( 173)											m31 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											m31 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this38 >> 24) & 255)) )));
HXDLIN( 173)										int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this38 >> 16) & 255)) )));
HXDLIN( 173)										int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this38 >> 8) & 255)) )));
HXDLIN( 173)										int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this38 & 255)) )));
HXDLIN( 173)										col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 173)								if ((col1 != 0)) {
HXLINE( 173)									int x4 = (dx1 - rectLeft1);
HXDLIN( 173)									int y4 = (dy1 - rectTop1);
HXDLIN( 173)									int c5 = col1;
HXDLIN( 173)									bool _hx_tmp9;
HXDLIN( 173)									if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 173)										_hx_tmp9 = undoImage3->transparent;
            									}
            									else {
HXLINE( 173)										_hx_tmp9 = false;
            									}
HXDLIN( 173)									if (_hx_tmp9) {
HXLINE( 173)										int location2;
HXDLIN( 173)										if (undoImage3->useVirtualPos) {
HXLINE( 173)											location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 173)											location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            										}
HXDLIN( 173)										int this43 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 173)										int this44;
HXDLIN( 173)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 173)											this44 = ((((((this43 >> 24) & 255) << 24) | ((this43 & 255) << 16)) | (((this43 >> 8) & 255) << 8)) | ((this43 >> 16) & 255));
            										}
            										else {
HXLINE( 173)											this44 = this43;
            										}
HXDLIN( 173)										Float a12;
HXDLIN( 173)										int this45 = ((this44 >> 24) & 255);
HXDLIN( 173)										if ((this45 == 0)) {
HXLINE( 173)											a12 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											a12 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float r12;
HXDLIN( 173)										int this46 = ((this44 >> 16) & 255);
HXDLIN( 173)										if ((this46 == 0)) {
HXLINE( 173)											r12 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											r12 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float g12;
HXDLIN( 173)										int this47 = ((this44 >> 8) & 255);
HXDLIN( 173)										if ((this47 == 0)) {
HXLINE( 173)											g12 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											g12 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float b13;
HXDLIN( 173)										int this48 = (this44 & 255);
HXDLIN( 173)										if ((this48 == 0)) {
HXLINE( 173)											b13 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											b13 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float a22;
HXDLIN( 173)										int this49 = ((col1 >> 24) & 255);
HXDLIN( 173)										if ((this49 == 0)) {
HXLINE( 173)											a22 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											a22 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float r22;
HXDLIN( 173)										int this50 = ((col1 >> 16) & 255);
HXDLIN( 173)										if ((this50 == 0)) {
HXLINE( 173)											r22 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											r22 = (( (Float)(this50) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float g22;
HXDLIN( 173)										int this51 = ((col1 >> 8) & 255);
HXDLIN( 173)										if ((this51 == 0)) {
HXLINE( 173)											g22 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											g22 = (( (Float)(this51) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float b23;
HXDLIN( 173)										int this52 = (col1 & 255);
HXDLIN( 173)										if ((this52 == 0)) {
HXLINE( 173)											b23 = ((Float)0.);
            										}
            										else {
HXLINE( 173)											b23 = (( (Float)(this52) ) / ( (Float)(255) ));
            										}
HXDLIN( 173)										Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 173)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 173)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 173)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 173)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 173)										int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 173)										{
HXLINE( 173)											int _hx_tmp10;
HXDLIN( 173)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 173)												_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE( 173)												_hx_tmp10 = blended2;
            											}
HXDLIN( 173)											::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            										}
            									}
            									else {
HXLINE( 173)										::Dynamic this53 = undoImage3->image;
HXDLIN( 173)										int index6;
HXDLIN( 173)										if (undoImage3->useVirtualPos) {
HXLINE( 173)											index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 173)											index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            										}
HXDLIN( 173)										int _hx_tmp11;
HXDLIN( 173)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 173)											_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 173)											_hx_tmp11 = c5;
            										}
HXDLIN( 173)										::iterMagic::Iimg_obj::set(this53,index6,_hx_tmp11);
            									}
            								}
            								else {
HXLINE( 173)									if (forceClear1) {
HXLINE( 173)										::Dynamic this54 = undoImage3->image;
HXDLIN( 173)										int x5 = (dx1 - rectLeft1);
HXDLIN( 173)										int y5 = (dy1 - rectTop1);
HXDLIN( 173)										int index7;
HXDLIN( 173)										if (undoImage3->useVirtualPos) {
HXLINE( 173)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 173)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            										}
HXDLIN( 173)										::iterMagic::Iimg_obj::set(this54,index7,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 173)		{
HXLINE( 173)			int _g_min2 = xIter31->start;
HXDLIN( 173)			int _g_max2 = xIter31->max;
HXDLIN( 173)			while((_g_min2 < _g_max2)){
HXLINE( 173)				_g_min2 = (_g_min2 + 1);
HXDLIN( 173)				int px1 = (_g_min2 - 1);
HXDLIN( 173)				Float pcx1 = (( (Float)(px1) ) - cx);
HXDLIN( 173)				{
HXLINE( 173)					int _g_min3 = yIter31->start;
HXDLIN( 173)					int _g_max3 = yIter31->max;
HXDLIN( 173)					while((_g_min3 < _g_max3)){
HXLINE( 173)						_g_min3 = (_g_min3 + 1);
HXDLIN( 173)						int py1 = (_g_min3 - 1);
HXDLIN( 173)						Float pcy1 = (( (Float)(py1) ) - cy);
HXDLIN( 173)						Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 173)						Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 173)						Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 173)						Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 173)						Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 173)						bool _hx_tmp12;
HXDLIN( 173)						bool _hx_tmp13;
HXDLIN( 173)						if ((ratioA1 >= 0)) {
HXLINE( 173)							_hx_tmp13 = (ratioB1 >= 0);
            						}
            						else {
HXLINE( 173)							_hx_tmp13 = false;
            						}
HXDLIN( 173)						if (_hx_tmp13) {
HXLINE( 173)							_hx_tmp12 = (ratioC1 >= 0);
            						}
            						else {
HXLINE( 173)							_hx_tmp12 = false;
            						}
HXDLIN( 173)						if (_hx_tmp12) {
HXLINE( 173)							int i17 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 173)							if ((i17 > 255)) {
HXLINE(  24)								i17 = 255;
            							}
HXLINE( 173)							if ((i17 < 0)) {
HXLINE(  25)								i17 = 0;
            							}
HXLINE( 173)							int a9 = i17;
HXDLIN( 173)							int i18 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 173)							if ((i18 > 255)) {
HXLINE(  24)								i18 = 255;
            							}
HXLINE( 173)							if ((i18 < 0)) {
HXLINE(  25)								i18 = 0;
            							}
HXLINE( 173)							int r6 = i18;
HXDLIN( 173)							int i19 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 173)							if ((i19 > 255)) {
HXLINE(  24)								i19 = 255;
            							}
HXLINE( 173)							if ((i19 < 0)) {
HXLINE(  25)								i19 = 0;
            							}
HXLINE( 173)							int g6 = i19;
HXDLIN( 173)							int i20 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 173)							if ((i20 > 255)) {
HXLINE(  24)								i20 = 255;
            							}
HXLINE( 173)							if ((i20 < 0)) {
HXLINE(  25)								i20 = 0;
            							}
HXLINE( 173)							int b10 = i20;
HXDLIN( 173)							{
HXLINE( 173)								int location3;
HXDLIN( 173)								if (this1->useVirtualPos) {
HXLINE( 173)									location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this1->virtualY) * ( (Float)(this1->width) )) + px1) - this1->virtualX));
            								}
            								else {
HXLINE( 173)									location3 = ::Std_obj::_hx_int(( (Float)(((py1 * this1->width) + px1)) ));
            								}
HXDLIN( 173)								bool _hx_tmp14;
HXDLIN( 173)								if (this1->transparent) {
HXLINE( 173)									_hx_tmp14 = (a9 < 254);
            								}
            								else {
HXLINE( 173)									_hx_tmp14 = false;
            								}
HXDLIN( 173)								if (_hx_tmp14) {
HXLINE( 173)									int this55 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 173)									int old1;
HXDLIN( 173)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 173)										old1 = ((((((this55 >> 24) & 255) << 24) | ((this55 & 255) << 16)) | (((this55 >> 8) & 255) << 8)) | ((this55 >> 16) & 255));
            									}
            									else {
HXLINE( 173)										old1 = this55;
            									}
HXDLIN( 173)									int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 173)									Float a13;
HXDLIN( 173)									int this56 = ((old1 >> 24) & 255);
HXDLIN( 173)									if ((this56 == 0)) {
HXLINE( 173)										a13 = ((Float)0.);
            									}
            									else {
HXLINE( 173)										a13 = (( (Float)(this56) ) / ( (Float)(255) ));
            									}
HXDLIN( 173)									Float r13;
HXDLIN( 173)									int this57 = ((old1 >> 16) & 255);
HXDLIN( 173)									if ((this57 == 0)) {
HXLINE( 173)										r13 = ((Float)0.);
            									}
            									else {
HXLINE( 173)										r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            									}
HXDLIN( 173)									Float g13;
HXDLIN( 173)									int this58 = ((old1 >> 8) & 255);
HXDLIN( 173)									if ((this58 == 0)) {
HXLINE( 173)										g13 = ((Float)0.);
            									}
            									else {
HXLINE( 173)										g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            									}
HXDLIN( 173)									Float b14;
HXDLIN( 173)									int this59 = (old1 & 255);
HXDLIN( 173)									if ((this59 == 0)) {
HXLINE( 173)										b14 = ((Float)0.);
            									}
            									else {
HXLINE( 173)										b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            									}
HXDLIN( 173)									Float a23;
HXDLIN( 173)									int this60 = ((rhs1 >> 24) & 255);
HXDLIN( 173)									if ((this60 == 0)) {
HXLINE( 173)										a23 = ((Float)0.);
            									}
            									else {
HXLINE( 173)										a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            									}
HXDLIN( 173)									Float r23;
HXDLIN( 173)									int this61 = ((rhs1 >> 16) & 255);
HXDLIN( 173)									if ((this61 == 0)) {
HXLINE( 173)										r23 = ((Float)0.);
            									}
            									else {
HXLINE( 173)										r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            									}
HXDLIN( 173)									Float g23;
HXDLIN( 173)									int this62 = ((rhs1 >> 8) & 255);
HXDLIN( 173)									if ((this62 == 0)) {
HXLINE( 173)										g23 = ((Float)0.);
            									}
            									else {
HXLINE( 173)										g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            									}
HXDLIN( 173)									Float b24;
HXDLIN( 173)									int this63 = (rhs1 & 255);
HXDLIN( 173)									if ((this63 == 0)) {
HXLINE( 173)										b24 = ((Float)0.);
            									}
            									else {
HXLINE( 173)										b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            									}
HXDLIN( 173)									Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 173)									int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 173)									int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 173)									int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 173)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 173)									int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 173)									{
HXLINE( 173)										int _hx_tmp15;
HXDLIN( 173)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 173)											_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            										}
            										else {
HXLINE( 173)											_hx_tmp15 = blended3;
            										}
HXDLIN( 173)										::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp15);
            									}
            								}
            								else {
HXLINE( 173)									int value1;
HXDLIN( 173)									if (this1->isLittle) {
HXLINE( 173)										value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            									}
            									else {
HXLINE( 173)										value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            									}
HXDLIN( 173)									::iterMagic::Iimg_obj::set(this1->image,location3,value1);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 173)		 ::pi_xy::algo::HitTri triHit1;
HXDLIN( 173)		if ((hasHit2 == false)) {
HXLINE( 173)			 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 173)			if (hasUndo1) {
HXLINE( 173)				v5->undoImage = undoImage3;
HXDLIN( 173)				v5->undoX = xIter31->start;
HXDLIN( 173)				v5->undoY = yIter31->start;
            			}
HXDLIN( 173)			triHit1 = v5;
            		}
            		else {
HXLINE( 173)			triHit1 = null();
            		}
HXLINE( 174)		if (hasHit) {
HXLINE( 174)			arrTri[arrTri->length] = triHit1;
            		}
HXLINE( 175)		if (hasHit) {
HXLINE( 176)			return  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,arrTri);
            		}
            		else {
HXLINE( 178)			arrTri = null();
HXLINE( 179)			return null();
            		}
HXLINE( 175)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(GradientShape_Impl__obj,pie,return )

void GradientShape_Impl__obj::radialRectangle( ::pi_xy::ImageStruct this1,Float x,Float y,Float wid,Float hi,int colorIn,int colorOut, ::Dynamic __o_gx, ::Dynamic __o_gy){
            		 ::Dynamic gx = __o_gx;
            		if (::hx::IsNull(__o_gx)) gx = 0;
            		 ::Dynamic gy = __o_gy;
            		if (::hx::IsNull(__o_gy)) gy = 0;
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_192_radialRectangle)
HXLINE( 193)		int width = ::Math_obj::ceil(wid);
HXDLIN( 193)		int height = ::Math_obj::ceil(hi);
HXDLIN( 193)		 ::Dynamic imageType = null();
HXDLIN( 193)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 193)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 193)		::Dynamic _hx_tmp;
HXDLIN( 193)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 193)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 193)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 193)				{
HXLINE( 193)					b->width = width;
HXDLIN( 193)					b->height = height;
HXDLIN( 193)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 193)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 193)					{
HXLINE( 193)						int len = b->length;
HXDLIN( 193)						int w = 0;
HXDLIN( 193)						{
HXLINE( 193)							int _g = 0;
HXDLIN( 193)							int _g1 = b->height;
HXDLIN( 193)							while((_g < _g1)){
HXLINE( 193)								_g = (_g + 1);
HXDLIN( 193)								int y1 = (_g - 1);
HXDLIN( 193)								{
HXLINE( 193)									int _g2 = 0;
HXDLIN( 193)									int _g3 = b->width;
HXDLIN( 193)									while((_g2 < _g3)){
HXLINE( 193)										_g2 = (_g2 + 1);
HXDLIN( 193)										int x1 = (_g2 - 1);
HXDLIN( 193)										{
HXLINE( 193)											w = (w + 1);
HXDLIN( 193)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 193)										{
HXLINE( 193)											w = (w + 1);
HXDLIN( 193)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 193)										{
HXLINE( 193)											w = (w + 1);
HXDLIN( 193)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 193)										{
HXLINE( 193)											w = (w + 1);
HXDLIN( 193)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 193)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 193)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 193)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 193)				{
HXLINE( 193)					a->width = width;
HXDLIN( 193)					a->height = height;
HXDLIN( 193)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 193)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 193)					{
HXLINE( 193)						int _g4 = 0;
HXDLIN( 193)						int _g5 = a->length;
HXDLIN( 193)						while((_g4 < _g5)){
HXLINE( 193)							_g4 = (_g4 + 1);
HXDLIN( 193)							int i = (_g4 - 1);
HXDLIN( 193)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 193)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 193)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 193)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 193)				{
HXLINE( 193)					b1->width = width;
HXDLIN( 193)					b1->height = height;
HXDLIN( 193)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 193)					int size = (b1->length * 4);
HXDLIN( 193)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 193)					{
HXLINE( 193)						int _g6 = 0;
HXDLIN( 193)						int _g7 = b1->length;
HXDLIN( 193)						while((_g6 < _g7)){
HXLINE( 193)							_g6 = (_g6 + 1);
HXDLIN( 193)							int i1 = (_g6 - 1);
HXDLIN( 193)							{
HXLINE( 193)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 193)								bool _hx_tmp1;
HXDLIN( 193)								if ((i1 >= 0)) {
HXLINE( 193)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 193)									_hx_tmp1 = false;
            								}
HXDLIN( 193)								if (_hx_tmp1) {
HXLINE( 193)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 193)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 193)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 193)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 193)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 193)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 193)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 193)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 193)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 193)				{
HXLINE( 193)					v->width = width;
HXDLIN( 193)					v->height = height;
HXDLIN( 193)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 193)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 193)					{
HXLINE( 193)						int _g8 = 0;
HXDLIN( 193)						int _g9 = v->length;
HXDLIN( 193)						while((_g8 < _g9)){
HXLINE( 193)							_g8 = (_g8 + 1);
HXDLIN( 193)							int i2 = (_g8 - 1);
HXDLIN( 193)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 193)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 193)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 193)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 193)				{
HXLINE( 193)					b2->width = width;
HXDLIN( 193)					b2->height = height;
HXDLIN( 193)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 193)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 193)					{
HXLINE( 193)						int len1 = b2->length;
HXDLIN( 193)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 193)						if (::hx::IsNull( d->head )) {
HXLINE( 193)							int _g10 = 0;
HXDLIN( 193)							int _g11 = len1;
HXDLIN( 193)							while((_g10 < _g11)){
HXLINE( 193)								_g10 = (_g10 + 1);
HXDLIN( 193)								int i3 = (_g10 - 1);
HXDLIN( 193)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 193)							int _g12 = 0;
HXDLIN( 193)							int _g13 = len1;
HXDLIN( 193)							while((_g12 < _g13)){
HXLINE( 193)								_g12 = (_g12 + 1);
HXDLIN( 193)								int i4 = (_g12 - 1);
HXDLIN( 193)								{
HXLINE( 193)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 193)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 193)									{
HXLINE( 193)										int _g14 = 0;
HXDLIN( 193)										int _g15 = i4;
HXDLIN( 193)										while((_g14 < _g15)){
HXLINE( 193)											_g14 = (_g14 + 1);
HXDLIN( 193)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 193)									if (::hx::IsNull( prev )) {
HXLINE( 193)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 193)										l = null();
            									}
            									else {
HXLINE( 193)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 193)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 193)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 193)		this2->image = _hx_tmp;
HXDLIN( 193)		this2->width = width;
HXDLIN( 193)		this2->height = height;
HXDLIN( 193)		this2->imageType = ( (int)(imageType) );
HXDLIN( 193)		 ::pi_xy::ImageStruct temp = this2;
HXLINE( 194)		Float rx = (wid / ( (Float)(2) ));
HXLINE( 195)		Float ry = (hi / ( (Float)(2) ));
HXLINE( 196)		temp->transparent = false;
HXLINE( 198)		{
HXLINE( 198)			int r_x = 0;
HXDLIN( 198)			int r_y = 0;
HXDLIN( 198)			int r_w = ::Std_obj::_hx_int(wid);
HXDLIN( 198)			int r_h = ::Std_obj::_hx_int(hi);
HXDLIN( 198)			int xmax = ((r_x + r_w) + 1);
HXDLIN( 198)			int ymax = ((r_y + r_h) + 1);
HXDLIN( 198)			int ii_min = r_x;
HXDLIN( 198)			int ii_max = xmax;
HXDLIN( 198)			int xRange__start = ii_min;
HXDLIN( 198)			int xRange__max = ii_max;
HXDLIN( 198)			int ii_min1 = r_y;
HXDLIN( 198)			int ii_max1 = ymax;
HXDLIN( 198)			int yRange__start = ii_min1;
HXDLIN( 198)			int yRange__max = ii_max1;
HXDLIN( 198)			int range_x = xRange__start;
HXDLIN( 198)			int range_y = (yRange__start - 1);
HXDLIN( 198)			int range_xReset = range_x;
HXDLIN( 198)			int range_yReset = range_y;
HXDLIN( 198)			int range_xMax = (xRange__max - 2);
HXDLIN( 198)			int range_yMax = (yRange__max - 2);
HXDLIN( 198)			int _this_min = 0;
HXDLIN( 198)			int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 198)			while((_this_min < _this_max)){
HXLINE( 198)				_this_min = (_this_min + 1);
HXDLIN( 198)				int i6 = (_this_min - 1);
HXDLIN( 198)				if ((range_y > range_yMax)) {
HXLINE( 198)					range_y = range_yReset;
HXDLIN( 198)					range_x = (range_x + 1);
            				}
HXDLIN( 198)				range_y = (range_y + 1);
HXDLIN( 198)				int i7 = i6;
HXDLIN( 198)				{
HXLINE( 198)					int x2 = range_x;
HXDLIN( 198)					int y2 = range_y;
HXDLIN( 198)					int c = colorOut;
HXDLIN( 198)					bool _hx_tmp2;
HXDLIN( 198)					if ((((c >> 24) & 255) < 254)) {
HXLINE( 198)						_hx_tmp2 = temp->transparent;
            					}
            					else {
HXLINE( 198)						_hx_tmp2 = false;
            					}
HXDLIN( 198)					if (_hx_tmp2) {
HXLINE( 198)						int location;
HXDLIN( 198)						if (temp->useVirtualPos) {
HXLINE( 198)							location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - temp->virtualY) * ( (Float)(temp->width) )) + x2) - temp->virtualX));
            						}
            						else {
HXLINE( 198)							location = ::Std_obj::_hx_int(( (Float)(((y2 * temp->width) + x2)) ));
            						}
HXDLIN( 198)						int this4 = ::iterMagic::Iimg_obj::get(temp->image,location);
HXDLIN( 198)						int this5;
HXDLIN( 198)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 198)							this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            						}
            						else {
HXLINE( 198)							this5 = this4;
            						}
HXDLIN( 198)						Float a1;
HXDLIN( 198)						int this6 = ((this5 >> 24) & 255);
HXDLIN( 198)						if ((this6 == 0)) {
HXLINE( 198)							a1 = ((Float)0.);
            						}
            						else {
HXLINE( 198)							a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN( 198)						Float r1;
HXDLIN( 198)						int this7 = ((this5 >> 16) & 255);
HXDLIN( 198)						if ((this7 == 0)) {
HXLINE( 198)							r1 = ((Float)0.);
            						}
            						else {
HXLINE( 198)							r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN( 198)						Float g1;
HXDLIN( 198)						int this8 = ((this5 >> 8) & 255);
HXDLIN( 198)						if ((this8 == 0)) {
HXLINE( 198)							g1 = ((Float)0.);
            						}
            						else {
HXLINE( 198)							g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN( 198)						Float b11;
HXDLIN( 198)						int this9 = (this5 & 255);
HXDLIN( 198)						if ((this9 == 0)) {
HXLINE( 198)							b11 = ((Float)0.);
            						}
            						else {
HXLINE( 198)							b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN( 198)						Float a2;
HXDLIN( 198)						int this10 = ((colorOut >> 24) & 255);
HXDLIN( 198)						if ((this10 == 0)) {
HXLINE( 198)							a2 = ((Float)0.);
            						}
            						else {
HXLINE( 198)							a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN( 198)						Float r2;
HXDLIN( 198)						int this11 = ((colorOut >> 16) & 255);
HXDLIN( 198)						if ((this11 == 0)) {
HXLINE( 198)							r2 = ((Float)0.);
            						}
            						else {
HXLINE( 198)							r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN( 198)						Float g2;
HXDLIN( 198)						int this12 = ((colorOut >> 8) & 255);
HXDLIN( 198)						if ((this12 == 0)) {
HXLINE( 198)							g2 = ((Float)0.);
            						}
            						else {
HXLINE( 198)							g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN( 198)						Float b21;
HXDLIN( 198)						int this13 = (colorOut & 255);
HXDLIN( 198)						if ((this13 == 0)) {
HXLINE( 198)							b21 = ((Float)0.);
            						}
            						else {
HXLINE( 198)							b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN( 198)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 198)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 198)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 198)						int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 198)						int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 198)						int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 198)						{
HXLINE( 198)							int _hx_tmp3;
HXDLIN( 198)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 198)								_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE( 198)								_hx_tmp3 = blended;
            							}
HXDLIN( 198)							::iterMagic::Iimg_obj::set(temp->image,location,_hx_tmp3);
            						}
            					}
            					else {
HXLINE( 198)						::Dynamic this14 = temp->image;
HXDLIN( 198)						int index;
HXDLIN( 198)						if (temp->useVirtualPos) {
HXLINE( 198)							index = ::Std_obj::_hx_int(((((( (Float)(y2) ) - temp->virtualY) * ( (Float)(temp->width) )) + x2) - temp->virtualX));
            						}
            						else {
HXLINE( 198)							index = ::Std_obj::_hx_int(( (Float)(((y2 * temp->width) + x2)) ));
            						}
HXDLIN( 198)						int _hx_tmp4;
HXDLIN( 198)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 198)							_hx_tmp4 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            						}
            						else {
HXLINE( 198)							_hx_tmp4 = c;
            						}
HXDLIN( 198)						::iterMagic::Iimg_obj::set(this14,index,_hx_tmp4);
            					}
            				}
            			}
            		}
HXLINE( 200)		{
HXLINE( 200)			 ::pi_xy::ImageStruct this15 = temp;
HXDLIN( 200)			Float rSmall;
HXDLIN( 200)			if ((rx > ry)) {
HXLINE( 200)				rSmall = ry;
            			}
            			else {
HXLINE( 200)				rSmall = rx;
            			}
HXDLIN( 200)			 ::Dynamic targetE = ((Float)1.05);
HXDLIN( 200)			if (::hx::IsNull( targetE )) {
HXLINE( 114)				targetE = ((Float)1.05);
            			}
HXLINE( 200)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 200)			int noSides;
HXDLIN( 200)			if ((result < 12)) {
HXLINE( 200)				noSides = 12;
            			}
            			else {
HXLINE( 200)				if ((result > 500)) {
HXLINE( 200)					noSides = 500;
            				}
            				else {
HXLINE( 200)					noSides = result;
            				}
            			}
HXDLIN( 200)			{
HXLINE( 200)				 ::Dynamic gx1 = ( (Float)(gx) );
HXDLIN( 200)				 ::Dynamic gy1 = ( (Float)(gy) );
HXDLIN( 200)				 ::Dynamic phi = ((Float)0.);
HXDLIN( 200)				 ::Dynamic sides = noSides;
HXDLIN( 200)				if (::hx::IsNull( sides )) {
HXLINE( 122)					sides = 36;
            				}
HXLINE( 200)				if (::hx::IsNull( phi )) {
HXLINE( 121)					phi = ((Float)0.);
            				}
HXLINE( 200)				if (::hx::IsNull( gy1 )) {
HXLINE( 120)					gy1 = 0;
            				}
HXLINE( 200)				if (::hx::IsNull( gx1 )) {
HXLINE( 120)					gx1 = 0;
            				}
HXLINE( 200)				if (::hx::IsLess( gx1,((Float)-1.) )) {
HXLINE( 193)					gx1 = -1;
            				}
HXLINE( 200)				if (::hx::IsGreater( gx1,((Float)1.) )) {
HXLINE( 194)					gx1 = 1;
            				}
HXLINE( 200)				if (::hx::IsLess( gy1,((Float)-1.) )) {
HXLINE( 195)					gy1 = ((Float)-1.);
            				}
HXLINE( 200)				if (::hx::IsGreater( gy1,((Float)1.) )) {
HXLINE( 196)					gy1 = 1;
            				}
HXLINE( 200)				Float mx = (rx + (( (Float)(gx1) ) * rx));
HXDLIN( 200)				Float my = (ry + (( (Float)(gy1) ) * ry));
HXDLIN( 200)				Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 200)				Float omega = ((Float)0.);
HXDLIN( 200)				Float lastX = ((Float)0.);
HXDLIN( 200)				Float lastY = ((Float)0.);
HXDLIN( 200)				if (::hx::IsNotEq( phi,0 )) {
HXLINE( 221)					lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + rx);
HXLINE( 222)					lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + ry);
            				}
            				else {
HXLINE( 224)					lastX = (rx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE( 225)					lastY = (ry + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            				}
HXLINE( 200)				if (::hx::IsNotEq( phi,0 )) {
HXLINE( 200)					Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 200)					Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 200)					{
HXLINE( 200)						int _g16 = 0;
HXDLIN( 200)						int _g17 = (sides + 1);
HXDLIN( 200)						while((_g16 < _g17)){
HXLINE( 200)							_g16 = (_g16 + 1);
HXDLIN( 200)							int i8 = (_g16 - 1);
HXDLIN( 200)							Float stheta = ::Math_obj::sin(((( (Float)(i8) ) * theta) + omega));
HXDLIN( 200)							Float ctheta = ::Math_obj::cos(((( (Float)(i8) ) * theta) + omega));
HXDLIN( 200)							Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + rx);
HXDLIN( 200)							Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + ry);
HXDLIN( 200)							{
HXLINE( 200)								 ::pi_xy::ImageStruct this16 = this15;
HXDLIN( 200)								{
HXLINE( 200)									bool hasHit = false;
HXDLIN( 200)									bool hasUndo = false;
HXDLIN( 200)									int aA = ((colorOut >> 24) & 255);
HXDLIN( 200)									int rA = ((colorOut >> 16) & 255);
HXDLIN( 200)									int gA = ((colorOut >> 8) & 255);
HXDLIN( 200)									int bA = (colorOut & 255);
HXDLIN( 200)									int aB = ((colorIn >> 24) & 255);
HXDLIN( 200)									int rB = ((colorIn >> 16) & 255);
HXDLIN( 200)									int gB = ((colorIn >> 8) & 255);
HXDLIN( 200)									int bB = (colorIn & 255);
HXDLIN( 200)									int aC = ((colorOut >> 24) & 255);
HXDLIN( 200)									int rC = ((colorOut >> 16) & 255);
HXDLIN( 200)									int gC = ((colorOut >> 8) & 255);
HXDLIN( 200)									int bC = (colorOut & 255);
HXDLIN( 200)									Float bcx = (lastX - nextX);
HXDLIN( 200)									Float bcy = (lastY - nextY);
HXDLIN( 200)									Float acx = (mx - nextX);
HXDLIN( 200)									Float acy = (my - nextY);
HXDLIN( 200)									Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 200)									Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 200)									Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 200)									Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 200)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 200)									if ((mx > lastX)) {
HXLINE( 200)										if ((mx > nextX)) {
HXLINE( 200)											int min;
HXDLIN( 200)											if ((lastX > nextX)) {
HXLINE( 200)												min = ::Math_obj::floor(nextX);
            											}
            											else {
HXLINE( 200)												min = ::Math_obj::floor(lastX);
            											}
HXDLIN( 200)											int ii_min2 = min;
HXDLIN( 200)											int ii_max2 = ::Math_obj::ceil(mx);
HXDLIN( 200)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXLINE( 200)											int ii_min3 = ::Math_obj::floor(lastX);
HXDLIN( 200)											int ii_max3 = ::Math_obj::ceil(nextX);
HXDLIN( 200)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
            									else {
HXLINE( 200)										if ((lastX > nextX)) {
HXLINE( 200)											int min1;
HXDLIN( 200)											if ((mx > nextX)) {
HXLINE( 200)												min1 = ::Math_obj::floor(nextX);
            											}
            											else {
HXLINE( 200)												min1 = ::Math_obj::ceil(mx);
            											}
HXDLIN( 200)											int ii_min4 = min1;
HXDLIN( 200)											int ii_max4 = ::Math_obj::ceil(lastX);
HXDLIN( 200)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXLINE( 200)											int ii_min5 = ::Math_obj::floor(mx);
HXDLIN( 200)											int ii_max5 = ::Math_obj::ceil(nextX);
HXDLIN( 200)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
HXDLIN( 200)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 200)									if ((my > lastY)) {
HXLINE( 200)										if ((my > nextY)) {
HXLINE( 200)											int min2;
HXDLIN( 200)											if ((lastY > nextY)) {
HXLINE( 200)												min2 = ::Math_obj::floor(nextY);
            											}
            											else {
HXLINE( 200)												min2 = ::Math_obj::floor(lastY);
            											}
HXDLIN( 200)											int ii_min6 = min2;
HXDLIN( 200)											int ii_max6 = ::Math_obj::ceil(my);
HXDLIN( 200)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXLINE( 200)											int ii_min7 = ::Math_obj::floor(lastY);
HXDLIN( 200)											int ii_max7 = ::Math_obj::ceil(nextY);
HXDLIN( 200)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
            									else {
HXLINE( 200)										if ((lastY > nextY)) {
HXLINE( 200)											int min3;
HXDLIN( 200)											if ((my > nextY)) {
HXLINE( 200)												min3 = ::Math_obj::floor(nextY);
            											}
            											else {
HXLINE( 200)												min3 = ::Math_obj::ceil(my);
            											}
HXDLIN( 200)											int ii_min8 = min3;
HXDLIN( 200)											int ii_max8 = ::Math_obj::ceil(lastY);
HXDLIN( 200)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            										}
            										else {
HXLINE( 200)											int ii_min9 = ::Math_obj::floor(my);
HXDLIN( 200)											int ii_max9 = ::Math_obj::ceil(nextY);
HXDLIN( 200)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            										}
            									}
HXDLIN( 200)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 200)									if (hasUndo) {
HXLINE( 200)										int width1 = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 200)										int height1 = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 200)										 ::Dynamic imageType1 = null();
HXDLIN( 200)										 ::pi_xy::ImageStruct this17 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 200)										if (::hx::IsNull( imageType1 )) {
HXLINE(  54)											imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 200)										::Dynamic undoImage1;
HXDLIN( 200)										switch((int)(( (int)(imageType1) ))){
            											case (int)0: {
HXLINE( 200)												 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 200)												 ::iterMagic::BytesImg b4 = byt1;
HXDLIN( 200)												{
HXLINE( 200)													b4->width = width1;
HXDLIN( 200)													b4->height = height1;
HXDLIN( 200)													b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 200)													b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN( 200)													{
HXLINE( 200)														int len2 = b4->length;
HXDLIN( 200)														int w1 = 0;
HXDLIN( 200)														{
HXLINE( 200)															int _g18 = 0;
HXDLIN( 200)															int _g19 = b4->height;
HXDLIN( 200)															while((_g18 < _g19)){
HXLINE( 200)																_g18 = (_g18 + 1);
HXDLIN( 200)																int y3 = (_g18 - 1);
HXDLIN( 200)																{
HXLINE( 200)																	int _g20 = 0;
HXDLIN( 200)																	int _g21 = b4->width;
HXDLIN( 200)																	while((_g20 < _g21)){
HXLINE( 200)																		_g20 = (_g20 + 1);
HXDLIN( 200)																		int x3 = (_g20 - 1);
HXDLIN( 200)																		{
HXLINE( 200)																			w1 = (w1 + 1);
HXDLIN( 200)																			b4->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 200)																		{
HXLINE( 200)																			w1 = (w1 + 1);
HXDLIN( 200)																			b4->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 200)																		{
HXLINE( 200)																			w1 = (w1 + 1);
HXDLIN( 200)																			b4->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 200)																		{
HXLINE( 200)																			w1 = (w1 + 1);
HXDLIN( 200)																			b4->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 200)												undoImage1 = b4;
            											}
            											break;
            											case (int)1: {
HXLINE( 200)												 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 200)												 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN( 200)												{
HXLINE( 200)													a5->width = width1;
HXDLIN( 200)													a5->height = height1;
HXDLIN( 200)													a5->data = ::Array_obj< int >::__new(0);
HXDLIN( 200)													a5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 200)													{
HXLINE( 200)														int _g22 = 0;
HXDLIN( 200)														int _g23 = a5->length;
HXDLIN( 200)														while((_g22 < _g23)){
HXLINE( 200)															_g22 = (_g22 + 1);
HXDLIN( 200)															int i9 = (_g22 - 1);
HXDLIN( 200)															a5->data[i9] = 0;
            														}
            													}
            												}
HXDLIN( 200)												undoImage1 = a5;
            											}
            											break;
            											case (int)2: {
HXLINE( 200)												 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 200)												 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN( 200)												{
HXLINE( 200)													b5->width = width1;
HXDLIN( 200)													b5->height = height1;
HXDLIN( 200)													b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 200)													int size1 = (b5->length * 4);
HXDLIN( 200)													b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 200)													{
HXLINE( 200)														int _g24 = 0;
HXDLIN( 200)														int _g25 = b5->length;
HXDLIN( 200)														while((_g24 < _g25)){
HXLINE( 200)															_g24 = (_g24 + 1);
HXDLIN( 200)															int i10 = (_g24 - 1);
HXDLIN( 200)															{
HXLINE( 200)																 ::haxe::io::ArrayBufferViewImpl this18 = b5->data;
HXDLIN( 200)																bool undoImage2;
HXDLIN( 200)																if ((i10 >= 0)) {
HXLINE( 200)																	undoImage2 = (i10 < (this18->byteLength >> 2));
            																}
            																else {
HXLINE( 200)																	undoImage2 = false;
            																}
HXDLIN( 200)																if (undoImage2) {
HXLINE( 200)																	 ::haxe::io::Bytes _this1 = this18->bytes;
HXDLIN( 200)																	int pos1 = ((i10 << 2) + this18->byteOffset);
HXDLIN( 200)																	_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 200)																	_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 200)																	_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 200)																	_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 200)												undoImage1 = b5;
            											}
            											break;
            											case (int)3: {
HXLINE( 200)												 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 200)												 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 200)												{
HXLINE( 200)													v1->width = width1;
HXDLIN( 200)													v1->height = height1;
HXDLIN( 200)													v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 200)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 200)													{
HXLINE( 200)														int _g26 = 0;
HXDLIN( 200)														int _g27 = v1->length;
HXDLIN( 200)														while((_g26 < _g27)){
HXLINE( 200)															_g26 = (_g26 + 1);
HXDLIN( 200)															int i11 = (_g26 - 1);
HXDLIN( 200)															v1->data->__unsafe_set(i11,0);
            														}
            													}
            												}
HXDLIN( 200)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXLINE( 200)												 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 200)												 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN( 200)												{
HXLINE( 200)													b6->width = width1;
HXDLIN( 200)													b6->height = height1;
HXDLIN( 200)													b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 200)													b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 200)													{
HXLINE( 200)														int len3 = b6->length;
HXDLIN( 200)														 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN( 200)														if (::hx::IsNull( d1->head )) {
HXLINE( 200)															int _g28 = 0;
HXDLIN( 200)															int _g29 = len3;
HXDLIN( 200)															while((_g28 < _g29)){
HXLINE( 200)																_g28 = (_g28 + 1);
HXDLIN( 200)																int i12 = (_g28 - 1);
HXDLIN( 200)																d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            															}
            														}
            														else {
HXLINE( 200)															int _g30 = 0;
HXDLIN( 200)															int _g31 = len3;
HXDLIN( 200)															while((_g30 < _g31)){
HXLINE( 200)																_g30 = (_g30 + 1);
HXDLIN( 200)																int i13 = (_g30 - 1);
HXDLIN( 200)																{
HXLINE( 200)																	 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN( 200)																	 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 200)																	{
HXLINE( 200)																		int _g32 = 0;
HXDLIN( 200)																		int _g33 = i13;
HXDLIN( 200)																		while((_g32 < _g33)){
HXLINE( 200)																			_g32 = (_g32 + 1);
HXDLIN( 200)																			int i14 = (_g32 - 1);
HXLINE( 345)																			prev1 = l1;
HXLINE( 346)																			l1 = l1->next;
            																		}
            																	}
HXLINE( 200)																	if (::hx::IsNull( prev1 )) {
HXLINE( 200)																		b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 200)																		l1 = null();
            																	}
            																	else {
HXLINE( 200)																		prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 200)																		l1 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 200)												undoImage1 = b6;
            											}
            											break;
            										}
HXDLIN( 200)										this17->image = undoImage1;
HXDLIN( 200)										this17->width = width1;
HXDLIN( 200)										this17->height = height1;
HXDLIN( 200)										this17->imageType = ( (int)(imageType1) );
HXDLIN( 200)										undoImage = this17;
HXDLIN( 200)										{
HXLINE( 200)											int rectLeft = xIter3->start;
HXDLIN( 200)											int rectTop = yIter3->start;
HXDLIN( 200)											int rectRight = xIter3->max;
HXDLIN( 200)											bool forceClear = false;
HXDLIN( 200)											{
HXLINE( 200)												int _g34 = rectTop;
HXDLIN( 200)												int _g35 = yIter3->max;
HXDLIN( 200)												while((_g34 < _g35)){
HXLINE( 200)													_g34 = (_g34 + 1);
HXDLIN( 200)													int dy = (_g34 - 1);
HXDLIN( 200)													{
HXLINE( 200)														int _g36 = rectLeft;
HXDLIN( 200)														int _g37 = rectRight;
HXDLIN( 200)														while((_g36 < _g37)){
HXLINE( 200)															_g36 = (_g36 + 1);
HXDLIN( 200)															int dx = (_g36 - 1);
HXDLIN( 200)															::Dynamic this19 = this16->image;
HXDLIN( 200)															int index1;
HXDLIN( 200)															if (this16->useVirtualPos) {
HXLINE( 200)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this16->virtualY) * ( (Float)(this16->width) )) + dx) - this16->virtualX));
            															}
            															else {
HXLINE( 200)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this16->width) + dx)) ));
            															}
HXDLIN( 200)															int c1 = ::iterMagic::Iimg_obj::get(this19,index1);
HXDLIN( 200)															int col;
HXDLIN( 200)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																col = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE( 200)																col = c1;
            															}
HXDLIN( 200)															bool _hx_tmp5;
HXDLIN( 200)															if (this16->useMask) {
HXLINE( 200)																_hx_tmp5 = ::hx::IsNotNull( this16->mask );
            															}
            															else {
HXLINE( 200)																_hx_tmp5 = false;
            															}
HXDLIN( 200)															if (_hx_tmp5) {
HXLINE( 200)																 ::pi_xy::ImageStruct this20 = this16->mask;
HXDLIN( 200)																::Dynamic this21 = this20->image;
HXDLIN( 200)																int index2;
HXDLIN( 200)																if (this20->useVirtualPos) {
HXLINE( 200)																	index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this20->virtualY) * ( (Float)(this20->width) )) + dx) - this20->virtualX));
            																}
            																else {
HXLINE( 200)																	index2 = ::Std_obj::_hx_int(( (Float)(((dy * this20->width) + dx)) ));
            																}
HXDLIN( 200)																int c2 = ::iterMagic::Iimg_obj::get(this21,index2);
HXDLIN( 200)																int v2;
HXDLIN( 200)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																	v2 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXLINE( 200)																	v2 = c2;
            																}
HXDLIN( 200)																int maskPixel = v2;
HXDLIN( 200)																int this22 = col;
HXDLIN( 200)																if ((maskPixel == 0)) {
HXLINE( 200)																	col = this22;
            																}
            																else {
HXLINE( 200)																	Float m0;
HXDLIN( 200)																	int this23 = ((maskPixel >> 24) & 255);
HXDLIN( 200)																	if ((this23 == 0)) {
HXLINE( 200)																		m0 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		m0 = (( (Float)(this23) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float m1;
HXDLIN( 200)																	int this24 = ((maskPixel >> 16) & 255);
HXDLIN( 200)																	if ((this24 == 0)) {
HXLINE( 200)																		m1 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		m1 = (( (Float)(this24) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float m2;
HXDLIN( 200)																	int this25 = ((maskPixel >> 8) & 255);
HXDLIN( 200)																	if ((this25 == 0)) {
HXLINE( 200)																		m2 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		m2 = (( (Float)(this25) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float m3;
HXDLIN( 200)																	int this26 = (maskPixel & 255);
HXDLIN( 200)																	if ((this26 == 0)) {
HXLINE( 200)																		m3 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		m3 = (( (Float)(this26) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this22 >> 24) & 255)) )));
HXDLIN( 200)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this22 >> 16) & 255)) )));
HXDLIN( 200)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this22 >> 8) & 255)) )));
HXDLIN( 200)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this22 & 255)) )));
HXDLIN( 200)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 200)															if ((col != 0)) {
HXLINE( 200)																int x4 = (dx - rectLeft);
HXDLIN( 200)																int y4 = (dy - rectTop);
HXDLIN( 200)																int c3 = col;
HXDLIN( 200)																bool _hx_tmp6;
HXDLIN( 200)																if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 200)																	_hx_tmp6 = undoImage->transparent;
            																}
            																else {
HXLINE( 200)																	_hx_tmp6 = false;
            																}
HXDLIN( 200)																if (_hx_tmp6) {
HXLINE( 200)																	int location1;
HXDLIN( 200)																	if (undoImage->useVirtualPos) {
HXLINE( 200)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x4) - undoImage->virtualX));
            																	}
            																	else {
HXLINE( 200)																		location1 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x4)) ));
            																	}
HXDLIN( 200)																	int this27 = ::iterMagic::Iimg_obj::get(undoImage->image,location1);
HXDLIN( 200)																	int this28;
HXDLIN( 200)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																		this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            																	}
            																	else {
HXLINE( 200)																		this28 = this27;
            																	}
HXDLIN( 200)																	Float a11;
HXDLIN( 200)																	int this29 = ((this28 >> 24) & 255);
HXDLIN( 200)																	if ((this29 == 0)) {
HXLINE( 200)																		a11 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		a11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float r11;
HXDLIN( 200)																	int this30 = ((this28 >> 16) & 255);
HXDLIN( 200)																	if ((this30 == 0)) {
HXLINE( 200)																		r11 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		r11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float g11;
HXDLIN( 200)																	int this31 = ((this28 >> 8) & 255);
HXDLIN( 200)																	if ((this31 == 0)) {
HXLINE( 200)																		g11 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		g11 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float b12;
HXDLIN( 200)																	int this32 = (this28 & 255);
HXDLIN( 200)																	if ((this32 == 0)) {
HXLINE( 200)																		b12 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		b12 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float a21;
HXDLIN( 200)																	int this33 = ((col >> 24) & 255);
HXDLIN( 200)																	if ((this33 == 0)) {
HXLINE( 200)																		a21 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		a21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float r21;
HXDLIN( 200)																	int this34 = ((col >> 16) & 255);
HXDLIN( 200)																	if ((this34 == 0)) {
HXLINE( 200)																		r21 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		r21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float g21;
HXDLIN( 200)																	int this35 = ((col >> 8) & 255);
HXDLIN( 200)																	if ((this35 == 0)) {
HXLINE( 200)																		g21 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		g21 = (( (Float)(this35) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float b22;
HXDLIN( 200)																	int this36 = (col & 255);
HXDLIN( 200)																	if ((this36 == 0)) {
HXLINE( 200)																		b22 = ((Float)0.);
            																	}
            																	else {
HXLINE( 200)																		b22 = (( (Float)(this36) ) / ( (Float)(255) ));
            																	}
HXDLIN( 200)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 200)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 200)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 200)																	int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 200)																	int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 200)																	int blended1 = ((((a6 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 200)																	{
HXLINE( 200)																		int _hx_tmp7;
HXDLIN( 200)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																			_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXLINE( 200)																			_hx_tmp7 = blended1;
            																		}
HXDLIN( 200)																		::iterMagic::Iimg_obj::set(undoImage->image,location1,_hx_tmp7);
            																	}
            																}
            																else {
HXLINE( 200)																	::Dynamic this37 = undoImage->image;
HXDLIN( 200)																	int index3;
HXDLIN( 200)																	if (undoImage->useVirtualPos) {
HXLINE( 200)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x4) - undoImage->virtualX));
            																	}
            																	else {
HXLINE( 200)																		index3 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x4)) ));
            																	}
HXDLIN( 200)																	int _hx_tmp8;
HXDLIN( 200)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																		_hx_tmp8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXLINE( 200)																		_hx_tmp8 = c3;
            																	}
HXDLIN( 200)																	::iterMagic::Iimg_obj::set(this37,index3,_hx_tmp8);
            																}
            															}
            															else {
HXLINE( 200)																if (forceClear) {
HXLINE( 200)																	::Dynamic this38 = undoImage->image;
HXDLIN( 200)																	int x5 = (dx - rectLeft);
HXDLIN( 200)																	int y5 = (dy - rectTop);
HXDLIN( 200)																	int index4;
HXDLIN( 200)																	if (undoImage->useVirtualPos) {
HXLINE( 200)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            																	}
            																	else {
HXLINE( 200)																		index4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            																	}
HXDLIN( 200)																	::iterMagic::Iimg_obj::set(this38,index4,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 200)									{
HXLINE( 200)										int _g_min = xIter3->start;
HXDLIN( 200)										int _g_max = xIter3->max;
HXDLIN( 200)										while((_g_min < _g_max)){
HXLINE( 200)											_g_min = (_g_min + 1);
HXDLIN( 200)											int px = (_g_min - 1);
HXDLIN( 200)											Float pcx = (( (Float)(px) ) - nextX);
HXDLIN( 200)											{
HXLINE( 200)												int _g_min1 = yIter3->start;
HXDLIN( 200)												int _g_max1 = yIter3->max;
HXDLIN( 200)												while((_g_min1 < _g_max1)){
HXLINE( 200)													_g_min1 = (_g_min1 + 1);
HXDLIN( 200)													int py = (_g_min1 - 1);
HXDLIN( 200)													Float pcy = (( (Float)(py) ) - nextY);
HXDLIN( 200)													Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 200)													Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 200)													Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 200)													Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 200)													Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 200)													bool _hx_tmp9;
HXDLIN( 200)													bool _hx_tmp10;
HXDLIN( 200)													if ((ratioA >= 0)) {
HXLINE( 200)														_hx_tmp10 = (ratioB >= 0);
            													}
            													else {
HXLINE( 200)														_hx_tmp10 = false;
            													}
HXDLIN( 200)													if (_hx_tmp10) {
HXLINE( 200)														_hx_tmp9 = (ratioC >= 0);
            													}
            													else {
HXLINE( 200)														_hx_tmp9 = false;
            													}
HXDLIN( 200)													if (_hx_tmp9) {
HXLINE( 200)														int i15 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 200)														if ((i15 > 255)) {
HXLINE(  24)															i15 = 255;
            														}
HXLINE( 200)														if ((i15 < 0)) {
HXLINE(  25)															i15 = 0;
            														}
HXLINE( 200)														int a7 = i15;
HXDLIN( 200)														int i16 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 200)														if ((i16 > 255)) {
HXLINE(  24)															i16 = 255;
            														}
HXLINE( 200)														if ((i16 < 0)) {
HXLINE(  25)															i16 = 0;
            														}
HXLINE( 200)														int r4 = i16;
HXDLIN( 200)														int i17 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 200)														if ((i17 > 255)) {
HXLINE(  24)															i17 = 255;
            														}
HXLINE( 200)														if ((i17 < 0)) {
HXLINE(  25)															i17 = 0;
            														}
HXLINE( 200)														int g4 = i17;
HXDLIN( 200)														int i18 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 200)														if ((i18 > 255)) {
HXLINE(  24)															i18 = 255;
            														}
HXLINE( 200)														if ((i18 < 0)) {
HXLINE(  25)															i18 = 0;
            														}
HXLINE( 200)														int b8 = i18;
HXDLIN( 200)														{
HXLINE( 200)															int location2;
HXDLIN( 200)															if (this16->useVirtualPos) {
HXLINE( 200)																location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this16->virtualY) * ( (Float)(this16->width) )) + px) - this16->virtualX));
            															}
            															else {
HXLINE( 200)																location2 = ::Std_obj::_hx_int(( (Float)(((py * this16->width) + px)) ));
            															}
HXDLIN( 200)															bool _hx_tmp11;
HXDLIN( 200)															if (this16->transparent) {
HXLINE( 200)																_hx_tmp11 = (a7 < 254);
            															}
            															else {
HXLINE( 200)																_hx_tmp11 = false;
            															}
HXDLIN( 200)															if (_hx_tmp11) {
HXLINE( 200)																int this39 = ::iterMagic::Iimg_obj::get(this16->image,location2);
HXDLIN( 200)																int old;
HXDLIN( 200)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																	old = ((((((this39 >> 24) & 255) << 24) | ((this39 & 255) << 16)) | (((this39 >> 8) & 255) << 8)) | ((this39 >> 16) & 255));
            																}
            																else {
HXLINE( 200)																	old = this39;
            																}
HXDLIN( 200)																int rhs = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 200)																Float a12;
HXDLIN( 200)																int this40 = ((old >> 24) & 255);
HXDLIN( 200)																if ((this40 == 0)) {
HXLINE( 200)																	a12 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	a12 = (( (Float)(this40) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float r12;
HXDLIN( 200)																int this41 = ((old >> 16) & 255);
HXDLIN( 200)																if ((this41 == 0)) {
HXLINE( 200)																	r12 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	r12 = (( (Float)(this41) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float g12;
HXDLIN( 200)																int this42 = ((old >> 8) & 255);
HXDLIN( 200)																if ((this42 == 0)) {
HXLINE( 200)																	g12 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	g12 = (( (Float)(this42) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float b13;
HXDLIN( 200)																int this43 = (old & 255);
HXDLIN( 200)																if ((this43 == 0)) {
HXLINE( 200)																	b13 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float a22;
HXDLIN( 200)																int this44 = ((rhs >> 24) & 255);
HXDLIN( 200)																if ((this44 == 0)) {
HXLINE( 200)																	a22 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	a22 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float r22;
HXDLIN( 200)																int this45 = ((rhs >> 16) & 255);
HXDLIN( 200)																if ((this45 == 0)) {
HXLINE( 200)																	r22 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	r22 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float g22;
HXDLIN( 200)																int this46 = ((rhs >> 8) & 255);
HXDLIN( 200)																if ((this46 == 0)) {
HXLINE( 200)																	g22 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	g22 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float b23;
HXDLIN( 200)																int this47 = (rhs & 255);
HXDLIN( 200)																if ((this47 == 0)) {
HXLINE( 200)																	b23 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 200)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 200)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 200)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 200)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 200)																int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 200)																{
HXLINE( 200)																	int _hx_tmp12;
HXDLIN( 200)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																		_hx_tmp12 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXLINE( 200)																		_hx_tmp12 = blended2;
            																	}
HXDLIN( 200)																	::iterMagic::Iimg_obj::set(this16->image,location2,_hx_tmp12);
            																}
            															}
            															else {
HXLINE( 200)																int value;
HXDLIN( 200)																if (this16->isLittle) {
HXLINE( 200)																	value = ((((a7 << 24) | (b8 << 16)) | (g4 << 8)) | r4);
            																}
            																else {
HXLINE( 200)																	value = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
            																}
HXDLIN( 200)																::iterMagic::Iimg_obj::set(this16->image,location2,value);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 200)									if ((hasHit == false)) {
HXLINE( 200)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX,nextY,true);
HXDLIN( 200)										if (hasUndo) {
HXLINE( 200)											v3->undoImage = undoImage;
HXDLIN( 200)											v3->undoX = xIter3->start;
HXDLIN( 200)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
HXLINE( 236)							lastX = nextX;
HXLINE( 237)							lastY = nextY;
            						}
            					}
            				}
            				else {
HXLINE( 200)					int _g38 = 0;
HXDLIN( 200)					int _g39 = (sides + 1);
HXDLIN( 200)					while((_g38 < _g39)){
HXLINE( 200)						_g38 = (_g38 + 1);
HXDLIN( 200)						int i19 = (_g38 - 1);
HXDLIN( 200)						Float nextX1 = (rx + (rx * ::Math_obj::cos(((( (Float)(i19) ) * theta) + omega))));
HXDLIN( 200)						Float nextY1 = (ry + (ry * ::Math_obj::sin(((( (Float)(i19) ) * theta) + omega))));
HXDLIN( 200)						{
HXLINE( 200)							 ::pi_xy::ImageStruct this48 = this15;
HXDLIN( 200)							{
HXLINE( 200)								bool hasHit1 = false;
HXDLIN( 200)								bool hasUndo1 = false;
HXDLIN( 200)								int aA1 = ((colorOut >> 24) & 255);
HXDLIN( 200)								int rA1 = ((colorOut >> 16) & 255);
HXDLIN( 200)								int gA1 = ((colorOut >> 8) & 255);
HXDLIN( 200)								int bA1 = (colorOut & 255);
HXDLIN( 200)								int aB1 = ((colorIn >> 24) & 255);
HXDLIN( 200)								int rB1 = ((colorIn >> 16) & 255);
HXDLIN( 200)								int gB1 = ((colorIn >> 8) & 255);
HXDLIN( 200)								int bB1 = (colorIn & 255);
HXDLIN( 200)								int aC1 = ((colorOut >> 24) & 255);
HXDLIN( 200)								int rC1 = ((colorOut >> 16) & 255);
HXDLIN( 200)								int gC1 = ((colorOut >> 8) & 255);
HXDLIN( 200)								int bC1 = (colorOut & 255);
HXDLIN( 200)								Float bcx1 = (lastX - nextX1);
HXDLIN( 200)								Float bcy1 = (lastY - nextY1);
HXDLIN( 200)								Float acx1 = (mx - nextX1);
HXDLIN( 200)								Float acy1 = (my - nextY1);
HXDLIN( 200)								Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 200)								Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 200)								Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 200)								Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 200)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 200)								if ((mx > lastX)) {
HXLINE( 200)									if ((mx > nextX1)) {
HXLINE( 200)										int min4;
HXDLIN( 200)										if ((lastX > nextX1)) {
HXLINE( 200)											min4 = ::Math_obj::floor(nextX1);
            										}
            										else {
HXLINE( 200)											min4 = ::Math_obj::floor(lastX);
            										}
HXDLIN( 200)										int ii_min10 = min4;
HXDLIN( 200)										int ii_max10 = ::Math_obj::ceil(mx);
HXDLIN( 200)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXLINE( 200)										int ii_min11 = ::Math_obj::floor(lastX);
HXDLIN( 200)										int ii_max11 = ::Math_obj::ceil(nextX1);
HXDLIN( 200)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
            								else {
HXLINE( 200)									if ((lastX > nextX1)) {
HXLINE( 200)										int min5;
HXDLIN( 200)										if ((mx > nextX1)) {
HXLINE( 200)											min5 = ::Math_obj::floor(nextX1);
            										}
            										else {
HXLINE( 200)											min5 = ::Math_obj::ceil(mx);
            										}
HXDLIN( 200)										int ii_min12 = min5;
HXDLIN( 200)										int ii_max12 = ::Math_obj::ceil(lastX);
HXDLIN( 200)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXLINE( 200)										int ii_min13 = ::Math_obj::floor(mx);
HXDLIN( 200)										int ii_max13 = ::Math_obj::ceil(nextX1);
HXDLIN( 200)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
HXDLIN( 200)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 200)								if ((my > lastY)) {
HXLINE( 200)									if ((my > nextY1)) {
HXLINE( 200)										int min6;
HXDLIN( 200)										if ((lastY > nextY1)) {
HXLINE( 200)											min6 = ::Math_obj::floor(nextY1);
            										}
            										else {
HXLINE( 200)											min6 = ::Math_obj::floor(lastY);
            										}
HXDLIN( 200)										int ii_min14 = min6;
HXDLIN( 200)										int ii_max14 = ::Math_obj::ceil(my);
HXDLIN( 200)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXLINE( 200)										int ii_min15 = ::Math_obj::floor(lastY);
HXDLIN( 200)										int ii_max15 = ::Math_obj::ceil(nextY1);
HXDLIN( 200)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
            								else {
HXLINE( 200)									if ((lastY > nextY1)) {
HXLINE( 200)										int min7;
HXDLIN( 200)										if ((my > nextY1)) {
HXLINE( 200)											min7 = ::Math_obj::floor(nextY1);
            										}
            										else {
HXLINE( 200)											min7 = ::Math_obj::ceil(my);
            										}
HXDLIN( 200)										int ii_min16 = min7;
HXDLIN( 200)										int ii_max16 = ::Math_obj::ceil(lastY);
HXDLIN( 200)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            									}
            									else {
HXLINE( 200)										int ii_min17 = ::Math_obj::floor(my);
HXDLIN( 200)										int ii_max17 = ::Math_obj::ceil(nextY1);
HXDLIN( 200)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            									}
            								}
HXDLIN( 200)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 200)								if (hasUndo1) {
HXLINE( 200)									int width2 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 200)									int height2 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 200)									 ::Dynamic imageType2 = null();
HXDLIN( 200)									 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 200)									if (::hx::IsNull( imageType2 )) {
HXLINE(  54)										imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 200)									::Dynamic undoImage4;
HXDLIN( 200)									switch((int)(( (int)(imageType2) ))){
            										case (int)0: {
HXLINE( 200)											 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 200)											 ::iterMagic::BytesImg b10 = byt2;
HXDLIN( 200)											{
HXLINE( 200)												b10->width = width2;
HXDLIN( 200)												b10->height = height2;
HXDLIN( 200)												b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 200)												b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN( 200)												{
HXLINE( 200)													int len4 = b10->length;
HXDLIN( 200)													int w2 = 0;
HXDLIN( 200)													{
HXLINE( 200)														int _g40 = 0;
HXDLIN( 200)														int _g41 = b10->height;
HXDLIN( 200)														while((_g40 < _g41)){
HXLINE( 200)															_g40 = (_g40 + 1);
HXDLIN( 200)															int y6 = (_g40 - 1);
HXDLIN( 200)															{
HXLINE( 200)																int _g42 = 0;
HXDLIN( 200)																int _g43 = b10->width;
HXDLIN( 200)																while((_g42 < _g43)){
HXLINE( 200)																	_g42 = (_g42 + 1);
HXDLIN( 200)																	int x6 = (_g42 - 1);
HXDLIN( 200)																	{
HXLINE( 200)																		w2 = (w2 + 1);
HXDLIN( 200)																		b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 200)																	{
HXLINE( 200)																		w2 = (w2 + 1);
HXDLIN( 200)																		b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 200)																	{
HXLINE( 200)																		w2 = (w2 + 1);
HXDLIN( 200)																		b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 200)																	{
HXLINE( 200)																		w2 = (w2 + 1);
HXDLIN( 200)																		b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 200)											undoImage4 = b10;
            										}
            										break;
            										case (int)1: {
HXLINE( 200)											 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 200)											 ::iterMagic::ArrIntImg a9 = arrI2;
HXDLIN( 200)											{
HXLINE( 200)												a9->width = width2;
HXDLIN( 200)												a9->height = height2;
HXDLIN( 200)												a9->data = ::Array_obj< int >::__new(0);
HXDLIN( 200)												a9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 200)												{
HXLINE( 200)													int _g44 = 0;
HXDLIN( 200)													int _g45 = a9->length;
HXDLIN( 200)													while((_g44 < _g45)){
HXLINE( 200)														_g44 = (_g44 + 1);
HXDLIN( 200)														int i20 = (_g44 - 1);
HXDLIN( 200)														a9->data[i20] = 0;
            													}
            												}
            											}
HXDLIN( 200)											undoImage4 = a9;
            										}
            										break;
            										case (int)2: {
HXLINE( 200)											 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 200)											 ::iterMagic::U32ArrImg b14 = u32a2;
HXDLIN( 200)											{
HXLINE( 200)												b14->width = width2;
HXDLIN( 200)												b14->height = height2;
HXDLIN( 200)												b14->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 200)												int size2 = (b14->length * 4);
HXDLIN( 200)												b14->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 200)												{
HXLINE( 200)													int _g46 = 0;
HXDLIN( 200)													int _g47 = b14->length;
HXDLIN( 200)													while((_g46 < _g47)){
HXLINE( 200)														_g46 = (_g46 + 1);
HXDLIN( 200)														int i21 = (_g46 - 1);
HXDLIN( 200)														{
HXLINE( 200)															 ::haxe::io::ArrayBufferViewImpl this50 = b14->data;
HXDLIN( 200)															bool undoImage5;
HXDLIN( 200)															if ((i21 >= 0)) {
HXLINE( 200)																undoImage5 = (i21 < (this50->byteLength >> 2));
            															}
            															else {
HXLINE( 200)																undoImage5 = false;
            															}
HXDLIN( 200)															if (undoImage5) {
HXLINE( 200)																 ::haxe::io::Bytes _this2 = this50->bytes;
HXDLIN( 200)																int pos2 = ((i21 << 2) + this50->byteOffset);
HXDLIN( 200)																_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 200)																_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 200)																_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 200)																_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 200)											undoImage4 = b14;
            										}
            										break;
            										case (int)3: {
HXLINE( 200)											 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 200)											 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN( 200)											{
HXLINE( 200)												v4->width = width2;
HXDLIN( 200)												v4->height = height2;
HXDLIN( 200)												v4->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 200)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 200)												{
HXLINE( 200)													int _g48 = 0;
HXDLIN( 200)													int _g49 = v4->length;
HXDLIN( 200)													while((_g48 < _g49)){
HXLINE( 200)														_g48 = (_g48 + 1);
HXDLIN( 200)														int i22 = (_g48 - 1);
HXDLIN( 200)														v4->data->__unsafe_set(i22,0);
            													}
            												}
            											}
HXDLIN( 200)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXLINE( 200)											 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 200)											 ::iterMagic::StackIntImg b15 = sInt2;
HXDLIN( 200)											{
HXLINE( 200)												b15->width = width2;
HXDLIN( 200)												b15->height = height2;
HXDLIN( 200)												b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 200)												b15->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 200)												{
HXLINE( 200)													int len5 = b15->length;
HXDLIN( 200)													 ::haxe::ds::GenericStack_Int d2 = b15->data;
HXDLIN( 200)													if (::hx::IsNull( d2->head )) {
HXLINE( 200)														int _g50 = 0;
HXDLIN( 200)														int _g51 = len5;
HXDLIN( 200)														while((_g50 < _g51)){
HXLINE( 200)															_g50 = (_g50 + 1);
HXDLIN( 200)															int i23 = (_g50 - 1);
HXDLIN( 200)															d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            														}
            													}
            													else {
HXLINE( 200)														int _g52 = 0;
HXDLIN( 200)														int _g53 = len5;
HXDLIN( 200)														while((_g52 < _g53)){
HXLINE( 200)															_g52 = (_g52 + 1);
HXDLIN( 200)															int i24 = (_g52 - 1);
HXDLIN( 200)															{
HXLINE( 200)																 ::haxe::ds::GenericCell_Int l2 = b15->data->head;
HXDLIN( 200)																 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 200)																{
HXLINE( 200)																	int _g54 = 0;
HXDLIN( 200)																	int _g55 = i24;
HXDLIN( 200)																	while((_g54 < _g55)){
HXLINE( 200)																		_g54 = (_g54 + 1);
HXDLIN( 200)																		int i25 = (_g54 - 1);
HXLINE( 345)																		prev2 = l2;
HXLINE( 346)																		l2 = l2->next;
            																	}
            																}
HXLINE( 200)																if (::hx::IsNull( prev2 )) {
HXLINE( 200)																	b15->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 200)																	l2 = null();
            																}
            																else {
HXLINE( 200)																	prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 200)																	l2 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 200)											undoImage4 = b15;
            										}
            										break;
            									}
HXDLIN( 200)									this49->image = undoImage4;
HXDLIN( 200)									this49->width = width2;
HXDLIN( 200)									this49->height = height2;
HXDLIN( 200)									this49->imageType = ( (int)(imageType2) );
HXDLIN( 200)									undoImage3 = this49;
HXDLIN( 200)									{
HXLINE( 200)										int rectLeft1 = xIter31->start;
HXDLIN( 200)										int rectTop1 = yIter31->start;
HXDLIN( 200)										int rectRight1 = xIter31->max;
HXDLIN( 200)										bool forceClear1 = false;
HXDLIN( 200)										{
HXLINE( 200)											int _g56 = rectTop1;
HXDLIN( 200)											int _g57 = yIter31->max;
HXDLIN( 200)											while((_g56 < _g57)){
HXLINE( 200)												_g56 = (_g56 + 1);
HXDLIN( 200)												int dy1 = (_g56 - 1);
HXDLIN( 200)												{
HXLINE( 200)													int _g58 = rectLeft1;
HXDLIN( 200)													int _g59 = rectRight1;
HXDLIN( 200)													while((_g58 < _g59)){
HXLINE( 200)														_g58 = (_g58 + 1);
HXDLIN( 200)														int dx1 = (_g58 - 1);
HXDLIN( 200)														::Dynamic this51 = this48->image;
HXDLIN( 200)														int index5;
HXDLIN( 200)														if (this48->useVirtualPos) {
HXLINE( 200)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this48->virtualY) * ( (Float)(this48->width) )) + dx1) - this48->virtualX));
            														}
            														else {
HXLINE( 200)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this48->width) + dx1)) ));
            														}
HXDLIN( 200)														int c4 = ::iterMagic::Iimg_obj::get(this51,index5);
HXDLIN( 200)														int col1;
HXDLIN( 200)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXLINE( 200)															col1 = c4;
            														}
HXDLIN( 200)														bool _hx_tmp13;
HXDLIN( 200)														if (this48->useMask) {
HXLINE( 200)															_hx_tmp13 = ::hx::IsNotNull( this48->mask );
            														}
            														else {
HXLINE( 200)															_hx_tmp13 = false;
            														}
HXDLIN( 200)														if (_hx_tmp13) {
HXLINE( 200)															 ::pi_xy::ImageStruct this52 = this48->mask;
HXDLIN( 200)															::Dynamic this53 = this52->image;
HXDLIN( 200)															int index6;
HXDLIN( 200)															if (this52->useVirtualPos) {
HXLINE( 200)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this52->virtualY) * ( (Float)(this52->width) )) + dx1) - this52->virtualX));
            															}
            															else {
HXLINE( 200)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this52->width) + dx1)) ));
            															}
HXDLIN( 200)															int c5 = ::iterMagic::Iimg_obj::get(this53,index6);
HXDLIN( 200)															int v5;
HXDLIN( 200)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXLINE( 200)																v5 = c5;
            															}
HXDLIN( 200)															int maskPixel1 = v5;
HXDLIN( 200)															int this54 = col1;
HXDLIN( 200)															if ((maskPixel1 == 0)) {
HXLINE( 200)																col1 = this54;
            															}
            															else {
HXLINE( 200)																Float m01;
HXDLIN( 200)																int this55 = ((maskPixel1 >> 24) & 255);
HXDLIN( 200)																if ((this55 == 0)) {
HXLINE( 200)																	m01 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	m01 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float m11;
HXDLIN( 200)																int this56 = ((maskPixel1 >> 16) & 255);
HXDLIN( 200)																if ((this56 == 0)) {
HXLINE( 200)																	m11 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	m11 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float m21;
HXDLIN( 200)																int this57 = ((maskPixel1 >> 8) & 255);
HXDLIN( 200)																if ((this57 == 0)) {
HXLINE( 200)																	m21 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	m21 = (( (Float)(this57) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float m31;
HXDLIN( 200)																int this58 = (maskPixel1 & 255);
HXDLIN( 200)																if ((this58 == 0)) {
HXLINE( 200)																	m31 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	m31 = (( (Float)(this58) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this54 >> 24) & 255)) )));
HXDLIN( 200)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this54 >> 16) & 255)) )));
HXDLIN( 200)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this54 >> 8) & 255)) )));
HXDLIN( 200)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this54 & 255)) )));
HXDLIN( 200)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 200)														if ((col1 != 0)) {
HXLINE( 200)															int x7 = (dx1 - rectLeft1);
HXDLIN( 200)															int y7 = (dy1 - rectTop1);
HXDLIN( 200)															int c6 = col1;
HXDLIN( 200)															bool _hx_tmp14;
HXDLIN( 200)															if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 200)																_hx_tmp14 = undoImage3->transparent;
            															}
            															else {
HXLINE( 200)																_hx_tmp14 = false;
            															}
HXDLIN( 200)															if (_hx_tmp14) {
HXLINE( 200)																int location3;
HXDLIN( 200)																if (undoImage3->useVirtualPos) {
HXLINE( 200)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 200)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            																}
HXDLIN( 200)																int this59 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN( 200)																int this60;
HXDLIN( 200)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXLINE( 200)																	this60 = this59;
            																}
HXDLIN( 200)																Float a13;
HXDLIN( 200)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 200)																if ((this61 == 0)) {
HXLINE( 200)																	a13 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float r13;
HXDLIN( 200)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 200)																if ((this62 == 0)) {
HXLINE( 200)																	r13 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float g13;
HXDLIN( 200)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 200)																if ((this63 == 0)) {
HXLINE( 200)																	g13 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float b16;
HXDLIN( 200)																int this64 = (this60 & 255);
HXDLIN( 200)																if ((this64 == 0)) {
HXLINE( 200)																	b16 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	b16 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float a23;
HXDLIN( 200)																int this65 = ((col1 >> 24) & 255);
HXDLIN( 200)																if ((this65 == 0)) {
HXLINE( 200)																	a23 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float r23;
HXDLIN( 200)																int this66 = ((col1 >> 16) & 255);
HXDLIN( 200)																if ((this66 == 0)) {
HXLINE( 200)																	r23 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float g23;
HXDLIN( 200)																int this67 = ((col1 >> 8) & 255);
HXDLIN( 200)																if ((this67 == 0)) {
HXLINE( 200)																	g23 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float b24;
HXDLIN( 200)																int this68 = (col1 & 255);
HXDLIN( 200)																if ((this68 == 0)) {
HXLINE( 200)																	b24 = ((Float)0.);
            																}
            																else {
HXLINE( 200)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 200)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 200)																int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 200)																int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 200)																int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a33) + (b24 * a23))));
HXDLIN( 200)																int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 200)																int blended3 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b17);
HXDLIN( 200)																{
HXLINE( 200)																	int _hx_tmp15;
HXDLIN( 200)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																		_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXLINE( 200)																		_hx_tmp15 = blended3;
            																	}
HXDLIN( 200)																	::iterMagic::Iimg_obj::set(undoImage3->image,location3,_hx_tmp15);
            																}
            															}
            															else {
HXLINE( 200)																::Dynamic this69 = undoImage3->image;
HXDLIN( 200)																int index7;
HXDLIN( 200)																if (undoImage3->useVirtualPos) {
HXLINE( 200)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 200)																	index7 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            																}
HXDLIN( 200)																int _hx_tmp16;
HXDLIN( 200)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																	_hx_tmp16 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXLINE( 200)																	_hx_tmp16 = c6;
            																}
HXDLIN( 200)																::iterMagic::Iimg_obj::set(this69,index7,_hx_tmp16);
            															}
            														}
            														else {
HXLINE( 200)															if (forceClear1) {
HXLINE( 200)																::Dynamic this70 = undoImage3->image;
HXDLIN( 200)																int x8 = (dx1 - rectLeft1);
HXDLIN( 200)																int y8 = (dy1 - rectTop1);
HXDLIN( 200)																int index8;
HXDLIN( 200)																if (undoImage3->useVirtualPos) {
HXLINE( 200)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 200)																	index8 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            																}
HXDLIN( 200)																::iterMagic::Iimg_obj::set(this70,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 200)								{
HXLINE( 200)									int _g_min2 = xIter31->start;
HXDLIN( 200)									int _g_max2 = xIter31->max;
HXDLIN( 200)									while((_g_min2 < _g_max2)){
HXLINE( 200)										_g_min2 = (_g_min2 + 1);
HXDLIN( 200)										int px1 = (_g_min2 - 1);
HXDLIN( 200)										Float pcx1 = (( (Float)(px1) ) - nextX1);
HXDLIN( 200)										{
HXLINE( 200)											int _g_min3 = yIter31->start;
HXDLIN( 200)											int _g_max3 = yIter31->max;
HXDLIN( 200)											while((_g_min3 < _g_max3)){
HXLINE( 200)												_g_min3 = (_g_min3 + 1);
HXDLIN( 200)												int py1 = (_g_min3 - 1);
HXDLIN( 200)												Float pcy1 = (( (Float)(py1) ) - nextY1);
HXDLIN( 200)												Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 200)												Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 200)												Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 200)												Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 200)												Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 200)												bool _hx_tmp17;
HXDLIN( 200)												bool _hx_tmp18;
HXDLIN( 200)												if ((ratioA1 >= 0)) {
HXLINE( 200)													_hx_tmp18 = (ratioB1 >= 0);
            												}
            												else {
HXLINE( 200)													_hx_tmp18 = false;
            												}
HXDLIN( 200)												if (_hx_tmp18) {
HXLINE( 200)													_hx_tmp17 = (ratioC1 >= 0);
            												}
            												else {
HXLINE( 200)													_hx_tmp17 = false;
            												}
HXDLIN( 200)												if (_hx_tmp17) {
HXLINE( 200)													int i26 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 200)													if ((i26 > 255)) {
HXLINE(  24)														i26 = 255;
            													}
HXLINE( 200)													if ((i26 < 0)) {
HXLINE(  25)														i26 = 0;
            													}
HXLINE( 200)													int a14 = i26;
HXDLIN( 200)													int i27 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 200)													if ((i27 > 255)) {
HXLINE(  24)														i27 = 255;
            													}
HXLINE( 200)													if ((i27 < 0)) {
HXLINE(  25)														i27 = 0;
            													}
HXLINE( 200)													int r7 = i27;
HXDLIN( 200)													int i28 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 200)													if ((i28 > 255)) {
HXLINE(  24)														i28 = 255;
            													}
HXLINE( 200)													if ((i28 < 0)) {
HXLINE(  25)														i28 = 0;
            													}
HXLINE( 200)													int g7 = i28;
HXDLIN( 200)													int i29 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 200)													if ((i29 > 255)) {
HXLINE(  24)														i29 = 255;
            													}
HXLINE( 200)													if ((i29 < 0)) {
HXLINE(  25)														i29 = 0;
            													}
HXLINE( 200)													int b18 = i29;
HXDLIN( 200)													{
HXLINE( 200)														int location4;
HXDLIN( 200)														if (this48->useVirtualPos) {
HXLINE( 200)															location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this48->virtualY) * ( (Float)(this48->width) )) + px1) - this48->virtualX));
            														}
            														else {
HXLINE( 200)															location4 = ::Std_obj::_hx_int(( (Float)(((py1 * this48->width) + px1)) ));
            														}
HXDLIN( 200)														bool _hx_tmp19;
HXDLIN( 200)														if (this48->transparent) {
HXLINE( 200)															_hx_tmp19 = (a14 < 254);
            														}
            														else {
HXLINE( 200)															_hx_tmp19 = false;
            														}
HXDLIN( 200)														if (_hx_tmp19) {
HXLINE( 200)															int this71 = ::iterMagic::Iimg_obj::get(this48->image,location4);
HXDLIN( 200)															int old1;
HXDLIN( 200)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																old1 = ((((((this71 >> 24) & 255) << 24) | ((this71 & 255) << 16)) | (((this71 >> 8) & 255) << 8)) | ((this71 >> 16) & 255));
            															}
            															else {
HXLINE( 200)																old1 = this71;
            															}
HXDLIN( 200)															int rhs1 = ((((a14 << 24) | (r7 << 16)) | (g7 << 8)) | b18);
HXDLIN( 200)															Float a15;
HXDLIN( 200)															int this72 = ((old1 >> 24) & 255);
HXDLIN( 200)															if ((this72 == 0)) {
HXLINE( 200)																a15 = ((Float)0.);
            															}
            															else {
HXLINE( 200)																a15 = (( (Float)(this72) ) / ( (Float)(255) ));
            															}
HXDLIN( 200)															Float r14;
HXDLIN( 200)															int this73 = ((old1 >> 16) & 255);
HXDLIN( 200)															if ((this73 == 0)) {
HXLINE( 200)																r14 = ((Float)0.);
            															}
            															else {
HXLINE( 200)																r14 = (( (Float)(this73) ) / ( (Float)(255) ));
            															}
HXDLIN( 200)															Float g14;
HXDLIN( 200)															int this74 = ((old1 >> 8) & 255);
HXDLIN( 200)															if ((this74 == 0)) {
HXLINE( 200)																g14 = ((Float)0.);
            															}
            															else {
HXLINE( 200)																g14 = (( (Float)(this74) ) / ( (Float)(255) ));
            															}
HXDLIN( 200)															Float b19;
HXDLIN( 200)															int this75 = (old1 & 255);
HXDLIN( 200)															if ((this75 == 0)) {
HXLINE( 200)																b19 = ((Float)0.);
            															}
            															else {
HXLINE( 200)																b19 = (( (Float)(this75) ) / ( (Float)(255) ));
            															}
HXDLIN( 200)															Float a24;
HXDLIN( 200)															int this76 = ((rhs1 >> 24) & 255);
HXDLIN( 200)															if ((this76 == 0)) {
HXLINE( 200)																a24 = ((Float)0.);
            															}
            															else {
HXLINE( 200)																a24 = (( (Float)(this76) ) / ( (Float)(255) ));
            															}
HXDLIN( 200)															Float r24;
HXDLIN( 200)															int this77 = ((rhs1 >> 16) & 255);
HXDLIN( 200)															if ((this77 == 0)) {
HXLINE( 200)																r24 = ((Float)0.);
            															}
            															else {
HXLINE( 200)																r24 = (( (Float)(this77) ) / ( (Float)(255) ));
            															}
HXDLIN( 200)															Float g24;
HXDLIN( 200)															int this78 = ((rhs1 >> 8) & 255);
HXDLIN( 200)															if ((this78 == 0)) {
HXLINE( 200)																g24 = ((Float)0.);
            															}
            															else {
HXLINE( 200)																g24 = (( (Float)(this78) ) / ( (Float)(255) ));
            															}
HXDLIN( 200)															Float b25;
HXDLIN( 200)															int this79 = (rhs1 & 255);
HXDLIN( 200)															if ((this79 == 0)) {
HXLINE( 200)																b25 = ((Float)0.);
            															}
            															else {
HXLINE( 200)																b25 = (( (Float)(this79) ) / ( (Float)(255) ));
            															}
HXDLIN( 200)															Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 200)															int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 200)															int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 200)															int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a34) + (b25 * a24))));
HXDLIN( 200)															int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 200)															int blended4 = ((((a16 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 200)															{
HXLINE( 200)																int _hx_tmp20;
HXDLIN( 200)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 200)																	_hx_tmp20 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            																}
            																else {
HXLINE( 200)																	_hx_tmp20 = blended4;
            																}
HXDLIN( 200)																::iterMagic::Iimg_obj::set(this48->image,location4,_hx_tmp20);
            															}
            														}
            														else {
HXLINE( 200)															int value1;
HXDLIN( 200)															if (this48->isLittle) {
HXLINE( 200)																value1 = ((((a14 << 24) | (b18 << 16)) | (g7 << 8)) | r7);
            															}
            															else {
HXLINE( 200)																value1 = ((((a14 << 24) | (r7 << 16)) | (g7 << 8)) | b18);
            															}
HXDLIN( 200)															::iterMagic::Iimg_obj::set(this48->image,location4,value1);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 200)								if ((hasHit1 == false)) {
HXLINE( 200)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,mx,my,lastX,lastY,nextX1,nextY1,true);
HXDLIN( 200)									if (hasUndo1) {
HXLINE( 200)										v6->undoImage = undoImage3;
HXDLIN( 200)										v6->undoX = xIter31->start;
HXDLIN( 200)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
HXLINE( 244)						lastX = nextX1;
HXLINE( 245)						lastY = nextY1;
            					}
            				}
            			}
            		}
HXLINE( 204)		{
HXLINE( 204)			int x9 = ::Std_obj::_hx_int(x);
HXDLIN( 204)			int y9 = ::Std_obj::_hx_int(y);
HXDLIN( 204)			bool forceClear2 = false;
HXDLIN( 204)			{
HXLINE( 204)				int _g60 = 0;
HXDLIN( 204)				int _g61 = temp->height;
HXDLIN( 204)				while((_g60 < _g61)){
HXLINE( 204)					_g60 = (_g60 + 1);
HXDLIN( 204)					int dy2 = (_g60 - 1);
HXDLIN( 204)					{
HXLINE( 204)						int _g62 = 0;
HXDLIN( 204)						int _g63 = temp->width;
HXDLIN( 204)						while((_g62 < _g63)){
HXLINE( 204)							_g62 = (_g62 + 1);
HXDLIN( 204)							int dx2 = (_g62 - 1);
HXDLIN( 204)							::Dynamic this80 = temp->image;
HXDLIN( 204)							int index9;
HXDLIN( 204)							if (temp->useVirtualPos) {
HXLINE( 204)								index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx2) - temp->virtualX));
            							}
            							else {
HXLINE( 204)								index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * temp->width) + dx2)) ));
            							}
HXDLIN( 204)							int c7 = ::iterMagic::Iimg_obj::get(this80,index9);
HXDLIN( 204)							int col2;
HXDLIN( 204)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 204)								col2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            							}
            							else {
HXLINE( 204)								col2 = c7;
            							}
HXDLIN( 204)							bool _hx_tmp21;
HXDLIN( 204)							if (temp->useMask) {
HXLINE( 204)								_hx_tmp21 = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE( 204)								_hx_tmp21 = false;
            							}
HXDLIN( 204)							if (_hx_tmp21) {
HXLINE( 204)								 ::pi_xy::ImageStruct this81 = temp->mask;
HXDLIN( 204)								::Dynamic this82 = this81->image;
HXDLIN( 204)								int index10;
HXDLIN( 204)								if (this81->useVirtualPos) {
HXLINE( 204)									index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this81->virtualY) * ( (Float)(this81->width) )) + dx2) - this81->virtualX));
            								}
            								else {
HXLINE( 204)									index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this81->width) + dx2)) ));
            								}
HXDLIN( 204)								int c8 = ::iterMagic::Iimg_obj::get(this82,index10);
HXDLIN( 204)								int v7;
HXDLIN( 204)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 204)									v7 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            								}
            								else {
HXLINE( 204)									v7 = c8;
            								}
HXDLIN( 204)								int maskPixel2 = v7;
HXDLIN( 204)								int this83 = col2;
HXDLIN( 204)								if ((maskPixel2 == 0)) {
HXLINE( 204)									col2 = this83;
            								}
            								else {
HXLINE( 204)									Float m02;
HXDLIN( 204)									int this84 = ((maskPixel2 >> 24) & 255);
HXDLIN( 204)									if ((this84 == 0)) {
HXLINE( 204)										m02 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										m02 = (( (Float)(this84) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float m12;
HXDLIN( 204)									int this85 = ((maskPixel2 >> 16) & 255);
HXDLIN( 204)									if ((this85 == 0)) {
HXLINE( 204)										m12 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										m12 = (( (Float)(this85) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float m22;
HXDLIN( 204)									int this86 = ((maskPixel2 >> 8) & 255);
HXDLIN( 204)									if ((this86 == 0)) {
HXLINE( 204)										m22 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										m22 = (( (Float)(this86) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float m32;
HXDLIN( 204)									int this87 = (maskPixel2 & 255);
HXDLIN( 204)									if ((this87 == 0)) {
HXLINE( 204)										m32 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										m32 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this83 >> 24) & 255)) )));
HXDLIN( 204)									int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this83 >> 16) & 255)) )));
HXDLIN( 204)									int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this83 >> 8) & 255)) )));
HXDLIN( 204)									int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this83 & 255)) )));
HXDLIN( 204)									col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 204)							if ((col2 != 0)) {
HXLINE( 204)								int x10 = (x9 + dx2);
HXDLIN( 204)								int y10 = (y9 + dy2);
HXDLIN( 204)								int c9 = col2;
HXDLIN( 204)								bool _hx_tmp22;
HXDLIN( 204)								if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 204)									_hx_tmp22 = this1->transparent;
            								}
            								else {
HXLINE( 204)									_hx_tmp22 = false;
            								}
HXDLIN( 204)								if (_hx_tmp22) {
HXLINE( 204)									int location5;
HXDLIN( 204)									if (this1->useVirtualPos) {
HXLINE( 204)										location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x10) - this1->virtualX));
            									}
            									else {
HXLINE( 204)										location5 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x10)) ));
            									}
HXDLIN( 204)									int this88 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 204)									int this89;
HXDLIN( 204)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 204)										this89 = ((((((this88 >> 24) & 255) << 24) | ((this88 & 255) << 16)) | (((this88 >> 8) & 255) << 8)) | ((this88 >> 16) & 255));
            									}
            									else {
HXLINE( 204)										this89 = this88;
            									}
HXDLIN( 204)									Float a17;
HXDLIN( 204)									int this90 = ((this89 >> 24) & 255);
HXDLIN( 204)									if ((this90 == 0)) {
HXLINE( 204)										a17 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										a17 = (( (Float)(this90) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float r15;
HXDLIN( 204)									int this91 = ((this89 >> 16) & 255);
HXDLIN( 204)									if ((this91 == 0)) {
HXLINE( 204)										r15 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										r15 = (( (Float)(this91) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float g15;
HXDLIN( 204)									int this92 = ((this89 >> 8) & 255);
HXDLIN( 204)									if ((this92 == 0)) {
HXLINE( 204)										g15 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										g15 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float b110;
HXDLIN( 204)									int this93 = (this89 & 255);
HXDLIN( 204)									if ((this93 == 0)) {
HXLINE( 204)										b110 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										b110 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float a25;
HXDLIN( 204)									int this94 = ((col2 >> 24) & 255);
HXDLIN( 204)									if ((this94 == 0)) {
HXLINE( 204)										a25 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										a25 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float r25;
HXDLIN( 204)									int this95 = ((col2 >> 16) & 255);
HXDLIN( 204)									if ((this95 == 0)) {
HXLINE( 204)										r25 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										r25 = (( (Float)(this95) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float g25;
HXDLIN( 204)									int this96 = ((col2 >> 8) & 255);
HXDLIN( 204)									if ((this96 == 0)) {
HXLINE( 204)										g25 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										g25 = (( (Float)(this96) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float b26;
HXDLIN( 204)									int this97 = (col2 & 255);
HXDLIN( 204)									if ((this97 == 0)) {
HXLINE( 204)										b26 = ((Float)0.);
            									}
            									else {
HXLINE( 204)										b26 = (( (Float)(this97) ) / ( (Float)(255) ));
            									}
HXDLIN( 204)									Float a35 = (a17 * (( (Float)(1) ) - a25));
HXDLIN( 204)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 204)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 204)									int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a35) + (b26 * a25))));
HXDLIN( 204)									int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 204)									int blended5 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b27);
HXDLIN( 204)									{
HXLINE( 204)										int _hx_tmp23;
HXDLIN( 204)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 204)											_hx_tmp23 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXLINE( 204)											_hx_tmp23 = blended5;
            										}
HXDLIN( 204)										::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp23);
            									}
            								}
            								else {
HXLINE( 204)									::Dynamic this98 = this1->image;
HXDLIN( 204)									int index11;
HXDLIN( 204)									if (this1->useVirtualPos) {
HXLINE( 204)										index11 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x10) - this1->virtualX));
            									}
            									else {
HXLINE( 204)										index11 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x10)) ));
            									}
HXDLIN( 204)									int _hx_tmp24;
HXDLIN( 204)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 204)										_hx_tmp24 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            									}
            									else {
HXLINE( 204)										_hx_tmp24 = c9;
            									}
HXDLIN( 204)									::iterMagic::Iimg_obj::set(this98,index11,_hx_tmp24);
            								}
            							}
            							else {
HXLINE( 204)								if (forceClear2) {
HXLINE( 204)									::Dynamic this99 = this1->image;
HXDLIN( 204)									int x11 = (x9 + dx2);
HXDLIN( 204)									int y11 = (y9 + dy2);
HXDLIN( 204)									int index12;
HXDLIN( 204)									if (this1->useVirtualPos) {
HXLINE( 204)										index12 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            									}
            									else {
HXLINE( 204)										index12 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            									}
HXDLIN( 204)									::iterMagic::Iimg_obj::set(this99,index12,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 205)		temp = null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(GradientShape_Impl__obj,radialRectangle,(void))

 ::pi_xy::algo::HitTriArray GradientShape_Impl__obj::thickArrow( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float thick,int color1,int color2,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< bool >  __o_hasHit){
            		bool flare = __o_flare.Default(false);
            		bool reverseFlare = __o_reverseFlare.Default(false);
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_218_thickArrow)
HXDLIN( 218)		Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 218)		Float o = (qy - py);
HXDLIN( 218)		Float a = (qx - px);
HXDLIN( 218)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 218)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 218)		Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN( 218)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 218)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 218)		Float radius = (thick / ( (Float)(2) ));
HXDLIN( 218)		Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 218)		Float h2 = (h / goldenRatio);
HXDLIN( 218)		 ::pi_xy::algo::HitQuad hitQuad;
HXDLIN( 218)		if (flare) {
HXDLIN( 218)			if (reverseFlare) {
HXDLIN( 218)				Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 218)				Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 218)				Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 218)				Float radius21 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN( 218)				Float dx = ((Float)0.1);
HXDLIN( 218)				Float dy = radius1;
HXDLIN( 218)				Float cx = h2;
HXDLIN( 218)				Float cy = radius21;
HXDLIN( 218)				Float bx = h2;
HXDLIN( 218)				Float by = -(radius21);
HXDLIN( 218)				Float ax = ((Float)0.1);
HXDLIN( 218)				Float ay = -(radius1);
HXDLIN( 218)				Float temp = ((Float)0.);
HXLINE( 525)				temp = (px + ((ax * cos1) - (ay * sin1)));
HXLINE( 526)				ay = (py + ((ay * cos1) + (ax * sin1)));
HXLINE( 527)				ax = temp;
HXLINE( 529)				temp = (px + ((bx * cos1) - (by * sin1)));
HXLINE( 530)				by = (py + ((by * cos1) + (bx * sin1)));
HXLINE( 531)				bx = temp;
HXLINE( 533)				temp = (px + ((cx * cos1) - (cy * sin1)));
HXLINE( 534)				cy = (py + ((cy * cos1) + (cx * sin1)));
HXLINE( 535)				cx = temp;
HXLINE( 537)				temp = (px + ((dx * cos1) - (dy * sin1)));
HXLINE( 538)				dy = (py + ((dy * cos1) + (dx * sin1)));
HXLINE( 539)				dx = temp;
HXLINE( 218)				{
HXDLIN( 218)					bool hasUndo = false;
HXDLIN( 218)					int aA = ((color1 >> 24) & 255);
HXDLIN( 218)					int rA = ((color1 >> 16) & 255);
HXDLIN( 218)					int gA = ((color1 >> 8) & 255);
HXDLIN( 218)					int bA = (color1 & 255);
HXDLIN( 218)					int aB = ((color1 >> 24) & 255);
HXDLIN( 218)					int rB = ((color1 >> 16) & 255);
HXDLIN( 218)					int gB = ((color1 >> 8) & 255);
HXDLIN( 218)					int bB = (color1 & 255);
HXDLIN( 218)					int aC = ((color2 >> 24) & 255);
HXDLIN( 218)					int rC = ((color2 >> 16) & 255);
HXDLIN( 218)					int gC = ((color2 >> 8) & 255);
HXDLIN( 218)					int bC = (color2 & 255);
HXDLIN( 218)					Float bcx = (bx - dx);
HXDLIN( 218)					Float bcy = (by - dy);
HXDLIN( 218)					Float acx = (ax - dx);
HXDLIN( 218)					Float acy = (ay - dy);
HXDLIN( 218)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 218)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 218)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 218)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 218)					 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 218)					if ((ax > bx)) {
HXDLIN( 218)						if ((ax > dx)) {
HXDLIN( 218)							int min;
HXDLIN( 218)							if ((bx > dx)) {
HXDLIN( 218)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXDLIN( 218)								min = ::Math_obj::floor(bx);
            							}
HXDLIN( 218)							int ii_min = min;
HXDLIN( 218)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 218)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXDLIN( 218)							int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 218)							int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 218)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            						}
            					}
            					else {
HXDLIN( 218)						if ((bx > dx)) {
HXDLIN( 218)							int min1;
HXDLIN( 218)							if ((ax > dx)) {
HXDLIN( 218)								min1 = ::Math_obj::floor(dx);
            							}
            							else {
HXDLIN( 218)								min1 = ::Math_obj::ceil(ax);
            							}
HXDLIN( 218)							int ii_min2 = min1;
HXDLIN( 218)							int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 218)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            						}
            						else {
HXDLIN( 218)							int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 218)							int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 218)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            					}
HXDLIN( 218)					 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 218)					if ((ay > by)) {
HXDLIN( 218)						if ((ay > dy)) {
HXDLIN( 218)							int min2;
HXDLIN( 218)							if ((by > dy)) {
HXDLIN( 218)								min2 = ::Math_obj::floor(dy);
            							}
            							else {
HXDLIN( 218)								min2 = ::Math_obj::floor(by);
            							}
HXDLIN( 218)							int ii_min4 = min2;
HXDLIN( 218)							int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 218)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
            						else {
HXDLIN( 218)							int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 218)							int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 218)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            						}
            					}
            					else {
HXDLIN( 218)						if ((by > dy)) {
HXDLIN( 218)							int min3;
HXDLIN( 218)							if ((ay > dy)) {
HXDLIN( 218)								min3 = ::Math_obj::floor(dy);
            							}
            							else {
HXDLIN( 218)								min3 = ::Math_obj::ceil(ay);
            							}
HXDLIN( 218)							int ii_min6 = min3;
HXDLIN( 218)							int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 218)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            						}
            						else {
HXDLIN( 218)							int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 218)							int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 218)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            						}
            					}
HXDLIN( 218)					 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 218)					if (hasUndo) {
HXDLIN( 218)						int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 218)						int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 218)						 ::Dynamic imageType = null();
HXDLIN( 218)						 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 218)						if (::hx::IsNull( imageType )) {
HXLINE(  54)							imageType = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 218)						::Dynamic undoImage1;
HXDLIN( 218)						switch((int)(( (int)(imageType) ))){
            							case (int)0: {
HXDLIN( 218)								 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::BytesImg b = byt;
HXDLIN( 218)								{
HXDLIN( 218)									b->width = width;
HXDLIN( 218)									b->height = height;
HXDLIN( 218)									b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 218)									b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 218)									{
HXDLIN( 218)										int len = b->length;
HXDLIN( 218)										int w = 0;
HXDLIN( 218)										{
HXDLIN( 218)											int _g = 0;
HXDLIN( 218)											int _g1 = b->height;
HXDLIN( 218)											while((_g < _g1)){
HXDLIN( 218)												_g = (_g + 1);
HXDLIN( 218)												int y = (_g - 1);
HXDLIN( 218)												{
HXDLIN( 218)													int _g2 = 0;
HXDLIN( 218)													int _g3 = b->width;
HXDLIN( 218)													while((_g2 < _g3)){
HXDLIN( 218)														_g2 = (_g2 + 1);
HXDLIN( 218)														int x = (_g2 - 1);
HXDLIN( 218)														{
HXDLIN( 218)															w = (w + 1);
HXDLIN( 218)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w = (w + 1);
HXDLIN( 218)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w = (w + 1);
HXDLIN( 218)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w = (w + 1);
HXDLIN( 218)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage1 = b;
            							}
            							break;
            							case (int)1: {
HXDLIN( 218)								 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 218)								{
HXDLIN( 218)									a1->width = width;
HXDLIN( 218)									a1->height = height;
HXDLIN( 218)									a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 218)									a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 218)									{
HXDLIN( 218)										int _g4 = 0;
HXDLIN( 218)										int _g5 = a1->length;
HXDLIN( 218)										while((_g4 < _g5)){
HXDLIN( 218)											_g4 = (_g4 + 1);
HXDLIN( 218)											int i = (_g4 - 1);
HXDLIN( 218)											a1->data[i] = 0;
            										}
            									}
            								}
HXDLIN( 218)								undoImage1 = a1;
            							}
            							break;
            							case (int)2: {
HXDLIN( 218)								 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 218)								{
HXDLIN( 218)									b1->width = width;
HXDLIN( 218)									b1->height = height;
HXDLIN( 218)									b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 218)									int size = (b1->length * 4);
HXDLIN( 218)									b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 218)									{
HXDLIN( 218)										int _g6 = 0;
HXDLIN( 218)										int _g7 = b1->length;
HXDLIN( 218)										while((_g6 < _g7)){
HXDLIN( 218)											_g6 = (_g6 + 1);
HXDLIN( 218)											int i1 = (_g6 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 218)												bool undoImage2;
HXDLIN( 218)												if ((i1 >= 0)) {
HXDLIN( 218)													undoImage2 = (i1 < (this3->byteLength >> 2));
            												}
            												else {
HXDLIN( 218)													undoImage2 = false;
            												}
HXDLIN( 218)												if (undoImage2) {
HXDLIN( 218)													 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 218)													int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 218)													_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 218)													_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 218)													_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 218)													_this->b[(pos + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage1 = b1;
            							}
            							break;
            							case (int)3: {
HXDLIN( 218)								 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::VecIntImg v = vec;
HXDLIN( 218)								{
HXDLIN( 218)									v->width = width;
HXDLIN( 218)									v->height = height;
HXDLIN( 218)									v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 218)									v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 218)									{
HXDLIN( 218)										int _g8 = 0;
HXDLIN( 218)										int _g9 = v->length;
HXDLIN( 218)										while((_g8 < _g9)){
HXDLIN( 218)											_g8 = (_g8 + 1);
HXDLIN( 218)											int i2 = (_g8 - 1);
HXDLIN( 218)											v->data->__unsafe_set(i2,0);
            										}
            									}
            								}
HXDLIN( 218)								undoImage1 = v;
            							}
            							break;
            							case (int)4: {
HXDLIN( 218)								 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 218)								{
HXDLIN( 218)									b2->width = width;
HXDLIN( 218)									b2->height = height;
HXDLIN( 218)									b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 218)									b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 218)									{
HXDLIN( 218)										int len1 = b2->length;
HXDLIN( 218)										 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 218)										if (::hx::IsNull( d->head )) {
HXDLIN( 218)											int _g10 = 0;
HXDLIN( 218)											int _g11 = len1;
HXDLIN( 218)											while((_g10 < _g11)){
HXDLIN( 218)												_g10 = (_g10 + 1);
HXDLIN( 218)												int i3 = (_g10 - 1);
HXDLIN( 218)												d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            											}
            										}
            										else {
HXDLIN( 218)											int _g12 = 0;
HXDLIN( 218)											int _g13 = len1;
HXDLIN( 218)											while((_g12 < _g13)){
HXDLIN( 218)												_g12 = (_g12 + 1);
HXDLIN( 218)												int i4 = (_g12 - 1);
HXDLIN( 218)												{
HXDLIN( 218)													 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 218)													 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 218)													{
HXDLIN( 218)														int _g14 = 0;
HXDLIN( 218)														int _g15 = i4;
HXDLIN( 218)														while((_g14 < _g15)){
HXDLIN( 218)															_g14 = (_g14 + 1);
HXDLIN( 218)															int i5 = (_g14 - 1);
HXLINE( 345)															prev = l;
HXLINE( 346)															l = l->next;
            														}
            													}
HXLINE( 218)													if (::hx::IsNull( prev )) {
HXDLIN( 218)														b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 218)														l = null();
            													}
            													else {
HXDLIN( 218)														prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 218)														l = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage1 = b2;
            							}
            							break;
            						}
HXDLIN( 218)						this2->image = undoImage1;
HXDLIN( 218)						this2->width = width;
HXDLIN( 218)						this2->height = height;
HXDLIN( 218)						this2->imageType = ( (int)(imageType) );
HXDLIN( 218)						undoImage = this2;
HXDLIN( 218)						{
HXDLIN( 218)							int rectLeft = xIter3->start;
HXDLIN( 218)							int rectTop = yIter3->start;
HXDLIN( 218)							int rectRight = xIter3->max;
HXDLIN( 218)							bool forceClear = false;
HXDLIN( 218)							{
HXDLIN( 218)								int _g16 = rectTop;
HXDLIN( 218)								int _g17 = yIter3->max;
HXDLIN( 218)								while((_g16 < _g17)){
HXDLIN( 218)									_g16 = (_g16 + 1);
HXDLIN( 218)									int dy1 = (_g16 - 1);
HXDLIN( 218)									{
HXDLIN( 218)										int _g18 = rectLeft;
HXDLIN( 218)										int _g19 = rectRight;
HXDLIN( 218)										while((_g18 < _g19)){
HXDLIN( 218)											_g18 = (_g18 + 1);
HXDLIN( 218)											int dx1 = (_g18 - 1);
HXDLIN( 218)											::Dynamic this4 = this1->image;
HXDLIN( 218)											int index;
HXDLIN( 218)											if (this1->useVirtualPos) {
HXDLIN( 218)												index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            											}
            											else {
HXDLIN( 218)												index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            											}
HXDLIN( 218)											int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 218)											int col;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												col = c;
            											}
HXDLIN( 218)											bool hitQuad1;
HXDLIN( 218)											if (this1->useMask) {
HXDLIN( 218)												hitQuad1 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXDLIN( 218)												hitQuad1 = false;
            											}
HXDLIN( 218)											if (hitQuad1) {
HXDLIN( 218)												 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 218)												::Dynamic this6 = this5->image;
HXDLIN( 218)												int index1;
HXDLIN( 218)												if (this5->useVirtualPos) {
HXDLIN( 218)													index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            												}
            												else {
HXDLIN( 218)													index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            												}
HXDLIN( 218)												int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 218)												int v1;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													v1 = c1;
            												}
HXDLIN( 218)												int maskPixel = v1;
HXDLIN( 218)												int this7 = col;
HXDLIN( 218)												if ((maskPixel == 0)) {
HXDLIN( 218)													col = this7;
            												}
            												else {
HXDLIN( 218)													Float m0;
HXDLIN( 218)													int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 218)													if ((this8 == 0)) {
HXDLIN( 218)														m0 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m1;
HXDLIN( 218)													int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 218)													if ((this9 == 0)) {
HXDLIN( 218)														m1 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m2;
HXDLIN( 218)													int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 218)													if ((this10 == 0)) {
HXDLIN( 218)														m2 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m3;
HXDLIN( 218)													int this11 = (maskPixel & 255);
HXDLIN( 218)													if ((this11 == 0)) {
HXDLIN( 218)														m3 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 218)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 218)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 218)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 218)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 218)											if ((col != 0)) {
HXDLIN( 218)												int x1 = (dx1 - rectLeft);
HXDLIN( 218)												int y1 = (dy1 - rectTop);
HXDLIN( 218)												int c2 = col;
HXDLIN( 218)												bool hitQuad2;
HXDLIN( 218)												if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 218)													hitQuad2 = undoImage->transparent;
            												}
            												else {
HXDLIN( 218)													hitQuad2 = false;
            												}
HXDLIN( 218)												if (hitQuad2) {
HXDLIN( 218)													int location;
HXDLIN( 218)													if (undoImage->useVirtualPos) {
HXDLIN( 218)														location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            													}
            													else {
HXDLIN( 218)														location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            													}
HXDLIN( 218)													int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 218)													int this13;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														this13 = this12;
            													}
HXDLIN( 218)													Float a11;
HXDLIN( 218)													int this14 = ((this13 >> 24) & 255);
HXDLIN( 218)													if ((this14 == 0)) {
HXDLIN( 218)														a11 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float r1;
HXDLIN( 218)													int this15 = ((this13 >> 16) & 255);
HXDLIN( 218)													if ((this15 == 0)) {
HXDLIN( 218)														r1 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float g1;
HXDLIN( 218)													int this16 = ((this13 >> 8) & 255);
HXDLIN( 218)													if ((this16 == 0)) {
HXDLIN( 218)														g1 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float b11;
HXDLIN( 218)													int this17 = (this13 & 255);
HXDLIN( 218)													if ((this17 == 0)) {
HXDLIN( 218)														b11 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float a2;
HXDLIN( 218)													int this18 = ((col >> 24) & 255);
HXDLIN( 218)													if ((this18 == 0)) {
HXDLIN( 218)														a2 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float r2;
HXDLIN( 218)													int this19 = ((col >> 16) & 255);
HXDLIN( 218)													if ((this19 == 0)) {
HXDLIN( 218)														r2 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float g2;
HXDLIN( 218)													int this20 = ((col >> 8) & 255);
HXDLIN( 218)													if ((this20 == 0)) {
HXDLIN( 218)														g2 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float b21;
HXDLIN( 218)													int this21 = (col & 255);
HXDLIN( 218)													if ((this21 == 0)) {
HXDLIN( 218)														b21 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 218)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 218)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 218)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 218)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 218)													int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 218)													{
HXDLIN( 218)														int hitQuad3;
HXDLIN( 218)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)															hitQuad3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXDLIN( 218)															hitQuad3 = blended;
            														}
HXDLIN( 218)														::iterMagic::Iimg_obj::set(undoImage->image,location,hitQuad3);
            													}
            												}
            												else {
HXDLIN( 218)													::Dynamic this22 = undoImage->image;
HXDLIN( 218)													int index2;
HXDLIN( 218)													if (undoImage->useVirtualPos) {
HXDLIN( 218)														index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            													}
            													else {
HXDLIN( 218)														index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            													}
HXDLIN( 218)													int hitQuad4;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad4 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad4 = c2;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this22,index2,hitQuad4);
            												}
            											}
            											else {
HXDLIN( 218)												if (forceClear) {
HXDLIN( 218)													::Dynamic this23 = undoImage->image;
HXDLIN( 218)													int x2 = (dx1 - rectLeft);
HXDLIN( 218)													int y2 = (dy1 - rectTop);
HXDLIN( 218)													int index3;
HXDLIN( 218)													if (undoImage->useVirtualPos) {
HXDLIN( 218)														index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            													}
            													else {
HXDLIN( 218)														index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this23,index3,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					{
HXDLIN( 218)						int _g_min = xIter3->start;
HXDLIN( 218)						int _g_max = xIter3->max;
HXDLIN( 218)						while((_g_min < _g_max)){
HXDLIN( 218)							_g_min = (_g_min + 1);
HXDLIN( 218)							int px1 = (_g_min - 1);
HXDLIN( 218)							Float pcx = (( (Float)(px1) ) - dx);
HXDLIN( 218)							{
HXDLIN( 218)								int _g_min1 = yIter3->start;
HXDLIN( 218)								int _g_max1 = yIter3->max;
HXDLIN( 218)								while((_g_min1 < _g_max1)){
HXDLIN( 218)									_g_min1 = (_g_min1 + 1);
HXDLIN( 218)									int py1 = (_g_min1 - 1);
HXDLIN( 218)									Float pcy = (( (Float)(py1) ) - dy);
HXDLIN( 218)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 218)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 218)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 218)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 218)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 218)									bool hitQuad5;
HXDLIN( 218)									bool hitQuad6;
HXDLIN( 218)									if ((ratioA >= 0)) {
HXDLIN( 218)										hitQuad6 = (ratioB >= 0);
            									}
            									else {
HXDLIN( 218)										hitQuad6 = false;
            									}
HXDLIN( 218)									if (hitQuad6) {
HXDLIN( 218)										hitQuad5 = (ratioC >= 0);
            									}
            									else {
HXDLIN( 218)										hitQuad5 = false;
            									}
HXDLIN( 218)									if (hitQuad5) {
HXDLIN( 218)										int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 218)										if ((i6 > 255)) {
HXLINE(  24)											i6 = 255;
            										}
HXLINE( 218)										if ((i6 < 0)) {
HXLINE(  25)											i6 = 0;
            										}
HXLINE( 218)										int a5 = i6;
HXDLIN( 218)										int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 218)										if ((i7 > 255)) {
HXLINE(  24)											i7 = 255;
            										}
HXLINE( 218)										if ((i7 < 0)) {
HXLINE(  25)											i7 = 0;
            										}
HXLINE( 218)										int r3 = i7;
HXDLIN( 218)										int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 218)										if ((i8 > 255)) {
HXLINE(  24)											i8 = 255;
            										}
HXLINE( 218)										if ((i8 < 0)) {
HXLINE(  25)											i8 = 0;
            										}
HXLINE( 218)										int g3 = i8;
HXDLIN( 218)										int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 218)										if ((i9 > 255)) {
HXLINE(  24)											i9 = 255;
            										}
HXLINE( 218)										if ((i9 < 0)) {
HXLINE(  25)											i9 = 0;
            										}
HXLINE( 218)										int b4 = i9;
HXDLIN( 218)										{
HXDLIN( 218)											int location1;
HXDLIN( 218)											if (this1->useVirtualPos) {
HXDLIN( 218)												location1 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this1->virtualY) * ( (Float)(this1->width) )) + px1) - this1->virtualX));
            											}
            											else {
HXDLIN( 218)												location1 = ::Std_obj::_hx_int(( (Float)(((py1 * this1->width) + px1)) ));
            											}
HXDLIN( 218)											bool hitQuad7;
HXDLIN( 218)											if (this1->transparent) {
HXDLIN( 218)												hitQuad7 = (a5 < 254);
            											}
            											else {
HXDLIN( 218)												hitQuad7 = false;
            											}
HXDLIN( 218)											if (hitQuad7) {
HXDLIN( 218)												int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 218)												int old;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													old = this24;
            												}
HXDLIN( 218)												int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 218)												Float a12;
HXDLIN( 218)												int this25 = ((old >> 24) & 255);
HXDLIN( 218)												if ((this25 == 0)) {
HXDLIN( 218)													a12 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a12 = (( (Float)(this25) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r11;
HXDLIN( 218)												int this26 = ((old >> 16) & 255);
HXDLIN( 218)												if ((this26 == 0)) {
HXDLIN( 218)													r11 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g11;
HXDLIN( 218)												int this27 = ((old >> 8) & 255);
HXDLIN( 218)												if ((this27 == 0)) {
HXDLIN( 218)													g11 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b12;
HXDLIN( 218)												int this28 = (old & 255);
HXDLIN( 218)												if ((this28 == 0)) {
HXDLIN( 218)													b12 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a21;
HXDLIN( 218)												int this29 = ((rhs >> 24) & 255);
HXDLIN( 218)												if ((this29 == 0)) {
HXDLIN( 218)													a21 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r21;
HXDLIN( 218)												int this30 = ((rhs >> 16) & 255);
HXDLIN( 218)												if ((this30 == 0)) {
HXDLIN( 218)													r21 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g21;
HXDLIN( 218)												int this31 = ((rhs >> 8) & 255);
HXDLIN( 218)												if ((this31 == 0)) {
HXDLIN( 218)													g21 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b22;
HXDLIN( 218)												int this32 = (rhs & 255);
HXDLIN( 218)												if ((this32 == 0)) {
HXDLIN( 218)													b22 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 218)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 218)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 218)												int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 218)												int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 218)												int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 218)												{
HXDLIN( 218)													int hitQuad8;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad8 = blended1;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this1->image,location1,hitQuad8);
            												}
            											}
            											else {
HXDLIN( 218)												int value;
HXDLIN( 218)												if (this1->isLittle) {
HXDLIN( 218)													value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            												}
            												else {
HXDLIN( 218)													value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this1->image,location1,value);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 218)				{
HXDLIN( 218)					bool hasHit1 = false;
HXDLIN( 218)					bool hasUndo1 = false;
HXDLIN( 218)					int aA1 = ((color2 >> 24) & 255);
HXDLIN( 218)					int rA1 = ((color2 >> 16) & 255);
HXDLIN( 218)					int gA1 = ((color2 >> 8) & 255);
HXDLIN( 218)					int bA1 = (color2 & 255);
HXDLIN( 218)					int aB1 = ((color1 >> 24) & 255);
HXDLIN( 218)					int rB1 = ((color1 >> 16) & 255);
HXDLIN( 218)					int gB1 = ((color1 >> 8) & 255);
HXDLIN( 218)					int bB1 = (color1 & 255);
HXDLIN( 218)					int aC1 = ((color2 >> 24) & 255);
HXDLIN( 218)					int rC1 = ((color2 >> 16) & 255);
HXDLIN( 218)					int gC1 = ((color2 >> 8) & 255);
HXDLIN( 218)					int bC1 = (color2 & 255);
HXDLIN( 218)					Float bcx1 = (cx - dx);
HXDLIN( 218)					Float bcy1 = (cy - dy);
HXDLIN( 218)					Float acx1 = (bx - dx);
HXDLIN( 218)					Float acy1 = (by - dy);
HXDLIN( 218)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 218)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 218)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 218)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 218)					 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 218)					if ((bx > cx)) {
HXDLIN( 218)						if ((bx > dx)) {
HXDLIN( 218)							int min4;
HXDLIN( 218)							if ((cx > dx)) {
HXDLIN( 218)								min4 = ::Math_obj::floor(dx);
            							}
            							else {
HXDLIN( 218)								min4 = ::Math_obj::floor(cx);
            							}
HXDLIN( 218)							int ii_min8 = min4;
HXDLIN( 218)							int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 218)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            						}
            						else {
HXDLIN( 218)							int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 218)							int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 218)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            						}
            					}
            					else {
HXDLIN( 218)						if ((cx > dx)) {
HXDLIN( 218)							int min5;
HXDLIN( 218)							if ((bx > dx)) {
HXDLIN( 218)								min5 = ::Math_obj::floor(dx);
            							}
            							else {
HXDLIN( 218)								min5 = ::Math_obj::ceil(bx);
            							}
HXDLIN( 218)							int ii_min10 = min5;
HXDLIN( 218)							int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 218)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXDLIN( 218)							int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 218)							int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 218)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
HXDLIN( 218)					 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 218)					if ((by > cy)) {
HXDLIN( 218)						if ((by > dy)) {
HXDLIN( 218)							int min6;
HXDLIN( 218)							if ((cy > dy)) {
HXDLIN( 218)								min6 = ::Math_obj::floor(dy);
            							}
            							else {
HXDLIN( 218)								min6 = ::Math_obj::floor(cy);
            							}
HXDLIN( 218)							int ii_min12 = min6;
HXDLIN( 218)							int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 218)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXDLIN( 218)							int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 218)							int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 218)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
            					else {
HXDLIN( 218)						if ((cy > dy)) {
HXDLIN( 218)							int min7;
HXDLIN( 218)							if ((by > dy)) {
HXDLIN( 218)								min7 = ::Math_obj::floor(dy);
            							}
            							else {
HXDLIN( 218)								min7 = ::Math_obj::ceil(by);
            							}
HXDLIN( 218)							int ii_min14 = min7;
HXDLIN( 218)							int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 218)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXDLIN( 218)							int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 218)							int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 218)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
HXDLIN( 218)					 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 218)					if (hasUndo1) {
HXDLIN( 218)						int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 218)						int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 218)						 ::Dynamic imageType1 = null();
HXDLIN( 218)						 ::pi_xy::ImageStruct this33 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 218)						if (::hx::IsNull( imageType1 )) {
HXLINE(  54)							imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 218)						::Dynamic undoImage4;
HXDLIN( 218)						switch((int)(( (int)(imageType1) ))){
            							case (int)0: {
HXDLIN( 218)								 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 218)								{
HXDLIN( 218)									b6->width = width1;
HXDLIN( 218)									b6->height = height1;
HXDLIN( 218)									b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 218)									b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 218)									{
HXDLIN( 218)										int len2 = b6->length;
HXDLIN( 218)										int w1 = 0;
HXDLIN( 218)										{
HXDLIN( 218)											int _g20 = 0;
HXDLIN( 218)											int _g21 = b6->height;
HXDLIN( 218)											while((_g20 < _g21)){
HXDLIN( 218)												_g20 = (_g20 + 1);
HXDLIN( 218)												int y3 = (_g20 - 1);
HXDLIN( 218)												{
HXDLIN( 218)													int _g22 = 0;
HXDLIN( 218)													int _g23 = b6->width;
HXDLIN( 218)													while((_g22 < _g23)){
HXDLIN( 218)														_g22 = (_g22 + 1);
HXDLIN( 218)														int x3 = (_g22 - 1);
HXDLIN( 218)														{
HXDLIN( 218)															w1 = (w1 + 1);
HXDLIN( 218)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w1 = (w1 + 1);
HXDLIN( 218)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w1 = (w1 + 1);
HXDLIN( 218)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w1 = (w1 + 1);
HXDLIN( 218)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage4 = b6;
            							}
            							break;
            							case (int)1: {
HXDLIN( 218)								 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 218)								{
HXDLIN( 218)									a7->width = width1;
HXDLIN( 218)									a7->height = height1;
HXDLIN( 218)									a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 218)									a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 218)									{
HXDLIN( 218)										int _g24 = 0;
HXDLIN( 218)										int _g25 = a7->length;
HXDLIN( 218)										while((_g24 < _g25)){
HXDLIN( 218)											_g24 = (_g24 + 1);
HXDLIN( 218)											int i10 = (_g24 - 1);
HXDLIN( 218)											a7->data[i10] = 0;
            										}
            									}
            								}
HXDLIN( 218)								undoImage4 = a7;
            							}
            							break;
            							case (int)2: {
HXDLIN( 218)								 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 218)								{
HXDLIN( 218)									b7->width = width1;
HXDLIN( 218)									b7->height = height1;
HXDLIN( 218)									b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 218)									int size1 = (b7->length * 4);
HXDLIN( 218)									b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 218)									{
HXDLIN( 218)										int _g26 = 0;
HXDLIN( 218)										int _g27 = b7->length;
HXDLIN( 218)										while((_g26 < _g27)){
HXDLIN( 218)											_g26 = (_g26 + 1);
HXDLIN( 218)											int i11 = (_g26 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												 ::haxe::io::ArrayBufferViewImpl this34 = b7->data;
HXDLIN( 218)												bool undoImage5;
HXDLIN( 218)												if ((i11 >= 0)) {
HXDLIN( 218)													undoImage5 = (i11 < (this34->byteLength >> 2));
            												}
            												else {
HXDLIN( 218)													undoImage5 = false;
            												}
HXDLIN( 218)												if (undoImage5) {
HXDLIN( 218)													 ::haxe::io::Bytes _this1 = this34->bytes;
HXDLIN( 218)													int pos1 = ((i11 << 2) + this34->byteOffset);
HXDLIN( 218)													_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 218)													_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 218)													_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 218)													_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage4 = b7;
            							}
            							break;
            							case (int)3: {
HXDLIN( 218)								 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 218)								{
HXDLIN( 218)									v2->width = width1;
HXDLIN( 218)									v2->height = height1;
HXDLIN( 218)									v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 218)									v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 218)									{
HXDLIN( 218)										int _g28 = 0;
HXDLIN( 218)										int _g29 = v2->length;
HXDLIN( 218)										while((_g28 < _g29)){
HXDLIN( 218)											_g28 = (_g28 + 1);
HXDLIN( 218)											int i12 = (_g28 - 1);
HXDLIN( 218)											v2->data->__unsafe_set(i12,0);
            										}
            									}
            								}
HXDLIN( 218)								undoImage4 = v2;
            							}
            							break;
            							case (int)4: {
HXDLIN( 218)								 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 218)								{
HXDLIN( 218)									b8->width = width1;
HXDLIN( 218)									b8->height = height1;
HXDLIN( 218)									b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 218)									b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 218)									{
HXDLIN( 218)										int len3 = b8->length;
HXDLIN( 218)										 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 218)										if (::hx::IsNull( d1->head )) {
HXDLIN( 218)											int _g30 = 0;
HXDLIN( 218)											int _g31 = len3;
HXDLIN( 218)											while((_g30 < _g31)){
HXDLIN( 218)												_g30 = (_g30 + 1);
HXDLIN( 218)												int i13 = (_g30 - 1);
HXDLIN( 218)												d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            											}
            										}
            										else {
HXDLIN( 218)											int _g32 = 0;
HXDLIN( 218)											int _g33 = len3;
HXDLIN( 218)											while((_g32 < _g33)){
HXDLIN( 218)												_g32 = (_g32 + 1);
HXDLIN( 218)												int i14 = (_g32 - 1);
HXDLIN( 218)												{
HXDLIN( 218)													 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 218)													 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 218)													{
HXDLIN( 218)														int _g34 = 0;
HXDLIN( 218)														int _g35 = i14;
HXDLIN( 218)														while((_g34 < _g35)){
HXDLIN( 218)															_g34 = (_g34 + 1);
HXDLIN( 218)															int i15 = (_g34 - 1);
HXLINE( 345)															prev1 = l1;
HXLINE( 346)															l1 = l1->next;
            														}
            													}
HXLINE( 218)													if (::hx::IsNull( prev1 )) {
HXDLIN( 218)														b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 218)														l1 = null();
            													}
            													else {
HXDLIN( 218)														prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 218)														l1 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage4 = b8;
            							}
            							break;
            						}
HXDLIN( 218)						this33->image = undoImage4;
HXDLIN( 218)						this33->width = width1;
HXDLIN( 218)						this33->height = height1;
HXDLIN( 218)						this33->imageType = ( (int)(imageType1) );
HXDLIN( 218)						undoImage3 = this33;
HXDLIN( 218)						{
HXDLIN( 218)							int rectLeft1 = xIter31->start;
HXDLIN( 218)							int rectTop1 = yIter31->start;
HXDLIN( 218)							int rectRight1 = xIter31->max;
HXDLIN( 218)							bool forceClear1 = false;
HXDLIN( 218)							{
HXDLIN( 218)								int _g36 = rectTop1;
HXDLIN( 218)								int _g37 = yIter31->max;
HXDLIN( 218)								while((_g36 < _g37)){
HXDLIN( 218)									_g36 = (_g36 + 1);
HXDLIN( 218)									int dy2 = (_g36 - 1);
HXDLIN( 218)									{
HXDLIN( 218)										int _g38 = rectLeft1;
HXDLIN( 218)										int _g39 = rectRight1;
HXDLIN( 218)										while((_g38 < _g39)){
HXDLIN( 218)											_g38 = (_g38 + 1);
HXDLIN( 218)											int dx2 = (_g38 - 1);
HXDLIN( 218)											::Dynamic this35 = this1->image;
HXDLIN( 218)											int index4;
HXDLIN( 218)											if (this1->useVirtualPos) {
HXDLIN( 218)												index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            											}
            											else {
HXDLIN( 218)												index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            											}
HXDLIN( 218)											int c3 = ::iterMagic::Iimg_obj::get(this35,index4);
HXDLIN( 218)											int col1;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												col1 = c3;
            											}
HXDLIN( 218)											bool hitQuad9;
HXDLIN( 218)											if (this1->useMask) {
HXDLIN( 218)												hitQuad9 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXDLIN( 218)												hitQuad9 = false;
            											}
HXDLIN( 218)											if (hitQuad9) {
HXDLIN( 218)												 ::pi_xy::ImageStruct this36 = this1->mask;
HXDLIN( 218)												::Dynamic this37 = this36->image;
HXDLIN( 218)												int index5;
HXDLIN( 218)												if (this36->useVirtualPos) {
HXDLIN( 218)													index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx2) - this36->virtualX));
            												}
            												else {
HXDLIN( 218)													index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this36->width) + dx2)) ));
            												}
HXDLIN( 218)												int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 218)												int v3;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													v3 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													v3 = c4;
            												}
HXDLIN( 218)												int maskPixel1 = v3;
HXDLIN( 218)												int this38 = col1;
HXDLIN( 218)												if ((maskPixel1 == 0)) {
HXDLIN( 218)													col1 = this38;
            												}
            												else {
HXDLIN( 218)													Float m01;
HXDLIN( 218)													int this39 = ((maskPixel1 >> 24) & 255);
HXDLIN( 218)													if ((this39 == 0)) {
HXDLIN( 218)														m01 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m01 = (( (Float)(this39) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m11;
HXDLIN( 218)													int this40 = ((maskPixel1 >> 16) & 255);
HXDLIN( 218)													if ((this40 == 0)) {
HXDLIN( 218)														m11 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m11 = (( (Float)(this40) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m21;
HXDLIN( 218)													int this41 = ((maskPixel1 >> 8) & 255);
HXDLIN( 218)													if ((this41 == 0)) {
HXDLIN( 218)														m21 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m21 = (( (Float)(this41) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m31;
HXDLIN( 218)													int this42 = (maskPixel1 & 255);
HXDLIN( 218)													if ((this42 == 0)) {
HXDLIN( 218)														m31 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m31 = (( (Float)(this42) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this38 >> 24) & 255)) )));
HXDLIN( 218)													int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this38 >> 16) & 255)) )));
HXDLIN( 218)													int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this38 >> 8) & 255)) )));
HXDLIN( 218)													int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this38 & 255)) )));
HXDLIN( 218)													col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 218)											if ((col1 != 0)) {
HXDLIN( 218)												int x4 = (dx2 - rectLeft1);
HXDLIN( 218)												int y4 = (dy2 - rectTop1);
HXDLIN( 218)												int c5 = col1;
HXDLIN( 218)												bool hitQuad10;
HXDLIN( 218)												if ((((c5 >> 24) & 255) < 254)) {
HXDLIN( 218)													hitQuad10 = undoImage3->transparent;
            												}
            												else {
HXDLIN( 218)													hitQuad10 = false;
            												}
HXDLIN( 218)												if (hitQuad10) {
HXDLIN( 218)													int location2;
HXDLIN( 218)													if (undoImage3->useVirtualPos) {
HXDLIN( 218)														location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 218)														location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            													}
HXDLIN( 218)													int this43 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 218)													int this44;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														this44 = ((((((this43 >> 24) & 255) << 24) | ((this43 & 255) << 16)) | (((this43 >> 8) & 255) << 8)) | ((this43 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														this44 = this43;
            													}
HXDLIN( 218)													Float a13;
HXDLIN( 218)													int this45 = ((this44 >> 24) & 255);
HXDLIN( 218)													if ((this45 == 0)) {
HXDLIN( 218)														a13 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														a13 = (( (Float)(this45) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float r12;
HXDLIN( 218)													int this46 = ((this44 >> 16) & 255);
HXDLIN( 218)													if ((this46 == 0)) {
HXDLIN( 218)														r12 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														r12 = (( (Float)(this46) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float g12;
HXDLIN( 218)													int this47 = ((this44 >> 8) & 255);
HXDLIN( 218)													if ((this47 == 0)) {
HXDLIN( 218)														g12 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														g12 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float b13;
HXDLIN( 218)													int this48 = (this44 & 255);
HXDLIN( 218)													if ((this48 == 0)) {
HXDLIN( 218)														b13 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														b13 = (( (Float)(this48) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float a22;
HXDLIN( 218)													int this49 = ((col1 >> 24) & 255);
HXDLIN( 218)													if ((this49 == 0)) {
HXDLIN( 218)														a22 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														a22 = (( (Float)(this49) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float r22;
HXDLIN( 218)													int this50 = ((col1 >> 16) & 255);
HXDLIN( 218)													if ((this50 == 0)) {
HXDLIN( 218)														r22 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														r22 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float g22;
HXDLIN( 218)													int this51 = ((col1 >> 8) & 255);
HXDLIN( 218)													if ((this51 == 0)) {
HXDLIN( 218)														g22 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														g22 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float b23;
HXDLIN( 218)													int this52 = (col1 & 255);
HXDLIN( 218)													if ((this52 == 0)) {
HXDLIN( 218)														b23 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														b23 = (( (Float)(this52) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 218)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 218)													int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 218)													int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 218)													int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 218)													int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 218)													{
HXDLIN( 218)														int hitQuad11;
HXDLIN( 218)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)															hitQuad11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXDLIN( 218)															hitQuad11 = blended2;
            														}
HXDLIN( 218)														::iterMagic::Iimg_obj::set(undoImage3->image,location2,hitQuad11);
            													}
            												}
            												else {
HXDLIN( 218)													::Dynamic this53 = undoImage3->image;
HXDLIN( 218)													int index6;
HXDLIN( 218)													if (undoImage3->useVirtualPos) {
HXDLIN( 218)														index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 218)														index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            													}
HXDLIN( 218)													int hitQuad12;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad12 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad12 = c5;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this53,index6,hitQuad12);
            												}
            											}
            											else {
HXDLIN( 218)												if (forceClear1) {
HXDLIN( 218)													::Dynamic this54 = undoImage3->image;
HXDLIN( 218)													int x5 = (dx2 - rectLeft1);
HXDLIN( 218)													int y5 = (dy2 - rectTop1);
HXDLIN( 218)													int index7;
HXDLIN( 218)													if (undoImage3->useVirtualPos) {
HXDLIN( 218)														index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 218)														index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this54,index7,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					{
HXDLIN( 218)						int _g_min2 = xIter31->start;
HXDLIN( 218)						int _g_max2 = xIter31->max;
HXDLIN( 218)						while((_g_min2 < _g_max2)){
HXDLIN( 218)							_g_min2 = (_g_min2 + 1);
HXDLIN( 218)							int px2 = (_g_min2 - 1);
HXDLIN( 218)							Float pcx1 = (( (Float)(px2) ) - dx);
HXDLIN( 218)							{
HXDLIN( 218)								int _g_min3 = yIter31->start;
HXDLIN( 218)								int _g_max3 = yIter31->max;
HXDLIN( 218)								while((_g_min3 < _g_max3)){
HXDLIN( 218)									_g_min3 = (_g_min3 + 1);
HXDLIN( 218)									int py2 = (_g_min3 - 1);
HXDLIN( 218)									Float pcy1 = (( (Float)(py2) ) - dy);
HXDLIN( 218)									Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 218)									Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 218)									Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 218)									Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 218)									Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 218)									bool hitQuad13;
HXDLIN( 218)									bool hitQuad14;
HXDLIN( 218)									if ((ratioA1 >= 0)) {
HXDLIN( 218)										hitQuad14 = (ratioB1 >= 0);
            									}
            									else {
HXDLIN( 218)										hitQuad14 = false;
            									}
HXDLIN( 218)									if (hitQuad14) {
HXDLIN( 218)										hitQuad13 = (ratioC1 >= 0);
            									}
            									else {
HXDLIN( 218)										hitQuad13 = false;
            									}
HXDLIN( 218)									if (hitQuad13) {
HXDLIN( 218)										int i16 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 218)										if ((i16 > 255)) {
HXLINE(  24)											i16 = 255;
            										}
HXLINE( 218)										if ((i16 < 0)) {
HXLINE(  25)											i16 = 0;
            										}
HXLINE( 218)										int a9 = i16;
HXDLIN( 218)										int i17 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 218)										if ((i17 > 255)) {
HXLINE(  24)											i17 = 255;
            										}
HXLINE( 218)										if ((i17 < 0)) {
HXLINE(  25)											i17 = 0;
            										}
HXLINE( 218)										int r6 = i17;
HXDLIN( 218)										int i18 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 218)										if ((i18 > 255)) {
HXLINE(  24)											i18 = 255;
            										}
HXLINE( 218)										if ((i18 < 0)) {
HXLINE(  25)											i18 = 0;
            										}
HXLINE( 218)										int g6 = i18;
HXDLIN( 218)										int i19 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 218)										if ((i19 > 255)) {
HXLINE(  24)											i19 = 255;
            										}
HXLINE( 218)										if ((i19 < 0)) {
HXLINE(  25)											i19 = 0;
            										}
HXLINE( 218)										int b10 = i19;
HXDLIN( 218)										{
HXDLIN( 218)											int location3;
HXDLIN( 218)											if (this1->useVirtualPos) {
HXDLIN( 218)												location3 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this1->virtualY) * ( (Float)(this1->width) )) + px2) - this1->virtualX));
            											}
            											else {
HXDLIN( 218)												location3 = ::Std_obj::_hx_int(( (Float)(((py2 * this1->width) + px2)) ));
            											}
HXDLIN( 218)											bool hitQuad15;
HXDLIN( 218)											if (this1->transparent) {
HXDLIN( 218)												hitQuad15 = (a9 < 254);
            											}
            											else {
HXDLIN( 218)												hitQuad15 = false;
            											}
HXDLIN( 218)											if (hitQuad15) {
HXDLIN( 218)												int this55 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 218)												int old1;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													old1 = ((((((this55 >> 24) & 255) << 24) | ((this55 & 255) << 16)) | (((this55 >> 8) & 255) << 8)) | ((this55 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													old1 = this55;
            												}
HXDLIN( 218)												int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 218)												Float a14;
HXDLIN( 218)												int this56 = ((old1 >> 24) & 255);
HXDLIN( 218)												if ((this56 == 0)) {
HXDLIN( 218)													a14 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a14 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r13;
HXDLIN( 218)												int this57 = ((old1 >> 16) & 255);
HXDLIN( 218)												if ((this57 == 0)) {
HXDLIN( 218)													r13 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g13;
HXDLIN( 218)												int this58 = ((old1 >> 8) & 255);
HXDLIN( 218)												if ((this58 == 0)) {
HXDLIN( 218)													g13 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b14;
HXDLIN( 218)												int this59 = (old1 & 255);
HXDLIN( 218)												if ((this59 == 0)) {
HXDLIN( 218)													b14 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a23;
HXDLIN( 218)												int this60 = ((rhs1 >> 24) & 255);
HXDLIN( 218)												if ((this60 == 0)) {
HXDLIN( 218)													a23 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r23;
HXDLIN( 218)												int this61 = ((rhs1 >> 16) & 255);
HXDLIN( 218)												if ((this61 == 0)) {
HXDLIN( 218)													r23 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g23;
HXDLIN( 218)												int this62 = ((rhs1 >> 8) & 255);
HXDLIN( 218)												if ((this62 == 0)) {
HXDLIN( 218)													g23 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b24;
HXDLIN( 218)												int this63 = (rhs1 & 255);
HXDLIN( 218)												if ((this63 == 0)) {
HXDLIN( 218)													b24 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 218)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 218)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 218)												int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 218)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 218)												int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 218)												{
HXDLIN( 218)													int hitQuad16;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad16 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad16 = blended3;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this1->image,location3,hitQuad16);
            												}
            											}
            											else {
HXDLIN( 218)												int value1;
HXDLIN( 218)												if (this1->isLittle) {
HXDLIN( 218)													value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            												}
            												else {
HXDLIN( 218)													value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this1->image,location3,value1);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					if ((hasHit1 == false)) {
HXDLIN( 218)						 ::pi_xy::algo::HitTri v4 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 218)						if (hasUndo1) {
HXDLIN( 218)							v4->undoImage = undoImage3;
HXDLIN( 218)							v4->undoX = xIter31->start;
HXDLIN( 218)							v4->undoY = yIter31->start;
            						}
            					}
            				}
HXDLIN( 218)				 ::pi_xy::algo::HitQuad v5 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 218)				hitQuad = v5;
            			}
            			else {
HXDLIN( 218)				Float sin2 = ::Math_obj::sin(theta);
HXDLIN( 218)				Float cos2 = ::Math_obj::cos(theta);
HXDLIN( 218)				Float radius11 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN( 218)				Float radius22 = (thick / ( (Float)(2) ));
HXDLIN( 218)				Float dx3 = ((Float)0.1);
HXDLIN( 218)				Float dy3 = radius11;
HXDLIN( 218)				Float cx1 = h2;
HXDLIN( 218)				Float cy1 = radius22;
HXDLIN( 218)				Float bx1 = h2;
HXDLIN( 218)				Float by1 = -(radius22);
HXDLIN( 218)				Float ax1 = ((Float)0.1);
HXDLIN( 218)				Float ay1 = -(radius11);
HXDLIN( 218)				Float temp1 = ((Float)0.);
HXLINE( 525)				temp1 = (px + ((ax1 * cos2) - (ay1 * sin2)));
HXLINE( 526)				ay1 = (py + ((ay1 * cos2) + (ax1 * sin2)));
HXLINE( 527)				ax1 = temp1;
HXLINE( 529)				temp1 = (px + ((bx1 * cos2) - (by1 * sin2)));
HXLINE( 530)				by1 = (py + ((by1 * cos2) + (bx1 * sin2)));
HXLINE( 531)				bx1 = temp1;
HXLINE( 533)				temp1 = (px + ((cx1 * cos2) - (cy1 * sin2)));
HXLINE( 534)				cy1 = (py + ((cy1 * cos2) + (cx1 * sin2)));
HXLINE( 535)				cx1 = temp1;
HXLINE( 537)				temp1 = (px + ((dx3 * cos2) - (dy3 * sin2)));
HXLINE( 538)				dy3 = (py + ((dy3 * cos2) + (dx3 * sin2)));
HXLINE( 539)				dx3 = temp1;
HXLINE( 218)				{
HXDLIN( 218)					bool hasUndo2 = false;
HXDLIN( 218)					int aA2 = ((color1 >> 24) & 255);
HXDLIN( 218)					int rA2 = ((color1 >> 16) & 255);
HXDLIN( 218)					int gA2 = ((color1 >> 8) & 255);
HXDLIN( 218)					int bA2 = (color1 & 255);
HXDLIN( 218)					int aB2 = ((color1 >> 24) & 255);
HXDLIN( 218)					int rB2 = ((color1 >> 16) & 255);
HXDLIN( 218)					int gB2 = ((color1 >> 8) & 255);
HXDLIN( 218)					int bB2 = (color1 & 255);
HXDLIN( 218)					int aC2 = ((color2 >> 24) & 255);
HXDLIN( 218)					int rC2 = ((color2 >> 16) & 255);
HXDLIN( 218)					int gC2 = ((color2 >> 8) & 255);
HXDLIN( 218)					int bC2 = (color2 & 255);
HXDLIN( 218)					Float bcx2 = (bx1 - dx3);
HXDLIN( 218)					Float bcy2 = (by1 - dy3);
HXDLIN( 218)					Float acx2 = (ax1 - dx3);
HXDLIN( 218)					Float acy2 = (ay1 - dy3);
HXDLIN( 218)					Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 218)					Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 218)					Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 218)					Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 218)					 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 218)					if ((ax1 > bx1)) {
HXDLIN( 218)						if ((ax1 > dx3)) {
HXDLIN( 218)							int min8;
HXDLIN( 218)							if ((bx1 > dx3)) {
HXDLIN( 218)								min8 = ::Math_obj::floor(dx3);
            							}
            							else {
HXDLIN( 218)								min8 = ::Math_obj::floor(bx1);
            							}
HXDLIN( 218)							int ii_min16 = min8;
HXDLIN( 218)							int ii_max16 = ::Math_obj::ceil(ax1);
HXDLIN( 218)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            						else {
HXDLIN( 218)							int ii_min17 = ::Math_obj::floor(bx1);
HXDLIN( 218)							int ii_max17 = ::Math_obj::ceil(dx3);
HXDLIN( 218)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            					}
            					else {
HXDLIN( 218)						if ((bx1 > dx3)) {
HXDLIN( 218)							int min9;
HXDLIN( 218)							if ((ax1 > dx3)) {
HXDLIN( 218)								min9 = ::Math_obj::floor(dx3);
            							}
            							else {
HXDLIN( 218)								min9 = ::Math_obj::ceil(ax1);
            							}
HXDLIN( 218)							int ii_min18 = min9;
HXDLIN( 218)							int ii_max18 = ::Math_obj::ceil(bx1);
HXDLIN( 218)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            						}
            						else {
HXDLIN( 218)							int ii_min19 = ::Math_obj::floor(ax1);
HXDLIN( 218)							int ii_max19 = ::Math_obj::ceil(dx3);
HXDLIN( 218)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            						}
            					}
HXDLIN( 218)					 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 218)					if ((ay1 > by1)) {
HXDLIN( 218)						if ((ay1 > dy3)) {
HXDLIN( 218)							int min10;
HXDLIN( 218)							if ((by1 > dy3)) {
HXDLIN( 218)								min10 = ::Math_obj::floor(dy3);
            							}
            							else {
HXDLIN( 218)								min10 = ::Math_obj::floor(by1);
            							}
HXDLIN( 218)							int ii_min20 = min10;
HXDLIN( 218)							int ii_max20 = ::Math_obj::ceil(ay1);
HXDLIN( 218)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            						}
            						else {
HXDLIN( 218)							int ii_min21 = ::Math_obj::floor(by1);
HXDLIN( 218)							int ii_max21 = ::Math_obj::ceil(dy3);
HXDLIN( 218)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            						}
            					}
            					else {
HXDLIN( 218)						if ((by1 > dy3)) {
HXDLIN( 218)							int min11;
HXDLIN( 218)							if ((ay1 > dy3)) {
HXDLIN( 218)								min11 = ::Math_obj::floor(dy3);
            							}
            							else {
HXDLIN( 218)								min11 = ::Math_obj::ceil(ay1);
            							}
HXDLIN( 218)							int ii_min22 = min11;
HXDLIN( 218)							int ii_max22 = ::Math_obj::ceil(by1);
HXDLIN( 218)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            						}
            						else {
HXDLIN( 218)							int ii_min23 = ::Math_obj::floor(ay1);
HXDLIN( 218)							int ii_max23 = ::Math_obj::ceil(dy3);
HXDLIN( 218)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            						}
            					}
HXDLIN( 218)					 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 218)					if (hasUndo2) {
HXDLIN( 218)						int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 218)						int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 218)						 ::Dynamic imageType2 = null();
HXDLIN( 218)						 ::pi_xy::ImageStruct this64 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 218)						if (::hx::IsNull( imageType2 )) {
HXLINE(  54)							imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 218)						::Dynamic undoImage7;
HXDLIN( 218)						switch((int)(( (int)(imageType2) ))){
            							case (int)0: {
HXDLIN( 218)								 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::BytesImg b16 = byt2;
HXDLIN( 218)								{
HXDLIN( 218)									b16->width = width2;
HXDLIN( 218)									b16->height = height2;
HXDLIN( 218)									b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 218)									b16->data = ::haxe::io::Bytes_obj::alloc((b16->length * 4));
HXDLIN( 218)									{
HXDLIN( 218)										int len4 = b16->length;
HXDLIN( 218)										int w2 = 0;
HXDLIN( 218)										{
HXDLIN( 218)											int _g40 = 0;
HXDLIN( 218)											int _g41 = b16->height;
HXDLIN( 218)											while((_g40 < _g41)){
HXDLIN( 218)												_g40 = (_g40 + 1);
HXDLIN( 218)												int y6 = (_g40 - 1);
HXDLIN( 218)												{
HXDLIN( 218)													int _g42 = 0;
HXDLIN( 218)													int _g43 = b16->width;
HXDLIN( 218)													while((_g42 < _g43)){
HXDLIN( 218)														_g42 = (_g42 + 1);
HXDLIN( 218)														int x6 = (_g42 - 1);
HXDLIN( 218)														{
HXDLIN( 218)															w2 = (w2 + 1);
HXDLIN( 218)															b16->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w2 = (w2 + 1);
HXDLIN( 218)															b16->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w2 = (w2 + 1);
HXDLIN( 218)															b16->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w2 = (w2 + 1);
HXDLIN( 218)															b16->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage7 = b16;
            							}
            							break;
            							case (int)1: {
HXDLIN( 218)								 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::ArrIntImg a15 = arrI2;
HXDLIN( 218)								{
HXDLIN( 218)									a15->width = width2;
HXDLIN( 218)									a15->height = height2;
HXDLIN( 218)									a15->data = ::Array_obj< int >::__new(0);
HXDLIN( 218)									a15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 218)									{
HXDLIN( 218)										int _g44 = 0;
HXDLIN( 218)										int _g45 = a15->length;
HXDLIN( 218)										while((_g44 < _g45)){
HXDLIN( 218)											_g44 = (_g44 + 1);
HXDLIN( 218)											int i20 = (_g44 - 1);
HXDLIN( 218)											a15->data[i20] = 0;
            										}
            									}
            								}
HXDLIN( 218)								undoImage7 = a15;
            							}
            							break;
            							case (int)2: {
HXDLIN( 218)								 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::U32ArrImg b17 = u32a2;
HXDLIN( 218)								{
HXDLIN( 218)									b17->width = width2;
HXDLIN( 218)									b17->height = height2;
HXDLIN( 218)									b17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 218)									int size2 = (b17->length * 4);
HXDLIN( 218)									b17->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 218)									{
HXDLIN( 218)										int _g46 = 0;
HXDLIN( 218)										int _g47 = b17->length;
HXDLIN( 218)										while((_g46 < _g47)){
HXDLIN( 218)											_g46 = (_g46 + 1);
HXDLIN( 218)											int i21 = (_g46 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												 ::haxe::io::ArrayBufferViewImpl this65 = b17->data;
HXDLIN( 218)												bool undoImage8;
HXDLIN( 218)												if ((i21 >= 0)) {
HXDLIN( 218)													undoImage8 = (i21 < (this65->byteLength >> 2));
            												}
            												else {
HXDLIN( 218)													undoImage8 = false;
            												}
HXDLIN( 218)												if (undoImage8) {
HXDLIN( 218)													 ::haxe::io::Bytes _this2 = this65->bytes;
HXDLIN( 218)													int pos2 = ((i21 << 2) + this65->byteOffset);
HXDLIN( 218)													_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 218)													_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 218)													_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 218)													_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage7 = b17;
            							}
            							break;
            							case (int)3: {
HXDLIN( 218)								 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN( 218)								{
HXDLIN( 218)									v6->width = width2;
HXDLIN( 218)									v6->height = height2;
HXDLIN( 218)									v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 218)									v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 218)									{
HXDLIN( 218)										int _g48 = 0;
HXDLIN( 218)										int _g49 = v6->length;
HXDLIN( 218)										while((_g48 < _g49)){
HXDLIN( 218)											_g48 = (_g48 + 1);
HXDLIN( 218)											int i22 = (_g48 - 1);
HXDLIN( 218)											v6->data->__unsafe_set(i22,0);
            										}
            									}
            								}
HXDLIN( 218)								undoImage7 = v6;
            							}
            							break;
            							case (int)4: {
HXDLIN( 218)								 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::StackIntImg b18 = sInt2;
HXDLIN( 218)								{
HXDLIN( 218)									b18->width = width2;
HXDLIN( 218)									b18->height = height2;
HXDLIN( 218)									b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 218)									b18->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 218)									{
HXDLIN( 218)										int len5 = b18->length;
HXDLIN( 218)										 ::haxe::ds::GenericStack_Int d2 = b18->data;
HXDLIN( 218)										if (::hx::IsNull( d2->head )) {
HXDLIN( 218)											int _g50 = 0;
HXDLIN( 218)											int _g51 = len5;
HXDLIN( 218)											while((_g50 < _g51)){
HXDLIN( 218)												_g50 = (_g50 + 1);
HXDLIN( 218)												int i23 = (_g50 - 1);
HXDLIN( 218)												d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            											}
            										}
            										else {
HXDLIN( 218)											int _g52 = 0;
HXDLIN( 218)											int _g53 = len5;
HXDLIN( 218)											while((_g52 < _g53)){
HXDLIN( 218)												_g52 = (_g52 + 1);
HXDLIN( 218)												int i24 = (_g52 - 1);
HXDLIN( 218)												{
HXDLIN( 218)													 ::haxe::ds::GenericCell_Int l2 = b18->data->head;
HXDLIN( 218)													 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 218)													{
HXDLIN( 218)														int _g54 = 0;
HXDLIN( 218)														int _g55 = i24;
HXDLIN( 218)														while((_g54 < _g55)){
HXDLIN( 218)															_g54 = (_g54 + 1);
HXDLIN( 218)															int i25 = (_g54 - 1);
HXLINE( 345)															prev2 = l2;
HXLINE( 346)															l2 = l2->next;
            														}
            													}
HXLINE( 218)													if (::hx::IsNull( prev2 )) {
HXDLIN( 218)														b18->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 218)														l2 = null();
            													}
            													else {
HXDLIN( 218)														prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 218)														l2 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage7 = b18;
            							}
            							break;
            						}
HXDLIN( 218)						this64->image = undoImage7;
HXDLIN( 218)						this64->width = width2;
HXDLIN( 218)						this64->height = height2;
HXDLIN( 218)						this64->imageType = ( (int)(imageType2) );
HXDLIN( 218)						undoImage6 = this64;
HXDLIN( 218)						{
HXDLIN( 218)							int rectLeft2 = xIter32->start;
HXDLIN( 218)							int rectTop2 = yIter32->start;
HXDLIN( 218)							int rectRight2 = xIter32->max;
HXDLIN( 218)							bool forceClear2 = false;
HXDLIN( 218)							{
HXDLIN( 218)								int _g56 = rectTop2;
HXDLIN( 218)								int _g57 = yIter32->max;
HXDLIN( 218)								while((_g56 < _g57)){
HXDLIN( 218)									_g56 = (_g56 + 1);
HXDLIN( 218)									int dy4 = (_g56 - 1);
HXDLIN( 218)									{
HXDLIN( 218)										int _g58 = rectLeft2;
HXDLIN( 218)										int _g59 = rectRight2;
HXDLIN( 218)										while((_g58 < _g59)){
HXDLIN( 218)											_g58 = (_g58 + 1);
HXDLIN( 218)											int dx4 = (_g58 - 1);
HXDLIN( 218)											::Dynamic this66 = this1->image;
HXDLIN( 218)											int index8;
HXDLIN( 218)											if (this1->useVirtualPos) {
HXDLIN( 218)												index8 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx4) - this1->virtualX));
            											}
            											else {
HXDLIN( 218)												index8 = ::Std_obj::_hx_int(( (Float)(((dy4 * this1->width) + dx4)) ));
            											}
HXDLIN( 218)											int c6 = ::iterMagic::Iimg_obj::get(this66,index8);
HXDLIN( 218)											int col2;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												col2 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												col2 = c6;
            											}
HXDLIN( 218)											bool hitQuad17;
HXDLIN( 218)											if (this1->useMask) {
HXDLIN( 218)												hitQuad17 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXDLIN( 218)												hitQuad17 = false;
            											}
HXDLIN( 218)											if (hitQuad17) {
HXDLIN( 218)												 ::pi_xy::ImageStruct this67 = this1->mask;
HXDLIN( 218)												::Dynamic this68 = this67->image;
HXDLIN( 218)												int index9;
HXDLIN( 218)												if (this67->useVirtualPos) {
HXDLIN( 218)													index9 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this67->virtualY) * ( (Float)(this67->width) )) + dx4) - this67->virtualX));
            												}
            												else {
HXDLIN( 218)													index9 = ::Std_obj::_hx_int(( (Float)(((dy4 * this67->width) + dx4)) ));
            												}
HXDLIN( 218)												int c7 = ::iterMagic::Iimg_obj::get(this68,index9);
HXDLIN( 218)												int v7;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													v7 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													v7 = c7;
            												}
HXDLIN( 218)												int maskPixel2 = v7;
HXDLIN( 218)												int this69 = col2;
HXDLIN( 218)												if ((maskPixel2 == 0)) {
HXDLIN( 218)													col2 = this69;
            												}
            												else {
HXDLIN( 218)													Float m02;
HXDLIN( 218)													int this70 = ((maskPixel2 >> 24) & 255);
HXDLIN( 218)													if ((this70 == 0)) {
HXDLIN( 218)														m02 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m02 = (( (Float)(this70) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m12;
HXDLIN( 218)													int this71 = ((maskPixel2 >> 16) & 255);
HXDLIN( 218)													if ((this71 == 0)) {
HXDLIN( 218)														m12 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m12 = (( (Float)(this71) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m22;
HXDLIN( 218)													int this72 = ((maskPixel2 >> 8) & 255);
HXDLIN( 218)													if ((this72 == 0)) {
HXDLIN( 218)														m22 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m22 = (( (Float)(this72) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m32;
HXDLIN( 218)													int this73 = (maskPixel2 & 255);
HXDLIN( 218)													if ((this73 == 0)) {
HXDLIN( 218)														m32 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m32 = (( (Float)(this73) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this69 >> 24) & 255)) )));
HXDLIN( 218)													int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this69 >> 16) & 255)) )));
HXDLIN( 218)													int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this69 >> 8) & 255)) )));
HXDLIN( 218)													int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this69 & 255)) )));
HXDLIN( 218)													col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 218)											if ((col2 != 0)) {
HXDLIN( 218)												int x7 = (dx4 - rectLeft2);
HXDLIN( 218)												int y7 = (dy4 - rectTop2);
HXDLIN( 218)												int c8 = col2;
HXDLIN( 218)												bool hitQuad18;
HXDLIN( 218)												if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 218)													hitQuad18 = undoImage6->transparent;
            												}
            												else {
HXDLIN( 218)													hitQuad18 = false;
            												}
HXDLIN( 218)												if (hitQuad18) {
HXDLIN( 218)													int location4;
HXDLIN( 218)													if (undoImage6->useVirtualPos) {
HXDLIN( 218)														location4 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 218)														location4 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            													}
HXDLIN( 218)													int this74 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 218)													int this75;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														this75 = ((((((this74 >> 24) & 255) << 24) | ((this74 & 255) << 16)) | (((this74 >> 8) & 255) << 8)) | ((this74 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														this75 = this74;
            													}
HXDLIN( 218)													Float a16;
HXDLIN( 218)													int this76 = ((this75 >> 24) & 255);
HXDLIN( 218)													if ((this76 == 0)) {
HXDLIN( 218)														a16 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														a16 = (( (Float)(this76) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float r14;
HXDLIN( 218)													int this77 = ((this75 >> 16) & 255);
HXDLIN( 218)													if ((this77 == 0)) {
HXDLIN( 218)														r14 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														r14 = (( (Float)(this77) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float g14;
HXDLIN( 218)													int this78 = ((this75 >> 8) & 255);
HXDLIN( 218)													if ((this78 == 0)) {
HXDLIN( 218)														g14 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														g14 = (( (Float)(this78) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float b19;
HXDLIN( 218)													int this79 = (this75 & 255);
HXDLIN( 218)													if ((this79 == 0)) {
HXDLIN( 218)														b19 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														b19 = (( (Float)(this79) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float a24;
HXDLIN( 218)													int this80 = ((col2 >> 24) & 255);
HXDLIN( 218)													if ((this80 == 0)) {
HXDLIN( 218)														a24 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														a24 = (( (Float)(this80) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float r24;
HXDLIN( 218)													int this81 = ((col2 >> 16) & 255);
HXDLIN( 218)													if ((this81 == 0)) {
HXDLIN( 218)														r24 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														r24 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float g24;
HXDLIN( 218)													int this82 = ((col2 >> 8) & 255);
HXDLIN( 218)													if ((this82 == 0)) {
HXDLIN( 218)														g24 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														g24 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float b25;
HXDLIN( 218)													int this83 = (col2 & 255);
HXDLIN( 218)													if ((this83 == 0)) {
HXDLIN( 218)														b25 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														b25 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float a34 = (a16 * (( (Float)(1) ) - a24));
HXDLIN( 218)													int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 218)													int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 218)													int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a34) + (b25 * a24))));
HXDLIN( 218)													int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 218)													int blended4 = ((((a17 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 218)													{
HXDLIN( 218)														int hitQuad19;
HXDLIN( 218)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)															hitQuad19 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXDLIN( 218)															hitQuad19 = blended4;
            														}
HXDLIN( 218)														::iterMagic::Iimg_obj::set(undoImage6->image,location4,hitQuad19);
            													}
            												}
            												else {
HXDLIN( 218)													::Dynamic this84 = undoImage6->image;
HXDLIN( 218)													int index10;
HXDLIN( 218)													if (undoImage6->useVirtualPos) {
HXDLIN( 218)														index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 218)														index10 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            													}
HXDLIN( 218)													int hitQuad20;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad20 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad20 = c8;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this84,index10,hitQuad20);
            												}
            											}
            											else {
HXDLIN( 218)												if (forceClear2) {
HXDLIN( 218)													::Dynamic this85 = undoImage6->image;
HXDLIN( 218)													int x8 = (dx4 - rectLeft2);
HXDLIN( 218)													int y8 = (dy4 - rectTop2);
HXDLIN( 218)													int index11;
HXDLIN( 218)													if (undoImage6->useVirtualPos) {
HXDLIN( 218)														index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 218)														index11 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this85,index11,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					{
HXDLIN( 218)						int _g_min4 = xIter32->start;
HXDLIN( 218)						int _g_max4 = xIter32->max;
HXDLIN( 218)						while((_g_min4 < _g_max4)){
HXDLIN( 218)							_g_min4 = (_g_min4 + 1);
HXDLIN( 218)							int px3 = (_g_min4 - 1);
HXDLIN( 218)							Float pcx2 = (( (Float)(px3) ) - dx3);
HXDLIN( 218)							{
HXDLIN( 218)								int _g_min5 = yIter32->start;
HXDLIN( 218)								int _g_max5 = yIter32->max;
HXDLIN( 218)								while((_g_min5 < _g_max5)){
HXDLIN( 218)									_g_min5 = (_g_min5 + 1);
HXDLIN( 218)									int py3 = (_g_min5 - 1);
HXDLIN( 218)									Float pcy2 = (( (Float)(py3) ) - dy3);
HXDLIN( 218)									Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 218)									Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 218)									Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 218)									Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 218)									Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 218)									bool hitQuad21;
HXDLIN( 218)									bool hitQuad22;
HXDLIN( 218)									if ((ratioA2 >= 0)) {
HXDLIN( 218)										hitQuad22 = (ratioB2 >= 0);
            									}
            									else {
HXDLIN( 218)										hitQuad22 = false;
            									}
HXDLIN( 218)									if (hitQuad22) {
HXDLIN( 218)										hitQuad21 = (ratioC2 >= 0);
            									}
            									else {
HXDLIN( 218)										hitQuad21 = false;
            									}
HXDLIN( 218)									if (hitQuad21) {
HXDLIN( 218)										int i26 = ::Std_obj::_hx_int((((( (Float)(aA2) ) * ratioA2) + (( (Float)(aB2) ) * ratioB2)) + (( (Float)(aC2) ) * ratioC2)));
HXDLIN( 218)										if ((i26 > 255)) {
HXLINE(  24)											i26 = 255;
            										}
HXLINE( 218)										if ((i26 < 0)) {
HXLINE(  25)											i26 = 0;
            										}
HXLINE( 218)										int a18 = i26;
HXDLIN( 218)										int i27 = ::Std_obj::_hx_int((((( (Float)(rA2) ) * ratioA2) + (( (Float)(rB2) ) * ratioB2)) + (( (Float)(rC2) ) * ratioC2)));
HXDLIN( 218)										if ((i27 > 255)) {
HXLINE(  24)											i27 = 255;
            										}
HXLINE( 218)										if ((i27 < 0)) {
HXLINE(  25)											i27 = 0;
            										}
HXLINE( 218)										int r9 = i27;
HXDLIN( 218)										int i28 = ::Std_obj::_hx_int((((( (Float)(gA2) ) * ratioA2) + (( (Float)(gB2) ) * ratioB2)) + (( (Float)(gC2) ) * ratioC2)));
HXDLIN( 218)										if ((i28 > 255)) {
HXLINE(  24)											i28 = 255;
            										}
HXLINE( 218)										if ((i28 < 0)) {
HXLINE(  25)											i28 = 0;
            										}
HXLINE( 218)										int g9 = i28;
HXDLIN( 218)										int i29 = ::Std_obj::_hx_int((((( (Float)(bA2) ) * ratioA2) + (( (Float)(bB2) ) * ratioB2)) + (( (Float)(bC2) ) * ratioC2)));
HXDLIN( 218)										if ((i29 > 255)) {
HXLINE(  24)											i29 = 255;
            										}
HXLINE( 218)										if ((i29 < 0)) {
HXLINE(  25)											i29 = 0;
            										}
HXLINE( 218)										int b26 = i29;
HXDLIN( 218)										{
HXDLIN( 218)											int location5;
HXDLIN( 218)											if (this1->useVirtualPos) {
HXDLIN( 218)												location5 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this1->virtualY) * ( (Float)(this1->width) )) + px3) - this1->virtualX));
            											}
            											else {
HXDLIN( 218)												location5 = ::Std_obj::_hx_int(( (Float)(((py3 * this1->width) + px3)) ));
            											}
HXDLIN( 218)											bool hitQuad23;
HXDLIN( 218)											if (this1->transparent) {
HXDLIN( 218)												hitQuad23 = (a18 < 254);
            											}
            											else {
HXDLIN( 218)												hitQuad23 = false;
            											}
HXDLIN( 218)											if (hitQuad23) {
HXDLIN( 218)												int this86 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 218)												int old2;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													old2 = ((((((this86 >> 24) & 255) << 24) | ((this86 & 255) << 16)) | (((this86 >> 8) & 255) << 8)) | ((this86 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													old2 = this86;
            												}
HXDLIN( 218)												int rhs2 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b26);
HXDLIN( 218)												Float a19;
HXDLIN( 218)												int this87 = ((old2 >> 24) & 255);
HXDLIN( 218)												if ((this87 == 0)) {
HXDLIN( 218)													a19 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a19 = (( (Float)(this87) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r15;
HXDLIN( 218)												int this88 = ((old2 >> 16) & 255);
HXDLIN( 218)												if ((this88 == 0)) {
HXDLIN( 218)													r15 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r15 = (( (Float)(this88) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g15;
HXDLIN( 218)												int this89 = ((old2 >> 8) & 255);
HXDLIN( 218)												if ((this89 == 0)) {
HXDLIN( 218)													g15 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g15 = (( (Float)(this89) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b110;
HXDLIN( 218)												int this90 = (old2 & 255);
HXDLIN( 218)												if ((this90 == 0)) {
HXDLIN( 218)													b110 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b110 = (( (Float)(this90) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a25;
HXDLIN( 218)												int this91 = ((rhs2 >> 24) & 255);
HXDLIN( 218)												if ((this91 == 0)) {
HXDLIN( 218)													a25 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a25 = (( (Float)(this91) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r25;
HXDLIN( 218)												int this92 = ((rhs2 >> 16) & 255);
HXDLIN( 218)												if ((this92 == 0)) {
HXDLIN( 218)													r25 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r25 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g25;
HXDLIN( 218)												int this93 = ((rhs2 >> 8) & 255);
HXDLIN( 218)												if ((this93 == 0)) {
HXDLIN( 218)													g25 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g25 = (( (Float)(this93) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b27;
HXDLIN( 218)												int this94 = (rhs2 & 255);
HXDLIN( 218)												if ((this94 == 0)) {
HXDLIN( 218)													b27 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b27 = (( (Float)(this94) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a35 = (a19 * (( (Float)(1) ) - a25));
HXDLIN( 218)												int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 218)												int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 218)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a35) + (b27 * a25))));
HXDLIN( 218)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 218)												int blended5 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b28);
HXDLIN( 218)												{
HXDLIN( 218)													int hitQuad24;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad24 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad24 = blended5;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this1->image,location5,hitQuad24);
            												}
            											}
            											else {
HXDLIN( 218)												int value2;
HXDLIN( 218)												if (this1->isLittle) {
HXDLIN( 218)													value2 = ((((a18 << 24) | (b26 << 16)) | (g9 << 8)) | r9);
            												}
            												else {
HXDLIN( 218)													value2 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b26);
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this1->image,location5,value2);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 218)				{
HXDLIN( 218)					bool hasHit2 = false;
HXDLIN( 218)					bool hasUndo3 = false;
HXDLIN( 218)					int aA3 = ((color2 >> 24) & 255);
HXDLIN( 218)					int rA3 = ((color2 >> 16) & 255);
HXDLIN( 218)					int gA3 = ((color2 >> 8) & 255);
HXDLIN( 218)					int bA3 = (color2 & 255);
HXDLIN( 218)					int aB3 = ((color1 >> 24) & 255);
HXDLIN( 218)					int rB3 = ((color1 >> 16) & 255);
HXDLIN( 218)					int gB3 = ((color1 >> 8) & 255);
HXDLIN( 218)					int bB3 = (color1 & 255);
HXDLIN( 218)					int aC3 = ((color2 >> 24) & 255);
HXDLIN( 218)					int rC3 = ((color2 >> 16) & 255);
HXDLIN( 218)					int gC3 = ((color2 >> 8) & 255);
HXDLIN( 218)					int bC3 = (color2 & 255);
HXDLIN( 218)					Float bcx3 = (cx1 - dx3);
HXDLIN( 218)					Float bcy3 = (cy1 - dy3);
HXDLIN( 218)					Float acx3 = (bx1 - dx3);
HXDLIN( 218)					Float acy3 = (by1 - dy3);
HXDLIN( 218)					Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 218)					Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 218)					Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 218)					Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 218)					 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 218)					if ((bx1 > cx1)) {
HXDLIN( 218)						if ((bx1 > dx3)) {
HXDLIN( 218)							int min12;
HXDLIN( 218)							if ((cx1 > dx3)) {
HXDLIN( 218)								min12 = ::Math_obj::floor(dx3);
            							}
            							else {
HXDLIN( 218)								min12 = ::Math_obj::floor(cx1);
            							}
HXDLIN( 218)							int ii_min24 = min12;
HXDLIN( 218)							int ii_max24 = ::Math_obj::ceil(bx1);
HXDLIN( 218)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            						}
            						else {
HXDLIN( 218)							int ii_min25 = ::Math_obj::floor(cx1);
HXDLIN( 218)							int ii_max25 = ::Math_obj::ceil(dx3);
HXDLIN( 218)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            						}
            					}
            					else {
HXDLIN( 218)						if ((cx1 > dx3)) {
HXDLIN( 218)							int min13;
HXDLIN( 218)							if ((bx1 > dx3)) {
HXDLIN( 218)								min13 = ::Math_obj::floor(dx3);
            							}
            							else {
HXDLIN( 218)								min13 = ::Math_obj::ceil(bx1);
            							}
HXDLIN( 218)							int ii_min26 = min13;
HXDLIN( 218)							int ii_max26 = ::Math_obj::ceil(cx1);
HXDLIN( 218)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            						}
            						else {
HXDLIN( 218)							int ii_min27 = ::Math_obj::floor(bx1);
HXDLIN( 218)							int ii_max27 = ::Math_obj::ceil(dx3);
HXDLIN( 218)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            						}
            					}
HXDLIN( 218)					 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 218)					if ((by1 > cy1)) {
HXDLIN( 218)						if ((by1 > dy3)) {
HXDLIN( 218)							int min14;
HXDLIN( 218)							if ((cy1 > dy3)) {
HXDLIN( 218)								min14 = ::Math_obj::floor(dy3);
            							}
            							else {
HXDLIN( 218)								min14 = ::Math_obj::floor(cy1);
            							}
HXDLIN( 218)							int ii_min28 = min14;
HXDLIN( 218)							int ii_max28 = ::Math_obj::ceil(by1);
HXDLIN( 218)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            						}
            						else {
HXDLIN( 218)							int ii_min29 = ::Math_obj::floor(cy1);
HXDLIN( 218)							int ii_max29 = ::Math_obj::ceil(dy3);
HXDLIN( 218)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            						}
            					}
            					else {
HXDLIN( 218)						if ((cy1 > dy3)) {
HXDLIN( 218)							int min15;
HXDLIN( 218)							if ((by1 > dy3)) {
HXDLIN( 218)								min15 = ::Math_obj::floor(dy3);
            							}
            							else {
HXDLIN( 218)								min15 = ::Math_obj::ceil(by1);
            							}
HXDLIN( 218)							int ii_min30 = min15;
HXDLIN( 218)							int ii_max30 = ::Math_obj::ceil(cy1);
HXDLIN( 218)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            						}
            						else {
HXDLIN( 218)							int ii_min31 = ::Math_obj::floor(by1);
HXDLIN( 218)							int ii_max31 = ::Math_obj::ceil(dy3);
HXDLIN( 218)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            						}
            					}
HXDLIN( 218)					 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 218)					if (hasUndo3) {
HXDLIN( 218)						int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 218)						int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 218)						 ::Dynamic imageType3 = null();
HXDLIN( 218)						 ::pi_xy::ImageStruct this95 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 218)						if (::hx::IsNull( imageType3 )) {
HXLINE(  54)							imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 218)						::Dynamic undoImage10;
HXDLIN( 218)						switch((int)(( (int)(imageType3) ))){
            							case (int)0: {
HXDLIN( 218)								 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::BytesImg b29 = byt3;
HXDLIN( 218)								{
HXDLIN( 218)									b29->width = width3;
HXDLIN( 218)									b29->height = height3;
HXDLIN( 218)									b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 218)									b29->data = ::haxe::io::Bytes_obj::alloc((b29->length * 4));
HXDLIN( 218)									{
HXDLIN( 218)										int len6 = b29->length;
HXDLIN( 218)										int w3 = 0;
HXDLIN( 218)										{
HXDLIN( 218)											int _g60 = 0;
HXDLIN( 218)											int _g61 = b29->height;
HXDLIN( 218)											while((_g60 < _g61)){
HXDLIN( 218)												_g60 = (_g60 + 1);
HXDLIN( 218)												int y9 = (_g60 - 1);
HXDLIN( 218)												{
HXDLIN( 218)													int _g62 = 0;
HXDLIN( 218)													int _g63 = b29->width;
HXDLIN( 218)													while((_g62 < _g63)){
HXDLIN( 218)														_g62 = (_g62 + 1);
HXDLIN( 218)														int x9 = (_g62 - 1);
HXDLIN( 218)														{
HXDLIN( 218)															w3 = (w3 + 1);
HXDLIN( 218)															b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w3 = (w3 + 1);
HXDLIN( 218)															b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w3 = (w3 + 1);
HXDLIN( 218)															b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 218)														{
HXDLIN( 218)															w3 = (w3 + 1);
HXDLIN( 218)															b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage10 = b29;
            							}
            							break;
            							case (int)1: {
HXDLIN( 218)								 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::ArrIntImg a26 = arrI3;
HXDLIN( 218)								{
HXDLIN( 218)									a26->width = width3;
HXDLIN( 218)									a26->height = height3;
HXDLIN( 218)									a26->data = ::Array_obj< int >::__new(0);
HXDLIN( 218)									a26->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 218)									{
HXDLIN( 218)										int _g64 = 0;
HXDLIN( 218)										int _g65 = a26->length;
HXDLIN( 218)										while((_g64 < _g65)){
HXDLIN( 218)											_g64 = (_g64 + 1);
HXDLIN( 218)											int i30 = (_g64 - 1);
HXDLIN( 218)											a26->data[i30] = 0;
            										}
            									}
            								}
HXDLIN( 218)								undoImage10 = a26;
            							}
            							break;
            							case (int)2: {
HXDLIN( 218)								 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::U32ArrImg b30 = u32a3;
HXDLIN( 218)								{
HXDLIN( 218)									b30->width = width3;
HXDLIN( 218)									b30->height = height3;
HXDLIN( 218)									b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 218)									int size3 = (b30->length * 4);
HXDLIN( 218)									b30->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 218)									{
HXDLIN( 218)										int _g66 = 0;
HXDLIN( 218)										int _g67 = b30->length;
HXDLIN( 218)										while((_g66 < _g67)){
HXDLIN( 218)											_g66 = (_g66 + 1);
HXDLIN( 218)											int i31 = (_g66 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												 ::haxe::io::ArrayBufferViewImpl this96 = b30->data;
HXDLIN( 218)												bool undoImage11;
HXDLIN( 218)												if ((i31 >= 0)) {
HXDLIN( 218)													undoImage11 = (i31 < (this96->byteLength >> 2));
            												}
            												else {
HXDLIN( 218)													undoImage11 = false;
            												}
HXDLIN( 218)												if (undoImage11) {
HXDLIN( 218)													 ::haxe::io::Bytes _this3 = this96->bytes;
HXDLIN( 218)													int pos3 = ((i31 << 2) + this96->byteOffset);
HXDLIN( 218)													_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 218)													_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 218)													_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 218)													_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage10 = b30;
            							}
            							break;
            							case (int)3: {
HXDLIN( 218)								 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::VecIntImg v8 = vec3;
HXDLIN( 218)								{
HXDLIN( 218)									v8->width = width3;
HXDLIN( 218)									v8->height = height3;
HXDLIN( 218)									v8->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 218)									v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN( 218)									{
HXDLIN( 218)										int _g68 = 0;
HXDLIN( 218)										int _g69 = v8->length;
HXDLIN( 218)										while((_g68 < _g69)){
HXDLIN( 218)											_g68 = (_g68 + 1);
HXDLIN( 218)											int i32 = (_g68 - 1);
HXDLIN( 218)											v8->data->__unsafe_set(i32,0);
            										}
            									}
            								}
HXDLIN( 218)								undoImage10 = v8;
            							}
            							break;
            							case (int)4: {
HXDLIN( 218)								 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)								 ::iterMagic::StackIntImg b31 = sInt3;
HXDLIN( 218)								{
HXDLIN( 218)									b31->width = width3;
HXDLIN( 218)									b31->height = height3;
HXDLIN( 218)									b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 218)									b31->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 218)									{
HXDLIN( 218)										int len7 = b31->length;
HXDLIN( 218)										 ::haxe::ds::GenericStack_Int d3 = b31->data;
HXDLIN( 218)										if (::hx::IsNull( d3->head )) {
HXDLIN( 218)											int _g70 = 0;
HXDLIN( 218)											int _g71 = len7;
HXDLIN( 218)											while((_g70 < _g71)){
HXDLIN( 218)												_g70 = (_g70 + 1);
HXDLIN( 218)												int i33 = (_g70 - 1);
HXDLIN( 218)												d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            											}
            										}
            										else {
HXDLIN( 218)											int _g72 = 0;
HXDLIN( 218)											int _g73 = len7;
HXDLIN( 218)											while((_g72 < _g73)){
HXDLIN( 218)												_g72 = (_g72 + 1);
HXDLIN( 218)												int i34 = (_g72 - 1);
HXDLIN( 218)												{
HXDLIN( 218)													 ::haxe::ds::GenericCell_Int l3 = b31->data->head;
HXDLIN( 218)													 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 218)													{
HXDLIN( 218)														int _g74 = 0;
HXDLIN( 218)														int _g75 = i34;
HXDLIN( 218)														while((_g74 < _g75)){
HXDLIN( 218)															_g74 = (_g74 + 1);
HXDLIN( 218)															int i35 = (_g74 - 1);
HXLINE( 345)															prev3 = l3;
HXLINE( 346)															l3 = l3->next;
            														}
            													}
HXLINE( 218)													if (::hx::IsNull( prev3 )) {
HXDLIN( 218)														b31->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 218)														l3 = null();
            													}
            													else {
HXDLIN( 218)														prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 218)														l3 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 218)								undoImage10 = b31;
            							}
            							break;
            						}
HXDLIN( 218)						this95->image = undoImage10;
HXDLIN( 218)						this95->width = width3;
HXDLIN( 218)						this95->height = height3;
HXDLIN( 218)						this95->imageType = ( (int)(imageType3) );
HXDLIN( 218)						undoImage9 = this95;
HXDLIN( 218)						{
HXDLIN( 218)							int rectLeft3 = xIter33->start;
HXDLIN( 218)							int rectTop3 = yIter33->start;
HXDLIN( 218)							int rectRight3 = xIter33->max;
HXDLIN( 218)							bool forceClear3 = false;
HXDLIN( 218)							{
HXDLIN( 218)								int _g76 = rectTop3;
HXDLIN( 218)								int _g77 = yIter33->max;
HXDLIN( 218)								while((_g76 < _g77)){
HXDLIN( 218)									_g76 = (_g76 + 1);
HXDLIN( 218)									int dy5 = (_g76 - 1);
HXDLIN( 218)									{
HXDLIN( 218)										int _g78 = rectLeft3;
HXDLIN( 218)										int _g79 = rectRight3;
HXDLIN( 218)										while((_g78 < _g79)){
HXDLIN( 218)											_g78 = (_g78 + 1);
HXDLIN( 218)											int dx5 = (_g78 - 1);
HXDLIN( 218)											::Dynamic this97 = this1->image;
HXDLIN( 218)											int index12;
HXDLIN( 218)											if (this1->useVirtualPos) {
HXDLIN( 218)												index12 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx5) - this1->virtualX));
            											}
            											else {
HXDLIN( 218)												index12 = ::Std_obj::_hx_int(( (Float)(((dy5 * this1->width) + dx5)) ));
            											}
HXDLIN( 218)											int c9 = ::iterMagic::Iimg_obj::get(this97,index12);
HXDLIN( 218)											int col3;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												col3 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												col3 = c9;
            											}
HXDLIN( 218)											bool hitQuad25;
HXDLIN( 218)											if (this1->useMask) {
HXDLIN( 218)												hitQuad25 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXDLIN( 218)												hitQuad25 = false;
            											}
HXDLIN( 218)											if (hitQuad25) {
HXDLIN( 218)												 ::pi_xy::ImageStruct this98 = this1->mask;
HXDLIN( 218)												::Dynamic this99 = this98->image;
HXDLIN( 218)												int index13;
HXDLIN( 218)												if (this98->useVirtualPos) {
HXDLIN( 218)													index13 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this98->virtualY) * ( (Float)(this98->width) )) + dx5) - this98->virtualX));
            												}
            												else {
HXDLIN( 218)													index13 = ::Std_obj::_hx_int(( (Float)(((dy5 * this98->width) + dx5)) ));
            												}
HXDLIN( 218)												int c10 = ::iterMagic::Iimg_obj::get(this99,index13);
HXDLIN( 218)												int v9;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													v9 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													v9 = c10;
            												}
HXDLIN( 218)												int maskPixel3 = v9;
HXDLIN( 218)												int this100 = col3;
HXDLIN( 218)												if ((maskPixel3 == 0)) {
HXDLIN( 218)													col3 = this100;
            												}
            												else {
HXDLIN( 218)													Float m03;
HXDLIN( 218)													int this101 = ((maskPixel3 >> 24) & 255);
HXDLIN( 218)													if ((this101 == 0)) {
HXDLIN( 218)														m03 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m03 = (( (Float)(this101) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m13;
HXDLIN( 218)													int this102 = ((maskPixel3 >> 16) & 255);
HXDLIN( 218)													if ((this102 == 0)) {
HXDLIN( 218)														m13 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m13 = (( (Float)(this102) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m23;
HXDLIN( 218)													int this103 = ((maskPixel3 >> 8) & 255);
HXDLIN( 218)													if ((this103 == 0)) {
HXDLIN( 218)														m23 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m23 = (( (Float)(this103) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float m33;
HXDLIN( 218)													int this104 = (maskPixel3 & 255);
HXDLIN( 218)													if ((this104 == 0)) {
HXDLIN( 218)														m33 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														m33 = (( (Float)(this104) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this100 >> 24) & 255)) )));
HXDLIN( 218)													int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this100 >> 16) & 255)) )));
HXDLIN( 218)													int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this100 >> 8) & 255)) )));
HXDLIN( 218)													int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this100 & 255)) )));
HXDLIN( 218)													col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 218)											if ((col3 != 0)) {
HXDLIN( 218)												int x10 = (dx5 - rectLeft3);
HXDLIN( 218)												int y10 = (dy5 - rectTop3);
HXDLIN( 218)												int c11 = col3;
HXDLIN( 218)												bool hitQuad26;
HXDLIN( 218)												if ((((c11 >> 24) & 255) < 254)) {
HXDLIN( 218)													hitQuad26 = undoImage9->transparent;
            												}
            												else {
HXDLIN( 218)													hitQuad26 = false;
            												}
HXDLIN( 218)												if (hitQuad26) {
HXDLIN( 218)													int location6;
HXDLIN( 218)													if (undoImage9->useVirtualPos) {
HXDLIN( 218)														location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            													}
            													else {
HXDLIN( 218)														location6 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            													}
HXDLIN( 218)													int this105 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 218)													int this106;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														this106 = ((((((this105 >> 24) & 255) << 24) | ((this105 & 255) << 16)) | (((this105 >> 8) & 255) << 8)) | ((this105 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														this106 = this105;
            													}
HXDLIN( 218)													Float a110;
HXDLIN( 218)													int this107 = ((this106 >> 24) & 255);
HXDLIN( 218)													if ((this107 == 0)) {
HXDLIN( 218)														a110 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														a110 = (( (Float)(this107) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float r16;
HXDLIN( 218)													int this108 = ((this106 >> 16) & 255);
HXDLIN( 218)													if ((this108 == 0)) {
HXDLIN( 218)														r16 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														r16 = (( (Float)(this108) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float g16;
HXDLIN( 218)													int this109 = ((this106 >> 8) & 255);
HXDLIN( 218)													if ((this109 == 0)) {
HXDLIN( 218)														g16 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														g16 = (( (Float)(this109) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float b111;
HXDLIN( 218)													int this110 = (this106 & 255);
HXDLIN( 218)													if ((this110 == 0)) {
HXDLIN( 218)														b111 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														b111 = (( (Float)(this110) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float a27;
HXDLIN( 218)													int this111 = ((col3 >> 24) & 255);
HXDLIN( 218)													if ((this111 == 0)) {
HXDLIN( 218)														a27 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														a27 = (( (Float)(this111) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float r26;
HXDLIN( 218)													int this112 = ((col3 >> 16) & 255);
HXDLIN( 218)													if ((this112 == 0)) {
HXDLIN( 218)														r26 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														r26 = (( (Float)(this112) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float g26;
HXDLIN( 218)													int this113 = ((col3 >> 8) & 255);
HXDLIN( 218)													if ((this113 == 0)) {
HXDLIN( 218)														g26 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														g26 = (( (Float)(this113) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float b210;
HXDLIN( 218)													int this114 = (col3 & 255);
HXDLIN( 218)													if ((this114 == 0)) {
HXDLIN( 218)														b210 = ((Float)0.);
            													}
            													else {
HXDLIN( 218)														b210 = (( (Float)(this114) ) / ( (Float)(255) ));
            													}
HXDLIN( 218)													Float a36 = (a110 * (( (Float)(1) ) - a27));
HXDLIN( 218)													int r17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a27))));
HXDLIN( 218)													int g17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a27))));
HXDLIN( 218)													int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a36) + (b210 * a27))));
HXDLIN( 218)													int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a27)));
HXDLIN( 218)													int blended6 = ((((a28 << 24) | (r17 << 16)) | (g17 << 8)) | b32);
HXDLIN( 218)													{
HXDLIN( 218)														int hitQuad27;
HXDLIN( 218)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)															hitQuad27 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            														}
            														else {
HXDLIN( 218)															hitQuad27 = blended6;
            														}
HXDLIN( 218)														::iterMagic::Iimg_obj::set(undoImage9->image,location6,hitQuad27);
            													}
            												}
            												else {
HXDLIN( 218)													::Dynamic this115 = undoImage9->image;
HXDLIN( 218)													int index14;
HXDLIN( 218)													if (undoImage9->useVirtualPos) {
HXDLIN( 218)														index14 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            													}
            													else {
HXDLIN( 218)														index14 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            													}
HXDLIN( 218)													int hitQuad28;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad28 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad28 = c11;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this115,index14,hitQuad28);
            												}
            											}
            											else {
HXDLIN( 218)												if (forceClear3) {
HXDLIN( 218)													::Dynamic this116 = undoImage9->image;
HXDLIN( 218)													int x11 = (dx5 - rectLeft3);
HXDLIN( 218)													int y11 = (dy5 - rectTop3);
HXDLIN( 218)													int index15;
HXDLIN( 218)													if (undoImage9->useVirtualPos) {
HXDLIN( 218)														index15 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            													}
            													else {
HXDLIN( 218)														index15 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this116,index15,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					{
HXDLIN( 218)						int _g_min6 = xIter33->start;
HXDLIN( 218)						int _g_max6 = xIter33->max;
HXDLIN( 218)						while((_g_min6 < _g_max6)){
HXDLIN( 218)							_g_min6 = (_g_min6 + 1);
HXDLIN( 218)							int px4 = (_g_min6 - 1);
HXDLIN( 218)							Float pcx3 = (( (Float)(px4) ) - dx3);
HXDLIN( 218)							{
HXDLIN( 218)								int _g_min7 = yIter33->start;
HXDLIN( 218)								int _g_max7 = yIter33->max;
HXDLIN( 218)								while((_g_min7 < _g_max7)){
HXDLIN( 218)									_g_min7 = (_g_min7 + 1);
HXDLIN( 218)									int py4 = (_g_min7 - 1);
HXDLIN( 218)									Float pcy3 = (( (Float)(py4) ) - dy3);
HXDLIN( 218)									Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 218)									Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 218)									Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 218)									Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 218)									Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 218)									bool hitQuad29;
HXDLIN( 218)									bool hitQuad30;
HXDLIN( 218)									if ((ratioA3 >= 0)) {
HXDLIN( 218)										hitQuad30 = (ratioB3 >= 0);
            									}
            									else {
HXDLIN( 218)										hitQuad30 = false;
            									}
HXDLIN( 218)									if (hitQuad30) {
HXDLIN( 218)										hitQuad29 = (ratioC3 >= 0);
            									}
            									else {
HXDLIN( 218)										hitQuad29 = false;
            									}
HXDLIN( 218)									if (hitQuad29) {
HXDLIN( 218)										int i36 = ::Std_obj::_hx_int((((( (Float)(aA3) ) * ratioA3) + (( (Float)(aB3) ) * ratioB3)) + (( (Float)(aC3) ) * ratioC3)));
HXDLIN( 218)										if ((i36 > 255)) {
HXLINE(  24)											i36 = 255;
            										}
HXLINE( 218)										if ((i36 < 0)) {
HXLINE(  25)											i36 = 0;
            										}
HXLINE( 218)										int a29 = i36;
HXDLIN( 218)										int i37 = ::Std_obj::_hx_int((((( (Float)(rA3) ) * ratioA3) + (( (Float)(rB3) ) * ratioB3)) + (( (Float)(rC3) ) * ratioC3)));
HXDLIN( 218)										if ((i37 > 255)) {
HXLINE(  24)											i37 = 255;
            										}
HXLINE( 218)										if ((i37 < 0)) {
HXLINE(  25)											i37 = 0;
            										}
HXLINE( 218)										int r18 = i37;
HXDLIN( 218)										int i38 = ::Std_obj::_hx_int((((( (Float)(gA3) ) * ratioA3) + (( (Float)(gB3) ) * ratioB3)) + (( (Float)(gC3) ) * ratioC3)));
HXDLIN( 218)										if ((i38 > 255)) {
HXLINE(  24)											i38 = 255;
            										}
HXLINE( 218)										if ((i38 < 0)) {
HXLINE(  25)											i38 = 0;
            										}
HXLINE( 218)										int g18 = i38;
HXDLIN( 218)										int i39 = ::Std_obj::_hx_int((((( (Float)(bA3) ) * ratioA3) + (( (Float)(bB3) ) * ratioB3)) + (( (Float)(bC3) ) * ratioC3)));
HXDLIN( 218)										if ((i39 > 255)) {
HXLINE(  24)											i39 = 255;
            										}
HXLINE( 218)										if ((i39 < 0)) {
HXLINE(  25)											i39 = 0;
            										}
HXLINE( 218)										int b33 = i39;
HXDLIN( 218)										{
HXDLIN( 218)											int location7;
HXDLIN( 218)											if (this1->useVirtualPos) {
HXDLIN( 218)												location7 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - this1->virtualY) * ( (Float)(this1->width) )) + px4) - this1->virtualX));
            											}
            											else {
HXDLIN( 218)												location7 = ::Std_obj::_hx_int(( (Float)(((py4 * this1->width) + px4)) ));
            											}
HXDLIN( 218)											bool hitQuad31;
HXDLIN( 218)											if (this1->transparent) {
HXDLIN( 218)												hitQuad31 = (a29 < 254);
            											}
            											else {
HXDLIN( 218)												hitQuad31 = false;
            											}
HXDLIN( 218)											if (hitQuad31) {
HXDLIN( 218)												int this117 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN( 218)												int old3;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													old3 = ((((((this117 >> 24) & 255) << 24) | ((this117 & 255) << 16)) | (((this117 >> 8) & 255) << 8)) | ((this117 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													old3 = this117;
            												}
HXDLIN( 218)												int rhs3 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b33);
HXDLIN( 218)												Float a111;
HXDLIN( 218)												int this118 = ((old3 >> 24) & 255);
HXDLIN( 218)												if ((this118 == 0)) {
HXDLIN( 218)													a111 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a111 = (( (Float)(this118) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r19;
HXDLIN( 218)												int this119 = ((old3 >> 16) & 255);
HXDLIN( 218)												if ((this119 == 0)) {
HXDLIN( 218)													r19 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r19 = (( (Float)(this119) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g19;
HXDLIN( 218)												int this120 = ((old3 >> 8) & 255);
HXDLIN( 218)												if ((this120 == 0)) {
HXDLIN( 218)													g19 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g19 = (( (Float)(this120) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b112;
HXDLIN( 218)												int this121 = (old3 & 255);
HXDLIN( 218)												if ((this121 == 0)) {
HXDLIN( 218)													b112 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b112 = (( (Float)(this121) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a210;
HXDLIN( 218)												int this122 = ((rhs3 >> 24) & 255);
HXDLIN( 218)												if ((this122 == 0)) {
HXDLIN( 218)													a210 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a210 = (( (Float)(this122) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r27;
HXDLIN( 218)												int this123 = ((rhs3 >> 16) & 255);
HXDLIN( 218)												if ((this123 == 0)) {
HXDLIN( 218)													r27 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r27 = (( (Float)(this123) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g27;
HXDLIN( 218)												int this124 = ((rhs3 >> 8) & 255);
HXDLIN( 218)												if ((this124 == 0)) {
HXDLIN( 218)													g27 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g27 = (( (Float)(this124) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b211;
HXDLIN( 218)												int this125 = (rhs3 & 255);
HXDLIN( 218)												if ((this125 == 0)) {
HXDLIN( 218)													b211 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b211 = (( (Float)(this125) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a37 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 218)												int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a37) + (r27 * a210))));
HXDLIN( 218)												int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a37) + (g27 * a210))));
HXDLIN( 218)												int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a37) + (b211 * a210))));
HXDLIN( 218)												int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a210)));
HXDLIN( 218)												int blended7 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 218)												{
HXDLIN( 218)													int hitQuad32;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad32 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad32 = blended7;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(this1->image,location7,hitQuad32);
            												}
            											}
            											else {
HXDLIN( 218)												int value3;
HXDLIN( 218)												if (this1->isLittle) {
HXDLIN( 218)													value3 = ((((a29 << 24) | (b33 << 16)) | (g18 << 8)) | r18);
            												}
            												else {
HXDLIN( 218)													value3 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b33);
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this1->image,location7,value3);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					if ((hasHit2 == false)) {
HXDLIN( 218)						 ::pi_xy::algo::HitTri v10 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx1,by1,cx1,cy1,dx3,dy3,true);
HXDLIN( 218)						if (hasUndo3) {
HXDLIN( 218)							v10->undoImage = undoImage9;
HXDLIN( 218)							v10->undoX = xIter33->start;
HXDLIN( 218)							v10->undoY = yIter33->start;
            						}
            					}
            				}
HXDLIN( 218)				 ::pi_xy::algo::HitQuad v11 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax1,ay1,bx1,by1,cx1,cy1,dx3,dy3,true);
HXDLIN( 218)				hitQuad = v11;
            			}
            		}
            		else {
HXDLIN( 218)			Float sin3 = ::Math_obj::sin(theta);
HXDLIN( 218)			Float cos3 = ::Math_obj::cos(theta);
HXDLIN( 218)			Float radius3 = (thick / ( (Float)(2) ));
HXDLIN( 218)			Float dx6 = ((Float)0.1);
HXDLIN( 218)			Float dy6 = radius3;
HXDLIN( 218)			Float cx2 = h2;
HXDLIN( 218)			Float cy2 = radius3;
HXDLIN( 218)			Float bx2 = h2;
HXDLIN( 218)			Float by2 = -(radius3);
HXDLIN( 218)			Float ax2 = ((Float)0.1);
HXDLIN( 218)			Float ay2 = -(radius3);
HXDLIN( 218)			Float temp2 = ((Float)0.);
HXLINE( 474)			temp2 = (px + ((ax2 * cos3) - (ay2 * sin3)));
HXLINE( 475)			ay2 = (py + ((ay2 * cos3) + (ax2 * sin3)));
HXLINE( 476)			ax2 = temp2;
HXLINE( 478)			temp2 = (px + ((bx2 * cos3) - (by2 * sin3)));
HXLINE( 479)			by2 = (py + ((by2 * cos3) + (bx2 * sin3)));
HXLINE( 480)			bx2 = temp2;
HXLINE( 482)			temp2 = (px + ((cx2 * cos3) - (cy2 * sin3)));
HXLINE( 483)			cy2 = (py + ((cy2 * cos3) + (cx2 * sin3)));
HXLINE( 484)			cx2 = temp2;
HXLINE( 486)			temp2 = (px + ((dx6 * cos3) - (dy6 * sin3)));
HXLINE( 487)			dy6 = (py + ((dy6 * cos3) + (dx6 * sin3)));
HXLINE( 488)			dx6 = temp2;
HXLINE( 218)			{
HXDLIN( 218)				bool hasUndo4 = false;
HXDLIN( 218)				int aA4 = ((color1 >> 24) & 255);
HXDLIN( 218)				int rA4 = ((color1 >> 16) & 255);
HXDLIN( 218)				int gA4 = ((color1 >> 8) & 255);
HXDLIN( 218)				int bA4 = (color1 & 255);
HXDLIN( 218)				int aB4 = ((color1 >> 24) & 255);
HXDLIN( 218)				int rB4 = ((color1 >> 16) & 255);
HXDLIN( 218)				int gB4 = ((color1 >> 8) & 255);
HXDLIN( 218)				int bB4 = (color1 & 255);
HXDLIN( 218)				int aC4 = ((color2 >> 24) & 255);
HXDLIN( 218)				int rC4 = ((color2 >> 16) & 255);
HXDLIN( 218)				int gC4 = ((color2 >> 8) & 255);
HXDLIN( 218)				int bC4 = (color2 & 255);
HXDLIN( 218)				Float bcx4 = (bx2 - dx6);
HXDLIN( 218)				Float bcy4 = (by2 - dy6);
HXDLIN( 218)				Float acx4 = (ax2 - dx6);
HXDLIN( 218)				Float acy4 = (ay2 - dy6);
HXDLIN( 218)				Float dot114 = ((bcx4 * bcx4) + (bcy4 * bcy4));
HXDLIN( 218)				Float dot124 = ((bcx4 * acx4) + (bcy4 * acy4));
HXDLIN( 218)				Float dot224 = ((acx4 * acx4) + (acy4 * acy4));
HXDLIN( 218)				Float denom14 = (( (Float)(1) ) / ((dot114 * dot224) - (dot124 * dot124)));
HXDLIN( 218)				 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 218)				if ((ax2 > bx2)) {
HXDLIN( 218)					if ((ax2 > dx6)) {
HXDLIN( 218)						int min16;
HXDLIN( 218)						if ((bx2 > dx6)) {
HXDLIN( 218)							min16 = ::Math_obj::floor(dx6);
            						}
            						else {
HXDLIN( 218)							min16 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 218)						int ii_min32 = min16;
HXDLIN( 218)						int ii_max32 = ::Math_obj::ceil(ax2);
HXDLIN( 218)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            					}
            					else {
HXDLIN( 218)						int ii_min33 = ::Math_obj::floor(bx2);
HXDLIN( 218)						int ii_max33 = ::Math_obj::ceil(dx6);
HXDLIN( 218)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            					}
            				}
            				else {
HXDLIN( 218)					if ((bx2 > dx6)) {
HXDLIN( 218)						int min17;
HXDLIN( 218)						if ((ax2 > dx6)) {
HXDLIN( 218)							min17 = ::Math_obj::floor(dx6);
            						}
            						else {
HXDLIN( 218)							min17 = ::Math_obj::ceil(ax2);
            						}
HXDLIN( 218)						int ii_min34 = min17;
HXDLIN( 218)						int ii_max34 = ::Math_obj::ceil(bx2);
HXDLIN( 218)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            					}
            					else {
HXDLIN( 218)						int ii_min35 = ::Math_obj::floor(ax2);
HXDLIN( 218)						int ii_max35 = ::Math_obj::ceil(dx6);
HXDLIN( 218)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            					}
            				}
HXDLIN( 218)				 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 218)				if ((ay2 > by2)) {
HXDLIN( 218)					if ((ay2 > dy6)) {
HXDLIN( 218)						int min18;
HXDLIN( 218)						if ((by2 > dy6)) {
HXDLIN( 218)							min18 = ::Math_obj::floor(dy6);
            						}
            						else {
HXDLIN( 218)							min18 = ::Math_obj::floor(by2);
            						}
HXDLIN( 218)						int ii_min36 = min18;
HXDLIN( 218)						int ii_max36 = ::Math_obj::ceil(ay2);
HXDLIN( 218)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            					}
            					else {
HXDLIN( 218)						int ii_min37 = ::Math_obj::floor(by2);
HXDLIN( 218)						int ii_max37 = ::Math_obj::ceil(dy6);
HXDLIN( 218)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            					}
            				}
            				else {
HXDLIN( 218)					if ((by2 > dy6)) {
HXDLIN( 218)						int min19;
HXDLIN( 218)						if ((ay2 > dy6)) {
HXDLIN( 218)							min19 = ::Math_obj::floor(dy6);
            						}
            						else {
HXDLIN( 218)							min19 = ::Math_obj::ceil(ay2);
            						}
HXDLIN( 218)						int ii_min38 = min19;
HXDLIN( 218)						int ii_max38 = ::Math_obj::ceil(by2);
HXDLIN( 218)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            					}
            					else {
HXDLIN( 218)						int ii_min39 = ::Math_obj::floor(ay2);
HXDLIN( 218)						int ii_max39 = ::Math_obj::ceil(dy6);
HXDLIN( 218)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            					}
            				}
HXDLIN( 218)				 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 218)				if (hasUndo4) {
HXDLIN( 218)					int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 218)					int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 218)					 ::Dynamic imageType4 = null();
HXDLIN( 218)					 ::pi_xy::ImageStruct this126 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 218)					if (::hx::IsNull( imageType4 )) {
HXLINE(  54)						imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 218)					::Dynamic undoImage13;
HXDLIN( 218)					switch((int)(( (int)(imageType4) ))){
            						case (int)0: {
HXDLIN( 218)							 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::BytesImg b35 = byt4;
HXDLIN( 218)							{
HXDLIN( 218)								b35->width = width4;
HXDLIN( 218)								b35->height = height4;
HXDLIN( 218)								b35->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 218)								b35->data = ::haxe::io::Bytes_obj::alloc((b35->length * 4));
HXDLIN( 218)								{
HXDLIN( 218)									int len8 = b35->length;
HXDLIN( 218)									int w4 = 0;
HXDLIN( 218)									{
HXDLIN( 218)										int _g80 = 0;
HXDLIN( 218)										int _g81 = b35->height;
HXDLIN( 218)										while((_g80 < _g81)){
HXDLIN( 218)											_g80 = (_g80 + 1);
HXDLIN( 218)											int y12 = (_g80 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												int _g82 = 0;
HXDLIN( 218)												int _g83 = b35->width;
HXDLIN( 218)												while((_g82 < _g83)){
HXDLIN( 218)													_g82 = (_g82 + 1);
HXDLIN( 218)													int x12 = (_g82 - 1);
HXDLIN( 218)													{
HXDLIN( 218)														w4 = (w4 + 1);
HXDLIN( 218)														b35->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 218)													{
HXDLIN( 218)														w4 = (w4 + 1);
HXDLIN( 218)														b35->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 218)													{
HXDLIN( 218)														w4 = (w4 + 1);
HXDLIN( 218)														b35->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 218)													{
HXDLIN( 218)														w4 = (w4 + 1);
HXDLIN( 218)														b35->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 218)							undoImage13 = b35;
            						}
            						break;
            						case (int)1: {
HXDLIN( 218)							 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::ArrIntImg a38 = arrI4;
HXDLIN( 218)							{
HXDLIN( 218)								a38->width = width4;
HXDLIN( 218)								a38->height = height4;
HXDLIN( 218)								a38->data = ::Array_obj< int >::__new(0);
HXDLIN( 218)								a38->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 218)								{
HXDLIN( 218)									int _g84 = 0;
HXDLIN( 218)									int _g85 = a38->length;
HXDLIN( 218)									while((_g84 < _g85)){
HXDLIN( 218)										_g84 = (_g84 + 1);
HXDLIN( 218)										int i40 = (_g84 - 1);
HXDLIN( 218)										a38->data[i40] = 0;
            									}
            								}
            							}
HXDLIN( 218)							undoImage13 = a38;
            						}
            						break;
            						case (int)2: {
HXDLIN( 218)							 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::U32ArrImg b36 = u32a4;
HXDLIN( 218)							{
HXDLIN( 218)								b36->width = width4;
HXDLIN( 218)								b36->height = height4;
HXDLIN( 218)								b36->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 218)								int size4 = (b36->length * 4);
HXDLIN( 218)								b36->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 218)								{
HXDLIN( 218)									int _g86 = 0;
HXDLIN( 218)									int _g87 = b36->length;
HXDLIN( 218)									while((_g86 < _g87)){
HXDLIN( 218)										_g86 = (_g86 + 1);
HXDLIN( 218)										int i41 = (_g86 - 1);
HXDLIN( 218)										{
HXDLIN( 218)											 ::haxe::io::ArrayBufferViewImpl this127 = b36->data;
HXDLIN( 218)											bool undoImage14;
HXDLIN( 218)											if ((i41 >= 0)) {
HXDLIN( 218)												undoImage14 = (i41 < (this127->byteLength >> 2));
            											}
            											else {
HXDLIN( 218)												undoImage14 = false;
            											}
HXDLIN( 218)											if (undoImage14) {
HXDLIN( 218)												 ::haxe::io::Bytes _this4 = this127->bytes;
HXDLIN( 218)												int pos4 = ((i41 << 2) + this127->byteOffset);
HXDLIN( 218)												_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 218)												_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 218)												_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 218)												_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 218)							undoImage13 = b36;
            						}
            						break;
            						case (int)3: {
HXDLIN( 218)							 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::VecIntImg v12 = vec4;
HXDLIN( 218)							{
HXDLIN( 218)								v12->width = width4;
HXDLIN( 218)								v12->height = height4;
HXDLIN( 218)								v12->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 218)								v12->data = ::Array_obj< int >::__new(v12->length);
HXDLIN( 218)								{
HXDLIN( 218)									int _g88 = 0;
HXDLIN( 218)									int _g89 = v12->length;
HXDLIN( 218)									while((_g88 < _g89)){
HXDLIN( 218)										_g88 = (_g88 + 1);
HXDLIN( 218)										int i42 = (_g88 - 1);
HXDLIN( 218)										v12->data->__unsafe_set(i42,0);
            									}
            								}
            							}
HXDLIN( 218)							undoImage13 = v12;
            						}
            						break;
            						case (int)4: {
HXDLIN( 218)							 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::StackIntImg b37 = sInt4;
HXDLIN( 218)							{
HXDLIN( 218)								b37->width = width4;
HXDLIN( 218)								b37->height = height4;
HXDLIN( 218)								b37->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 218)								b37->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 218)								{
HXDLIN( 218)									int len9 = b37->length;
HXDLIN( 218)									 ::haxe::ds::GenericStack_Int d4 = b37->data;
HXDLIN( 218)									if (::hx::IsNull( d4->head )) {
HXDLIN( 218)										int _g90 = 0;
HXDLIN( 218)										int _g91 = len9;
HXDLIN( 218)										while((_g90 < _g91)){
HXDLIN( 218)											_g90 = (_g90 + 1);
HXDLIN( 218)											int i43 = (_g90 - 1);
HXDLIN( 218)											d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            										}
            									}
            									else {
HXDLIN( 218)										int _g92 = 0;
HXDLIN( 218)										int _g93 = len9;
HXDLIN( 218)										while((_g92 < _g93)){
HXDLIN( 218)											_g92 = (_g92 + 1);
HXDLIN( 218)											int i44 = (_g92 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												 ::haxe::ds::GenericCell_Int l4 = b37->data->head;
HXDLIN( 218)												 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 218)												{
HXDLIN( 218)													int _g94 = 0;
HXDLIN( 218)													int _g95 = i44;
HXDLIN( 218)													while((_g94 < _g95)){
HXDLIN( 218)														_g94 = (_g94 + 1);
HXDLIN( 218)														int i45 = (_g94 - 1);
HXLINE( 345)														prev4 = l4;
HXLINE( 346)														l4 = l4->next;
            													}
            												}
HXLINE( 218)												if (::hx::IsNull( prev4 )) {
HXDLIN( 218)													b37->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 218)													l4 = null();
            												}
            												else {
HXDLIN( 218)													prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 218)													l4 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 218)							undoImage13 = b37;
            						}
            						break;
            					}
HXDLIN( 218)					this126->image = undoImage13;
HXDLIN( 218)					this126->width = width4;
HXDLIN( 218)					this126->height = height4;
HXDLIN( 218)					this126->imageType = ( (int)(imageType4) );
HXDLIN( 218)					undoImage12 = this126;
HXDLIN( 218)					{
HXDLIN( 218)						int rectLeft4 = xIter34->start;
HXDLIN( 218)						int rectTop4 = yIter34->start;
HXDLIN( 218)						int rectRight4 = xIter34->max;
HXDLIN( 218)						bool forceClear4 = false;
HXDLIN( 218)						{
HXDLIN( 218)							int _g96 = rectTop4;
HXDLIN( 218)							int _g97 = yIter34->max;
HXDLIN( 218)							while((_g96 < _g97)){
HXDLIN( 218)								_g96 = (_g96 + 1);
HXDLIN( 218)								int dy7 = (_g96 - 1);
HXDLIN( 218)								{
HXDLIN( 218)									int _g98 = rectLeft4;
HXDLIN( 218)									int _g99 = rectRight4;
HXDLIN( 218)									while((_g98 < _g99)){
HXDLIN( 218)										_g98 = (_g98 + 1);
HXDLIN( 218)										int dx7 = (_g98 - 1);
HXDLIN( 218)										::Dynamic this128 = this1->image;
HXDLIN( 218)										int index16;
HXDLIN( 218)										if (this1->useVirtualPos) {
HXDLIN( 218)											index16 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx7) - this1->virtualX));
            										}
            										else {
HXDLIN( 218)											index16 = ::Std_obj::_hx_int(( (Float)(((dy7 * this1->width) + dx7)) ));
            										}
HXDLIN( 218)										int c12 = ::iterMagic::Iimg_obj::get(this128,index16);
HXDLIN( 218)										int col4;
HXDLIN( 218)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)											col4 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 218)											col4 = c12;
            										}
HXDLIN( 218)										bool hitQuad33;
HXDLIN( 218)										if (this1->useMask) {
HXDLIN( 218)											hitQuad33 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 218)											hitQuad33 = false;
            										}
HXDLIN( 218)										if (hitQuad33) {
HXDLIN( 218)											 ::pi_xy::ImageStruct this129 = this1->mask;
HXDLIN( 218)											::Dynamic this130 = this129->image;
HXDLIN( 218)											int index17;
HXDLIN( 218)											if (this129->useVirtualPos) {
HXDLIN( 218)												index17 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this129->virtualY) * ( (Float)(this129->width) )) + dx7) - this129->virtualX));
            											}
            											else {
HXDLIN( 218)												index17 = ::Std_obj::_hx_int(( (Float)(((dy7 * this129->width) + dx7)) ));
            											}
HXDLIN( 218)											int c13 = ::iterMagic::Iimg_obj::get(this130,index17);
HXDLIN( 218)											int v13;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												v13 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												v13 = c13;
            											}
HXDLIN( 218)											int maskPixel4 = v13;
HXDLIN( 218)											int this131 = col4;
HXDLIN( 218)											if ((maskPixel4 == 0)) {
HXDLIN( 218)												col4 = this131;
            											}
            											else {
HXDLIN( 218)												Float m04;
HXDLIN( 218)												int this132 = ((maskPixel4 >> 24) & 255);
HXDLIN( 218)												if ((this132 == 0)) {
HXDLIN( 218)													m04 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													m04 = (( (Float)(this132) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float m14;
HXDLIN( 218)												int this133 = ((maskPixel4 >> 16) & 255);
HXDLIN( 218)												if ((this133 == 0)) {
HXDLIN( 218)													m14 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													m14 = (( (Float)(this133) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float m24;
HXDLIN( 218)												int this134 = ((maskPixel4 >> 8) & 255);
HXDLIN( 218)												if ((this134 == 0)) {
HXDLIN( 218)													m24 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													m24 = (( (Float)(this134) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float m34;
HXDLIN( 218)												int this135 = (maskPixel4 & 255);
HXDLIN( 218)												if ((this135 == 0)) {
HXDLIN( 218)													m34 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													m34 = (( (Float)(this135) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this131 >> 24) & 255)) )));
HXDLIN( 218)												int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this131 >> 16) & 255)) )));
HXDLIN( 218)												int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this131 >> 8) & 255)) )));
HXDLIN( 218)												int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this131 & 255)) )));
HXDLIN( 218)												col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 218)										if ((col4 != 0)) {
HXDLIN( 218)											int x13 = (dx7 - rectLeft4);
HXDLIN( 218)											int y13 = (dy7 - rectTop4);
HXDLIN( 218)											int c14 = col4;
HXDLIN( 218)											bool hitQuad34;
HXDLIN( 218)											if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 218)												hitQuad34 = undoImage12->transparent;
            											}
            											else {
HXDLIN( 218)												hitQuad34 = false;
            											}
HXDLIN( 218)											if (hitQuad34) {
HXDLIN( 218)												int location8;
HXDLIN( 218)												if (undoImage12->useVirtualPos) {
HXDLIN( 218)													location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x13) - undoImage12->virtualX));
            												}
            												else {
HXDLIN( 218)													location8 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage12->width) + x13)) ));
            												}
HXDLIN( 218)												int this136 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 218)												int this137;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													this137 = ((((((this136 >> 24) & 255) << 24) | ((this136 & 255) << 16)) | (((this136 >> 8) & 255) << 8)) | ((this136 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													this137 = this136;
            												}
HXDLIN( 218)												Float a112;
HXDLIN( 218)												int this138 = ((this137 >> 24) & 255);
HXDLIN( 218)												if ((this138 == 0)) {
HXDLIN( 218)													a112 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a112 = (( (Float)(this138) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r110;
HXDLIN( 218)												int this139 = ((this137 >> 16) & 255);
HXDLIN( 218)												if ((this139 == 0)) {
HXDLIN( 218)													r110 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r110 = (( (Float)(this139) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g110;
HXDLIN( 218)												int this140 = ((this137 >> 8) & 255);
HXDLIN( 218)												if ((this140 == 0)) {
HXDLIN( 218)													g110 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g110 = (( (Float)(this140) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b113;
HXDLIN( 218)												int this141 = (this137 & 255);
HXDLIN( 218)												if ((this141 == 0)) {
HXDLIN( 218)													b113 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b113 = (( (Float)(this141) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a211;
HXDLIN( 218)												int this142 = ((col4 >> 24) & 255);
HXDLIN( 218)												if ((this142 == 0)) {
HXDLIN( 218)													a211 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a211 = (( (Float)(this142) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r28;
HXDLIN( 218)												int this143 = ((col4 >> 16) & 255);
HXDLIN( 218)												if ((this143 == 0)) {
HXDLIN( 218)													r28 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r28 = (( (Float)(this143) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g28;
HXDLIN( 218)												int this144 = ((col4 >> 8) & 255);
HXDLIN( 218)												if ((this144 == 0)) {
HXDLIN( 218)													g28 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g28 = (( (Float)(this144) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b212;
HXDLIN( 218)												int this145 = (col4 & 255);
HXDLIN( 218)												if ((this145 == 0)) {
HXDLIN( 218)													b212 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b212 = (( (Float)(this145) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a39 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 218)												int r29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a39) + (r28 * a211))));
HXDLIN( 218)												int g29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a39) + (g28 * a211))));
HXDLIN( 218)												int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a39) + (b212 * a211))));
HXDLIN( 218)												int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a211)));
HXDLIN( 218)												int blended8 = ((((a40 << 24) | (r29 << 16)) | (g29 << 8)) | b38);
HXDLIN( 218)												{
HXDLIN( 218)													int hitQuad35;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad35 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad35 = blended8;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(undoImage12->image,location8,hitQuad35);
            												}
            											}
            											else {
HXDLIN( 218)												::Dynamic this146 = undoImage12->image;
HXDLIN( 218)												int index18;
HXDLIN( 218)												if (undoImage12->useVirtualPos) {
HXDLIN( 218)													index18 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x13) - undoImage12->virtualX));
            												}
            												else {
HXDLIN( 218)													index18 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage12->width) + x13)) ));
            												}
HXDLIN( 218)												int hitQuad36;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													hitQuad36 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													hitQuad36 = c14;
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this146,index18,hitQuad36);
            											}
            										}
            										else {
HXDLIN( 218)											if (forceClear4) {
HXDLIN( 218)												::Dynamic this147 = undoImage12->image;
HXDLIN( 218)												int x14 = (dx7 - rectLeft4);
HXDLIN( 218)												int y14 = (dy7 - rectTop4);
HXDLIN( 218)												int index19;
HXDLIN( 218)												if (undoImage12->useVirtualPos) {
HXDLIN( 218)													index19 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x14) - undoImage12->virtualX));
            												}
            												else {
HXDLIN( 218)													index19 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage12->width) + x14)) ));
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this147,index19,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 218)				{
HXDLIN( 218)					int _g_min8 = xIter34->start;
HXDLIN( 218)					int _g_max8 = xIter34->max;
HXDLIN( 218)					while((_g_min8 < _g_max8)){
HXDLIN( 218)						_g_min8 = (_g_min8 + 1);
HXDLIN( 218)						int px5 = (_g_min8 - 1);
HXDLIN( 218)						Float pcx4 = (( (Float)(px5) ) - dx6);
HXDLIN( 218)						{
HXDLIN( 218)							int _g_min9 = yIter34->start;
HXDLIN( 218)							int _g_max9 = yIter34->max;
HXDLIN( 218)							while((_g_min9 < _g_max9)){
HXDLIN( 218)								_g_min9 = (_g_min9 + 1);
HXDLIN( 218)								int py5 = (_g_min9 - 1);
HXDLIN( 218)								Float pcy4 = (( (Float)(py5) ) - dy6);
HXDLIN( 218)								Float dot314 = ((pcx4 * bcx4) + (pcy4 * bcy4));
HXDLIN( 218)								Float dot324 = ((pcx4 * acx4) + (pcy4 * acy4));
HXDLIN( 218)								Float ratioA4 = (((dot224 * dot314) - (dot124 * dot324)) * denom14);
HXDLIN( 218)								Float ratioB4 = (((dot114 * dot324) - (dot124 * dot314)) * denom14);
HXDLIN( 218)								Float ratioC4 = ((((Float)1.0) - ratioB4) - ratioA4);
HXDLIN( 218)								bool hitQuad37;
HXDLIN( 218)								bool hitQuad38;
HXDLIN( 218)								if ((ratioA4 >= 0)) {
HXDLIN( 218)									hitQuad38 = (ratioB4 >= 0);
            								}
            								else {
HXDLIN( 218)									hitQuad38 = false;
            								}
HXDLIN( 218)								if (hitQuad38) {
HXDLIN( 218)									hitQuad37 = (ratioC4 >= 0);
            								}
            								else {
HXDLIN( 218)									hitQuad37 = false;
            								}
HXDLIN( 218)								if (hitQuad37) {
HXDLIN( 218)									int i46 = ::Std_obj::_hx_int((((( (Float)(aA4) ) * ratioA4) + (( (Float)(aB4) ) * ratioB4)) + (( (Float)(aC4) ) * ratioC4)));
HXDLIN( 218)									if ((i46 > 255)) {
HXLINE(  24)										i46 = 255;
            									}
HXLINE( 218)									if ((i46 < 0)) {
HXLINE(  25)										i46 = 0;
            									}
HXLINE( 218)									int a41 = i46;
HXDLIN( 218)									int i47 = ::Std_obj::_hx_int((((( (Float)(rA4) ) * ratioA4) + (( (Float)(rB4) ) * ratioB4)) + (( (Float)(rC4) ) * ratioC4)));
HXDLIN( 218)									if ((i47 > 255)) {
HXLINE(  24)										i47 = 255;
            									}
HXLINE( 218)									if ((i47 < 0)) {
HXLINE(  25)										i47 = 0;
            									}
HXLINE( 218)									int r30 = i47;
HXDLIN( 218)									int i48 = ::Std_obj::_hx_int((((( (Float)(gA4) ) * ratioA4) + (( (Float)(gB4) ) * ratioB4)) + (( (Float)(gC4) ) * ratioC4)));
HXDLIN( 218)									if ((i48 > 255)) {
HXLINE(  24)										i48 = 255;
            									}
HXLINE( 218)									if ((i48 < 0)) {
HXLINE(  25)										i48 = 0;
            									}
HXLINE( 218)									int g30 = i48;
HXDLIN( 218)									int i49 = ::Std_obj::_hx_int((((( (Float)(bA4) ) * ratioA4) + (( (Float)(bB4) ) * ratioB4)) + (( (Float)(bC4) ) * ratioC4)));
HXDLIN( 218)									if ((i49 > 255)) {
HXLINE(  24)										i49 = 255;
            									}
HXLINE( 218)									if ((i49 < 0)) {
HXLINE(  25)										i49 = 0;
            									}
HXLINE( 218)									int b39 = i49;
HXDLIN( 218)									{
HXDLIN( 218)										int location9;
HXDLIN( 218)										if (this1->useVirtualPos) {
HXDLIN( 218)											location9 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - this1->virtualY) * ( (Float)(this1->width) )) + px5) - this1->virtualX));
            										}
            										else {
HXDLIN( 218)											location9 = ::Std_obj::_hx_int(( (Float)(((py5 * this1->width) + px5)) ));
            										}
HXDLIN( 218)										bool hitQuad39;
HXDLIN( 218)										if (this1->transparent) {
HXDLIN( 218)											hitQuad39 = (a41 < 254);
            										}
            										else {
HXDLIN( 218)											hitQuad39 = false;
            										}
HXDLIN( 218)										if (hitQuad39) {
HXDLIN( 218)											int this148 = ::iterMagic::Iimg_obj::get(this1->image,location9);
HXDLIN( 218)											int old4;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												old4 = ((((((this148 >> 24) & 255) << 24) | ((this148 & 255) << 16)) | (((this148 >> 8) & 255) << 8)) | ((this148 >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												old4 = this148;
            											}
HXDLIN( 218)											int rhs4 = ((((a41 << 24) | (r30 << 16)) | (g30 << 8)) | b39);
HXDLIN( 218)											Float a113;
HXDLIN( 218)											int this149 = ((old4 >> 24) & 255);
HXDLIN( 218)											if ((this149 == 0)) {
HXDLIN( 218)												a113 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												a113 = (( (Float)(this149) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float r111;
HXDLIN( 218)											int this150 = ((old4 >> 16) & 255);
HXDLIN( 218)											if ((this150 == 0)) {
HXDLIN( 218)												r111 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												r111 = (( (Float)(this150) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float g111;
HXDLIN( 218)											int this151 = ((old4 >> 8) & 255);
HXDLIN( 218)											if ((this151 == 0)) {
HXDLIN( 218)												g111 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												g111 = (( (Float)(this151) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float b114;
HXDLIN( 218)											int this152 = (old4 & 255);
HXDLIN( 218)											if ((this152 == 0)) {
HXDLIN( 218)												b114 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												b114 = (( (Float)(this152) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float a212;
HXDLIN( 218)											int this153 = ((rhs4 >> 24) & 255);
HXDLIN( 218)											if ((this153 == 0)) {
HXDLIN( 218)												a212 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												a212 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float r210;
HXDLIN( 218)											int this154 = ((rhs4 >> 16) & 255);
HXDLIN( 218)											if ((this154 == 0)) {
HXDLIN( 218)												r210 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float g210;
HXDLIN( 218)											int this155 = ((rhs4 >> 8) & 255);
HXDLIN( 218)											if ((this155 == 0)) {
HXDLIN( 218)												g210 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float b213;
HXDLIN( 218)											int this156 = (rhs4 & 255);
HXDLIN( 218)											if ((this156 == 0)) {
HXDLIN( 218)												b213 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												b213 = (( (Float)(this156) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float a310 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 218)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a310) + (r210 * a212))));
HXDLIN( 218)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a310) + (g210 * a212))));
HXDLIN( 218)											int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b213 * a212))));
HXDLIN( 218)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a212)));
HXDLIN( 218)											int blended9 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b40);
HXDLIN( 218)											{
HXDLIN( 218)												int hitQuad40;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													hitQuad40 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													hitQuad40 = blended9;
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this1->image,location9,hitQuad40);
            											}
            										}
            										else {
HXDLIN( 218)											int value4;
HXDLIN( 218)											if (this1->isLittle) {
HXDLIN( 218)												value4 = ((((a41 << 24) | (b39 << 16)) | (g30 << 8)) | r30);
            											}
            											else {
HXDLIN( 218)												value4 = ((((a41 << 24) | (r30 << 16)) | (g30 << 8)) | b39);
            											}
HXDLIN( 218)											::iterMagic::Iimg_obj::set(this1->image,location9,value4);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 218)			{
HXDLIN( 218)				bool hasHit3 = false;
HXDLIN( 218)				bool hasUndo5 = false;
HXDLIN( 218)				int aA5 = ((color2 >> 24) & 255);
HXDLIN( 218)				int rA5 = ((color2 >> 16) & 255);
HXDLIN( 218)				int gA5 = ((color2 >> 8) & 255);
HXDLIN( 218)				int bA5 = (color2 & 255);
HXDLIN( 218)				int aB5 = ((color1 >> 24) & 255);
HXDLIN( 218)				int rB5 = ((color1 >> 16) & 255);
HXDLIN( 218)				int gB5 = ((color1 >> 8) & 255);
HXDLIN( 218)				int bB5 = (color1 & 255);
HXDLIN( 218)				int aC5 = ((color2 >> 24) & 255);
HXDLIN( 218)				int rC5 = ((color2 >> 16) & 255);
HXDLIN( 218)				int gC5 = ((color2 >> 8) & 255);
HXDLIN( 218)				int bC5 = (color2 & 255);
HXDLIN( 218)				Float bcx5 = (cx2 - dx6);
HXDLIN( 218)				Float bcy5 = (cy2 - dy6);
HXDLIN( 218)				Float acx5 = (bx2 - dx6);
HXDLIN( 218)				Float acy5 = (by2 - dy6);
HXDLIN( 218)				Float dot115 = ((bcx5 * bcx5) + (bcy5 * bcy5));
HXDLIN( 218)				Float dot125 = ((bcx5 * acx5) + (bcy5 * acy5));
HXDLIN( 218)				Float dot225 = ((acx5 * acx5) + (acy5 * acy5));
HXDLIN( 218)				Float denom15 = (( (Float)(1) ) / ((dot115 * dot225) - (dot125 * dot125)));
HXDLIN( 218)				 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 218)				if ((bx2 > cx2)) {
HXDLIN( 218)					if ((bx2 > dx6)) {
HXDLIN( 218)						int min20;
HXDLIN( 218)						if ((cx2 > dx6)) {
HXDLIN( 218)							min20 = ::Math_obj::floor(dx6);
            						}
            						else {
HXDLIN( 218)							min20 = ::Math_obj::floor(cx2);
            						}
HXDLIN( 218)						int ii_min40 = min20;
HXDLIN( 218)						int ii_max40 = ::Math_obj::ceil(bx2);
HXDLIN( 218)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            					}
            					else {
HXDLIN( 218)						int ii_min41 = ::Math_obj::floor(cx2);
HXDLIN( 218)						int ii_max41 = ::Math_obj::ceil(dx6);
HXDLIN( 218)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            					}
            				}
            				else {
HXDLIN( 218)					if ((cx2 > dx6)) {
HXDLIN( 218)						int min21;
HXDLIN( 218)						if ((bx2 > dx6)) {
HXDLIN( 218)							min21 = ::Math_obj::floor(dx6);
            						}
            						else {
HXDLIN( 218)							min21 = ::Math_obj::ceil(bx2);
            						}
HXDLIN( 218)						int ii_min42 = min21;
HXDLIN( 218)						int ii_max42 = ::Math_obj::ceil(cx2);
HXDLIN( 218)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            					}
            					else {
HXDLIN( 218)						int ii_min43 = ::Math_obj::floor(bx2);
HXDLIN( 218)						int ii_max43 = ::Math_obj::ceil(dx6);
HXDLIN( 218)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            					}
            				}
HXDLIN( 218)				 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 218)				if ((by2 > cy2)) {
HXDLIN( 218)					if ((by2 > dy6)) {
HXDLIN( 218)						int min22;
HXDLIN( 218)						if ((cy2 > dy6)) {
HXDLIN( 218)							min22 = ::Math_obj::floor(dy6);
            						}
            						else {
HXDLIN( 218)							min22 = ::Math_obj::floor(cy2);
            						}
HXDLIN( 218)						int ii_min44 = min22;
HXDLIN( 218)						int ii_max44 = ::Math_obj::ceil(by2);
HXDLIN( 218)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            					}
            					else {
HXDLIN( 218)						int ii_min45 = ::Math_obj::floor(cy2);
HXDLIN( 218)						int ii_max45 = ::Math_obj::ceil(dy6);
HXDLIN( 218)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            					}
            				}
            				else {
HXDLIN( 218)					if ((cy2 > dy6)) {
HXDLIN( 218)						int min23;
HXDLIN( 218)						if ((by2 > dy6)) {
HXDLIN( 218)							min23 = ::Math_obj::floor(dy6);
            						}
            						else {
HXDLIN( 218)							min23 = ::Math_obj::ceil(by2);
            						}
HXDLIN( 218)						int ii_min46 = min23;
HXDLIN( 218)						int ii_max46 = ::Math_obj::ceil(cy2);
HXDLIN( 218)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            					}
            					else {
HXDLIN( 218)						int ii_min47 = ::Math_obj::floor(by2);
HXDLIN( 218)						int ii_max47 = ::Math_obj::ceil(dy6);
HXDLIN( 218)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            					}
            				}
HXDLIN( 218)				 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 218)				if (hasUndo5) {
HXDLIN( 218)					int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 218)					int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 218)					 ::Dynamic imageType5 = null();
HXDLIN( 218)					 ::pi_xy::ImageStruct this157 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 218)					if (::hx::IsNull( imageType5 )) {
HXLINE(  54)						imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 218)					::Dynamic undoImage16;
HXDLIN( 218)					switch((int)(( (int)(imageType5) ))){
            						case (int)0: {
HXDLIN( 218)							 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::BytesImg b41 = byt5;
HXDLIN( 218)							{
HXDLIN( 218)								b41->width = width5;
HXDLIN( 218)								b41->height = height5;
HXDLIN( 218)								b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 218)								b41->data = ::haxe::io::Bytes_obj::alloc((b41->length * 4));
HXDLIN( 218)								{
HXDLIN( 218)									int len10 = b41->length;
HXDLIN( 218)									int w5 = 0;
HXDLIN( 218)									{
HXDLIN( 218)										int _g100 = 0;
HXDLIN( 218)										int _g101 = b41->height;
HXDLIN( 218)										while((_g100 < _g101)){
HXDLIN( 218)											_g100 = (_g100 + 1);
HXDLIN( 218)											int y15 = (_g100 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												int _g102 = 0;
HXDLIN( 218)												int _g103 = b41->width;
HXDLIN( 218)												while((_g102 < _g103)){
HXDLIN( 218)													_g102 = (_g102 + 1);
HXDLIN( 218)													int x15 = (_g102 - 1);
HXDLIN( 218)													{
HXDLIN( 218)														w5 = (w5 + 1);
HXDLIN( 218)														b41->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 218)													{
HXDLIN( 218)														w5 = (w5 + 1);
HXDLIN( 218)														b41->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 218)													{
HXDLIN( 218)														w5 = (w5 + 1);
HXDLIN( 218)														b41->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 218)													{
HXDLIN( 218)														w5 = (w5 + 1);
HXDLIN( 218)														b41->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 218)							undoImage16 = b41;
            						}
            						break;
            						case (int)1: {
HXDLIN( 218)							 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::ArrIntImg a43 = arrI5;
HXDLIN( 218)							{
HXDLIN( 218)								a43->width = width5;
HXDLIN( 218)								a43->height = height5;
HXDLIN( 218)								a43->data = ::Array_obj< int >::__new(0);
HXDLIN( 218)								a43->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 218)								{
HXDLIN( 218)									int _g104 = 0;
HXDLIN( 218)									int _g105 = a43->length;
HXDLIN( 218)									while((_g104 < _g105)){
HXDLIN( 218)										_g104 = (_g104 + 1);
HXDLIN( 218)										int i50 = (_g104 - 1);
HXDLIN( 218)										a43->data[i50] = 0;
            									}
            								}
            							}
HXDLIN( 218)							undoImage16 = a43;
            						}
            						break;
            						case (int)2: {
HXDLIN( 218)							 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::U32ArrImg b42 = u32a5;
HXDLIN( 218)							{
HXDLIN( 218)								b42->width = width5;
HXDLIN( 218)								b42->height = height5;
HXDLIN( 218)								b42->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 218)								int size5 = (b42->length * 4);
HXDLIN( 218)								b42->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 218)								{
HXDLIN( 218)									int _g106 = 0;
HXDLIN( 218)									int _g107 = b42->length;
HXDLIN( 218)									while((_g106 < _g107)){
HXDLIN( 218)										_g106 = (_g106 + 1);
HXDLIN( 218)										int i51 = (_g106 - 1);
HXDLIN( 218)										{
HXDLIN( 218)											 ::haxe::io::ArrayBufferViewImpl this158 = b42->data;
HXDLIN( 218)											bool undoImage17;
HXDLIN( 218)											if ((i51 >= 0)) {
HXDLIN( 218)												undoImage17 = (i51 < (this158->byteLength >> 2));
            											}
            											else {
HXDLIN( 218)												undoImage17 = false;
            											}
HXDLIN( 218)											if (undoImage17) {
HXDLIN( 218)												 ::haxe::io::Bytes _this5 = this158->bytes;
HXDLIN( 218)												int pos5 = ((i51 << 2) + this158->byteOffset);
HXDLIN( 218)												_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 218)												_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 218)												_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 218)												_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 218)							undoImage16 = b42;
            						}
            						break;
            						case (int)3: {
HXDLIN( 218)							 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::VecIntImg v14 = vec5;
HXDLIN( 218)							{
HXDLIN( 218)								v14->width = width5;
HXDLIN( 218)								v14->height = height5;
HXDLIN( 218)								v14->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 218)								v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN( 218)								{
HXDLIN( 218)									int _g108 = 0;
HXDLIN( 218)									int _g109 = v14->length;
HXDLIN( 218)									while((_g108 < _g109)){
HXDLIN( 218)										_g108 = (_g108 + 1);
HXDLIN( 218)										int i52 = (_g108 - 1);
HXDLIN( 218)										v14->data->__unsafe_set(i52,0);
            									}
            								}
            							}
HXDLIN( 218)							undoImage16 = v14;
            						}
            						break;
            						case (int)4: {
HXDLIN( 218)							 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)							 ::iterMagic::StackIntImg b43 = sInt5;
HXDLIN( 218)							{
HXDLIN( 218)								b43->width = width5;
HXDLIN( 218)								b43->height = height5;
HXDLIN( 218)								b43->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 218)								b43->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 218)								{
HXDLIN( 218)									int len11 = b43->length;
HXDLIN( 218)									 ::haxe::ds::GenericStack_Int d5 = b43->data;
HXDLIN( 218)									if (::hx::IsNull( d5->head )) {
HXDLIN( 218)										int _g110 = 0;
HXDLIN( 218)										int _g111 = len11;
HXDLIN( 218)										while((_g110 < _g111)){
HXDLIN( 218)											_g110 = (_g110 + 1);
HXDLIN( 218)											int i53 = (_g110 - 1);
HXDLIN( 218)											d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            										}
            									}
            									else {
HXDLIN( 218)										int _g112 = 0;
HXDLIN( 218)										int _g113 = len11;
HXDLIN( 218)										while((_g112 < _g113)){
HXDLIN( 218)											_g112 = (_g112 + 1);
HXDLIN( 218)											int i54 = (_g112 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												 ::haxe::ds::GenericCell_Int l5 = b43->data->head;
HXDLIN( 218)												 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 218)												{
HXDLIN( 218)													int _g114 = 0;
HXDLIN( 218)													int _g115 = i54;
HXDLIN( 218)													while((_g114 < _g115)){
HXDLIN( 218)														_g114 = (_g114 + 1);
HXDLIN( 218)														int i55 = (_g114 - 1);
HXLINE( 345)														prev5 = l5;
HXLINE( 346)														l5 = l5->next;
            													}
            												}
HXLINE( 218)												if (::hx::IsNull( prev5 )) {
HXDLIN( 218)													b43->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 218)													l5 = null();
            												}
            												else {
HXDLIN( 218)													prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 218)													l5 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 218)							undoImage16 = b43;
            						}
            						break;
            					}
HXDLIN( 218)					this157->image = undoImage16;
HXDLIN( 218)					this157->width = width5;
HXDLIN( 218)					this157->height = height5;
HXDLIN( 218)					this157->imageType = ( (int)(imageType5) );
HXDLIN( 218)					undoImage15 = this157;
HXDLIN( 218)					{
HXDLIN( 218)						int rectLeft5 = xIter35->start;
HXDLIN( 218)						int rectTop5 = yIter35->start;
HXDLIN( 218)						int rectRight5 = xIter35->max;
HXDLIN( 218)						bool forceClear5 = false;
HXDLIN( 218)						{
HXDLIN( 218)							int _g116 = rectTop5;
HXDLIN( 218)							int _g117 = yIter35->max;
HXDLIN( 218)							while((_g116 < _g117)){
HXDLIN( 218)								_g116 = (_g116 + 1);
HXDLIN( 218)								int dy8 = (_g116 - 1);
HXDLIN( 218)								{
HXDLIN( 218)									int _g118 = rectLeft5;
HXDLIN( 218)									int _g119 = rectRight5;
HXDLIN( 218)									while((_g118 < _g119)){
HXDLIN( 218)										_g118 = (_g118 + 1);
HXDLIN( 218)										int dx8 = (_g118 - 1);
HXDLIN( 218)										::Dynamic this159 = this1->image;
HXDLIN( 218)										int index20;
HXDLIN( 218)										if (this1->useVirtualPos) {
HXDLIN( 218)											index20 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx8) - this1->virtualX));
            										}
            										else {
HXDLIN( 218)											index20 = ::Std_obj::_hx_int(( (Float)(((dy8 * this1->width) + dx8)) ));
            										}
HXDLIN( 218)										int c15 = ::iterMagic::Iimg_obj::get(this159,index20);
HXDLIN( 218)										int col5;
HXDLIN( 218)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)											col5 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXDLIN( 218)											col5 = c15;
            										}
HXDLIN( 218)										bool hitQuad41;
HXDLIN( 218)										if (this1->useMask) {
HXDLIN( 218)											hitQuad41 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 218)											hitQuad41 = false;
            										}
HXDLIN( 218)										if (hitQuad41) {
HXDLIN( 218)											 ::pi_xy::ImageStruct this160 = this1->mask;
HXDLIN( 218)											::Dynamic this161 = this160->image;
HXDLIN( 218)											int index21;
HXDLIN( 218)											if (this160->useVirtualPos) {
HXDLIN( 218)												index21 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this160->virtualY) * ( (Float)(this160->width) )) + dx8) - this160->virtualX));
            											}
            											else {
HXDLIN( 218)												index21 = ::Std_obj::_hx_int(( (Float)(((dy8 * this160->width) + dx8)) ));
            											}
HXDLIN( 218)											int c16 = ::iterMagic::Iimg_obj::get(this161,index21);
HXDLIN( 218)											int v15;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												v15 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												v15 = c16;
            											}
HXDLIN( 218)											int maskPixel5 = v15;
HXDLIN( 218)											int this162 = col5;
HXDLIN( 218)											if ((maskPixel5 == 0)) {
HXDLIN( 218)												col5 = this162;
            											}
            											else {
HXDLIN( 218)												Float m05;
HXDLIN( 218)												int this163 = ((maskPixel5 >> 24) & 255);
HXDLIN( 218)												if ((this163 == 0)) {
HXDLIN( 218)													m05 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													m05 = (( (Float)(this163) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float m15;
HXDLIN( 218)												int this164 = ((maskPixel5 >> 16) & 255);
HXDLIN( 218)												if ((this164 == 0)) {
HXDLIN( 218)													m15 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													m15 = (( (Float)(this164) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float m25;
HXDLIN( 218)												int this165 = ((maskPixel5 >> 8) & 255);
HXDLIN( 218)												if ((this165 == 0)) {
HXDLIN( 218)													m25 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													m25 = (( (Float)(this165) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float m35;
HXDLIN( 218)												int this166 = (maskPixel5 & 255);
HXDLIN( 218)												if ((this166 == 0)) {
HXDLIN( 218)													m35 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													m35 = (( (Float)(this166) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this162 >> 24) & 255)) )));
HXDLIN( 218)												int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this162 >> 16) & 255)) )));
HXDLIN( 218)												int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this162 >> 8) & 255)) )));
HXDLIN( 218)												int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this162 & 255)) )));
HXDLIN( 218)												col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 218)										if ((col5 != 0)) {
HXDLIN( 218)											int x16 = (dx8 - rectLeft5);
HXDLIN( 218)											int y16 = (dy8 - rectTop5);
HXDLIN( 218)											int c17 = col5;
HXDLIN( 218)											bool hitQuad42;
HXDLIN( 218)											if ((((c17 >> 24) & 255) < 254)) {
HXDLIN( 218)												hitQuad42 = undoImage15->transparent;
            											}
            											else {
HXDLIN( 218)												hitQuad42 = false;
            											}
HXDLIN( 218)											if (hitQuad42) {
HXDLIN( 218)												int location10;
HXDLIN( 218)												if (undoImage15->useVirtualPos) {
HXDLIN( 218)													location10 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x16) - undoImage15->virtualX));
            												}
            												else {
HXDLIN( 218)													location10 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage15->width) + x16)) ));
            												}
HXDLIN( 218)												int this167 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 218)												int this168;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													this168 = ((((((this167 >> 24) & 255) << 24) | ((this167 & 255) << 16)) | (((this167 >> 8) & 255) << 8)) | ((this167 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													this168 = this167;
            												}
HXDLIN( 218)												Float a114;
HXDLIN( 218)												int this169 = ((this168 >> 24) & 255);
HXDLIN( 218)												if ((this169 == 0)) {
HXDLIN( 218)													a114 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a114 = (( (Float)(this169) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r112;
HXDLIN( 218)												int this170 = ((this168 >> 16) & 255);
HXDLIN( 218)												if ((this170 == 0)) {
HXDLIN( 218)													r112 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r112 = (( (Float)(this170) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g112;
HXDLIN( 218)												int this171 = ((this168 >> 8) & 255);
HXDLIN( 218)												if ((this171 == 0)) {
HXDLIN( 218)													g112 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g112 = (( (Float)(this171) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b115;
HXDLIN( 218)												int this172 = (this168 & 255);
HXDLIN( 218)												if ((this172 == 0)) {
HXDLIN( 218)													b115 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b115 = (( (Float)(this172) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a213;
HXDLIN( 218)												int this173 = ((col5 >> 24) & 255);
HXDLIN( 218)												if ((this173 == 0)) {
HXDLIN( 218)													a213 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													a213 = (( (Float)(this173) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float r211;
HXDLIN( 218)												int this174 = ((col5 >> 16) & 255);
HXDLIN( 218)												if ((this174 == 0)) {
HXDLIN( 218)													r211 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													r211 = (( (Float)(this174) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float g211;
HXDLIN( 218)												int this175 = ((col5 >> 8) & 255);
HXDLIN( 218)												if ((this175 == 0)) {
HXDLIN( 218)													g211 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													g211 = (( (Float)(this175) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float b214;
HXDLIN( 218)												int this176 = (col5 & 255);
HXDLIN( 218)												if ((this176 == 0)) {
HXDLIN( 218)													b214 = ((Float)0.);
            												}
            												else {
HXDLIN( 218)													b214 = (( (Float)(this176) ) / ( (Float)(255) ));
            												}
HXDLIN( 218)												Float a311 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 218)												int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a311) + (r211 * a213))));
HXDLIN( 218)												int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a311) + (g211 * a213))));
HXDLIN( 218)												int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b214 * a213))));
HXDLIN( 218)												int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a213)));
HXDLIN( 218)												int blended10 = ((((a44 << 24) | (r32 << 16)) | (g32 << 8)) | b44);
HXDLIN( 218)												{
HXDLIN( 218)													int hitQuad43;
HXDLIN( 218)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)														hitQuad43 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            													}
            													else {
HXDLIN( 218)														hitQuad43 = blended10;
            													}
HXDLIN( 218)													::iterMagic::Iimg_obj::set(undoImage15->image,location10,hitQuad43);
            												}
            											}
            											else {
HXDLIN( 218)												::Dynamic this177 = undoImage15->image;
HXDLIN( 218)												int index22;
HXDLIN( 218)												if (undoImage15->useVirtualPos) {
HXDLIN( 218)													index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x16) - undoImage15->virtualX));
            												}
            												else {
HXDLIN( 218)													index22 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage15->width) + x16)) ));
            												}
HXDLIN( 218)												int hitQuad44;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													hitQuad44 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													hitQuad44 = c17;
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this177,index22,hitQuad44);
            											}
            										}
            										else {
HXDLIN( 218)											if (forceClear5) {
HXDLIN( 218)												::Dynamic this178 = undoImage15->image;
HXDLIN( 218)												int x17 = (dx8 - rectLeft5);
HXDLIN( 218)												int y17 = (dy8 - rectTop5);
HXDLIN( 218)												int index23;
HXDLIN( 218)												if (undoImage15->useVirtualPos) {
HXDLIN( 218)													index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x17) - undoImage15->virtualX));
            												}
            												else {
HXDLIN( 218)													index23 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage15->width) + x17)) ));
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this178,index23,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 218)				{
HXDLIN( 218)					int _g_min10 = xIter35->start;
HXDLIN( 218)					int _g_max10 = xIter35->max;
HXDLIN( 218)					while((_g_min10 < _g_max10)){
HXDLIN( 218)						_g_min10 = (_g_min10 + 1);
HXDLIN( 218)						int px6 = (_g_min10 - 1);
HXDLIN( 218)						Float pcx5 = (( (Float)(px6) ) - dx6);
HXDLIN( 218)						{
HXDLIN( 218)							int _g_min11 = yIter35->start;
HXDLIN( 218)							int _g_max11 = yIter35->max;
HXDLIN( 218)							while((_g_min11 < _g_max11)){
HXDLIN( 218)								_g_min11 = (_g_min11 + 1);
HXDLIN( 218)								int py6 = (_g_min11 - 1);
HXDLIN( 218)								Float pcy5 = (( (Float)(py6) ) - dy6);
HXDLIN( 218)								Float dot315 = ((pcx5 * bcx5) + (pcy5 * bcy5));
HXDLIN( 218)								Float dot325 = ((pcx5 * acx5) + (pcy5 * acy5));
HXDLIN( 218)								Float ratioA5 = (((dot225 * dot315) - (dot125 * dot325)) * denom15);
HXDLIN( 218)								Float ratioB5 = (((dot115 * dot325) - (dot125 * dot315)) * denom15);
HXDLIN( 218)								Float ratioC5 = ((((Float)1.0) - ratioB5) - ratioA5);
HXDLIN( 218)								bool hitQuad45;
HXDLIN( 218)								bool hitQuad46;
HXDLIN( 218)								if ((ratioA5 >= 0)) {
HXDLIN( 218)									hitQuad46 = (ratioB5 >= 0);
            								}
            								else {
HXDLIN( 218)									hitQuad46 = false;
            								}
HXDLIN( 218)								if (hitQuad46) {
HXDLIN( 218)									hitQuad45 = (ratioC5 >= 0);
            								}
            								else {
HXDLIN( 218)									hitQuad45 = false;
            								}
HXDLIN( 218)								if (hitQuad45) {
HXDLIN( 218)									int i56 = ::Std_obj::_hx_int((((( (Float)(aA5) ) * ratioA5) + (( (Float)(aB5) ) * ratioB5)) + (( (Float)(aC5) ) * ratioC5)));
HXDLIN( 218)									if ((i56 > 255)) {
HXLINE(  24)										i56 = 255;
            									}
HXLINE( 218)									if ((i56 < 0)) {
HXLINE(  25)										i56 = 0;
            									}
HXLINE( 218)									int a45 = i56;
HXDLIN( 218)									int i57 = ::Std_obj::_hx_int((((( (Float)(rA5) ) * ratioA5) + (( (Float)(rB5) ) * ratioB5)) + (( (Float)(rC5) ) * ratioC5)));
HXDLIN( 218)									if ((i57 > 255)) {
HXLINE(  24)										i57 = 255;
            									}
HXLINE( 218)									if ((i57 < 0)) {
HXLINE(  25)										i57 = 0;
            									}
HXLINE( 218)									int r33 = i57;
HXDLIN( 218)									int i58 = ::Std_obj::_hx_int((((( (Float)(gA5) ) * ratioA5) + (( (Float)(gB5) ) * ratioB5)) + (( (Float)(gC5) ) * ratioC5)));
HXDLIN( 218)									if ((i58 > 255)) {
HXLINE(  24)										i58 = 255;
            									}
HXLINE( 218)									if ((i58 < 0)) {
HXLINE(  25)										i58 = 0;
            									}
HXLINE( 218)									int g33 = i58;
HXDLIN( 218)									int i59 = ::Std_obj::_hx_int((((( (Float)(bA5) ) * ratioA5) + (( (Float)(bB5) ) * ratioB5)) + (( (Float)(bC5) ) * ratioC5)));
HXDLIN( 218)									if ((i59 > 255)) {
HXLINE(  24)										i59 = 255;
            									}
HXLINE( 218)									if ((i59 < 0)) {
HXLINE(  25)										i59 = 0;
            									}
HXLINE( 218)									int b45 = i59;
HXDLIN( 218)									{
HXDLIN( 218)										int location11;
HXDLIN( 218)										if (this1->useVirtualPos) {
HXDLIN( 218)											location11 = ::Std_obj::_hx_int(((((( (Float)(py6) ) - this1->virtualY) * ( (Float)(this1->width) )) + px6) - this1->virtualX));
            										}
            										else {
HXDLIN( 218)											location11 = ::Std_obj::_hx_int(( (Float)(((py6 * this1->width) + px6)) ));
            										}
HXDLIN( 218)										bool hitQuad47;
HXDLIN( 218)										if (this1->transparent) {
HXDLIN( 218)											hitQuad47 = (a45 < 254);
            										}
            										else {
HXDLIN( 218)											hitQuad47 = false;
            										}
HXDLIN( 218)										if (hitQuad47) {
HXDLIN( 218)											int this179 = ::iterMagic::Iimg_obj::get(this1->image,location11);
HXDLIN( 218)											int old5;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												old5 = ((((((this179 >> 24) & 255) << 24) | ((this179 & 255) << 16)) | (((this179 >> 8) & 255) << 8)) | ((this179 >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												old5 = this179;
            											}
HXDLIN( 218)											int rhs5 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b45);
HXDLIN( 218)											Float a115;
HXDLIN( 218)											int this180 = ((old5 >> 24) & 255);
HXDLIN( 218)											if ((this180 == 0)) {
HXDLIN( 218)												a115 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												a115 = (( (Float)(this180) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float r113;
HXDLIN( 218)											int this181 = ((old5 >> 16) & 255);
HXDLIN( 218)											if ((this181 == 0)) {
HXDLIN( 218)												r113 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												r113 = (( (Float)(this181) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float g113;
HXDLIN( 218)											int this182 = ((old5 >> 8) & 255);
HXDLIN( 218)											if ((this182 == 0)) {
HXDLIN( 218)												g113 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												g113 = (( (Float)(this182) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float b116;
HXDLIN( 218)											int this183 = (old5 & 255);
HXDLIN( 218)											if ((this183 == 0)) {
HXDLIN( 218)												b116 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												b116 = (( (Float)(this183) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float a214;
HXDLIN( 218)											int this184 = ((rhs5 >> 24) & 255);
HXDLIN( 218)											if ((this184 == 0)) {
HXDLIN( 218)												a214 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												a214 = (( (Float)(this184) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float r212;
HXDLIN( 218)											int this185 = ((rhs5 >> 16) & 255);
HXDLIN( 218)											if ((this185 == 0)) {
HXDLIN( 218)												r212 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												r212 = (( (Float)(this185) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float g212;
HXDLIN( 218)											int this186 = ((rhs5 >> 8) & 255);
HXDLIN( 218)											if ((this186 == 0)) {
HXDLIN( 218)												g212 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												g212 = (( (Float)(this186) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float b215;
HXDLIN( 218)											int this187 = (rhs5 & 255);
HXDLIN( 218)											if ((this187 == 0)) {
HXDLIN( 218)												b215 = ((Float)0.);
            											}
            											else {
HXDLIN( 218)												b215 = (( (Float)(this187) ) / ( (Float)(255) ));
            											}
HXDLIN( 218)											Float a312 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 218)											int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a312) + (r212 * a214))));
HXDLIN( 218)											int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a312) + (g212 * a214))));
HXDLIN( 218)											int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b215 * a214))));
HXDLIN( 218)											int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a214)));
HXDLIN( 218)											int blended11 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b46);
HXDLIN( 218)											{
HXDLIN( 218)												int hitQuad48;
HXDLIN( 218)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)													hitQuad48 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXDLIN( 218)													hitQuad48 = blended11;
            												}
HXDLIN( 218)												::iterMagic::Iimg_obj::set(this1->image,location11,hitQuad48);
            											}
            										}
            										else {
HXDLIN( 218)											int value5;
HXDLIN( 218)											if (this1->isLittle) {
HXDLIN( 218)												value5 = ((((a45 << 24) | (b45 << 16)) | (g33 << 8)) | r33);
            											}
            											else {
HXDLIN( 218)												value5 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b45);
            											}
HXDLIN( 218)											::iterMagic::Iimg_obj::set(this1->image,location11,value5);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 218)				if ((hasHit3 == false)) {
HXDLIN( 218)					 ::pi_xy::algo::HitTri v16 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx2,by2,cx2,cy2,dx6,dy6,true);
HXDLIN( 218)					if (hasUndo5) {
HXDLIN( 218)						v16->undoImage = undoImage15;
HXDLIN( 218)						v16->undoX = xIter35->start;
HXDLIN( 218)						v16->undoY = yIter35->start;
            					}
            				}
            			}
HXDLIN( 218)			 ::pi_xy::algo::HitQuad v17 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax2,ay2,bx2,by2,cx2,cy2,dx6,dy6,true);
HXDLIN( 218)			hitQuad = v17;
            		}
HXDLIN( 218)		Float cx3 = h2;
HXDLIN( 218)		Float cy3 = radius2;
HXDLIN( 218)		Float bx3 = h2;
HXDLIN( 218)		Float by3 = -(radius2);
HXDLIN( 218)		Float temp3 = ((Float)0.);
HXLINE( 146)		temp3 = (px + ((bx3 * cos) - (by3 * sin)));
HXLINE( 147)		by3 = (py + ((by3 * cos) + (bx3 * sin)));
HXLINE( 148)		bx3 = temp3;
HXLINE( 149)		temp3 = (px + ((cx3 * cos) - (cy3 * sin)));
HXLINE( 150)		cy3 = (py + ((cy3 * cos) + (cx3 * sin)));
HXLINE( 151)		cx3 = temp3;
HXLINE( 218)		 ::pi_xy::pixel::_TwoGrad::TwoGrad_ twoColors =  ::pi_xy::pixel::_TwoGrad::TwoGrad__obj::__alloc( HX_CTX ,color1,color2);
HXDLIN( 218)		int a47 = twoColors->colorClock;
HXDLIN( 218)		int b47 = twoColors->colorAnti;
HXDLIN( 218)		int half = ((((::Math_obj::round(((((( (Float)(((a47 >> 24) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b47 >> 24) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 24) | (::Math_obj::round(((((( (Float)(((a47 >> 16) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b47 >> 16) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 16)) | (::Math_obj::round(((((( (Float)(((a47 >> 8) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b47 >> 8) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 8)) | ::Math_obj::round(((((( (Float)((a47 & 255)) ) / ( (Float)(255) )) + (( (Float)((b47 & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))));
HXDLIN( 218)		bool hasUndo6 = false;
HXDLIN( 218)		int aA6 = ((color1 >> 24) & 255);
HXDLIN( 218)		int rA6 = ((color1 >> 16) & 255);
HXDLIN( 218)		int gA6 = ((color1 >> 8) & 255);
HXDLIN( 218)		int bA6 = (color1 & 255);
HXDLIN( 218)		int aB6 = ((half >> 24) & 255);
HXDLIN( 218)		int rB6 = ((half >> 16) & 255);
HXDLIN( 218)		int gB6 = ((half >> 8) & 255);
HXDLIN( 218)		int bB6 = (half & 255);
HXDLIN( 218)		int aC6 = ((color2 >> 24) & 255);
HXDLIN( 218)		int rC6 = ((color2 >> 16) & 255);
HXDLIN( 218)		int gC6 = ((color2 >> 8) & 255);
HXDLIN( 218)		int bC6 = (color2 & 255);
HXDLIN( 218)		Float bcx6 = (bx3 - cx3);
HXDLIN( 218)		Float bcy6 = (by3 - cy3);
HXDLIN( 218)		Float acx6 = (qx - cx3);
HXDLIN( 218)		Float acy6 = (qy - cy3);
HXDLIN( 218)		Float dot116 = ((bcx6 * bcx6) + (bcy6 * bcy6));
HXDLIN( 218)		Float dot126 = ((bcx6 * acx6) + (bcy6 * acy6));
HXDLIN( 218)		Float dot226 = ((acx6 * acx6) + (acy6 * acy6));
HXDLIN( 218)		Float denom16 = (( (Float)(1) ) / ((dot116 * dot226) - (dot126 * dot126)));
HXDLIN( 218)		 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 218)		if ((qx > bx3)) {
HXDLIN( 218)			if ((qx > cx3)) {
HXDLIN( 218)				int min24;
HXDLIN( 218)				if ((bx3 > cx3)) {
HXDLIN( 218)					min24 = ::Math_obj::floor(cx3);
            				}
            				else {
HXDLIN( 218)					min24 = ::Math_obj::floor(bx3);
            				}
HXDLIN( 218)				int ii_min48 = min24;
HXDLIN( 218)				int ii_max48 = ::Math_obj::ceil(qx);
HXDLIN( 218)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            			}
            			else {
HXDLIN( 218)				int ii_min49 = ::Math_obj::floor(bx3);
HXDLIN( 218)				int ii_max49 = ::Math_obj::ceil(cx3);
HXDLIN( 218)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            			}
            		}
            		else {
HXDLIN( 218)			if ((bx3 > cx3)) {
HXDLIN( 218)				int min25;
HXDLIN( 218)				if ((qx > cx3)) {
HXDLIN( 218)					min25 = ::Math_obj::floor(cx3);
            				}
            				else {
HXDLIN( 218)					min25 = ::Math_obj::ceil(qx);
            				}
HXDLIN( 218)				int ii_min50 = min25;
HXDLIN( 218)				int ii_max50 = ::Math_obj::ceil(bx3);
HXDLIN( 218)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            			}
            			else {
HXDLIN( 218)				int ii_min51 = ::Math_obj::floor(qx);
HXDLIN( 218)				int ii_max51 = ::Math_obj::ceil(cx3);
HXDLIN( 218)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            			}
            		}
HXDLIN( 218)		 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 218)		if ((qy > by3)) {
HXDLIN( 218)			if ((qy > cy3)) {
HXDLIN( 218)				int min26;
HXDLIN( 218)				if ((by3 > cy3)) {
HXDLIN( 218)					min26 = ::Math_obj::floor(cy3);
            				}
            				else {
HXDLIN( 218)					min26 = ::Math_obj::floor(by3);
            				}
HXDLIN( 218)				int ii_min52 = min26;
HXDLIN( 218)				int ii_max52 = ::Math_obj::ceil(qy);
HXDLIN( 218)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            			}
            			else {
HXDLIN( 218)				int ii_min53 = ::Math_obj::floor(by3);
HXDLIN( 218)				int ii_max53 = ::Math_obj::ceil(cy3);
HXDLIN( 218)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            			}
            		}
            		else {
HXDLIN( 218)			if ((by3 > cy3)) {
HXDLIN( 218)				int min27;
HXDLIN( 218)				if ((qy > cy3)) {
HXDLIN( 218)					min27 = ::Math_obj::floor(cy3);
            				}
            				else {
HXDLIN( 218)					min27 = ::Math_obj::ceil(qy);
            				}
HXDLIN( 218)				int ii_min54 = min27;
HXDLIN( 218)				int ii_max54 = ::Math_obj::ceil(by3);
HXDLIN( 218)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            			}
            			else {
HXDLIN( 218)				int ii_min55 = ::Math_obj::floor(qy);
HXDLIN( 218)				int ii_max55 = ::Math_obj::ceil(cy3);
HXDLIN( 218)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            			}
            		}
HXDLIN( 218)		 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 218)		if (hasUndo6) {
HXDLIN( 218)			int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 218)			int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 218)			 ::Dynamic imageType6 = null();
HXDLIN( 218)			 ::pi_xy::ImageStruct this188 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 218)			if (::hx::IsNull( imageType6 )) {
HXLINE(  54)				imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 218)			::Dynamic undoImage19;
HXDLIN( 218)			switch((int)(( (int)(imageType6) ))){
            				case (int)0: {
HXDLIN( 218)					 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 218)					 ::iterMagic::BytesImg b48 = byt6;
HXDLIN( 218)					{
HXDLIN( 218)						b48->width = width6;
HXDLIN( 218)						b48->height = height6;
HXDLIN( 218)						b48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 218)						b48->data = ::haxe::io::Bytes_obj::alloc((b48->length * 4));
HXDLIN( 218)						{
HXDLIN( 218)							int len12 = b48->length;
HXDLIN( 218)							int w6 = 0;
HXDLIN( 218)							{
HXDLIN( 218)								int _g120 = 0;
HXDLIN( 218)								int _g121 = b48->height;
HXDLIN( 218)								while((_g120 < _g121)){
HXDLIN( 218)									_g120 = (_g120 + 1);
HXDLIN( 218)									int y18 = (_g120 - 1);
HXDLIN( 218)									{
HXDLIN( 218)										int _g122 = 0;
HXDLIN( 218)										int _g123 = b48->width;
HXDLIN( 218)										while((_g122 < _g123)){
HXDLIN( 218)											_g122 = (_g122 + 1);
HXDLIN( 218)											int x18 = (_g122 - 1);
HXDLIN( 218)											{
HXDLIN( 218)												w6 = (w6 + 1);
HXDLIN( 218)												b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 218)											{
HXDLIN( 218)												w6 = (w6 + 1);
HXDLIN( 218)												b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 218)											{
HXDLIN( 218)												w6 = (w6 + 1);
HXDLIN( 218)												b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 218)											{
HXDLIN( 218)												w6 = (w6 + 1);
HXDLIN( 218)												b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					undoImage19 = b48;
            				}
            				break;
            				case (int)1: {
HXDLIN( 218)					 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)					 ::iterMagic::ArrIntImg a48 = arrI6;
HXDLIN( 218)					{
HXDLIN( 218)						a48->width = width6;
HXDLIN( 218)						a48->height = height6;
HXDLIN( 218)						a48->data = ::Array_obj< int >::__new(0);
HXDLIN( 218)						a48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 218)						{
HXDLIN( 218)							int _g124 = 0;
HXDLIN( 218)							int _g125 = a48->length;
HXDLIN( 218)							while((_g124 < _g125)){
HXDLIN( 218)								_g124 = (_g124 + 1);
HXDLIN( 218)								int i60 = (_g124 - 1);
HXDLIN( 218)								a48->data[i60] = 0;
            							}
            						}
            					}
HXDLIN( 218)					undoImage19 = a48;
            				}
            				break;
            				case (int)2: {
HXDLIN( 218)					 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 218)					 ::iterMagic::U32ArrImg b49 = u32a6;
HXDLIN( 218)					{
HXDLIN( 218)						b49->width = width6;
HXDLIN( 218)						b49->height = height6;
HXDLIN( 218)						b49->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 218)						int size6 = (b49->length * 4);
HXDLIN( 218)						b49->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 218)						{
HXDLIN( 218)							int _g126 = 0;
HXDLIN( 218)							int _g127 = b49->length;
HXDLIN( 218)							while((_g126 < _g127)){
HXDLIN( 218)								_g126 = (_g126 + 1);
HXDLIN( 218)								int i61 = (_g126 - 1);
HXDLIN( 218)								{
HXDLIN( 218)									 ::haxe::io::ArrayBufferViewImpl this189 = b49->data;
HXDLIN( 218)									bool undoImage20;
HXDLIN( 218)									if ((i61 >= 0)) {
HXDLIN( 218)										undoImage20 = (i61 < (this189->byteLength >> 2));
            									}
            									else {
HXDLIN( 218)										undoImage20 = false;
            									}
HXDLIN( 218)									if (undoImage20) {
HXDLIN( 218)										 ::haxe::io::Bytes _this6 = this189->bytes;
HXDLIN( 218)										int pos6 = ((i61 << 2) + this189->byteOffset);
HXDLIN( 218)										_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 218)										_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 218)										_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 218)										_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					undoImage19 = b49;
            				}
            				break;
            				case (int)3: {
HXDLIN( 218)					 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)					 ::iterMagic::VecIntImg v18 = vec6;
HXDLIN( 218)					{
HXDLIN( 218)						v18->width = width6;
HXDLIN( 218)						v18->height = height6;
HXDLIN( 218)						v18->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 218)						v18->data = ::Array_obj< int >::__new(v18->length);
HXDLIN( 218)						{
HXDLIN( 218)							int _g128 = 0;
HXDLIN( 218)							int _g129 = v18->length;
HXDLIN( 218)							while((_g128 < _g129)){
HXDLIN( 218)								_g128 = (_g128 + 1);
HXDLIN( 218)								int i62 = (_g128 - 1);
HXDLIN( 218)								v18->data->__unsafe_set(i62,0);
            							}
            						}
            					}
HXDLIN( 218)					undoImage19 = v18;
            				}
            				break;
            				case (int)4: {
HXDLIN( 218)					 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 218)					 ::iterMagic::StackIntImg b50 = sInt6;
HXDLIN( 218)					{
HXDLIN( 218)						b50->width = width6;
HXDLIN( 218)						b50->height = height6;
HXDLIN( 218)						b50->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 218)						b50->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 218)						{
HXDLIN( 218)							int len13 = b50->length;
HXDLIN( 218)							 ::haxe::ds::GenericStack_Int d6 = b50->data;
HXDLIN( 218)							if (::hx::IsNull( d6->head )) {
HXDLIN( 218)								int _g130 = 0;
HXDLIN( 218)								int _g131 = len13;
HXDLIN( 218)								while((_g130 < _g131)){
HXDLIN( 218)									_g130 = (_g130 + 1);
HXDLIN( 218)									int i63 = (_g130 - 1);
HXDLIN( 218)									d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            								}
            							}
            							else {
HXDLIN( 218)								int _g132 = 0;
HXDLIN( 218)								int _g133 = len13;
HXDLIN( 218)								while((_g132 < _g133)){
HXDLIN( 218)									_g132 = (_g132 + 1);
HXDLIN( 218)									int i64 = (_g132 - 1);
HXDLIN( 218)									{
HXDLIN( 218)										 ::haxe::ds::GenericCell_Int l6 = b50->data->head;
HXDLIN( 218)										 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 218)										{
HXDLIN( 218)											int _g134 = 0;
HXDLIN( 218)											int _g135 = i64;
HXDLIN( 218)											while((_g134 < _g135)){
HXDLIN( 218)												_g134 = (_g134 + 1);
HXDLIN( 218)												int i65 = (_g134 - 1);
HXLINE( 345)												prev6 = l6;
HXLINE( 346)												l6 = l6->next;
            											}
            										}
HXLINE( 218)										if (::hx::IsNull( prev6 )) {
HXDLIN( 218)											b50->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 218)											l6 = null();
            										}
            										else {
HXDLIN( 218)											prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 218)											l6 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 218)					undoImage19 = b50;
            				}
            				break;
            			}
HXDLIN( 218)			this188->image = undoImage19;
HXDLIN( 218)			this188->width = width6;
HXDLIN( 218)			this188->height = height6;
HXDLIN( 218)			this188->imageType = ( (int)(imageType6) );
HXDLIN( 218)			undoImage18 = this188;
HXDLIN( 218)			{
HXDLIN( 218)				int rectLeft6 = xIter36->start;
HXDLIN( 218)				int rectTop6 = yIter36->start;
HXDLIN( 218)				int rectRight6 = xIter36->max;
HXDLIN( 218)				bool forceClear6 = false;
HXDLIN( 218)				{
HXDLIN( 218)					int _g136 = rectTop6;
HXDLIN( 218)					int _g137 = yIter36->max;
HXDLIN( 218)					while((_g136 < _g137)){
HXDLIN( 218)						_g136 = (_g136 + 1);
HXDLIN( 218)						int dy9 = (_g136 - 1);
HXDLIN( 218)						{
HXDLIN( 218)							int _g138 = rectLeft6;
HXDLIN( 218)							int _g139 = rectRight6;
HXDLIN( 218)							while((_g138 < _g139)){
HXDLIN( 218)								_g138 = (_g138 + 1);
HXDLIN( 218)								int dx9 = (_g138 - 1);
HXDLIN( 218)								::Dynamic this190 = this1->image;
HXDLIN( 218)								int index24;
HXDLIN( 218)								if (this1->useVirtualPos) {
HXDLIN( 218)									index24 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx9) - this1->virtualX));
            								}
            								else {
HXDLIN( 218)									index24 = ::Std_obj::_hx_int(( (Float)(((dy9 * this1->width) + dx9)) ));
            								}
HXDLIN( 218)								int c18 = ::iterMagic::Iimg_obj::get(this190,index24);
HXDLIN( 218)								int col6;
HXDLIN( 218)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)									col6 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            								}
            								else {
HXDLIN( 218)									col6 = c18;
            								}
HXDLIN( 218)								bool _hx_tmp;
HXDLIN( 218)								if (this1->useMask) {
HXDLIN( 218)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 218)									_hx_tmp = false;
            								}
HXDLIN( 218)								if (_hx_tmp) {
HXDLIN( 218)									 ::pi_xy::ImageStruct this191 = this1->mask;
HXDLIN( 218)									::Dynamic this192 = this191->image;
HXDLIN( 218)									int index25;
HXDLIN( 218)									if (this191->useVirtualPos) {
HXDLIN( 218)										index25 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this191->virtualY) * ( (Float)(this191->width) )) + dx9) - this191->virtualX));
            									}
            									else {
HXDLIN( 218)										index25 = ::Std_obj::_hx_int(( (Float)(((dy9 * this191->width) + dx9)) ));
            									}
HXDLIN( 218)									int c19 = ::iterMagic::Iimg_obj::get(this192,index25);
HXDLIN( 218)									int v19;
HXDLIN( 218)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)										v19 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            									}
            									else {
HXDLIN( 218)										v19 = c19;
            									}
HXDLIN( 218)									int maskPixel6 = v19;
HXDLIN( 218)									int this193 = col6;
HXDLIN( 218)									if ((maskPixel6 == 0)) {
HXDLIN( 218)										col6 = this193;
            									}
            									else {
HXDLIN( 218)										Float m06;
HXDLIN( 218)										int this194 = ((maskPixel6 >> 24) & 255);
HXDLIN( 218)										if ((this194 == 0)) {
HXDLIN( 218)											m06 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											m06 = (( (Float)(this194) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float m16;
HXDLIN( 218)										int this195 = ((maskPixel6 >> 16) & 255);
HXDLIN( 218)										if ((this195 == 0)) {
HXDLIN( 218)											m16 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											m16 = (( (Float)(this195) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float m26;
HXDLIN( 218)										int this196 = ((maskPixel6 >> 8) & 255);
HXDLIN( 218)										if ((this196 == 0)) {
HXDLIN( 218)											m26 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											m26 = (( (Float)(this196) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float m36;
HXDLIN( 218)										int this197 = (maskPixel6 & 255);
HXDLIN( 218)										if ((this197 == 0)) {
HXDLIN( 218)											m36 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											m36 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this193 >> 24) & 255)) )));
HXDLIN( 218)										int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this193 >> 16) & 255)) )));
HXDLIN( 218)										int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this193 >> 8) & 255)) )));
HXDLIN( 218)										int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this193 & 255)) )));
HXDLIN( 218)										col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 218)								if ((col6 != 0)) {
HXDLIN( 218)									int x19 = (dx9 - rectLeft6);
HXDLIN( 218)									int y19 = (dy9 - rectTop6);
HXDLIN( 218)									int c20 = col6;
HXDLIN( 218)									bool _hx_tmp1;
HXDLIN( 218)									if ((((c20 >> 24) & 255) < 254)) {
HXDLIN( 218)										_hx_tmp1 = undoImage18->transparent;
            									}
            									else {
HXDLIN( 218)										_hx_tmp1 = false;
            									}
HXDLIN( 218)									if (_hx_tmp1) {
HXDLIN( 218)										int location12;
HXDLIN( 218)										if (undoImage18->useVirtualPos) {
HXDLIN( 218)											location12 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x19) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 218)											location12 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage18->width) + x19)) ));
            										}
HXDLIN( 218)										int this198 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 218)										int this199;
HXDLIN( 218)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)											this199 = ((((((this198 >> 24) & 255) << 24) | ((this198 & 255) << 16)) | (((this198 >> 8) & 255) << 8)) | ((this198 >> 16) & 255));
            										}
            										else {
HXDLIN( 218)											this199 = this198;
            										}
HXDLIN( 218)										Float a116;
HXDLIN( 218)										int this200 = ((this199 >> 24) & 255);
HXDLIN( 218)										if ((this200 == 0)) {
HXDLIN( 218)											a116 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											a116 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float r114;
HXDLIN( 218)										int this201 = ((this199 >> 16) & 255);
HXDLIN( 218)										if ((this201 == 0)) {
HXDLIN( 218)											r114 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											r114 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float g114;
HXDLIN( 218)										int this202 = ((this199 >> 8) & 255);
HXDLIN( 218)										if ((this202 == 0)) {
HXDLIN( 218)											g114 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											g114 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float b117;
HXDLIN( 218)										int this203 = (this199 & 255);
HXDLIN( 218)										if ((this203 == 0)) {
HXDLIN( 218)											b117 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											b117 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float a215;
HXDLIN( 218)										int this204 = ((col6 >> 24) & 255);
HXDLIN( 218)										if ((this204 == 0)) {
HXDLIN( 218)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											a215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float r213;
HXDLIN( 218)										int this205 = ((col6 >> 16) & 255);
HXDLIN( 218)										if ((this205 == 0)) {
HXDLIN( 218)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											r213 = (( (Float)(this205) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float g213;
HXDLIN( 218)										int this206 = ((col6 >> 8) & 255);
HXDLIN( 218)										if ((this206 == 0)) {
HXDLIN( 218)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											g213 = (( (Float)(this206) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float b216;
HXDLIN( 218)										int this207 = (col6 & 255);
HXDLIN( 218)										if ((this207 == 0)) {
HXDLIN( 218)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 218)											b216 = (( (Float)(this207) ) / ( (Float)(255) ));
            										}
HXDLIN( 218)										Float a313 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 218)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a313) + (r213 * a215))));
HXDLIN( 218)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a313) + (g213 * a215))));
HXDLIN( 218)										int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b216 * a215))));
HXDLIN( 218)										int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a215)));
HXDLIN( 218)										int blended12 = ((((a49 << 24) | (r35 << 16)) | (g35 << 8)) | b51);
HXDLIN( 218)										{
HXDLIN( 218)											int _hx_tmp2;
HXDLIN( 218)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)												_hx_tmp2 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 218)												_hx_tmp2 = blended12;
            											}
HXDLIN( 218)											::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 218)										::Dynamic this208 = undoImage18->image;
HXDLIN( 218)										int index26;
HXDLIN( 218)										if (undoImage18->useVirtualPos) {
HXDLIN( 218)											index26 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x19) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 218)											index26 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage18->width) + x19)) ));
            										}
HXDLIN( 218)										int _hx_tmp3;
HXDLIN( 218)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)											_hx_tmp3 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            										}
            										else {
HXDLIN( 218)											_hx_tmp3 = c20;
            										}
HXDLIN( 218)										::iterMagic::Iimg_obj::set(this208,index26,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 218)									if (forceClear6) {
HXDLIN( 218)										::Dynamic this209 = undoImage18->image;
HXDLIN( 218)										int x20 = (dx9 - rectLeft6);
HXDLIN( 218)										int y20 = (dy9 - rectTop6);
HXDLIN( 218)										int index27;
HXDLIN( 218)										if (undoImage18->useVirtualPos) {
HXDLIN( 218)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x20) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 218)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage18->width) + x20)) ));
            										}
HXDLIN( 218)										::iterMagic::Iimg_obj::set(this209,index27,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 218)		{
HXDLIN( 218)			int _g_min12 = xIter36->start;
HXDLIN( 218)			int _g_max12 = xIter36->max;
HXDLIN( 218)			while((_g_min12 < _g_max12)){
HXDLIN( 218)				_g_min12 = (_g_min12 + 1);
HXDLIN( 218)				int px7 = (_g_min12 - 1);
HXDLIN( 218)				Float pcx6 = (( (Float)(px7) ) - cx3);
HXDLIN( 218)				{
HXDLIN( 218)					int _g_min13 = yIter36->start;
HXDLIN( 218)					int _g_max13 = yIter36->max;
HXDLIN( 218)					while((_g_min13 < _g_max13)){
HXDLIN( 218)						_g_min13 = (_g_min13 + 1);
HXDLIN( 218)						int py7 = (_g_min13 - 1);
HXDLIN( 218)						Float pcy6 = (( (Float)(py7) ) - cy3);
HXDLIN( 218)						Float dot316 = ((pcx6 * bcx6) + (pcy6 * bcy6));
HXDLIN( 218)						Float dot326 = ((pcx6 * acx6) + (pcy6 * acy6));
HXDLIN( 218)						Float ratioA6 = (((dot226 * dot316) - (dot126 * dot326)) * denom16);
HXDLIN( 218)						Float ratioB6 = (((dot116 * dot326) - (dot126 * dot316)) * denom16);
HXDLIN( 218)						Float ratioC6 = ((((Float)1.0) - ratioB6) - ratioA6);
HXDLIN( 218)						bool _hx_tmp4;
HXDLIN( 218)						bool _hx_tmp5;
HXDLIN( 218)						if ((ratioA6 >= 0)) {
HXDLIN( 218)							_hx_tmp5 = (ratioB6 >= 0);
            						}
            						else {
HXDLIN( 218)							_hx_tmp5 = false;
            						}
HXDLIN( 218)						if (_hx_tmp5) {
HXDLIN( 218)							_hx_tmp4 = (ratioC6 >= 0);
            						}
            						else {
HXDLIN( 218)							_hx_tmp4 = false;
            						}
HXDLIN( 218)						if (_hx_tmp4) {
HXDLIN( 218)							int i66 = ::Std_obj::_hx_int((((( (Float)(aA6) ) * ratioA6) + (( (Float)(aB6) ) * ratioB6)) + (( (Float)(aC6) ) * ratioC6)));
HXDLIN( 218)							if ((i66 > 255)) {
HXLINE(  24)								i66 = 255;
            							}
HXLINE( 218)							if ((i66 < 0)) {
HXLINE(  25)								i66 = 0;
            							}
HXLINE( 218)							int a50 = i66;
HXDLIN( 218)							int i67 = ::Std_obj::_hx_int((((( (Float)(rA6) ) * ratioA6) + (( (Float)(rB6) ) * ratioB6)) + (( (Float)(rC6) ) * ratioC6)));
HXDLIN( 218)							if ((i67 > 255)) {
HXLINE(  24)								i67 = 255;
            							}
HXLINE( 218)							if ((i67 < 0)) {
HXLINE(  25)								i67 = 0;
            							}
HXLINE( 218)							int r36 = i67;
HXDLIN( 218)							int i68 = ::Std_obj::_hx_int((((( (Float)(gA6) ) * ratioA6) + (( (Float)(gB6) ) * ratioB6)) + (( (Float)(gC6) ) * ratioC6)));
HXDLIN( 218)							if ((i68 > 255)) {
HXLINE(  24)								i68 = 255;
            							}
HXLINE( 218)							if ((i68 < 0)) {
HXLINE(  25)								i68 = 0;
            							}
HXLINE( 218)							int g36 = i68;
HXDLIN( 218)							int i69 = ::Std_obj::_hx_int((((( (Float)(bA6) ) * ratioA6) + (( (Float)(bB6) ) * ratioB6)) + (( (Float)(bC6) ) * ratioC6)));
HXDLIN( 218)							if ((i69 > 255)) {
HXLINE(  24)								i69 = 255;
            							}
HXLINE( 218)							if ((i69 < 0)) {
HXLINE(  25)								i69 = 0;
            							}
HXLINE( 218)							int b52 = i69;
HXDLIN( 218)							{
HXDLIN( 218)								int location13;
HXDLIN( 218)								if (this1->useVirtualPos) {
HXDLIN( 218)									location13 = ::Std_obj::_hx_int(((((( (Float)(py7) ) - this1->virtualY) * ( (Float)(this1->width) )) + px7) - this1->virtualX));
            								}
            								else {
HXDLIN( 218)									location13 = ::Std_obj::_hx_int(( (Float)(((py7 * this1->width) + px7)) ));
            								}
HXDLIN( 218)								bool _hx_tmp6;
HXDLIN( 218)								if (this1->transparent) {
HXDLIN( 218)									_hx_tmp6 = (a50 < 254);
            								}
            								else {
HXDLIN( 218)									_hx_tmp6 = false;
            								}
HXDLIN( 218)								if (_hx_tmp6) {
HXDLIN( 218)									int this210 = ::iterMagic::Iimg_obj::get(this1->image,location13);
HXDLIN( 218)									int old6;
HXDLIN( 218)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)										old6 = ((((((this210 >> 24) & 255) << 24) | ((this210 & 255) << 16)) | (((this210 >> 8) & 255) << 8)) | ((this210 >> 16) & 255));
            									}
            									else {
HXDLIN( 218)										old6 = this210;
            									}
HXDLIN( 218)									int rhs6 = ((((a50 << 24) | (r36 << 16)) | (g36 << 8)) | b52);
HXDLIN( 218)									Float a117;
HXDLIN( 218)									int this211 = ((old6 >> 24) & 255);
HXDLIN( 218)									if ((this211 == 0)) {
HXDLIN( 218)										a117 = ((Float)0.);
            									}
            									else {
HXDLIN( 218)										a117 = (( (Float)(this211) ) / ( (Float)(255) ));
            									}
HXDLIN( 218)									Float r115;
HXDLIN( 218)									int this212 = ((old6 >> 16) & 255);
HXDLIN( 218)									if ((this212 == 0)) {
HXDLIN( 218)										r115 = ((Float)0.);
            									}
            									else {
HXDLIN( 218)										r115 = (( (Float)(this212) ) / ( (Float)(255) ));
            									}
HXDLIN( 218)									Float g115;
HXDLIN( 218)									int this213 = ((old6 >> 8) & 255);
HXDLIN( 218)									if ((this213 == 0)) {
HXDLIN( 218)										g115 = ((Float)0.);
            									}
            									else {
HXDLIN( 218)										g115 = (( (Float)(this213) ) / ( (Float)(255) ));
            									}
HXDLIN( 218)									Float b118;
HXDLIN( 218)									int this214 = (old6 & 255);
HXDLIN( 218)									if ((this214 == 0)) {
HXDLIN( 218)										b118 = ((Float)0.);
            									}
            									else {
HXDLIN( 218)										b118 = (( (Float)(this214) ) / ( (Float)(255) ));
            									}
HXDLIN( 218)									Float a216;
HXDLIN( 218)									int this215 = ((rhs6 >> 24) & 255);
HXDLIN( 218)									if ((this215 == 0)) {
HXDLIN( 218)										a216 = ((Float)0.);
            									}
            									else {
HXDLIN( 218)										a216 = (( (Float)(this215) ) / ( (Float)(255) ));
            									}
HXDLIN( 218)									Float r214;
HXDLIN( 218)									int this216 = ((rhs6 >> 16) & 255);
HXDLIN( 218)									if ((this216 == 0)) {
HXDLIN( 218)										r214 = ((Float)0.);
            									}
            									else {
HXDLIN( 218)										r214 = (( (Float)(this216) ) / ( (Float)(255) ));
            									}
HXDLIN( 218)									Float g214;
HXDLIN( 218)									int this217 = ((rhs6 >> 8) & 255);
HXDLIN( 218)									if ((this217 == 0)) {
HXDLIN( 218)										g214 = ((Float)0.);
            									}
            									else {
HXDLIN( 218)										g214 = (( (Float)(this217) ) / ( (Float)(255) ));
            									}
HXDLIN( 218)									Float b217;
HXDLIN( 218)									int this218 = (rhs6 & 255);
HXDLIN( 218)									if ((this218 == 0)) {
HXDLIN( 218)										b217 = ((Float)0.);
            									}
            									else {
HXDLIN( 218)										b217 = (( (Float)(this218) ) / ( (Float)(255) ));
            									}
HXDLIN( 218)									Float a314 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 218)									int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a314) + (r214 * a216))));
HXDLIN( 218)									int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a314) + (g214 * a216))));
HXDLIN( 218)									int b53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b217 * a216))));
HXDLIN( 218)									int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a216)));
HXDLIN( 218)									int blended13 = ((((a51 << 24) | (r37 << 16)) | (g37 << 8)) | b53);
HXDLIN( 218)									{
HXDLIN( 218)										int _hx_tmp7;
HXDLIN( 218)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 218)											_hx_tmp7 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            										}
            										else {
HXDLIN( 218)											_hx_tmp7 = blended13;
            										}
HXDLIN( 218)										::iterMagic::Iimg_obj::set(this1->image,location13,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN( 218)									int value6;
HXDLIN( 218)									if (this1->isLittle) {
HXDLIN( 218)										value6 = ((((a50 << 24) | (b52 << 16)) | (g36 << 8)) | r36);
            									}
            									else {
HXDLIN( 218)										value6 = ((((a50 << 24) | (r36 << 16)) | (g36 << 8)) | b52);
            									}
HXDLIN( 218)									::iterMagic::Iimg_obj::set(this1->image,location13,value6);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 218)		 ::pi_xy::algo::HitTri hitTri;
HXDLIN( 218)		if ((hasHit == false)) {
HXDLIN( 218)			 ::pi_xy::algo::HitTri v20 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx3,by3,cx3,cy3,true);
HXDLIN( 218)			if (hasUndo6) {
HXDLIN( 218)				v20->undoImage = undoImage18;
HXDLIN( 218)				v20->undoX = xIter36->start;
HXDLIN( 218)				v20->undoY = yIter36->start;
            			}
HXDLIN( 218)			hitTri = v20;
            		}
            		else {
HXDLIN( 218)			hitTri = null();
            		}
HXDLIN( 218)		if (hasHit) {
HXDLIN( 218)			 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN( 218)			if (::hx::IsNotNull( hitQuad )) {
HXDLIN( 218)				hitArr->triArr->push(hitQuad->triABD);
            			}
HXDLIN( 218)			hitArr->triArr->push(hitQuad->triBCD);
HXDLIN( 218)			return hitArr;
            		}
            		else {
HXDLIN( 218)			return null();
            		}
HXDLIN( 218)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(GradientShape_Impl__obj,thickArrow,return )

 ::pi_xy::algo::HitTriArray GradientShape_Impl__obj::thickArrowBoth( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float thick,int color1,int color2,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_235_thickArrowBoth)
HXDLIN( 235)		Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 235)		Float o = (qy - py);
HXDLIN( 235)		Float a = (qx - px);
HXDLIN( 235)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 235)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 235)		Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN( 235)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 235)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 235)		Float radius = (thick / ( (Float)(2) ));
HXDLIN( 235)		Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 235)		Float h2 = (h / goldenRatio);
HXDLIN( 235)		Float hSmall = (h - h2);
HXDLIN( 235)		Float px_ = hSmall;
HXDLIN( 235)		Float py_ = ((Float)0.);
HXDLIN( 235)		Float temp = ((Float)0.);
HXLINE( 320)		temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 321)		py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 322)		px_ = temp;
HXLINE( 235)		Float h1 = (h2 - hSmall);
HXDLIN( 235)		Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 235)		Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 235)		Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 235)		Float dx = ((Float)0.1);
HXDLIN( 235)		Float dy = radius1;
HXDLIN( 235)		Float cx = h1;
HXDLIN( 235)		Float cy = radius1;
HXDLIN( 235)		Float bx = h1;
HXDLIN( 235)		Float by = -(radius1);
HXDLIN( 235)		Float ax = ((Float)0.1);
HXDLIN( 235)		Float ay = -(radius1);
HXDLIN( 235)		Float temp1 = ((Float)0.);
HXLINE( 474)		temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE( 475)		ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE( 476)		ax = temp1;
HXLINE( 478)		temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE( 479)		by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE( 480)		bx = temp1;
HXLINE( 482)		temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE( 483)		cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE( 484)		cx = temp1;
HXLINE( 486)		temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE( 487)		dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE( 488)		dx = temp1;
HXLINE( 235)		{
HXDLIN( 235)			bool hasUndo = false;
HXDLIN( 235)			int aA = ((color1 >> 24) & 255);
HXDLIN( 235)			int rA = ((color1 >> 16) & 255);
HXDLIN( 235)			int gA = ((color1 >> 8) & 255);
HXDLIN( 235)			int bA = (color1 & 255);
HXDLIN( 235)			int aB = ((color1 >> 24) & 255);
HXDLIN( 235)			int rB = ((color1 >> 16) & 255);
HXDLIN( 235)			int gB = ((color1 >> 8) & 255);
HXDLIN( 235)			int bB = (color1 & 255);
HXDLIN( 235)			int aC = ((color2 >> 24) & 255);
HXDLIN( 235)			int rC = ((color2 >> 16) & 255);
HXDLIN( 235)			int gC = ((color2 >> 8) & 255);
HXDLIN( 235)			int bC = (color2 & 255);
HXDLIN( 235)			Float bcx = (bx - dx);
HXDLIN( 235)			Float bcy = (by - dy);
HXDLIN( 235)			Float acx = (ax - dx);
HXDLIN( 235)			Float acy = (ay - dy);
HXDLIN( 235)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 235)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 235)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 235)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 235)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 235)			if ((ax > bx)) {
HXDLIN( 235)				if ((ax > dx)) {
HXDLIN( 235)					int min;
HXDLIN( 235)					if ((bx > dx)) {
HXDLIN( 235)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN( 235)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 235)					int ii_min = min;
HXDLIN( 235)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 235)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXDLIN( 235)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 235)					int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 235)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXDLIN( 235)				if ((bx > dx)) {
HXDLIN( 235)					int min1;
HXDLIN( 235)					if ((ax > dx)) {
HXDLIN( 235)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN( 235)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 235)					int ii_min2 = min1;
HXDLIN( 235)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 235)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXDLIN( 235)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 235)					int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 235)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN( 235)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 235)			if ((ay > by)) {
HXDLIN( 235)				if ((ay > dy)) {
HXDLIN( 235)					int min2;
HXDLIN( 235)					if ((by > dy)) {
HXDLIN( 235)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN( 235)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 235)					int ii_min4 = min2;
HXDLIN( 235)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 235)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXDLIN( 235)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 235)					int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 235)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXDLIN( 235)				if ((by > dy)) {
HXDLIN( 235)					int min3;
HXDLIN( 235)					if ((ay > dy)) {
HXDLIN( 235)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN( 235)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 235)					int ii_min6 = min3;
HXDLIN( 235)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 235)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXDLIN( 235)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 235)					int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 235)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN( 235)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 235)			if (hasUndo) {
HXDLIN( 235)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 235)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 235)				 ::Dynamic imageType = null();
HXDLIN( 235)				 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 235)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 235)				::Dynamic undoImage1;
HXDLIN( 235)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXDLIN( 235)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 235)						{
HXDLIN( 235)							b->width = width;
HXDLIN( 235)							b->height = height;
HXDLIN( 235)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 235)							{
HXDLIN( 235)								int len = b->length;
HXDLIN( 235)								int w = 0;
HXDLIN( 235)								{
HXDLIN( 235)									int _g = 0;
HXDLIN( 235)									int _g1 = b->height;
HXDLIN( 235)									while((_g < _g1)){
HXDLIN( 235)										_g = (_g + 1);
HXDLIN( 235)										int y = (_g - 1);
HXDLIN( 235)										{
HXDLIN( 235)											int _g2 = 0;
HXDLIN( 235)											int _g3 = b->width;
HXDLIN( 235)											while((_g2 < _g3)){
HXDLIN( 235)												_g2 = (_g2 + 1);
HXDLIN( 235)												int x = (_g2 - 1);
HXDLIN( 235)												{
HXDLIN( 235)													w = (w + 1);
HXDLIN( 235)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 235)												{
HXDLIN( 235)													w = (w + 1);
HXDLIN( 235)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 235)												{
HXDLIN( 235)													w = (w + 1);
HXDLIN( 235)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 235)												{
HXDLIN( 235)													w = (w + 1);
HXDLIN( 235)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 235)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXDLIN( 235)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 235)						{
HXDLIN( 235)							a1->width = width;
HXDLIN( 235)							a1->height = height;
HXDLIN( 235)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 235)							a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)							{
HXDLIN( 235)								int _g4 = 0;
HXDLIN( 235)								int _g5 = a1->length;
HXDLIN( 235)								while((_g4 < _g5)){
HXDLIN( 235)									_g4 = (_g4 + 1);
HXDLIN( 235)									int i = (_g4 - 1);
HXDLIN( 235)									a1->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 235)						undoImage1 = a1;
            					}
            					break;
            					case (int)2: {
HXDLIN( 235)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 235)						{
HXDLIN( 235)							b1->width = width;
HXDLIN( 235)							b1->height = height;
HXDLIN( 235)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)							int size = (b1->length * 4);
HXDLIN( 235)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 235)							{
HXDLIN( 235)								int _g6 = 0;
HXDLIN( 235)								int _g7 = b1->length;
HXDLIN( 235)								while((_g6 < _g7)){
HXDLIN( 235)									_g6 = (_g6 + 1);
HXDLIN( 235)									int i1 = (_g6 - 1);
HXDLIN( 235)									{
HXDLIN( 235)										 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 235)										bool undoImage2;
HXDLIN( 235)										if ((i1 >= 0)) {
HXDLIN( 235)											undoImage2 = (i1 < (this3->byteLength >> 2));
            										}
            										else {
HXDLIN( 235)											undoImage2 = false;
            										}
HXDLIN( 235)										if (undoImage2) {
HXDLIN( 235)											 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 235)											int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 235)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 235)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 235)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 235)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 235)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXDLIN( 235)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 235)						{
HXDLIN( 235)							v->width = width;
HXDLIN( 235)							v->height = height;
HXDLIN( 235)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 235)							{
HXDLIN( 235)								int _g8 = 0;
HXDLIN( 235)								int _g9 = v->length;
HXDLIN( 235)								while((_g8 < _g9)){
HXDLIN( 235)									_g8 = (_g8 + 1);
HXDLIN( 235)									int i2 = (_g8 - 1);
HXDLIN( 235)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 235)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXDLIN( 235)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 235)						{
HXDLIN( 235)							b2->width = width;
HXDLIN( 235)							b2->height = height;
HXDLIN( 235)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 235)							{
HXDLIN( 235)								int len1 = b2->length;
HXDLIN( 235)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 235)								if (::hx::IsNull( d->head )) {
HXDLIN( 235)									int _g10 = 0;
HXDLIN( 235)									int _g11 = len1;
HXDLIN( 235)									while((_g10 < _g11)){
HXDLIN( 235)										_g10 = (_g10 + 1);
HXDLIN( 235)										int i3 = (_g10 - 1);
HXDLIN( 235)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXDLIN( 235)									int _g12 = 0;
HXDLIN( 235)									int _g13 = len1;
HXDLIN( 235)									while((_g12 < _g13)){
HXDLIN( 235)										_g12 = (_g12 + 1);
HXDLIN( 235)										int i4 = (_g12 - 1);
HXDLIN( 235)										{
HXDLIN( 235)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 235)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 235)											{
HXDLIN( 235)												int _g14 = 0;
HXDLIN( 235)												int _g15 = i4;
HXDLIN( 235)												while((_g14 < _g15)){
HXDLIN( 235)													_g14 = (_g14 + 1);
HXDLIN( 235)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 235)											if (::hx::IsNull( prev )) {
HXDLIN( 235)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 235)												l = null();
            											}
            											else {
HXDLIN( 235)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 235)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 235)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 235)				this2->image = undoImage1;
HXDLIN( 235)				this2->width = width;
HXDLIN( 235)				this2->height = height;
HXDLIN( 235)				this2->imageType = ( (int)(imageType) );
HXDLIN( 235)				undoImage = this2;
HXDLIN( 235)				{
HXDLIN( 235)					int rectLeft = xIter3->start;
HXDLIN( 235)					int rectTop = yIter3->start;
HXDLIN( 235)					int rectRight = xIter3->max;
HXDLIN( 235)					bool forceClear = false;
HXDLIN( 235)					{
HXDLIN( 235)						int _g16 = rectTop;
HXDLIN( 235)						int _g17 = yIter3->max;
HXDLIN( 235)						while((_g16 < _g17)){
HXDLIN( 235)							_g16 = (_g16 + 1);
HXDLIN( 235)							int dy1 = (_g16 - 1);
HXDLIN( 235)							{
HXDLIN( 235)								int _g18 = rectLeft;
HXDLIN( 235)								int _g19 = rectRight;
HXDLIN( 235)								while((_g18 < _g19)){
HXDLIN( 235)									_g18 = (_g18 + 1);
HXDLIN( 235)									int dx1 = (_g18 - 1);
HXDLIN( 235)									::Dynamic this4 = this1->image;
HXDLIN( 235)									int index;
HXDLIN( 235)									if (this1->useVirtualPos) {
HXDLIN( 235)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            									}
            									else {
HXDLIN( 235)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            									}
HXDLIN( 235)									int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 235)									int col;
HXDLIN( 235)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXDLIN( 235)										col = c;
            									}
HXDLIN( 235)									bool _hx_tmp;
HXDLIN( 235)									if (this1->useMask) {
HXDLIN( 235)										_hx_tmp = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN( 235)										_hx_tmp = false;
            									}
HXDLIN( 235)									if (_hx_tmp) {
HXDLIN( 235)										 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 235)										::Dynamic this6 = this5->image;
HXDLIN( 235)										int index1;
HXDLIN( 235)										if (this5->useVirtualPos) {
HXDLIN( 235)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            										}
            										else {
HXDLIN( 235)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            										}
HXDLIN( 235)										int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 235)										int v1;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											v1 = c1;
            										}
HXDLIN( 235)										int maskPixel = v1;
HXDLIN( 235)										int this7 = col;
HXDLIN( 235)										if ((maskPixel == 0)) {
HXDLIN( 235)											col = this7;
            										}
            										else {
HXDLIN( 235)											Float m0;
HXDLIN( 235)											int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 235)											if ((this8 == 0)) {
HXDLIN( 235)												m0 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float m1;
HXDLIN( 235)											int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 235)											if ((this9 == 0)) {
HXDLIN( 235)												m1 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float m2;
HXDLIN( 235)											int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 235)											if ((this10 == 0)) {
HXDLIN( 235)												m2 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float m3;
HXDLIN( 235)											int this11 = (maskPixel & 255);
HXDLIN( 235)											if ((this11 == 0)) {
HXDLIN( 235)												m3 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 235)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 235)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 235)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 235)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 235)									if ((col != 0)) {
HXDLIN( 235)										int x1 = (dx1 - rectLeft);
HXDLIN( 235)										int y1 = (dy1 - rectTop);
HXDLIN( 235)										int c2 = col;
HXDLIN( 235)										bool _hx_tmp1;
HXDLIN( 235)										if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 235)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXDLIN( 235)											_hx_tmp1 = false;
            										}
HXDLIN( 235)										if (_hx_tmp1) {
HXDLIN( 235)											int location;
HXDLIN( 235)											if (undoImage->useVirtualPos) {
HXDLIN( 235)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXDLIN( 235)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 235)											int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 235)											int this13;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)												this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            											}
            											else {
HXDLIN( 235)												this13 = this12;
            											}
HXDLIN( 235)											Float a11;
HXDLIN( 235)											int this14 = ((this13 >> 24) & 255);
HXDLIN( 235)											if ((this14 == 0)) {
HXDLIN( 235)												a11 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float r1;
HXDLIN( 235)											int this15 = ((this13 >> 16) & 255);
HXDLIN( 235)											if ((this15 == 0)) {
HXDLIN( 235)												r1 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float g1;
HXDLIN( 235)											int this16 = ((this13 >> 8) & 255);
HXDLIN( 235)											if ((this16 == 0)) {
HXDLIN( 235)												g1 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float b11;
HXDLIN( 235)											int this17 = (this13 & 255);
HXDLIN( 235)											if ((this17 == 0)) {
HXDLIN( 235)												b11 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float a2;
HXDLIN( 235)											int this18 = ((col >> 24) & 255);
HXDLIN( 235)											if ((this18 == 0)) {
HXDLIN( 235)												a2 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float r2;
HXDLIN( 235)											int this19 = ((col >> 16) & 255);
HXDLIN( 235)											if ((this19 == 0)) {
HXDLIN( 235)												r2 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float g2;
HXDLIN( 235)											int this20 = ((col >> 8) & 255);
HXDLIN( 235)											if ((this20 == 0)) {
HXDLIN( 235)												g2 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float b21;
HXDLIN( 235)											int this21 = (col & 255);
HXDLIN( 235)											if ((this21 == 0)) {
HXDLIN( 235)												b21 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 235)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 235)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 235)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 235)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 235)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 235)											{
HXDLIN( 235)												int _hx_tmp2;
HXDLIN( 235)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXDLIN( 235)													_hx_tmp2 = blended;
            												}
HXDLIN( 235)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXDLIN( 235)											::Dynamic this22 = undoImage->image;
HXDLIN( 235)											int index2;
HXDLIN( 235)											if (undoImage->useVirtualPos) {
HXDLIN( 235)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXDLIN( 235)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 235)											int _hx_tmp3;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXDLIN( 235)												_hx_tmp3 = c2;
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            										}
            									}
            									else {
HXDLIN( 235)										if (forceClear) {
HXDLIN( 235)											::Dynamic this23 = undoImage->image;
HXDLIN( 235)											int x2 = (dx1 - rectLeft);
HXDLIN( 235)											int y2 = (dy1 - rectTop);
HXDLIN( 235)											int index3;
HXDLIN( 235)											if (undoImage->useVirtualPos) {
HXDLIN( 235)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXDLIN( 235)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(this23,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 235)			{
HXDLIN( 235)				int _g_min = xIter3->start;
HXDLIN( 235)				int _g_max = xIter3->max;
HXDLIN( 235)				while((_g_min < _g_max)){
HXDLIN( 235)					_g_min = (_g_min + 1);
HXDLIN( 235)					int px1 = (_g_min - 1);
HXDLIN( 235)					Float pcx = (( (Float)(px1) ) - dx);
HXDLIN( 235)					{
HXDLIN( 235)						int _g_min1 = yIter3->start;
HXDLIN( 235)						int _g_max1 = yIter3->max;
HXDLIN( 235)						while((_g_min1 < _g_max1)){
HXDLIN( 235)							_g_min1 = (_g_min1 + 1);
HXDLIN( 235)							int py1 = (_g_min1 - 1);
HXDLIN( 235)							Float pcy = (( (Float)(py1) ) - dy);
HXDLIN( 235)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 235)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 235)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 235)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 235)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 235)							bool _hx_tmp4;
HXDLIN( 235)							bool _hx_tmp5;
HXDLIN( 235)							if ((ratioA >= 0)) {
HXDLIN( 235)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXDLIN( 235)								_hx_tmp5 = false;
            							}
HXDLIN( 235)							if (_hx_tmp5) {
HXDLIN( 235)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXDLIN( 235)								_hx_tmp4 = false;
            							}
HXDLIN( 235)							if (_hx_tmp4) {
HXDLIN( 235)								int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 235)								if ((i6 > 255)) {
HXLINE(  24)									i6 = 255;
            								}
HXLINE( 235)								if ((i6 < 0)) {
HXLINE(  25)									i6 = 0;
            								}
HXLINE( 235)								int a5 = i6;
HXDLIN( 235)								int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 235)								if ((i7 > 255)) {
HXLINE(  24)									i7 = 255;
            								}
HXLINE( 235)								if ((i7 < 0)) {
HXLINE(  25)									i7 = 0;
            								}
HXLINE( 235)								int r3 = i7;
HXDLIN( 235)								int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 235)								if ((i8 > 255)) {
HXLINE(  24)									i8 = 255;
            								}
HXLINE( 235)								if ((i8 < 0)) {
HXLINE(  25)									i8 = 0;
            								}
HXLINE( 235)								int g3 = i8;
HXDLIN( 235)								int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 235)								if ((i9 > 255)) {
HXLINE(  24)									i9 = 255;
            								}
HXLINE( 235)								if ((i9 < 0)) {
HXLINE(  25)									i9 = 0;
            								}
HXLINE( 235)								int b4 = i9;
HXDLIN( 235)								{
HXDLIN( 235)									int location1;
HXDLIN( 235)									if (this1->useVirtualPos) {
HXDLIN( 235)										location1 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this1->virtualY) * ( (Float)(this1->width) )) + px1) - this1->virtualX));
            									}
            									else {
HXDLIN( 235)										location1 = ::Std_obj::_hx_int(( (Float)(((py1 * this1->width) + px1)) ));
            									}
HXDLIN( 235)									bool _hx_tmp6;
HXDLIN( 235)									if (this1->transparent) {
HXDLIN( 235)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXDLIN( 235)										_hx_tmp6 = false;
            									}
HXDLIN( 235)									if (_hx_tmp6) {
HXDLIN( 235)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 235)										int old;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											old = this24;
            										}
HXDLIN( 235)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 235)										Float a12;
HXDLIN( 235)										int this25 = ((old >> 24) & 255);
HXDLIN( 235)										if ((this25 == 0)) {
HXDLIN( 235)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											a12 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r11;
HXDLIN( 235)										int this26 = ((old >> 16) & 255);
HXDLIN( 235)										if ((this26 == 0)) {
HXDLIN( 235)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g11;
HXDLIN( 235)										int this27 = ((old >> 8) & 255);
HXDLIN( 235)										if ((this27 == 0)) {
HXDLIN( 235)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b12;
HXDLIN( 235)										int this28 = (old & 255);
HXDLIN( 235)										if ((this28 == 0)) {
HXDLIN( 235)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a21;
HXDLIN( 235)										int this29 = ((rhs >> 24) & 255);
HXDLIN( 235)										if ((this29 == 0)) {
HXDLIN( 235)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r21;
HXDLIN( 235)										int this30 = ((rhs >> 16) & 255);
HXDLIN( 235)										if ((this30 == 0)) {
HXDLIN( 235)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g21;
HXDLIN( 235)										int this31 = ((rhs >> 8) & 255);
HXDLIN( 235)										if ((this31 == 0)) {
HXDLIN( 235)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b22;
HXDLIN( 235)										int this32 = (rhs & 255);
HXDLIN( 235)										if ((this32 == 0)) {
HXDLIN( 235)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 235)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 235)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 235)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 235)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 235)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 235)										{
HXDLIN( 235)											int _hx_tmp7;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 235)												_hx_tmp7 = blended1;
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXDLIN( 235)										int value;
HXDLIN( 235)										if (this1->isLittle) {
HXDLIN( 235)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXDLIN( 235)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this1->image,location1,value);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 235)		{
HXDLIN( 235)			bool hasHit1 = false;
HXDLIN( 235)			bool hasUndo1 = false;
HXDLIN( 235)			int aA1 = ((color2 >> 24) & 255);
HXDLIN( 235)			int rA1 = ((color2 >> 16) & 255);
HXDLIN( 235)			int gA1 = ((color2 >> 8) & 255);
HXDLIN( 235)			int bA1 = (color2 & 255);
HXDLIN( 235)			int aB1 = ((color1 >> 24) & 255);
HXDLIN( 235)			int rB1 = ((color1 >> 16) & 255);
HXDLIN( 235)			int gB1 = ((color1 >> 8) & 255);
HXDLIN( 235)			int bB1 = (color1 & 255);
HXDLIN( 235)			int aC1 = ((color2 >> 24) & 255);
HXDLIN( 235)			int rC1 = ((color2 >> 16) & 255);
HXDLIN( 235)			int gC1 = ((color2 >> 8) & 255);
HXDLIN( 235)			int bC1 = (color2 & 255);
HXDLIN( 235)			Float bcx1 = (cx - dx);
HXDLIN( 235)			Float bcy1 = (cy - dy);
HXDLIN( 235)			Float acx1 = (bx - dx);
HXDLIN( 235)			Float acy1 = (by - dy);
HXDLIN( 235)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 235)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 235)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 235)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 235)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 235)			if ((bx > cx)) {
HXDLIN( 235)				if ((bx > dx)) {
HXDLIN( 235)					int min4;
HXDLIN( 235)					if ((cx > dx)) {
HXDLIN( 235)						min4 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN( 235)						min4 = ::Math_obj::floor(cx);
            					}
HXDLIN( 235)					int ii_min8 = min4;
HXDLIN( 235)					int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 235)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXDLIN( 235)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 235)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 235)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXDLIN( 235)				if ((cx > dx)) {
HXDLIN( 235)					int min5;
HXDLIN( 235)					if ((bx > dx)) {
HXDLIN( 235)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN( 235)						min5 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 235)					int ii_min10 = min5;
HXDLIN( 235)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 235)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXDLIN( 235)					int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 235)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 235)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 235)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 235)			if ((by > cy)) {
HXDLIN( 235)				if ((by > dy)) {
HXDLIN( 235)					int min6;
HXDLIN( 235)					if ((cy > dy)) {
HXDLIN( 235)						min6 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN( 235)						min6 = ::Math_obj::floor(cy);
            					}
HXDLIN( 235)					int ii_min12 = min6;
HXDLIN( 235)					int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 235)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXDLIN( 235)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 235)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 235)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXDLIN( 235)				if ((cy > dy)) {
HXDLIN( 235)					int min7;
HXDLIN( 235)					if ((by > dy)) {
HXDLIN( 235)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN( 235)						min7 = ::Math_obj::ceil(by);
            					}
HXDLIN( 235)					int ii_min14 = min7;
HXDLIN( 235)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 235)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXDLIN( 235)					int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 235)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 235)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 235)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 235)			if (hasUndo1) {
HXDLIN( 235)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 235)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 235)				 ::Dynamic imageType1 = null();
HXDLIN( 235)				 ::pi_xy::ImageStruct this33 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 235)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 235)				::Dynamic undoImage4;
HXDLIN( 235)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN( 235)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 235)						{
HXDLIN( 235)							b6->width = width1;
HXDLIN( 235)							b6->height = height1;
HXDLIN( 235)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 235)							{
HXDLIN( 235)								int len2 = b6->length;
HXDLIN( 235)								int w1 = 0;
HXDLIN( 235)								{
HXDLIN( 235)									int _g20 = 0;
HXDLIN( 235)									int _g21 = b6->height;
HXDLIN( 235)									while((_g20 < _g21)){
HXDLIN( 235)										_g20 = (_g20 + 1);
HXDLIN( 235)										int y3 = (_g20 - 1);
HXDLIN( 235)										{
HXDLIN( 235)											int _g22 = 0;
HXDLIN( 235)											int _g23 = b6->width;
HXDLIN( 235)											while((_g22 < _g23)){
HXDLIN( 235)												_g22 = (_g22 + 1);
HXDLIN( 235)												int x3 = (_g22 - 1);
HXDLIN( 235)												{
HXDLIN( 235)													w1 = (w1 + 1);
HXDLIN( 235)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 235)												{
HXDLIN( 235)													w1 = (w1 + 1);
HXDLIN( 235)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 235)												{
HXDLIN( 235)													w1 = (w1 + 1);
HXDLIN( 235)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 235)												{
HXDLIN( 235)													w1 = (w1 + 1);
HXDLIN( 235)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 235)						undoImage4 = b6;
            					}
            					break;
            					case (int)1: {
HXDLIN( 235)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 235)						{
HXDLIN( 235)							a7->width = width1;
HXDLIN( 235)							a7->height = height1;
HXDLIN( 235)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 235)							a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)							{
HXDLIN( 235)								int _g24 = 0;
HXDLIN( 235)								int _g25 = a7->length;
HXDLIN( 235)								while((_g24 < _g25)){
HXDLIN( 235)									_g24 = (_g24 + 1);
HXDLIN( 235)									int i10 = (_g24 - 1);
HXDLIN( 235)									a7->data[i10] = 0;
            								}
            							}
            						}
HXDLIN( 235)						undoImage4 = a7;
            					}
            					break;
            					case (int)2: {
HXDLIN( 235)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 235)						{
HXDLIN( 235)							b7->width = width1;
HXDLIN( 235)							b7->height = height1;
HXDLIN( 235)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)							int size1 = (b7->length * 4);
HXDLIN( 235)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 235)							{
HXDLIN( 235)								int _g26 = 0;
HXDLIN( 235)								int _g27 = b7->length;
HXDLIN( 235)								while((_g26 < _g27)){
HXDLIN( 235)									_g26 = (_g26 + 1);
HXDLIN( 235)									int i11 = (_g26 - 1);
HXDLIN( 235)									{
HXDLIN( 235)										 ::haxe::io::ArrayBufferViewImpl this34 = b7->data;
HXDLIN( 235)										bool undoImage5;
HXDLIN( 235)										if ((i11 >= 0)) {
HXDLIN( 235)											undoImage5 = (i11 < (this34->byteLength >> 2));
            										}
            										else {
HXDLIN( 235)											undoImage5 = false;
            										}
HXDLIN( 235)										if (undoImage5) {
HXDLIN( 235)											 ::haxe::io::Bytes _this1 = this34->bytes;
HXDLIN( 235)											int pos1 = ((i11 << 2) + this34->byteOffset);
HXDLIN( 235)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 235)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 235)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 235)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 235)						undoImage4 = b7;
            					}
            					break;
            					case (int)3: {
HXDLIN( 235)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 235)						{
HXDLIN( 235)							v2->width = width1;
HXDLIN( 235)							v2->height = height1;
HXDLIN( 235)							v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 235)							{
HXDLIN( 235)								int _g28 = 0;
HXDLIN( 235)								int _g29 = v2->length;
HXDLIN( 235)								while((_g28 < _g29)){
HXDLIN( 235)									_g28 = (_g28 + 1);
HXDLIN( 235)									int i12 = (_g28 - 1);
HXDLIN( 235)									v2->data->__unsafe_set(i12,0);
            								}
            							}
            						}
HXDLIN( 235)						undoImage4 = v2;
            					}
            					break;
            					case (int)4: {
HXDLIN( 235)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)						 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 235)						{
HXDLIN( 235)							b8->width = width1;
HXDLIN( 235)							b8->height = height1;
HXDLIN( 235)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 235)							{
HXDLIN( 235)								int len3 = b8->length;
HXDLIN( 235)								 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 235)								if (::hx::IsNull( d1->head )) {
HXDLIN( 235)									int _g30 = 0;
HXDLIN( 235)									int _g31 = len3;
HXDLIN( 235)									while((_g30 < _g31)){
HXDLIN( 235)										_g30 = (_g30 + 1);
HXDLIN( 235)										int i13 = (_g30 - 1);
HXDLIN( 235)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN( 235)									int _g32 = 0;
HXDLIN( 235)									int _g33 = len3;
HXDLIN( 235)									while((_g32 < _g33)){
HXDLIN( 235)										_g32 = (_g32 + 1);
HXDLIN( 235)										int i14 = (_g32 - 1);
HXDLIN( 235)										{
HXDLIN( 235)											 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 235)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 235)											{
HXDLIN( 235)												int _g34 = 0;
HXDLIN( 235)												int _g35 = i14;
HXDLIN( 235)												while((_g34 < _g35)){
HXDLIN( 235)													_g34 = (_g34 + 1);
HXDLIN( 235)													int i15 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 235)											if (::hx::IsNull( prev1 )) {
HXDLIN( 235)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 235)												l1 = null();
            											}
            											else {
HXDLIN( 235)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 235)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 235)						undoImage4 = b8;
            					}
            					break;
            				}
HXDLIN( 235)				this33->image = undoImage4;
HXDLIN( 235)				this33->width = width1;
HXDLIN( 235)				this33->height = height1;
HXDLIN( 235)				this33->imageType = ( (int)(imageType1) );
HXDLIN( 235)				undoImage3 = this33;
HXDLIN( 235)				{
HXDLIN( 235)					int rectLeft1 = xIter31->start;
HXDLIN( 235)					int rectTop1 = yIter31->start;
HXDLIN( 235)					int rectRight1 = xIter31->max;
HXDLIN( 235)					bool forceClear1 = false;
HXDLIN( 235)					{
HXDLIN( 235)						int _g36 = rectTop1;
HXDLIN( 235)						int _g37 = yIter31->max;
HXDLIN( 235)						while((_g36 < _g37)){
HXDLIN( 235)							_g36 = (_g36 + 1);
HXDLIN( 235)							int dy2 = (_g36 - 1);
HXDLIN( 235)							{
HXDLIN( 235)								int _g38 = rectLeft1;
HXDLIN( 235)								int _g39 = rectRight1;
HXDLIN( 235)								while((_g38 < _g39)){
HXDLIN( 235)									_g38 = (_g38 + 1);
HXDLIN( 235)									int dx2 = (_g38 - 1);
HXDLIN( 235)									::Dynamic this35 = this1->image;
HXDLIN( 235)									int index4;
HXDLIN( 235)									if (this1->useVirtualPos) {
HXDLIN( 235)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            									}
            									else {
HXDLIN( 235)										index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            									}
HXDLIN( 235)									int c3 = ::iterMagic::Iimg_obj::get(this35,index4);
HXDLIN( 235)									int col1;
HXDLIN( 235)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXDLIN( 235)										col1 = c3;
            									}
HXDLIN( 235)									bool _hx_tmp8;
HXDLIN( 235)									if (this1->useMask) {
HXDLIN( 235)										_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN( 235)										_hx_tmp8 = false;
            									}
HXDLIN( 235)									if (_hx_tmp8) {
HXDLIN( 235)										 ::pi_xy::ImageStruct this36 = this1->mask;
HXDLIN( 235)										::Dynamic this37 = this36->image;
HXDLIN( 235)										int index5;
HXDLIN( 235)										if (this36->useVirtualPos) {
HXDLIN( 235)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx2) - this36->virtualX));
            										}
            										else {
HXDLIN( 235)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this36->width) + dx2)) ));
            										}
HXDLIN( 235)										int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 235)										int v3;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											v3 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											v3 = c4;
            										}
HXDLIN( 235)										int maskPixel1 = v3;
HXDLIN( 235)										int this38 = col1;
HXDLIN( 235)										if ((maskPixel1 == 0)) {
HXDLIN( 235)											col1 = this38;
            										}
            										else {
HXDLIN( 235)											Float m01;
HXDLIN( 235)											int this39 = ((maskPixel1 >> 24) & 255);
HXDLIN( 235)											if ((this39 == 0)) {
HXDLIN( 235)												m01 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												m01 = (( (Float)(this39) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float m11;
HXDLIN( 235)											int this40 = ((maskPixel1 >> 16) & 255);
HXDLIN( 235)											if ((this40 == 0)) {
HXDLIN( 235)												m11 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												m11 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float m21;
HXDLIN( 235)											int this41 = ((maskPixel1 >> 8) & 255);
HXDLIN( 235)											if ((this41 == 0)) {
HXDLIN( 235)												m21 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												m21 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float m31;
HXDLIN( 235)											int this42 = (maskPixel1 & 255);
HXDLIN( 235)											if ((this42 == 0)) {
HXDLIN( 235)												m31 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												m31 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this38 >> 24) & 255)) )));
HXDLIN( 235)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this38 >> 16) & 255)) )));
HXDLIN( 235)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this38 >> 8) & 255)) )));
HXDLIN( 235)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this38 & 255)) )));
HXDLIN( 235)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 235)									if ((col1 != 0)) {
HXDLIN( 235)										int x4 = (dx2 - rectLeft1);
HXDLIN( 235)										int y4 = (dy2 - rectTop1);
HXDLIN( 235)										int c5 = col1;
HXDLIN( 235)										bool _hx_tmp9;
HXDLIN( 235)										if ((((c5 >> 24) & 255) < 254)) {
HXDLIN( 235)											_hx_tmp9 = undoImage3->transparent;
            										}
            										else {
HXDLIN( 235)											_hx_tmp9 = false;
            										}
HXDLIN( 235)										if (_hx_tmp9) {
HXDLIN( 235)											int location2;
HXDLIN( 235)											if (undoImage3->useVirtualPos) {
HXDLIN( 235)												location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXDLIN( 235)												location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 235)											int this43 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 235)											int this44;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)												this44 = ((((((this43 >> 24) & 255) << 24) | ((this43 & 255) << 16)) | (((this43 >> 8) & 255) << 8)) | ((this43 >> 16) & 255));
            											}
            											else {
HXDLIN( 235)												this44 = this43;
            											}
HXDLIN( 235)											Float a13;
HXDLIN( 235)											int this45 = ((this44 >> 24) & 255);
HXDLIN( 235)											if ((this45 == 0)) {
HXDLIN( 235)												a13 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												a13 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float r12;
HXDLIN( 235)											int this46 = ((this44 >> 16) & 255);
HXDLIN( 235)											if ((this46 == 0)) {
HXDLIN( 235)												r12 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												r12 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float g12;
HXDLIN( 235)											int this47 = ((this44 >> 8) & 255);
HXDLIN( 235)											if ((this47 == 0)) {
HXDLIN( 235)												g12 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												g12 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float b13;
HXDLIN( 235)											int this48 = (this44 & 255);
HXDLIN( 235)											if ((this48 == 0)) {
HXDLIN( 235)												b13 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												b13 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float a22;
HXDLIN( 235)											int this49 = ((col1 >> 24) & 255);
HXDLIN( 235)											if ((this49 == 0)) {
HXDLIN( 235)												a22 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												a22 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float r22;
HXDLIN( 235)											int this50 = ((col1 >> 16) & 255);
HXDLIN( 235)											if ((this50 == 0)) {
HXDLIN( 235)												r22 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												r22 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float g22;
HXDLIN( 235)											int this51 = ((col1 >> 8) & 255);
HXDLIN( 235)											if ((this51 == 0)) {
HXDLIN( 235)												g22 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												g22 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float b23;
HXDLIN( 235)											int this52 = (col1 & 255);
HXDLIN( 235)											if ((this52 == 0)) {
HXDLIN( 235)												b23 = ((Float)0.);
            											}
            											else {
HXDLIN( 235)												b23 = (( (Float)(this52) ) / ( (Float)(255) ));
            											}
HXDLIN( 235)											Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 235)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 235)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 235)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 235)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 235)											int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 235)											{
HXDLIN( 235)												int _hx_tmp10;
HXDLIN( 235)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)													_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXDLIN( 235)													_hx_tmp10 = blended2;
            												}
HXDLIN( 235)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            											}
            										}
            										else {
HXDLIN( 235)											::Dynamic this53 = undoImage3->image;
HXDLIN( 235)											int index6;
HXDLIN( 235)											if (undoImage3->useVirtualPos) {
HXDLIN( 235)												index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXDLIN( 235)												index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 235)											int _hx_tmp11;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)												_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXDLIN( 235)												_hx_tmp11 = c5;
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(this53,index6,_hx_tmp11);
            										}
            									}
            									else {
HXDLIN( 235)										if (forceClear1) {
HXDLIN( 235)											::Dynamic this54 = undoImage3->image;
HXDLIN( 235)											int x5 = (dx2 - rectLeft1);
HXDLIN( 235)											int y5 = (dy2 - rectTop1);
HXDLIN( 235)											int index7;
HXDLIN( 235)											if (undoImage3->useVirtualPos) {
HXDLIN( 235)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXDLIN( 235)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(this54,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 235)			{
HXDLIN( 235)				int _g_min2 = xIter31->start;
HXDLIN( 235)				int _g_max2 = xIter31->max;
HXDLIN( 235)				while((_g_min2 < _g_max2)){
HXDLIN( 235)					_g_min2 = (_g_min2 + 1);
HXDLIN( 235)					int px2 = (_g_min2 - 1);
HXDLIN( 235)					Float pcx1 = (( (Float)(px2) ) - dx);
HXDLIN( 235)					{
HXDLIN( 235)						int _g_min3 = yIter31->start;
HXDLIN( 235)						int _g_max3 = yIter31->max;
HXDLIN( 235)						while((_g_min3 < _g_max3)){
HXDLIN( 235)							_g_min3 = (_g_min3 + 1);
HXDLIN( 235)							int py2 = (_g_min3 - 1);
HXDLIN( 235)							Float pcy1 = (( (Float)(py2) ) - dy);
HXDLIN( 235)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 235)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 235)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 235)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 235)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 235)							bool _hx_tmp12;
HXDLIN( 235)							bool _hx_tmp13;
HXDLIN( 235)							if ((ratioA1 >= 0)) {
HXDLIN( 235)								_hx_tmp13 = (ratioB1 >= 0);
            							}
            							else {
HXDLIN( 235)								_hx_tmp13 = false;
            							}
HXDLIN( 235)							if (_hx_tmp13) {
HXDLIN( 235)								_hx_tmp12 = (ratioC1 >= 0);
            							}
            							else {
HXDLIN( 235)								_hx_tmp12 = false;
            							}
HXDLIN( 235)							if (_hx_tmp12) {
HXDLIN( 235)								int i16 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 235)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE( 235)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE( 235)								int a9 = i16;
HXDLIN( 235)								int i17 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 235)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE( 235)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE( 235)								int r6 = i17;
HXDLIN( 235)								int i18 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 235)								if ((i18 > 255)) {
HXLINE(  24)									i18 = 255;
            								}
HXLINE( 235)								if ((i18 < 0)) {
HXLINE(  25)									i18 = 0;
            								}
HXLINE( 235)								int g6 = i18;
HXDLIN( 235)								int i19 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 235)								if ((i19 > 255)) {
HXLINE(  24)									i19 = 255;
            								}
HXLINE( 235)								if ((i19 < 0)) {
HXLINE(  25)									i19 = 0;
            								}
HXLINE( 235)								int b10 = i19;
HXDLIN( 235)								{
HXDLIN( 235)									int location3;
HXDLIN( 235)									if (this1->useVirtualPos) {
HXDLIN( 235)										location3 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this1->virtualY) * ( (Float)(this1->width) )) + px2) - this1->virtualX));
            									}
            									else {
HXDLIN( 235)										location3 = ::Std_obj::_hx_int(( (Float)(((py2 * this1->width) + px2)) ));
            									}
HXDLIN( 235)									bool _hx_tmp14;
HXDLIN( 235)									if (this1->transparent) {
HXDLIN( 235)										_hx_tmp14 = (a9 < 254);
            									}
            									else {
HXDLIN( 235)										_hx_tmp14 = false;
            									}
HXDLIN( 235)									if (_hx_tmp14) {
HXDLIN( 235)										int this55 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 235)										int old1;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											old1 = ((((((this55 >> 24) & 255) << 24) | ((this55 & 255) << 16)) | (((this55 >> 8) & 255) << 8)) | ((this55 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											old1 = this55;
            										}
HXDLIN( 235)										int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 235)										Float a14;
HXDLIN( 235)										int this56 = ((old1 >> 24) & 255);
HXDLIN( 235)										if ((this56 == 0)) {
HXDLIN( 235)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											a14 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r13;
HXDLIN( 235)										int this57 = ((old1 >> 16) & 255);
HXDLIN( 235)										if ((this57 == 0)) {
HXDLIN( 235)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g13;
HXDLIN( 235)										int this58 = ((old1 >> 8) & 255);
HXDLIN( 235)										if ((this58 == 0)) {
HXDLIN( 235)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b14;
HXDLIN( 235)										int this59 = (old1 & 255);
HXDLIN( 235)										if ((this59 == 0)) {
HXDLIN( 235)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a23;
HXDLIN( 235)										int this60 = ((rhs1 >> 24) & 255);
HXDLIN( 235)										if ((this60 == 0)) {
HXDLIN( 235)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r23;
HXDLIN( 235)										int this61 = ((rhs1 >> 16) & 255);
HXDLIN( 235)										if ((this61 == 0)) {
HXDLIN( 235)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g23;
HXDLIN( 235)										int this62 = ((rhs1 >> 8) & 255);
HXDLIN( 235)										if ((this62 == 0)) {
HXDLIN( 235)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b24;
HXDLIN( 235)										int this63 = (rhs1 & 255);
HXDLIN( 235)										if ((this63 == 0)) {
HXDLIN( 235)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 235)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 235)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 235)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 235)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 235)										int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 235)										{
HXDLIN( 235)											int _hx_tmp15;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)												_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 235)												_hx_tmp15 = blended3;
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp15);
            										}
            									}
            									else {
HXDLIN( 235)										int value1;
HXDLIN( 235)										if (this1->isLittle) {
HXDLIN( 235)											value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            										}
            										else {
HXDLIN( 235)											value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this1->image,location3,value1);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 235)			if ((hasHit1 == false)) {
HXDLIN( 235)				 ::pi_xy::algo::HitTri v4 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 235)				if (hasUndo1) {
HXDLIN( 235)					v4->undoImage = undoImage3;
HXDLIN( 235)					v4->undoX = xIter31->start;
HXDLIN( 235)					v4->undoY = yIter31->start;
            				}
            			}
            		}
HXDLIN( 235)		 ::pi_xy::algo::HitQuad v5 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 235)		 ::pi_xy::algo::HitQuad hitQuad = v5;
HXDLIN( 235)		Float cx1 = h2;
HXDLIN( 235)		Float cy1 = radius2;
HXDLIN( 235)		Float bx1 = h2;
HXDLIN( 235)		Float by1 = -(radius2);
HXDLIN( 235)		Float dx3 = hSmall;
HXDLIN( 235)		Float dy3 = radius2;
HXDLIN( 235)		Float ax1 = hSmall;
HXDLIN( 235)		Float ay1 = -(radius2);
HXLINE( 335)		temp = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE( 336)		by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE( 337)		bx1 = temp;
HXLINE( 338)		temp = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE( 339)		cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE( 340)		cx1 = temp;
HXLINE( 342)		temp = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE( 343)		ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE( 344)		ax1 = temp;
HXLINE( 346)		temp = (px + ((dx3 * cos) - (dy3 * sin)));
HXLINE( 347)		dy3 = (py + ((dy3 * cos) + (dx3 * sin)));
HXLINE( 348)		dx3 = temp;
HXLINE( 235)		 ::pi_xy::pixel::_TwoGrad::TwoGrad_ twoColors =  ::pi_xy::pixel::_TwoGrad::TwoGrad__obj::__alloc( HX_CTX ,color1,color2);
HXDLIN( 235)		int a15 = twoColors->colorClock;
HXDLIN( 235)		int b16 = twoColors->colorAnti;
HXDLIN( 235)		int half = ((((::Math_obj::round(((((( (Float)(((a15 >> 24) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b16 >> 24) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 24) | (::Math_obj::round(((((( (Float)(((a15 >> 16) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b16 >> 16) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 16)) | (::Math_obj::round(((((( (Float)(((a15 >> 8) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b16 >> 8) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 8)) | ::Math_obj::round(((((( (Float)((a15 & 255)) ) / ( (Float)(255) )) + (( (Float)((b16 & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))));
HXDLIN( 235)		bool hasUndo2 = false;
HXDLIN( 235)		int aA2 = ((color1 >> 24) & 255);
HXDLIN( 235)		int rA2 = ((color1 >> 16) & 255);
HXDLIN( 235)		int gA2 = ((color1 >> 8) & 255);
HXDLIN( 235)		int bA2 = (color1 & 255);
HXDLIN( 235)		int aB2 = ((half >> 24) & 255);
HXDLIN( 235)		int rB2 = ((half >> 16) & 255);
HXDLIN( 235)		int gB2 = ((half >> 8) & 255);
HXDLIN( 235)		int bB2 = (half & 255);
HXDLIN( 235)		int aC2 = ((color2 >> 24) & 255);
HXDLIN( 235)		int rC2 = ((color2 >> 16) & 255);
HXDLIN( 235)		int gC2 = ((color2 >> 8) & 255);
HXDLIN( 235)		int bC2 = (color2 & 255);
HXDLIN( 235)		Float bcx2 = (bx1 - cx1);
HXDLIN( 235)		Float bcy2 = (by1 - cy1);
HXDLIN( 235)		Float acx2 = (qx - cx1);
HXDLIN( 235)		Float acy2 = (qy - cy1);
HXDLIN( 235)		Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 235)		Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 235)		Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 235)		Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 235)		 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 235)		if ((qx > bx1)) {
HXDLIN( 235)			if ((qx > cx1)) {
HXDLIN( 235)				int min8;
HXDLIN( 235)				if ((bx1 > cx1)) {
HXDLIN( 235)					min8 = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN( 235)					min8 = ::Math_obj::floor(bx1);
            				}
HXDLIN( 235)				int ii_min16 = min8;
HXDLIN( 235)				int ii_max16 = ::Math_obj::ceil(qx);
HXDLIN( 235)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            			}
            			else {
HXDLIN( 235)				int ii_min17 = ::Math_obj::floor(bx1);
HXDLIN( 235)				int ii_max17 = ::Math_obj::ceil(cx1);
HXDLIN( 235)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            			}
            		}
            		else {
HXDLIN( 235)			if ((bx1 > cx1)) {
HXDLIN( 235)				int min9;
HXDLIN( 235)				if ((qx > cx1)) {
HXDLIN( 235)					min9 = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN( 235)					min9 = ::Math_obj::ceil(qx);
            				}
HXDLIN( 235)				int ii_min18 = min9;
HXDLIN( 235)				int ii_max18 = ::Math_obj::ceil(bx1);
HXDLIN( 235)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            			}
            			else {
HXDLIN( 235)				int ii_min19 = ::Math_obj::floor(qx);
HXDLIN( 235)				int ii_max19 = ::Math_obj::ceil(cx1);
HXDLIN( 235)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            			}
            		}
HXDLIN( 235)		 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 235)		if ((qy > by1)) {
HXDLIN( 235)			if ((qy > cy1)) {
HXDLIN( 235)				int min10;
HXDLIN( 235)				if ((by1 > cy1)) {
HXDLIN( 235)					min10 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN( 235)					min10 = ::Math_obj::floor(by1);
            				}
HXDLIN( 235)				int ii_min20 = min10;
HXDLIN( 235)				int ii_max20 = ::Math_obj::ceil(qy);
HXDLIN( 235)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            			}
            			else {
HXDLIN( 235)				int ii_min21 = ::Math_obj::floor(by1);
HXDLIN( 235)				int ii_max21 = ::Math_obj::ceil(cy1);
HXDLIN( 235)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            			}
            		}
            		else {
HXDLIN( 235)			if ((by1 > cy1)) {
HXDLIN( 235)				int min11;
HXDLIN( 235)				if ((qy > cy1)) {
HXDLIN( 235)					min11 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN( 235)					min11 = ::Math_obj::ceil(qy);
            				}
HXDLIN( 235)				int ii_min22 = min11;
HXDLIN( 235)				int ii_max22 = ::Math_obj::ceil(by1);
HXDLIN( 235)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            			}
            			else {
HXDLIN( 235)				int ii_min23 = ::Math_obj::floor(qy);
HXDLIN( 235)				int ii_max23 = ::Math_obj::ceil(cy1);
HXDLIN( 235)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            			}
            		}
HXDLIN( 235)		 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 235)		if (hasUndo2) {
HXDLIN( 235)			int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 235)			int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 235)			 ::Dynamic imageType2 = null();
HXDLIN( 235)			 ::pi_xy::ImageStruct this64 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 235)			if (::hx::IsNull( imageType2 )) {
HXLINE(  54)				imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 235)			::Dynamic undoImage7;
HXDLIN( 235)			switch((int)(( (int)(imageType2) ))){
            				case (int)0: {
HXDLIN( 235)					 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::BytesImg b17 = byt2;
HXDLIN( 235)					{
HXDLIN( 235)						b17->width = width2;
HXDLIN( 235)						b17->height = height2;
HXDLIN( 235)						b17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 235)						b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN( 235)						{
HXDLIN( 235)							int len4 = b17->length;
HXDLIN( 235)							int w2 = 0;
HXDLIN( 235)							{
HXDLIN( 235)								int _g40 = 0;
HXDLIN( 235)								int _g41 = b17->height;
HXDLIN( 235)								while((_g40 < _g41)){
HXDLIN( 235)									_g40 = (_g40 + 1);
HXDLIN( 235)									int y6 = (_g40 - 1);
HXDLIN( 235)									{
HXDLIN( 235)										int _g42 = 0;
HXDLIN( 235)										int _g43 = b17->width;
HXDLIN( 235)										while((_g42 < _g43)){
HXDLIN( 235)											_g42 = (_g42 + 1);
HXDLIN( 235)											int x6 = (_g42 - 1);
HXDLIN( 235)											{
HXDLIN( 235)												w2 = (w2 + 1);
HXDLIN( 235)												b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 235)											{
HXDLIN( 235)												w2 = (w2 + 1);
HXDLIN( 235)												b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 235)											{
HXDLIN( 235)												w2 = (w2 + 1);
HXDLIN( 235)												b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 235)											{
HXDLIN( 235)												w2 = (w2 + 1);
HXDLIN( 235)												b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 235)					undoImage7 = b17;
            				}
            				break;
            				case (int)1: {
HXDLIN( 235)					 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::ArrIntImg a16 = arrI2;
HXDLIN( 235)					{
HXDLIN( 235)						a16->width = width2;
HXDLIN( 235)						a16->height = height2;
HXDLIN( 235)						a16->data = ::Array_obj< int >::__new(0);
HXDLIN( 235)						a16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 235)						{
HXDLIN( 235)							int _g44 = 0;
HXDLIN( 235)							int _g45 = a16->length;
HXDLIN( 235)							while((_g44 < _g45)){
HXDLIN( 235)								_g44 = (_g44 + 1);
HXDLIN( 235)								int i20 = (_g44 - 1);
HXDLIN( 235)								a16->data[i20] = 0;
            							}
            						}
            					}
HXDLIN( 235)					undoImage7 = a16;
            				}
            				break;
            				case (int)2: {
HXDLIN( 235)					 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::U32ArrImg b18 = u32a2;
HXDLIN( 235)					{
HXDLIN( 235)						b18->width = width2;
HXDLIN( 235)						b18->height = height2;
HXDLIN( 235)						b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 235)						int size2 = (b18->length * 4);
HXDLIN( 235)						b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 235)						{
HXDLIN( 235)							int _g46 = 0;
HXDLIN( 235)							int _g47 = b18->length;
HXDLIN( 235)							while((_g46 < _g47)){
HXDLIN( 235)								_g46 = (_g46 + 1);
HXDLIN( 235)								int i21 = (_g46 - 1);
HXDLIN( 235)								{
HXDLIN( 235)									 ::haxe::io::ArrayBufferViewImpl this65 = b18->data;
HXDLIN( 235)									bool undoImage8;
HXDLIN( 235)									if ((i21 >= 0)) {
HXDLIN( 235)										undoImage8 = (i21 < (this65->byteLength >> 2));
            									}
            									else {
HXDLIN( 235)										undoImage8 = false;
            									}
HXDLIN( 235)									if (undoImage8) {
HXDLIN( 235)										 ::haxe::io::Bytes _this2 = this65->bytes;
HXDLIN( 235)										int pos2 = ((i21 << 2) + this65->byteOffset);
HXDLIN( 235)										_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 235)										_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 235)										_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 235)										_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 235)					undoImage7 = b18;
            				}
            				break;
            				case (int)3: {
HXDLIN( 235)					 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN( 235)					{
HXDLIN( 235)						v6->width = width2;
HXDLIN( 235)						v6->height = height2;
HXDLIN( 235)						v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 235)						v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 235)						{
HXDLIN( 235)							int _g48 = 0;
HXDLIN( 235)							int _g49 = v6->length;
HXDLIN( 235)							while((_g48 < _g49)){
HXDLIN( 235)								_g48 = (_g48 + 1);
HXDLIN( 235)								int i22 = (_g48 - 1);
HXDLIN( 235)								v6->data->__unsafe_set(i22,0);
            							}
            						}
            					}
HXDLIN( 235)					undoImage7 = v6;
            				}
            				break;
            				case (int)4: {
HXDLIN( 235)					 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::StackIntImg b19 = sInt2;
HXDLIN( 235)					{
HXDLIN( 235)						b19->width = width2;
HXDLIN( 235)						b19->height = height2;
HXDLIN( 235)						b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 235)						b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 235)						{
HXDLIN( 235)							int len5 = b19->length;
HXDLIN( 235)							 ::haxe::ds::GenericStack_Int d2 = b19->data;
HXDLIN( 235)							if (::hx::IsNull( d2->head )) {
HXDLIN( 235)								int _g50 = 0;
HXDLIN( 235)								int _g51 = len5;
HXDLIN( 235)								while((_g50 < _g51)){
HXDLIN( 235)									_g50 = (_g50 + 1);
HXDLIN( 235)									int i23 = (_g50 - 1);
HXDLIN( 235)									d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            								}
            							}
            							else {
HXDLIN( 235)								int _g52 = 0;
HXDLIN( 235)								int _g53 = len5;
HXDLIN( 235)								while((_g52 < _g53)){
HXDLIN( 235)									_g52 = (_g52 + 1);
HXDLIN( 235)									int i24 = (_g52 - 1);
HXDLIN( 235)									{
HXDLIN( 235)										 ::haxe::ds::GenericCell_Int l2 = b19->data->head;
HXDLIN( 235)										 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 235)										{
HXDLIN( 235)											int _g54 = 0;
HXDLIN( 235)											int _g55 = i24;
HXDLIN( 235)											while((_g54 < _g55)){
HXDLIN( 235)												_g54 = (_g54 + 1);
HXDLIN( 235)												int i25 = (_g54 - 1);
HXLINE( 345)												prev2 = l2;
HXLINE( 346)												l2 = l2->next;
            											}
            										}
HXLINE( 235)										if (::hx::IsNull( prev2 )) {
HXDLIN( 235)											b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 235)											l2 = null();
            										}
            										else {
HXDLIN( 235)											prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 235)											l2 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 235)					undoImage7 = b19;
            				}
            				break;
            			}
HXDLIN( 235)			this64->image = undoImage7;
HXDLIN( 235)			this64->width = width2;
HXDLIN( 235)			this64->height = height2;
HXDLIN( 235)			this64->imageType = ( (int)(imageType2) );
HXDLIN( 235)			undoImage6 = this64;
HXDLIN( 235)			{
HXDLIN( 235)				int rectLeft2 = xIter32->start;
HXDLIN( 235)				int rectTop2 = yIter32->start;
HXDLIN( 235)				int rectRight2 = xIter32->max;
HXDLIN( 235)				bool forceClear2 = false;
HXDLIN( 235)				{
HXDLIN( 235)					int _g56 = rectTop2;
HXDLIN( 235)					int _g57 = yIter32->max;
HXDLIN( 235)					while((_g56 < _g57)){
HXDLIN( 235)						_g56 = (_g56 + 1);
HXDLIN( 235)						int dy4 = (_g56 - 1);
HXDLIN( 235)						{
HXDLIN( 235)							int _g58 = rectLeft2;
HXDLIN( 235)							int _g59 = rectRight2;
HXDLIN( 235)							while((_g58 < _g59)){
HXDLIN( 235)								_g58 = (_g58 + 1);
HXDLIN( 235)								int dx4 = (_g58 - 1);
HXDLIN( 235)								::Dynamic this66 = this1->image;
HXDLIN( 235)								int index8;
HXDLIN( 235)								if (this1->useVirtualPos) {
HXDLIN( 235)									index8 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx4) - this1->virtualX));
            								}
            								else {
HXDLIN( 235)									index8 = ::Std_obj::_hx_int(( (Float)(((dy4 * this1->width) + dx4)) ));
            								}
HXDLIN( 235)								int c6 = ::iterMagic::Iimg_obj::get(this66,index8);
HXDLIN( 235)								int col2;
HXDLIN( 235)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)									col2 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            								}
            								else {
HXDLIN( 235)									col2 = c6;
            								}
HXDLIN( 235)								bool _hx_tmp16;
HXDLIN( 235)								if (this1->useMask) {
HXDLIN( 235)									_hx_tmp16 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 235)									_hx_tmp16 = false;
            								}
HXDLIN( 235)								if (_hx_tmp16) {
HXDLIN( 235)									 ::pi_xy::ImageStruct this67 = this1->mask;
HXDLIN( 235)									::Dynamic this68 = this67->image;
HXDLIN( 235)									int index9;
HXDLIN( 235)									if (this67->useVirtualPos) {
HXDLIN( 235)										index9 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this67->virtualY) * ( (Float)(this67->width) )) + dx4) - this67->virtualX));
            									}
            									else {
HXDLIN( 235)										index9 = ::Std_obj::_hx_int(( (Float)(((dy4 * this67->width) + dx4)) ));
            									}
HXDLIN( 235)									int c7 = ::iterMagic::Iimg_obj::get(this68,index9);
HXDLIN( 235)									int v7;
HXDLIN( 235)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)										v7 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXDLIN( 235)										v7 = c7;
            									}
HXDLIN( 235)									int maskPixel2 = v7;
HXDLIN( 235)									int this69 = col2;
HXDLIN( 235)									if ((maskPixel2 == 0)) {
HXDLIN( 235)										col2 = this69;
            									}
            									else {
HXDLIN( 235)										Float m02;
HXDLIN( 235)										int this70 = ((maskPixel2 >> 24) & 255);
HXDLIN( 235)										if ((this70 == 0)) {
HXDLIN( 235)											m02 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											m02 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float m12;
HXDLIN( 235)										int this71 = ((maskPixel2 >> 16) & 255);
HXDLIN( 235)										if ((this71 == 0)) {
HXDLIN( 235)											m12 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											m12 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float m22;
HXDLIN( 235)										int this72 = ((maskPixel2 >> 8) & 255);
HXDLIN( 235)										if ((this72 == 0)) {
HXDLIN( 235)											m22 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											m22 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float m32;
HXDLIN( 235)										int this73 = (maskPixel2 & 255);
HXDLIN( 235)										if ((this73 == 0)) {
HXDLIN( 235)											m32 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											m32 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this69 >> 24) & 255)) )));
HXDLIN( 235)										int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this69 >> 16) & 255)) )));
HXDLIN( 235)										int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this69 >> 8) & 255)) )));
HXDLIN( 235)										int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this69 & 255)) )));
HXDLIN( 235)										col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 235)								if ((col2 != 0)) {
HXDLIN( 235)									int x7 = (dx4 - rectLeft2);
HXDLIN( 235)									int y7 = (dy4 - rectTop2);
HXDLIN( 235)									int c8 = col2;
HXDLIN( 235)									bool _hx_tmp17;
HXDLIN( 235)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 235)										_hx_tmp17 = undoImage6->transparent;
            									}
            									else {
HXDLIN( 235)										_hx_tmp17 = false;
            									}
HXDLIN( 235)									if (_hx_tmp17) {
HXDLIN( 235)										int location4;
HXDLIN( 235)										if (undoImage6->useVirtualPos) {
HXDLIN( 235)											location4 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 235)											location4 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            										}
HXDLIN( 235)										int this74 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 235)										int this75;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											this75 = ((((((this74 >> 24) & 255) << 24) | ((this74 & 255) << 16)) | (((this74 >> 8) & 255) << 8)) | ((this74 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											this75 = this74;
            										}
HXDLIN( 235)										Float a17;
HXDLIN( 235)										int this76 = ((this75 >> 24) & 255);
HXDLIN( 235)										if ((this76 == 0)) {
HXDLIN( 235)											a17 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											a17 = (( (Float)(this76) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r14;
HXDLIN( 235)										int this77 = ((this75 >> 16) & 255);
HXDLIN( 235)										if ((this77 == 0)) {
HXDLIN( 235)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											r14 = (( (Float)(this77) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g14;
HXDLIN( 235)										int this78 = ((this75 >> 8) & 255);
HXDLIN( 235)										if ((this78 == 0)) {
HXDLIN( 235)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											g14 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b110;
HXDLIN( 235)										int this79 = (this75 & 255);
HXDLIN( 235)										if ((this79 == 0)) {
HXDLIN( 235)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											b110 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a24;
HXDLIN( 235)										int this80 = ((col2 >> 24) & 255);
HXDLIN( 235)										if ((this80 == 0)) {
HXDLIN( 235)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											a24 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r24;
HXDLIN( 235)										int this81 = ((col2 >> 16) & 255);
HXDLIN( 235)										if ((this81 == 0)) {
HXDLIN( 235)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											r24 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g24;
HXDLIN( 235)										int this82 = ((col2 >> 8) & 255);
HXDLIN( 235)										if ((this82 == 0)) {
HXDLIN( 235)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											g24 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b25;
HXDLIN( 235)										int this83 = (col2 & 255);
HXDLIN( 235)										if ((this83 == 0)) {
HXDLIN( 235)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											b25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a34 = (a17 * (( (Float)(1) ) - a24));
HXDLIN( 235)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 235)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 235)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN( 235)										int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 235)										int blended4 = ((((a18 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 235)										{
HXDLIN( 235)											int _hx_tmp18;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)												_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 235)												_hx_tmp18 = blended4;
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            										}
            									}
            									else {
HXDLIN( 235)										::Dynamic this84 = undoImage6->image;
HXDLIN( 235)										int index10;
HXDLIN( 235)										if (undoImage6->useVirtualPos) {
HXDLIN( 235)											index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 235)											index10 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            										}
HXDLIN( 235)										int _hx_tmp19;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											_hx_tmp19 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											_hx_tmp19 = c8;
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this84,index10,_hx_tmp19);
            									}
            								}
            								else {
HXDLIN( 235)									if (forceClear2) {
HXDLIN( 235)										::Dynamic this85 = undoImage6->image;
HXDLIN( 235)										int x8 = (dx4 - rectLeft2);
HXDLIN( 235)										int y8 = (dy4 - rectTop2);
HXDLIN( 235)										int index11;
HXDLIN( 235)										if (undoImage6->useVirtualPos) {
HXDLIN( 235)											index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 235)											index11 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this85,index11,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 235)		{
HXDLIN( 235)			int _g_min4 = xIter32->start;
HXDLIN( 235)			int _g_max4 = xIter32->max;
HXDLIN( 235)			while((_g_min4 < _g_max4)){
HXDLIN( 235)				_g_min4 = (_g_min4 + 1);
HXDLIN( 235)				int px3 = (_g_min4 - 1);
HXDLIN( 235)				Float pcx2 = (( (Float)(px3) ) - cx1);
HXDLIN( 235)				{
HXDLIN( 235)					int _g_min5 = yIter32->start;
HXDLIN( 235)					int _g_max5 = yIter32->max;
HXDLIN( 235)					while((_g_min5 < _g_max5)){
HXDLIN( 235)						_g_min5 = (_g_min5 + 1);
HXDLIN( 235)						int py3 = (_g_min5 - 1);
HXDLIN( 235)						Float pcy2 = (( (Float)(py3) ) - cy1);
HXDLIN( 235)						Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 235)						Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 235)						Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 235)						Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 235)						Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 235)						bool _hx_tmp20;
HXDLIN( 235)						bool _hx_tmp21;
HXDLIN( 235)						if ((ratioA2 >= 0)) {
HXDLIN( 235)							_hx_tmp21 = (ratioB2 >= 0);
            						}
            						else {
HXDLIN( 235)							_hx_tmp21 = false;
            						}
HXDLIN( 235)						if (_hx_tmp21) {
HXDLIN( 235)							_hx_tmp20 = (ratioC2 >= 0);
            						}
            						else {
HXDLIN( 235)							_hx_tmp20 = false;
            						}
HXDLIN( 235)						if (_hx_tmp20) {
HXDLIN( 235)							int i26 = ::Std_obj::_hx_int((((( (Float)(aA2) ) * ratioA2) + (( (Float)(aB2) ) * ratioB2)) + (( (Float)(aC2) ) * ratioC2)));
HXDLIN( 235)							if ((i26 > 255)) {
HXLINE(  24)								i26 = 255;
            							}
HXLINE( 235)							if ((i26 < 0)) {
HXLINE(  25)								i26 = 0;
            							}
HXLINE( 235)							int a19 = i26;
HXDLIN( 235)							int i27 = ::Std_obj::_hx_int((((( (Float)(rA2) ) * ratioA2) + (( (Float)(rB2) ) * ratioB2)) + (( (Float)(rC2) ) * ratioC2)));
HXDLIN( 235)							if ((i27 > 255)) {
HXLINE(  24)								i27 = 255;
            							}
HXLINE( 235)							if ((i27 < 0)) {
HXLINE(  25)								i27 = 0;
            							}
HXLINE( 235)							int r9 = i27;
HXDLIN( 235)							int i28 = ::Std_obj::_hx_int((((( (Float)(gA2) ) * ratioA2) + (( (Float)(gB2) ) * ratioB2)) + (( (Float)(gC2) ) * ratioC2)));
HXDLIN( 235)							if ((i28 > 255)) {
HXLINE(  24)								i28 = 255;
            							}
HXLINE( 235)							if ((i28 < 0)) {
HXLINE(  25)								i28 = 0;
            							}
HXLINE( 235)							int g9 = i28;
HXDLIN( 235)							int i29 = ::Std_obj::_hx_int((((( (Float)(bA2) ) * ratioA2) + (( (Float)(bB2) ) * ratioB2)) + (( (Float)(bC2) ) * ratioC2)));
HXDLIN( 235)							if ((i29 > 255)) {
HXLINE(  24)								i29 = 255;
            							}
HXLINE( 235)							if ((i29 < 0)) {
HXLINE(  25)								i29 = 0;
            							}
HXLINE( 235)							int b26 = i29;
HXDLIN( 235)							{
HXDLIN( 235)								int location5;
HXDLIN( 235)								if (this1->useVirtualPos) {
HXDLIN( 235)									location5 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this1->virtualY) * ( (Float)(this1->width) )) + px3) - this1->virtualX));
            								}
            								else {
HXDLIN( 235)									location5 = ::Std_obj::_hx_int(( (Float)(((py3 * this1->width) + px3)) ));
            								}
HXDLIN( 235)								bool _hx_tmp22;
HXDLIN( 235)								if (this1->transparent) {
HXDLIN( 235)									_hx_tmp22 = (a19 < 254);
            								}
            								else {
HXDLIN( 235)									_hx_tmp22 = false;
            								}
HXDLIN( 235)								if (_hx_tmp22) {
HXDLIN( 235)									int this86 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 235)									int old2;
HXDLIN( 235)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)										old2 = ((((((this86 >> 24) & 255) << 24) | ((this86 & 255) << 16)) | (((this86 >> 8) & 255) << 8)) | ((this86 >> 16) & 255));
            									}
            									else {
HXDLIN( 235)										old2 = this86;
            									}
HXDLIN( 235)									int rhs2 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b26);
HXDLIN( 235)									Float a110;
HXDLIN( 235)									int this87 = ((old2 >> 24) & 255);
HXDLIN( 235)									if ((this87 == 0)) {
HXDLIN( 235)										a110 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										a110 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float r15;
HXDLIN( 235)									int this88 = ((old2 >> 16) & 255);
HXDLIN( 235)									if ((this88 == 0)) {
HXDLIN( 235)										r15 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										r15 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float g15;
HXDLIN( 235)									int this89 = ((old2 >> 8) & 255);
HXDLIN( 235)									if ((this89 == 0)) {
HXDLIN( 235)										g15 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										g15 = (( (Float)(this89) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float b111;
HXDLIN( 235)									int this90 = (old2 & 255);
HXDLIN( 235)									if ((this90 == 0)) {
HXDLIN( 235)										b111 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										b111 = (( (Float)(this90) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float a25;
HXDLIN( 235)									int this91 = ((rhs2 >> 24) & 255);
HXDLIN( 235)									if ((this91 == 0)) {
HXDLIN( 235)										a25 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										a25 = (( (Float)(this91) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float r25;
HXDLIN( 235)									int this92 = ((rhs2 >> 16) & 255);
HXDLIN( 235)									if ((this92 == 0)) {
HXDLIN( 235)										r25 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										r25 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float g25;
HXDLIN( 235)									int this93 = ((rhs2 >> 8) & 255);
HXDLIN( 235)									if ((this93 == 0)) {
HXDLIN( 235)										g25 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										g25 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float b27;
HXDLIN( 235)									int this94 = (rhs2 & 255);
HXDLIN( 235)									if ((this94 == 0)) {
HXDLIN( 235)										b27 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										b27 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 235)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 235)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 235)									int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b27 * a25))));
HXDLIN( 235)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 235)									int blended5 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b28);
HXDLIN( 235)									{
HXDLIN( 235)										int _hx_tmp23;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											_hx_tmp23 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											_hx_tmp23 = blended5;
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp23);
            									}
            								}
            								else {
HXDLIN( 235)									int value2;
HXDLIN( 235)									if (this1->isLittle) {
HXDLIN( 235)										value2 = ((((a19 << 24) | (b26 << 16)) | (g9 << 8)) | r9);
            									}
            									else {
HXDLIN( 235)										value2 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b26);
            									}
HXDLIN( 235)									::iterMagic::Iimg_obj::set(this1->image,location5,value2);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 235)		 ::pi_xy::algo::HitTri hitTriTop;
HXDLIN( 235)		if ((hasHit == false)) {
HXDLIN( 235)			 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx1,by1,cx1,cy1,true);
HXDLIN( 235)			if (hasUndo2) {
HXDLIN( 235)				v8->undoImage = undoImage6;
HXDLIN( 235)				v8->undoX = xIter32->start;
HXDLIN( 235)				v8->undoY = yIter32->start;
            			}
HXDLIN( 235)			hitTriTop = v8;
            		}
            		else {
HXDLIN( 235)			hitTriTop = null();
            		}
HXDLIN( 235)		bool hasUndo3 = false;
HXDLIN( 235)		int aA3 = ((color1 >> 24) & 255);
HXDLIN( 235)		int rA3 = ((color1 >> 16) & 255);
HXDLIN( 235)		int gA3 = ((color1 >> 8) & 255);
HXDLIN( 235)		int bA3 = (color1 & 255);
HXDLIN( 235)		int aB3 = ((half >> 24) & 255);
HXDLIN( 235)		int rB3 = ((half >> 16) & 255);
HXDLIN( 235)		int gB3 = ((half >> 8) & 255);
HXDLIN( 235)		int bB3 = (half & 255);
HXDLIN( 235)		int aC3 = ((color2 >> 24) & 255);
HXDLIN( 235)		int rC3 = ((color2 >> 16) & 255);
HXDLIN( 235)		int gC3 = ((color2 >> 8) & 255);
HXDLIN( 235)		int bC3 = (color2 & 255);
HXDLIN( 235)		Float bcx3 = (ax1 - dx3);
HXDLIN( 235)		Float bcy3 = (ay1 - dy3);
HXDLIN( 235)		Float acx3 = (px - dx3);
HXDLIN( 235)		Float acy3 = (py - dy3);
HXDLIN( 235)		Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 235)		Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 235)		Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 235)		Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 235)		 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 235)		if ((px > ax1)) {
HXDLIN( 235)			if ((px > dx3)) {
HXDLIN( 235)				int min12;
HXDLIN( 235)				if ((ax1 > dx3)) {
HXDLIN( 235)					min12 = ::Math_obj::floor(dx3);
            				}
            				else {
HXDLIN( 235)					min12 = ::Math_obj::floor(ax1);
            				}
HXDLIN( 235)				int ii_min24 = min12;
HXDLIN( 235)				int ii_max24 = ::Math_obj::ceil(px);
HXDLIN( 235)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            			}
            			else {
HXDLIN( 235)				int ii_min25 = ::Math_obj::floor(ax1);
HXDLIN( 235)				int ii_max25 = ::Math_obj::ceil(dx3);
HXDLIN( 235)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            			}
            		}
            		else {
HXDLIN( 235)			if ((ax1 > dx3)) {
HXDLIN( 235)				int min13;
HXDLIN( 235)				if ((px > dx3)) {
HXDLIN( 235)					min13 = ::Math_obj::floor(dx3);
            				}
            				else {
HXDLIN( 235)					min13 = ::Math_obj::ceil(px);
            				}
HXDLIN( 235)				int ii_min26 = min13;
HXDLIN( 235)				int ii_max26 = ::Math_obj::ceil(ax1);
HXDLIN( 235)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            			}
            			else {
HXDLIN( 235)				int ii_min27 = ::Math_obj::floor(px);
HXDLIN( 235)				int ii_max27 = ::Math_obj::ceil(dx3);
HXDLIN( 235)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            			}
            		}
HXDLIN( 235)		 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 235)		if ((py > ay1)) {
HXDLIN( 235)			if ((py > dy3)) {
HXDLIN( 235)				int min14;
HXDLIN( 235)				if ((ay1 > dy3)) {
HXDLIN( 235)					min14 = ::Math_obj::floor(dy3);
            				}
            				else {
HXDLIN( 235)					min14 = ::Math_obj::floor(ay1);
            				}
HXDLIN( 235)				int ii_min28 = min14;
HXDLIN( 235)				int ii_max28 = ::Math_obj::ceil(py);
HXDLIN( 235)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            			}
            			else {
HXDLIN( 235)				int ii_min29 = ::Math_obj::floor(ay1);
HXDLIN( 235)				int ii_max29 = ::Math_obj::ceil(dy3);
HXDLIN( 235)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            			}
            		}
            		else {
HXDLIN( 235)			if ((ay1 > dy3)) {
HXDLIN( 235)				int min15;
HXDLIN( 235)				if ((py > dy3)) {
HXDLIN( 235)					min15 = ::Math_obj::floor(dy3);
            				}
            				else {
HXDLIN( 235)					min15 = ::Math_obj::ceil(py);
            				}
HXDLIN( 235)				int ii_min30 = min15;
HXDLIN( 235)				int ii_max30 = ::Math_obj::ceil(ay1);
HXDLIN( 235)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            			}
            			else {
HXDLIN( 235)				int ii_min31 = ::Math_obj::floor(py);
HXDLIN( 235)				int ii_max31 = ::Math_obj::ceil(dy3);
HXDLIN( 235)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            			}
            		}
HXDLIN( 235)		 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 235)		if (hasUndo3) {
HXDLIN( 235)			int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 235)			int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 235)			 ::Dynamic imageType3 = null();
HXDLIN( 235)			 ::pi_xy::ImageStruct this95 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 235)			if (::hx::IsNull( imageType3 )) {
HXLINE(  54)				imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 235)			::Dynamic undoImage10;
HXDLIN( 235)			switch((int)(( (int)(imageType3) ))){
            				case (int)0: {
HXDLIN( 235)					 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::BytesImg b29 = byt3;
HXDLIN( 235)					{
HXDLIN( 235)						b29->width = width3;
HXDLIN( 235)						b29->height = height3;
HXDLIN( 235)						b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 235)						b29->data = ::haxe::io::Bytes_obj::alloc((b29->length * 4));
HXDLIN( 235)						{
HXDLIN( 235)							int len6 = b29->length;
HXDLIN( 235)							int w3 = 0;
HXDLIN( 235)							{
HXDLIN( 235)								int _g60 = 0;
HXDLIN( 235)								int _g61 = b29->height;
HXDLIN( 235)								while((_g60 < _g61)){
HXDLIN( 235)									_g60 = (_g60 + 1);
HXDLIN( 235)									int y9 = (_g60 - 1);
HXDLIN( 235)									{
HXDLIN( 235)										int _g62 = 0;
HXDLIN( 235)										int _g63 = b29->width;
HXDLIN( 235)										while((_g62 < _g63)){
HXDLIN( 235)											_g62 = (_g62 + 1);
HXDLIN( 235)											int x9 = (_g62 - 1);
HXDLIN( 235)											{
HXDLIN( 235)												w3 = (w3 + 1);
HXDLIN( 235)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 235)											{
HXDLIN( 235)												w3 = (w3 + 1);
HXDLIN( 235)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 235)											{
HXDLIN( 235)												w3 = (w3 + 1);
HXDLIN( 235)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 235)											{
HXDLIN( 235)												w3 = (w3 + 1);
HXDLIN( 235)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 235)					undoImage10 = b29;
            				}
            				break;
            				case (int)1: {
HXDLIN( 235)					 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::ArrIntImg a26 = arrI3;
HXDLIN( 235)					{
HXDLIN( 235)						a26->width = width3;
HXDLIN( 235)						a26->height = height3;
HXDLIN( 235)						a26->data = ::Array_obj< int >::__new(0);
HXDLIN( 235)						a26->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 235)						{
HXDLIN( 235)							int _g64 = 0;
HXDLIN( 235)							int _g65 = a26->length;
HXDLIN( 235)							while((_g64 < _g65)){
HXDLIN( 235)								_g64 = (_g64 + 1);
HXDLIN( 235)								int i30 = (_g64 - 1);
HXDLIN( 235)								a26->data[i30] = 0;
            							}
            						}
            					}
HXDLIN( 235)					undoImage10 = a26;
            				}
            				break;
            				case (int)2: {
HXDLIN( 235)					 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::U32ArrImg b30 = u32a3;
HXDLIN( 235)					{
HXDLIN( 235)						b30->width = width3;
HXDLIN( 235)						b30->height = height3;
HXDLIN( 235)						b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 235)						int size3 = (b30->length * 4);
HXDLIN( 235)						b30->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 235)						{
HXDLIN( 235)							int _g66 = 0;
HXDLIN( 235)							int _g67 = b30->length;
HXDLIN( 235)							while((_g66 < _g67)){
HXDLIN( 235)								_g66 = (_g66 + 1);
HXDLIN( 235)								int i31 = (_g66 - 1);
HXDLIN( 235)								{
HXDLIN( 235)									 ::haxe::io::ArrayBufferViewImpl this96 = b30->data;
HXDLIN( 235)									bool undoImage11;
HXDLIN( 235)									if ((i31 >= 0)) {
HXDLIN( 235)										undoImage11 = (i31 < (this96->byteLength >> 2));
            									}
            									else {
HXDLIN( 235)										undoImage11 = false;
            									}
HXDLIN( 235)									if (undoImage11) {
HXDLIN( 235)										 ::haxe::io::Bytes _this3 = this96->bytes;
HXDLIN( 235)										int pos3 = ((i31 << 2) + this96->byteOffset);
HXDLIN( 235)										_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 235)										_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 235)										_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 235)										_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 235)					undoImage10 = b30;
            				}
            				break;
            				case (int)3: {
HXDLIN( 235)					 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN( 235)					{
HXDLIN( 235)						v9->width = width3;
HXDLIN( 235)						v9->height = height3;
HXDLIN( 235)						v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 235)						v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN( 235)						{
HXDLIN( 235)							int _g68 = 0;
HXDLIN( 235)							int _g69 = v9->length;
HXDLIN( 235)							while((_g68 < _g69)){
HXDLIN( 235)								_g68 = (_g68 + 1);
HXDLIN( 235)								int i32 = (_g68 - 1);
HXDLIN( 235)								v9->data->__unsafe_set(i32,0);
            							}
            						}
            					}
HXDLIN( 235)					undoImage10 = v9;
            				}
            				break;
            				case (int)4: {
HXDLIN( 235)					 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)					 ::iterMagic::StackIntImg b31 = sInt3;
HXDLIN( 235)					{
HXDLIN( 235)						b31->width = width3;
HXDLIN( 235)						b31->height = height3;
HXDLIN( 235)						b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 235)						b31->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 235)						{
HXDLIN( 235)							int len7 = b31->length;
HXDLIN( 235)							 ::haxe::ds::GenericStack_Int d3 = b31->data;
HXDLIN( 235)							if (::hx::IsNull( d3->head )) {
HXDLIN( 235)								int _g70 = 0;
HXDLIN( 235)								int _g71 = len7;
HXDLIN( 235)								while((_g70 < _g71)){
HXDLIN( 235)									_g70 = (_g70 + 1);
HXDLIN( 235)									int i33 = (_g70 - 1);
HXDLIN( 235)									d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            								}
            							}
            							else {
HXDLIN( 235)								int _g72 = 0;
HXDLIN( 235)								int _g73 = len7;
HXDLIN( 235)								while((_g72 < _g73)){
HXDLIN( 235)									_g72 = (_g72 + 1);
HXDLIN( 235)									int i34 = (_g72 - 1);
HXDLIN( 235)									{
HXDLIN( 235)										 ::haxe::ds::GenericCell_Int l3 = b31->data->head;
HXDLIN( 235)										 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 235)										{
HXDLIN( 235)											int _g74 = 0;
HXDLIN( 235)											int _g75 = i34;
HXDLIN( 235)											while((_g74 < _g75)){
HXDLIN( 235)												_g74 = (_g74 + 1);
HXDLIN( 235)												int i35 = (_g74 - 1);
HXLINE( 345)												prev3 = l3;
HXLINE( 346)												l3 = l3->next;
            											}
            										}
HXLINE( 235)										if (::hx::IsNull( prev3 )) {
HXDLIN( 235)											b31->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 235)											l3 = null();
            										}
            										else {
HXDLIN( 235)											prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 235)											l3 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 235)					undoImage10 = b31;
            				}
            				break;
            			}
HXDLIN( 235)			this95->image = undoImage10;
HXDLIN( 235)			this95->width = width3;
HXDLIN( 235)			this95->height = height3;
HXDLIN( 235)			this95->imageType = ( (int)(imageType3) );
HXDLIN( 235)			undoImage9 = this95;
HXDLIN( 235)			{
HXDLIN( 235)				int rectLeft3 = xIter33->start;
HXDLIN( 235)				int rectTop3 = yIter33->start;
HXDLIN( 235)				int rectRight3 = xIter33->max;
HXDLIN( 235)				bool forceClear3 = false;
HXDLIN( 235)				{
HXDLIN( 235)					int _g76 = rectTop3;
HXDLIN( 235)					int _g77 = yIter33->max;
HXDLIN( 235)					while((_g76 < _g77)){
HXDLIN( 235)						_g76 = (_g76 + 1);
HXDLIN( 235)						int dy5 = (_g76 - 1);
HXDLIN( 235)						{
HXDLIN( 235)							int _g78 = rectLeft3;
HXDLIN( 235)							int _g79 = rectRight3;
HXDLIN( 235)							while((_g78 < _g79)){
HXDLIN( 235)								_g78 = (_g78 + 1);
HXDLIN( 235)								int dx5 = (_g78 - 1);
HXDLIN( 235)								::Dynamic this97 = this1->image;
HXDLIN( 235)								int index12;
HXDLIN( 235)								if (this1->useVirtualPos) {
HXDLIN( 235)									index12 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx5) - this1->virtualX));
            								}
            								else {
HXDLIN( 235)									index12 = ::Std_obj::_hx_int(( (Float)(((dy5 * this1->width) + dx5)) ));
            								}
HXDLIN( 235)								int c9 = ::iterMagic::Iimg_obj::get(this97,index12);
HXDLIN( 235)								int col3;
HXDLIN( 235)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)									col3 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXDLIN( 235)									col3 = c9;
            								}
HXDLIN( 235)								bool _hx_tmp24;
HXDLIN( 235)								if (this1->useMask) {
HXDLIN( 235)									_hx_tmp24 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 235)									_hx_tmp24 = false;
            								}
HXDLIN( 235)								if (_hx_tmp24) {
HXDLIN( 235)									 ::pi_xy::ImageStruct this98 = this1->mask;
HXDLIN( 235)									::Dynamic this99 = this98->image;
HXDLIN( 235)									int index13;
HXDLIN( 235)									if (this98->useVirtualPos) {
HXDLIN( 235)										index13 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this98->virtualY) * ( (Float)(this98->width) )) + dx5) - this98->virtualX));
            									}
            									else {
HXDLIN( 235)										index13 = ::Std_obj::_hx_int(( (Float)(((dy5 * this98->width) + dx5)) ));
            									}
HXDLIN( 235)									int c10 = ::iterMagic::Iimg_obj::get(this99,index13);
HXDLIN( 235)									int v10;
HXDLIN( 235)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)										v10 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXDLIN( 235)										v10 = c10;
            									}
HXDLIN( 235)									int maskPixel3 = v10;
HXDLIN( 235)									int this100 = col3;
HXDLIN( 235)									if ((maskPixel3 == 0)) {
HXDLIN( 235)										col3 = this100;
            									}
            									else {
HXDLIN( 235)										Float m03;
HXDLIN( 235)										int this101 = ((maskPixel3 >> 24) & 255);
HXDLIN( 235)										if ((this101 == 0)) {
HXDLIN( 235)											m03 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											m03 = (( (Float)(this101) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float m13;
HXDLIN( 235)										int this102 = ((maskPixel3 >> 16) & 255);
HXDLIN( 235)										if ((this102 == 0)) {
HXDLIN( 235)											m13 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											m13 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float m23;
HXDLIN( 235)										int this103 = ((maskPixel3 >> 8) & 255);
HXDLIN( 235)										if ((this103 == 0)) {
HXDLIN( 235)											m23 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											m23 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float m33;
HXDLIN( 235)										int this104 = (maskPixel3 & 255);
HXDLIN( 235)										if ((this104 == 0)) {
HXDLIN( 235)											m33 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											m33 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this100 >> 24) & 255)) )));
HXDLIN( 235)										int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this100 >> 16) & 255)) )));
HXDLIN( 235)										int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this100 >> 8) & 255)) )));
HXDLIN( 235)										int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this100 & 255)) )));
HXDLIN( 235)										col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 235)								if ((col3 != 0)) {
HXDLIN( 235)									int x10 = (dx5 - rectLeft3);
HXDLIN( 235)									int y10 = (dy5 - rectTop3);
HXDLIN( 235)									int c11 = col3;
HXDLIN( 235)									bool _hx_tmp25;
HXDLIN( 235)									if ((((c11 >> 24) & 255) < 254)) {
HXDLIN( 235)										_hx_tmp25 = undoImage9->transparent;
            									}
            									else {
HXDLIN( 235)										_hx_tmp25 = false;
            									}
HXDLIN( 235)									if (_hx_tmp25) {
HXDLIN( 235)										int location6;
HXDLIN( 235)										if (undoImage9->useVirtualPos) {
HXDLIN( 235)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 235)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            										}
HXDLIN( 235)										int this105 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 235)										int this106;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											this106 = ((((((this105 >> 24) & 255) << 24) | ((this105 & 255) << 16)) | (((this105 >> 8) & 255) << 8)) | ((this105 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											this106 = this105;
            										}
HXDLIN( 235)										Float a111;
HXDLIN( 235)										int this107 = ((this106 >> 24) & 255);
HXDLIN( 235)										if ((this107 == 0)) {
HXDLIN( 235)											a111 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											a111 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r16;
HXDLIN( 235)										int this108 = ((this106 >> 16) & 255);
HXDLIN( 235)										if ((this108 == 0)) {
HXDLIN( 235)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											r16 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g16;
HXDLIN( 235)										int this109 = ((this106 >> 8) & 255);
HXDLIN( 235)										if ((this109 == 0)) {
HXDLIN( 235)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											g16 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b112;
HXDLIN( 235)										int this110 = (this106 & 255);
HXDLIN( 235)										if ((this110 == 0)) {
HXDLIN( 235)											b112 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											b112 = (( (Float)(this110) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a27;
HXDLIN( 235)										int this111 = ((col3 >> 24) & 255);
HXDLIN( 235)										if ((this111 == 0)) {
HXDLIN( 235)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											a27 = (( (Float)(this111) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float r26;
HXDLIN( 235)										int this112 = ((col3 >> 16) & 255);
HXDLIN( 235)										if ((this112 == 0)) {
HXDLIN( 235)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											r26 = (( (Float)(this112) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float g26;
HXDLIN( 235)										int this113 = ((col3 >> 8) & 255);
HXDLIN( 235)										if ((this113 == 0)) {
HXDLIN( 235)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											g26 = (( (Float)(this113) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float b210;
HXDLIN( 235)										int this114 = (col3 & 255);
HXDLIN( 235)										if ((this114 == 0)) {
HXDLIN( 235)											b210 = ((Float)0.);
            										}
            										else {
HXDLIN( 235)											b210 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 235)										Float a36 = (a111 * (( (Float)(1) ) - a27));
HXDLIN( 235)										int r17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a27))));
HXDLIN( 235)										int g17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a27))));
HXDLIN( 235)										int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a27))));
HXDLIN( 235)										int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a27)));
HXDLIN( 235)										int blended6 = ((((a28 << 24) | (r17 << 16)) | (g17 << 8)) | b32);
HXDLIN( 235)										{
HXDLIN( 235)											int _hx_tmp26;
HXDLIN( 235)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)												_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 235)												_hx_tmp26 = blended6;
            											}
HXDLIN( 235)											::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            										}
            									}
            									else {
HXDLIN( 235)										::Dynamic this115 = undoImage9->image;
HXDLIN( 235)										int index14;
HXDLIN( 235)										if (undoImage9->useVirtualPos) {
HXDLIN( 235)											index14 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 235)											index14 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            										}
HXDLIN( 235)										int _hx_tmp27;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											_hx_tmp27 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											_hx_tmp27 = c11;
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this115,index14,_hx_tmp27);
            									}
            								}
            								else {
HXDLIN( 235)									if (forceClear3) {
HXDLIN( 235)										::Dynamic this116 = undoImage9->image;
HXDLIN( 235)										int x11 = (dx5 - rectLeft3);
HXDLIN( 235)										int y11 = (dy5 - rectTop3);
HXDLIN( 235)										int index15;
HXDLIN( 235)										if (undoImage9->useVirtualPos) {
HXDLIN( 235)											index15 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 235)											index15 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this116,index15,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 235)		{
HXDLIN( 235)			int _g_min6 = xIter33->start;
HXDLIN( 235)			int _g_max6 = xIter33->max;
HXDLIN( 235)			while((_g_min6 < _g_max6)){
HXDLIN( 235)				_g_min6 = (_g_min6 + 1);
HXDLIN( 235)				int px4 = (_g_min6 - 1);
HXDLIN( 235)				Float pcx3 = (( (Float)(px4) ) - dx3);
HXDLIN( 235)				{
HXDLIN( 235)					int _g_min7 = yIter33->start;
HXDLIN( 235)					int _g_max7 = yIter33->max;
HXDLIN( 235)					while((_g_min7 < _g_max7)){
HXDLIN( 235)						_g_min7 = (_g_min7 + 1);
HXDLIN( 235)						int py4 = (_g_min7 - 1);
HXDLIN( 235)						Float pcy3 = (( (Float)(py4) ) - dy3);
HXDLIN( 235)						Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 235)						Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 235)						Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 235)						Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 235)						Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 235)						bool _hx_tmp28;
HXDLIN( 235)						bool _hx_tmp29;
HXDLIN( 235)						if ((ratioA3 >= 0)) {
HXDLIN( 235)							_hx_tmp29 = (ratioB3 >= 0);
            						}
            						else {
HXDLIN( 235)							_hx_tmp29 = false;
            						}
HXDLIN( 235)						if (_hx_tmp29) {
HXDLIN( 235)							_hx_tmp28 = (ratioC3 >= 0);
            						}
            						else {
HXDLIN( 235)							_hx_tmp28 = false;
            						}
HXDLIN( 235)						if (_hx_tmp28) {
HXDLIN( 235)							int i36 = ::Std_obj::_hx_int((((( (Float)(aA3) ) * ratioA3) + (( (Float)(aB3) ) * ratioB3)) + (( (Float)(aC3) ) * ratioC3)));
HXDLIN( 235)							if ((i36 > 255)) {
HXLINE(  24)								i36 = 255;
            							}
HXLINE( 235)							if ((i36 < 0)) {
HXLINE(  25)								i36 = 0;
            							}
HXLINE( 235)							int a29 = i36;
HXDLIN( 235)							int i37 = ::Std_obj::_hx_int((((( (Float)(rA3) ) * ratioA3) + (( (Float)(rB3) ) * ratioB3)) + (( (Float)(rC3) ) * ratioC3)));
HXDLIN( 235)							if ((i37 > 255)) {
HXLINE(  24)								i37 = 255;
            							}
HXLINE( 235)							if ((i37 < 0)) {
HXLINE(  25)								i37 = 0;
            							}
HXLINE( 235)							int r18 = i37;
HXDLIN( 235)							int i38 = ::Std_obj::_hx_int((((( (Float)(gA3) ) * ratioA3) + (( (Float)(gB3) ) * ratioB3)) + (( (Float)(gC3) ) * ratioC3)));
HXDLIN( 235)							if ((i38 > 255)) {
HXLINE(  24)								i38 = 255;
            							}
HXLINE( 235)							if ((i38 < 0)) {
HXLINE(  25)								i38 = 0;
            							}
HXLINE( 235)							int g18 = i38;
HXDLIN( 235)							int i39 = ::Std_obj::_hx_int((((( (Float)(bA3) ) * ratioA3) + (( (Float)(bB3) ) * ratioB3)) + (( (Float)(bC3) ) * ratioC3)));
HXDLIN( 235)							if ((i39 > 255)) {
HXLINE(  24)								i39 = 255;
            							}
HXLINE( 235)							if ((i39 < 0)) {
HXLINE(  25)								i39 = 0;
            							}
HXLINE( 235)							int b33 = i39;
HXDLIN( 235)							{
HXDLIN( 235)								int location7;
HXDLIN( 235)								if (this1->useVirtualPos) {
HXDLIN( 235)									location7 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - this1->virtualY) * ( (Float)(this1->width) )) + px4) - this1->virtualX));
            								}
            								else {
HXDLIN( 235)									location7 = ::Std_obj::_hx_int(( (Float)(((py4 * this1->width) + px4)) ));
            								}
HXDLIN( 235)								bool _hx_tmp30;
HXDLIN( 235)								if (this1->transparent) {
HXDLIN( 235)									_hx_tmp30 = (a29 < 254);
            								}
            								else {
HXDLIN( 235)									_hx_tmp30 = false;
            								}
HXDLIN( 235)								if (_hx_tmp30) {
HXDLIN( 235)									int this117 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN( 235)									int old3;
HXDLIN( 235)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)										old3 = ((((((this117 >> 24) & 255) << 24) | ((this117 & 255) << 16)) | (((this117 >> 8) & 255) << 8)) | ((this117 >> 16) & 255));
            									}
            									else {
HXDLIN( 235)										old3 = this117;
            									}
HXDLIN( 235)									int rhs3 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b33);
HXDLIN( 235)									Float a112;
HXDLIN( 235)									int this118 = ((old3 >> 24) & 255);
HXDLIN( 235)									if ((this118 == 0)) {
HXDLIN( 235)										a112 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										a112 = (( (Float)(this118) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float r19;
HXDLIN( 235)									int this119 = ((old3 >> 16) & 255);
HXDLIN( 235)									if ((this119 == 0)) {
HXDLIN( 235)										r19 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										r19 = (( (Float)(this119) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float g19;
HXDLIN( 235)									int this120 = ((old3 >> 8) & 255);
HXDLIN( 235)									if ((this120 == 0)) {
HXDLIN( 235)										g19 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										g19 = (( (Float)(this120) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float b113;
HXDLIN( 235)									int this121 = (old3 & 255);
HXDLIN( 235)									if ((this121 == 0)) {
HXDLIN( 235)										b113 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										b113 = (( (Float)(this121) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float a210;
HXDLIN( 235)									int this122 = ((rhs3 >> 24) & 255);
HXDLIN( 235)									if ((this122 == 0)) {
HXDLIN( 235)										a210 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										a210 = (( (Float)(this122) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float r27;
HXDLIN( 235)									int this123 = ((rhs3 >> 16) & 255);
HXDLIN( 235)									if ((this123 == 0)) {
HXDLIN( 235)										r27 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										r27 = (( (Float)(this123) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float g27;
HXDLIN( 235)									int this124 = ((rhs3 >> 8) & 255);
HXDLIN( 235)									if ((this124 == 0)) {
HXDLIN( 235)										g27 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										g27 = (( (Float)(this124) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float b211;
HXDLIN( 235)									int this125 = (rhs3 & 255);
HXDLIN( 235)									if ((this125 == 0)) {
HXDLIN( 235)										b211 = ((Float)0.);
            									}
            									else {
HXDLIN( 235)										b211 = (( (Float)(this125) ) / ( (Float)(255) ));
            									}
HXDLIN( 235)									Float a37 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 235)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a37) + (r27 * a210))));
HXDLIN( 235)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a37) + (g27 * a210))));
HXDLIN( 235)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a210))));
HXDLIN( 235)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a210)));
HXDLIN( 235)									int blended7 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 235)									{
HXDLIN( 235)										int _hx_tmp31;
HXDLIN( 235)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)											_hx_tmp31 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXDLIN( 235)											_hx_tmp31 = blended7;
            										}
HXDLIN( 235)										::iterMagic::Iimg_obj::set(this1->image,location7,_hx_tmp31);
            									}
            								}
            								else {
HXDLIN( 235)									int value3;
HXDLIN( 235)									if (this1->isLittle) {
HXDLIN( 235)										value3 = ((((a29 << 24) | (b33 << 16)) | (g18 << 8)) | r18);
            									}
            									else {
HXDLIN( 235)										value3 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b33);
            									}
HXDLIN( 235)									::iterMagic::Iimg_obj::set(this1->image,location7,value3);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 235)		 ::pi_xy::algo::HitTri hitTriBottom;
HXDLIN( 235)		if ((hasHit == false)) {
HXDLIN( 235)			 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,px,py,ax1,ay1,dx3,dy3,true);
HXDLIN( 235)			if (hasUndo3) {
HXDLIN( 235)				v11->undoImage = undoImage9;
HXDLIN( 235)				v11->undoX = xIter33->start;
HXDLIN( 235)				v11->undoY = yIter33->start;
            			}
HXDLIN( 235)			hitTriBottom = v11;
            		}
            		else {
HXDLIN( 235)			hitTriBottom = null();
            		}
HXDLIN( 235)		if (hasHit) {
HXDLIN( 235)			 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN( 235)			if (::hx::IsNotNull( hitQuad )) {
HXDLIN( 235)				hitArr->triArr->push(hitQuad->triABD);
            			}
HXDLIN( 235)			hitArr->triArr->push(hitQuad->triBCD);
HXDLIN( 235)			return hitArr;
            		}
            		else {
HXDLIN( 235)			return null();
            		}
HXDLIN( 235)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(GradientShape_Impl__obj,thickArrowBoth,return )

 ::pi_xy::algo::HitTriArray GradientShape_Impl__obj::thickFixArrow( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float arrowWidth,Float arrowHeight,Float thick,int color1,int color2,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< bool >  __o_hasHit){
            		bool flare = __o_flare.Default(false);
            		bool reverseFlare = __o_reverseFlare.Default(false);
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_251_thickFixArrow)
HXDLIN( 251)		Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 251)		Float o = (qy - py);
HXDLIN( 251)		Float a = (qx - px);
HXDLIN( 251)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 251)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 251)		Float thicker;
HXDLIN( 251)		if ((arrowWidth > (thick * ((Float)1.1)))) {
HXDLIN( 251)			thicker = arrowWidth;
            		}
            		else {
HXDLIN( 251)			thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            		}
HXDLIN( 251)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 251)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 251)		Float radius = (thick / ( (Float)(2) ));
HXDLIN( 251)		Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 251)		Float h2;
HXDLIN( 251)		if ((arrowHeight < (h * ((Float)1.1)))) {
HXDLIN( 251)			h2 = (h - arrowHeight);
            		}
            		else {
HXDLIN( 251)			h2 = (h / goldenRatio);
            		}
HXDLIN( 251)		 ::pi_xy::algo::HitQuad hitQuad;
HXDLIN( 251)		if (flare) {
HXDLIN( 251)			if (reverseFlare) {
HXDLIN( 251)				Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 251)				Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 251)				Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 251)				Float radius21 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN( 251)				Float dx = ((Float)0.1);
HXDLIN( 251)				Float dy = radius1;
HXDLIN( 251)				Float cx = h2;
HXDLIN( 251)				Float cy = radius21;
HXDLIN( 251)				Float bx = h2;
HXDLIN( 251)				Float by = -(radius21);
HXDLIN( 251)				Float ax = ((Float)0.1);
HXDLIN( 251)				Float ay = -(radius1);
HXDLIN( 251)				Float temp = ((Float)0.);
HXLINE( 525)				temp = (px + ((ax * cos1) - (ay * sin1)));
HXLINE( 526)				ay = (py + ((ay * cos1) + (ax * sin1)));
HXLINE( 527)				ax = temp;
HXLINE( 529)				temp = (px + ((bx * cos1) - (by * sin1)));
HXLINE( 530)				by = (py + ((by * cos1) + (bx * sin1)));
HXLINE( 531)				bx = temp;
HXLINE( 533)				temp = (px + ((cx * cos1) - (cy * sin1)));
HXLINE( 534)				cy = (py + ((cy * cos1) + (cx * sin1)));
HXLINE( 535)				cx = temp;
HXLINE( 537)				temp = (px + ((dx * cos1) - (dy * sin1)));
HXLINE( 538)				dy = (py + ((dy * cos1) + (dx * sin1)));
HXLINE( 539)				dx = temp;
HXLINE( 251)				{
HXDLIN( 251)					bool hasUndo = false;
HXDLIN( 251)					int aA = ((color1 >> 24) & 255);
HXDLIN( 251)					int rA = ((color1 >> 16) & 255);
HXDLIN( 251)					int gA = ((color1 >> 8) & 255);
HXDLIN( 251)					int bA = (color1 & 255);
HXDLIN( 251)					int aB = ((color1 >> 24) & 255);
HXDLIN( 251)					int rB = ((color1 >> 16) & 255);
HXDLIN( 251)					int gB = ((color1 >> 8) & 255);
HXDLIN( 251)					int bB = (color1 & 255);
HXDLIN( 251)					int aC = ((color2 >> 24) & 255);
HXDLIN( 251)					int rC = ((color2 >> 16) & 255);
HXDLIN( 251)					int gC = ((color2 >> 8) & 255);
HXDLIN( 251)					int bC = (color2 & 255);
HXDLIN( 251)					Float bcx = (bx - dx);
HXDLIN( 251)					Float bcy = (by - dy);
HXDLIN( 251)					Float acx = (ax - dx);
HXDLIN( 251)					Float acy = (ay - dy);
HXDLIN( 251)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 251)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 251)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 251)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 251)					 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 251)					if ((ax > bx)) {
HXDLIN( 251)						if ((ax > dx)) {
HXDLIN( 251)							int min;
HXDLIN( 251)							if ((bx > dx)) {
HXDLIN( 251)								min = ::Math_obj::floor(dx);
            							}
            							else {
HXDLIN( 251)								min = ::Math_obj::floor(bx);
            							}
HXDLIN( 251)							int ii_min = min;
HXDLIN( 251)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 251)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXDLIN( 251)							int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 251)							int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 251)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            						}
            					}
            					else {
HXDLIN( 251)						if ((bx > dx)) {
HXDLIN( 251)							int min1;
HXDLIN( 251)							if ((ax > dx)) {
HXDLIN( 251)								min1 = ::Math_obj::floor(dx);
            							}
            							else {
HXDLIN( 251)								min1 = ::Math_obj::ceil(ax);
            							}
HXDLIN( 251)							int ii_min2 = min1;
HXDLIN( 251)							int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 251)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            						}
            						else {
HXDLIN( 251)							int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 251)							int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 251)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            					}
HXDLIN( 251)					 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 251)					if ((ay > by)) {
HXDLIN( 251)						if ((ay > dy)) {
HXDLIN( 251)							int min2;
HXDLIN( 251)							if ((by > dy)) {
HXDLIN( 251)								min2 = ::Math_obj::floor(dy);
            							}
            							else {
HXDLIN( 251)								min2 = ::Math_obj::floor(by);
            							}
HXDLIN( 251)							int ii_min4 = min2;
HXDLIN( 251)							int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 251)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
            						else {
HXDLIN( 251)							int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 251)							int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 251)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            						}
            					}
            					else {
HXDLIN( 251)						if ((by > dy)) {
HXDLIN( 251)							int min3;
HXDLIN( 251)							if ((ay > dy)) {
HXDLIN( 251)								min3 = ::Math_obj::floor(dy);
            							}
            							else {
HXDLIN( 251)								min3 = ::Math_obj::ceil(ay);
            							}
HXDLIN( 251)							int ii_min6 = min3;
HXDLIN( 251)							int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 251)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            						}
            						else {
HXDLIN( 251)							int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 251)							int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 251)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            						}
            					}
HXDLIN( 251)					 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 251)					if (hasUndo) {
HXDLIN( 251)						int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 251)						int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 251)						 ::Dynamic imageType = null();
HXDLIN( 251)						 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 251)						if (::hx::IsNull( imageType )) {
HXLINE(  54)							imageType = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 251)						::Dynamic undoImage1;
HXDLIN( 251)						switch((int)(( (int)(imageType) ))){
            							case (int)0: {
HXDLIN( 251)								 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::BytesImg b = byt;
HXDLIN( 251)								{
HXDLIN( 251)									b->width = width;
HXDLIN( 251)									b->height = height;
HXDLIN( 251)									b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 251)									b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 251)									{
HXDLIN( 251)										int len = b->length;
HXDLIN( 251)										int w = 0;
HXDLIN( 251)										{
HXDLIN( 251)											int _g = 0;
HXDLIN( 251)											int _g1 = b->height;
HXDLIN( 251)											while((_g < _g1)){
HXDLIN( 251)												_g = (_g + 1);
HXDLIN( 251)												int y = (_g - 1);
HXDLIN( 251)												{
HXDLIN( 251)													int _g2 = 0;
HXDLIN( 251)													int _g3 = b->width;
HXDLIN( 251)													while((_g2 < _g3)){
HXDLIN( 251)														_g2 = (_g2 + 1);
HXDLIN( 251)														int x = (_g2 - 1);
HXDLIN( 251)														{
HXDLIN( 251)															w = (w + 1);
HXDLIN( 251)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w = (w + 1);
HXDLIN( 251)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w = (w + 1);
HXDLIN( 251)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w = (w + 1);
HXDLIN( 251)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage1 = b;
            							}
            							break;
            							case (int)1: {
HXDLIN( 251)								 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 251)								{
HXDLIN( 251)									a1->width = width;
HXDLIN( 251)									a1->height = height;
HXDLIN( 251)									a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 251)									a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 251)									{
HXDLIN( 251)										int _g4 = 0;
HXDLIN( 251)										int _g5 = a1->length;
HXDLIN( 251)										while((_g4 < _g5)){
HXDLIN( 251)											_g4 = (_g4 + 1);
HXDLIN( 251)											int i = (_g4 - 1);
HXDLIN( 251)											a1->data[i] = 0;
            										}
            									}
            								}
HXDLIN( 251)								undoImage1 = a1;
            							}
            							break;
            							case (int)2: {
HXDLIN( 251)								 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 251)								{
HXDLIN( 251)									b1->width = width;
HXDLIN( 251)									b1->height = height;
HXDLIN( 251)									b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 251)									int size = (b1->length * 4);
HXDLIN( 251)									b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 251)									{
HXDLIN( 251)										int _g6 = 0;
HXDLIN( 251)										int _g7 = b1->length;
HXDLIN( 251)										while((_g6 < _g7)){
HXDLIN( 251)											_g6 = (_g6 + 1);
HXDLIN( 251)											int i1 = (_g6 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 251)												bool undoImage2;
HXDLIN( 251)												if ((i1 >= 0)) {
HXDLIN( 251)													undoImage2 = (i1 < (this3->byteLength >> 2));
            												}
            												else {
HXDLIN( 251)													undoImage2 = false;
            												}
HXDLIN( 251)												if (undoImage2) {
HXDLIN( 251)													 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 251)													int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 251)													_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 251)													_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 251)													_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 251)													_this->b[(pos + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage1 = b1;
            							}
            							break;
            							case (int)3: {
HXDLIN( 251)								 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::VecIntImg v = vec;
HXDLIN( 251)								{
HXDLIN( 251)									v->width = width;
HXDLIN( 251)									v->height = height;
HXDLIN( 251)									v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 251)									v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 251)									{
HXDLIN( 251)										int _g8 = 0;
HXDLIN( 251)										int _g9 = v->length;
HXDLIN( 251)										while((_g8 < _g9)){
HXDLIN( 251)											_g8 = (_g8 + 1);
HXDLIN( 251)											int i2 = (_g8 - 1);
HXDLIN( 251)											v->data->__unsafe_set(i2,0);
            										}
            									}
            								}
HXDLIN( 251)								undoImage1 = v;
            							}
            							break;
            							case (int)4: {
HXDLIN( 251)								 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 251)								{
HXDLIN( 251)									b2->width = width;
HXDLIN( 251)									b2->height = height;
HXDLIN( 251)									b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 251)									b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 251)									{
HXDLIN( 251)										int len1 = b2->length;
HXDLIN( 251)										 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 251)										if (::hx::IsNull( d->head )) {
HXDLIN( 251)											int _g10 = 0;
HXDLIN( 251)											int _g11 = len1;
HXDLIN( 251)											while((_g10 < _g11)){
HXDLIN( 251)												_g10 = (_g10 + 1);
HXDLIN( 251)												int i3 = (_g10 - 1);
HXDLIN( 251)												d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            											}
            										}
            										else {
HXDLIN( 251)											int _g12 = 0;
HXDLIN( 251)											int _g13 = len1;
HXDLIN( 251)											while((_g12 < _g13)){
HXDLIN( 251)												_g12 = (_g12 + 1);
HXDLIN( 251)												int i4 = (_g12 - 1);
HXDLIN( 251)												{
HXDLIN( 251)													 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 251)													 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 251)													{
HXDLIN( 251)														int _g14 = 0;
HXDLIN( 251)														int _g15 = i4;
HXDLIN( 251)														while((_g14 < _g15)){
HXDLIN( 251)															_g14 = (_g14 + 1);
HXDLIN( 251)															int i5 = (_g14 - 1);
HXLINE( 345)															prev = l;
HXLINE( 346)															l = l->next;
            														}
            													}
HXLINE( 251)													if (::hx::IsNull( prev )) {
HXDLIN( 251)														b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 251)														l = null();
            													}
            													else {
HXDLIN( 251)														prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 251)														l = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage1 = b2;
            							}
            							break;
            						}
HXDLIN( 251)						this2->image = undoImage1;
HXDLIN( 251)						this2->width = width;
HXDLIN( 251)						this2->height = height;
HXDLIN( 251)						this2->imageType = ( (int)(imageType) );
HXDLIN( 251)						undoImage = this2;
HXDLIN( 251)						{
HXDLIN( 251)							int rectLeft = xIter3->start;
HXDLIN( 251)							int rectTop = yIter3->start;
HXDLIN( 251)							int rectRight = xIter3->max;
HXDLIN( 251)							bool forceClear = false;
HXDLIN( 251)							{
HXDLIN( 251)								int _g16 = rectTop;
HXDLIN( 251)								int _g17 = yIter3->max;
HXDLIN( 251)								while((_g16 < _g17)){
HXDLIN( 251)									_g16 = (_g16 + 1);
HXDLIN( 251)									int dy1 = (_g16 - 1);
HXDLIN( 251)									{
HXDLIN( 251)										int _g18 = rectLeft;
HXDLIN( 251)										int _g19 = rectRight;
HXDLIN( 251)										while((_g18 < _g19)){
HXDLIN( 251)											_g18 = (_g18 + 1);
HXDLIN( 251)											int dx1 = (_g18 - 1);
HXDLIN( 251)											::Dynamic this4 = this1->image;
HXDLIN( 251)											int index;
HXDLIN( 251)											if (this1->useVirtualPos) {
HXDLIN( 251)												index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            											}
            											else {
HXDLIN( 251)												index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            											}
HXDLIN( 251)											int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 251)											int col;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												col = c;
            											}
HXDLIN( 251)											bool hitQuad1;
HXDLIN( 251)											if (this1->useMask) {
HXDLIN( 251)												hitQuad1 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXDLIN( 251)												hitQuad1 = false;
            											}
HXDLIN( 251)											if (hitQuad1) {
HXDLIN( 251)												 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 251)												::Dynamic this6 = this5->image;
HXDLIN( 251)												int index1;
HXDLIN( 251)												if (this5->useVirtualPos) {
HXDLIN( 251)													index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            												}
            												else {
HXDLIN( 251)													index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            												}
HXDLIN( 251)												int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 251)												int v1;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													v1 = c1;
            												}
HXDLIN( 251)												int maskPixel = v1;
HXDLIN( 251)												int this7 = col;
HXDLIN( 251)												if ((maskPixel == 0)) {
HXDLIN( 251)													col = this7;
            												}
            												else {
HXDLIN( 251)													Float m0;
HXDLIN( 251)													int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 251)													if ((this8 == 0)) {
HXDLIN( 251)														m0 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m1;
HXDLIN( 251)													int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 251)													if ((this9 == 0)) {
HXDLIN( 251)														m1 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m2;
HXDLIN( 251)													int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 251)													if ((this10 == 0)) {
HXDLIN( 251)														m2 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m3;
HXDLIN( 251)													int this11 = (maskPixel & 255);
HXDLIN( 251)													if ((this11 == 0)) {
HXDLIN( 251)														m3 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 251)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 251)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 251)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 251)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 251)											if ((col != 0)) {
HXDLIN( 251)												int x1 = (dx1 - rectLeft);
HXDLIN( 251)												int y1 = (dy1 - rectTop);
HXDLIN( 251)												int c2 = col;
HXDLIN( 251)												bool hitQuad2;
HXDLIN( 251)												if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 251)													hitQuad2 = undoImage->transparent;
            												}
            												else {
HXDLIN( 251)													hitQuad2 = false;
            												}
HXDLIN( 251)												if (hitQuad2) {
HXDLIN( 251)													int location;
HXDLIN( 251)													if (undoImage->useVirtualPos) {
HXDLIN( 251)														location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            													}
            													else {
HXDLIN( 251)														location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            													}
HXDLIN( 251)													int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 251)													int this13;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														this13 = this12;
            													}
HXDLIN( 251)													Float a11;
HXDLIN( 251)													int this14 = ((this13 >> 24) & 255);
HXDLIN( 251)													if ((this14 == 0)) {
HXDLIN( 251)														a11 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float r1;
HXDLIN( 251)													int this15 = ((this13 >> 16) & 255);
HXDLIN( 251)													if ((this15 == 0)) {
HXDLIN( 251)														r1 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float g1;
HXDLIN( 251)													int this16 = ((this13 >> 8) & 255);
HXDLIN( 251)													if ((this16 == 0)) {
HXDLIN( 251)														g1 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float b11;
HXDLIN( 251)													int this17 = (this13 & 255);
HXDLIN( 251)													if ((this17 == 0)) {
HXDLIN( 251)														b11 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float a2;
HXDLIN( 251)													int this18 = ((col >> 24) & 255);
HXDLIN( 251)													if ((this18 == 0)) {
HXDLIN( 251)														a2 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float r2;
HXDLIN( 251)													int this19 = ((col >> 16) & 255);
HXDLIN( 251)													if ((this19 == 0)) {
HXDLIN( 251)														r2 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float g2;
HXDLIN( 251)													int this20 = ((col >> 8) & 255);
HXDLIN( 251)													if ((this20 == 0)) {
HXDLIN( 251)														g2 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float b21;
HXDLIN( 251)													int this21 = (col & 255);
HXDLIN( 251)													if ((this21 == 0)) {
HXDLIN( 251)														b21 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 251)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 251)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 251)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 251)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 251)													int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 251)													{
HXDLIN( 251)														int hitQuad3;
HXDLIN( 251)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)															hitQuad3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXDLIN( 251)															hitQuad3 = blended;
            														}
HXDLIN( 251)														::iterMagic::Iimg_obj::set(undoImage->image,location,hitQuad3);
            													}
            												}
            												else {
HXDLIN( 251)													::Dynamic this22 = undoImage->image;
HXDLIN( 251)													int index2;
HXDLIN( 251)													if (undoImage->useVirtualPos) {
HXDLIN( 251)														index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            													}
            													else {
HXDLIN( 251)														index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            													}
HXDLIN( 251)													int hitQuad4;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad4 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad4 = c2;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this22,index2,hitQuad4);
            												}
            											}
            											else {
HXDLIN( 251)												if (forceClear) {
HXDLIN( 251)													::Dynamic this23 = undoImage->image;
HXDLIN( 251)													int x2 = (dx1 - rectLeft);
HXDLIN( 251)													int y2 = (dy1 - rectTop);
HXDLIN( 251)													int index3;
HXDLIN( 251)													if (undoImage->useVirtualPos) {
HXDLIN( 251)														index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            													}
            													else {
HXDLIN( 251)														index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this23,index3,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					{
HXDLIN( 251)						int _g_min = xIter3->start;
HXDLIN( 251)						int _g_max = xIter3->max;
HXDLIN( 251)						while((_g_min < _g_max)){
HXDLIN( 251)							_g_min = (_g_min + 1);
HXDLIN( 251)							int px1 = (_g_min - 1);
HXDLIN( 251)							Float pcx = (( (Float)(px1) ) - dx);
HXDLIN( 251)							{
HXDLIN( 251)								int _g_min1 = yIter3->start;
HXDLIN( 251)								int _g_max1 = yIter3->max;
HXDLIN( 251)								while((_g_min1 < _g_max1)){
HXDLIN( 251)									_g_min1 = (_g_min1 + 1);
HXDLIN( 251)									int py1 = (_g_min1 - 1);
HXDLIN( 251)									Float pcy = (( (Float)(py1) ) - dy);
HXDLIN( 251)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 251)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 251)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 251)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 251)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 251)									bool hitQuad5;
HXDLIN( 251)									bool hitQuad6;
HXDLIN( 251)									if ((ratioA >= 0)) {
HXDLIN( 251)										hitQuad6 = (ratioB >= 0);
            									}
            									else {
HXDLIN( 251)										hitQuad6 = false;
            									}
HXDLIN( 251)									if (hitQuad6) {
HXDLIN( 251)										hitQuad5 = (ratioC >= 0);
            									}
            									else {
HXDLIN( 251)										hitQuad5 = false;
            									}
HXDLIN( 251)									if (hitQuad5) {
HXDLIN( 251)										int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 251)										if ((i6 > 255)) {
HXLINE(  24)											i6 = 255;
            										}
HXLINE( 251)										if ((i6 < 0)) {
HXLINE(  25)											i6 = 0;
            										}
HXLINE( 251)										int a5 = i6;
HXDLIN( 251)										int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 251)										if ((i7 > 255)) {
HXLINE(  24)											i7 = 255;
            										}
HXLINE( 251)										if ((i7 < 0)) {
HXLINE(  25)											i7 = 0;
            										}
HXLINE( 251)										int r3 = i7;
HXDLIN( 251)										int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 251)										if ((i8 > 255)) {
HXLINE(  24)											i8 = 255;
            										}
HXLINE( 251)										if ((i8 < 0)) {
HXLINE(  25)											i8 = 0;
            										}
HXLINE( 251)										int g3 = i8;
HXDLIN( 251)										int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 251)										if ((i9 > 255)) {
HXLINE(  24)											i9 = 255;
            										}
HXLINE( 251)										if ((i9 < 0)) {
HXLINE(  25)											i9 = 0;
            										}
HXLINE( 251)										int b4 = i9;
HXDLIN( 251)										{
HXDLIN( 251)											int location1;
HXDLIN( 251)											if (this1->useVirtualPos) {
HXDLIN( 251)												location1 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this1->virtualY) * ( (Float)(this1->width) )) + px1) - this1->virtualX));
            											}
            											else {
HXDLIN( 251)												location1 = ::Std_obj::_hx_int(( (Float)(((py1 * this1->width) + px1)) ));
            											}
HXDLIN( 251)											bool hitQuad7;
HXDLIN( 251)											if (this1->transparent) {
HXDLIN( 251)												hitQuad7 = (a5 < 254);
            											}
            											else {
HXDLIN( 251)												hitQuad7 = false;
            											}
HXDLIN( 251)											if (hitQuad7) {
HXDLIN( 251)												int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 251)												int old;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													old = this24;
            												}
HXDLIN( 251)												int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 251)												Float a12;
HXDLIN( 251)												int this25 = ((old >> 24) & 255);
HXDLIN( 251)												if ((this25 == 0)) {
HXDLIN( 251)													a12 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a12 = (( (Float)(this25) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r11;
HXDLIN( 251)												int this26 = ((old >> 16) & 255);
HXDLIN( 251)												if ((this26 == 0)) {
HXDLIN( 251)													r11 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g11;
HXDLIN( 251)												int this27 = ((old >> 8) & 255);
HXDLIN( 251)												if ((this27 == 0)) {
HXDLIN( 251)													g11 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b12;
HXDLIN( 251)												int this28 = (old & 255);
HXDLIN( 251)												if ((this28 == 0)) {
HXDLIN( 251)													b12 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a21;
HXDLIN( 251)												int this29 = ((rhs >> 24) & 255);
HXDLIN( 251)												if ((this29 == 0)) {
HXDLIN( 251)													a21 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r21;
HXDLIN( 251)												int this30 = ((rhs >> 16) & 255);
HXDLIN( 251)												if ((this30 == 0)) {
HXDLIN( 251)													r21 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g21;
HXDLIN( 251)												int this31 = ((rhs >> 8) & 255);
HXDLIN( 251)												if ((this31 == 0)) {
HXDLIN( 251)													g21 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b22;
HXDLIN( 251)												int this32 = (rhs & 255);
HXDLIN( 251)												if ((this32 == 0)) {
HXDLIN( 251)													b22 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 251)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 251)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 251)												int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 251)												int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 251)												int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 251)												{
HXDLIN( 251)													int hitQuad8;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad8 = blended1;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this1->image,location1,hitQuad8);
            												}
            											}
            											else {
HXDLIN( 251)												int value;
HXDLIN( 251)												if (this1->isLittle) {
HXDLIN( 251)													value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            												}
            												else {
HXDLIN( 251)													value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this1->image,location1,value);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 251)				{
HXDLIN( 251)					bool hasHit1 = false;
HXDLIN( 251)					bool hasUndo1 = false;
HXDLIN( 251)					int aA1 = ((color2 >> 24) & 255);
HXDLIN( 251)					int rA1 = ((color2 >> 16) & 255);
HXDLIN( 251)					int gA1 = ((color2 >> 8) & 255);
HXDLIN( 251)					int bA1 = (color2 & 255);
HXDLIN( 251)					int aB1 = ((color1 >> 24) & 255);
HXDLIN( 251)					int rB1 = ((color1 >> 16) & 255);
HXDLIN( 251)					int gB1 = ((color1 >> 8) & 255);
HXDLIN( 251)					int bB1 = (color1 & 255);
HXDLIN( 251)					int aC1 = ((color2 >> 24) & 255);
HXDLIN( 251)					int rC1 = ((color2 >> 16) & 255);
HXDLIN( 251)					int gC1 = ((color2 >> 8) & 255);
HXDLIN( 251)					int bC1 = (color2 & 255);
HXDLIN( 251)					Float bcx1 = (cx - dx);
HXDLIN( 251)					Float bcy1 = (cy - dy);
HXDLIN( 251)					Float acx1 = (bx - dx);
HXDLIN( 251)					Float acy1 = (by - dy);
HXDLIN( 251)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 251)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 251)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 251)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 251)					 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 251)					if ((bx > cx)) {
HXDLIN( 251)						if ((bx > dx)) {
HXDLIN( 251)							int min4;
HXDLIN( 251)							if ((cx > dx)) {
HXDLIN( 251)								min4 = ::Math_obj::floor(dx);
            							}
            							else {
HXDLIN( 251)								min4 = ::Math_obj::floor(cx);
            							}
HXDLIN( 251)							int ii_min8 = min4;
HXDLIN( 251)							int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 251)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            						}
            						else {
HXDLIN( 251)							int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 251)							int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 251)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            						}
            					}
            					else {
HXDLIN( 251)						if ((cx > dx)) {
HXDLIN( 251)							int min5;
HXDLIN( 251)							if ((bx > dx)) {
HXDLIN( 251)								min5 = ::Math_obj::floor(dx);
            							}
            							else {
HXDLIN( 251)								min5 = ::Math_obj::ceil(bx);
            							}
HXDLIN( 251)							int ii_min10 = min5;
HXDLIN( 251)							int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 251)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXDLIN( 251)							int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 251)							int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 251)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
HXDLIN( 251)					 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 251)					if ((by > cy)) {
HXDLIN( 251)						if ((by > dy)) {
HXDLIN( 251)							int min6;
HXDLIN( 251)							if ((cy > dy)) {
HXDLIN( 251)								min6 = ::Math_obj::floor(dy);
            							}
            							else {
HXDLIN( 251)								min6 = ::Math_obj::floor(cy);
            							}
HXDLIN( 251)							int ii_min12 = min6;
HXDLIN( 251)							int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 251)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXDLIN( 251)							int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 251)							int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 251)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
            					else {
HXDLIN( 251)						if ((cy > dy)) {
HXDLIN( 251)							int min7;
HXDLIN( 251)							if ((by > dy)) {
HXDLIN( 251)								min7 = ::Math_obj::floor(dy);
            							}
            							else {
HXDLIN( 251)								min7 = ::Math_obj::ceil(by);
            							}
HXDLIN( 251)							int ii_min14 = min7;
HXDLIN( 251)							int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 251)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXDLIN( 251)							int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 251)							int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 251)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
HXDLIN( 251)					 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 251)					if (hasUndo1) {
HXDLIN( 251)						int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 251)						int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 251)						 ::Dynamic imageType1 = null();
HXDLIN( 251)						 ::pi_xy::ImageStruct this33 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 251)						if (::hx::IsNull( imageType1 )) {
HXLINE(  54)							imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 251)						::Dynamic undoImage4;
HXDLIN( 251)						switch((int)(( (int)(imageType1) ))){
            							case (int)0: {
HXDLIN( 251)								 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 251)								{
HXDLIN( 251)									b6->width = width1;
HXDLIN( 251)									b6->height = height1;
HXDLIN( 251)									b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 251)									b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 251)									{
HXDLIN( 251)										int len2 = b6->length;
HXDLIN( 251)										int w1 = 0;
HXDLIN( 251)										{
HXDLIN( 251)											int _g20 = 0;
HXDLIN( 251)											int _g21 = b6->height;
HXDLIN( 251)											while((_g20 < _g21)){
HXDLIN( 251)												_g20 = (_g20 + 1);
HXDLIN( 251)												int y3 = (_g20 - 1);
HXDLIN( 251)												{
HXDLIN( 251)													int _g22 = 0;
HXDLIN( 251)													int _g23 = b6->width;
HXDLIN( 251)													while((_g22 < _g23)){
HXDLIN( 251)														_g22 = (_g22 + 1);
HXDLIN( 251)														int x3 = (_g22 - 1);
HXDLIN( 251)														{
HXDLIN( 251)															w1 = (w1 + 1);
HXDLIN( 251)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w1 = (w1 + 1);
HXDLIN( 251)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w1 = (w1 + 1);
HXDLIN( 251)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w1 = (w1 + 1);
HXDLIN( 251)															b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage4 = b6;
            							}
            							break;
            							case (int)1: {
HXDLIN( 251)								 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 251)								{
HXDLIN( 251)									a7->width = width1;
HXDLIN( 251)									a7->height = height1;
HXDLIN( 251)									a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 251)									a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 251)									{
HXDLIN( 251)										int _g24 = 0;
HXDLIN( 251)										int _g25 = a7->length;
HXDLIN( 251)										while((_g24 < _g25)){
HXDLIN( 251)											_g24 = (_g24 + 1);
HXDLIN( 251)											int i10 = (_g24 - 1);
HXDLIN( 251)											a7->data[i10] = 0;
            										}
            									}
            								}
HXDLIN( 251)								undoImage4 = a7;
            							}
            							break;
            							case (int)2: {
HXDLIN( 251)								 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 251)								{
HXDLIN( 251)									b7->width = width1;
HXDLIN( 251)									b7->height = height1;
HXDLIN( 251)									b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 251)									int size1 = (b7->length * 4);
HXDLIN( 251)									b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 251)									{
HXDLIN( 251)										int _g26 = 0;
HXDLIN( 251)										int _g27 = b7->length;
HXDLIN( 251)										while((_g26 < _g27)){
HXDLIN( 251)											_g26 = (_g26 + 1);
HXDLIN( 251)											int i11 = (_g26 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												 ::haxe::io::ArrayBufferViewImpl this34 = b7->data;
HXDLIN( 251)												bool undoImage5;
HXDLIN( 251)												if ((i11 >= 0)) {
HXDLIN( 251)													undoImage5 = (i11 < (this34->byteLength >> 2));
            												}
            												else {
HXDLIN( 251)													undoImage5 = false;
            												}
HXDLIN( 251)												if (undoImage5) {
HXDLIN( 251)													 ::haxe::io::Bytes _this1 = this34->bytes;
HXDLIN( 251)													int pos1 = ((i11 << 2) + this34->byteOffset);
HXDLIN( 251)													_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 251)													_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 251)													_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 251)													_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage4 = b7;
            							}
            							break;
            							case (int)3: {
HXDLIN( 251)								 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 251)								{
HXDLIN( 251)									v2->width = width1;
HXDLIN( 251)									v2->height = height1;
HXDLIN( 251)									v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 251)									v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 251)									{
HXDLIN( 251)										int _g28 = 0;
HXDLIN( 251)										int _g29 = v2->length;
HXDLIN( 251)										while((_g28 < _g29)){
HXDLIN( 251)											_g28 = (_g28 + 1);
HXDLIN( 251)											int i12 = (_g28 - 1);
HXDLIN( 251)											v2->data->__unsafe_set(i12,0);
            										}
            									}
            								}
HXDLIN( 251)								undoImage4 = v2;
            							}
            							break;
            							case (int)4: {
HXDLIN( 251)								 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 251)								{
HXDLIN( 251)									b8->width = width1;
HXDLIN( 251)									b8->height = height1;
HXDLIN( 251)									b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 251)									b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 251)									{
HXDLIN( 251)										int len3 = b8->length;
HXDLIN( 251)										 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 251)										if (::hx::IsNull( d1->head )) {
HXDLIN( 251)											int _g30 = 0;
HXDLIN( 251)											int _g31 = len3;
HXDLIN( 251)											while((_g30 < _g31)){
HXDLIN( 251)												_g30 = (_g30 + 1);
HXDLIN( 251)												int i13 = (_g30 - 1);
HXDLIN( 251)												d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            											}
            										}
            										else {
HXDLIN( 251)											int _g32 = 0;
HXDLIN( 251)											int _g33 = len3;
HXDLIN( 251)											while((_g32 < _g33)){
HXDLIN( 251)												_g32 = (_g32 + 1);
HXDLIN( 251)												int i14 = (_g32 - 1);
HXDLIN( 251)												{
HXDLIN( 251)													 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 251)													 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 251)													{
HXDLIN( 251)														int _g34 = 0;
HXDLIN( 251)														int _g35 = i14;
HXDLIN( 251)														while((_g34 < _g35)){
HXDLIN( 251)															_g34 = (_g34 + 1);
HXDLIN( 251)															int i15 = (_g34 - 1);
HXLINE( 345)															prev1 = l1;
HXLINE( 346)															l1 = l1->next;
            														}
            													}
HXLINE( 251)													if (::hx::IsNull( prev1 )) {
HXDLIN( 251)														b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 251)														l1 = null();
            													}
            													else {
HXDLIN( 251)														prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 251)														l1 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage4 = b8;
            							}
            							break;
            						}
HXDLIN( 251)						this33->image = undoImage4;
HXDLIN( 251)						this33->width = width1;
HXDLIN( 251)						this33->height = height1;
HXDLIN( 251)						this33->imageType = ( (int)(imageType1) );
HXDLIN( 251)						undoImage3 = this33;
HXDLIN( 251)						{
HXDLIN( 251)							int rectLeft1 = xIter31->start;
HXDLIN( 251)							int rectTop1 = yIter31->start;
HXDLIN( 251)							int rectRight1 = xIter31->max;
HXDLIN( 251)							bool forceClear1 = false;
HXDLIN( 251)							{
HXDLIN( 251)								int _g36 = rectTop1;
HXDLIN( 251)								int _g37 = yIter31->max;
HXDLIN( 251)								while((_g36 < _g37)){
HXDLIN( 251)									_g36 = (_g36 + 1);
HXDLIN( 251)									int dy2 = (_g36 - 1);
HXDLIN( 251)									{
HXDLIN( 251)										int _g38 = rectLeft1;
HXDLIN( 251)										int _g39 = rectRight1;
HXDLIN( 251)										while((_g38 < _g39)){
HXDLIN( 251)											_g38 = (_g38 + 1);
HXDLIN( 251)											int dx2 = (_g38 - 1);
HXDLIN( 251)											::Dynamic this35 = this1->image;
HXDLIN( 251)											int index4;
HXDLIN( 251)											if (this1->useVirtualPos) {
HXDLIN( 251)												index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            											}
            											else {
HXDLIN( 251)												index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            											}
HXDLIN( 251)											int c3 = ::iterMagic::Iimg_obj::get(this35,index4);
HXDLIN( 251)											int col1;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												col1 = c3;
            											}
HXDLIN( 251)											bool hitQuad9;
HXDLIN( 251)											if (this1->useMask) {
HXDLIN( 251)												hitQuad9 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXDLIN( 251)												hitQuad9 = false;
            											}
HXDLIN( 251)											if (hitQuad9) {
HXDLIN( 251)												 ::pi_xy::ImageStruct this36 = this1->mask;
HXDLIN( 251)												::Dynamic this37 = this36->image;
HXDLIN( 251)												int index5;
HXDLIN( 251)												if (this36->useVirtualPos) {
HXDLIN( 251)													index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx2) - this36->virtualX));
            												}
            												else {
HXDLIN( 251)													index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this36->width) + dx2)) ));
            												}
HXDLIN( 251)												int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 251)												int v3;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													v3 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													v3 = c4;
            												}
HXDLIN( 251)												int maskPixel1 = v3;
HXDLIN( 251)												int this38 = col1;
HXDLIN( 251)												if ((maskPixel1 == 0)) {
HXDLIN( 251)													col1 = this38;
            												}
            												else {
HXDLIN( 251)													Float m01;
HXDLIN( 251)													int this39 = ((maskPixel1 >> 24) & 255);
HXDLIN( 251)													if ((this39 == 0)) {
HXDLIN( 251)														m01 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m01 = (( (Float)(this39) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m11;
HXDLIN( 251)													int this40 = ((maskPixel1 >> 16) & 255);
HXDLIN( 251)													if ((this40 == 0)) {
HXDLIN( 251)														m11 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m11 = (( (Float)(this40) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m21;
HXDLIN( 251)													int this41 = ((maskPixel1 >> 8) & 255);
HXDLIN( 251)													if ((this41 == 0)) {
HXDLIN( 251)														m21 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m21 = (( (Float)(this41) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m31;
HXDLIN( 251)													int this42 = (maskPixel1 & 255);
HXDLIN( 251)													if ((this42 == 0)) {
HXDLIN( 251)														m31 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m31 = (( (Float)(this42) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this38 >> 24) & 255)) )));
HXDLIN( 251)													int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this38 >> 16) & 255)) )));
HXDLIN( 251)													int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this38 >> 8) & 255)) )));
HXDLIN( 251)													int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this38 & 255)) )));
HXDLIN( 251)													col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 251)											if ((col1 != 0)) {
HXDLIN( 251)												int x4 = (dx2 - rectLeft1);
HXDLIN( 251)												int y4 = (dy2 - rectTop1);
HXDLIN( 251)												int c5 = col1;
HXDLIN( 251)												bool hitQuad10;
HXDLIN( 251)												if ((((c5 >> 24) & 255) < 254)) {
HXDLIN( 251)													hitQuad10 = undoImage3->transparent;
            												}
            												else {
HXDLIN( 251)													hitQuad10 = false;
            												}
HXDLIN( 251)												if (hitQuad10) {
HXDLIN( 251)													int location2;
HXDLIN( 251)													if (undoImage3->useVirtualPos) {
HXDLIN( 251)														location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 251)														location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            													}
HXDLIN( 251)													int this43 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 251)													int this44;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														this44 = ((((((this43 >> 24) & 255) << 24) | ((this43 & 255) << 16)) | (((this43 >> 8) & 255) << 8)) | ((this43 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														this44 = this43;
            													}
HXDLIN( 251)													Float a13;
HXDLIN( 251)													int this45 = ((this44 >> 24) & 255);
HXDLIN( 251)													if ((this45 == 0)) {
HXDLIN( 251)														a13 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														a13 = (( (Float)(this45) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float r12;
HXDLIN( 251)													int this46 = ((this44 >> 16) & 255);
HXDLIN( 251)													if ((this46 == 0)) {
HXDLIN( 251)														r12 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														r12 = (( (Float)(this46) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float g12;
HXDLIN( 251)													int this47 = ((this44 >> 8) & 255);
HXDLIN( 251)													if ((this47 == 0)) {
HXDLIN( 251)														g12 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														g12 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float b13;
HXDLIN( 251)													int this48 = (this44 & 255);
HXDLIN( 251)													if ((this48 == 0)) {
HXDLIN( 251)														b13 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														b13 = (( (Float)(this48) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float a22;
HXDLIN( 251)													int this49 = ((col1 >> 24) & 255);
HXDLIN( 251)													if ((this49 == 0)) {
HXDLIN( 251)														a22 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														a22 = (( (Float)(this49) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float r22;
HXDLIN( 251)													int this50 = ((col1 >> 16) & 255);
HXDLIN( 251)													if ((this50 == 0)) {
HXDLIN( 251)														r22 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														r22 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float g22;
HXDLIN( 251)													int this51 = ((col1 >> 8) & 255);
HXDLIN( 251)													if ((this51 == 0)) {
HXDLIN( 251)														g22 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														g22 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float b23;
HXDLIN( 251)													int this52 = (col1 & 255);
HXDLIN( 251)													if ((this52 == 0)) {
HXDLIN( 251)														b23 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														b23 = (( (Float)(this52) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 251)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 251)													int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 251)													int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 251)													int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 251)													int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 251)													{
HXDLIN( 251)														int hitQuad11;
HXDLIN( 251)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)															hitQuad11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXDLIN( 251)															hitQuad11 = blended2;
            														}
HXDLIN( 251)														::iterMagic::Iimg_obj::set(undoImage3->image,location2,hitQuad11);
            													}
            												}
            												else {
HXDLIN( 251)													::Dynamic this53 = undoImage3->image;
HXDLIN( 251)													int index6;
HXDLIN( 251)													if (undoImage3->useVirtualPos) {
HXDLIN( 251)														index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 251)														index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            													}
HXDLIN( 251)													int hitQuad12;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad12 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad12 = c5;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this53,index6,hitQuad12);
            												}
            											}
            											else {
HXDLIN( 251)												if (forceClear1) {
HXDLIN( 251)													::Dynamic this54 = undoImage3->image;
HXDLIN( 251)													int x5 = (dx2 - rectLeft1);
HXDLIN( 251)													int y5 = (dy2 - rectTop1);
HXDLIN( 251)													int index7;
HXDLIN( 251)													if (undoImage3->useVirtualPos) {
HXDLIN( 251)														index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 251)														index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this54,index7,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					{
HXDLIN( 251)						int _g_min2 = xIter31->start;
HXDLIN( 251)						int _g_max2 = xIter31->max;
HXDLIN( 251)						while((_g_min2 < _g_max2)){
HXDLIN( 251)							_g_min2 = (_g_min2 + 1);
HXDLIN( 251)							int px2 = (_g_min2 - 1);
HXDLIN( 251)							Float pcx1 = (( (Float)(px2) ) - dx);
HXDLIN( 251)							{
HXDLIN( 251)								int _g_min3 = yIter31->start;
HXDLIN( 251)								int _g_max3 = yIter31->max;
HXDLIN( 251)								while((_g_min3 < _g_max3)){
HXDLIN( 251)									_g_min3 = (_g_min3 + 1);
HXDLIN( 251)									int py2 = (_g_min3 - 1);
HXDLIN( 251)									Float pcy1 = (( (Float)(py2) ) - dy);
HXDLIN( 251)									Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 251)									Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 251)									Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 251)									Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 251)									Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 251)									bool hitQuad13;
HXDLIN( 251)									bool hitQuad14;
HXDLIN( 251)									if ((ratioA1 >= 0)) {
HXDLIN( 251)										hitQuad14 = (ratioB1 >= 0);
            									}
            									else {
HXDLIN( 251)										hitQuad14 = false;
            									}
HXDLIN( 251)									if (hitQuad14) {
HXDLIN( 251)										hitQuad13 = (ratioC1 >= 0);
            									}
            									else {
HXDLIN( 251)										hitQuad13 = false;
            									}
HXDLIN( 251)									if (hitQuad13) {
HXDLIN( 251)										int i16 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 251)										if ((i16 > 255)) {
HXLINE(  24)											i16 = 255;
            										}
HXLINE( 251)										if ((i16 < 0)) {
HXLINE(  25)											i16 = 0;
            										}
HXLINE( 251)										int a9 = i16;
HXDLIN( 251)										int i17 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 251)										if ((i17 > 255)) {
HXLINE(  24)											i17 = 255;
            										}
HXLINE( 251)										if ((i17 < 0)) {
HXLINE(  25)											i17 = 0;
            										}
HXLINE( 251)										int r6 = i17;
HXDLIN( 251)										int i18 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 251)										if ((i18 > 255)) {
HXLINE(  24)											i18 = 255;
            										}
HXLINE( 251)										if ((i18 < 0)) {
HXLINE(  25)											i18 = 0;
            										}
HXLINE( 251)										int g6 = i18;
HXDLIN( 251)										int i19 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 251)										if ((i19 > 255)) {
HXLINE(  24)											i19 = 255;
            										}
HXLINE( 251)										if ((i19 < 0)) {
HXLINE(  25)											i19 = 0;
            										}
HXLINE( 251)										int b10 = i19;
HXDLIN( 251)										{
HXDLIN( 251)											int location3;
HXDLIN( 251)											if (this1->useVirtualPos) {
HXDLIN( 251)												location3 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this1->virtualY) * ( (Float)(this1->width) )) + px2) - this1->virtualX));
            											}
            											else {
HXDLIN( 251)												location3 = ::Std_obj::_hx_int(( (Float)(((py2 * this1->width) + px2)) ));
            											}
HXDLIN( 251)											bool hitQuad15;
HXDLIN( 251)											if (this1->transparent) {
HXDLIN( 251)												hitQuad15 = (a9 < 254);
            											}
            											else {
HXDLIN( 251)												hitQuad15 = false;
            											}
HXDLIN( 251)											if (hitQuad15) {
HXDLIN( 251)												int this55 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 251)												int old1;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													old1 = ((((((this55 >> 24) & 255) << 24) | ((this55 & 255) << 16)) | (((this55 >> 8) & 255) << 8)) | ((this55 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													old1 = this55;
            												}
HXDLIN( 251)												int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 251)												Float a14;
HXDLIN( 251)												int this56 = ((old1 >> 24) & 255);
HXDLIN( 251)												if ((this56 == 0)) {
HXDLIN( 251)													a14 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a14 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r13;
HXDLIN( 251)												int this57 = ((old1 >> 16) & 255);
HXDLIN( 251)												if ((this57 == 0)) {
HXDLIN( 251)													r13 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g13;
HXDLIN( 251)												int this58 = ((old1 >> 8) & 255);
HXDLIN( 251)												if ((this58 == 0)) {
HXDLIN( 251)													g13 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b14;
HXDLIN( 251)												int this59 = (old1 & 255);
HXDLIN( 251)												if ((this59 == 0)) {
HXDLIN( 251)													b14 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a23;
HXDLIN( 251)												int this60 = ((rhs1 >> 24) & 255);
HXDLIN( 251)												if ((this60 == 0)) {
HXDLIN( 251)													a23 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r23;
HXDLIN( 251)												int this61 = ((rhs1 >> 16) & 255);
HXDLIN( 251)												if ((this61 == 0)) {
HXDLIN( 251)													r23 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g23;
HXDLIN( 251)												int this62 = ((rhs1 >> 8) & 255);
HXDLIN( 251)												if ((this62 == 0)) {
HXDLIN( 251)													g23 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b24;
HXDLIN( 251)												int this63 = (rhs1 & 255);
HXDLIN( 251)												if ((this63 == 0)) {
HXDLIN( 251)													b24 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 251)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 251)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 251)												int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 251)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 251)												int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 251)												{
HXDLIN( 251)													int hitQuad16;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad16 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad16 = blended3;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this1->image,location3,hitQuad16);
            												}
            											}
            											else {
HXDLIN( 251)												int value1;
HXDLIN( 251)												if (this1->isLittle) {
HXDLIN( 251)													value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            												}
            												else {
HXDLIN( 251)													value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this1->image,location3,value1);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					if ((hasHit1 == false)) {
HXDLIN( 251)						 ::pi_xy::algo::HitTri v4 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 251)						if (hasUndo1) {
HXDLIN( 251)							v4->undoImage = undoImage3;
HXDLIN( 251)							v4->undoX = xIter31->start;
HXDLIN( 251)							v4->undoY = yIter31->start;
            						}
            					}
            				}
HXDLIN( 251)				 ::pi_xy::algo::HitQuad v5 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 251)				hitQuad = v5;
            			}
            			else {
HXDLIN( 251)				Float sin2 = ::Math_obj::sin(theta);
HXDLIN( 251)				Float cos2 = ::Math_obj::cos(theta);
HXDLIN( 251)				Float radius11 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN( 251)				Float radius22 = (thick / ( (Float)(2) ));
HXDLIN( 251)				Float dx3 = ((Float)0.1);
HXDLIN( 251)				Float dy3 = radius11;
HXDLIN( 251)				Float cx1 = h2;
HXDLIN( 251)				Float cy1 = radius22;
HXDLIN( 251)				Float bx1 = h2;
HXDLIN( 251)				Float by1 = -(radius22);
HXDLIN( 251)				Float ax1 = ((Float)0.1);
HXDLIN( 251)				Float ay1 = -(radius11);
HXDLIN( 251)				Float temp1 = ((Float)0.);
HXLINE( 525)				temp1 = (px + ((ax1 * cos2) - (ay1 * sin2)));
HXLINE( 526)				ay1 = (py + ((ay1 * cos2) + (ax1 * sin2)));
HXLINE( 527)				ax1 = temp1;
HXLINE( 529)				temp1 = (px + ((bx1 * cos2) - (by1 * sin2)));
HXLINE( 530)				by1 = (py + ((by1 * cos2) + (bx1 * sin2)));
HXLINE( 531)				bx1 = temp1;
HXLINE( 533)				temp1 = (px + ((cx1 * cos2) - (cy1 * sin2)));
HXLINE( 534)				cy1 = (py + ((cy1 * cos2) + (cx1 * sin2)));
HXLINE( 535)				cx1 = temp1;
HXLINE( 537)				temp1 = (px + ((dx3 * cos2) - (dy3 * sin2)));
HXLINE( 538)				dy3 = (py + ((dy3 * cos2) + (dx3 * sin2)));
HXLINE( 539)				dx3 = temp1;
HXLINE( 251)				{
HXDLIN( 251)					bool hasUndo2 = false;
HXDLIN( 251)					int aA2 = ((color1 >> 24) & 255);
HXDLIN( 251)					int rA2 = ((color1 >> 16) & 255);
HXDLIN( 251)					int gA2 = ((color1 >> 8) & 255);
HXDLIN( 251)					int bA2 = (color1 & 255);
HXDLIN( 251)					int aB2 = ((color1 >> 24) & 255);
HXDLIN( 251)					int rB2 = ((color1 >> 16) & 255);
HXDLIN( 251)					int gB2 = ((color1 >> 8) & 255);
HXDLIN( 251)					int bB2 = (color1 & 255);
HXDLIN( 251)					int aC2 = ((color2 >> 24) & 255);
HXDLIN( 251)					int rC2 = ((color2 >> 16) & 255);
HXDLIN( 251)					int gC2 = ((color2 >> 8) & 255);
HXDLIN( 251)					int bC2 = (color2 & 255);
HXDLIN( 251)					Float bcx2 = (bx1 - dx3);
HXDLIN( 251)					Float bcy2 = (by1 - dy3);
HXDLIN( 251)					Float acx2 = (ax1 - dx3);
HXDLIN( 251)					Float acy2 = (ay1 - dy3);
HXDLIN( 251)					Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 251)					Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 251)					Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 251)					Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 251)					 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 251)					if ((ax1 > bx1)) {
HXDLIN( 251)						if ((ax1 > dx3)) {
HXDLIN( 251)							int min8;
HXDLIN( 251)							if ((bx1 > dx3)) {
HXDLIN( 251)								min8 = ::Math_obj::floor(dx3);
            							}
            							else {
HXDLIN( 251)								min8 = ::Math_obj::floor(bx1);
            							}
HXDLIN( 251)							int ii_min16 = min8;
HXDLIN( 251)							int ii_max16 = ::Math_obj::ceil(ax1);
HXDLIN( 251)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            						else {
HXDLIN( 251)							int ii_min17 = ::Math_obj::floor(bx1);
HXDLIN( 251)							int ii_max17 = ::Math_obj::ceil(dx3);
HXDLIN( 251)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            					}
            					else {
HXDLIN( 251)						if ((bx1 > dx3)) {
HXDLIN( 251)							int min9;
HXDLIN( 251)							if ((ax1 > dx3)) {
HXDLIN( 251)								min9 = ::Math_obj::floor(dx3);
            							}
            							else {
HXDLIN( 251)								min9 = ::Math_obj::ceil(ax1);
            							}
HXDLIN( 251)							int ii_min18 = min9;
HXDLIN( 251)							int ii_max18 = ::Math_obj::ceil(bx1);
HXDLIN( 251)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            						}
            						else {
HXDLIN( 251)							int ii_min19 = ::Math_obj::floor(ax1);
HXDLIN( 251)							int ii_max19 = ::Math_obj::ceil(dx3);
HXDLIN( 251)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            						}
            					}
HXDLIN( 251)					 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 251)					if ((ay1 > by1)) {
HXDLIN( 251)						if ((ay1 > dy3)) {
HXDLIN( 251)							int min10;
HXDLIN( 251)							if ((by1 > dy3)) {
HXDLIN( 251)								min10 = ::Math_obj::floor(dy3);
            							}
            							else {
HXDLIN( 251)								min10 = ::Math_obj::floor(by1);
            							}
HXDLIN( 251)							int ii_min20 = min10;
HXDLIN( 251)							int ii_max20 = ::Math_obj::ceil(ay1);
HXDLIN( 251)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            						}
            						else {
HXDLIN( 251)							int ii_min21 = ::Math_obj::floor(by1);
HXDLIN( 251)							int ii_max21 = ::Math_obj::ceil(dy3);
HXDLIN( 251)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            						}
            					}
            					else {
HXDLIN( 251)						if ((by1 > dy3)) {
HXDLIN( 251)							int min11;
HXDLIN( 251)							if ((ay1 > dy3)) {
HXDLIN( 251)								min11 = ::Math_obj::floor(dy3);
            							}
            							else {
HXDLIN( 251)								min11 = ::Math_obj::ceil(ay1);
            							}
HXDLIN( 251)							int ii_min22 = min11;
HXDLIN( 251)							int ii_max22 = ::Math_obj::ceil(by1);
HXDLIN( 251)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            						}
            						else {
HXDLIN( 251)							int ii_min23 = ::Math_obj::floor(ay1);
HXDLIN( 251)							int ii_max23 = ::Math_obj::ceil(dy3);
HXDLIN( 251)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            						}
            					}
HXDLIN( 251)					 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 251)					if (hasUndo2) {
HXDLIN( 251)						int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 251)						int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 251)						 ::Dynamic imageType2 = null();
HXDLIN( 251)						 ::pi_xy::ImageStruct this64 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 251)						if (::hx::IsNull( imageType2 )) {
HXLINE(  54)							imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 251)						::Dynamic undoImage7;
HXDLIN( 251)						switch((int)(( (int)(imageType2) ))){
            							case (int)0: {
HXDLIN( 251)								 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::BytesImg b16 = byt2;
HXDLIN( 251)								{
HXDLIN( 251)									b16->width = width2;
HXDLIN( 251)									b16->height = height2;
HXDLIN( 251)									b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 251)									b16->data = ::haxe::io::Bytes_obj::alloc((b16->length * 4));
HXDLIN( 251)									{
HXDLIN( 251)										int len4 = b16->length;
HXDLIN( 251)										int w2 = 0;
HXDLIN( 251)										{
HXDLIN( 251)											int _g40 = 0;
HXDLIN( 251)											int _g41 = b16->height;
HXDLIN( 251)											while((_g40 < _g41)){
HXDLIN( 251)												_g40 = (_g40 + 1);
HXDLIN( 251)												int y6 = (_g40 - 1);
HXDLIN( 251)												{
HXDLIN( 251)													int _g42 = 0;
HXDLIN( 251)													int _g43 = b16->width;
HXDLIN( 251)													while((_g42 < _g43)){
HXDLIN( 251)														_g42 = (_g42 + 1);
HXDLIN( 251)														int x6 = (_g42 - 1);
HXDLIN( 251)														{
HXDLIN( 251)															w2 = (w2 + 1);
HXDLIN( 251)															b16->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w2 = (w2 + 1);
HXDLIN( 251)															b16->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w2 = (w2 + 1);
HXDLIN( 251)															b16->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w2 = (w2 + 1);
HXDLIN( 251)															b16->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage7 = b16;
            							}
            							break;
            							case (int)1: {
HXDLIN( 251)								 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::ArrIntImg a15 = arrI2;
HXDLIN( 251)								{
HXDLIN( 251)									a15->width = width2;
HXDLIN( 251)									a15->height = height2;
HXDLIN( 251)									a15->data = ::Array_obj< int >::__new(0);
HXDLIN( 251)									a15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 251)									{
HXDLIN( 251)										int _g44 = 0;
HXDLIN( 251)										int _g45 = a15->length;
HXDLIN( 251)										while((_g44 < _g45)){
HXDLIN( 251)											_g44 = (_g44 + 1);
HXDLIN( 251)											int i20 = (_g44 - 1);
HXDLIN( 251)											a15->data[i20] = 0;
            										}
            									}
            								}
HXDLIN( 251)								undoImage7 = a15;
            							}
            							break;
            							case (int)2: {
HXDLIN( 251)								 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::U32ArrImg b17 = u32a2;
HXDLIN( 251)								{
HXDLIN( 251)									b17->width = width2;
HXDLIN( 251)									b17->height = height2;
HXDLIN( 251)									b17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 251)									int size2 = (b17->length * 4);
HXDLIN( 251)									b17->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 251)									{
HXDLIN( 251)										int _g46 = 0;
HXDLIN( 251)										int _g47 = b17->length;
HXDLIN( 251)										while((_g46 < _g47)){
HXDLIN( 251)											_g46 = (_g46 + 1);
HXDLIN( 251)											int i21 = (_g46 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												 ::haxe::io::ArrayBufferViewImpl this65 = b17->data;
HXDLIN( 251)												bool undoImage8;
HXDLIN( 251)												if ((i21 >= 0)) {
HXDLIN( 251)													undoImage8 = (i21 < (this65->byteLength >> 2));
            												}
            												else {
HXDLIN( 251)													undoImage8 = false;
            												}
HXDLIN( 251)												if (undoImage8) {
HXDLIN( 251)													 ::haxe::io::Bytes _this2 = this65->bytes;
HXDLIN( 251)													int pos2 = ((i21 << 2) + this65->byteOffset);
HXDLIN( 251)													_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 251)													_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 251)													_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 251)													_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage7 = b17;
            							}
            							break;
            							case (int)3: {
HXDLIN( 251)								 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN( 251)								{
HXDLIN( 251)									v6->width = width2;
HXDLIN( 251)									v6->height = height2;
HXDLIN( 251)									v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 251)									v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 251)									{
HXDLIN( 251)										int _g48 = 0;
HXDLIN( 251)										int _g49 = v6->length;
HXDLIN( 251)										while((_g48 < _g49)){
HXDLIN( 251)											_g48 = (_g48 + 1);
HXDLIN( 251)											int i22 = (_g48 - 1);
HXDLIN( 251)											v6->data->__unsafe_set(i22,0);
            										}
            									}
            								}
HXDLIN( 251)								undoImage7 = v6;
            							}
            							break;
            							case (int)4: {
HXDLIN( 251)								 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::StackIntImg b18 = sInt2;
HXDLIN( 251)								{
HXDLIN( 251)									b18->width = width2;
HXDLIN( 251)									b18->height = height2;
HXDLIN( 251)									b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 251)									b18->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 251)									{
HXDLIN( 251)										int len5 = b18->length;
HXDLIN( 251)										 ::haxe::ds::GenericStack_Int d2 = b18->data;
HXDLIN( 251)										if (::hx::IsNull( d2->head )) {
HXDLIN( 251)											int _g50 = 0;
HXDLIN( 251)											int _g51 = len5;
HXDLIN( 251)											while((_g50 < _g51)){
HXDLIN( 251)												_g50 = (_g50 + 1);
HXDLIN( 251)												int i23 = (_g50 - 1);
HXDLIN( 251)												d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            											}
            										}
            										else {
HXDLIN( 251)											int _g52 = 0;
HXDLIN( 251)											int _g53 = len5;
HXDLIN( 251)											while((_g52 < _g53)){
HXDLIN( 251)												_g52 = (_g52 + 1);
HXDLIN( 251)												int i24 = (_g52 - 1);
HXDLIN( 251)												{
HXDLIN( 251)													 ::haxe::ds::GenericCell_Int l2 = b18->data->head;
HXDLIN( 251)													 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 251)													{
HXDLIN( 251)														int _g54 = 0;
HXDLIN( 251)														int _g55 = i24;
HXDLIN( 251)														while((_g54 < _g55)){
HXDLIN( 251)															_g54 = (_g54 + 1);
HXDLIN( 251)															int i25 = (_g54 - 1);
HXLINE( 345)															prev2 = l2;
HXLINE( 346)															l2 = l2->next;
            														}
            													}
HXLINE( 251)													if (::hx::IsNull( prev2 )) {
HXDLIN( 251)														b18->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 251)														l2 = null();
            													}
            													else {
HXDLIN( 251)														prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 251)														l2 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage7 = b18;
            							}
            							break;
            						}
HXDLIN( 251)						this64->image = undoImage7;
HXDLIN( 251)						this64->width = width2;
HXDLIN( 251)						this64->height = height2;
HXDLIN( 251)						this64->imageType = ( (int)(imageType2) );
HXDLIN( 251)						undoImage6 = this64;
HXDLIN( 251)						{
HXDLIN( 251)							int rectLeft2 = xIter32->start;
HXDLIN( 251)							int rectTop2 = yIter32->start;
HXDLIN( 251)							int rectRight2 = xIter32->max;
HXDLIN( 251)							bool forceClear2 = false;
HXDLIN( 251)							{
HXDLIN( 251)								int _g56 = rectTop2;
HXDLIN( 251)								int _g57 = yIter32->max;
HXDLIN( 251)								while((_g56 < _g57)){
HXDLIN( 251)									_g56 = (_g56 + 1);
HXDLIN( 251)									int dy4 = (_g56 - 1);
HXDLIN( 251)									{
HXDLIN( 251)										int _g58 = rectLeft2;
HXDLIN( 251)										int _g59 = rectRight2;
HXDLIN( 251)										while((_g58 < _g59)){
HXDLIN( 251)											_g58 = (_g58 + 1);
HXDLIN( 251)											int dx4 = (_g58 - 1);
HXDLIN( 251)											::Dynamic this66 = this1->image;
HXDLIN( 251)											int index8;
HXDLIN( 251)											if (this1->useVirtualPos) {
HXDLIN( 251)												index8 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx4) - this1->virtualX));
            											}
            											else {
HXDLIN( 251)												index8 = ::Std_obj::_hx_int(( (Float)(((dy4 * this1->width) + dx4)) ));
            											}
HXDLIN( 251)											int c6 = ::iterMagic::Iimg_obj::get(this66,index8);
HXDLIN( 251)											int col2;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												col2 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												col2 = c6;
            											}
HXDLIN( 251)											bool hitQuad17;
HXDLIN( 251)											if (this1->useMask) {
HXDLIN( 251)												hitQuad17 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXDLIN( 251)												hitQuad17 = false;
            											}
HXDLIN( 251)											if (hitQuad17) {
HXDLIN( 251)												 ::pi_xy::ImageStruct this67 = this1->mask;
HXDLIN( 251)												::Dynamic this68 = this67->image;
HXDLIN( 251)												int index9;
HXDLIN( 251)												if (this67->useVirtualPos) {
HXDLIN( 251)													index9 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this67->virtualY) * ( (Float)(this67->width) )) + dx4) - this67->virtualX));
            												}
            												else {
HXDLIN( 251)													index9 = ::Std_obj::_hx_int(( (Float)(((dy4 * this67->width) + dx4)) ));
            												}
HXDLIN( 251)												int c7 = ::iterMagic::Iimg_obj::get(this68,index9);
HXDLIN( 251)												int v7;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													v7 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													v7 = c7;
            												}
HXDLIN( 251)												int maskPixel2 = v7;
HXDLIN( 251)												int this69 = col2;
HXDLIN( 251)												if ((maskPixel2 == 0)) {
HXDLIN( 251)													col2 = this69;
            												}
            												else {
HXDLIN( 251)													Float m02;
HXDLIN( 251)													int this70 = ((maskPixel2 >> 24) & 255);
HXDLIN( 251)													if ((this70 == 0)) {
HXDLIN( 251)														m02 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m02 = (( (Float)(this70) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m12;
HXDLIN( 251)													int this71 = ((maskPixel2 >> 16) & 255);
HXDLIN( 251)													if ((this71 == 0)) {
HXDLIN( 251)														m12 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m12 = (( (Float)(this71) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m22;
HXDLIN( 251)													int this72 = ((maskPixel2 >> 8) & 255);
HXDLIN( 251)													if ((this72 == 0)) {
HXDLIN( 251)														m22 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m22 = (( (Float)(this72) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m32;
HXDLIN( 251)													int this73 = (maskPixel2 & 255);
HXDLIN( 251)													if ((this73 == 0)) {
HXDLIN( 251)														m32 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m32 = (( (Float)(this73) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this69 >> 24) & 255)) )));
HXDLIN( 251)													int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this69 >> 16) & 255)) )));
HXDLIN( 251)													int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this69 >> 8) & 255)) )));
HXDLIN( 251)													int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this69 & 255)) )));
HXDLIN( 251)													col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 251)											if ((col2 != 0)) {
HXDLIN( 251)												int x7 = (dx4 - rectLeft2);
HXDLIN( 251)												int y7 = (dy4 - rectTop2);
HXDLIN( 251)												int c8 = col2;
HXDLIN( 251)												bool hitQuad18;
HXDLIN( 251)												if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 251)													hitQuad18 = undoImage6->transparent;
            												}
            												else {
HXDLIN( 251)													hitQuad18 = false;
            												}
HXDLIN( 251)												if (hitQuad18) {
HXDLIN( 251)													int location4;
HXDLIN( 251)													if (undoImage6->useVirtualPos) {
HXDLIN( 251)														location4 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 251)														location4 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            													}
HXDLIN( 251)													int this74 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 251)													int this75;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														this75 = ((((((this74 >> 24) & 255) << 24) | ((this74 & 255) << 16)) | (((this74 >> 8) & 255) << 8)) | ((this74 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														this75 = this74;
            													}
HXDLIN( 251)													Float a16;
HXDLIN( 251)													int this76 = ((this75 >> 24) & 255);
HXDLIN( 251)													if ((this76 == 0)) {
HXDLIN( 251)														a16 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														a16 = (( (Float)(this76) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float r14;
HXDLIN( 251)													int this77 = ((this75 >> 16) & 255);
HXDLIN( 251)													if ((this77 == 0)) {
HXDLIN( 251)														r14 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														r14 = (( (Float)(this77) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float g14;
HXDLIN( 251)													int this78 = ((this75 >> 8) & 255);
HXDLIN( 251)													if ((this78 == 0)) {
HXDLIN( 251)														g14 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														g14 = (( (Float)(this78) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float b19;
HXDLIN( 251)													int this79 = (this75 & 255);
HXDLIN( 251)													if ((this79 == 0)) {
HXDLIN( 251)														b19 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														b19 = (( (Float)(this79) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float a24;
HXDLIN( 251)													int this80 = ((col2 >> 24) & 255);
HXDLIN( 251)													if ((this80 == 0)) {
HXDLIN( 251)														a24 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														a24 = (( (Float)(this80) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float r24;
HXDLIN( 251)													int this81 = ((col2 >> 16) & 255);
HXDLIN( 251)													if ((this81 == 0)) {
HXDLIN( 251)														r24 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														r24 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float g24;
HXDLIN( 251)													int this82 = ((col2 >> 8) & 255);
HXDLIN( 251)													if ((this82 == 0)) {
HXDLIN( 251)														g24 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														g24 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float b25;
HXDLIN( 251)													int this83 = (col2 & 255);
HXDLIN( 251)													if ((this83 == 0)) {
HXDLIN( 251)														b25 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														b25 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float a34 = (a16 * (( (Float)(1) ) - a24));
HXDLIN( 251)													int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 251)													int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 251)													int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a34) + (b25 * a24))));
HXDLIN( 251)													int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 251)													int blended4 = ((((a17 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 251)													{
HXDLIN( 251)														int hitQuad19;
HXDLIN( 251)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)															hitQuad19 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXDLIN( 251)															hitQuad19 = blended4;
            														}
HXDLIN( 251)														::iterMagic::Iimg_obj::set(undoImage6->image,location4,hitQuad19);
            													}
            												}
            												else {
HXDLIN( 251)													::Dynamic this84 = undoImage6->image;
HXDLIN( 251)													int index10;
HXDLIN( 251)													if (undoImage6->useVirtualPos) {
HXDLIN( 251)														index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 251)														index10 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            													}
HXDLIN( 251)													int hitQuad20;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad20 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad20 = c8;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this84,index10,hitQuad20);
            												}
            											}
            											else {
HXDLIN( 251)												if (forceClear2) {
HXDLIN( 251)													::Dynamic this85 = undoImage6->image;
HXDLIN( 251)													int x8 = (dx4 - rectLeft2);
HXDLIN( 251)													int y8 = (dy4 - rectTop2);
HXDLIN( 251)													int index11;
HXDLIN( 251)													if (undoImage6->useVirtualPos) {
HXDLIN( 251)														index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 251)														index11 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this85,index11,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					{
HXDLIN( 251)						int _g_min4 = xIter32->start;
HXDLIN( 251)						int _g_max4 = xIter32->max;
HXDLIN( 251)						while((_g_min4 < _g_max4)){
HXDLIN( 251)							_g_min4 = (_g_min4 + 1);
HXDLIN( 251)							int px3 = (_g_min4 - 1);
HXDLIN( 251)							Float pcx2 = (( (Float)(px3) ) - dx3);
HXDLIN( 251)							{
HXDLIN( 251)								int _g_min5 = yIter32->start;
HXDLIN( 251)								int _g_max5 = yIter32->max;
HXDLIN( 251)								while((_g_min5 < _g_max5)){
HXDLIN( 251)									_g_min5 = (_g_min5 + 1);
HXDLIN( 251)									int py3 = (_g_min5 - 1);
HXDLIN( 251)									Float pcy2 = (( (Float)(py3) ) - dy3);
HXDLIN( 251)									Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 251)									Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 251)									Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 251)									Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 251)									Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 251)									bool hitQuad21;
HXDLIN( 251)									bool hitQuad22;
HXDLIN( 251)									if ((ratioA2 >= 0)) {
HXDLIN( 251)										hitQuad22 = (ratioB2 >= 0);
            									}
            									else {
HXDLIN( 251)										hitQuad22 = false;
            									}
HXDLIN( 251)									if (hitQuad22) {
HXDLIN( 251)										hitQuad21 = (ratioC2 >= 0);
            									}
            									else {
HXDLIN( 251)										hitQuad21 = false;
            									}
HXDLIN( 251)									if (hitQuad21) {
HXDLIN( 251)										int i26 = ::Std_obj::_hx_int((((( (Float)(aA2) ) * ratioA2) + (( (Float)(aB2) ) * ratioB2)) + (( (Float)(aC2) ) * ratioC2)));
HXDLIN( 251)										if ((i26 > 255)) {
HXLINE(  24)											i26 = 255;
            										}
HXLINE( 251)										if ((i26 < 0)) {
HXLINE(  25)											i26 = 0;
            										}
HXLINE( 251)										int a18 = i26;
HXDLIN( 251)										int i27 = ::Std_obj::_hx_int((((( (Float)(rA2) ) * ratioA2) + (( (Float)(rB2) ) * ratioB2)) + (( (Float)(rC2) ) * ratioC2)));
HXDLIN( 251)										if ((i27 > 255)) {
HXLINE(  24)											i27 = 255;
            										}
HXLINE( 251)										if ((i27 < 0)) {
HXLINE(  25)											i27 = 0;
            										}
HXLINE( 251)										int r9 = i27;
HXDLIN( 251)										int i28 = ::Std_obj::_hx_int((((( (Float)(gA2) ) * ratioA2) + (( (Float)(gB2) ) * ratioB2)) + (( (Float)(gC2) ) * ratioC2)));
HXDLIN( 251)										if ((i28 > 255)) {
HXLINE(  24)											i28 = 255;
            										}
HXLINE( 251)										if ((i28 < 0)) {
HXLINE(  25)											i28 = 0;
            										}
HXLINE( 251)										int g9 = i28;
HXDLIN( 251)										int i29 = ::Std_obj::_hx_int((((( (Float)(bA2) ) * ratioA2) + (( (Float)(bB2) ) * ratioB2)) + (( (Float)(bC2) ) * ratioC2)));
HXDLIN( 251)										if ((i29 > 255)) {
HXLINE(  24)											i29 = 255;
            										}
HXLINE( 251)										if ((i29 < 0)) {
HXLINE(  25)											i29 = 0;
            										}
HXLINE( 251)										int b26 = i29;
HXDLIN( 251)										{
HXDLIN( 251)											int location5;
HXDLIN( 251)											if (this1->useVirtualPos) {
HXDLIN( 251)												location5 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this1->virtualY) * ( (Float)(this1->width) )) + px3) - this1->virtualX));
            											}
            											else {
HXDLIN( 251)												location5 = ::Std_obj::_hx_int(( (Float)(((py3 * this1->width) + px3)) ));
            											}
HXDLIN( 251)											bool hitQuad23;
HXDLIN( 251)											if (this1->transparent) {
HXDLIN( 251)												hitQuad23 = (a18 < 254);
            											}
            											else {
HXDLIN( 251)												hitQuad23 = false;
            											}
HXDLIN( 251)											if (hitQuad23) {
HXDLIN( 251)												int this86 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 251)												int old2;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													old2 = ((((((this86 >> 24) & 255) << 24) | ((this86 & 255) << 16)) | (((this86 >> 8) & 255) << 8)) | ((this86 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													old2 = this86;
            												}
HXDLIN( 251)												int rhs2 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b26);
HXDLIN( 251)												Float a19;
HXDLIN( 251)												int this87 = ((old2 >> 24) & 255);
HXDLIN( 251)												if ((this87 == 0)) {
HXDLIN( 251)													a19 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a19 = (( (Float)(this87) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r15;
HXDLIN( 251)												int this88 = ((old2 >> 16) & 255);
HXDLIN( 251)												if ((this88 == 0)) {
HXDLIN( 251)													r15 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r15 = (( (Float)(this88) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g15;
HXDLIN( 251)												int this89 = ((old2 >> 8) & 255);
HXDLIN( 251)												if ((this89 == 0)) {
HXDLIN( 251)													g15 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g15 = (( (Float)(this89) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b110;
HXDLIN( 251)												int this90 = (old2 & 255);
HXDLIN( 251)												if ((this90 == 0)) {
HXDLIN( 251)													b110 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b110 = (( (Float)(this90) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a25;
HXDLIN( 251)												int this91 = ((rhs2 >> 24) & 255);
HXDLIN( 251)												if ((this91 == 0)) {
HXDLIN( 251)													a25 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a25 = (( (Float)(this91) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r25;
HXDLIN( 251)												int this92 = ((rhs2 >> 16) & 255);
HXDLIN( 251)												if ((this92 == 0)) {
HXDLIN( 251)													r25 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r25 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g25;
HXDLIN( 251)												int this93 = ((rhs2 >> 8) & 255);
HXDLIN( 251)												if ((this93 == 0)) {
HXDLIN( 251)													g25 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g25 = (( (Float)(this93) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b27;
HXDLIN( 251)												int this94 = (rhs2 & 255);
HXDLIN( 251)												if ((this94 == 0)) {
HXDLIN( 251)													b27 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b27 = (( (Float)(this94) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a35 = (a19 * (( (Float)(1) ) - a25));
HXDLIN( 251)												int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 251)												int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 251)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a35) + (b27 * a25))));
HXDLIN( 251)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 251)												int blended5 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b28);
HXDLIN( 251)												{
HXDLIN( 251)													int hitQuad24;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad24 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad24 = blended5;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this1->image,location5,hitQuad24);
            												}
            											}
            											else {
HXDLIN( 251)												int value2;
HXDLIN( 251)												if (this1->isLittle) {
HXDLIN( 251)													value2 = ((((a18 << 24) | (b26 << 16)) | (g9 << 8)) | r9);
            												}
            												else {
HXDLIN( 251)													value2 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b26);
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this1->image,location5,value2);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 251)				{
HXDLIN( 251)					bool hasHit2 = false;
HXDLIN( 251)					bool hasUndo3 = false;
HXDLIN( 251)					int aA3 = ((color2 >> 24) & 255);
HXDLIN( 251)					int rA3 = ((color2 >> 16) & 255);
HXDLIN( 251)					int gA3 = ((color2 >> 8) & 255);
HXDLIN( 251)					int bA3 = (color2 & 255);
HXDLIN( 251)					int aB3 = ((color1 >> 24) & 255);
HXDLIN( 251)					int rB3 = ((color1 >> 16) & 255);
HXDLIN( 251)					int gB3 = ((color1 >> 8) & 255);
HXDLIN( 251)					int bB3 = (color1 & 255);
HXDLIN( 251)					int aC3 = ((color2 >> 24) & 255);
HXDLIN( 251)					int rC3 = ((color2 >> 16) & 255);
HXDLIN( 251)					int gC3 = ((color2 >> 8) & 255);
HXDLIN( 251)					int bC3 = (color2 & 255);
HXDLIN( 251)					Float bcx3 = (cx1 - dx3);
HXDLIN( 251)					Float bcy3 = (cy1 - dy3);
HXDLIN( 251)					Float acx3 = (bx1 - dx3);
HXDLIN( 251)					Float acy3 = (by1 - dy3);
HXDLIN( 251)					Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 251)					Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 251)					Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 251)					Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 251)					 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 251)					if ((bx1 > cx1)) {
HXDLIN( 251)						if ((bx1 > dx3)) {
HXDLIN( 251)							int min12;
HXDLIN( 251)							if ((cx1 > dx3)) {
HXDLIN( 251)								min12 = ::Math_obj::floor(dx3);
            							}
            							else {
HXDLIN( 251)								min12 = ::Math_obj::floor(cx1);
            							}
HXDLIN( 251)							int ii_min24 = min12;
HXDLIN( 251)							int ii_max24 = ::Math_obj::ceil(bx1);
HXDLIN( 251)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            						}
            						else {
HXDLIN( 251)							int ii_min25 = ::Math_obj::floor(cx1);
HXDLIN( 251)							int ii_max25 = ::Math_obj::ceil(dx3);
HXDLIN( 251)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            						}
            					}
            					else {
HXDLIN( 251)						if ((cx1 > dx3)) {
HXDLIN( 251)							int min13;
HXDLIN( 251)							if ((bx1 > dx3)) {
HXDLIN( 251)								min13 = ::Math_obj::floor(dx3);
            							}
            							else {
HXDLIN( 251)								min13 = ::Math_obj::ceil(bx1);
            							}
HXDLIN( 251)							int ii_min26 = min13;
HXDLIN( 251)							int ii_max26 = ::Math_obj::ceil(cx1);
HXDLIN( 251)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            						}
            						else {
HXDLIN( 251)							int ii_min27 = ::Math_obj::floor(bx1);
HXDLIN( 251)							int ii_max27 = ::Math_obj::ceil(dx3);
HXDLIN( 251)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            						}
            					}
HXDLIN( 251)					 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 251)					if ((by1 > cy1)) {
HXDLIN( 251)						if ((by1 > dy3)) {
HXDLIN( 251)							int min14;
HXDLIN( 251)							if ((cy1 > dy3)) {
HXDLIN( 251)								min14 = ::Math_obj::floor(dy3);
            							}
            							else {
HXDLIN( 251)								min14 = ::Math_obj::floor(cy1);
            							}
HXDLIN( 251)							int ii_min28 = min14;
HXDLIN( 251)							int ii_max28 = ::Math_obj::ceil(by1);
HXDLIN( 251)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            						}
            						else {
HXDLIN( 251)							int ii_min29 = ::Math_obj::floor(cy1);
HXDLIN( 251)							int ii_max29 = ::Math_obj::ceil(dy3);
HXDLIN( 251)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            						}
            					}
            					else {
HXDLIN( 251)						if ((cy1 > dy3)) {
HXDLIN( 251)							int min15;
HXDLIN( 251)							if ((by1 > dy3)) {
HXDLIN( 251)								min15 = ::Math_obj::floor(dy3);
            							}
            							else {
HXDLIN( 251)								min15 = ::Math_obj::ceil(by1);
            							}
HXDLIN( 251)							int ii_min30 = min15;
HXDLIN( 251)							int ii_max30 = ::Math_obj::ceil(cy1);
HXDLIN( 251)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            						}
            						else {
HXDLIN( 251)							int ii_min31 = ::Math_obj::floor(by1);
HXDLIN( 251)							int ii_max31 = ::Math_obj::ceil(dy3);
HXDLIN( 251)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            						}
            					}
HXDLIN( 251)					 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 251)					if (hasUndo3) {
HXDLIN( 251)						int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 251)						int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 251)						 ::Dynamic imageType3 = null();
HXDLIN( 251)						 ::pi_xy::ImageStruct this95 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 251)						if (::hx::IsNull( imageType3 )) {
HXLINE(  54)							imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 251)						::Dynamic undoImage10;
HXDLIN( 251)						switch((int)(( (int)(imageType3) ))){
            							case (int)0: {
HXDLIN( 251)								 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::BytesImg b29 = byt3;
HXDLIN( 251)								{
HXDLIN( 251)									b29->width = width3;
HXDLIN( 251)									b29->height = height3;
HXDLIN( 251)									b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 251)									b29->data = ::haxe::io::Bytes_obj::alloc((b29->length * 4));
HXDLIN( 251)									{
HXDLIN( 251)										int len6 = b29->length;
HXDLIN( 251)										int w3 = 0;
HXDLIN( 251)										{
HXDLIN( 251)											int _g60 = 0;
HXDLIN( 251)											int _g61 = b29->height;
HXDLIN( 251)											while((_g60 < _g61)){
HXDLIN( 251)												_g60 = (_g60 + 1);
HXDLIN( 251)												int y9 = (_g60 - 1);
HXDLIN( 251)												{
HXDLIN( 251)													int _g62 = 0;
HXDLIN( 251)													int _g63 = b29->width;
HXDLIN( 251)													while((_g62 < _g63)){
HXDLIN( 251)														_g62 = (_g62 + 1);
HXDLIN( 251)														int x9 = (_g62 - 1);
HXDLIN( 251)														{
HXDLIN( 251)															w3 = (w3 + 1);
HXDLIN( 251)															b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w3 = (w3 + 1);
HXDLIN( 251)															b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w3 = (w3 + 1);
HXDLIN( 251)															b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 251)														{
HXDLIN( 251)															w3 = (w3 + 1);
HXDLIN( 251)															b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage10 = b29;
            							}
            							break;
            							case (int)1: {
HXDLIN( 251)								 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::ArrIntImg a26 = arrI3;
HXDLIN( 251)								{
HXDLIN( 251)									a26->width = width3;
HXDLIN( 251)									a26->height = height3;
HXDLIN( 251)									a26->data = ::Array_obj< int >::__new(0);
HXDLIN( 251)									a26->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 251)									{
HXDLIN( 251)										int _g64 = 0;
HXDLIN( 251)										int _g65 = a26->length;
HXDLIN( 251)										while((_g64 < _g65)){
HXDLIN( 251)											_g64 = (_g64 + 1);
HXDLIN( 251)											int i30 = (_g64 - 1);
HXDLIN( 251)											a26->data[i30] = 0;
            										}
            									}
            								}
HXDLIN( 251)								undoImage10 = a26;
            							}
            							break;
            							case (int)2: {
HXDLIN( 251)								 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::U32ArrImg b30 = u32a3;
HXDLIN( 251)								{
HXDLIN( 251)									b30->width = width3;
HXDLIN( 251)									b30->height = height3;
HXDLIN( 251)									b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 251)									int size3 = (b30->length * 4);
HXDLIN( 251)									b30->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 251)									{
HXDLIN( 251)										int _g66 = 0;
HXDLIN( 251)										int _g67 = b30->length;
HXDLIN( 251)										while((_g66 < _g67)){
HXDLIN( 251)											_g66 = (_g66 + 1);
HXDLIN( 251)											int i31 = (_g66 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												 ::haxe::io::ArrayBufferViewImpl this96 = b30->data;
HXDLIN( 251)												bool undoImage11;
HXDLIN( 251)												if ((i31 >= 0)) {
HXDLIN( 251)													undoImage11 = (i31 < (this96->byteLength >> 2));
            												}
            												else {
HXDLIN( 251)													undoImage11 = false;
            												}
HXDLIN( 251)												if (undoImage11) {
HXDLIN( 251)													 ::haxe::io::Bytes _this3 = this96->bytes;
HXDLIN( 251)													int pos3 = ((i31 << 2) + this96->byteOffset);
HXDLIN( 251)													_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 251)													_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 251)													_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 251)													_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage10 = b30;
            							}
            							break;
            							case (int)3: {
HXDLIN( 251)								 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::VecIntImg v8 = vec3;
HXDLIN( 251)								{
HXDLIN( 251)									v8->width = width3;
HXDLIN( 251)									v8->height = height3;
HXDLIN( 251)									v8->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 251)									v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN( 251)									{
HXDLIN( 251)										int _g68 = 0;
HXDLIN( 251)										int _g69 = v8->length;
HXDLIN( 251)										while((_g68 < _g69)){
HXDLIN( 251)											_g68 = (_g68 + 1);
HXDLIN( 251)											int i32 = (_g68 - 1);
HXDLIN( 251)											v8->data->__unsafe_set(i32,0);
            										}
            									}
            								}
HXDLIN( 251)								undoImage10 = v8;
            							}
            							break;
            							case (int)4: {
HXDLIN( 251)								 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)								 ::iterMagic::StackIntImg b31 = sInt3;
HXDLIN( 251)								{
HXDLIN( 251)									b31->width = width3;
HXDLIN( 251)									b31->height = height3;
HXDLIN( 251)									b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 251)									b31->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 251)									{
HXDLIN( 251)										int len7 = b31->length;
HXDLIN( 251)										 ::haxe::ds::GenericStack_Int d3 = b31->data;
HXDLIN( 251)										if (::hx::IsNull( d3->head )) {
HXDLIN( 251)											int _g70 = 0;
HXDLIN( 251)											int _g71 = len7;
HXDLIN( 251)											while((_g70 < _g71)){
HXDLIN( 251)												_g70 = (_g70 + 1);
HXDLIN( 251)												int i33 = (_g70 - 1);
HXDLIN( 251)												d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            											}
            										}
            										else {
HXDLIN( 251)											int _g72 = 0;
HXDLIN( 251)											int _g73 = len7;
HXDLIN( 251)											while((_g72 < _g73)){
HXDLIN( 251)												_g72 = (_g72 + 1);
HXDLIN( 251)												int i34 = (_g72 - 1);
HXDLIN( 251)												{
HXDLIN( 251)													 ::haxe::ds::GenericCell_Int l3 = b31->data->head;
HXDLIN( 251)													 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 251)													{
HXDLIN( 251)														int _g74 = 0;
HXDLIN( 251)														int _g75 = i34;
HXDLIN( 251)														while((_g74 < _g75)){
HXDLIN( 251)															_g74 = (_g74 + 1);
HXDLIN( 251)															int i35 = (_g74 - 1);
HXLINE( 345)															prev3 = l3;
HXLINE( 346)															l3 = l3->next;
            														}
            													}
HXLINE( 251)													if (::hx::IsNull( prev3 )) {
HXDLIN( 251)														b31->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 251)														l3 = null();
            													}
            													else {
HXDLIN( 251)														prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 251)														l3 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 251)								undoImage10 = b31;
            							}
            							break;
            						}
HXDLIN( 251)						this95->image = undoImage10;
HXDLIN( 251)						this95->width = width3;
HXDLIN( 251)						this95->height = height3;
HXDLIN( 251)						this95->imageType = ( (int)(imageType3) );
HXDLIN( 251)						undoImage9 = this95;
HXDLIN( 251)						{
HXDLIN( 251)							int rectLeft3 = xIter33->start;
HXDLIN( 251)							int rectTop3 = yIter33->start;
HXDLIN( 251)							int rectRight3 = xIter33->max;
HXDLIN( 251)							bool forceClear3 = false;
HXDLIN( 251)							{
HXDLIN( 251)								int _g76 = rectTop3;
HXDLIN( 251)								int _g77 = yIter33->max;
HXDLIN( 251)								while((_g76 < _g77)){
HXDLIN( 251)									_g76 = (_g76 + 1);
HXDLIN( 251)									int dy5 = (_g76 - 1);
HXDLIN( 251)									{
HXDLIN( 251)										int _g78 = rectLeft3;
HXDLIN( 251)										int _g79 = rectRight3;
HXDLIN( 251)										while((_g78 < _g79)){
HXDLIN( 251)											_g78 = (_g78 + 1);
HXDLIN( 251)											int dx5 = (_g78 - 1);
HXDLIN( 251)											::Dynamic this97 = this1->image;
HXDLIN( 251)											int index12;
HXDLIN( 251)											if (this1->useVirtualPos) {
HXDLIN( 251)												index12 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx5) - this1->virtualX));
            											}
            											else {
HXDLIN( 251)												index12 = ::Std_obj::_hx_int(( (Float)(((dy5 * this1->width) + dx5)) ));
            											}
HXDLIN( 251)											int c9 = ::iterMagic::Iimg_obj::get(this97,index12);
HXDLIN( 251)											int col3;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												col3 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												col3 = c9;
            											}
HXDLIN( 251)											bool hitQuad25;
HXDLIN( 251)											if (this1->useMask) {
HXDLIN( 251)												hitQuad25 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXDLIN( 251)												hitQuad25 = false;
            											}
HXDLIN( 251)											if (hitQuad25) {
HXDLIN( 251)												 ::pi_xy::ImageStruct this98 = this1->mask;
HXDLIN( 251)												::Dynamic this99 = this98->image;
HXDLIN( 251)												int index13;
HXDLIN( 251)												if (this98->useVirtualPos) {
HXDLIN( 251)													index13 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this98->virtualY) * ( (Float)(this98->width) )) + dx5) - this98->virtualX));
            												}
            												else {
HXDLIN( 251)													index13 = ::Std_obj::_hx_int(( (Float)(((dy5 * this98->width) + dx5)) ));
            												}
HXDLIN( 251)												int c10 = ::iterMagic::Iimg_obj::get(this99,index13);
HXDLIN( 251)												int v9;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													v9 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													v9 = c10;
            												}
HXDLIN( 251)												int maskPixel3 = v9;
HXDLIN( 251)												int this100 = col3;
HXDLIN( 251)												if ((maskPixel3 == 0)) {
HXDLIN( 251)													col3 = this100;
            												}
            												else {
HXDLIN( 251)													Float m03;
HXDLIN( 251)													int this101 = ((maskPixel3 >> 24) & 255);
HXDLIN( 251)													if ((this101 == 0)) {
HXDLIN( 251)														m03 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m03 = (( (Float)(this101) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m13;
HXDLIN( 251)													int this102 = ((maskPixel3 >> 16) & 255);
HXDLIN( 251)													if ((this102 == 0)) {
HXDLIN( 251)														m13 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m13 = (( (Float)(this102) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m23;
HXDLIN( 251)													int this103 = ((maskPixel3 >> 8) & 255);
HXDLIN( 251)													if ((this103 == 0)) {
HXDLIN( 251)														m23 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m23 = (( (Float)(this103) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float m33;
HXDLIN( 251)													int this104 = (maskPixel3 & 255);
HXDLIN( 251)													if ((this104 == 0)) {
HXDLIN( 251)														m33 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														m33 = (( (Float)(this104) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this100 >> 24) & 255)) )));
HXDLIN( 251)													int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this100 >> 16) & 255)) )));
HXDLIN( 251)													int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this100 >> 8) & 255)) )));
HXDLIN( 251)													int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this100 & 255)) )));
HXDLIN( 251)													col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 251)											if ((col3 != 0)) {
HXDLIN( 251)												int x10 = (dx5 - rectLeft3);
HXDLIN( 251)												int y10 = (dy5 - rectTop3);
HXDLIN( 251)												int c11 = col3;
HXDLIN( 251)												bool hitQuad26;
HXDLIN( 251)												if ((((c11 >> 24) & 255) < 254)) {
HXDLIN( 251)													hitQuad26 = undoImage9->transparent;
            												}
            												else {
HXDLIN( 251)													hitQuad26 = false;
            												}
HXDLIN( 251)												if (hitQuad26) {
HXDLIN( 251)													int location6;
HXDLIN( 251)													if (undoImage9->useVirtualPos) {
HXDLIN( 251)														location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            													}
            													else {
HXDLIN( 251)														location6 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            													}
HXDLIN( 251)													int this105 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 251)													int this106;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														this106 = ((((((this105 >> 24) & 255) << 24) | ((this105 & 255) << 16)) | (((this105 >> 8) & 255) << 8)) | ((this105 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														this106 = this105;
            													}
HXDLIN( 251)													Float a110;
HXDLIN( 251)													int this107 = ((this106 >> 24) & 255);
HXDLIN( 251)													if ((this107 == 0)) {
HXDLIN( 251)														a110 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														a110 = (( (Float)(this107) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float r16;
HXDLIN( 251)													int this108 = ((this106 >> 16) & 255);
HXDLIN( 251)													if ((this108 == 0)) {
HXDLIN( 251)														r16 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														r16 = (( (Float)(this108) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float g16;
HXDLIN( 251)													int this109 = ((this106 >> 8) & 255);
HXDLIN( 251)													if ((this109 == 0)) {
HXDLIN( 251)														g16 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														g16 = (( (Float)(this109) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float b111;
HXDLIN( 251)													int this110 = (this106 & 255);
HXDLIN( 251)													if ((this110 == 0)) {
HXDLIN( 251)														b111 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														b111 = (( (Float)(this110) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float a27;
HXDLIN( 251)													int this111 = ((col3 >> 24) & 255);
HXDLIN( 251)													if ((this111 == 0)) {
HXDLIN( 251)														a27 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														a27 = (( (Float)(this111) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float r26;
HXDLIN( 251)													int this112 = ((col3 >> 16) & 255);
HXDLIN( 251)													if ((this112 == 0)) {
HXDLIN( 251)														r26 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														r26 = (( (Float)(this112) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float g26;
HXDLIN( 251)													int this113 = ((col3 >> 8) & 255);
HXDLIN( 251)													if ((this113 == 0)) {
HXDLIN( 251)														g26 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														g26 = (( (Float)(this113) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float b210;
HXDLIN( 251)													int this114 = (col3 & 255);
HXDLIN( 251)													if ((this114 == 0)) {
HXDLIN( 251)														b210 = ((Float)0.);
            													}
            													else {
HXDLIN( 251)														b210 = (( (Float)(this114) ) / ( (Float)(255) ));
            													}
HXDLIN( 251)													Float a36 = (a110 * (( (Float)(1) ) - a27));
HXDLIN( 251)													int r17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a27))));
HXDLIN( 251)													int g17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a27))));
HXDLIN( 251)													int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a36) + (b210 * a27))));
HXDLIN( 251)													int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a27)));
HXDLIN( 251)													int blended6 = ((((a28 << 24) | (r17 << 16)) | (g17 << 8)) | b32);
HXDLIN( 251)													{
HXDLIN( 251)														int hitQuad27;
HXDLIN( 251)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)															hitQuad27 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            														}
            														else {
HXDLIN( 251)															hitQuad27 = blended6;
            														}
HXDLIN( 251)														::iterMagic::Iimg_obj::set(undoImage9->image,location6,hitQuad27);
            													}
            												}
            												else {
HXDLIN( 251)													::Dynamic this115 = undoImage9->image;
HXDLIN( 251)													int index14;
HXDLIN( 251)													if (undoImage9->useVirtualPos) {
HXDLIN( 251)														index14 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            													}
            													else {
HXDLIN( 251)														index14 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            													}
HXDLIN( 251)													int hitQuad28;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad28 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad28 = c11;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this115,index14,hitQuad28);
            												}
            											}
            											else {
HXDLIN( 251)												if (forceClear3) {
HXDLIN( 251)													::Dynamic this116 = undoImage9->image;
HXDLIN( 251)													int x11 = (dx5 - rectLeft3);
HXDLIN( 251)													int y11 = (dy5 - rectTop3);
HXDLIN( 251)													int index15;
HXDLIN( 251)													if (undoImage9->useVirtualPos) {
HXDLIN( 251)														index15 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            													}
            													else {
HXDLIN( 251)														index15 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this116,index15,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					{
HXDLIN( 251)						int _g_min6 = xIter33->start;
HXDLIN( 251)						int _g_max6 = xIter33->max;
HXDLIN( 251)						while((_g_min6 < _g_max6)){
HXDLIN( 251)							_g_min6 = (_g_min6 + 1);
HXDLIN( 251)							int px4 = (_g_min6 - 1);
HXDLIN( 251)							Float pcx3 = (( (Float)(px4) ) - dx3);
HXDLIN( 251)							{
HXDLIN( 251)								int _g_min7 = yIter33->start;
HXDLIN( 251)								int _g_max7 = yIter33->max;
HXDLIN( 251)								while((_g_min7 < _g_max7)){
HXDLIN( 251)									_g_min7 = (_g_min7 + 1);
HXDLIN( 251)									int py4 = (_g_min7 - 1);
HXDLIN( 251)									Float pcy3 = (( (Float)(py4) ) - dy3);
HXDLIN( 251)									Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 251)									Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 251)									Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 251)									Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 251)									Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 251)									bool hitQuad29;
HXDLIN( 251)									bool hitQuad30;
HXDLIN( 251)									if ((ratioA3 >= 0)) {
HXDLIN( 251)										hitQuad30 = (ratioB3 >= 0);
            									}
            									else {
HXDLIN( 251)										hitQuad30 = false;
            									}
HXDLIN( 251)									if (hitQuad30) {
HXDLIN( 251)										hitQuad29 = (ratioC3 >= 0);
            									}
            									else {
HXDLIN( 251)										hitQuad29 = false;
            									}
HXDLIN( 251)									if (hitQuad29) {
HXDLIN( 251)										int i36 = ::Std_obj::_hx_int((((( (Float)(aA3) ) * ratioA3) + (( (Float)(aB3) ) * ratioB3)) + (( (Float)(aC3) ) * ratioC3)));
HXDLIN( 251)										if ((i36 > 255)) {
HXLINE(  24)											i36 = 255;
            										}
HXLINE( 251)										if ((i36 < 0)) {
HXLINE(  25)											i36 = 0;
            										}
HXLINE( 251)										int a29 = i36;
HXDLIN( 251)										int i37 = ::Std_obj::_hx_int((((( (Float)(rA3) ) * ratioA3) + (( (Float)(rB3) ) * ratioB3)) + (( (Float)(rC3) ) * ratioC3)));
HXDLIN( 251)										if ((i37 > 255)) {
HXLINE(  24)											i37 = 255;
            										}
HXLINE( 251)										if ((i37 < 0)) {
HXLINE(  25)											i37 = 0;
            										}
HXLINE( 251)										int r18 = i37;
HXDLIN( 251)										int i38 = ::Std_obj::_hx_int((((( (Float)(gA3) ) * ratioA3) + (( (Float)(gB3) ) * ratioB3)) + (( (Float)(gC3) ) * ratioC3)));
HXDLIN( 251)										if ((i38 > 255)) {
HXLINE(  24)											i38 = 255;
            										}
HXLINE( 251)										if ((i38 < 0)) {
HXLINE(  25)											i38 = 0;
            										}
HXLINE( 251)										int g18 = i38;
HXDLIN( 251)										int i39 = ::Std_obj::_hx_int((((( (Float)(bA3) ) * ratioA3) + (( (Float)(bB3) ) * ratioB3)) + (( (Float)(bC3) ) * ratioC3)));
HXDLIN( 251)										if ((i39 > 255)) {
HXLINE(  24)											i39 = 255;
            										}
HXLINE( 251)										if ((i39 < 0)) {
HXLINE(  25)											i39 = 0;
            										}
HXLINE( 251)										int b33 = i39;
HXDLIN( 251)										{
HXDLIN( 251)											int location7;
HXDLIN( 251)											if (this1->useVirtualPos) {
HXDLIN( 251)												location7 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - this1->virtualY) * ( (Float)(this1->width) )) + px4) - this1->virtualX));
            											}
            											else {
HXDLIN( 251)												location7 = ::Std_obj::_hx_int(( (Float)(((py4 * this1->width) + px4)) ));
            											}
HXDLIN( 251)											bool hitQuad31;
HXDLIN( 251)											if (this1->transparent) {
HXDLIN( 251)												hitQuad31 = (a29 < 254);
            											}
            											else {
HXDLIN( 251)												hitQuad31 = false;
            											}
HXDLIN( 251)											if (hitQuad31) {
HXDLIN( 251)												int this117 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN( 251)												int old3;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													old3 = ((((((this117 >> 24) & 255) << 24) | ((this117 & 255) << 16)) | (((this117 >> 8) & 255) << 8)) | ((this117 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													old3 = this117;
            												}
HXDLIN( 251)												int rhs3 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b33);
HXDLIN( 251)												Float a111;
HXDLIN( 251)												int this118 = ((old3 >> 24) & 255);
HXDLIN( 251)												if ((this118 == 0)) {
HXDLIN( 251)													a111 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a111 = (( (Float)(this118) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r19;
HXDLIN( 251)												int this119 = ((old3 >> 16) & 255);
HXDLIN( 251)												if ((this119 == 0)) {
HXDLIN( 251)													r19 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r19 = (( (Float)(this119) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g19;
HXDLIN( 251)												int this120 = ((old3 >> 8) & 255);
HXDLIN( 251)												if ((this120 == 0)) {
HXDLIN( 251)													g19 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g19 = (( (Float)(this120) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b112;
HXDLIN( 251)												int this121 = (old3 & 255);
HXDLIN( 251)												if ((this121 == 0)) {
HXDLIN( 251)													b112 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b112 = (( (Float)(this121) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a210;
HXDLIN( 251)												int this122 = ((rhs3 >> 24) & 255);
HXDLIN( 251)												if ((this122 == 0)) {
HXDLIN( 251)													a210 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a210 = (( (Float)(this122) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r27;
HXDLIN( 251)												int this123 = ((rhs3 >> 16) & 255);
HXDLIN( 251)												if ((this123 == 0)) {
HXDLIN( 251)													r27 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r27 = (( (Float)(this123) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g27;
HXDLIN( 251)												int this124 = ((rhs3 >> 8) & 255);
HXDLIN( 251)												if ((this124 == 0)) {
HXDLIN( 251)													g27 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g27 = (( (Float)(this124) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b211;
HXDLIN( 251)												int this125 = (rhs3 & 255);
HXDLIN( 251)												if ((this125 == 0)) {
HXDLIN( 251)													b211 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b211 = (( (Float)(this125) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a37 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 251)												int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a37) + (r27 * a210))));
HXDLIN( 251)												int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a37) + (g27 * a210))));
HXDLIN( 251)												int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a37) + (b211 * a210))));
HXDLIN( 251)												int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a210)));
HXDLIN( 251)												int blended7 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 251)												{
HXDLIN( 251)													int hitQuad32;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad32 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad32 = blended7;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(this1->image,location7,hitQuad32);
            												}
            											}
            											else {
HXDLIN( 251)												int value3;
HXDLIN( 251)												if (this1->isLittle) {
HXDLIN( 251)													value3 = ((((a29 << 24) | (b33 << 16)) | (g18 << 8)) | r18);
            												}
            												else {
HXDLIN( 251)													value3 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b33);
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this1->image,location7,value3);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					if ((hasHit2 == false)) {
HXDLIN( 251)						 ::pi_xy::algo::HitTri v10 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx1,by1,cx1,cy1,dx3,dy3,true);
HXDLIN( 251)						if (hasUndo3) {
HXDLIN( 251)							v10->undoImage = undoImage9;
HXDLIN( 251)							v10->undoX = xIter33->start;
HXDLIN( 251)							v10->undoY = yIter33->start;
            						}
            					}
            				}
HXDLIN( 251)				 ::pi_xy::algo::HitQuad v11 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax1,ay1,bx1,by1,cx1,cy1,dx3,dy3,true);
HXDLIN( 251)				hitQuad = v11;
            			}
            		}
            		else {
HXDLIN( 251)			Float sin3 = ::Math_obj::sin(theta);
HXDLIN( 251)			Float cos3 = ::Math_obj::cos(theta);
HXDLIN( 251)			Float radius3 = (thick / ( (Float)(2) ));
HXDLIN( 251)			Float dx6 = ((Float)0.1);
HXDLIN( 251)			Float dy6 = radius3;
HXDLIN( 251)			Float cx2 = h2;
HXDLIN( 251)			Float cy2 = radius3;
HXDLIN( 251)			Float bx2 = h2;
HXDLIN( 251)			Float by2 = -(radius3);
HXDLIN( 251)			Float ax2 = ((Float)0.1);
HXDLIN( 251)			Float ay2 = -(radius3);
HXDLIN( 251)			Float temp2 = ((Float)0.);
HXLINE( 474)			temp2 = (px + ((ax2 * cos3) - (ay2 * sin3)));
HXLINE( 475)			ay2 = (py + ((ay2 * cos3) + (ax2 * sin3)));
HXLINE( 476)			ax2 = temp2;
HXLINE( 478)			temp2 = (px + ((bx2 * cos3) - (by2 * sin3)));
HXLINE( 479)			by2 = (py + ((by2 * cos3) + (bx2 * sin3)));
HXLINE( 480)			bx2 = temp2;
HXLINE( 482)			temp2 = (px + ((cx2 * cos3) - (cy2 * sin3)));
HXLINE( 483)			cy2 = (py + ((cy2 * cos3) + (cx2 * sin3)));
HXLINE( 484)			cx2 = temp2;
HXLINE( 486)			temp2 = (px + ((dx6 * cos3) - (dy6 * sin3)));
HXLINE( 487)			dy6 = (py + ((dy6 * cos3) + (dx6 * sin3)));
HXLINE( 488)			dx6 = temp2;
HXLINE( 251)			{
HXDLIN( 251)				bool hasUndo4 = false;
HXDLIN( 251)				int aA4 = ((color1 >> 24) & 255);
HXDLIN( 251)				int rA4 = ((color1 >> 16) & 255);
HXDLIN( 251)				int gA4 = ((color1 >> 8) & 255);
HXDLIN( 251)				int bA4 = (color1 & 255);
HXDLIN( 251)				int aB4 = ((color1 >> 24) & 255);
HXDLIN( 251)				int rB4 = ((color1 >> 16) & 255);
HXDLIN( 251)				int gB4 = ((color1 >> 8) & 255);
HXDLIN( 251)				int bB4 = (color1 & 255);
HXDLIN( 251)				int aC4 = ((color2 >> 24) & 255);
HXDLIN( 251)				int rC4 = ((color2 >> 16) & 255);
HXDLIN( 251)				int gC4 = ((color2 >> 8) & 255);
HXDLIN( 251)				int bC4 = (color2 & 255);
HXDLIN( 251)				Float bcx4 = (bx2 - dx6);
HXDLIN( 251)				Float bcy4 = (by2 - dy6);
HXDLIN( 251)				Float acx4 = (ax2 - dx6);
HXDLIN( 251)				Float acy4 = (ay2 - dy6);
HXDLIN( 251)				Float dot114 = ((bcx4 * bcx4) + (bcy4 * bcy4));
HXDLIN( 251)				Float dot124 = ((bcx4 * acx4) + (bcy4 * acy4));
HXDLIN( 251)				Float dot224 = ((acx4 * acx4) + (acy4 * acy4));
HXDLIN( 251)				Float denom14 = (( (Float)(1) ) / ((dot114 * dot224) - (dot124 * dot124)));
HXDLIN( 251)				 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 251)				if ((ax2 > bx2)) {
HXDLIN( 251)					if ((ax2 > dx6)) {
HXDLIN( 251)						int min16;
HXDLIN( 251)						if ((bx2 > dx6)) {
HXDLIN( 251)							min16 = ::Math_obj::floor(dx6);
            						}
            						else {
HXDLIN( 251)							min16 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 251)						int ii_min32 = min16;
HXDLIN( 251)						int ii_max32 = ::Math_obj::ceil(ax2);
HXDLIN( 251)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            					}
            					else {
HXDLIN( 251)						int ii_min33 = ::Math_obj::floor(bx2);
HXDLIN( 251)						int ii_max33 = ::Math_obj::ceil(dx6);
HXDLIN( 251)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            					}
            				}
            				else {
HXDLIN( 251)					if ((bx2 > dx6)) {
HXDLIN( 251)						int min17;
HXDLIN( 251)						if ((ax2 > dx6)) {
HXDLIN( 251)							min17 = ::Math_obj::floor(dx6);
            						}
            						else {
HXDLIN( 251)							min17 = ::Math_obj::ceil(ax2);
            						}
HXDLIN( 251)						int ii_min34 = min17;
HXDLIN( 251)						int ii_max34 = ::Math_obj::ceil(bx2);
HXDLIN( 251)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            					}
            					else {
HXDLIN( 251)						int ii_min35 = ::Math_obj::floor(ax2);
HXDLIN( 251)						int ii_max35 = ::Math_obj::ceil(dx6);
HXDLIN( 251)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            					}
            				}
HXDLIN( 251)				 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 251)				if ((ay2 > by2)) {
HXDLIN( 251)					if ((ay2 > dy6)) {
HXDLIN( 251)						int min18;
HXDLIN( 251)						if ((by2 > dy6)) {
HXDLIN( 251)							min18 = ::Math_obj::floor(dy6);
            						}
            						else {
HXDLIN( 251)							min18 = ::Math_obj::floor(by2);
            						}
HXDLIN( 251)						int ii_min36 = min18;
HXDLIN( 251)						int ii_max36 = ::Math_obj::ceil(ay2);
HXDLIN( 251)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            					}
            					else {
HXDLIN( 251)						int ii_min37 = ::Math_obj::floor(by2);
HXDLIN( 251)						int ii_max37 = ::Math_obj::ceil(dy6);
HXDLIN( 251)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            					}
            				}
            				else {
HXDLIN( 251)					if ((by2 > dy6)) {
HXDLIN( 251)						int min19;
HXDLIN( 251)						if ((ay2 > dy6)) {
HXDLIN( 251)							min19 = ::Math_obj::floor(dy6);
            						}
            						else {
HXDLIN( 251)							min19 = ::Math_obj::ceil(ay2);
            						}
HXDLIN( 251)						int ii_min38 = min19;
HXDLIN( 251)						int ii_max38 = ::Math_obj::ceil(by2);
HXDLIN( 251)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            					}
            					else {
HXDLIN( 251)						int ii_min39 = ::Math_obj::floor(ay2);
HXDLIN( 251)						int ii_max39 = ::Math_obj::ceil(dy6);
HXDLIN( 251)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            					}
            				}
HXDLIN( 251)				 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 251)				if (hasUndo4) {
HXDLIN( 251)					int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 251)					int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 251)					 ::Dynamic imageType4 = null();
HXDLIN( 251)					 ::pi_xy::ImageStruct this126 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 251)					if (::hx::IsNull( imageType4 )) {
HXLINE(  54)						imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 251)					::Dynamic undoImage13;
HXDLIN( 251)					switch((int)(( (int)(imageType4) ))){
            						case (int)0: {
HXDLIN( 251)							 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::BytesImg b35 = byt4;
HXDLIN( 251)							{
HXDLIN( 251)								b35->width = width4;
HXDLIN( 251)								b35->height = height4;
HXDLIN( 251)								b35->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 251)								b35->data = ::haxe::io::Bytes_obj::alloc((b35->length * 4));
HXDLIN( 251)								{
HXDLIN( 251)									int len8 = b35->length;
HXDLIN( 251)									int w4 = 0;
HXDLIN( 251)									{
HXDLIN( 251)										int _g80 = 0;
HXDLIN( 251)										int _g81 = b35->height;
HXDLIN( 251)										while((_g80 < _g81)){
HXDLIN( 251)											_g80 = (_g80 + 1);
HXDLIN( 251)											int y12 = (_g80 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												int _g82 = 0;
HXDLIN( 251)												int _g83 = b35->width;
HXDLIN( 251)												while((_g82 < _g83)){
HXDLIN( 251)													_g82 = (_g82 + 1);
HXDLIN( 251)													int x12 = (_g82 - 1);
HXDLIN( 251)													{
HXDLIN( 251)														w4 = (w4 + 1);
HXDLIN( 251)														b35->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 251)													{
HXDLIN( 251)														w4 = (w4 + 1);
HXDLIN( 251)														b35->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 251)													{
HXDLIN( 251)														w4 = (w4 + 1);
HXDLIN( 251)														b35->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 251)													{
HXDLIN( 251)														w4 = (w4 + 1);
HXDLIN( 251)														b35->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 251)							undoImage13 = b35;
            						}
            						break;
            						case (int)1: {
HXDLIN( 251)							 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::ArrIntImg a38 = arrI4;
HXDLIN( 251)							{
HXDLIN( 251)								a38->width = width4;
HXDLIN( 251)								a38->height = height4;
HXDLIN( 251)								a38->data = ::Array_obj< int >::__new(0);
HXDLIN( 251)								a38->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 251)								{
HXDLIN( 251)									int _g84 = 0;
HXDLIN( 251)									int _g85 = a38->length;
HXDLIN( 251)									while((_g84 < _g85)){
HXDLIN( 251)										_g84 = (_g84 + 1);
HXDLIN( 251)										int i40 = (_g84 - 1);
HXDLIN( 251)										a38->data[i40] = 0;
            									}
            								}
            							}
HXDLIN( 251)							undoImage13 = a38;
            						}
            						break;
            						case (int)2: {
HXDLIN( 251)							 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::U32ArrImg b36 = u32a4;
HXDLIN( 251)							{
HXDLIN( 251)								b36->width = width4;
HXDLIN( 251)								b36->height = height4;
HXDLIN( 251)								b36->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 251)								int size4 = (b36->length * 4);
HXDLIN( 251)								b36->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 251)								{
HXDLIN( 251)									int _g86 = 0;
HXDLIN( 251)									int _g87 = b36->length;
HXDLIN( 251)									while((_g86 < _g87)){
HXDLIN( 251)										_g86 = (_g86 + 1);
HXDLIN( 251)										int i41 = (_g86 - 1);
HXDLIN( 251)										{
HXDLIN( 251)											 ::haxe::io::ArrayBufferViewImpl this127 = b36->data;
HXDLIN( 251)											bool undoImage14;
HXDLIN( 251)											if ((i41 >= 0)) {
HXDLIN( 251)												undoImage14 = (i41 < (this127->byteLength >> 2));
            											}
            											else {
HXDLIN( 251)												undoImage14 = false;
            											}
HXDLIN( 251)											if (undoImage14) {
HXDLIN( 251)												 ::haxe::io::Bytes _this4 = this127->bytes;
HXDLIN( 251)												int pos4 = ((i41 << 2) + this127->byteOffset);
HXDLIN( 251)												_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 251)												_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 251)												_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 251)												_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 251)							undoImage13 = b36;
            						}
            						break;
            						case (int)3: {
HXDLIN( 251)							 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::VecIntImg v12 = vec4;
HXDLIN( 251)							{
HXDLIN( 251)								v12->width = width4;
HXDLIN( 251)								v12->height = height4;
HXDLIN( 251)								v12->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 251)								v12->data = ::Array_obj< int >::__new(v12->length);
HXDLIN( 251)								{
HXDLIN( 251)									int _g88 = 0;
HXDLIN( 251)									int _g89 = v12->length;
HXDLIN( 251)									while((_g88 < _g89)){
HXDLIN( 251)										_g88 = (_g88 + 1);
HXDLIN( 251)										int i42 = (_g88 - 1);
HXDLIN( 251)										v12->data->__unsafe_set(i42,0);
            									}
            								}
            							}
HXDLIN( 251)							undoImage13 = v12;
            						}
            						break;
            						case (int)4: {
HXDLIN( 251)							 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::StackIntImg b37 = sInt4;
HXDLIN( 251)							{
HXDLIN( 251)								b37->width = width4;
HXDLIN( 251)								b37->height = height4;
HXDLIN( 251)								b37->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 251)								b37->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 251)								{
HXDLIN( 251)									int len9 = b37->length;
HXDLIN( 251)									 ::haxe::ds::GenericStack_Int d4 = b37->data;
HXDLIN( 251)									if (::hx::IsNull( d4->head )) {
HXDLIN( 251)										int _g90 = 0;
HXDLIN( 251)										int _g91 = len9;
HXDLIN( 251)										while((_g90 < _g91)){
HXDLIN( 251)											_g90 = (_g90 + 1);
HXDLIN( 251)											int i43 = (_g90 - 1);
HXDLIN( 251)											d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            										}
            									}
            									else {
HXDLIN( 251)										int _g92 = 0;
HXDLIN( 251)										int _g93 = len9;
HXDLIN( 251)										while((_g92 < _g93)){
HXDLIN( 251)											_g92 = (_g92 + 1);
HXDLIN( 251)											int i44 = (_g92 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												 ::haxe::ds::GenericCell_Int l4 = b37->data->head;
HXDLIN( 251)												 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 251)												{
HXDLIN( 251)													int _g94 = 0;
HXDLIN( 251)													int _g95 = i44;
HXDLIN( 251)													while((_g94 < _g95)){
HXDLIN( 251)														_g94 = (_g94 + 1);
HXDLIN( 251)														int i45 = (_g94 - 1);
HXLINE( 345)														prev4 = l4;
HXLINE( 346)														l4 = l4->next;
            													}
            												}
HXLINE( 251)												if (::hx::IsNull( prev4 )) {
HXDLIN( 251)													b37->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 251)													l4 = null();
            												}
            												else {
HXDLIN( 251)													prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 251)													l4 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 251)							undoImage13 = b37;
            						}
            						break;
            					}
HXDLIN( 251)					this126->image = undoImage13;
HXDLIN( 251)					this126->width = width4;
HXDLIN( 251)					this126->height = height4;
HXDLIN( 251)					this126->imageType = ( (int)(imageType4) );
HXDLIN( 251)					undoImage12 = this126;
HXDLIN( 251)					{
HXDLIN( 251)						int rectLeft4 = xIter34->start;
HXDLIN( 251)						int rectTop4 = yIter34->start;
HXDLIN( 251)						int rectRight4 = xIter34->max;
HXDLIN( 251)						bool forceClear4 = false;
HXDLIN( 251)						{
HXDLIN( 251)							int _g96 = rectTop4;
HXDLIN( 251)							int _g97 = yIter34->max;
HXDLIN( 251)							while((_g96 < _g97)){
HXDLIN( 251)								_g96 = (_g96 + 1);
HXDLIN( 251)								int dy7 = (_g96 - 1);
HXDLIN( 251)								{
HXDLIN( 251)									int _g98 = rectLeft4;
HXDLIN( 251)									int _g99 = rectRight4;
HXDLIN( 251)									while((_g98 < _g99)){
HXDLIN( 251)										_g98 = (_g98 + 1);
HXDLIN( 251)										int dx7 = (_g98 - 1);
HXDLIN( 251)										::Dynamic this128 = this1->image;
HXDLIN( 251)										int index16;
HXDLIN( 251)										if (this1->useVirtualPos) {
HXDLIN( 251)											index16 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx7) - this1->virtualX));
            										}
            										else {
HXDLIN( 251)											index16 = ::Std_obj::_hx_int(( (Float)(((dy7 * this1->width) + dx7)) ));
            										}
HXDLIN( 251)										int c12 = ::iterMagic::Iimg_obj::get(this128,index16);
HXDLIN( 251)										int col4;
HXDLIN( 251)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)											col4 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 251)											col4 = c12;
            										}
HXDLIN( 251)										bool hitQuad33;
HXDLIN( 251)										if (this1->useMask) {
HXDLIN( 251)											hitQuad33 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 251)											hitQuad33 = false;
            										}
HXDLIN( 251)										if (hitQuad33) {
HXDLIN( 251)											 ::pi_xy::ImageStruct this129 = this1->mask;
HXDLIN( 251)											::Dynamic this130 = this129->image;
HXDLIN( 251)											int index17;
HXDLIN( 251)											if (this129->useVirtualPos) {
HXDLIN( 251)												index17 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this129->virtualY) * ( (Float)(this129->width) )) + dx7) - this129->virtualX));
            											}
            											else {
HXDLIN( 251)												index17 = ::Std_obj::_hx_int(( (Float)(((dy7 * this129->width) + dx7)) ));
            											}
HXDLIN( 251)											int c13 = ::iterMagic::Iimg_obj::get(this130,index17);
HXDLIN( 251)											int v13;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												v13 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												v13 = c13;
            											}
HXDLIN( 251)											int maskPixel4 = v13;
HXDLIN( 251)											int this131 = col4;
HXDLIN( 251)											if ((maskPixel4 == 0)) {
HXDLIN( 251)												col4 = this131;
            											}
            											else {
HXDLIN( 251)												Float m04;
HXDLIN( 251)												int this132 = ((maskPixel4 >> 24) & 255);
HXDLIN( 251)												if ((this132 == 0)) {
HXDLIN( 251)													m04 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													m04 = (( (Float)(this132) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float m14;
HXDLIN( 251)												int this133 = ((maskPixel4 >> 16) & 255);
HXDLIN( 251)												if ((this133 == 0)) {
HXDLIN( 251)													m14 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													m14 = (( (Float)(this133) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float m24;
HXDLIN( 251)												int this134 = ((maskPixel4 >> 8) & 255);
HXDLIN( 251)												if ((this134 == 0)) {
HXDLIN( 251)													m24 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													m24 = (( (Float)(this134) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float m34;
HXDLIN( 251)												int this135 = (maskPixel4 & 255);
HXDLIN( 251)												if ((this135 == 0)) {
HXDLIN( 251)													m34 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													m34 = (( (Float)(this135) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this131 >> 24) & 255)) )));
HXDLIN( 251)												int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this131 >> 16) & 255)) )));
HXDLIN( 251)												int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this131 >> 8) & 255)) )));
HXDLIN( 251)												int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this131 & 255)) )));
HXDLIN( 251)												col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 251)										if ((col4 != 0)) {
HXDLIN( 251)											int x13 = (dx7 - rectLeft4);
HXDLIN( 251)											int y13 = (dy7 - rectTop4);
HXDLIN( 251)											int c14 = col4;
HXDLIN( 251)											bool hitQuad34;
HXDLIN( 251)											if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 251)												hitQuad34 = undoImage12->transparent;
            											}
            											else {
HXDLIN( 251)												hitQuad34 = false;
            											}
HXDLIN( 251)											if (hitQuad34) {
HXDLIN( 251)												int location8;
HXDLIN( 251)												if (undoImage12->useVirtualPos) {
HXDLIN( 251)													location8 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x13) - undoImage12->virtualX));
            												}
            												else {
HXDLIN( 251)													location8 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage12->width) + x13)) ));
            												}
HXDLIN( 251)												int this136 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 251)												int this137;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													this137 = ((((((this136 >> 24) & 255) << 24) | ((this136 & 255) << 16)) | (((this136 >> 8) & 255) << 8)) | ((this136 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													this137 = this136;
            												}
HXDLIN( 251)												Float a112;
HXDLIN( 251)												int this138 = ((this137 >> 24) & 255);
HXDLIN( 251)												if ((this138 == 0)) {
HXDLIN( 251)													a112 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a112 = (( (Float)(this138) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r110;
HXDLIN( 251)												int this139 = ((this137 >> 16) & 255);
HXDLIN( 251)												if ((this139 == 0)) {
HXDLIN( 251)													r110 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r110 = (( (Float)(this139) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g110;
HXDLIN( 251)												int this140 = ((this137 >> 8) & 255);
HXDLIN( 251)												if ((this140 == 0)) {
HXDLIN( 251)													g110 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g110 = (( (Float)(this140) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b113;
HXDLIN( 251)												int this141 = (this137 & 255);
HXDLIN( 251)												if ((this141 == 0)) {
HXDLIN( 251)													b113 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b113 = (( (Float)(this141) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a211;
HXDLIN( 251)												int this142 = ((col4 >> 24) & 255);
HXDLIN( 251)												if ((this142 == 0)) {
HXDLIN( 251)													a211 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a211 = (( (Float)(this142) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r28;
HXDLIN( 251)												int this143 = ((col4 >> 16) & 255);
HXDLIN( 251)												if ((this143 == 0)) {
HXDLIN( 251)													r28 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r28 = (( (Float)(this143) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g28;
HXDLIN( 251)												int this144 = ((col4 >> 8) & 255);
HXDLIN( 251)												if ((this144 == 0)) {
HXDLIN( 251)													g28 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g28 = (( (Float)(this144) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b212;
HXDLIN( 251)												int this145 = (col4 & 255);
HXDLIN( 251)												if ((this145 == 0)) {
HXDLIN( 251)													b212 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b212 = (( (Float)(this145) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a39 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 251)												int r29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a39) + (r28 * a211))));
HXDLIN( 251)												int g29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a39) + (g28 * a211))));
HXDLIN( 251)												int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a39) + (b212 * a211))));
HXDLIN( 251)												int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a211)));
HXDLIN( 251)												int blended8 = ((((a40 << 24) | (r29 << 16)) | (g29 << 8)) | b38);
HXDLIN( 251)												{
HXDLIN( 251)													int hitQuad35;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad35 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad35 = blended8;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(undoImage12->image,location8,hitQuad35);
            												}
            											}
            											else {
HXDLIN( 251)												::Dynamic this146 = undoImage12->image;
HXDLIN( 251)												int index18;
HXDLIN( 251)												if (undoImage12->useVirtualPos) {
HXDLIN( 251)													index18 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x13) - undoImage12->virtualX));
            												}
            												else {
HXDLIN( 251)													index18 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage12->width) + x13)) ));
            												}
HXDLIN( 251)												int hitQuad36;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													hitQuad36 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													hitQuad36 = c14;
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this146,index18,hitQuad36);
            											}
            										}
            										else {
HXDLIN( 251)											if (forceClear4) {
HXDLIN( 251)												::Dynamic this147 = undoImage12->image;
HXDLIN( 251)												int x14 = (dx7 - rectLeft4);
HXDLIN( 251)												int y14 = (dy7 - rectTop4);
HXDLIN( 251)												int index19;
HXDLIN( 251)												if (undoImage12->useVirtualPos) {
HXDLIN( 251)													index19 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x14) - undoImage12->virtualX));
            												}
            												else {
HXDLIN( 251)													index19 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage12->width) + x14)) ));
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this147,index19,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 251)				{
HXDLIN( 251)					int _g_min8 = xIter34->start;
HXDLIN( 251)					int _g_max8 = xIter34->max;
HXDLIN( 251)					while((_g_min8 < _g_max8)){
HXDLIN( 251)						_g_min8 = (_g_min8 + 1);
HXDLIN( 251)						int px5 = (_g_min8 - 1);
HXDLIN( 251)						Float pcx4 = (( (Float)(px5) ) - dx6);
HXDLIN( 251)						{
HXDLIN( 251)							int _g_min9 = yIter34->start;
HXDLIN( 251)							int _g_max9 = yIter34->max;
HXDLIN( 251)							while((_g_min9 < _g_max9)){
HXDLIN( 251)								_g_min9 = (_g_min9 + 1);
HXDLIN( 251)								int py5 = (_g_min9 - 1);
HXDLIN( 251)								Float pcy4 = (( (Float)(py5) ) - dy6);
HXDLIN( 251)								Float dot314 = ((pcx4 * bcx4) + (pcy4 * bcy4));
HXDLIN( 251)								Float dot324 = ((pcx4 * acx4) + (pcy4 * acy4));
HXDLIN( 251)								Float ratioA4 = (((dot224 * dot314) - (dot124 * dot324)) * denom14);
HXDLIN( 251)								Float ratioB4 = (((dot114 * dot324) - (dot124 * dot314)) * denom14);
HXDLIN( 251)								Float ratioC4 = ((((Float)1.0) - ratioB4) - ratioA4);
HXDLIN( 251)								bool hitQuad37;
HXDLIN( 251)								bool hitQuad38;
HXDLIN( 251)								if ((ratioA4 >= 0)) {
HXDLIN( 251)									hitQuad38 = (ratioB4 >= 0);
            								}
            								else {
HXDLIN( 251)									hitQuad38 = false;
            								}
HXDLIN( 251)								if (hitQuad38) {
HXDLIN( 251)									hitQuad37 = (ratioC4 >= 0);
            								}
            								else {
HXDLIN( 251)									hitQuad37 = false;
            								}
HXDLIN( 251)								if (hitQuad37) {
HXDLIN( 251)									int i46 = ::Std_obj::_hx_int((((( (Float)(aA4) ) * ratioA4) + (( (Float)(aB4) ) * ratioB4)) + (( (Float)(aC4) ) * ratioC4)));
HXDLIN( 251)									if ((i46 > 255)) {
HXLINE(  24)										i46 = 255;
            									}
HXLINE( 251)									if ((i46 < 0)) {
HXLINE(  25)										i46 = 0;
            									}
HXLINE( 251)									int a41 = i46;
HXDLIN( 251)									int i47 = ::Std_obj::_hx_int((((( (Float)(rA4) ) * ratioA4) + (( (Float)(rB4) ) * ratioB4)) + (( (Float)(rC4) ) * ratioC4)));
HXDLIN( 251)									if ((i47 > 255)) {
HXLINE(  24)										i47 = 255;
            									}
HXLINE( 251)									if ((i47 < 0)) {
HXLINE(  25)										i47 = 0;
            									}
HXLINE( 251)									int r30 = i47;
HXDLIN( 251)									int i48 = ::Std_obj::_hx_int((((( (Float)(gA4) ) * ratioA4) + (( (Float)(gB4) ) * ratioB4)) + (( (Float)(gC4) ) * ratioC4)));
HXDLIN( 251)									if ((i48 > 255)) {
HXLINE(  24)										i48 = 255;
            									}
HXLINE( 251)									if ((i48 < 0)) {
HXLINE(  25)										i48 = 0;
            									}
HXLINE( 251)									int g30 = i48;
HXDLIN( 251)									int i49 = ::Std_obj::_hx_int((((( (Float)(bA4) ) * ratioA4) + (( (Float)(bB4) ) * ratioB4)) + (( (Float)(bC4) ) * ratioC4)));
HXDLIN( 251)									if ((i49 > 255)) {
HXLINE(  24)										i49 = 255;
            									}
HXLINE( 251)									if ((i49 < 0)) {
HXLINE(  25)										i49 = 0;
            									}
HXLINE( 251)									int b39 = i49;
HXDLIN( 251)									{
HXDLIN( 251)										int location9;
HXDLIN( 251)										if (this1->useVirtualPos) {
HXDLIN( 251)											location9 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - this1->virtualY) * ( (Float)(this1->width) )) + px5) - this1->virtualX));
            										}
            										else {
HXDLIN( 251)											location9 = ::Std_obj::_hx_int(( (Float)(((py5 * this1->width) + px5)) ));
            										}
HXDLIN( 251)										bool hitQuad39;
HXDLIN( 251)										if (this1->transparent) {
HXDLIN( 251)											hitQuad39 = (a41 < 254);
            										}
            										else {
HXDLIN( 251)											hitQuad39 = false;
            										}
HXDLIN( 251)										if (hitQuad39) {
HXDLIN( 251)											int this148 = ::iterMagic::Iimg_obj::get(this1->image,location9);
HXDLIN( 251)											int old4;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												old4 = ((((((this148 >> 24) & 255) << 24) | ((this148 & 255) << 16)) | (((this148 >> 8) & 255) << 8)) | ((this148 >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												old4 = this148;
            											}
HXDLIN( 251)											int rhs4 = ((((a41 << 24) | (r30 << 16)) | (g30 << 8)) | b39);
HXDLIN( 251)											Float a113;
HXDLIN( 251)											int this149 = ((old4 >> 24) & 255);
HXDLIN( 251)											if ((this149 == 0)) {
HXDLIN( 251)												a113 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												a113 = (( (Float)(this149) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float r111;
HXDLIN( 251)											int this150 = ((old4 >> 16) & 255);
HXDLIN( 251)											if ((this150 == 0)) {
HXDLIN( 251)												r111 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												r111 = (( (Float)(this150) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float g111;
HXDLIN( 251)											int this151 = ((old4 >> 8) & 255);
HXDLIN( 251)											if ((this151 == 0)) {
HXDLIN( 251)												g111 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												g111 = (( (Float)(this151) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float b114;
HXDLIN( 251)											int this152 = (old4 & 255);
HXDLIN( 251)											if ((this152 == 0)) {
HXDLIN( 251)												b114 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												b114 = (( (Float)(this152) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float a212;
HXDLIN( 251)											int this153 = ((rhs4 >> 24) & 255);
HXDLIN( 251)											if ((this153 == 0)) {
HXDLIN( 251)												a212 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												a212 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float r210;
HXDLIN( 251)											int this154 = ((rhs4 >> 16) & 255);
HXDLIN( 251)											if ((this154 == 0)) {
HXDLIN( 251)												r210 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												r210 = (( (Float)(this154) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float g210;
HXDLIN( 251)											int this155 = ((rhs4 >> 8) & 255);
HXDLIN( 251)											if ((this155 == 0)) {
HXDLIN( 251)												g210 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												g210 = (( (Float)(this155) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float b213;
HXDLIN( 251)											int this156 = (rhs4 & 255);
HXDLIN( 251)											if ((this156 == 0)) {
HXDLIN( 251)												b213 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												b213 = (( (Float)(this156) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float a310 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 251)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a310) + (r210 * a212))));
HXDLIN( 251)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a310) + (g210 * a212))));
HXDLIN( 251)											int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b213 * a212))));
HXDLIN( 251)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a212)));
HXDLIN( 251)											int blended9 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b40);
HXDLIN( 251)											{
HXDLIN( 251)												int hitQuad40;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													hitQuad40 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													hitQuad40 = blended9;
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this1->image,location9,hitQuad40);
            											}
            										}
            										else {
HXDLIN( 251)											int value4;
HXDLIN( 251)											if (this1->isLittle) {
HXDLIN( 251)												value4 = ((((a41 << 24) | (b39 << 16)) | (g30 << 8)) | r30);
            											}
            											else {
HXDLIN( 251)												value4 = ((((a41 << 24) | (r30 << 16)) | (g30 << 8)) | b39);
            											}
HXDLIN( 251)											::iterMagic::Iimg_obj::set(this1->image,location9,value4);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 251)			{
HXDLIN( 251)				bool hasHit3 = false;
HXDLIN( 251)				bool hasUndo5 = false;
HXDLIN( 251)				int aA5 = ((color2 >> 24) & 255);
HXDLIN( 251)				int rA5 = ((color2 >> 16) & 255);
HXDLIN( 251)				int gA5 = ((color2 >> 8) & 255);
HXDLIN( 251)				int bA5 = (color2 & 255);
HXDLIN( 251)				int aB5 = ((color1 >> 24) & 255);
HXDLIN( 251)				int rB5 = ((color1 >> 16) & 255);
HXDLIN( 251)				int gB5 = ((color1 >> 8) & 255);
HXDLIN( 251)				int bB5 = (color1 & 255);
HXDLIN( 251)				int aC5 = ((color2 >> 24) & 255);
HXDLIN( 251)				int rC5 = ((color2 >> 16) & 255);
HXDLIN( 251)				int gC5 = ((color2 >> 8) & 255);
HXDLIN( 251)				int bC5 = (color2 & 255);
HXDLIN( 251)				Float bcx5 = (cx2 - dx6);
HXDLIN( 251)				Float bcy5 = (cy2 - dy6);
HXDLIN( 251)				Float acx5 = (bx2 - dx6);
HXDLIN( 251)				Float acy5 = (by2 - dy6);
HXDLIN( 251)				Float dot115 = ((bcx5 * bcx5) + (bcy5 * bcy5));
HXDLIN( 251)				Float dot125 = ((bcx5 * acx5) + (bcy5 * acy5));
HXDLIN( 251)				Float dot225 = ((acx5 * acx5) + (acy5 * acy5));
HXDLIN( 251)				Float denom15 = (( (Float)(1) ) / ((dot115 * dot225) - (dot125 * dot125)));
HXDLIN( 251)				 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 251)				if ((bx2 > cx2)) {
HXDLIN( 251)					if ((bx2 > dx6)) {
HXDLIN( 251)						int min20;
HXDLIN( 251)						if ((cx2 > dx6)) {
HXDLIN( 251)							min20 = ::Math_obj::floor(dx6);
            						}
            						else {
HXDLIN( 251)							min20 = ::Math_obj::floor(cx2);
            						}
HXDLIN( 251)						int ii_min40 = min20;
HXDLIN( 251)						int ii_max40 = ::Math_obj::ceil(bx2);
HXDLIN( 251)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            					}
            					else {
HXDLIN( 251)						int ii_min41 = ::Math_obj::floor(cx2);
HXDLIN( 251)						int ii_max41 = ::Math_obj::ceil(dx6);
HXDLIN( 251)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            					}
            				}
            				else {
HXDLIN( 251)					if ((cx2 > dx6)) {
HXDLIN( 251)						int min21;
HXDLIN( 251)						if ((bx2 > dx6)) {
HXDLIN( 251)							min21 = ::Math_obj::floor(dx6);
            						}
            						else {
HXDLIN( 251)							min21 = ::Math_obj::ceil(bx2);
            						}
HXDLIN( 251)						int ii_min42 = min21;
HXDLIN( 251)						int ii_max42 = ::Math_obj::ceil(cx2);
HXDLIN( 251)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            					}
            					else {
HXDLIN( 251)						int ii_min43 = ::Math_obj::floor(bx2);
HXDLIN( 251)						int ii_max43 = ::Math_obj::ceil(dx6);
HXDLIN( 251)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            					}
            				}
HXDLIN( 251)				 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 251)				if ((by2 > cy2)) {
HXDLIN( 251)					if ((by2 > dy6)) {
HXDLIN( 251)						int min22;
HXDLIN( 251)						if ((cy2 > dy6)) {
HXDLIN( 251)							min22 = ::Math_obj::floor(dy6);
            						}
            						else {
HXDLIN( 251)							min22 = ::Math_obj::floor(cy2);
            						}
HXDLIN( 251)						int ii_min44 = min22;
HXDLIN( 251)						int ii_max44 = ::Math_obj::ceil(by2);
HXDLIN( 251)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            					}
            					else {
HXDLIN( 251)						int ii_min45 = ::Math_obj::floor(cy2);
HXDLIN( 251)						int ii_max45 = ::Math_obj::ceil(dy6);
HXDLIN( 251)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            					}
            				}
            				else {
HXDLIN( 251)					if ((cy2 > dy6)) {
HXDLIN( 251)						int min23;
HXDLIN( 251)						if ((by2 > dy6)) {
HXDLIN( 251)							min23 = ::Math_obj::floor(dy6);
            						}
            						else {
HXDLIN( 251)							min23 = ::Math_obj::ceil(by2);
            						}
HXDLIN( 251)						int ii_min46 = min23;
HXDLIN( 251)						int ii_max46 = ::Math_obj::ceil(cy2);
HXDLIN( 251)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            					}
            					else {
HXDLIN( 251)						int ii_min47 = ::Math_obj::floor(by2);
HXDLIN( 251)						int ii_max47 = ::Math_obj::ceil(dy6);
HXDLIN( 251)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            					}
            				}
HXDLIN( 251)				 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 251)				if (hasUndo5) {
HXDLIN( 251)					int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 251)					int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 251)					 ::Dynamic imageType5 = null();
HXDLIN( 251)					 ::pi_xy::ImageStruct this157 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 251)					if (::hx::IsNull( imageType5 )) {
HXLINE(  54)						imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 251)					::Dynamic undoImage16;
HXDLIN( 251)					switch((int)(( (int)(imageType5) ))){
            						case (int)0: {
HXDLIN( 251)							 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::BytesImg b41 = byt5;
HXDLIN( 251)							{
HXDLIN( 251)								b41->width = width5;
HXDLIN( 251)								b41->height = height5;
HXDLIN( 251)								b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 251)								b41->data = ::haxe::io::Bytes_obj::alloc((b41->length * 4));
HXDLIN( 251)								{
HXDLIN( 251)									int len10 = b41->length;
HXDLIN( 251)									int w5 = 0;
HXDLIN( 251)									{
HXDLIN( 251)										int _g100 = 0;
HXDLIN( 251)										int _g101 = b41->height;
HXDLIN( 251)										while((_g100 < _g101)){
HXDLIN( 251)											_g100 = (_g100 + 1);
HXDLIN( 251)											int y15 = (_g100 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												int _g102 = 0;
HXDLIN( 251)												int _g103 = b41->width;
HXDLIN( 251)												while((_g102 < _g103)){
HXDLIN( 251)													_g102 = (_g102 + 1);
HXDLIN( 251)													int x15 = (_g102 - 1);
HXDLIN( 251)													{
HXDLIN( 251)														w5 = (w5 + 1);
HXDLIN( 251)														b41->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 251)													{
HXDLIN( 251)														w5 = (w5 + 1);
HXDLIN( 251)														b41->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 251)													{
HXDLIN( 251)														w5 = (w5 + 1);
HXDLIN( 251)														b41->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 251)													{
HXDLIN( 251)														w5 = (w5 + 1);
HXDLIN( 251)														b41->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 251)							undoImage16 = b41;
            						}
            						break;
            						case (int)1: {
HXDLIN( 251)							 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::ArrIntImg a43 = arrI5;
HXDLIN( 251)							{
HXDLIN( 251)								a43->width = width5;
HXDLIN( 251)								a43->height = height5;
HXDLIN( 251)								a43->data = ::Array_obj< int >::__new(0);
HXDLIN( 251)								a43->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 251)								{
HXDLIN( 251)									int _g104 = 0;
HXDLIN( 251)									int _g105 = a43->length;
HXDLIN( 251)									while((_g104 < _g105)){
HXDLIN( 251)										_g104 = (_g104 + 1);
HXDLIN( 251)										int i50 = (_g104 - 1);
HXDLIN( 251)										a43->data[i50] = 0;
            									}
            								}
            							}
HXDLIN( 251)							undoImage16 = a43;
            						}
            						break;
            						case (int)2: {
HXDLIN( 251)							 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::U32ArrImg b42 = u32a5;
HXDLIN( 251)							{
HXDLIN( 251)								b42->width = width5;
HXDLIN( 251)								b42->height = height5;
HXDLIN( 251)								b42->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 251)								int size5 = (b42->length * 4);
HXDLIN( 251)								b42->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 251)								{
HXDLIN( 251)									int _g106 = 0;
HXDLIN( 251)									int _g107 = b42->length;
HXDLIN( 251)									while((_g106 < _g107)){
HXDLIN( 251)										_g106 = (_g106 + 1);
HXDLIN( 251)										int i51 = (_g106 - 1);
HXDLIN( 251)										{
HXDLIN( 251)											 ::haxe::io::ArrayBufferViewImpl this158 = b42->data;
HXDLIN( 251)											bool undoImage17;
HXDLIN( 251)											if ((i51 >= 0)) {
HXDLIN( 251)												undoImage17 = (i51 < (this158->byteLength >> 2));
            											}
            											else {
HXDLIN( 251)												undoImage17 = false;
            											}
HXDLIN( 251)											if (undoImage17) {
HXDLIN( 251)												 ::haxe::io::Bytes _this5 = this158->bytes;
HXDLIN( 251)												int pos5 = ((i51 << 2) + this158->byteOffset);
HXDLIN( 251)												_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 251)												_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 251)												_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 251)												_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 251)							undoImage16 = b42;
            						}
            						break;
            						case (int)3: {
HXDLIN( 251)							 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::VecIntImg v14 = vec5;
HXDLIN( 251)							{
HXDLIN( 251)								v14->width = width5;
HXDLIN( 251)								v14->height = height5;
HXDLIN( 251)								v14->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 251)								v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN( 251)								{
HXDLIN( 251)									int _g108 = 0;
HXDLIN( 251)									int _g109 = v14->length;
HXDLIN( 251)									while((_g108 < _g109)){
HXDLIN( 251)										_g108 = (_g108 + 1);
HXDLIN( 251)										int i52 = (_g108 - 1);
HXDLIN( 251)										v14->data->__unsafe_set(i52,0);
            									}
            								}
            							}
HXDLIN( 251)							undoImage16 = v14;
            						}
            						break;
            						case (int)4: {
HXDLIN( 251)							 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)							 ::iterMagic::StackIntImg b43 = sInt5;
HXDLIN( 251)							{
HXDLIN( 251)								b43->width = width5;
HXDLIN( 251)								b43->height = height5;
HXDLIN( 251)								b43->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 251)								b43->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 251)								{
HXDLIN( 251)									int len11 = b43->length;
HXDLIN( 251)									 ::haxe::ds::GenericStack_Int d5 = b43->data;
HXDLIN( 251)									if (::hx::IsNull( d5->head )) {
HXDLIN( 251)										int _g110 = 0;
HXDLIN( 251)										int _g111 = len11;
HXDLIN( 251)										while((_g110 < _g111)){
HXDLIN( 251)											_g110 = (_g110 + 1);
HXDLIN( 251)											int i53 = (_g110 - 1);
HXDLIN( 251)											d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            										}
            									}
            									else {
HXDLIN( 251)										int _g112 = 0;
HXDLIN( 251)										int _g113 = len11;
HXDLIN( 251)										while((_g112 < _g113)){
HXDLIN( 251)											_g112 = (_g112 + 1);
HXDLIN( 251)											int i54 = (_g112 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												 ::haxe::ds::GenericCell_Int l5 = b43->data->head;
HXDLIN( 251)												 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 251)												{
HXDLIN( 251)													int _g114 = 0;
HXDLIN( 251)													int _g115 = i54;
HXDLIN( 251)													while((_g114 < _g115)){
HXDLIN( 251)														_g114 = (_g114 + 1);
HXDLIN( 251)														int i55 = (_g114 - 1);
HXLINE( 345)														prev5 = l5;
HXLINE( 346)														l5 = l5->next;
            													}
            												}
HXLINE( 251)												if (::hx::IsNull( prev5 )) {
HXDLIN( 251)													b43->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 251)													l5 = null();
            												}
            												else {
HXDLIN( 251)													prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 251)													l5 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 251)							undoImage16 = b43;
            						}
            						break;
            					}
HXDLIN( 251)					this157->image = undoImage16;
HXDLIN( 251)					this157->width = width5;
HXDLIN( 251)					this157->height = height5;
HXDLIN( 251)					this157->imageType = ( (int)(imageType5) );
HXDLIN( 251)					undoImage15 = this157;
HXDLIN( 251)					{
HXDLIN( 251)						int rectLeft5 = xIter35->start;
HXDLIN( 251)						int rectTop5 = yIter35->start;
HXDLIN( 251)						int rectRight5 = xIter35->max;
HXDLIN( 251)						bool forceClear5 = false;
HXDLIN( 251)						{
HXDLIN( 251)							int _g116 = rectTop5;
HXDLIN( 251)							int _g117 = yIter35->max;
HXDLIN( 251)							while((_g116 < _g117)){
HXDLIN( 251)								_g116 = (_g116 + 1);
HXDLIN( 251)								int dy8 = (_g116 - 1);
HXDLIN( 251)								{
HXDLIN( 251)									int _g118 = rectLeft5;
HXDLIN( 251)									int _g119 = rectRight5;
HXDLIN( 251)									while((_g118 < _g119)){
HXDLIN( 251)										_g118 = (_g118 + 1);
HXDLIN( 251)										int dx8 = (_g118 - 1);
HXDLIN( 251)										::Dynamic this159 = this1->image;
HXDLIN( 251)										int index20;
HXDLIN( 251)										if (this1->useVirtualPos) {
HXDLIN( 251)											index20 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx8) - this1->virtualX));
            										}
            										else {
HXDLIN( 251)											index20 = ::Std_obj::_hx_int(( (Float)(((dy8 * this1->width) + dx8)) ));
            										}
HXDLIN( 251)										int c15 = ::iterMagic::Iimg_obj::get(this159,index20);
HXDLIN( 251)										int col5;
HXDLIN( 251)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)											col5 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXDLIN( 251)											col5 = c15;
            										}
HXDLIN( 251)										bool hitQuad41;
HXDLIN( 251)										if (this1->useMask) {
HXDLIN( 251)											hitQuad41 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 251)											hitQuad41 = false;
            										}
HXDLIN( 251)										if (hitQuad41) {
HXDLIN( 251)											 ::pi_xy::ImageStruct this160 = this1->mask;
HXDLIN( 251)											::Dynamic this161 = this160->image;
HXDLIN( 251)											int index21;
HXDLIN( 251)											if (this160->useVirtualPos) {
HXDLIN( 251)												index21 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this160->virtualY) * ( (Float)(this160->width) )) + dx8) - this160->virtualX));
            											}
            											else {
HXDLIN( 251)												index21 = ::Std_obj::_hx_int(( (Float)(((dy8 * this160->width) + dx8)) ));
            											}
HXDLIN( 251)											int c16 = ::iterMagic::Iimg_obj::get(this161,index21);
HXDLIN( 251)											int v15;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												v15 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												v15 = c16;
            											}
HXDLIN( 251)											int maskPixel5 = v15;
HXDLIN( 251)											int this162 = col5;
HXDLIN( 251)											if ((maskPixel5 == 0)) {
HXDLIN( 251)												col5 = this162;
            											}
            											else {
HXDLIN( 251)												Float m05;
HXDLIN( 251)												int this163 = ((maskPixel5 >> 24) & 255);
HXDLIN( 251)												if ((this163 == 0)) {
HXDLIN( 251)													m05 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													m05 = (( (Float)(this163) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float m15;
HXDLIN( 251)												int this164 = ((maskPixel5 >> 16) & 255);
HXDLIN( 251)												if ((this164 == 0)) {
HXDLIN( 251)													m15 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													m15 = (( (Float)(this164) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float m25;
HXDLIN( 251)												int this165 = ((maskPixel5 >> 8) & 255);
HXDLIN( 251)												if ((this165 == 0)) {
HXDLIN( 251)													m25 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													m25 = (( (Float)(this165) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float m35;
HXDLIN( 251)												int this166 = (maskPixel5 & 255);
HXDLIN( 251)												if ((this166 == 0)) {
HXDLIN( 251)													m35 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													m35 = (( (Float)(this166) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this162 >> 24) & 255)) )));
HXDLIN( 251)												int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this162 >> 16) & 255)) )));
HXDLIN( 251)												int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this162 >> 8) & 255)) )));
HXDLIN( 251)												int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this162 & 255)) )));
HXDLIN( 251)												col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 251)										if ((col5 != 0)) {
HXDLIN( 251)											int x16 = (dx8 - rectLeft5);
HXDLIN( 251)											int y16 = (dy8 - rectTop5);
HXDLIN( 251)											int c17 = col5;
HXDLIN( 251)											bool hitQuad42;
HXDLIN( 251)											if ((((c17 >> 24) & 255) < 254)) {
HXDLIN( 251)												hitQuad42 = undoImage15->transparent;
            											}
            											else {
HXDLIN( 251)												hitQuad42 = false;
            											}
HXDLIN( 251)											if (hitQuad42) {
HXDLIN( 251)												int location10;
HXDLIN( 251)												if (undoImage15->useVirtualPos) {
HXDLIN( 251)													location10 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x16) - undoImage15->virtualX));
            												}
            												else {
HXDLIN( 251)													location10 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage15->width) + x16)) ));
            												}
HXDLIN( 251)												int this167 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 251)												int this168;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													this168 = ((((((this167 >> 24) & 255) << 24) | ((this167 & 255) << 16)) | (((this167 >> 8) & 255) << 8)) | ((this167 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													this168 = this167;
            												}
HXDLIN( 251)												Float a114;
HXDLIN( 251)												int this169 = ((this168 >> 24) & 255);
HXDLIN( 251)												if ((this169 == 0)) {
HXDLIN( 251)													a114 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a114 = (( (Float)(this169) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r112;
HXDLIN( 251)												int this170 = ((this168 >> 16) & 255);
HXDLIN( 251)												if ((this170 == 0)) {
HXDLIN( 251)													r112 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r112 = (( (Float)(this170) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g112;
HXDLIN( 251)												int this171 = ((this168 >> 8) & 255);
HXDLIN( 251)												if ((this171 == 0)) {
HXDLIN( 251)													g112 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g112 = (( (Float)(this171) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b115;
HXDLIN( 251)												int this172 = (this168 & 255);
HXDLIN( 251)												if ((this172 == 0)) {
HXDLIN( 251)													b115 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b115 = (( (Float)(this172) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a213;
HXDLIN( 251)												int this173 = ((col5 >> 24) & 255);
HXDLIN( 251)												if ((this173 == 0)) {
HXDLIN( 251)													a213 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													a213 = (( (Float)(this173) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float r211;
HXDLIN( 251)												int this174 = ((col5 >> 16) & 255);
HXDLIN( 251)												if ((this174 == 0)) {
HXDLIN( 251)													r211 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													r211 = (( (Float)(this174) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float g211;
HXDLIN( 251)												int this175 = ((col5 >> 8) & 255);
HXDLIN( 251)												if ((this175 == 0)) {
HXDLIN( 251)													g211 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													g211 = (( (Float)(this175) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float b214;
HXDLIN( 251)												int this176 = (col5 & 255);
HXDLIN( 251)												if ((this176 == 0)) {
HXDLIN( 251)													b214 = ((Float)0.);
            												}
            												else {
HXDLIN( 251)													b214 = (( (Float)(this176) ) / ( (Float)(255) ));
            												}
HXDLIN( 251)												Float a311 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 251)												int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a311) + (r211 * a213))));
HXDLIN( 251)												int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a311) + (g211 * a213))));
HXDLIN( 251)												int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b214 * a213))));
HXDLIN( 251)												int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a213)));
HXDLIN( 251)												int blended10 = ((((a44 << 24) | (r32 << 16)) | (g32 << 8)) | b44);
HXDLIN( 251)												{
HXDLIN( 251)													int hitQuad43;
HXDLIN( 251)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)														hitQuad43 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            													}
            													else {
HXDLIN( 251)														hitQuad43 = blended10;
            													}
HXDLIN( 251)													::iterMagic::Iimg_obj::set(undoImage15->image,location10,hitQuad43);
            												}
            											}
            											else {
HXDLIN( 251)												::Dynamic this177 = undoImage15->image;
HXDLIN( 251)												int index22;
HXDLIN( 251)												if (undoImage15->useVirtualPos) {
HXDLIN( 251)													index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x16) - undoImage15->virtualX));
            												}
            												else {
HXDLIN( 251)													index22 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage15->width) + x16)) ));
            												}
HXDLIN( 251)												int hitQuad44;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													hitQuad44 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													hitQuad44 = c17;
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this177,index22,hitQuad44);
            											}
            										}
            										else {
HXDLIN( 251)											if (forceClear5) {
HXDLIN( 251)												::Dynamic this178 = undoImage15->image;
HXDLIN( 251)												int x17 = (dx8 - rectLeft5);
HXDLIN( 251)												int y17 = (dy8 - rectTop5);
HXDLIN( 251)												int index23;
HXDLIN( 251)												if (undoImage15->useVirtualPos) {
HXDLIN( 251)													index23 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x17) - undoImage15->virtualX));
            												}
            												else {
HXDLIN( 251)													index23 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage15->width) + x17)) ));
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this178,index23,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 251)				{
HXDLIN( 251)					int _g_min10 = xIter35->start;
HXDLIN( 251)					int _g_max10 = xIter35->max;
HXDLIN( 251)					while((_g_min10 < _g_max10)){
HXDLIN( 251)						_g_min10 = (_g_min10 + 1);
HXDLIN( 251)						int px6 = (_g_min10 - 1);
HXDLIN( 251)						Float pcx5 = (( (Float)(px6) ) - dx6);
HXDLIN( 251)						{
HXDLIN( 251)							int _g_min11 = yIter35->start;
HXDLIN( 251)							int _g_max11 = yIter35->max;
HXDLIN( 251)							while((_g_min11 < _g_max11)){
HXDLIN( 251)								_g_min11 = (_g_min11 + 1);
HXDLIN( 251)								int py6 = (_g_min11 - 1);
HXDLIN( 251)								Float pcy5 = (( (Float)(py6) ) - dy6);
HXDLIN( 251)								Float dot315 = ((pcx5 * bcx5) + (pcy5 * bcy5));
HXDLIN( 251)								Float dot325 = ((pcx5 * acx5) + (pcy5 * acy5));
HXDLIN( 251)								Float ratioA5 = (((dot225 * dot315) - (dot125 * dot325)) * denom15);
HXDLIN( 251)								Float ratioB5 = (((dot115 * dot325) - (dot125 * dot315)) * denom15);
HXDLIN( 251)								Float ratioC5 = ((((Float)1.0) - ratioB5) - ratioA5);
HXDLIN( 251)								bool hitQuad45;
HXDLIN( 251)								bool hitQuad46;
HXDLIN( 251)								if ((ratioA5 >= 0)) {
HXDLIN( 251)									hitQuad46 = (ratioB5 >= 0);
            								}
            								else {
HXDLIN( 251)									hitQuad46 = false;
            								}
HXDLIN( 251)								if (hitQuad46) {
HXDLIN( 251)									hitQuad45 = (ratioC5 >= 0);
            								}
            								else {
HXDLIN( 251)									hitQuad45 = false;
            								}
HXDLIN( 251)								if (hitQuad45) {
HXDLIN( 251)									int i56 = ::Std_obj::_hx_int((((( (Float)(aA5) ) * ratioA5) + (( (Float)(aB5) ) * ratioB5)) + (( (Float)(aC5) ) * ratioC5)));
HXDLIN( 251)									if ((i56 > 255)) {
HXLINE(  24)										i56 = 255;
            									}
HXLINE( 251)									if ((i56 < 0)) {
HXLINE(  25)										i56 = 0;
            									}
HXLINE( 251)									int a45 = i56;
HXDLIN( 251)									int i57 = ::Std_obj::_hx_int((((( (Float)(rA5) ) * ratioA5) + (( (Float)(rB5) ) * ratioB5)) + (( (Float)(rC5) ) * ratioC5)));
HXDLIN( 251)									if ((i57 > 255)) {
HXLINE(  24)										i57 = 255;
            									}
HXLINE( 251)									if ((i57 < 0)) {
HXLINE(  25)										i57 = 0;
            									}
HXLINE( 251)									int r33 = i57;
HXDLIN( 251)									int i58 = ::Std_obj::_hx_int((((( (Float)(gA5) ) * ratioA5) + (( (Float)(gB5) ) * ratioB5)) + (( (Float)(gC5) ) * ratioC5)));
HXDLIN( 251)									if ((i58 > 255)) {
HXLINE(  24)										i58 = 255;
            									}
HXLINE( 251)									if ((i58 < 0)) {
HXLINE(  25)										i58 = 0;
            									}
HXLINE( 251)									int g33 = i58;
HXDLIN( 251)									int i59 = ::Std_obj::_hx_int((((( (Float)(bA5) ) * ratioA5) + (( (Float)(bB5) ) * ratioB5)) + (( (Float)(bC5) ) * ratioC5)));
HXDLIN( 251)									if ((i59 > 255)) {
HXLINE(  24)										i59 = 255;
            									}
HXLINE( 251)									if ((i59 < 0)) {
HXLINE(  25)										i59 = 0;
            									}
HXLINE( 251)									int b45 = i59;
HXDLIN( 251)									{
HXDLIN( 251)										int location11;
HXDLIN( 251)										if (this1->useVirtualPos) {
HXDLIN( 251)											location11 = ::Std_obj::_hx_int(((((( (Float)(py6) ) - this1->virtualY) * ( (Float)(this1->width) )) + px6) - this1->virtualX));
            										}
            										else {
HXDLIN( 251)											location11 = ::Std_obj::_hx_int(( (Float)(((py6 * this1->width) + px6)) ));
            										}
HXDLIN( 251)										bool hitQuad47;
HXDLIN( 251)										if (this1->transparent) {
HXDLIN( 251)											hitQuad47 = (a45 < 254);
            										}
            										else {
HXDLIN( 251)											hitQuad47 = false;
            										}
HXDLIN( 251)										if (hitQuad47) {
HXDLIN( 251)											int this179 = ::iterMagic::Iimg_obj::get(this1->image,location11);
HXDLIN( 251)											int old5;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												old5 = ((((((this179 >> 24) & 255) << 24) | ((this179 & 255) << 16)) | (((this179 >> 8) & 255) << 8)) | ((this179 >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												old5 = this179;
            											}
HXDLIN( 251)											int rhs5 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b45);
HXDLIN( 251)											Float a115;
HXDLIN( 251)											int this180 = ((old5 >> 24) & 255);
HXDLIN( 251)											if ((this180 == 0)) {
HXDLIN( 251)												a115 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												a115 = (( (Float)(this180) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float r113;
HXDLIN( 251)											int this181 = ((old5 >> 16) & 255);
HXDLIN( 251)											if ((this181 == 0)) {
HXDLIN( 251)												r113 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												r113 = (( (Float)(this181) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float g113;
HXDLIN( 251)											int this182 = ((old5 >> 8) & 255);
HXDLIN( 251)											if ((this182 == 0)) {
HXDLIN( 251)												g113 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												g113 = (( (Float)(this182) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float b116;
HXDLIN( 251)											int this183 = (old5 & 255);
HXDLIN( 251)											if ((this183 == 0)) {
HXDLIN( 251)												b116 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												b116 = (( (Float)(this183) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float a214;
HXDLIN( 251)											int this184 = ((rhs5 >> 24) & 255);
HXDLIN( 251)											if ((this184 == 0)) {
HXDLIN( 251)												a214 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												a214 = (( (Float)(this184) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float r212;
HXDLIN( 251)											int this185 = ((rhs5 >> 16) & 255);
HXDLIN( 251)											if ((this185 == 0)) {
HXDLIN( 251)												r212 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												r212 = (( (Float)(this185) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float g212;
HXDLIN( 251)											int this186 = ((rhs5 >> 8) & 255);
HXDLIN( 251)											if ((this186 == 0)) {
HXDLIN( 251)												g212 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												g212 = (( (Float)(this186) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float b215;
HXDLIN( 251)											int this187 = (rhs5 & 255);
HXDLIN( 251)											if ((this187 == 0)) {
HXDLIN( 251)												b215 = ((Float)0.);
            											}
            											else {
HXDLIN( 251)												b215 = (( (Float)(this187) ) / ( (Float)(255) ));
            											}
HXDLIN( 251)											Float a312 = (a115 * (( (Float)(1) ) - a214));
HXDLIN( 251)											int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a312) + (r212 * a214))));
HXDLIN( 251)											int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a312) + (g212 * a214))));
HXDLIN( 251)											int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b215 * a214))));
HXDLIN( 251)											int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a214)));
HXDLIN( 251)											int blended11 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b46);
HXDLIN( 251)											{
HXDLIN( 251)												int hitQuad48;
HXDLIN( 251)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)													hitQuad48 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXDLIN( 251)													hitQuad48 = blended11;
            												}
HXDLIN( 251)												::iterMagic::Iimg_obj::set(this1->image,location11,hitQuad48);
            											}
            										}
            										else {
HXDLIN( 251)											int value5;
HXDLIN( 251)											if (this1->isLittle) {
HXDLIN( 251)												value5 = ((((a45 << 24) | (b45 << 16)) | (g33 << 8)) | r33);
            											}
            											else {
HXDLIN( 251)												value5 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b45);
            											}
HXDLIN( 251)											::iterMagic::Iimg_obj::set(this1->image,location11,value5);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 251)				if ((hasHit3 == false)) {
HXDLIN( 251)					 ::pi_xy::algo::HitTri v16 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx2,by2,cx2,cy2,dx6,dy6,true);
HXDLIN( 251)					if (hasUndo5) {
HXDLIN( 251)						v16->undoImage = undoImage15;
HXDLIN( 251)						v16->undoX = xIter35->start;
HXDLIN( 251)						v16->undoY = yIter35->start;
            					}
            				}
            			}
HXDLIN( 251)			 ::pi_xy::algo::HitQuad v17 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax2,ay2,bx2,by2,cx2,cy2,dx6,dy6,true);
HXDLIN( 251)			hitQuad = v17;
            		}
HXDLIN( 251)		Float cx3 = h2;
HXDLIN( 251)		Float cy3 = radius2;
HXDLIN( 251)		Float bx3 = h2;
HXDLIN( 251)		Float by3 = -(radius2);
HXDLIN( 251)		Float temp3 = ((Float)0.);
HXLINE( 526)		temp3 = (px + ((bx3 * cos) - (by3 * sin)));
HXLINE( 527)		by3 = (py + ((by3 * cos) + (bx3 * sin)));
HXLINE( 528)		bx3 = temp3;
HXLINE( 529)		temp3 = (px + ((cx3 * cos) - (cy3 * sin)));
HXLINE( 530)		cy3 = (py + ((cy3 * cos) + (cx3 * sin)));
HXLINE( 531)		cx3 = temp3;
HXLINE( 251)		 ::pi_xy::pixel::_TwoGrad::TwoGrad_ twoColors =  ::pi_xy::pixel::_TwoGrad::TwoGrad__obj::__alloc( HX_CTX ,color1,color2);
HXDLIN( 251)		int a47 = twoColors->colorClock;
HXDLIN( 251)		int b47 = twoColors->colorAnti;
HXDLIN( 251)		int half = ((((::Math_obj::round(((((( (Float)(((a47 >> 24) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b47 >> 24) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 24) | (::Math_obj::round(((((( (Float)(((a47 >> 16) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b47 >> 16) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 16)) | (::Math_obj::round(((((( (Float)(((a47 >> 8) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b47 >> 8) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 8)) | ::Math_obj::round(((((( (Float)((a47 & 255)) ) / ( (Float)(255) )) + (( (Float)((b47 & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))));
HXDLIN( 251)		bool hasUndo6 = false;
HXDLIN( 251)		int aA6 = ((color1 >> 24) & 255);
HXDLIN( 251)		int rA6 = ((color1 >> 16) & 255);
HXDLIN( 251)		int gA6 = ((color1 >> 8) & 255);
HXDLIN( 251)		int bA6 = (color1 & 255);
HXDLIN( 251)		int aB6 = ((half >> 24) & 255);
HXDLIN( 251)		int rB6 = ((half >> 16) & 255);
HXDLIN( 251)		int gB6 = ((half >> 8) & 255);
HXDLIN( 251)		int bB6 = (half & 255);
HXDLIN( 251)		int aC6 = ((color2 >> 24) & 255);
HXDLIN( 251)		int rC6 = ((color2 >> 16) & 255);
HXDLIN( 251)		int gC6 = ((color2 >> 8) & 255);
HXDLIN( 251)		int bC6 = (color2 & 255);
HXDLIN( 251)		Float bcx6 = (bx3 - cx3);
HXDLIN( 251)		Float bcy6 = (by3 - cy3);
HXDLIN( 251)		Float acx6 = (qx - cx3);
HXDLIN( 251)		Float acy6 = (qy - cy3);
HXDLIN( 251)		Float dot116 = ((bcx6 * bcx6) + (bcy6 * bcy6));
HXDLIN( 251)		Float dot126 = ((bcx6 * acx6) + (bcy6 * acy6));
HXDLIN( 251)		Float dot226 = ((acx6 * acx6) + (acy6 * acy6));
HXDLIN( 251)		Float denom16 = (( (Float)(1) ) / ((dot116 * dot226) - (dot126 * dot126)));
HXDLIN( 251)		 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 251)		if ((qx > bx3)) {
HXDLIN( 251)			if ((qx > cx3)) {
HXDLIN( 251)				int min24;
HXDLIN( 251)				if ((bx3 > cx3)) {
HXDLIN( 251)					min24 = ::Math_obj::floor(cx3);
            				}
            				else {
HXDLIN( 251)					min24 = ::Math_obj::floor(bx3);
            				}
HXDLIN( 251)				int ii_min48 = min24;
HXDLIN( 251)				int ii_max48 = ::Math_obj::ceil(qx);
HXDLIN( 251)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            			}
            			else {
HXDLIN( 251)				int ii_min49 = ::Math_obj::floor(bx3);
HXDLIN( 251)				int ii_max49 = ::Math_obj::ceil(cx3);
HXDLIN( 251)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            			}
            		}
            		else {
HXDLIN( 251)			if ((bx3 > cx3)) {
HXDLIN( 251)				int min25;
HXDLIN( 251)				if ((qx > cx3)) {
HXDLIN( 251)					min25 = ::Math_obj::floor(cx3);
            				}
            				else {
HXDLIN( 251)					min25 = ::Math_obj::ceil(qx);
            				}
HXDLIN( 251)				int ii_min50 = min25;
HXDLIN( 251)				int ii_max50 = ::Math_obj::ceil(bx3);
HXDLIN( 251)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            			}
            			else {
HXDLIN( 251)				int ii_min51 = ::Math_obj::floor(qx);
HXDLIN( 251)				int ii_max51 = ::Math_obj::ceil(cx3);
HXDLIN( 251)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            			}
            		}
HXDLIN( 251)		 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 251)		if ((qy > by3)) {
HXDLIN( 251)			if ((qy > cy3)) {
HXDLIN( 251)				int min26;
HXDLIN( 251)				if ((by3 > cy3)) {
HXDLIN( 251)					min26 = ::Math_obj::floor(cy3);
            				}
            				else {
HXDLIN( 251)					min26 = ::Math_obj::floor(by3);
            				}
HXDLIN( 251)				int ii_min52 = min26;
HXDLIN( 251)				int ii_max52 = ::Math_obj::ceil(qy);
HXDLIN( 251)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            			}
            			else {
HXDLIN( 251)				int ii_min53 = ::Math_obj::floor(by3);
HXDLIN( 251)				int ii_max53 = ::Math_obj::ceil(cy3);
HXDLIN( 251)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            			}
            		}
            		else {
HXDLIN( 251)			if ((by3 > cy3)) {
HXDLIN( 251)				int min27;
HXDLIN( 251)				if ((qy > cy3)) {
HXDLIN( 251)					min27 = ::Math_obj::floor(cy3);
            				}
            				else {
HXDLIN( 251)					min27 = ::Math_obj::ceil(qy);
            				}
HXDLIN( 251)				int ii_min54 = min27;
HXDLIN( 251)				int ii_max54 = ::Math_obj::ceil(by3);
HXDLIN( 251)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            			}
            			else {
HXDLIN( 251)				int ii_min55 = ::Math_obj::floor(qy);
HXDLIN( 251)				int ii_max55 = ::Math_obj::ceil(cy3);
HXDLIN( 251)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            			}
            		}
HXDLIN( 251)		 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 251)		if (hasUndo6) {
HXDLIN( 251)			int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 251)			int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 251)			 ::Dynamic imageType6 = null();
HXDLIN( 251)			 ::pi_xy::ImageStruct this188 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 251)			if (::hx::IsNull( imageType6 )) {
HXLINE(  54)				imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 251)			::Dynamic undoImage19;
HXDLIN( 251)			switch((int)(( (int)(imageType6) ))){
            				case (int)0: {
HXDLIN( 251)					 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 251)					 ::iterMagic::BytesImg b48 = byt6;
HXDLIN( 251)					{
HXDLIN( 251)						b48->width = width6;
HXDLIN( 251)						b48->height = height6;
HXDLIN( 251)						b48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 251)						b48->data = ::haxe::io::Bytes_obj::alloc((b48->length * 4));
HXDLIN( 251)						{
HXDLIN( 251)							int len12 = b48->length;
HXDLIN( 251)							int w6 = 0;
HXDLIN( 251)							{
HXDLIN( 251)								int _g120 = 0;
HXDLIN( 251)								int _g121 = b48->height;
HXDLIN( 251)								while((_g120 < _g121)){
HXDLIN( 251)									_g120 = (_g120 + 1);
HXDLIN( 251)									int y18 = (_g120 - 1);
HXDLIN( 251)									{
HXDLIN( 251)										int _g122 = 0;
HXDLIN( 251)										int _g123 = b48->width;
HXDLIN( 251)										while((_g122 < _g123)){
HXDLIN( 251)											_g122 = (_g122 + 1);
HXDLIN( 251)											int x18 = (_g122 - 1);
HXDLIN( 251)											{
HXDLIN( 251)												w6 = (w6 + 1);
HXDLIN( 251)												b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 251)											{
HXDLIN( 251)												w6 = (w6 + 1);
HXDLIN( 251)												b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 251)											{
HXDLIN( 251)												w6 = (w6 + 1);
HXDLIN( 251)												b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 251)											{
HXDLIN( 251)												w6 = (w6 + 1);
HXDLIN( 251)												b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					undoImage19 = b48;
            				}
            				break;
            				case (int)1: {
HXDLIN( 251)					 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)					 ::iterMagic::ArrIntImg a48 = arrI6;
HXDLIN( 251)					{
HXDLIN( 251)						a48->width = width6;
HXDLIN( 251)						a48->height = height6;
HXDLIN( 251)						a48->data = ::Array_obj< int >::__new(0);
HXDLIN( 251)						a48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 251)						{
HXDLIN( 251)							int _g124 = 0;
HXDLIN( 251)							int _g125 = a48->length;
HXDLIN( 251)							while((_g124 < _g125)){
HXDLIN( 251)								_g124 = (_g124 + 1);
HXDLIN( 251)								int i60 = (_g124 - 1);
HXDLIN( 251)								a48->data[i60] = 0;
            							}
            						}
            					}
HXDLIN( 251)					undoImage19 = a48;
            				}
            				break;
            				case (int)2: {
HXDLIN( 251)					 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 251)					 ::iterMagic::U32ArrImg b49 = u32a6;
HXDLIN( 251)					{
HXDLIN( 251)						b49->width = width6;
HXDLIN( 251)						b49->height = height6;
HXDLIN( 251)						b49->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 251)						int size6 = (b49->length * 4);
HXDLIN( 251)						b49->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 251)						{
HXDLIN( 251)							int _g126 = 0;
HXDLIN( 251)							int _g127 = b49->length;
HXDLIN( 251)							while((_g126 < _g127)){
HXDLIN( 251)								_g126 = (_g126 + 1);
HXDLIN( 251)								int i61 = (_g126 - 1);
HXDLIN( 251)								{
HXDLIN( 251)									 ::haxe::io::ArrayBufferViewImpl this189 = b49->data;
HXDLIN( 251)									bool undoImage20;
HXDLIN( 251)									if ((i61 >= 0)) {
HXDLIN( 251)										undoImage20 = (i61 < (this189->byteLength >> 2));
            									}
            									else {
HXDLIN( 251)										undoImage20 = false;
            									}
HXDLIN( 251)									if (undoImage20) {
HXDLIN( 251)										 ::haxe::io::Bytes _this6 = this189->bytes;
HXDLIN( 251)										int pos6 = ((i61 << 2) + this189->byteOffset);
HXDLIN( 251)										_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 251)										_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 251)										_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 251)										_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					undoImage19 = b49;
            				}
            				break;
            				case (int)3: {
HXDLIN( 251)					 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)					 ::iterMagic::VecIntImg v18 = vec6;
HXDLIN( 251)					{
HXDLIN( 251)						v18->width = width6;
HXDLIN( 251)						v18->height = height6;
HXDLIN( 251)						v18->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 251)						v18->data = ::Array_obj< int >::__new(v18->length);
HXDLIN( 251)						{
HXDLIN( 251)							int _g128 = 0;
HXDLIN( 251)							int _g129 = v18->length;
HXDLIN( 251)							while((_g128 < _g129)){
HXDLIN( 251)								_g128 = (_g128 + 1);
HXDLIN( 251)								int i62 = (_g128 - 1);
HXDLIN( 251)								v18->data->__unsafe_set(i62,0);
            							}
            						}
            					}
HXDLIN( 251)					undoImage19 = v18;
            				}
            				break;
            				case (int)4: {
HXDLIN( 251)					 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 251)					 ::iterMagic::StackIntImg b50 = sInt6;
HXDLIN( 251)					{
HXDLIN( 251)						b50->width = width6;
HXDLIN( 251)						b50->height = height6;
HXDLIN( 251)						b50->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 251)						b50->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 251)						{
HXDLIN( 251)							int len13 = b50->length;
HXDLIN( 251)							 ::haxe::ds::GenericStack_Int d6 = b50->data;
HXDLIN( 251)							if (::hx::IsNull( d6->head )) {
HXDLIN( 251)								int _g130 = 0;
HXDLIN( 251)								int _g131 = len13;
HXDLIN( 251)								while((_g130 < _g131)){
HXDLIN( 251)									_g130 = (_g130 + 1);
HXDLIN( 251)									int i63 = (_g130 - 1);
HXDLIN( 251)									d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            								}
            							}
            							else {
HXDLIN( 251)								int _g132 = 0;
HXDLIN( 251)								int _g133 = len13;
HXDLIN( 251)								while((_g132 < _g133)){
HXDLIN( 251)									_g132 = (_g132 + 1);
HXDLIN( 251)									int i64 = (_g132 - 1);
HXDLIN( 251)									{
HXDLIN( 251)										 ::haxe::ds::GenericCell_Int l6 = b50->data->head;
HXDLIN( 251)										 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 251)										{
HXDLIN( 251)											int _g134 = 0;
HXDLIN( 251)											int _g135 = i64;
HXDLIN( 251)											while((_g134 < _g135)){
HXDLIN( 251)												_g134 = (_g134 + 1);
HXDLIN( 251)												int i65 = (_g134 - 1);
HXLINE( 345)												prev6 = l6;
HXLINE( 346)												l6 = l6->next;
            											}
            										}
HXLINE( 251)										if (::hx::IsNull( prev6 )) {
HXDLIN( 251)											b50->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 251)											l6 = null();
            										}
            										else {
HXDLIN( 251)											prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 251)											l6 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 251)					undoImage19 = b50;
            				}
            				break;
            			}
HXDLIN( 251)			this188->image = undoImage19;
HXDLIN( 251)			this188->width = width6;
HXDLIN( 251)			this188->height = height6;
HXDLIN( 251)			this188->imageType = ( (int)(imageType6) );
HXDLIN( 251)			undoImage18 = this188;
HXDLIN( 251)			{
HXDLIN( 251)				int rectLeft6 = xIter36->start;
HXDLIN( 251)				int rectTop6 = yIter36->start;
HXDLIN( 251)				int rectRight6 = xIter36->max;
HXDLIN( 251)				bool forceClear6 = false;
HXDLIN( 251)				{
HXDLIN( 251)					int _g136 = rectTop6;
HXDLIN( 251)					int _g137 = yIter36->max;
HXDLIN( 251)					while((_g136 < _g137)){
HXDLIN( 251)						_g136 = (_g136 + 1);
HXDLIN( 251)						int dy9 = (_g136 - 1);
HXDLIN( 251)						{
HXDLIN( 251)							int _g138 = rectLeft6;
HXDLIN( 251)							int _g139 = rectRight6;
HXDLIN( 251)							while((_g138 < _g139)){
HXDLIN( 251)								_g138 = (_g138 + 1);
HXDLIN( 251)								int dx9 = (_g138 - 1);
HXDLIN( 251)								::Dynamic this190 = this1->image;
HXDLIN( 251)								int index24;
HXDLIN( 251)								if (this1->useVirtualPos) {
HXDLIN( 251)									index24 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx9) - this1->virtualX));
            								}
            								else {
HXDLIN( 251)									index24 = ::Std_obj::_hx_int(( (Float)(((dy9 * this1->width) + dx9)) ));
            								}
HXDLIN( 251)								int c18 = ::iterMagic::Iimg_obj::get(this190,index24);
HXDLIN( 251)								int col6;
HXDLIN( 251)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)									col6 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            								}
            								else {
HXDLIN( 251)									col6 = c18;
            								}
HXDLIN( 251)								bool _hx_tmp;
HXDLIN( 251)								if (this1->useMask) {
HXDLIN( 251)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 251)									_hx_tmp = false;
            								}
HXDLIN( 251)								if (_hx_tmp) {
HXDLIN( 251)									 ::pi_xy::ImageStruct this191 = this1->mask;
HXDLIN( 251)									::Dynamic this192 = this191->image;
HXDLIN( 251)									int index25;
HXDLIN( 251)									if (this191->useVirtualPos) {
HXDLIN( 251)										index25 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this191->virtualY) * ( (Float)(this191->width) )) + dx9) - this191->virtualX));
            									}
            									else {
HXDLIN( 251)										index25 = ::Std_obj::_hx_int(( (Float)(((dy9 * this191->width) + dx9)) ));
            									}
HXDLIN( 251)									int c19 = ::iterMagic::Iimg_obj::get(this192,index25);
HXDLIN( 251)									int v19;
HXDLIN( 251)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)										v19 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            									}
            									else {
HXDLIN( 251)										v19 = c19;
            									}
HXDLIN( 251)									int maskPixel6 = v19;
HXDLIN( 251)									int this193 = col6;
HXDLIN( 251)									if ((maskPixel6 == 0)) {
HXDLIN( 251)										col6 = this193;
            									}
            									else {
HXDLIN( 251)										Float m06;
HXDLIN( 251)										int this194 = ((maskPixel6 >> 24) & 255);
HXDLIN( 251)										if ((this194 == 0)) {
HXDLIN( 251)											m06 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											m06 = (( (Float)(this194) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float m16;
HXDLIN( 251)										int this195 = ((maskPixel6 >> 16) & 255);
HXDLIN( 251)										if ((this195 == 0)) {
HXDLIN( 251)											m16 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											m16 = (( (Float)(this195) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float m26;
HXDLIN( 251)										int this196 = ((maskPixel6 >> 8) & 255);
HXDLIN( 251)										if ((this196 == 0)) {
HXDLIN( 251)											m26 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											m26 = (( (Float)(this196) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float m36;
HXDLIN( 251)										int this197 = (maskPixel6 & 255);
HXDLIN( 251)										if ((this197 == 0)) {
HXDLIN( 251)											m36 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											m36 = (( (Float)(this197) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this193 >> 24) & 255)) )));
HXDLIN( 251)										int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this193 >> 16) & 255)) )));
HXDLIN( 251)										int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this193 >> 8) & 255)) )));
HXDLIN( 251)										int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this193 & 255)) )));
HXDLIN( 251)										col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 251)								if ((col6 != 0)) {
HXDLIN( 251)									int x19 = (dx9 - rectLeft6);
HXDLIN( 251)									int y19 = (dy9 - rectTop6);
HXDLIN( 251)									int c20 = col6;
HXDLIN( 251)									bool _hx_tmp1;
HXDLIN( 251)									if ((((c20 >> 24) & 255) < 254)) {
HXDLIN( 251)										_hx_tmp1 = undoImage18->transparent;
            									}
            									else {
HXDLIN( 251)										_hx_tmp1 = false;
            									}
HXDLIN( 251)									if (_hx_tmp1) {
HXDLIN( 251)										int location12;
HXDLIN( 251)										if (undoImage18->useVirtualPos) {
HXDLIN( 251)											location12 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x19) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 251)											location12 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage18->width) + x19)) ));
            										}
HXDLIN( 251)										int this198 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 251)										int this199;
HXDLIN( 251)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)											this199 = ((((((this198 >> 24) & 255) << 24) | ((this198 & 255) << 16)) | (((this198 >> 8) & 255) << 8)) | ((this198 >> 16) & 255));
            										}
            										else {
HXDLIN( 251)											this199 = this198;
            										}
HXDLIN( 251)										Float a116;
HXDLIN( 251)										int this200 = ((this199 >> 24) & 255);
HXDLIN( 251)										if ((this200 == 0)) {
HXDLIN( 251)											a116 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											a116 = (( (Float)(this200) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float r114;
HXDLIN( 251)										int this201 = ((this199 >> 16) & 255);
HXDLIN( 251)										if ((this201 == 0)) {
HXDLIN( 251)											r114 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											r114 = (( (Float)(this201) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float g114;
HXDLIN( 251)										int this202 = ((this199 >> 8) & 255);
HXDLIN( 251)										if ((this202 == 0)) {
HXDLIN( 251)											g114 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											g114 = (( (Float)(this202) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float b117;
HXDLIN( 251)										int this203 = (this199 & 255);
HXDLIN( 251)										if ((this203 == 0)) {
HXDLIN( 251)											b117 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											b117 = (( (Float)(this203) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float a215;
HXDLIN( 251)										int this204 = ((col6 >> 24) & 255);
HXDLIN( 251)										if ((this204 == 0)) {
HXDLIN( 251)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											a215 = (( (Float)(this204) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float r213;
HXDLIN( 251)										int this205 = ((col6 >> 16) & 255);
HXDLIN( 251)										if ((this205 == 0)) {
HXDLIN( 251)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											r213 = (( (Float)(this205) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float g213;
HXDLIN( 251)										int this206 = ((col6 >> 8) & 255);
HXDLIN( 251)										if ((this206 == 0)) {
HXDLIN( 251)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											g213 = (( (Float)(this206) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float b216;
HXDLIN( 251)										int this207 = (col6 & 255);
HXDLIN( 251)										if ((this207 == 0)) {
HXDLIN( 251)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 251)											b216 = (( (Float)(this207) ) / ( (Float)(255) ));
            										}
HXDLIN( 251)										Float a313 = (a116 * (( (Float)(1) ) - a215));
HXDLIN( 251)										int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a313) + (r213 * a215))));
HXDLIN( 251)										int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a313) + (g213 * a215))));
HXDLIN( 251)										int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b216 * a215))));
HXDLIN( 251)										int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a215)));
HXDLIN( 251)										int blended12 = ((((a49 << 24) | (r35 << 16)) | (g35 << 8)) | b51);
HXDLIN( 251)										{
HXDLIN( 251)											int _hx_tmp2;
HXDLIN( 251)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)												_hx_tmp2 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 251)												_hx_tmp2 = blended12;
            											}
HXDLIN( 251)											::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 251)										::Dynamic this208 = undoImage18->image;
HXDLIN( 251)										int index26;
HXDLIN( 251)										if (undoImage18->useVirtualPos) {
HXDLIN( 251)											index26 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x19) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 251)											index26 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage18->width) + x19)) ));
            										}
HXDLIN( 251)										int _hx_tmp3;
HXDLIN( 251)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)											_hx_tmp3 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            										}
            										else {
HXDLIN( 251)											_hx_tmp3 = c20;
            										}
HXDLIN( 251)										::iterMagic::Iimg_obj::set(this208,index26,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 251)									if (forceClear6) {
HXDLIN( 251)										::Dynamic this209 = undoImage18->image;
HXDLIN( 251)										int x20 = (dx9 - rectLeft6);
HXDLIN( 251)										int y20 = (dy9 - rectTop6);
HXDLIN( 251)										int index27;
HXDLIN( 251)										if (undoImage18->useVirtualPos) {
HXDLIN( 251)											index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x20) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 251)											index27 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage18->width) + x20)) ));
            										}
HXDLIN( 251)										::iterMagic::Iimg_obj::set(this209,index27,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 251)		{
HXDLIN( 251)			int _g_min12 = xIter36->start;
HXDLIN( 251)			int _g_max12 = xIter36->max;
HXDLIN( 251)			while((_g_min12 < _g_max12)){
HXDLIN( 251)				_g_min12 = (_g_min12 + 1);
HXDLIN( 251)				int px7 = (_g_min12 - 1);
HXDLIN( 251)				Float pcx6 = (( (Float)(px7) ) - cx3);
HXDLIN( 251)				{
HXDLIN( 251)					int _g_min13 = yIter36->start;
HXDLIN( 251)					int _g_max13 = yIter36->max;
HXDLIN( 251)					while((_g_min13 < _g_max13)){
HXDLIN( 251)						_g_min13 = (_g_min13 + 1);
HXDLIN( 251)						int py7 = (_g_min13 - 1);
HXDLIN( 251)						Float pcy6 = (( (Float)(py7) ) - cy3);
HXDLIN( 251)						Float dot316 = ((pcx6 * bcx6) + (pcy6 * bcy6));
HXDLIN( 251)						Float dot326 = ((pcx6 * acx6) + (pcy6 * acy6));
HXDLIN( 251)						Float ratioA6 = (((dot226 * dot316) - (dot126 * dot326)) * denom16);
HXDLIN( 251)						Float ratioB6 = (((dot116 * dot326) - (dot126 * dot316)) * denom16);
HXDLIN( 251)						Float ratioC6 = ((((Float)1.0) - ratioB6) - ratioA6);
HXDLIN( 251)						bool _hx_tmp4;
HXDLIN( 251)						bool _hx_tmp5;
HXDLIN( 251)						if ((ratioA6 >= 0)) {
HXDLIN( 251)							_hx_tmp5 = (ratioB6 >= 0);
            						}
            						else {
HXDLIN( 251)							_hx_tmp5 = false;
            						}
HXDLIN( 251)						if (_hx_tmp5) {
HXDLIN( 251)							_hx_tmp4 = (ratioC6 >= 0);
            						}
            						else {
HXDLIN( 251)							_hx_tmp4 = false;
            						}
HXDLIN( 251)						if (_hx_tmp4) {
HXDLIN( 251)							int i66 = ::Std_obj::_hx_int((((( (Float)(aA6) ) * ratioA6) + (( (Float)(aB6) ) * ratioB6)) + (( (Float)(aC6) ) * ratioC6)));
HXDLIN( 251)							if ((i66 > 255)) {
HXLINE(  24)								i66 = 255;
            							}
HXLINE( 251)							if ((i66 < 0)) {
HXLINE(  25)								i66 = 0;
            							}
HXLINE( 251)							int a50 = i66;
HXDLIN( 251)							int i67 = ::Std_obj::_hx_int((((( (Float)(rA6) ) * ratioA6) + (( (Float)(rB6) ) * ratioB6)) + (( (Float)(rC6) ) * ratioC6)));
HXDLIN( 251)							if ((i67 > 255)) {
HXLINE(  24)								i67 = 255;
            							}
HXLINE( 251)							if ((i67 < 0)) {
HXLINE(  25)								i67 = 0;
            							}
HXLINE( 251)							int r36 = i67;
HXDLIN( 251)							int i68 = ::Std_obj::_hx_int((((( (Float)(gA6) ) * ratioA6) + (( (Float)(gB6) ) * ratioB6)) + (( (Float)(gC6) ) * ratioC6)));
HXDLIN( 251)							if ((i68 > 255)) {
HXLINE(  24)								i68 = 255;
            							}
HXLINE( 251)							if ((i68 < 0)) {
HXLINE(  25)								i68 = 0;
            							}
HXLINE( 251)							int g36 = i68;
HXDLIN( 251)							int i69 = ::Std_obj::_hx_int((((( (Float)(bA6) ) * ratioA6) + (( (Float)(bB6) ) * ratioB6)) + (( (Float)(bC6) ) * ratioC6)));
HXDLIN( 251)							if ((i69 > 255)) {
HXLINE(  24)								i69 = 255;
            							}
HXLINE( 251)							if ((i69 < 0)) {
HXLINE(  25)								i69 = 0;
            							}
HXLINE( 251)							int b52 = i69;
HXDLIN( 251)							{
HXDLIN( 251)								int location13;
HXDLIN( 251)								if (this1->useVirtualPos) {
HXDLIN( 251)									location13 = ::Std_obj::_hx_int(((((( (Float)(py7) ) - this1->virtualY) * ( (Float)(this1->width) )) + px7) - this1->virtualX));
            								}
            								else {
HXDLIN( 251)									location13 = ::Std_obj::_hx_int(( (Float)(((py7 * this1->width) + px7)) ));
            								}
HXDLIN( 251)								bool _hx_tmp6;
HXDLIN( 251)								if (this1->transparent) {
HXDLIN( 251)									_hx_tmp6 = (a50 < 254);
            								}
            								else {
HXDLIN( 251)									_hx_tmp6 = false;
            								}
HXDLIN( 251)								if (_hx_tmp6) {
HXDLIN( 251)									int this210 = ::iterMagic::Iimg_obj::get(this1->image,location13);
HXDLIN( 251)									int old6;
HXDLIN( 251)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)										old6 = ((((((this210 >> 24) & 255) << 24) | ((this210 & 255) << 16)) | (((this210 >> 8) & 255) << 8)) | ((this210 >> 16) & 255));
            									}
            									else {
HXDLIN( 251)										old6 = this210;
            									}
HXDLIN( 251)									int rhs6 = ((((a50 << 24) | (r36 << 16)) | (g36 << 8)) | b52);
HXDLIN( 251)									Float a117;
HXDLIN( 251)									int this211 = ((old6 >> 24) & 255);
HXDLIN( 251)									if ((this211 == 0)) {
HXDLIN( 251)										a117 = ((Float)0.);
            									}
            									else {
HXDLIN( 251)										a117 = (( (Float)(this211) ) / ( (Float)(255) ));
            									}
HXDLIN( 251)									Float r115;
HXDLIN( 251)									int this212 = ((old6 >> 16) & 255);
HXDLIN( 251)									if ((this212 == 0)) {
HXDLIN( 251)										r115 = ((Float)0.);
            									}
            									else {
HXDLIN( 251)										r115 = (( (Float)(this212) ) / ( (Float)(255) ));
            									}
HXDLIN( 251)									Float g115;
HXDLIN( 251)									int this213 = ((old6 >> 8) & 255);
HXDLIN( 251)									if ((this213 == 0)) {
HXDLIN( 251)										g115 = ((Float)0.);
            									}
            									else {
HXDLIN( 251)										g115 = (( (Float)(this213) ) / ( (Float)(255) ));
            									}
HXDLIN( 251)									Float b118;
HXDLIN( 251)									int this214 = (old6 & 255);
HXDLIN( 251)									if ((this214 == 0)) {
HXDLIN( 251)										b118 = ((Float)0.);
            									}
            									else {
HXDLIN( 251)										b118 = (( (Float)(this214) ) / ( (Float)(255) ));
            									}
HXDLIN( 251)									Float a216;
HXDLIN( 251)									int this215 = ((rhs6 >> 24) & 255);
HXDLIN( 251)									if ((this215 == 0)) {
HXDLIN( 251)										a216 = ((Float)0.);
            									}
            									else {
HXDLIN( 251)										a216 = (( (Float)(this215) ) / ( (Float)(255) ));
            									}
HXDLIN( 251)									Float r214;
HXDLIN( 251)									int this216 = ((rhs6 >> 16) & 255);
HXDLIN( 251)									if ((this216 == 0)) {
HXDLIN( 251)										r214 = ((Float)0.);
            									}
            									else {
HXDLIN( 251)										r214 = (( (Float)(this216) ) / ( (Float)(255) ));
            									}
HXDLIN( 251)									Float g214;
HXDLIN( 251)									int this217 = ((rhs6 >> 8) & 255);
HXDLIN( 251)									if ((this217 == 0)) {
HXDLIN( 251)										g214 = ((Float)0.);
            									}
            									else {
HXDLIN( 251)										g214 = (( (Float)(this217) ) / ( (Float)(255) ));
            									}
HXDLIN( 251)									Float b217;
HXDLIN( 251)									int this218 = (rhs6 & 255);
HXDLIN( 251)									if ((this218 == 0)) {
HXDLIN( 251)										b217 = ((Float)0.);
            									}
            									else {
HXDLIN( 251)										b217 = (( (Float)(this218) ) / ( (Float)(255) ));
            									}
HXDLIN( 251)									Float a314 = (a117 * (( (Float)(1) ) - a216));
HXDLIN( 251)									int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a314) + (r214 * a216))));
HXDLIN( 251)									int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a314) + (g214 * a216))));
HXDLIN( 251)									int b53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b217 * a216))));
HXDLIN( 251)									int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a216)));
HXDLIN( 251)									int blended13 = ((((a51 << 24) | (r37 << 16)) | (g37 << 8)) | b53);
HXDLIN( 251)									{
HXDLIN( 251)										int _hx_tmp7;
HXDLIN( 251)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 251)											_hx_tmp7 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            										}
            										else {
HXDLIN( 251)											_hx_tmp7 = blended13;
            										}
HXDLIN( 251)										::iterMagic::Iimg_obj::set(this1->image,location13,_hx_tmp7);
            									}
            								}
            								else {
HXDLIN( 251)									int value6;
HXDLIN( 251)									if (this1->isLittle) {
HXDLIN( 251)										value6 = ((((a50 << 24) | (b52 << 16)) | (g36 << 8)) | r36);
            									}
            									else {
HXDLIN( 251)										value6 = ((((a50 << 24) | (r36 << 16)) | (g36 << 8)) | b52);
            									}
HXDLIN( 251)									::iterMagic::Iimg_obj::set(this1->image,location13,value6);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 251)		 ::pi_xy::algo::HitTri hitTri;
HXDLIN( 251)		if ((hasHit == false)) {
HXDLIN( 251)			 ::pi_xy::algo::HitTri v20 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx3,by3,cx3,cy3,true);
HXDLIN( 251)			if (hasUndo6) {
HXDLIN( 251)				v20->undoImage = undoImage18;
HXDLIN( 251)				v20->undoX = xIter36->start;
HXDLIN( 251)				v20->undoY = yIter36->start;
            			}
HXDLIN( 251)			hitTri = v20;
            		}
            		else {
HXDLIN( 251)			hitTri = null();
            		}
HXDLIN( 251)		if (hasHit) {
HXDLIN( 251)			 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN( 251)			if (::hx::IsNotNull( hitQuad )) {
HXDLIN( 251)				hitArr->triArr->push(hitQuad->triABD);
            			}
HXDLIN( 251)			hitArr->triArr->push(hitQuad->triBCD);
HXDLIN( 251)			return hitArr;
            		}
            		else {
HXDLIN( 251)			return null();
            		}
HXDLIN( 251)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC13(GradientShape_Impl__obj,thickFixArrow,return )

 ::pi_xy::algo::HitTriArray GradientShape_Impl__obj::thickFixArrowBoth( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float arrowWidth,Float arrowHeight,Float thick,int color1,int color2,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_268_thickFixArrowBoth)
HXDLIN( 268)		Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 268)		Float o = (qy - py);
HXDLIN( 268)		Float a = (qx - px);
HXDLIN( 268)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 268)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 268)		Float thicker;
HXDLIN( 268)		if ((arrowWidth > (thick * ((Float)1.1)))) {
HXDLIN( 268)			thicker = arrowWidth;
            		}
            		else {
HXDLIN( 268)			thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            		}
HXDLIN( 268)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 268)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 268)		Float radius = (thick / ( (Float)(2) ));
HXDLIN( 268)		Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 268)		Float h2;
HXDLIN( 268)		if ((arrowHeight < (h * ((Float)1.1)))) {
HXDLIN( 268)			h2 = (h - arrowHeight);
            		}
            		else {
HXDLIN( 268)			h2 = (h / goldenRatio);
            		}
HXDLIN( 268)		Float hSmall = (h - h2);
HXDLIN( 268)		Float px_ = hSmall;
HXDLIN( 268)		Float py_ = ((Float)0.);
HXDLIN( 268)		Float temp = ((Float)0.);
HXLINE( 729)		temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 730)		py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 731)		px_ = temp;
HXLINE( 268)		Float h1 = (h2 - hSmall);
HXDLIN( 268)		Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 268)		Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 268)		Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 268)		Float dx = ((Float)0.1);
HXDLIN( 268)		Float dy = radius1;
HXDLIN( 268)		Float cx = h1;
HXDLIN( 268)		Float cy = radius1;
HXDLIN( 268)		Float bx = h1;
HXDLIN( 268)		Float by = -(radius1);
HXDLIN( 268)		Float ax = ((Float)0.1);
HXDLIN( 268)		Float ay = -(radius1);
HXDLIN( 268)		Float temp1 = ((Float)0.);
HXLINE( 474)		temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE( 475)		ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE( 476)		ax = temp1;
HXLINE( 478)		temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE( 479)		by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE( 480)		bx = temp1;
HXLINE( 482)		temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE( 483)		cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE( 484)		cx = temp1;
HXLINE( 486)		temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE( 487)		dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE( 488)		dx = temp1;
HXLINE( 268)		{
HXDLIN( 268)			bool hasUndo = false;
HXDLIN( 268)			int aA = ((color1 >> 24) & 255);
HXDLIN( 268)			int rA = ((color1 >> 16) & 255);
HXDLIN( 268)			int gA = ((color1 >> 8) & 255);
HXDLIN( 268)			int bA = (color1 & 255);
HXDLIN( 268)			int aB = ((color1 >> 24) & 255);
HXDLIN( 268)			int rB = ((color1 >> 16) & 255);
HXDLIN( 268)			int gB = ((color1 >> 8) & 255);
HXDLIN( 268)			int bB = (color1 & 255);
HXDLIN( 268)			int aC = ((color2 >> 24) & 255);
HXDLIN( 268)			int rC = ((color2 >> 16) & 255);
HXDLIN( 268)			int gC = ((color2 >> 8) & 255);
HXDLIN( 268)			int bC = (color2 & 255);
HXDLIN( 268)			Float bcx = (bx - dx);
HXDLIN( 268)			Float bcy = (by - dy);
HXDLIN( 268)			Float acx = (ax - dx);
HXDLIN( 268)			Float acy = (ay - dy);
HXDLIN( 268)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 268)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 268)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 268)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 268)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 268)			if ((ax > bx)) {
HXDLIN( 268)				if ((ax > dx)) {
HXDLIN( 268)					int min;
HXDLIN( 268)					if ((bx > dx)) {
HXDLIN( 268)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN( 268)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 268)					int ii_min = min;
HXDLIN( 268)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 268)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXDLIN( 268)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 268)					int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 268)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXDLIN( 268)				if ((bx > dx)) {
HXDLIN( 268)					int min1;
HXDLIN( 268)					if ((ax > dx)) {
HXDLIN( 268)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN( 268)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 268)					int ii_min2 = min1;
HXDLIN( 268)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 268)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXDLIN( 268)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 268)					int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 268)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN( 268)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 268)			if ((ay > by)) {
HXDLIN( 268)				if ((ay > dy)) {
HXDLIN( 268)					int min2;
HXDLIN( 268)					if ((by > dy)) {
HXDLIN( 268)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN( 268)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 268)					int ii_min4 = min2;
HXDLIN( 268)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 268)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXDLIN( 268)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 268)					int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 268)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXDLIN( 268)				if ((by > dy)) {
HXDLIN( 268)					int min3;
HXDLIN( 268)					if ((ay > dy)) {
HXDLIN( 268)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN( 268)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 268)					int ii_min6 = min3;
HXDLIN( 268)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 268)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXDLIN( 268)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 268)					int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 268)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN( 268)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 268)			if (hasUndo) {
HXDLIN( 268)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 268)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 268)				 ::Dynamic imageType = null();
HXDLIN( 268)				 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 268)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 268)				::Dynamic undoImage1;
HXDLIN( 268)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXDLIN( 268)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 268)						{
HXDLIN( 268)							b->width = width;
HXDLIN( 268)							b->height = height;
HXDLIN( 268)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 268)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 268)							{
HXDLIN( 268)								int len = b->length;
HXDLIN( 268)								int w = 0;
HXDLIN( 268)								{
HXDLIN( 268)									int _g = 0;
HXDLIN( 268)									int _g1 = b->height;
HXDLIN( 268)									while((_g < _g1)){
HXDLIN( 268)										_g = (_g + 1);
HXDLIN( 268)										int y = (_g - 1);
HXDLIN( 268)										{
HXDLIN( 268)											int _g2 = 0;
HXDLIN( 268)											int _g3 = b->width;
HXDLIN( 268)											while((_g2 < _g3)){
HXDLIN( 268)												_g2 = (_g2 + 1);
HXDLIN( 268)												int x = (_g2 - 1);
HXDLIN( 268)												{
HXDLIN( 268)													w = (w + 1);
HXDLIN( 268)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 268)												{
HXDLIN( 268)													w = (w + 1);
HXDLIN( 268)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 268)												{
HXDLIN( 268)													w = (w + 1);
HXDLIN( 268)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 268)												{
HXDLIN( 268)													w = (w + 1);
HXDLIN( 268)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 268)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXDLIN( 268)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 268)						{
HXDLIN( 268)							a1->width = width;
HXDLIN( 268)							a1->height = height;
HXDLIN( 268)							a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 268)							a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 268)							{
HXDLIN( 268)								int _g4 = 0;
HXDLIN( 268)								int _g5 = a1->length;
HXDLIN( 268)								while((_g4 < _g5)){
HXDLIN( 268)									_g4 = (_g4 + 1);
HXDLIN( 268)									int i = (_g4 - 1);
HXDLIN( 268)									a1->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 268)						undoImage1 = a1;
            					}
            					break;
            					case (int)2: {
HXDLIN( 268)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 268)						{
HXDLIN( 268)							b1->width = width;
HXDLIN( 268)							b1->height = height;
HXDLIN( 268)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 268)							int size = (b1->length * 4);
HXDLIN( 268)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 268)							{
HXDLIN( 268)								int _g6 = 0;
HXDLIN( 268)								int _g7 = b1->length;
HXDLIN( 268)								while((_g6 < _g7)){
HXDLIN( 268)									_g6 = (_g6 + 1);
HXDLIN( 268)									int i1 = (_g6 - 1);
HXDLIN( 268)									{
HXDLIN( 268)										 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 268)										bool undoImage2;
HXDLIN( 268)										if ((i1 >= 0)) {
HXDLIN( 268)											undoImage2 = (i1 < (this3->byteLength >> 2));
            										}
            										else {
HXDLIN( 268)											undoImage2 = false;
            										}
HXDLIN( 268)										if (undoImage2) {
HXDLIN( 268)											 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 268)											int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 268)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 268)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 268)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 268)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 268)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXDLIN( 268)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 268)						{
HXDLIN( 268)							v->width = width;
HXDLIN( 268)							v->height = height;
HXDLIN( 268)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 268)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 268)							{
HXDLIN( 268)								int _g8 = 0;
HXDLIN( 268)								int _g9 = v->length;
HXDLIN( 268)								while((_g8 < _g9)){
HXDLIN( 268)									_g8 = (_g8 + 1);
HXDLIN( 268)									int i2 = (_g8 - 1);
HXDLIN( 268)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 268)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXDLIN( 268)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 268)						{
HXDLIN( 268)							b2->width = width;
HXDLIN( 268)							b2->height = height;
HXDLIN( 268)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 268)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 268)							{
HXDLIN( 268)								int len1 = b2->length;
HXDLIN( 268)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 268)								if (::hx::IsNull( d->head )) {
HXDLIN( 268)									int _g10 = 0;
HXDLIN( 268)									int _g11 = len1;
HXDLIN( 268)									while((_g10 < _g11)){
HXDLIN( 268)										_g10 = (_g10 + 1);
HXDLIN( 268)										int i3 = (_g10 - 1);
HXDLIN( 268)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXDLIN( 268)									int _g12 = 0;
HXDLIN( 268)									int _g13 = len1;
HXDLIN( 268)									while((_g12 < _g13)){
HXDLIN( 268)										_g12 = (_g12 + 1);
HXDLIN( 268)										int i4 = (_g12 - 1);
HXDLIN( 268)										{
HXDLIN( 268)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 268)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 268)											{
HXDLIN( 268)												int _g14 = 0;
HXDLIN( 268)												int _g15 = i4;
HXDLIN( 268)												while((_g14 < _g15)){
HXDLIN( 268)													_g14 = (_g14 + 1);
HXDLIN( 268)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 268)											if (::hx::IsNull( prev )) {
HXDLIN( 268)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 268)												l = null();
            											}
            											else {
HXDLIN( 268)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 268)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 268)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 268)				this2->image = undoImage1;
HXDLIN( 268)				this2->width = width;
HXDLIN( 268)				this2->height = height;
HXDLIN( 268)				this2->imageType = ( (int)(imageType) );
HXDLIN( 268)				undoImage = this2;
HXDLIN( 268)				{
HXDLIN( 268)					int rectLeft = xIter3->start;
HXDLIN( 268)					int rectTop = yIter3->start;
HXDLIN( 268)					int rectRight = xIter3->max;
HXDLIN( 268)					bool forceClear = false;
HXDLIN( 268)					{
HXDLIN( 268)						int _g16 = rectTop;
HXDLIN( 268)						int _g17 = yIter3->max;
HXDLIN( 268)						while((_g16 < _g17)){
HXDLIN( 268)							_g16 = (_g16 + 1);
HXDLIN( 268)							int dy1 = (_g16 - 1);
HXDLIN( 268)							{
HXDLIN( 268)								int _g18 = rectLeft;
HXDLIN( 268)								int _g19 = rectRight;
HXDLIN( 268)								while((_g18 < _g19)){
HXDLIN( 268)									_g18 = (_g18 + 1);
HXDLIN( 268)									int dx1 = (_g18 - 1);
HXDLIN( 268)									::Dynamic this4 = this1->image;
HXDLIN( 268)									int index;
HXDLIN( 268)									if (this1->useVirtualPos) {
HXDLIN( 268)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            									}
            									else {
HXDLIN( 268)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            									}
HXDLIN( 268)									int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 268)									int col;
HXDLIN( 268)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXDLIN( 268)										col = c;
            									}
HXDLIN( 268)									bool _hx_tmp;
HXDLIN( 268)									if (this1->useMask) {
HXDLIN( 268)										_hx_tmp = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN( 268)										_hx_tmp = false;
            									}
HXDLIN( 268)									if (_hx_tmp) {
HXDLIN( 268)										 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 268)										::Dynamic this6 = this5->image;
HXDLIN( 268)										int index1;
HXDLIN( 268)										if (this5->useVirtualPos) {
HXDLIN( 268)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            										}
            										else {
HXDLIN( 268)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            										}
HXDLIN( 268)										int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 268)										int v1;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											v1 = c1;
            										}
HXDLIN( 268)										int maskPixel = v1;
HXDLIN( 268)										int this7 = col;
HXDLIN( 268)										if ((maskPixel == 0)) {
HXDLIN( 268)											col = this7;
            										}
            										else {
HXDLIN( 268)											Float m0;
HXDLIN( 268)											int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 268)											if ((this8 == 0)) {
HXDLIN( 268)												m0 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float m1;
HXDLIN( 268)											int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 268)											if ((this9 == 0)) {
HXDLIN( 268)												m1 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float m2;
HXDLIN( 268)											int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 268)											if ((this10 == 0)) {
HXDLIN( 268)												m2 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float m3;
HXDLIN( 268)											int this11 = (maskPixel & 255);
HXDLIN( 268)											if ((this11 == 0)) {
HXDLIN( 268)												m3 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 268)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 268)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 268)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 268)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 268)									if ((col != 0)) {
HXDLIN( 268)										int x1 = (dx1 - rectLeft);
HXDLIN( 268)										int y1 = (dy1 - rectTop);
HXDLIN( 268)										int c2 = col;
HXDLIN( 268)										bool _hx_tmp1;
HXDLIN( 268)										if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 268)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXDLIN( 268)											_hx_tmp1 = false;
            										}
HXDLIN( 268)										if (_hx_tmp1) {
HXDLIN( 268)											int location;
HXDLIN( 268)											if (undoImage->useVirtualPos) {
HXDLIN( 268)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXDLIN( 268)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 268)											int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 268)											int this13;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)												this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            											}
            											else {
HXDLIN( 268)												this13 = this12;
            											}
HXDLIN( 268)											Float a11;
HXDLIN( 268)											int this14 = ((this13 >> 24) & 255);
HXDLIN( 268)											if ((this14 == 0)) {
HXDLIN( 268)												a11 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float r1;
HXDLIN( 268)											int this15 = ((this13 >> 16) & 255);
HXDLIN( 268)											if ((this15 == 0)) {
HXDLIN( 268)												r1 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float g1;
HXDLIN( 268)											int this16 = ((this13 >> 8) & 255);
HXDLIN( 268)											if ((this16 == 0)) {
HXDLIN( 268)												g1 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float b11;
HXDLIN( 268)											int this17 = (this13 & 255);
HXDLIN( 268)											if ((this17 == 0)) {
HXDLIN( 268)												b11 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float a2;
HXDLIN( 268)											int this18 = ((col >> 24) & 255);
HXDLIN( 268)											if ((this18 == 0)) {
HXDLIN( 268)												a2 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float r2;
HXDLIN( 268)											int this19 = ((col >> 16) & 255);
HXDLIN( 268)											if ((this19 == 0)) {
HXDLIN( 268)												r2 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float g2;
HXDLIN( 268)											int this20 = ((col >> 8) & 255);
HXDLIN( 268)											if ((this20 == 0)) {
HXDLIN( 268)												g2 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float b21;
HXDLIN( 268)											int this21 = (col & 255);
HXDLIN( 268)											if ((this21 == 0)) {
HXDLIN( 268)												b21 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 268)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 268)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 268)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 268)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 268)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 268)											{
HXDLIN( 268)												int _hx_tmp2;
HXDLIN( 268)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXDLIN( 268)													_hx_tmp2 = blended;
            												}
HXDLIN( 268)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXDLIN( 268)											::Dynamic this22 = undoImage->image;
HXDLIN( 268)											int index2;
HXDLIN( 268)											if (undoImage->useVirtualPos) {
HXDLIN( 268)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXDLIN( 268)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 268)											int _hx_tmp3;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXDLIN( 268)												_hx_tmp3 = c2;
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            										}
            									}
            									else {
HXDLIN( 268)										if (forceClear) {
HXDLIN( 268)											::Dynamic this23 = undoImage->image;
HXDLIN( 268)											int x2 = (dx1 - rectLeft);
HXDLIN( 268)											int y2 = (dy1 - rectTop);
HXDLIN( 268)											int index3;
HXDLIN( 268)											if (undoImage->useVirtualPos) {
HXDLIN( 268)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXDLIN( 268)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(this23,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 268)			{
HXDLIN( 268)				int _g_min = xIter3->start;
HXDLIN( 268)				int _g_max = xIter3->max;
HXDLIN( 268)				while((_g_min < _g_max)){
HXDLIN( 268)					_g_min = (_g_min + 1);
HXDLIN( 268)					int px1 = (_g_min - 1);
HXDLIN( 268)					Float pcx = (( (Float)(px1) ) - dx);
HXDLIN( 268)					{
HXDLIN( 268)						int _g_min1 = yIter3->start;
HXDLIN( 268)						int _g_max1 = yIter3->max;
HXDLIN( 268)						while((_g_min1 < _g_max1)){
HXDLIN( 268)							_g_min1 = (_g_min1 + 1);
HXDLIN( 268)							int py1 = (_g_min1 - 1);
HXDLIN( 268)							Float pcy = (( (Float)(py1) ) - dy);
HXDLIN( 268)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 268)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 268)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 268)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 268)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 268)							bool _hx_tmp4;
HXDLIN( 268)							bool _hx_tmp5;
HXDLIN( 268)							if ((ratioA >= 0)) {
HXDLIN( 268)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXDLIN( 268)								_hx_tmp5 = false;
            							}
HXDLIN( 268)							if (_hx_tmp5) {
HXDLIN( 268)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXDLIN( 268)								_hx_tmp4 = false;
            							}
HXDLIN( 268)							if (_hx_tmp4) {
HXDLIN( 268)								int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 268)								if ((i6 > 255)) {
HXLINE(  24)									i6 = 255;
            								}
HXLINE( 268)								if ((i6 < 0)) {
HXLINE(  25)									i6 = 0;
            								}
HXLINE( 268)								int a5 = i6;
HXDLIN( 268)								int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 268)								if ((i7 > 255)) {
HXLINE(  24)									i7 = 255;
            								}
HXLINE( 268)								if ((i7 < 0)) {
HXLINE(  25)									i7 = 0;
            								}
HXLINE( 268)								int r3 = i7;
HXDLIN( 268)								int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 268)								if ((i8 > 255)) {
HXLINE(  24)									i8 = 255;
            								}
HXLINE( 268)								if ((i8 < 0)) {
HXLINE(  25)									i8 = 0;
            								}
HXLINE( 268)								int g3 = i8;
HXDLIN( 268)								int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 268)								if ((i9 > 255)) {
HXLINE(  24)									i9 = 255;
            								}
HXLINE( 268)								if ((i9 < 0)) {
HXLINE(  25)									i9 = 0;
            								}
HXLINE( 268)								int b4 = i9;
HXDLIN( 268)								{
HXDLIN( 268)									int location1;
HXDLIN( 268)									if (this1->useVirtualPos) {
HXDLIN( 268)										location1 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this1->virtualY) * ( (Float)(this1->width) )) + px1) - this1->virtualX));
            									}
            									else {
HXDLIN( 268)										location1 = ::Std_obj::_hx_int(( (Float)(((py1 * this1->width) + px1)) ));
            									}
HXDLIN( 268)									bool _hx_tmp6;
HXDLIN( 268)									if (this1->transparent) {
HXDLIN( 268)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXDLIN( 268)										_hx_tmp6 = false;
            									}
HXDLIN( 268)									if (_hx_tmp6) {
HXDLIN( 268)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 268)										int old;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											old = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											old = this24;
            										}
HXDLIN( 268)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 268)										Float a12;
HXDLIN( 268)										int this25 = ((old >> 24) & 255);
HXDLIN( 268)										if ((this25 == 0)) {
HXDLIN( 268)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											a12 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float r11;
HXDLIN( 268)										int this26 = ((old >> 16) & 255);
HXDLIN( 268)										if ((this26 == 0)) {
HXDLIN( 268)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float g11;
HXDLIN( 268)										int this27 = ((old >> 8) & 255);
HXDLIN( 268)										if ((this27 == 0)) {
HXDLIN( 268)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float b12;
HXDLIN( 268)										int this28 = (old & 255);
HXDLIN( 268)										if ((this28 == 0)) {
HXDLIN( 268)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float a21;
HXDLIN( 268)										int this29 = ((rhs >> 24) & 255);
HXDLIN( 268)										if ((this29 == 0)) {
HXDLIN( 268)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float r21;
HXDLIN( 268)										int this30 = ((rhs >> 16) & 255);
HXDLIN( 268)										if ((this30 == 0)) {
HXDLIN( 268)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float g21;
HXDLIN( 268)										int this31 = ((rhs >> 8) & 255);
HXDLIN( 268)										if ((this31 == 0)) {
HXDLIN( 268)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float b22;
HXDLIN( 268)										int this32 = (rhs & 255);
HXDLIN( 268)										if ((this32 == 0)) {
HXDLIN( 268)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 268)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 268)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 268)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 268)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 268)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 268)										{
HXDLIN( 268)											int _hx_tmp7;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 268)												_hx_tmp7 = blended1;
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXDLIN( 268)										int value;
HXDLIN( 268)										if (this1->isLittle) {
HXDLIN( 268)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXDLIN( 268)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN( 268)										::iterMagic::Iimg_obj::set(this1->image,location1,value);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 268)		{
HXDLIN( 268)			bool hasHit1 = false;
HXDLIN( 268)			bool hasUndo1 = false;
HXDLIN( 268)			int aA1 = ((color2 >> 24) & 255);
HXDLIN( 268)			int rA1 = ((color2 >> 16) & 255);
HXDLIN( 268)			int gA1 = ((color2 >> 8) & 255);
HXDLIN( 268)			int bA1 = (color2 & 255);
HXDLIN( 268)			int aB1 = ((color1 >> 24) & 255);
HXDLIN( 268)			int rB1 = ((color1 >> 16) & 255);
HXDLIN( 268)			int gB1 = ((color1 >> 8) & 255);
HXDLIN( 268)			int bB1 = (color1 & 255);
HXDLIN( 268)			int aC1 = ((color2 >> 24) & 255);
HXDLIN( 268)			int rC1 = ((color2 >> 16) & 255);
HXDLIN( 268)			int gC1 = ((color2 >> 8) & 255);
HXDLIN( 268)			int bC1 = (color2 & 255);
HXDLIN( 268)			Float bcx1 = (cx - dx);
HXDLIN( 268)			Float bcy1 = (cy - dy);
HXDLIN( 268)			Float acx1 = (bx - dx);
HXDLIN( 268)			Float acy1 = (by - dy);
HXDLIN( 268)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 268)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 268)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 268)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 268)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 268)			if ((bx > cx)) {
HXDLIN( 268)				if ((bx > dx)) {
HXDLIN( 268)					int min4;
HXDLIN( 268)					if ((cx > dx)) {
HXDLIN( 268)						min4 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN( 268)						min4 = ::Math_obj::floor(cx);
            					}
HXDLIN( 268)					int ii_min8 = min4;
HXDLIN( 268)					int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 268)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXDLIN( 268)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 268)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 268)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXDLIN( 268)				if ((cx > dx)) {
HXDLIN( 268)					int min5;
HXDLIN( 268)					if ((bx > dx)) {
HXDLIN( 268)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN( 268)						min5 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 268)					int ii_min10 = min5;
HXDLIN( 268)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 268)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXDLIN( 268)					int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 268)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 268)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 268)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 268)			if ((by > cy)) {
HXDLIN( 268)				if ((by > dy)) {
HXDLIN( 268)					int min6;
HXDLIN( 268)					if ((cy > dy)) {
HXDLIN( 268)						min6 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN( 268)						min6 = ::Math_obj::floor(cy);
            					}
HXDLIN( 268)					int ii_min12 = min6;
HXDLIN( 268)					int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 268)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXDLIN( 268)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 268)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 268)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXDLIN( 268)				if ((cy > dy)) {
HXDLIN( 268)					int min7;
HXDLIN( 268)					if ((by > dy)) {
HXDLIN( 268)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN( 268)						min7 = ::Math_obj::ceil(by);
            					}
HXDLIN( 268)					int ii_min14 = min7;
HXDLIN( 268)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 268)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXDLIN( 268)					int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 268)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 268)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 268)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 268)			if (hasUndo1) {
HXDLIN( 268)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 268)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 268)				 ::Dynamic imageType1 = null();
HXDLIN( 268)				 ::pi_xy::ImageStruct this33 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 268)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 268)				::Dynamic undoImage4;
HXDLIN( 268)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN( 268)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 268)						{
HXDLIN( 268)							b6->width = width1;
HXDLIN( 268)							b6->height = height1;
HXDLIN( 268)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 268)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 268)							{
HXDLIN( 268)								int len2 = b6->length;
HXDLIN( 268)								int w1 = 0;
HXDLIN( 268)								{
HXDLIN( 268)									int _g20 = 0;
HXDLIN( 268)									int _g21 = b6->height;
HXDLIN( 268)									while((_g20 < _g21)){
HXDLIN( 268)										_g20 = (_g20 + 1);
HXDLIN( 268)										int y3 = (_g20 - 1);
HXDLIN( 268)										{
HXDLIN( 268)											int _g22 = 0;
HXDLIN( 268)											int _g23 = b6->width;
HXDLIN( 268)											while((_g22 < _g23)){
HXDLIN( 268)												_g22 = (_g22 + 1);
HXDLIN( 268)												int x3 = (_g22 - 1);
HXDLIN( 268)												{
HXDLIN( 268)													w1 = (w1 + 1);
HXDLIN( 268)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 268)												{
HXDLIN( 268)													w1 = (w1 + 1);
HXDLIN( 268)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 268)												{
HXDLIN( 268)													w1 = (w1 + 1);
HXDLIN( 268)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 268)												{
HXDLIN( 268)													w1 = (w1 + 1);
HXDLIN( 268)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 268)						undoImage4 = b6;
            					}
            					break;
            					case (int)1: {
HXDLIN( 268)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 268)						{
HXDLIN( 268)							a7->width = width1;
HXDLIN( 268)							a7->height = height1;
HXDLIN( 268)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 268)							a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 268)							{
HXDLIN( 268)								int _g24 = 0;
HXDLIN( 268)								int _g25 = a7->length;
HXDLIN( 268)								while((_g24 < _g25)){
HXDLIN( 268)									_g24 = (_g24 + 1);
HXDLIN( 268)									int i10 = (_g24 - 1);
HXDLIN( 268)									a7->data[i10] = 0;
            								}
            							}
            						}
HXDLIN( 268)						undoImage4 = a7;
            					}
            					break;
            					case (int)2: {
HXDLIN( 268)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 268)						{
HXDLIN( 268)							b7->width = width1;
HXDLIN( 268)							b7->height = height1;
HXDLIN( 268)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 268)							int size1 = (b7->length * 4);
HXDLIN( 268)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 268)							{
HXDLIN( 268)								int _g26 = 0;
HXDLIN( 268)								int _g27 = b7->length;
HXDLIN( 268)								while((_g26 < _g27)){
HXDLIN( 268)									_g26 = (_g26 + 1);
HXDLIN( 268)									int i11 = (_g26 - 1);
HXDLIN( 268)									{
HXDLIN( 268)										 ::haxe::io::ArrayBufferViewImpl this34 = b7->data;
HXDLIN( 268)										bool undoImage5;
HXDLIN( 268)										if ((i11 >= 0)) {
HXDLIN( 268)											undoImage5 = (i11 < (this34->byteLength >> 2));
            										}
            										else {
HXDLIN( 268)											undoImage5 = false;
            										}
HXDLIN( 268)										if (undoImage5) {
HXDLIN( 268)											 ::haxe::io::Bytes _this1 = this34->bytes;
HXDLIN( 268)											int pos1 = ((i11 << 2) + this34->byteOffset);
HXDLIN( 268)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 268)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 268)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 268)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 268)						undoImage4 = b7;
            					}
            					break;
            					case (int)3: {
HXDLIN( 268)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 268)						{
HXDLIN( 268)							v2->width = width1;
HXDLIN( 268)							v2->height = height1;
HXDLIN( 268)							v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 268)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 268)							{
HXDLIN( 268)								int _g28 = 0;
HXDLIN( 268)								int _g29 = v2->length;
HXDLIN( 268)								while((_g28 < _g29)){
HXDLIN( 268)									_g28 = (_g28 + 1);
HXDLIN( 268)									int i12 = (_g28 - 1);
HXDLIN( 268)									v2->data->__unsafe_set(i12,0);
            								}
            							}
            						}
HXDLIN( 268)						undoImage4 = v2;
            					}
            					break;
            					case (int)4: {
HXDLIN( 268)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)						 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 268)						{
HXDLIN( 268)							b8->width = width1;
HXDLIN( 268)							b8->height = height1;
HXDLIN( 268)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 268)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 268)							{
HXDLIN( 268)								int len3 = b8->length;
HXDLIN( 268)								 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 268)								if (::hx::IsNull( d1->head )) {
HXDLIN( 268)									int _g30 = 0;
HXDLIN( 268)									int _g31 = len3;
HXDLIN( 268)									while((_g30 < _g31)){
HXDLIN( 268)										_g30 = (_g30 + 1);
HXDLIN( 268)										int i13 = (_g30 - 1);
HXDLIN( 268)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN( 268)									int _g32 = 0;
HXDLIN( 268)									int _g33 = len3;
HXDLIN( 268)									while((_g32 < _g33)){
HXDLIN( 268)										_g32 = (_g32 + 1);
HXDLIN( 268)										int i14 = (_g32 - 1);
HXDLIN( 268)										{
HXDLIN( 268)											 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 268)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 268)											{
HXDLIN( 268)												int _g34 = 0;
HXDLIN( 268)												int _g35 = i14;
HXDLIN( 268)												while((_g34 < _g35)){
HXDLIN( 268)													_g34 = (_g34 + 1);
HXDLIN( 268)													int i15 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 268)											if (::hx::IsNull( prev1 )) {
HXDLIN( 268)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 268)												l1 = null();
            											}
            											else {
HXDLIN( 268)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 268)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 268)						undoImage4 = b8;
            					}
            					break;
            				}
HXDLIN( 268)				this33->image = undoImage4;
HXDLIN( 268)				this33->width = width1;
HXDLIN( 268)				this33->height = height1;
HXDLIN( 268)				this33->imageType = ( (int)(imageType1) );
HXDLIN( 268)				undoImage3 = this33;
HXDLIN( 268)				{
HXDLIN( 268)					int rectLeft1 = xIter31->start;
HXDLIN( 268)					int rectTop1 = yIter31->start;
HXDLIN( 268)					int rectRight1 = xIter31->max;
HXDLIN( 268)					bool forceClear1 = false;
HXDLIN( 268)					{
HXDLIN( 268)						int _g36 = rectTop1;
HXDLIN( 268)						int _g37 = yIter31->max;
HXDLIN( 268)						while((_g36 < _g37)){
HXDLIN( 268)							_g36 = (_g36 + 1);
HXDLIN( 268)							int dy2 = (_g36 - 1);
HXDLIN( 268)							{
HXDLIN( 268)								int _g38 = rectLeft1;
HXDLIN( 268)								int _g39 = rectRight1;
HXDLIN( 268)								while((_g38 < _g39)){
HXDLIN( 268)									_g38 = (_g38 + 1);
HXDLIN( 268)									int dx2 = (_g38 - 1);
HXDLIN( 268)									::Dynamic this35 = this1->image;
HXDLIN( 268)									int index4;
HXDLIN( 268)									if (this1->useVirtualPos) {
HXDLIN( 268)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            									}
            									else {
HXDLIN( 268)										index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            									}
HXDLIN( 268)									int c3 = ::iterMagic::Iimg_obj::get(this35,index4);
HXDLIN( 268)									int col1;
HXDLIN( 268)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXDLIN( 268)										col1 = c3;
            									}
HXDLIN( 268)									bool _hx_tmp8;
HXDLIN( 268)									if (this1->useMask) {
HXDLIN( 268)										_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN( 268)										_hx_tmp8 = false;
            									}
HXDLIN( 268)									if (_hx_tmp8) {
HXDLIN( 268)										 ::pi_xy::ImageStruct this36 = this1->mask;
HXDLIN( 268)										::Dynamic this37 = this36->image;
HXDLIN( 268)										int index5;
HXDLIN( 268)										if (this36->useVirtualPos) {
HXDLIN( 268)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx2) - this36->virtualX));
            										}
            										else {
HXDLIN( 268)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this36->width) + dx2)) ));
            										}
HXDLIN( 268)										int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 268)										int v3;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											v3 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											v3 = c4;
            										}
HXDLIN( 268)										int maskPixel1 = v3;
HXDLIN( 268)										int this38 = col1;
HXDLIN( 268)										if ((maskPixel1 == 0)) {
HXDLIN( 268)											col1 = this38;
            										}
            										else {
HXDLIN( 268)											Float m01;
HXDLIN( 268)											int this39 = ((maskPixel1 >> 24) & 255);
HXDLIN( 268)											if ((this39 == 0)) {
HXDLIN( 268)												m01 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												m01 = (( (Float)(this39) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float m11;
HXDLIN( 268)											int this40 = ((maskPixel1 >> 16) & 255);
HXDLIN( 268)											if ((this40 == 0)) {
HXDLIN( 268)												m11 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												m11 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float m21;
HXDLIN( 268)											int this41 = ((maskPixel1 >> 8) & 255);
HXDLIN( 268)											if ((this41 == 0)) {
HXDLIN( 268)												m21 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												m21 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float m31;
HXDLIN( 268)											int this42 = (maskPixel1 & 255);
HXDLIN( 268)											if ((this42 == 0)) {
HXDLIN( 268)												m31 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												m31 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this38 >> 24) & 255)) )));
HXDLIN( 268)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this38 >> 16) & 255)) )));
HXDLIN( 268)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this38 >> 8) & 255)) )));
HXDLIN( 268)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this38 & 255)) )));
HXDLIN( 268)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 268)									if ((col1 != 0)) {
HXDLIN( 268)										int x4 = (dx2 - rectLeft1);
HXDLIN( 268)										int y4 = (dy2 - rectTop1);
HXDLIN( 268)										int c5 = col1;
HXDLIN( 268)										bool _hx_tmp9;
HXDLIN( 268)										if ((((c5 >> 24) & 255) < 254)) {
HXDLIN( 268)											_hx_tmp9 = undoImage3->transparent;
            										}
            										else {
HXDLIN( 268)											_hx_tmp9 = false;
            										}
HXDLIN( 268)										if (_hx_tmp9) {
HXDLIN( 268)											int location2;
HXDLIN( 268)											if (undoImage3->useVirtualPos) {
HXDLIN( 268)												location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXDLIN( 268)												location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 268)											int this43 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 268)											int this44;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)												this44 = ((((((this43 >> 24) & 255) << 24) | ((this43 & 255) << 16)) | (((this43 >> 8) & 255) << 8)) | ((this43 >> 16) & 255));
            											}
            											else {
HXDLIN( 268)												this44 = this43;
            											}
HXDLIN( 268)											Float a13;
HXDLIN( 268)											int this45 = ((this44 >> 24) & 255);
HXDLIN( 268)											if ((this45 == 0)) {
HXDLIN( 268)												a13 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												a13 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float r12;
HXDLIN( 268)											int this46 = ((this44 >> 16) & 255);
HXDLIN( 268)											if ((this46 == 0)) {
HXDLIN( 268)												r12 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												r12 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float g12;
HXDLIN( 268)											int this47 = ((this44 >> 8) & 255);
HXDLIN( 268)											if ((this47 == 0)) {
HXDLIN( 268)												g12 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												g12 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float b13;
HXDLIN( 268)											int this48 = (this44 & 255);
HXDLIN( 268)											if ((this48 == 0)) {
HXDLIN( 268)												b13 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												b13 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float a22;
HXDLIN( 268)											int this49 = ((col1 >> 24) & 255);
HXDLIN( 268)											if ((this49 == 0)) {
HXDLIN( 268)												a22 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												a22 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float r22;
HXDLIN( 268)											int this50 = ((col1 >> 16) & 255);
HXDLIN( 268)											if ((this50 == 0)) {
HXDLIN( 268)												r22 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												r22 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float g22;
HXDLIN( 268)											int this51 = ((col1 >> 8) & 255);
HXDLIN( 268)											if ((this51 == 0)) {
HXDLIN( 268)												g22 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												g22 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float b23;
HXDLIN( 268)											int this52 = (col1 & 255);
HXDLIN( 268)											if ((this52 == 0)) {
HXDLIN( 268)												b23 = ((Float)0.);
            											}
            											else {
HXDLIN( 268)												b23 = (( (Float)(this52) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 268)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 268)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 268)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 268)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 268)											int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 268)											{
HXDLIN( 268)												int _hx_tmp10;
HXDLIN( 268)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)													_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXDLIN( 268)													_hx_tmp10 = blended2;
            												}
HXDLIN( 268)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            											}
            										}
            										else {
HXDLIN( 268)											::Dynamic this53 = undoImage3->image;
HXDLIN( 268)											int index6;
HXDLIN( 268)											if (undoImage3->useVirtualPos) {
HXDLIN( 268)												index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXDLIN( 268)												index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 268)											int _hx_tmp11;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)												_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXDLIN( 268)												_hx_tmp11 = c5;
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(this53,index6,_hx_tmp11);
            										}
            									}
            									else {
HXDLIN( 268)										if (forceClear1) {
HXDLIN( 268)											::Dynamic this54 = undoImage3->image;
HXDLIN( 268)											int x5 = (dx2 - rectLeft1);
HXDLIN( 268)											int y5 = (dy2 - rectTop1);
HXDLIN( 268)											int index7;
HXDLIN( 268)											if (undoImage3->useVirtualPos) {
HXDLIN( 268)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXDLIN( 268)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(this54,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 268)			{
HXDLIN( 268)				int _g_min2 = xIter31->start;
HXDLIN( 268)				int _g_max2 = xIter31->max;
HXDLIN( 268)				while((_g_min2 < _g_max2)){
HXDLIN( 268)					_g_min2 = (_g_min2 + 1);
HXDLIN( 268)					int px2 = (_g_min2 - 1);
HXDLIN( 268)					Float pcx1 = (( (Float)(px2) ) - dx);
HXDLIN( 268)					{
HXDLIN( 268)						int _g_min3 = yIter31->start;
HXDLIN( 268)						int _g_max3 = yIter31->max;
HXDLIN( 268)						while((_g_min3 < _g_max3)){
HXDLIN( 268)							_g_min3 = (_g_min3 + 1);
HXDLIN( 268)							int py2 = (_g_min3 - 1);
HXDLIN( 268)							Float pcy1 = (( (Float)(py2) ) - dy);
HXDLIN( 268)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 268)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 268)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 268)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 268)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 268)							bool _hx_tmp12;
HXDLIN( 268)							bool _hx_tmp13;
HXDLIN( 268)							if ((ratioA1 >= 0)) {
HXDLIN( 268)								_hx_tmp13 = (ratioB1 >= 0);
            							}
            							else {
HXDLIN( 268)								_hx_tmp13 = false;
            							}
HXDLIN( 268)							if (_hx_tmp13) {
HXDLIN( 268)								_hx_tmp12 = (ratioC1 >= 0);
            							}
            							else {
HXDLIN( 268)								_hx_tmp12 = false;
            							}
HXDLIN( 268)							if (_hx_tmp12) {
HXDLIN( 268)								int i16 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 268)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE( 268)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE( 268)								int a9 = i16;
HXDLIN( 268)								int i17 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 268)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE( 268)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE( 268)								int r6 = i17;
HXDLIN( 268)								int i18 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 268)								if ((i18 > 255)) {
HXLINE(  24)									i18 = 255;
            								}
HXLINE( 268)								if ((i18 < 0)) {
HXLINE(  25)									i18 = 0;
            								}
HXLINE( 268)								int g6 = i18;
HXDLIN( 268)								int i19 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 268)								if ((i19 > 255)) {
HXLINE(  24)									i19 = 255;
            								}
HXLINE( 268)								if ((i19 < 0)) {
HXLINE(  25)									i19 = 0;
            								}
HXLINE( 268)								int b10 = i19;
HXDLIN( 268)								{
HXDLIN( 268)									int location3;
HXDLIN( 268)									if (this1->useVirtualPos) {
HXDLIN( 268)										location3 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this1->virtualY) * ( (Float)(this1->width) )) + px2) - this1->virtualX));
            									}
            									else {
HXDLIN( 268)										location3 = ::Std_obj::_hx_int(( (Float)(((py2 * this1->width) + px2)) ));
            									}
HXDLIN( 268)									bool _hx_tmp14;
HXDLIN( 268)									if (this1->transparent) {
HXDLIN( 268)										_hx_tmp14 = (a9 < 254);
            									}
            									else {
HXDLIN( 268)										_hx_tmp14 = false;
            									}
HXDLIN( 268)									if (_hx_tmp14) {
HXDLIN( 268)										int this55 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 268)										int old1;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											old1 = ((((((this55 >> 24) & 255) << 24) | ((this55 & 255) << 16)) | (((this55 >> 8) & 255) << 8)) | ((this55 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											old1 = this55;
            										}
HXDLIN( 268)										int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 268)										Float a14;
HXDLIN( 268)										int this56 = ((old1 >> 24) & 255);
HXDLIN( 268)										if ((this56 == 0)) {
HXDLIN( 268)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											a14 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float r13;
HXDLIN( 268)										int this57 = ((old1 >> 16) & 255);
HXDLIN( 268)										if ((this57 == 0)) {
HXDLIN( 268)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											r13 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float g13;
HXDLIN( 268)										int this58 = ((old1 >> 8) & 255);
HXDLIN( 268)										if ((this58 == 0)) {
HXDLIN( 268)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											g13 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float b14;
HXDLIN( 268)										int this59 = (old1 & 255);
HXDLIN( 268)										if ((this59 == 0)) {
HXDLIN( 268)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											b14 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float a23;
HXDLIN( 268)										int this60 = ((rhs1 >> 24) & 255);
HXDLIN( 268)										if ((this60 == 0)) {
HXDLIN( 268)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											a23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float r23;
HXDLIN( 268)										int this61 = ((rhs1 >> 16) & 255);
HXDLIN( 268)										if ((this61 == 0)) {
HXDLIN( 268)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											r23 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float g23;
HXDLIN( 268)										int this62 = ((rhs1 >> 8) & 255);
HXDLIN( 268)										if ((this62 == 0)) {
HXDLIN( 268)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											g23 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float b24;
HXDLIN( 268)										int this63 = (rhs1 & 255);
HXDLIN( 268)										if ((this63 == 0)) {
HXDLIN( 268)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											b24 = (( (Float)(this63) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 268)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 268)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 268)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 268)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 268)										int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 268)										{
HXDLIN( 268)											int _hx_tmp15;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)												_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 268)												_hx_tmp15 = blended3;
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp15);
            										}
            									}
            									else {
HXDLIN( 268)										int value1;
HXDLIN( 268)										if (this1->isLittle) {
HXDLIN( 268)											value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            										}
            										else {
HXDLIN( 268)											value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            										}
HXDLIN( 268)										::iterMagic::Iimg_obj::set(this1->image,location3,value1);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 268)			if ((hasHit1 == false)) {
HXDLIN( 268)				 ::pi_xy::algo::HitTri v4 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 268)				if (hasUndo1) {
HXDLIN( 268)					v4->undoImage = undoImage3;
HXDLIN( 268)					v4->undoX = xIter31->start;
HXDLIN( 268)					v4->undoY = yIter31->start;
            				}
            			}
            		}
HXDLIN( 268)		 ::pi_xy::algo::HitQuad v5 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 268)		 ::pi_xy::algo::HitQuad hitQuad = v5;
HXDLIN( 268)		Float cx1 = h2;
HXDLIN( 268)		Float cy1 = radius2;
HXDLIN( 268)		Float bx1 = h2;
HXDLIN( 268)		Float by1 = -(radius2);
HXDLIN( 268)		Float dx3 = hSmall;
HXDLIN( 268)		Float dy3 = radius2;
HXDLIN( 268)		Float ax1 = hSmall;
HXDLIN( 268)		Float ay1 = -(radius2);
HXLINE( 744)		temp = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE( 745)		by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE( 746)		bx1 = temp;
HXLINE( 747)		temp = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE( 748)		cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE( 749)		cx1 = temp;
HXLINE( 751)		temp = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE( 752)		ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE( 753)		ax1 = temp;
HXLINE( 755)		temp = (px + ((dx3 * cos) - (dy3 * sin)));
HXLINE( 756)		dy3 = (py + ((dy3 * cos) + (dx3 * sin)));
HXLINE( 757)		dx3 = temp;
HXLINE( 268)		 ::pi_xy::pixel::_TwoGrad::TwoGrad_ twoColors =  ::pi_xy::pixel::_TwoGrad::TwoGrad__obj::__alloc( HX_CTX ,color1,color2);
HXDLIN( 268)		int a15 = twoColors->colorClock;
HXDLIN( 268)		int b16 = twoColors->colorAnti;
HXDLIN( 268)		int half = ((((::Math_obj::round(((((( (Float)(((a15 >> 24) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b16 >> 24) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 24) | (::Math_obj::round(((((( (Float)(((a15 >> 16) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b16 >> 16) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 16)) | (::Math_obj::round(((((( (Float)(((a15 >> 8) & 255)) ) / ( (Float)(255) )) + (( (Float)(((b16 >> 8) & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))) << 8)) | ::Math_obj::round(((((( (Float)((a15 & 255)) ) / ( (Float)(255) )) + (( (Float)((b16 & 255)) ) / ( (Float)(255) ))) / ( (Float)(2) )) * ( (Float)(255) ))));
HXDLIN( 268)		bool hasUndo2 = false;
HXDLIN( 268)		int aA2 = ((color1 >> 24) & 255);
HXDLIN( 268)		int rA2 = ((color1 >> 16) & 255);
HXDLIN( 268)		int gA2 = ((color1 >> 8) & 255);
HXDLIN( 268)		int bA2 = (color1 & 255);
HXDLIN( 268)		int aB2 = ((half >> 24) & 255);
HXDLIN( 268)		int rB2 = ((half >> 16) & 255);
HXDLIN( 268)		int gB2 = ((half >> 8) & 255);
HXDLIN( 268)		int bB2 = (half & 255);
HXDLIN( 268)		int aC2 = ((color2 >> 24) & 255);
HXDLIN( 268)		int rC2 = ((color2 >> 16) & 255);
HXDLIN( 268)		int gC2 = ((color2 >> 8) & 255);
HXDLIN( 268)		int bC2 = (color2 & 255);
HXDLIN( 268)		Float bcx2 = (bx1 - cx1);
HXDLIN( 268)		Float bcy2 = (by1 - cy1);
HXDLIN( 268)		Float acx2 = (qx - cx1);
HXDLIN( 268)		Float acy2 = (qy - cy1);
HXDLIN( 268)		Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 268)		Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 268)		Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 268)		Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 268)		 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 268)		if ((qx > bx1)) {
HXDLIN( 268)			if ((qx > cx1)) {
HXDLIN( 268)				int min8;
HXDLIN( 268)				if ((bx1 > cx1)) {
HXDLIN( 268)					min8 = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN( 268)					min8 = ::Math_obj::floor(bx1);
            				}
HXDLIN( 268)				int ii_min16 = min8;
HXDLIN( 268)				int ii_max16 = ::Math_obj::ceil(qx);
HXDLIN( 268)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            			}
            			else {
HXDLIN( 268)				int ii_min17 = ::Math_obj::floor(bx1);
HXDLIN( 268)				int ii_max17 = ::Math_obj::ceil(cx1);
HXDLIN( 268)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            			}
            		}
            		else {
HXDLIN( 268)			if ((bx1 > cx1)) {
HXDLIN( 268)				int min9;
HXDLIN( 268)				if ((qx > cx1)) {
HXDLIN( 268)					min9 = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN( 268)					min9 = ::Math_obj::ceil(qx);
            				}
HXDLIN( 268)				int ii_min18 = min9;
HXDLIN( 268)				int ii_max18 = ::Math_obj::ceil(bx1);
HXDLIN( 268)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            			}
            			else {
HXDLIN( 268)				int ii_min19 = ::Math_obj::floor(qx);
HXDLIN( 268)				int ii_max19 = ::Math_obj::ceil(cx1);
HXDLIN( 268)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            			}
            		}
HXDLIN( 268)		 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 268)		if ((qy > by1)) {
HXDLIN( 268)			if ((qy > cy1)) {
HXDLIN( 268)				int min10;
HXDLIN( 268)				if ((by1 > cy1)) {
HXDLIN( 268)					min10 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN( 268)					min10 = ::Math_obj::floor(by1);
            				}
HXDLIN( 268)				int ii_min20 = min10;
HXDLIN( 268)				int ii_max20 = ::Math_obj::ceil(qy);
HXDLIN( 268)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            			}
            			else {
HXDLIN( 268)				int ii_min21 = ::Math_obj::floor(by1);
HXDLIN( 268)				int ii_max21 = ::Math_obj::ceil(cy1);
HXDLIN( 268)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            			}
            		}
            		else {
HXDLIN( 268)			if ((by1 > cy1)) {
HXDLIN( 268)				int min11;
HXDLIN( 268)				if ((qy > cy1)) {
HXDLIN( 268)					min11 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN( 268)					min11 = ::Math_obj::ceil(qy);
            				}
HXDLIN( 268)				int ii_min22 = min11;
HXDLIN( 268)				int ii_max22 = ::Math_obj::ceil(by1);
HXDLIN( 268)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            			}
            			else {
HXDLIN( 268)				int ii_min23 = ::Math_obj::floor(qy);
HXDLIN( 268)				int ii_max23 = ::Math_obj::ceil(cy1);
HXDLIN( 268)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            			}
            		}
HXDLIN( 268)		 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 268)		if (hasUndo2) {
HXDLIN( 268)			int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 268)			int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 268)			 ::Dynamic imageType2 = null();
HXDLIN( 268)			 ::pi_xy::ImageStruct this64 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 268)			if (::hx::IsNull( imageType2 )) {
HXLINE(  54)				imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 268)			::Dynamic undoImage7;
HXDLIN( 268)			switch((int)(( (int)(imageType2) ))){
            				case (int)0: {
HXDLIN( 268)					 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::BytesImg b17 = byt2;
HXDLIN( 268)					{
HXDLIN( 268)						b17->width = width2;
HXDLIN( 268)						b17->height = height2;
HXDLIN( 268)						b17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 268)						b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN( 268)						{
HXDLIN( 268)							int len4 = b17->length;
HXDLIN( 268)							int w2 = 0;
HXDLIN( 268)							{
HXDLIN( 268)								int _g40 = 0;
HXDLIN( 268)								int _g41 = b17->height;
HXDLIN( 268)								while((_g40 < _g41)){
HXDLIN( 268)									_g40 = (_g40 + 1);
HXDLIN( 268)									int y6 = (_g40 - 1);
HXDLIN( 268)									{
HXDLIN( 268)										int _g42 = 0;
HXDLIN( 268)										int _g43 = b17->width;
HXDLIN( 268)										while((_g42 < _g43)){
HXDLIN( 268)											_g42 = (_g42 + 1);
HXDLIN( 268)											int x6 = (_g42 - 1);
HXDLIN( 268)											{
HXDLIN( 268)												w2 = (w2 + 1);
HXDLIN( 268)												b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 268)											{
HXDLIN( 268)												w2 = (w2 + 1);
HXDLIN( 268)												b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 268)											{
HXDLIN( 268)												w2 = (w2 + 1);
HXDLIN( 268)												b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 268)											{
HXDLIN( 268)												w2 = (w2 + 1);
HXDLIN( 268)												b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 268)					undoImage7 = b17;
            				}
            				break;
            				case (int)1: {
HXDLIN( 268)					 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::ArrIntImg a16 = arrI2;
HXDLIN( 268)					{
HXDLIN( 268)						a16->width = width2;
HXDLIN( 268)						a16->height = height2;
HXDLIN( 268)						a16->data = ::Array_obj< int >::__new(0);
HXDLIN( 268)						a16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 268)						{
HXDLIN( 268)							int _g44 = 0;
HXDLIN( 268)							int _g45 = a16->length;
HXDLIN( 268)							while((_g44 < _g45)){
HXDLIN( 268)								_g44 = (_g44 + 1);
HXDLIN( 268)								int i20 = (_g44 - 1);
HXDLIN( 268)								a16->data[i20] = 0;
            							}
            						}
            					}
HXDLIN( 268)					undoImage7 = a16;
            				}
            				break;
            				case (int)2: {
HXDLIN( 268)					 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::U32ArrImg b18 = u32a2;
HXDLIN( 268)					{
HXDLIN( 268)						b18->width = width2;
HXDLIN( 268)						b18->height = height2;
HXDLIN( 268)						b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 268)						int size2 = (b18->length * 4);
HXDLIN( 268)						b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 268)						{
HXDLIN( 268)							int _g46 = 0;
HXDLIN( 268)							int _g47 = b18->length;
HXDLIN( 268)							while((_g46 < _g47)){
HXDLIN( 268)								_g46 = (_g46 + 1);
HXDLIN( 268)								int i21 = (_g46 - 1);
HXDLIN( 268)								{
HXDLIN( 268)									 ::haxe::io::ArrayBufferViewImpl this65 = b18->data;
HXDLIN( 268)									bool undoImage8;
HXDLIN( 268)									if ((i21 >= 0)) {
HXDLIN( 268)										undoImage8 = (i21 < (this65->byteLength >> 2));
            									}
            									else {
HXDLIN( 268)										undoImage8 = false;
            									}
HXDLIN( 268)									if (undoImage8) {
HXDLIN( 268)										 ::haxe::io::Bytes _this2 = this65->bytes;
HXDLIN( 268)										int pos2 = ((i21 << 2) + this65->byteOffset);
HXDLIN( 268)										_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 268)										_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 268)										_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 268)										_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 268)					undoImage7 = b18;
            				}
            				break;
            				case (int)3: {
HXDLIN( 268)					 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN( 268)					{
HXDLIN( 268)						v6->width = width2;
HXDLIN( 268)						v6->height = height2;
HXDLIN( 268)						v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 268)						v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 268)						{
HXDLIN( 268)							int _g48 = 0;
HXDLIN( 268)							int _g49 = v6->length;
HXDLIN( 268)							while((_g48 < _g49)){
HXDLIN( 268)								_g48 = (_g48 + 1);
HXDLIN( 268)								int i22 = (_g48 - 1);
HXDLIN( 268)								v6->data->__unsafe_set(i22,0);
            							}
            						}
            					}
HXDLIN( 268)					undoImage7 = v6;
            				}
            				break;
            				case (int)4: {
HXDLIN( 268)					 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::StackIntImg b19 = sInt2;
HXDLIN( 268)					{
HXDLIN( 268)						b19->width = width2;
HXDLIN( 268)						b19->height = height2;
HXDLIN( 268)						b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 268)						b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 268)						{
HXDLIN( 268)							int len5 = b19->length;
HXDLIN( 268)							 ::haxe::ds::GenericStack_Int d2 = b19->data;
HXDLIN( 268)							if (::hx::IsNull( d2->head )) {
HXDLIN( 268)								int _g50 = 0;
HXDLIN( 268)								int _g51 = len5;
HXDLIN( 268)								while((_g50 < _g51)){
HXDLIN( 268)									_g50 = (_g50 + 1);
HXDLIN( 268)									int i23 = (_g50 - 1);
HXDLIN( 268)									d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            								}
            							}
            							else {
HXDLIN( 268)								int _g52 = 0;
HXDLIN( 268)								int _g53 = len5;
HXDLIN( 268)								while((_g52 < _g53)){
HXDLIN( 268)									_g52 = (_g52 + 1);
HXDLIN( 268)									int i24 = (_g52 - 1);
HXDLIN( 268)									{
HXDLIN( 268)										 ::haxe::ds::GenericCell_Int l2 = b19->data->head;
HXDLIN( 268)										 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 268)										{
HXDLIN( 268)											int _g54 = 0;
HXDLIN( 268)											int _g55 = i24;
HXDLIN( 268)											while((_g54 < _g55)){
HXDLIN( 268)												_g54 = (_g54 + 1);
HXDLIN( 268)												int i25 = (_g54 - 1);
HXLINE( 345)												prev2 = l2;
HXLINE( 346)												l2 = l2->next;
            											}
            										}
HXLINE( 268)										if (::hx::IsNull( prev2 )) {
HXDLIN( 268)											b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 268)											l2 = null();
            										}
            										else {
HXDLIN( 268)											prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 268)											l2 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 268)					undoImage7 = b19;
            				}
            				break;
            			}
HXDLIN( 268)			this64->image = undoImage7;
HXDLIN( 268)			this64->width = width2;
HXDLIN( 268)			this64->height = height2;
HXDLIN( 268)			this64->imageType = ( (int)(imageType2) );
HXDLIN( 268)			undoImage6 = this64;
HXDLIN( 268)			{
HXDLIN( 268)				int rectLeft2 = xIter32->start;
HXDLIN( 268)				int rectTop2 = yIter32->start;
HXDLIN( 268)				int rectRight2 = xIter32->max;
HXDLIN( 268)				bool forceClear2 = false;
HXDLIN( 268)				{
HXDLIN( 268)					int _g56 = rectTop2;
HXDLIN( 268)					int _g57 = yIter32->max;
HXDLIN( 268)					while((_g56 < _g57)){
HXDLIN( 268)						_g56 = (_g56 + 1);
HXDLIN( 268)						int dy4 = (_g56 - 1);
HXDLIN( 268)						{
HXDLIN( 268)							int _g58 = rectLeft2;
HXDLIN( 268)							int _g59 = rectRight2;
HXDLIN( 268)							while((_g58 < _g59)){
HXDLIN( 268)								_g58 = (_g58 + 1);
HXDLIN( 268)								int dx4 = (_g58 - 1);
HXDLIN( 268)								::Dynamic this66 = this1->image;
HXDLIN( 268)								int index8;
HXDLIN( 268)								if (this1->useVirtualPos) {
HXDLIN( 268)									index8 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx4) - this1->virtualX));
            								}
            								else {
HXDLIN( 268)									index8 = ::Std_obj::_hx_int(( (Float)(((dy4 * this1->width) + dx4)) ));
            								}
HXDLIN( 268)								int c6 = ::iterMagic::Iimg_obj::get(this66,index8);
HXDLIN( 268)								int col2;
HXDLIN( 268)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)									col2 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            								}
            								else {
HXDLIN( 268)									col2 = c6;
            								}
HXDLIN( 268)								bool _hx_tmp16;
HXDLIN( 268)								if (this1->useMask) {
HXDLIN( 268)									_hx_tmp16 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 268)									_hx_tmp16 = false;
            								}
HXDLIN( 268)								if (_hx_tmp16) {
HXDLIN( 268)									 ::pi_xy::ImageStruct this67 = this1->mask;
HXDLIN( 268)									::Dynamic this68 = this67->image;
HXDLIN( 268)									int index9;
HXDLIN( 268)									if (this67->useVirtualPos) {
HXDLIN( 268)										index9 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this67->virtualY) * ( (Float)(this67->width) )) + dx4) - this67->virtualX));
            									}
            									else {
HXDLIN( 268)										index9 = ::Std_obj::_hx_int(( (Float)(((dy4 * this67->width) + dx4)) ));
            									}
HXDLIN( 268)									int c7 = ::iterMagic::Iimg_obj::get(this68,index9);
HXDLIN( 268)									int v7;
HXDLIN( 268)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)										v7 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXDLIN( 268)										v7 = c7;
            									}
HXDLIN( 268)									int maskPixel2 = v7;
HXDLIN( 268)									int this69 = col2;
HXDLIN( 268)									if ((maskPixel2 == 0)) {
HXDLIN( 268)										col2 = this69;
            									}
            									else {
HXDLIN( 268)										Float m02;
HXDLIN( 268)										int this70 = ((maskPixel2 >> 24) & 255);
HXDLIN( 268)										if ((this70 == 0)) {
HXDLIN( 268)											m02 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											m02 = (( (Float)(this70) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float m12;
HXDLIN( 268)										int this71 = ((maskPixel2 >> 16) & 255);
HXDLIN( 268)										if ((this71 == 0)) {
HXDLIN( 268)											m12 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											m12 = (( (Float)(this71) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float m22;
HXDLIN( 268)										int this72 = ((maskPixel2 >> 8) & 255);
HXDLIN( 268)										if ((this72 == 0)) {
HXDLIN( 268)											m22 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											m22 = (( (Float)(this72) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float m32;
HXDLIN( 268)										int this73 = (maskPixel2 & 255);
HXDLIN( 268)										if ((this73 == 0)) {
HXDLIN( 268)											m32 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											m32 = (( (Float)(this73) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this69 >> 24) & 255)) )));
HXDLIN( 268)										int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this69 >> 16) & 255)) )));
HXDLIN( 268)										int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this69 >> 8) & 255)) )));
HXDLIN( 268)										int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this69 & 255)) )));
HXDLIN( 268)										col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 268)								if ((col2 != 0)) {
HXDLIN( 268)									int x7 = (dx4 - rectLeft2);
HXDLIN( 268)									int y7 = (dy4 - rectTop2);
HXDLIN( 268)									int c8 = col2;
HXDLIN( 268)									bool _hx_tmp17;
HXDLIN( 268)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 268)										_hx_tmp17 = undoImage6->transparent;
            									}
            									else {
HXDLIN( 268)										_hx_tmp17 = false;
            									}
HXDLIN( 268)									if (_hx_tmp17) {
HXDLIN( 268)										int location4;
HXDLIN( 268)										if (undoImage6->useVirtualPos) {
HXDLIN( 268)											location4 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 268)											location4 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            										}
HXDLIN( 268)										int this74 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 268)										int this75;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											this75 = ((((((this74 >> 24) & 255) << 24) | ((this74 & 255) << 16)) | (((this74 >> 8) & 255) << 8)) | ((this74 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											this75 = this74;
            										}
HXDLIN( 268)										Float a17;
HXDLIN( 268)										int this76 = ((this75 >> 24) & 255);
HXDLIN( 268)										if ((this76 == 0)) {
HXDLIN( 268)											a17 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											a17 = (( (Float)(this76) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float r14;
HXDLIN( 268)										int this77 = ((this75 >> 16) & 255);
HXDLIN( 268)										if ((this77 == 0)) {
HXDLIN( 268)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											r14 = (( (Float)(this77) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float g14;
HXDLIN( 268)										int this78 = ((this75 >> 8) & 255);
HXDLIN( 268)										if ((this78 == 0)) {
HXDLIN( 268)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											g14 = (( (Float)(this78) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float b110;
HXDLIN( 268)										int this79 = (this75 & 255);
HXDLIN( 268)										if ((this79 == 0)) {
HXDLIN( 268)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											b110 = (( (Float)(this79) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float a24;
HXDLIN( 268)										int this80 = ((col2 >> 24) & 255);
HXDLIN( 268)										if ((this80 == 0)) {
HXDLIN( 268)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											a24 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float r24;
HXDLIN( 268)										int this81 = ((col2 >> 16) & 255);
HXDLIN( 268)										if ((this81 == 0)) {
HXDLIN( 268)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											r24 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float g24;
HXDLIN( 268)										int this82 = ((col2 >> 8) & 255);
HXDLIN( 268)										if ((this82 == 0)) {
HXDLIN( 268)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											g24 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float b25;
HXDLIN( 268)										int this83 = (col2 & 255);
HXDLIN( 268)										if ((this83 == 0)) {
HXDLIN( 268)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											b25 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float a34 = (a17 * (( (Float)(1) ) - a24));
HXDLIN( 268)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 268)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 268)										int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN( 268)										int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 268)										int blended4 = ((((a18 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 268)										{
HXDLIN( 268)											int _hx_tmp18;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)												_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 268)												_hx_tmp18 = blended4;
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            										}
            									}
            									else {
HXDLIN( 268)										::Dynamic this84 = undoImage6->image;
HXDLIN( 268)										int index10;
HXDLIN( 268)										if (undoImage6->useVirtualPos) {
HXDLIN( 268)											index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 268)											index10 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            										}
HXDLIN( 268)										int _hx_tmp19;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											_hx_tmp19 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											_hx_tmp19 = c8;
            										}
HXDLIN( 268)										::iterMagic::Iimg_obj::set(this84,index10,_hx_tmp19);
            									}
            								}
            								else {
HXDLIN( 268)									if (forceClear2) {
HXDLIN( 268)										::Dynamic this85 = undoImage6->image;
HXDLIN( 268)										int x8 = (dx4 - rectLeft2);
HXDLIN( 268)										int y8 = (dy4 - rectTop2);
HXDLIN( 268)										int index11;
HXDLIN( 268)										if (undoImage6->useVirtualPos) {
HXDLIN( 268)											index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 268)											index11 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            										}
HXDLIN( 268)										::iterMagic::Iimg_obj::set(this85,index11,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 268)		{
HXDLIN( 268)			int _g_min4 = xIter32->start;
HXDLIN( 268)			int _g_max4 = xIter32->max;
HXDLIN( 268)			while((_g_min4 < _g_max4)){
HXDLIN( 268)				_g_min4 = (_g_min4 + 1);
HXDLIN( 268)				int px3 = (_g_min4 - 1);
HXDLIN( 268)				Float pcx2 = (( (Float)(px3) ) - cx1);
HXDLIN( 268)				{
HXDLIN( 268)					int _g_min5 = yIter32->start;
HXDLIN( 268)					int _g_max5 = yIter32->max;
HXDLIN( 268)					while((_g_min5 < _g_max5)){
HXDLIN( 268)						_g_min5 = (_g_min5 + 1);
HXDLIN( 268)						int py3 = (_g_min5 - 1);
HXDLIN( 268)						Float pcy2 = (( (Float)(py3) ) - cy1);
HXDLIN( 268)						Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 268)						Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 268)						Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 268)						Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 268)						Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 268)						bool _hx_tmp20;
HXDLIN( 268)						bool _hx_tmp21;
HXDLIN( 268)						if ((ratioA2 >= 0)) {
HXDLIN( 268)							_hx_tmp21 = (ratioB2 >= 0);
            						}
            						else {
HXDLIN( 268)							_hx_tmp21 = false;
            						}
HXDLIN( 268)						if (_hx_tmp21) {
HXDLIN( 268)							_hx_tmp20 = (ratioC2 >= 0);
            						}
            						else {
HXDLIN( 268)							_hx_tmp20 = false;
            						}
HXDLIN( 268)						if (_hx_tmp20) {
HXDLIN( 268)							int i26 = ::Std_obj::_hx_int((((( (Float)(aA2) ) * ratioA2) + (( (Float)(aB2) ) * ratioB2)) + (( (Float)(aC2) ) * ratioC2)));
HXDLIN( 268)							if ((i26 > 255)) {
HXLINE(  24)								i26 = 255;
            							}
HXLINE( 268)							if ((i26 < 0)) {
HXLINE(  25)								i26 = 0;
            							}
HXLINE( 268)							int a19 = i26;
HXDLIN( 268)							int i27 = ::Std_obj::_hx_int((((( (Float)(rA2) ) * ratioA2) + (( (Float)(rB2) ) * ratioB2)) + (( (Float)(rC2) ) * ratioC2)));
HXDLIN( 268)							if ((i27 > 255)) {
HXLINE(  24)								i27 = 255;
            							}
HXLINE( 268)							if ((i27 < 0)) {
HXLINE(  25)								i27 = 0;
            							}
HXLINE( 268)							int r9 = i27;
HXDLIN( 268)							int i28 = ::Std_obj::_hx_int((((( (Float)(gA2) ) * ratioA2) + (( (Float)(gB2) ) * ratioB2)) + (( (Float)(gC2) ) * ratioC2)));
HXDLIN( 268)							if ((i28 > 255)) {
HXLINE(  24)								i28 = 255;
            							}
HXLINE( 268)							if ((i28 < 0)) {
HXLINE(  25)								i28 = 0;
            							}
HXLINE( 268)							int g9 = i28;
HXDLIN( 268)							int i29 = ::Std_obj::_hx_int((((( (Float)(bA2) ) * ratioA2) + (( (Float)(bB2) ) * ratioB2)) + (( (Float)(bC2) ) * ratioC2)));
HXDLIN( 268)							if ((i29 > 255)) {
HXLINE(  24)								i29 = 255;
            							}
HXLINE( 268)							if ((i29 < 0)) {
HXLINE(  25)								i29 = 0;
            							}
HXLINE( 268)							int b26 = i29;
HXDLIN( 268)							{
HXDLIN( 268)								int location5;
HXDLIN( 268)								if (this1->useVirtualPos) {
HXDLIN( 268)									location5 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this1->virtualY) * ( (Float)(this1->width) )) + px3) - this1->virtualX));
            								}
            								else {
HXDLIN( 268)									location5 = ::Std_obj::_hx_int(( (Float)(((py3 * this1->width) + px3)) ));
            								}
HXDLIN( 268)								bool _hx_tmp22;
HXDLIN( 268)								if (this1->transparent) {
HXDLIN( 268)									_hx_tmp22 = (a19 < 254);
            								}
            								else {
HXDLIN( 268)									_hx_tmp22 = false;
            								}
HXDLIN( 268)								if (_hx_tmp22) {
HXDLIN( 268)									int this86 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 268)									int old2;
HXDLIN( 268)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)										old2 = ((((((this86 >> 24) & 255) << 24) | ((this86 & 255) << 16)) | (((this86 >> 8) & 255) << 8)) | ((this86 >> 16) & 255));
            									}
            									else {
HXDLIN( 268)										old2 = this86;
            									}
HXDLIN( 268)									int rhs2 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b26);
HXDLIN( 268)									Float a110;
HXDLIN( 268)									int this87 = ((old2 >> 24) & 255);
HXDLIN( 268)									if ((this87 == 0)) {
HXDLIN( 268)										a110 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										a110 = (( (Float)(this87) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float r15;
HXDLIN( 268)									int this88 = ((old2 >> 16) & 255);
HXDLIN( 268)									if ((this88 == 0)) {
HXDLIN( 268)										r15 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										r15 = (( (Float)(this88) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float g15;
HXDLIN( 268)									int this89 = ((old2 >> 8) & 255);
HXDLIN( 268)									if ((this89 == 0)) {
HXDLIN( 268)										g15 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										g15 = (( (Float)(this89) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float b111;
HXDLIN( 268)									int this90 = (old2 & 255);
HXDLIN( 268)									if ((this90 == 0)) {
HXDLIN( 268)										b111 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										b111 = (( (Float)(this90) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float a25;
HXDLIN( 268)									int this91 = ((rhs2 >> 24) & 255);
HXDLIN( 268)									if ((this91 == 0)) {
HXDLIN( 268)										a25 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										a25 = (( (Float)(this91) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float r25;
HXDLIN( 268)									int this92 = ((rhs2 >> 16) & 255);
HXDLIN( 268)									if ((this92 == 0)) {
HXDLIN( 268)										r25 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										r25 = (( (Float)(this92) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float g25;
HXDLIN( 268)									int this93 = ((rhs2 >> 8) & 255);
HXDLIN( 268)									if ((this93 == 0)) {
HXDLIN( 268)										g25 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										g25 = (( (Float)(this93) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float b27;
HXDLIN( 268)									int this94 = (rhs2 & 255);
HXDLIN( 268)									if ((this94 == 0)) {
HXDLIN( 268)										b27 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										b27 = (( (Float)(this94) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 268)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 268)									int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 268)									int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b27 * a25))));
HXDLIN( 268)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 268)									int blended5 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b28);
HXDLIN( 268)									{
HXDLIN( 268)										int _hx_tmp23;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											_hx_tmp23 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											_hx_tmp23 = blended5;
            										}
HXDLIN( 268)										::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp23);
            									}
            								}
            								else {
HXDLIN( 268)									int value2;
HXDLIN( 268)									if (this1->isLittle) {
HXDLIN( 268)										value2 = ((((a19 << 24) | (b26 << 16)) | (g9 << 8)) | r9);
            									}
            									else {
HXDLIN( 268)										value2 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b26);
            									}
HXDLIN( 268)									::iterMagic::Iimg_obj::set(this1->image,location5,value2);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 268)		 ::pi_xy::algo::HitTri hitTriTop;
HXDLIN( 268)		if ((hasHit == false)) {
HXDLIN( 268)			 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx1,by1,cx1,cy1,true);
HXDLIN( 268)			if (hasUndo2) {
HXDLIN( 268)				v8->undoImage = undoImage6;
HXDLIN( 268)				v8->undoX = xIter32->start;
HXDLIN( 268)				v8->undoY = yIter32->start;
            			}
HXDLIN( 268)			hitTriTop = v8;
            		}
            		else {
HXDLIN( 268)			hitTriTop = null();
            		}
HXDLIN( 268)		bool hasUndo3 = false;
HXDLIN( 268)		int aA3 = ((color1 >> 24) & 255);
HXDLIN( 268)		int rA3 = ((color1 >> 16) & 255);
HXDLIN( 268)		int gA3 = ((color1 >> 8) & 255);
HXDLIN( 268)		int bA3 = (color1 & 255);
HXDLIN( 268)		int aB3 = ((half >> 24) & 255);
HXDLIN( 268)		int rB3 = ((half >> 16) & 255);
HXDLIN( 268)		int gB3 = ((half >> 8) & 255);
HXDLIN( 268)		int bB3 = (half & 255);
HXDLIN( 268)		int aC3 = ((color2 >> 24) & 255);
HXDLIN( 268)		int rC3 = ((color2 >> 16) & 255);
HXDLIN( 268)		int gC3 = ((color2 >> 8) & 255);
HXDLIN( 268)		int bC3 = (color2 & 255);
HXDLIN( 268)		Float bcx3 = (ax1 - dx3);
HXDLIN( 268)		Float bcy3 = (ay1 - dy3);
HXDLIN( 268)		Float acx3 = (px - dx3);
HXDLIN( 268)		Float acy3 = (py - dy3);
HXDLIN( 268)		Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 268)		Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 268)		Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 268)		Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 268)		 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 268)		if ((px > ax1)) {
HXDLIN( 268)			if ((px > dx3)) {
HXDLIN( 268)				int min12;
HXDLIN( 268)				if ((ax1 > dx3)) {
HXDLIN( 268)					min12 = ::Math_obj::floor(dx3);
            				}
            				else {
HXDLIN( 268)					min12 = ::Math_obj::floor(ax1);
            				}
HXDLIN( 268)				int ii_min24 = min12;
HXDLIN( 268)				int ii_max24 = ::Math_obj::ceil(px);
HXDLIN( 268)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            			}
            			else {
HXDLIN( 268)				int ii_min25 = ::Math_obj::floor(ax1);
HXDLIN( 268)				int ii_max25 = ::Math_obj::ceil(dx3);
HXDLIN( 268)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            			}
            		}
            		else {
HXDLIN( 268)			if ((ax1 > dx3)) {
HXDLIN( 268)				int min13;
HXDLIN( 268)				if ((px > dx3)) {
HXDLIN( 268)					min13 = ::Math_obj::floor(dx3);
            				}
            				else {
HXDLIN( 268)					min13 = ::Math_obj::ceil(px);
            				}
HXDLIN( 268)				int ii_min26 = min13;
HXDLIN( 268)				int ii_max26 = ::Math_obj::ceil(ax1);
HXDLIN( 268)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            			}
            			else {
HXDLIN( 268)				int ii_min27 = ::Math_obj::floor(px);
HXDLIN( 268)				int ii_max27 = ::Math_obj::ceil(dx3);
HXDLIN( 268)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            			}
            		}
HXDLIN( 268)		 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 268)		if ((py > ay1)) {
HXDLIN( 268)			if ((py > dy3)) {
HXDLIN( 268)				int min14;
HXDLIN( 268)				if ((ay1 > dy3)) {
HXDLIN( 268)					min14 = ::Math_obj::floor(dy3);
            				}
            				else {
HXDLIN( 268)					min14 = ::Math_obj::floor(ay1);
            				}
HXDLIN( 268)				int ii_min28 = min14;
HXDLIN( 268)				int ii_max28 = ::Math_obj::ceil(py);
HXDLIN( 268)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            			}
            			else {
HXDLIN( 268)				int ii_min29 = ::Math_obj::floor(ay1);
HXDLIN( 268)				int ii_max29 = ::Math_obj::ceil(dy3);
HXDLIN( 268)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            			}
            		}
            		else {
HXDLIN( 268)			if ((ay1 > dy3)) {
HXDLIN( 268)				int min15;
HXDLIN( 268)				if ((py > dy3)) {
HXDLIN( 268)					min15 = ::Math_obj::floor(dy3);
            				}
            				else {
HXDLIN( 268)					min15 = ::Math_obj::ceil(py);
            				}
HXDLIN( 268)				int ii_min30 = min15;
HXDLIN( 268)				int ii_max30 = ::Math_obj::ceil(ay1);
HXDLIN( 268)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            			}
            			else {
HXDLIN( 268)				int ii_min31 = ::Math_obj::floor(py);
HXDLIN( 268)				int ii_max31 = ::Math_obj::ceil(dy3);
HXDLIN( 268)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            			}
            		}
HXDLIN( 268)		 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 268)		if (hasUndo3) {
HXDLIN( 268)			int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 268)			int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 268)			 ::Dynamic imageType3 = null();
HXDLIN( 268)			 ::pi_xy::ImageStruct this95 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 268)			if (::hx::IsNull( imageType3 )) {
HXLINE(  54)				imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 268)			::Dynamic undoImage10;
HXDLIN( 268)			switch((int)(( (int)(imageType3) ))){
            				case (int)0: {
HXDLIN( 268)					 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::BytesImg b29 = byt3;
HXDLIN( 268)					{
HXDLIN( 268)						b29->width = width3;
HXDLIN( 268)						b29->height = height3;
HXDLIN( 268)						b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 268)						b29->data = ::haxe::io::Bytes_obj::alloc((b29->length * 4));
HXDLIN( 268)						{
HXDLIN( 268)							int len6 = b29->length;
HXDLIN( 268)							int w3 = 0;
HXDLIN( 268)							{
HXDLIN( 268)								int _g60 = 0;
HXDLIN( 268)								int _g61 = b29->height;
HXDLIN( 268)								while((_g60 < _g61)){
HXDLIN( 268)									_g60 = (_g60 + 1);
HXDLIN( 268)									int y9 = (_g60 - 1);
HXDLIN( 268)									{
HXDLIN( 268)										int _g62 = 0;
HXDLIN( 268)										int _g63 = b29->width;
HXDLIN( 268)										while((_g62 < _g63)){
HXDLIN( 268)											_g62 = (_g62 + 1);
HXDLIN( 268)											int x9 = (_g62 - 1);
HXDLIN( 268)											{
HXDLIN( 268)												w3 = (w3 + 1);
HXDLIN( 268)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 268)											{
HXDLIN( 268)												w3 = (w3 + 1);
HXDLIN( 268)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 268)											{
HXDLIN( 268)												w3 = (w3 + 1);
HXDLIN( 268)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 268)											{
HXDLIN( 268)												w3 = (w3 + 1);
HXDLIN( 268)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 268)					undoImage10 = b29;
            				}
            				break;
            				case (int)1: {
HXDLIN( 268)					 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::ArrIntImg a26 = arrI3;
HXDLIN( 268)					{
HXDLIN( 268)						a26->width = width3;
HXDLIN( 268)						a26->height = height3;
HXDLIN( 268)						a26->data = ::Array_obj< int >::__new(0);
HXDLIN( 268)						a26->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 268)						{
HXDLIN( 268)							int _g64 = 0;
HXDLIN( 268)							int _g65 = a26->length;
HXDLIN( 268)							while((_g64 < _g65)){
HXDLIN( 268)								_g64 = (_g64 + 1);
HXDLIN( 268)								int i30 = (_g64 - 1);
HXDLIN( 268)								a26->data[i30] = 0;
            							}
            						}
            					}
HXDLIN( 268)					undoImage10 = a26;
            				}
            				break;
            				case (int)2: {
HXDLIN( 268)					 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::U32ArrImg b30 = u32a3;
HXDLIN( 268)					{
HXDLIN( 268)						b30->width = width3;
HXDLIN( 268)						b30->height = height3;
HXDLIN( 268)						b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 268)						int size3 = (b30->length * 4);
HXDLIN( 268)						b30->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 268)						{
HXDLIN( 268)							int _g66 = 0;
HXDLIN( 268)							int _g67 = b30->length;
HXDLIN( 268)							while((_g66 < _g67)){
HXDLIN( 268)								_g66 = (_g66 + 1);
HXDLIN( 268)								int i31 = (_g66 - 1);
HXDLIN( 268)								{
HXDLIN( 268)									 ::haxe::io::ArrayBufferViewImpl this96 = b30->data;
HXDLIN( 268)									bool undoImage11;
HXDLIN( 268)									if ((i31 >= 0)) {
HXDLIN( 268)										undoImage11 = (i31 < (this96->byteLength >> 2));
            									}
            									else {
HXDLIN( 268)										undoImage11 = false;
            									}
HXDLIN( 268)									if (undoImage11) {
HXDLIN( 268)										 ::haxe::io::Bytes _this3 = this96->bytes;
HXDLIN( 268)										int pos3 = ((i31 << 2) + this96->byteOffset);
HXDLIN( 268)										_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 268)										_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 268)										_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 268)										_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 268)					undoImage10 = b30;
            				}
            				break;
            				case (int)3: {
HXDLIN( 268)					 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN( 268)					{
HXDLIN( 268)						v9->width = width3;
HXDLIN( 268)						v9->height = height3;
HXDLIN( 268)						v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 268)						v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN( 268)						{
HXDLIN( 268)							int _g68 = 0;
HXDLIN( 268)							int _g69 = v9->length;
HXDLIN( 268)							while((_g68 < _g69)){
HXDLIN( 268)								_g68 = (_g68 + 1);
HXDLIN( 268)								int i32 = (_g68 - 1);
HXDLIN( 268)								v9->data->__unsafe_set(i32,0);
            							}
            						}
            					}
HXDLIN( 268)					undoImage10 = v9;
            				}
            				break;
            				case (int)4: {
HXDLIN( 268)					 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)					 ::iterMagic::StackIntImg b31 = sInt3;
HXDLIN( 268)					{
HXDLIN( 268)						b31->width = width3;
HXDLIN( 268)						b31->height = height3;
HXDLIN( 268)						b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 268)						b31->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 268)						{
HXDLIN( 268)							int len7 = b31->length;
HXDLIN( 268)							 ::haxe::ds::GenericStack_Int d3 = b31->data;
HXDLIN( 268)							if (::hx::IsNull( d3->head )) {
HXDLIN( 268)								int _g70 = 0;
HXDLIN( 268)								int _g71 = len7;
HXDLIN( 268)								while((_g70 < _g71)){
HXDLIN( 268)									_g70 = (_g70 + 1);
HXDLIN( 268)									int i33 = (_g70 - 1);
HXDLIN( 268)									d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            								}
            							}
            							else {
HXDLIN( 268)								int _g72 = 0;
HXDLIN( 268)								int _g73 = len7;
HXDLIN( 268)								while((_g72 < _g73)){
HXDLIN( 268)									_g72 = (_g72 + 1);
HXDLIN( 268)									int i34 = (_g72 - 1);
HXDLIN( 268)									{
HXDLIN( 268)										 ::haxe::ds::GenericCell_Int l3 = b31->data->head;
HXDLIN( 268)										 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 268)										{
HXDLIN( 268)											int _g74 = 0;
HXDLIN( 268)											int _g75 = i34;
HXDLIN( 268)											while((_g74 < _g75)){
HXDLIN( 268)												_g74 = (_g74 + 1);
HXDLIN( 268)												int i35 = (_g74 - 1);
HXLINE( 345)												prev3 = l3;
HXLINE( 346)												l3 = l3->next;
            											}
            										}
HXLINE( 268)										if (::hx::IsNull( prev3 )) {
HXDLIN( 268)											b31->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 268)											l3 = null();
            										}
            										else {
HXDLIN( 268)											prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 268)											l3 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 268)					undoImage10 = b31;
            				}
            				break;
            			}
HXDLIN( 268)			this95->image = undoImage10;
HXDLIN( 268)			this95->width = width3;
HXDLIN( 268)			this95->height = height3;
HXDLIN( 268)			this95->imageType = ( (int)(imageType3) );
HXDLIN( 268)			undoImage9 = this95;
HXDLIN( 268)			{
HXDLIN( 268)				int rectLeft3 = xIter33->start;
HXDLIN( 268)				int rectTop3 = yIter33->start;
HXDLIN( 268)				int rectRight3 = xIter33->max;
HXDLIN( 268)				bool forceClear3 = false;
HXDLIN( 268)				{
HXDLIN( 268)					int _g76 = rectTop3;
HXDLIN( 268)					int _g77 = yIter33->max;
HXDLIN( 268)					while((_g76 < _g77)){
HXDLIN( 268)						_g76 = (_g76 + 1);
HXDLIN( 268)						int dy5 = (_g76 - 1);
HXDLIN( 268)						{
HXDLIN( 268)							int _g78 = rectLeft3;
HXDLIN( 268)							int _g79 = rectRight3;
HXDLIN( 268)							while((_g78 < _g79)){
HXDLIN( 268)								_g78 = (_g78 + 1);
HXDLIN( 268)								int dx5 = (_g78 - 1);
HXDLIN( 268)								::Dynamic this97 = this1->image;
HXDLIN( 268)								int index12;
HXDLIN( 268)								if (this1->useVirtualPos) {
HXDLIN( 268)									index12 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx5) - this1->virtualX));
            								}
            								else {
HXDLIN( 268)									index12 = ::Std_obj::_hx_int(( (Float)(((dy5 * this1->width) + dx5)) ));
            								}
HXDLIN( 268)								int c9 = ::iterMagic::Iimg_obj::get(this97,index12);
HXDLIN( 268)								int col3;
HXDLIN( 268)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)									col3 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXDLIN( 268)									col3 = c9;
            								}
HXDLIN( 268)								bool _hx_tmp24;
HXDLIN( 268)								if (this1->useMask) {
HXDLIN( 268)									_hx_tmp24 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 268)									_hx_tmp24 = false;
            								}
HXDLIN( 268)								if (_hx_tmp24) {
HXDLIN( 268)									 ::pi_xy::ImageStruct this98 = this1->mask;
HXDLIN( 268)									::Dynamic this99 = this98->image;
HXDLIN( 268)									int index13;
HXDLIN( 268)									if (this98->useVirtualPos) {
HXDLIN( 268)										index13 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this98->virtualY) * ( (Float)(this98->width) )) + dx5) - this98->virtualX));
            									}
            									else {
HXDLIN( 268)										index13 = ::Std_obj::_hx_int(( (Float)(((dy5 * this98->width) + dx5)) ));
            									}
HXDLIN( 268)									int c10 = ::iterMagic::Iimg_obj::get(this99,index13);
HXDLIN( 268)									int v10;
HXDLIN( 268)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)										v10 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXDLIN( 268)										v10 = c10;
            									}
HXDLIN( 268)									int maskPixel3 = v10;
HXDLIN( 268)									int this100 = col3;
HXDLIN( 268)									if ((maskPixel3 == 0)) {
HXDLIN( 268)										col3 = this100;
            									}
            									else {
HXDLIN( 268)										Float m03;
HXDLIN( 268)										int this101 = ((maskPixel3 >> 24) & 255);
HXDLIN( 268)										if ((this101 == 0)) {
HXDLIN( 268)											m03 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											m03 = (( (Float)(this101) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float m13;
HXDLIN( 268)										int this102 = ((maskPixel3 >> 16) & 255);
HXDLIN( 268)										if ((this102 == 0)) {
HXDLIN( 268)											m13 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											m13 = (( (Float)(this102) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float m23;
HXDLIN( 268)										int this103 = ((maskPixel3 >> 8) & 255);
HXDLIN( 268)										if ((this103 == 0)) {
HXDLIN( 268)											m23 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											m23 = (( (Float)(this103) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float m33;
HXDLIN( 268)										int this104 = (maskPixel3 & 255);
HXDLIN( 268)										if ((this104 == 0)) {
HXDLIN( 268)											m33 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											m33 = (( (Float)(this104) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this100 >> 24) & 255)) )));
HXDLIN( 268)										int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this100 >> 16) & 255)) )));
HXDLIN( 268)										int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this100 >> 8) & 255)) )));
HXDLIN( 268)										int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this100 & 255)) )));
HXDLIN( 268)										col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 268)								if ((col3 != 0)) {
HXDLIN( 268)									int x10 = (dx5 - rectLeft3);
HXDLIN( 268)									int y10 = (dy5 - rectTop3);
HXDLIN( 268)									int c11 = col3;
HXDLIN( 268)									bool _hx_tmp25;
HXDLIN( 268)									if ((((c11 >> 24) & 255) < 254)) {
HXDLIN( 268)										_hx_tmp25 = undoImage9->transparent;
            									}
            									else {
HXDLIN( 268)										_hx_tmp25 = false;
            									}
HXDLIN( 268)									if (_hx_tmp25) {
HXDLIN( 268)										int location6;
HXDLIN( 268)										if (undoImage9->useVirtualPos) {
HXDLIN( 268)											location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 268)											location6 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            										}
HXDLIN( 268)										int this105 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 268)										int this106;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											this106 = ((((((this105 >> 24) & 255) << 24) | ((this105 & 255) << 16)) | (((this105 >> 8) & 255) << 8)) | ((this105 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											this106 = this105;
            										}
HXDLIN( 268)										Float a111;
HXDLIN( 268)										int this107 = ((this106 >> 24) & 255);
HXDLIN( 268)										if ((this107 == 0)) {
HXDLIN( 268)											a111 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											a111 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float r16;
HXDLIN( 268)										int this108 = ((this106 >> 16) & 255);
HXDLIN( 268)										if ((this108 == 0)) {
HXDLIN( 268)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											r16 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float g16;
HXDLIN( 268)										int this109 = ((this106 >> 8) & 255);
HXDLIN( 268)										if ((this109 == 0)) {
HXDLIN( 268)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											g16 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float b112;
HXDLIN( 268)										int this110 = (this106 & 255);
HXDLIN( 268)										if ((this110 == 0)) {
HXDLIN( 268)											b112 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											b112 = (( (Float)(this110) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float a27;
HXDLIN( 268)										int this111 = ((col3 >> 24) & 255);
HXDLIN( 268)										if ((this111 == 0)) {
HXDLIN( 268)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											a27 = (( (Float)(this111) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float r26;
HXDLIN( 268)										int this112 = ((col3 >> 16) & 255);
HXDLIN( 268)										if ((this112 == 0)) {
HXDLIN( 268)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											r26 = (( (Float)(this112) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float g26;
HXDLIN( 268)										int this113 = ((col3 >> 8) & 255);
HXDLIN( 268)										if ((this113 == 0)) {
HXDLIN( 268)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											g26 = (( (Float)(this113) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float b210;
HXDLIN( 268)										int this114 = (col3 & 255);
HXDLIN( 268)										if ((this114 == 0)) {
HXDLIN( 268)											b210 = ((Float)0.);
            										}
            										else {
HXDLIN( 268)											b210 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 268)										Float a36 = (a111 * (( (Float)(1) ) - a27));
HXDLIN( 268)										int r17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a27))));
HXDLIN( 268)										int g17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a27))));
HXDLIN( 268)										int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a27))));
HXDLIN( 268)										int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a27)));
HXDLIN( 268)										int blended6 = ((((a28 << 24) | (r17 << 16)) | (g17 << 8)) | b32);
HXDLIN( 268)										{
HXDLIN( 268)											int _hx_tmp26;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)												_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 268)												_hx_tmp26 = blended6;
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            										}
            									}
            									else {
HXDLIN( 268)										::Dynamic this115 = undoImage9->image;
HXDLIN( 268)										int index14;
HXDLIN( 268)										if (undoImage9->useVirtualPos) {
HXDLIN( 268)											index14 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 268)											index14 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            										}
HXDLIN( 268)										int _hx_tmp27;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											_hx_tmp27 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											_hx_tmp27 = c11;
            										}
HXDLIN( 268)										::iterMagic::Iimg_obj::set(this115,index14,_hx_tmp27);
            									}
            								}
            								else {
HXDLIN( 268)									if (forceClear3) {
HXDLIN( 268)										::Dynamic this116 = undoImage9->image;
HXDLIN( 268)										int x11 = (dx5 - rectLeft3);
HXDLIN( 268)										int y11 = (dy5 - rectTop3);
HXDLIN( 268)										int index15;
HXDLIN( 268)										if (undoImage9->useVirtualPos) {
HXDLIN( 268)											index15 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 268)											index15 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            										}
HXDLIN( 268)										::iterMagic::Iimg_obj::set(this116,index15,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 268)		{
HXDLIN( 268)			int _g_min6 = xIter33->start;
HXDLIN( 268)			int _g_max6 = xIter33->max;
HXDLIN( 268)			while((_g_min6 < _g_max6)){
HXDLIN( 268)				_g_min6 = (_g_min6 + 1);
HXDLIN( 268)				int px4 = (_g_min6 - 1);
HXDLIN( 268)				Float pcx3 = (( (Float)(px4) ) - dx3);
HXDLIN( 268)				{
HXDLIN( 268)					int _g_min7 = yIter33->start;
HXDLIN( 268)					int _g_max7 = yIter33->max;
HXDLIN( 268)					while((_g_min7 < _g_max7)){
HXDLIN( 268)						_g_min7 = (_g_min7 + 1);
HXDLIN( 268)						int py4 = (_g_min7 - 1);
HXDLIN( 268)						Float pcy3 = (( (Float)(py4) ) - dy3);
HXDLIN( 268)						Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 268)						Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 268)						Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 268)						Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 268)						Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 268)						bool _hx_tmp28;
HXDLIN( 268)						bool _hx_tmp29;
HXDLIN( 268)						if ((ratioA3 >= 0)) {
HXDLIN( 268)							_hx_tmp29 = (ratioB3 >= 0);
            						}
            						else {
HXDLIN( 268)							_hx_tmp29 = false;
            						}
HXDLIN( 268)						if (_hx_tmp29) {
HXDLIN( 268)							_hx_tmp28 = (ratioC3 >= 0);
            						}
            						else {
HXDLIN( 268)							_hx_tmp28 = false;
            						}
HXDLIN( 268)						if (_hx_tmp28) {
HXDLIN( 268)							int i36 = ::Std_obj::_hx_int((((( (Float)(aA3) ) * ratioA3) + (( (Float)(aB3) ) * ratioB3)) + (( (Float)(aC3) ) * ratioC3)));
HXDLIN( 268)							if ((i36 > 255)) {
HXLINE(  24)								i36 = 255;
            							}
HXLINE( 268)							if ((i36 < 0)) {
HXLINE(  25)								i36 = 0;
            							}
HXLINE( 268)							int a29 = i36;
HXDLIN( 268)							int i37 = ::Std_obj::_hx_int((((( (Float)(rA3) ) * ratioA3) + (( (Float)(rB3) ) * ratioB3)) + (( (Float)(rC3) ) * ratioC3)));
HXDLIN( 268)							if ((i37 > 255)) {
HXLINE(  24)								i37 = 255;
            							}
HXLINE( 268)							if ((i37 < 0)) {
HXLINE(  25)								i37 = 0;
            							}
HXLINE( 268)							int r18 = i37;
HXDLIN( 268)							int i38 = ::Std_obj::_hx_int((((( (Float)(gA3) ) * ratioA3) + (( (Float)(gB3) ) * ratioB3)) + (( (Float)(gC3) ) * ratioC3)));
HXDLIN( 268)							if ((i38 > 255)) {
HXLINE(  24)								i38 = 255;
            							}
HXLINE( 268)							if ((i38 < 0)) {
HXLINE(  25)								i38 = 0;
            							}
HXLINE( 268)							int g18 = i38;
HXDLIN( 268)							int i39 = ::Std_obj::_hx_int((((( (Float)(bA3) ) * ratioA3) + (( (Float)(bB3) ) * ratioB3)) + (( (Float)(bC3) ) * ratioC3)));
HXDLIN( 268)							if ((i39 > 255)) {
HXLINE(  24)								i39 = 255;
            							}
HXLINE( 268)							if ((i39 < 0)) {
HXLINE(  25)								i39 = 0;
            							}
HXLINE( 268)							int b33 = i39;
HXDLIN( 268)							{
HXDLIN( 268)								int location7;
HXDLIN( 268)								if (this1->useVirtualPos) {
HXDLIN( 268)									location7 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - this1->virtualY) * ( (Float)(this1->width) )) + px4) - this1->virtualX));
            								}
            								else {
HXDLIN( 268)									location7 = ::Std_obj::_hx_int(( (Float)(((py4 * this1->width) + px4)) ));
            								}
HXDLIN( 268)								bool _hx_tmp30;
HXDLIN( 268)								if (this1->transparent) {
HXDLIN( 268)									_hx_tmp30 = (a29 < 254);
            								}
            								else {
HXDLIN( 268)									_hx_tmp30 = false;
            								}
HXDLIN( 268)								if (_hx_tmp30) {
HXDLIN( 268)									int this117 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN( 268)									int old3;
HXDLIN( 268)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)										old3 = ((((((this117 >> 24) & 255) << 24) | ((this117 & 255) << 16)) | (((this117 >> 8) & 255) << 8)) | ((this117 >> 16) & 255));
            									}
            									else {
HXDLIN( 268)										old3 = this117;
            									}
HXDLIN( 268)									int rhs3 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b33);
HXDLIN( 268)									Float a112;
HXDLIN( 268)									int this118 = ((old3 >> 24) & 255);
HXDLIN( 268)									if ((this118 == 0)) {
HXDLIN( 268)										a112 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										a112 = (( (Float)(this118) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float r19;
HXDLIN( 268)									int this119 = ((old3 >> 16) & 255);
HXDLIN( 268)									if ((this119 == 0)) {
HXDLIN( 268)										r19 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										r19 = (( (Float)(this119) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float g19;
HXDLIN( 268)									int this120 = ((old3 >> 8) & 255);
HXDLIN( 268)									if ((this120 == 0)) {
HXDLIN( 268)										g19 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										g19 = (( (Float)(this120) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float b113;
HXDLIN( 268)									int this121 = (old3 & 255);
HXDLIN( 268)									if ((this121 == 0)) {
HXDLIN( 268)										b113 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										b113 = (( (Float)(this121) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float a210;
HXDLIN( 268)									int this122 = ((rhs3 >> 24) & 255);
HXDLIN( 268)									if ((this122 == 0)) {
HXDLIN( 268)										a210 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										a210 = (( (Float)(this122) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float r27;
HXDLIN( 268)									int this123 = ((rhs3 >> 16) & 255);
HXDLIN( 268)									if ((this123 == 0)) {
HXDLIN( 268)										r27 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										r27 = (( (Float)(this123) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float g27;
HXDLIN( 268)									int this124 = ((rhs3 >> 8) & 255);
HXDLIN( 268)									if ((this124 == 0)) {
HXDLIN( 268)										g27 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										g27 = (( (Float)(this124) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float b211;
HXDLIN( 268)									int this125 = (rhs3 & 255);
HXDLIN( 268)									if ((this125 == 0)) {
HXDLIN( 268)										b211 = ((Float)0.);
            									}
            									else {
HXDLIN( 268)										b211 = (( (Float)(this125) ) / ( (Float)(255) ));
            									}
HXDLIN( 268)									Float a37 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 268)									int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a37) + (r27 * a210))));
HXDLIN( 268)									int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a37) + (g27 * a210))));
HXDLIN( 268)									int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a210))));
HXDLIN( 268)									int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a210)));
HXDLIN( 268)									int blended7 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b34);
HXDLIN( 268)									{
HXDLIN( 268)										int _hx_tmp31;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 268)											_hx_tmp31 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            										}
            										else {
HXDLIN( 268)											_hx_tmp31 = blended7;
            										}
HXDLIN( 268)										::iterMagic::Iimg_obj::set(this1->image,location7,_hx_tmp31);
            									}
            								}
            								else {
HXDLIN( 268)									int value3;
HXDLIN( 268)									if (this1->isLittle) {
HXDLIN( 268)										value3 = ((((a29 << 24) | (b33 << 16)) | (g18 << 8)) | r18);
            									}
            									else {
HXDLIN( 268)										value3 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b33);
            									}
HXDLIN( 268)									::iterMagic::Iimg_obj::set(this1->image,location7,value3);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 268)		 ::pi_xy::algo::HitTri hitTriBottom;
HXDLIN( 268)		if ((hasHit == false)) {
HXDLIN( 268)			 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,px,py,ax1,ay1,dx3,dy3,true);
HXDLIN( 268)			if (hasUndo3) {
HXDLIN( 268)				v11->undoImage = undoImage9;
HXDLIN( 268)				v11->undoX = xIter33->start;
HXDLIN( 268)				v11->undoY = yIter33->start;
            			}
HXDLIN( 268)			hitTriBottom = v11;
            		}
            		else {
HXDLIN( 268)			hitTriBottom = null();
            		}
HXDLIN( 268)		if (hasHit) {
HXDLIN( 268)			 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN( 268)			if (::hx::IsNotNull( hitQuad )) {
HXDLIN( 268)				hitArr->triArr->push(hitQuad->triABD);
            			}
HXDLIN( 268)			hitArr->triArr->push(hitQuad->triBCD);
HXDLIN( 268)			return hitArr;
            		}
            		else {
HXDLIN( 268)			return null();
            		}
HXDLIN( 268)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(GradientShape_Impl__obj,thickFixArrowBoth,return )

void GradientShape_Impl__obj::RoundRectangle( ::pi_xy::ImageStruct this1,Float x,Float y,Float hi,Float wid,int colorA,int colorB,int colorC,int colorD, ::Dynamic __o_dx, ::Dynamic __o_dy, ::Dynamic __o_fat, ::Dynamic __o_tall){
            		 ::Dynamic dx = __o_dx;
            		if (::hx::IsNull(__o_dx)) dx = ((Float)-1.);
            		 ::Dynamic dy = __o_dy;
            		if (::hx::IsNull(__o_dy)) dy = ((Float)-1.);
            		 ::Dynamic fat = __o_fat;
            		if (::hx::IsNull(__o_fat)) fat = ((Float)-1.);
            		 ::Dynamic tall = __o_tall;
            		if (::hx::IsNull(__o_tall)) tall = ((Float)-1.);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_289_RoundRectangle)
HXDLIN( 289)		 ::Dynamic dx1 = dx;
HXDLIN( 289)		 ::Dynamic dy1 = dy;
HXDLIN( 289)		 ::Dynamic fat1 = fat;
HXDLIN( 289)		 ::Dynamic tall1 = tall;
HXLINE( 294)		if (::hx::IsNull( tall1 )) {
HXLINE( 294)			tall1 = ((Float)-1.);
            		}
HXDLIN( 294)		if (::hx::IsNull( fat1 )) {
HXLINE( 294)			fat1 = ((Float)-1.);
            		}
HXLINE( 293)		if (::hx::IsNull( dy1 )) {
HXLINE( 293)			dy1 = ((Float)-1.);
            		}
HXDLIN( 293)		if (::hx::IsNull( dx1 )) {
HXLINE( 293)			dx1 = ((Float)-1.);
            		}
HXLINE( 289)		if (::hx::IsLess( dx1,((Float)0.) )) {
HXDLIN( 289)			Float smallest;
HXDLIN( 289)			if ((hi < wid)) {
HXDLIN( 289)				smallest = hi;
            			}
            			else {
HXDLIN( 289)				smallest = wid;
            			}
HXDLIN( 289)			Float goldenRatio = ((Float)1.61803398875);
HXLINE( 106)			dx1 = (smallest / (goldenRatio + 2));
            		}
HXLINE( 289)		if (::hx::IsLess( dy1,((Float)0.) )) {
HXLINE( 108)			dy1 = dx1;
            		}
HXLINE( 289)		if (::hx::IsLess( fat1,((Float)0.) )) {
HXLINE( 109)			fat1 = (wid - (( (Float)(2) ) * ( (Float)(dx1) )));
            		}
HXLINE( 289)		if (::hx::IsLess( tall1,((Float)0.) )) {
HXLINE( 110)			tall1 = (hi - (( (Float)(2) ) * ( (Float)(dy1) )));
            		}
HXLINE( 289)		Float rightRadius = ((wid - ( (Float)(fat1) )) - ( (Float)(dx1) ));
HXDLIN( 289)		Float bottomRadius = ((hi - ( (Float)(tall1) )) - ( (Float)(dy1) ));
HXDLIN( 289)		Float farX = ((x + dx1) + fat1);
HXDLIN( 289)		Float lowerY = ((y + dy1) + tall1);
HXDLIN( 289)		{
HXDLIN( 289)			 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 289)			Float cx = (x + dx1);
HXDLIN( 289)			Float cy = (y + dy1);
HXDLIN( 289)			Float rx = ( (Float)(dx1) );
HXDLIN( 289)			Float ry = ( (Float)(dy1) );
HXDLIN( 289)			{
HXDLIN( 289)				 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 289)				if (::hx::IsNull( targetError )) {
HXLINE( 113)					targetError = ((Float)1.05);
            				}
HXLINE( 289)				Float rSmall;
HXDLIN( 289)				if ((rx > ry)) {
HXDLIN( 289)					rSmall = ry;
            				}
            				else {
HXDLIN( 289)					rSmall = rx;
            				}
HXDLIN( 289)				 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 289)				if (::hx::IsNull( targetE )) {
HXLINE(  20)					targetE = ((Float)1.05);
            				}
HXLINE( 289)				int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 289)				int noSides;
HXDLIN( 289)				if ((result < 12)) {
HXDLIN( 289)					noSides = 12;
            				}
            				else {
HXDLIN( 289)					if ((result > 500)) {
HXDLIN( 289)						noSides = 500;
            					}
            					else {
HXDLIN( 289)						noSides = result;
            					}
            				}
HXDLIN( 289)				int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 289)				Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 289)				Float omega = ::Math_obj::PI;
HXDLIN( 289)				int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 289)				Float lastX = ((Float)0.);
HXDLIN( 289)				Float lastY = ((Float)0.);
HXDLIN( 289)				{
HXLINE(  26)					lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)					lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            				}
HXLINE( 289)				{
HXDLIN( 289)					int _g = 0;
HXDLIN( 289)					int _g1 = (quarter + 1);
HXDLIN( 289)					while((_g < _g1)){
HXDLIN( 289)						_g = (_g + 1);
HXDLIN( 289)						int i = (_g - 1);
HXDLIN( 289)						Float nextX = (cx + (rx * ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 289)						Float nextY = (cy + (ry * ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 289)						{
HXDLIN( 289)							 ::pi_xy::ImageStruct this3 = this2;
HXDLIN( 289)							bool hasHit = false;
HXDLIN( 289)							bool hasUndo = false;
HXDLIN( 289)							{
HXDLIN( 289)								Float bx = lastX;
HXDLIN( 289)								Float by = lastY;
HXDLIN( 289)								Float cx1 = nextX;
HXDLIN( 289)								Float cy1 = nextY;
HXDLIN( 289)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 289)								if (!(adjustWinding)) {
HXDLIN( 289)									Float bx_ = bx;
HXDLIN( 289)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 289)								{
HXDLIN( 289)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 289)									Float sx = (cy1 - cy);
HXDLIN( 289)									Float sy = (cx - cx1);
HXDLIN( 289)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 289)									Float tx = (cy - by);
HXDLIN( 289)									Float ty = (bx - cx);
HXDLIN( 289)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 289)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 289)									if ((cx > bx)) {
HXDLIN( 289)										if ((cx > cx1)) {
HXDLIN( 289)											int min;
HXDLIN( 289)											if ((bx > cx1)) {
HXDLIN( 289)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 289)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 289)											int ii_min = min;
HXDLIN( 289)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 289)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 289)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 289)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 289)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 289)										if ((bx > cx1)) {
HXDLIN( 289)											int min1;
HXDLIN( 289)											if ((cx > cx1)) {
HXDLIN( 289)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 289)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 289)											int ii_min2 = min1;
HXDLIN( 289)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 289)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 289)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 289)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 289)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 289)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 289)									if ((cy > by)) {
HXDLIN( 289)										if ((cy > cy1)) {
HXDLIN( 289)											int min2;
HXDLIN( 289)											if ((by > cy1)) {
HXDLIN( 289)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 289)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 289)											int ii_min4 = min2;
HXDLIN( 289)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 289)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 289)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 289)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 289)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 289)										if ((by > cy1)) {
HXDLIN( 289)											int min3;
HXDLIN( 289)											if ((cy > cy1)) {
HXDLIN( 289)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 289)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 289)											int ii_min6 = min3;
HXDLIN( 289)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 289)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 289)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 289)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 289)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 289)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 289)									if (hasUndo) {
HXDLIN( 289)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 289)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 289)										 ::Dynamic imageType = null();
HXDLIN( 289)										 ::pi_xy::ImageStruct this4 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 289)										::Dynamic undoImage1;
HXDLIN( 289)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 289)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 289)												{
HXDLIN( 289)													b->width = width;
HXDLIN( 289)													b->height = height;
HXDLIN( 289)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 289)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 289)													{
HXDLIN( 289)														int len = b->length;
HXDLIN( 289)														int w = 0;
HXDLIN( 289)														{
HXDLIN( 289)															int _g2 = 0;
HXDLIN( 289)															int _g3 = b->height;
HXDLIN( 289)															while((_g2 < _g3)){
HXDLIN( 289)																_g2 = (_g2 + 1);
HXDLIN( 289)																int y1 = (_g2 - 1);
HXDLIN( 289)																{
HXDLIN( 289)																	int _g4 = 0;
HXDLIN( 289)																	int _g5 = b->width;
HXDLIN( 289)																	while((_g4 < _g5)){
HXDLIN( 289)																		_g4 = (_g4 + 1);
HXDLIN( 289)																		int x1 = (_g4 - 1);
HXDLIN( 289)																		{
HXDLIN( 289)																			w = (w + 1);
HXDLIN( 289)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w = (w + 1);
HXDLIN( 289)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w = (w + 1);
HXDLIN( 289)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w = (w + 1);
HXDLIN( 289)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 289)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 289)												{
HXDLIN( 289)													a->width = width;
HXDLIN( 289)													a->height = height;
HXDLIN( 289)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 289)													{
HXDLIN( 289)														int _g6 = 0;
HXDLIN( 289)														int _g7 = a->length;
HXDLIN( 289)														while((_g6 < _g7)){
HXDLIN( 289)															_g6 = (_g6 + 1);
HXDLIN( 289)															int i1 = (_g6 - 1);
HXDLIN( 289)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 289)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 289)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 289)												{
HXDLIN( 289)													b1->width = width;
HXDLIN( 289)													b1->height = height;
HXDLIN( 289)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 289)													int size = (b1->length * 4);
HXDLIN( 289)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 289)													{
HXDLIN( 289)														int _g8 = 0;
HXDLIN( 289)														int _g9 = b1->length;
HXDLIN( 289)														while((_g8 < _g9)){
HXDLIN( 289)															_g8 = (_g8 + 1);
HXDLIN( 289)															int i2 = (_g8 - 1);
HXDLIN( 289)															{
HXDLIN( 289)																 ::haxe::io::ArrayBufferViewImpl this5 = b1->data;
HXDLIN( 289)																bool undoImage2;
HXDLIN( 289)																if ((i2 >= 0)) {
HXDLIN( 289)																	undoImage2 = (i2 < (this5->byteLength >> 2));
            																}
            																else {
HXDLIN( 289)																	undoImage2 = false;
            																}
HXDLIN( 289)																if (undoImage2) {
HXDLIN( 289)																	 ::haxe::io::Bytes _this = this5->bytes;
HXDLIN( 289)																	int pos = ((i2 << 2) + this5->byteOffset);
HXDLIN( 289)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 289)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::VecIntImg v = vec;
HXDLIN( 289)												{
HXDLIN( 289)													v->width = width;
HXDLIN( 289)													v->height = height;
HXDLIN( 289)													v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 289)													v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 289)													{
HXDLIN( 289)														int _g10 = 0;
HXDLIN( 289)														int _g11 = v->length;
HXDLIN( 289)														while((_g10 < _g11)){
HXDLIN( 289)															_g10 = (_g10 + 1);
HXDLIN( 289)															int i3 = (_g10 - 1);
HXDLIN( 289)															v->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 289)												undoImage1 = v;
            											}
            											break;
            											case (int)4: {
HXDLIN( 289)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 289)												{
HXDLIN( 289)													b2->width = width;
HXDLIN( 289)													b2->height = height;
HXDLIN( 289)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 289)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)													{
HXDLIN( 289)														int len1 = b2->length;
HXDLIN( 289)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 289)														if (::hx::IsNull( d->head )) {
HXDLIN( 289)															int _g12 = 0;
HXDLIN( 289)															int _g13 = len1;
HXDLIN( 289)															while((_g12 < _g13)){
HXDLIN( 289)																_g12 = (_g12 + 1);
HXDLIN( 289)																int i4 = (_g12 - 1);
HXDLIN( 289)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 289)															int _g14 = 0;
HXDLIN( 289)															int _g15 = len1;
HXDLIN( 289)															while((_g14 < _g15)){
HXDLIN( 289)																_g14 = (_g14 + 1);
HXDLIN( 289)																int i5 = (_g14 - 1);
HXDLIN( 289)																{
HXDLIN( 289)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 289)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 289)																	{
HXDLIN( 289)																		int _g16 = 0;
HXDLIN( 289)																		int _g17 = i5;
HXDLIN( 289)																		while((_g16 < _g17)){
HXDLIN( 289)																			_g16 = (_g16 + 1);
HXDLIN( 289)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 289)																	if (::hx::IsNull( prev )) {
HXDLIN( 289)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 289)																		l = null();
            																	}
            																	else {
HXDLIN( 289)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 289)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 289)										this4->image = undoImage1;
HXDLIN( 289)										this4->width = width;
HXDLIN( 289)										this4->height = height;
HXDLIN( 289)										this4->imageType = ( (int)(imageType) );
HXDLIN( 289)										undoImage = this4;
HXDLIN( 289)										{
HXDLIN( 289)											int rectLeft = xIter3->start;
HXDLIN( 289)											int rectTop = yIter3->start;
HXDLIN( 289)											int rectRight = xIter3->max;
HXDLIN( 289)											bool forceClear = false;
HXDLIN( 289)											{
HXDLIN( 289)												int _g18 = rectTop;
HXDLIN( 289)												int _g19 = yIter3->max;
HXDLIN( 289)												while((_g18 < _g19)){
HXDLIN( 289)													_g18 = (_g18 + 1);
HXDLIN( 289)													int dy2 = (_g18 - 1);
HXDLIN( 289)													{
HXDLIN( 289)														int _g20 = rectLeft;
HXDLIN( 289)														int _g21 = rectRight;
HXDLIN( 289)														while((_g20 < _g21)){
HXDLIN( 289)															_g20 = (_g20 + 1);
HXDLIN( 289)															int dx2 = (_g20 - 1);
HXDLIN( 289)															::Dynamic this6 = this3->image;
HXDLIN( 289)															int index;
HXDLIN( 289)															if (this3->useVirtualPos) {
HXDLIN( 289)																index = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this3->virtualY) * ( (Float)(this3->width) )) + dx2) - this3->virtualX));
            															}
            															else {
HXDLIN( 289)																index = ::Std_obj::_hx_int(( (Float)(((dy2 * this3->width) + dx2)) ));
            															}
HXDLIN( 289)															int c = ::iterMagic::Iimg_obj::get(this6,index);
HXDLIN( 289)															int col;
HXDLIN( 289)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 289)																col = c;
            															}
HXDLIN( 289)															bool _hx_tmp;
HXDLIN( 289)															if (this3->useMask) {
HXDLIN( 289)																_hx_tmp = ::hx::IsNotNull( this3->mask );
            															}
            															else {
HXDLIN( 289)																_hx_tmp = false;
            															}
HXDLIN( 289)															if (_hx_tmp) {
HXDLIN( 289)																 ::pi_xy::ImageStruct this7 = this3->mask;
HXDLIN( 289)																::Dynamic this8 = this7->image;
HXDLIN( 289)																int index1;
HXDLIN( 289)																if (this7->useVirtualPos) {
HXDLIN( 289)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this7->virtualY) * ( (Float)(this7->width) )) + dx2) - this7->virtualX));
            																}
            																else {
HXDLIN( 289)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy2 * this7->width) + dx2)) ));
            																}
HXDLIN( 289)																int c1 = ::iterMagic::Iimg_obj::get(this8,index1);
HXDLIN( 289)																int v1;
HXDLIN( 289)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																	v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 289)																	v1 = c1;
            																}
HXDLIN( 289)																int maskPixel = v1;
HXDLIN( 289)																int this9 = col;
HXDLIN( 289)																if ((maskPixel == 0)) {
HXDLIN( 289)																	col = this9;
            																}
            																else {
HXDLIN( 289)																	Float m0;
HXDLIN( 289)																	int this10 = ((maskPixel >> 24) & 255);
HXDLIN( 289)																	if ((this10 == 0)) {
HXDLIN( 289)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m0 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m1;
HXDLIN( 289)																	int this11 = ((maskPixel >> 16) & 255);
HXDLIN( 289)																	if ((this11 == 0)) {
HXDLIN( 289)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m1 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m2;
HXDLIN( 289)																	int this12 = ((maskPixel >> 8) & 255);
HXDLIN( 289)																	if ((this12 == 0)) {
HXDLIN( 289)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m3;
HXDLIN( 289)																	int this13 = (maskPixel & 255);
HXDLIN( 289)																	if ((this13 == 0)) {
HXDLIN( 289)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m3 = (( (Float)(this13) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this9 >> 24) & 255)) )));
HXDLIN( 289)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this9 >> 16) & 255)) )));
HXDLIN( 289)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this9 >> 8) & 255)) )));
HXDLIN( 289)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this9 & 255)) )));
HXDLIN( 289)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 289)															if ((col != 0)) {
HXDLIN( 289)																int x2 = (dx2 - rectLeft);
HXDLIN( 289)																int y2 = (dy2 - rectTop);
HXDLIN( 289)																int c2 = col;
HXDLIN( 289)																bool _hx_tmp1;
HXDLIN( 289)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 289)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 289)																	_hx_tmp1 = false;
            																}
HXDLIN( 289)																if (_hx_tmp1) {
HXDLIN( 289)																	int location;
HXDLIN( 289)																	if (undoImage->useVirtualPos) {
HXDLIN( 289)																		location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		location = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 289)																	int this14 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 289)																	int this15;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		this15 = this14;
            																	}
HXDLIN( 289)																	Float a1;
HXDLIN( 289)																	int this16 = ((this15 >> 24) & 255);
HXDLIN( 289)																	if ((this16 == 0)) {
HXDLIN( 289)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r1;
HXDLIN( 289)																	int this17 = ((this15 >> 16) & 255);
HXDLIN( 289)																	if ((this17 == 0)) {
HXDLIN( 289)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g1;
HXDLIN( 289)																	int this18 = ((this15 >> 8) & 255);
HXDLIN( 289)																	if ((this18 == 0)) {
HXDLIN( 289)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g1 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b11;
HXDLIN( 289)																	int this19 = (this15 & 255);
HXDLIN( 289)																	if ((this19 == 0)) {
HXDLIN( 289)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a2;
HXDLIN( 289)																	int this20 = ((col >> 24) & 255);
HXDLIN( 289)																	if ((this20 == 0)) {
HXDLIN( 289)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r2;
HXDLIN( 289)																	int this21 = ((col >> 16) & 255);
HXDLIN( 289)																	if ((this21 == 0)) {
HXDLIN( 289)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g2;
HXDLIN( 289)																	int this22 = ((col >> 8) & 255);
HXDLIN( 289)																	if ((this22 == 0)) {
HXDLIN( 289)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g2 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b21;
HXDLIN( 289)																	int this23 = (col & 255);
HXDLIN( 289)																	if ((this23 == 0)) {
HXDLIN( 289)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 289)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 289)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 289)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 289)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 289)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 289)																	{
HXDLIN( 289)																		int _hx_tmp2;
HXDLIN( 289)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 289)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 289)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 289)																	::Dynamic this24 = undoImage->image;
HXDLIN( 289)																	int index2;
HXDLIN( 289)																	if (undoImage->useVirtualPos) {
HXDLIN( 289)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index2 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 289)																	int _hx_tmp3;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this24,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 289)																if (forceClear) {
HXDLIN( 289)																	::Dynamic this25 = undoImage->image;
HXDLIN( 289)																	int x3 = (dx2 - rectLeft);
HXDLIN( 289)																	int y3 = (dy2 - rectTop);
HXDLIN( 289)																	int index3;
HXDLIN( 289)																	if (undoImage->useVirtualPos) {
HXDLIN( 289)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this25,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 289)									bool found = false;
HXDLIN( 289)									Float s = ((Float)0.);
HXDLIN( 289)									Float t = ((Float)0.);
HXDLIN( 289)									Float sxx = ((Float)0.);
HXDLIN( 289)									Float txx = ((Float)0.);
HXDLIN( 289)									{
HXDLIN( 289)										int _g_min = xIter3->start;
HXDLIN( 289)										int _g_max = xIter3->max;
HXDLIN( 289)										while((_g_min < _g_max)){
HXDLIN( 289)											_g_min = (_g_min + 1);
HXDLIN( 289)											int x4 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x4) ));
HXLINE(  61)											txx = (tx * ( (Float)(x4) ));
HXLINE(  62)											found = false;
HXLINE( 289)											{
HXDLIN( 289)												int _g_min1 = yIter3->start;
HXDLIN( 289)												int _g_max1 = yIter3->max;
HXDLIN( 289)												while((_g_min1 < _g_max1)){
HXDLIN( 289)													_g_min1 = (_g_min1 + 1);
HXDLIN( 289)													int y4 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y4) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y4) )));
HXLINE( 289)													bool _hx_tmp4;
HXDLIN( 289)													if (!((s <= 0))) {
HXDLIN( 289)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 289)														_hx_tmp4 = true;
            													}
HXDLIN( 289)													if (_hx_tmp4) {
HXDLIN( 289)														if (found) {
HXDLIN( 289)															goto _hx_goto_512;
            														}
            													}
            													else {
HXDLIN( 289)														if (((s + t) < A)) {
HXDLIN( 289)															{
HXDLIN( 289)																int c3 = colorA;
HXDLIN( 289)																bool _hx_tmp5;
HXDLIN( 289)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 289)																	_hx_tmp5 = this3->transparent;
            																}
            																else {
HXDLIN( 289)																	_hx_tmp5 = false;
            																}
HXDLIN( 289)																if (_hx_tmp5) {
HXDLIN( 289)																	int location1;
HXDLIN( 289)																	if (this3->useVirtualPos) {
HXDLIN( 289)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this3->virtualY) * ( (Float)(this3->width) )) + x4) - this3->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		location1 = ::Std_obj::_hx_int(( (Float)(((y4 * this3->width) + x4)) ));
            																	}
HXDLIN( 289)																	int this26 = ::iterMagic::Iimg_obj::get(this3->image,location1);
HXDLIN( 289)																	int this27;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		this27 = this26;
            																	}
HXDLIN( 289)																	Float a11;
HXDLIN( 289)																	int this28 = ((this27 >> 24) & 255);
HXDLIN( 289)																	if ((this28 == 0)) {
HXDLIN( 289)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r11;
HXDLIN( 289)																	int this29 = ((this27 >> 16) & 255);
HXDLIN( 289)																	if ((this29 == 0)) {
HXDLIN( 289)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g11;
HXDLIN( 289)																	int this30 = ((this27 >> 8) & 255);
HXDLIN( 289)																	if ((this30 == 0)) {
HXDLIN( 289)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b12;
HXDLIN( 289)																	int this31 = (this27 & 255);
HXDLIN( 289)																	if ((this31 == 0)) {
HXDLIN( 289)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a21;
HXDLIN( 289)																	int this32 = ((colorA >> 24) & 255);
HXDLIN( 289)																	if ((this32 == 0)) {
HXDLIN( 289)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r21;
HXDLIN( 289)																	int this33 = ((colorA >> 16) & 255);
HXDLIN( 289)																	if ((this33 == 0)) {
HXDLIN( 289)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g21;
HXDLIN( 289)																	int this34 = ((colorA >> 8) & 255);
HXDLIN( 289)																	if ((this34 == 0)) {
HXDLIN( 289)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b22;
HXDLIN( 289)																	int this35 = (colorA & 255);
HXDLIN( 289)																	if ((this35 == 0)) {
HXDLIN( 289)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 289)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 289)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 289)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 289)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 289)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 289)																	{
HXDLIN( 289)																		int _hx_tmp6;
HXDLIN( 289)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 289)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 289)																		::iterMagic::Iimg_obj::set(this3->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 289)																	::Dynamic this36 = this3->image;
HXDLIN( 289)																	int index4;
HXDLIN( 289)																	if (this3->useVirtualPos) {
HXDLIN( 289)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this3->virtualY) * ( (Float)(this3->width) )) + x4) - this3->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index4 = ::Std_obj::_hx_int(( (Float)(((y4 * this3->width) + x4)) ));
            																	}
HXDLIN( 289)																	int _hx_tmp7;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this36,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 289)															if (found) {
HXDLIN( 289)																goto _hx_goto_512;
            															}
            														}
            													}
            												}
            												_hx_goto_512:;
            											}
            										}
            									}
HXDLIN( 289)									if ((hasHit == true)) {
HXDLIN( 289)										 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 289)										if (hasUndo) {
HXDLIN( 289)											v2->undoImage = undoImage;
HXDLIN( 289)											v2->undoX = xIter3->start;
HXDLIN( 289)											v2->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  46)						lastX = nextX;
HXLINE(  47)						lastY = nextY;
            					}
            				}
            			}
            		}
HXLINE( 289)		 ::pi_xy::ImageStruct this37 = this1;
HXDLIN( 289)		Float x5 = (x + dx1);
HXDLIN( 289)		Float bx1 = (x5 + ( (Float)(fat1) ));
HXDLIN( 289)		Float cy2 = (y + ( (Float)(dy1) ));
HXDLIN( 289)		{
HXDLIN( 289)			bool hasHit1 = true;
HXDLIN( 289)			{
HXDLIN( 289)				{
HXDLIN( 289)					bool hasUndo1 = false;
HXDLIN( 289)					int aA = ((colorC >> 24) & 255);
HXDLIN( 289)					int rA = ((colorC >> 16) & 255);
HXDLIN( 289)					int gA = ((colorC >> 8) & 255);
HXDLIN( 289)					int bA = (colorC & 255);
HXDLIN( 289)					int aB = ((colorA >> 24) & 255);
HXDLIN( 289)					int rB = ((colorA >> 16) & 255);
HXDLIN( 289)					int gB = ((colorA >> 8) & 255);
HXDLIN( 289)					int bB = (colorA & 255);
HXDLIN( 289)					int aC = ((colorA >> 24) & 255);
HXDLIN( 289)					int rC = ((colorA >> 16) & 255);
HXDLIN( 289)					int gC = ((colorA >> 8) & 255);
HXDLIN( 289)					int bC = (colorA & 255);
HXDLIN( 289)					Float bcx = (bx1 - x5);
HXDLIN( 289)					Float bcy = (y - cy2);
HXDLIN( 289)					Float acx = (x5 - x5);
HXDLIN( 289)					Float acy = (y - cy2);
HXDLIN( 289)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 289)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 289)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 289)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 289)					if ((x5 > bx1)) {
HXDLIN( 289)						if ((x5 > x5)) {
HXDLIN( 289)							int min4;
HXDLIN( 289)							if ((bx1 > x5)) {
HXDLIN( 289)								min4 = ::Math_obj::floor(x5);
            							}
            							else {
HXDLIN( 289)								min4 = ::Math_obj::floor(bx1);
            							}
HXDLIN( 289)							int ii_min8 = min4;
HXDLIN( 289)							int ii_max8 = ::Math_obj::ceil(x5);
HXDLIN( 289)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            						}
            						else {
HXDLIN( 289)							int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 289)							int ii_max9 = ::Math_obj::ceil(x5);
HXDLIN( 289)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx1 > x5)) {
HXDLIN( 289)							int min5;
HXDLIN( 289)							if ((x5 > x5)) {
HXDLIN( 289)								min5 = ::Math_obj::floor(x5);
            							}
            							else {
HXDLIN( 289)								min5 = ::Math_obj::ceil(x5);
            							}
HXDLIN( 289)							int ii_min10 = min5;
HXDLIN( 289)							int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 289)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXDLIN( 289)							int ii_min11 = ::Math_obj::floor(x5);
HXDLIN( 289)							int ii_max11 = ::Math_obj::ceil(x5);
HXDLIN( 289)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 289)					if ((y > y)) {
HXDLIN( 289)						if ((y > cy2)) {
HXDLIN( 289)							int min6;
HXDLIN( 289)							if ((y > cy2)) {
HXDLIN( 289)								min6 = ::Math_obj::floor(cy2);
            							}
            							else {
HXDLIN( 289)								min6 = ::Math_obj::floor(y);
            							}
HXDLIN( 289)							int ii_min12 = min6;
HXDLIN( 289)							int ii_max12 = ::Math_obj::ceil(y);
HXDLIN( 289)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXDLIN( 289)							int ii_min13 = ::Math_obj::floor(y);
HXDLIN( 289)							int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 289)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
            					else {
HXDLIN( 289)						if ((y > cy2)) {
HXDLIN( 289)							int min7;
HXDLIN( 289)							if ((y > cy2)) {
HXDLIN( 289)								min7 = ::Math_obj::floor(cy2);
            							}
            							else {
HXDLIN( 289)								min7 = ::Math_obj::ceil(y);
            							}
HXDLIN( 289)							int ii_min14 = min7;
HXDLIN( 289)							int ii_max14 = ::Math_obj::ceil(y);
HXDLIN( 289)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXDLIN( 289)							int ii_min15 = ::Math_obj::floor(y);
HXDLIN( 289)							int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 289)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 289)					if (hasUndo1) {
HXDLIN( 289)						int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 289)						int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType1 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType1 )) {
HXLINE(  54)							imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage4;
HXDLIN( 289)						switch((int)(( (int)(imageType1) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 289)								{
HXDLIN( 289)									b5->width = width1;
HXDLIN( 289)									b5->height = height1;
HXDLIN( 289)									b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 289)									b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len2 = b5->length;
HXDLIN( 289)										int w1 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g22 = 0;
HXDLIN( 289)											int _g23 = b5->height;
HXDLIN( 289)											while((_g22 < _g23)){
HXDLIN( 289)												_g22 = (_g22 + 1);
HXDLIN( 289)												int y5 = (_g22 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g24 = 0;
HXDLIN( 289)													int _g25 = b5->width;
HXDLIN( 289)													while((_g24 < _g25)){
HXDLIN( 289)														_g24 = (_g24 + 1);
HXDLIN( 289)														int x6 = (_g24 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w1 = (w1 + 1);
HXDLIN( 289)															b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w1 = (w1 + 1);
HXDLIN( 289)															b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w1 = (w1 + 1);
HXDLIN( 289)															b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w1 = (w1 + 1);
HXDLIN( 289)															b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage4 = b5;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 289)								{
HXDLIN( 289)									a6->width = width1;
HXDLIN( 289)									a6->height = height1;
HXDLIN( 289)									a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g26 = 0;
HXDLIN( 289)										int _g27 = a6->length;
HXDLIN( 289)										while((_g26 < _g27)){
HXDLIN( 289)											_g26 = (_g26 + 1);
HXDLIN( 289)											int i7 = (_g26 - 1);
HXDLIN( 289)											a6->data[i7] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage4 = a6;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 289)								{
HXDLIN( 289)									b6->width = width1;
HXDLIN( 289)									b6->height = height1;
HXDLIN( 289)									b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 289)									int size1 = (b6->length * 4);
HXDLIN( 289)									b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g28 = 0;
HXDLIN( 289)										int _g29 = b6->length;
HXDLIN( 289)										while((_g28 < _g29)){
HXDLIN( 289)											_g28 = (_g28 + 1);
HXDLIN( 289)											int i8 = (_g28 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this39 = b6->data;
HXDLIN( 289)												bool undoImage5;
HXDLIN( 289)												if ((i8 >= 0)) {
HXDLIN( 289)													undoImage5 = (i8 < (this39->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage5 = false;
            												}
HXDLIN( 289)												if (undoImage5) {
HXDLIN( 289)													 ::haxe::io::Bytes _this1 = this39->bytes;
HXDLIN( 289)													int pos1 = ((i8 << 2) + this39->byteOffset);
HXDLIN( 289)													_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 289)													_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage4 = b6;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 289)								{
HXDLIN( 289)									v3->width = width1;
HXDLIN( 289)									v3->height = height1;
HXDLIN( 289)									v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 289)									v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g30 = 0;
HXDLIN( 289)										int _g31 = v3->length;
HXDLIN( 289)										while((_g30 < _g31)){
HXDLIN( 289)											_g30 = (_g30 + 1);
HXDLIN( 289)											int i9 = (_g30 - 1);
HXDLIN( 289)											v3->data->__unsafe_set(i9,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage4 = v3;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 289)								{
HXDLIN( 289)									b7->width = width1;
HXDLIN( 289)									b7->height = height1;
HXDLIN( 289)									b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 289)									b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len3 = b7->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 289)										if (::hx::IsNull( d1->head )) {
HXDLIN( 289)											int _g32 = 0;
HXDLIN( 289)											int _g33 = len3;
HXDLIN( 289)											while((_g32 < _g33)){
HXDLIN( 289)												_g32 = (_g32 + 1);
HXDLIN( 289)												int i10 = (_g32 - 1);
HXDLIN( 289)												d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g34 = 0;
HXDLIN( 289)											int _g35 = len3;
HXDLIN( 289)											while((_g34 < _g35)){
HXDLIN( 289)												_g34 = (_g34 + 1);
HXDLIN( 289)												int i11 = (_g34 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g36 = 0;
HXDLIN( 289)														int _g37 = i11;
HXDLIN( 289)														while((_g36 < _g37)){
HXDLIN( 289)															_g36 = (_g36 + 1);
HXDLIN( 289)															int i12 = (_g36 - 1);
HXLINE( 345)															prev1 = l1;
HXLINE( 346)															l1 = l1->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev1 )) {
HXDLIN( 289)														b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 289)														l1 = null();
            													}
            													else {
HXDLIN( 289)														prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 289)														l1 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage4 = b7;
            							}
            							break;
            						}
HXDLIN( 289)						this38->image = undoImage4;
HXDLIN( 289)						this38->width = width1;
HXDLIN( 289)						this38->height = height1;
HXDLIN( 289)						this38->imageType = ( (int)(imageType1) );
HXDLIN( 289)						undoImage3 = this38;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft1 = xIter31->start;
HXDLIN( 289)							int rectTop1 = yIter31->start;
HXDLIN( 289)							int rectRight1 = xIter31->max;
HXDLIN( 289)							bool forceClear1 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g38 = rectTop1;
HXDLIN( 289)								int _g39 = yIter31->max;
HXDLIN( 289)								while((_g38 < _g39)){
HXDLIN( 289)									_g38 = (_g38 + 1);
HXDLIN( 289)									int dy3 = (_g38 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g40 = rectLeft1;
HXDLIN( 289)										int _g41 = rectRight1;
HXDLIN( 289)										while((_g40 < _g41)){
HXDLIN( 289)											_g40 = (_g40 + 1);
HXDLIN( 289)											int dx3 = (_g40 - 1);
HXDLIN( 289)											::Dynamic this40 = this37->image;
HXDLIN( 289)											int index5;
HXDLIN( 289)											if (this37->useVirtualPos) {
HXDLIN( 289)												index5 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx3) - this37->virtualX));
            											}
            											else {
HXDLIN( 289)												index5 = ::Std_obj::_hx_int(( (Float)(((dy3 * this37->width) + dx3)) ));
            											}
HXDLIN( 289)											int c4 = ::iterMagic::Iimg_obj::get(this40,index5);
HXDLIN( 289)											int col1;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col1 = c4;
            											}
HXDLIN( 289)											bool _hx_tmp8;
HXDLIN( 289)											if (this37->useMask) {
HXDLIN( 289)												_hx_tmp8 = ::hx::IsNotNull( this37->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp8 = false;
            											}
HXDLIN( 289)											if (_hx_tmp8) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this41 = this37->mask;
HXDLIN( 289)												::Dynamic this42 = this41->image;
HXDLIN( 289)												int index6;
HXDLIN( 289)												if (this41->useVirtualPos) {
HXDLIN( 289)													index6 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx3) - this41->virtualX));
            												}
            												else {
HXDLIN( 289)													index6 = ::Std_obj::_hx_int(( (Float)(((dy3 * this41->width) + dx3)) ));
            												}
HXDLIN( 289)												int c5 = ::iterMagic::Iimg_obj::get(this42,index6);
HXDLIN( 289)												int v4;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v4 = c5;
            												}
HXDLIN( 289)												int maskPixel1 = v4;
HXDLIN( 289)												int this43 = col1;
HXDLIN( 289)												if ((maskPixel1 == 0)) {
HXDLIN( 289)													col1 = this43;
            												}
            												else {
HXDLIN( 289)													Float m01;
HXDLIN( 289)													int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN( 289)													if ((this44 == 0)) {
HXDLIN( 289)														m01 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m11;
HXDLIN( 289)													int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN( 289)													if ((this45 == 0)) {
HXDLIN( 289)														m11 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m21;
HXDLIN( 289)													int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN( 289)													if ((this46 == 0)) {
HXDLIN( 289)														m21 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m31;
HXDLIN( 289)													int this47 = (maskPixel1 & 255);
HXDLIN( 289)													if ((this47 == 0)) {
HXDLIN( 289)														m31 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN( 289)													int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN( 289)													int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN( 289)													int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN( 289)													col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col1 != 0)) {
HXDLIN( 289)												int x7 = (dx3 - rectLeft1);
HXDLIN( 289)												int y6 = (dy3 - rectTop1);
HXDLIN( 289)												int c6 = col1;
HXDLIN( 289)												bool _hx_tmp9;
HXDLIN( 289)												if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp9 = undoImage3->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp9 = false;
            												}
HXDLIN( 289)												if (_hx_tmp9) {
HXDLIN( 289)													int location2;
HXDLIN( 289)													if (undoImage3->useVirtualPos) {
HXDLIN( 289)														location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 289)														location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x7)) ));
            													}
HXDLIN( 289)													int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 289)													int this49;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this49 = this48;
            													}
HXDLIN( 289)													Float a12;
HXDLIN( 289)													int this50 = ((this49 >> 24) & 255);
HXDLIN( 289)													if ((this50 == 0)) {
HXDLIN( 289)														a12 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a12 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r12;
HXDLIN( 289)													int this51 = ((this49 >> 16) & 255);
HXDLIN( 289)													if ((this51 == 0)) {
HXDLIN( 289)														r12 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g12;
HXDLIN( 289)													int this52 = ((this49 >> 8) & 255);
HXDLIN( 289)													if ((this52 == 0)) {
HXDLIN( 289)														g12 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b13;
HXDLIN( 289)													int this53 = (this49 & 255);
HXDLIN( 289)													if ((this53 == 0)) {
HXDLIN( 289)														b13 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a22;
HXDLIN( 289)													int this54 = ((col1 >> 24) & 255);
HXDLIN( 289)													if ((this54 == 0)) {
HXDLIN( 289)														a22 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r22;
HXDLIN( 289)													int this55 = ((col1 >> 16) & 255);
HXDLIN( 289)													if ((this55 == 0)) {
HXDLIN( 289)														r22 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g22;
HXDLIN( 289)													int this56 = ((col1 >> 8) & 255);
HXDLIN( 289)													if ((this56 == 0)) {
HXDLIN( 289)														g22 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b23;
HXDLIN( 289)													int this57 = (col1 & 255);
HXDLIN( 289)													if ((this57 == 0)) {
HXDLIN( 289)														b23 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 289)													int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 289)													int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 289)													int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 289)													int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 289)													int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp10;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp10 = blended2;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this58 = undoImage3->image;
HXDLIN( 289)													int index7;
HXDLIN( 289)													if (undoImage3->useVirtualPos) {
HXDLIN( 289)														index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 289)														index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x7)) ));
            													}
HXDLIN( 289)													int _hx_tmp11;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp11 = c6;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this58,index7,_hx_tmp11);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear1) {
HXDLIN( 289)													::Dynamic this59 = undoImage3->image;
HXDLIN( 289)													int x8 = (dx3 - rectLeft1);
HXDLIN( 289)													int y7 = (dy3 - rectTop1);
HXDLIN( 289)													int index8;
HXDLIN( 289)													if (undoImage3->useVirtualPos) {
HXDLIN( 289)														index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            													}
            													else {
HXDLIN( 289)														index8 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x8)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this59,index8,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min2 = xIter31->start;
HXDLIN( 289)						int _g_max2 = xIter31->max;
HXDLIN( 289)						while((_g_min2 < _g_max2)){
HXDLIN( 289)							_g_min2 = (_g_min2 + 1);
HXDLIN( 289)							int px = (_g_min2 - 1);
HXDLIN( 289)							Float pcx = (( (Float)(px) ) - x5);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min3 = yIter31->start;
HXDLIN( 289)								int _g_max3 = yIter31->max;
HXDLIN( 289)								while((_g_min3 < _g_max3)){
HXDLIN( 289)									_g_min3 = (_g_min3 + 1);
HXDLIN( 289)									int py = (_g_min3 - 1);
HXDLIN( 289)									Float pcy = (( (Float)(py) ) - cy2);
HXDLIN( 289)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 289)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 289)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 289)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 289)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 289)									bool _hx_tmp12;
HXDLIN( 289)									bool _hx_tmp13;
HXDLIN( 289)									if ((ratioA >= 0)) {
HXDLIN( 289)										_hx_tmp13 = (ratioB >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp13 = false;
            									}
HXDLIN( 289)									if (_hx_tmp13) {
HXDLIN( 289)										_hx_tmp12 = (ratioC >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp12 = false;
            									}
HXDLIN( 289)									if (_hx_tmp12) {
HXDLIN( 289)										int i13 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 289)										if ((i13 > 255)) {
HXLINE(  24)											i13 = 255;
            										}
HXLINE( 289)										if ((i13 < 0)) {
HXLINE(  25)											i13 = 0;
            										}
HXLINE( 289)										int a8 = i13;
HXDLIN( 289)										int i14 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 289)										if ((i14 > 255)) {
HXLINE(  24)											i14 = 255;
            										}
HXLINE( 289)										if ((i14 < 0)) {
HXLINE(  25)											i14 = 0;
            										}
HXLINE( 289)										int r5 = i14;
HXDLIN( 289)										int i15 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 289)										if ((i15 > 255)) {
HXLINE(  24)											i15 = 255;
            										}
HXLINE( 289)										if ((i15 < 0)) {
HXLINE(  25)											i15 = 0;
            										}
HXLINE( 289)										int g5 = i15;
HXDLIN( 289)										int i16 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 289)										if ((i16 > 255)) {
HXLINE(  24)											i16 = 255;
            										}
HXLINE( 289)										if ((i16 < 0)) {
HXLINE(  25)											i16 = 0;
            										}
HXLINE( 289)										int b9 = i16;
HXDLIN( 289)										{
HXDLIN( 289)											int location3;
HXDLIN( 289)											if (this37->useVirtualPos) {
HXDLIN( 289)												location3 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this37->virtualY) * ( (Float)(this37->width) )) + px) - this37->virtualX));
            											}
            											else {
HXDLIN( 289)												location3 = ::Std_obj::_hx_int(( (Float)(((py * this37->width) + px)) ));
            											}
HXDLIN( 289)											bool _hx_tmp14;
HXDLIN( 289)											if (this37->transparent) {
HXDLIN( 289)												_hx_tmp14 = (a8 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp14 = false;
            											}
HXDLIN( 289)											if (_hx_tmp14) {
HXDLIN( 289)												int this60 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 289)												int old;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old = this60;
            												}
HXDLIN( 289)												int rhs = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 289)												Float a13;
HXDLIN( 289)												int this61 = ((old >> 24) & 255);
HXDLIN( 289)												if ((this61 == 0)) {
HXDLIN( 289)													a13 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r13;
HXDLIN( 289)												int this62 = ((old >> 16) & 255);
HXDLIN( 289)												if ((this62 == 0)) {
HXDLIN( 289)													r13 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g13;
HXDLIN( 289)												int this63 = ((old >> 8) & 255);
HXDLIN( 289)												if ((this63 == 0)) {
HXDLIN( 289)													g13 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b14;
HXDLIN( 289)												int this64 = (old & 255);
HXDLIN( 289)												if ((this64 == 0)) {
HXDLIN( 289)													b14 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a23;
HXDLIN( 289)												int this65 = ((rhs >> 24) & 255);
HXDLIN( 289)												if ((this65 == 0)) {
HXDLIN( 289)													a23 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r23;
HXDLIN( 289)												int this66 = ((rhs >> 16) & 255);
HXDLIN( 289)												if ((this66 == 0)) {
HXDLIN( 289)													r23 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g23;
HXDLIN( 289)												int this67 = ((rhs >> 8) & 255);
HXDLIN( 289)												if ((this67 == 0)) {
HXDLIN( 289)													g23 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b24;
HXDLIN( 289)												int this68 = (rhs & 255);
HXDLIN( 289)												if ((this68 == 0)) {
HXDLIN( 289)													b24 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 289)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 289)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 289)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 289)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 289)												int blended3 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp15;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp15 = blended3;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp15);
            												}
            											}
            											else {
HXDLIN( 289)												int value;
HXDLIN( 289)												if (this37->isLittle) {
HXDLIN( 289)													value = ((((a8 << 24) | (b9 << 16)) | (g5 << 8)) | r5);
            												}
            												else {
HXDLIN( 289)													value = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this37->image,location3,value);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit1 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x5,y,bx1,y,x5,cy2,true);
HXDLIN( 289)						if (hasUndo1) {
HXDLIN( 289)							v5->undoImage = undoImage3;
HXDLIN( 289)							v5->undoX = xIter31->start;
HXDLIN( 289)							v5->undoY = yIter31->start;
            						}
            					}
            				}
HXDLIN( 289)				{
HXDLIN( 289)					bool hasHit2 = false;
HXDLIN( 289)					bool hasUndo2 = false;
HXDLIN( 289)					int aA1 = ((colorC >> 24) & 255);
HXDLIN( 289)					int rA1 = ((colorC >> 16) & 255);
HXDLIN( 289)					int gA1 = ((colorC >> 8) & 255);
HXDLIN( 289)					int bA1 = (colorC & 255);
HXDLIN( 289)					int aB1 = ((colorC >> 24) & 255);
HXDLIN( 289)					int rB1 = ((colorC >> 16) & 255);
HXDLIN( 289)					int gB1 = ((colorC >> 8) & 255);
HXDLIN( 289)					int bB1 = (colorC & 255);
HXDLIN( 289)					int aC1 = ((colorA >> 24) & 255);
HXDLIN( 289)					int rC1 = ((colorA >> 16) & 255);
HXDLIN( 289)					int gC1 = ((colorA >> 8) & 255);
HXDLIN( 289)					int bC1 = (colorA & 255);
HXDLIN( 289)					Float bcx1 = (bx1 - x5);
HXDLIN( 289)					Float bcy1 = (cy2 - cy2);
HXDLIN( 289)					Float acx1 = (bx1 - x5);
HXDLIN( 289)					Float acy1 = (y - cy2);
HXDLIN( 289)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 289)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 289)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 289)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 289)					if ((bx1 > bx1)) {
HXDLIN( 289)						if ((bx1 > x5)) {
HXDLIN( 289)							int min8;
HXDLIN( 289)							if ((bx1 > x5)) {
HXDLIN( 289)								min8 = ::Math_obj::floor(x5);
            							}
            							else {
HXDLIN( 289)								min8 = ::Math_obj::floor(bx1);
            							}
HXDLIN( 289)							int ii_min16 = min8;
HXDLIN( 289)							int ii_max16 = ::Math_obj::ceil(bx1);
HXDLIN( 289)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            						else {
HXDLIN( 289)							int ii_min17 = ::Math_obj::floor(bx1);
HXDLIN( 289)							int ii_max17 = ::Math_obj::ceil(x5);
HXDLIN( 289)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx1 > x5)) {
HXDLIN( 289)							int min9;
HXDLIN( 289)							if ((bx1 > x5)) {
HXDLIN( 289)								min9 = ::Math_obj::floor(x5);
            							}
            							else {
HXDLIN( 289)								min9 = ::Math_obj::ceil(bx1);
            							}
HXDLIN( 289)							int ii_min18 = min9;
HXDLIN( 289)							int ii_max18 = ::Math_obj::ceil(bx1);
HXDLIN( 289)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            						}
            						else {
HXDLIN( 289)							int ii_min19 = ::Math_obj::floor(bx1);
HXDLIN( 289)							int ii_max19 = ::Math_obj::ceil(x5);
HXDLIN( 289)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 289)					if ((y > cy2)) {
HXDLIN( 289)						if ((y > cy2)) {
HXDLIN( 289)							int min10;
HXDLIN( 289)							if ((cy2 > cy2)) {
HXDLIN( 289)								min10 = ::Math_obj::floor(cy2);
            							}
            							else {
HXDLIN( 289)								min10 = ::Math_obj::floor(cy2);
            							}
HXDLIN( 289)							int ii_min20 = min10;
HXDLIN( 289)							int ii_max20 = ::Math_obj::ceil(y);
HXDLIN( 289)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            						}
            						else {
HXDLIN( 289)							int ii_min21 = ::Math_obj::floor(cy2);
HXDLIN( 289)							int ii_max21 = ::Math_obj::ceil(cy2);
HXDLIN( 289)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            						}
            					}
            					else {
HXDLIN( 289)						if ((cy2 > cy2)) {
HXDLIN( 289)							int min11;
HXDLIN( 289)							if ((y > cy2)) {
HXDLIN( 289)								min11 = ::Math_obj::floor(cy2);
            							}
            							else {
HXDLIN( 289)								min11 = ::Math_obj::ceil(y);
            							}
HXDLIN( 289)							int ii_min22 = min11;
HXDLIN( 289)							int ii_max22 = ::Math_obj::ceil(cy2);
HXDLIN( 289)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            						}
            						else {
HXDLIN( 289)							int ii_min23 = ::Math_obj::floor(y);
HXDLIN( 289)							int ii_max23 = ::Math_obj::ceil(cy2);
HXDLIN( 289)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 289)					if (hasUndo2) {
HXDLIN( 289)						int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 289)						int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType2 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this69 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType2 )) {
HXLINE(  54)							imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage7;
HXDLIN( 289)						switch((int)(( (int)(imageType2) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b15 = byt2;
HXDLIN( 289)								{
HXDLIN( 289)									b15->width = width2;
HXDLIN( 289)									b15->height = height2;
HXDLIN( 289)									b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 289)									b15->data = ::haxe::io::Bytes_obj::alloc((b15->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len4 = b15->length;
HXDLIN( 289)										int w2 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g42 = 0;
HXDLIN( 289)											int _g43 = b15->height;
HXDLIN( 289)											while((_g42 < _g43)){
HXDLIN( 289)												_g42 = (_g42 + 1);
HXDLIN( 289)												int y8 = (_g42 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g44 = 0;
HXDLIN( 289)													int _g45 = b15->width;
HXDLIN( 289)													while((_g44 < _g45)){
HXDLIN( 289)														_g44 = (_g44 + 1);
HXDLIN( 289)														int x9 = (_g44 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w2 = (w2 + 1);
HXDLIN( 289)															b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w2 = (w2 + 1);
HXDLIN( 289)															b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w2 = (w2 + 1);
HXDLIN( 289)															b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w2 = (w2 + 1);
HXDLIN( 289)															b15->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage7 = b15;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a10 = arrI2;
HXDLIN( 289)								{
HXDLIN( 289)									a10->width = width2;
HXDLIN( 289)									a10->height = height2;
HXDLIN( 289)									a10->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g46 = 0;
HXDLIN( 289)										int _g47 = a10->length;
HXDLIN( 289)										while((_g46 < _g47)){
HXDLIN( 289)											_g46 = (_g46 + 1);
HXDLIN( 289)											int i17 = (_g46 - 1);
HXDLIN( 289)											a10->data[i17] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage7 = a10;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b16 = u32a2;
HXDLIN( 289)								{
HXDLIN( 289)									b16->width = width2;
HXDLIN( 289)									b16->height = height2;
HXDLIN( 289)									b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 289)									int size2 = (b16->length * 4);
HXDLIN( 289)									b16->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 289)									{
HXDLIN( 289)										int _g48 = 0;
HXDLIN( 289)										int _g49 = b16->length;
HXDLIN( 289)										while((_g48 < _g49)){
HXDLIN( 289)											_g48 = (_g48 + 1);
HXDLIN( 289)											int i18 = (_g48 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this70 = b16->data;
HXDLIN( 289)												bool undoImage8;
HXDLIN( 289)												if ((i18 >= 0)) {
HXDLIN( 289)													undoImage8 = (i18 < (this70->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage8 = false;
            												}
HXDLIN( 289)												if (undoImage8) {
HXDLIN( 289)													 ::haxe::io::Bytes _this2 = this70->bytes;
HXDLIN( 289)													int pos2 = ((i18 << 2) + this70->byteOffset);
HXDLIN( 289)													_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 289)													_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage7 = b16;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN( 289)								{
HXDLIN( 289)									v6->width = width2;
HXDLIN( 289)									v6->height = height2;
HXDLIN( 289)									v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 289)									v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g50 = 0;
HXDLIN( 289)										int _g51 = v6->length;
HXDLIN( 289)										while((_g50 < _g51)){
HXDLIN( 289)											_g50 = (_g50 + 1);
HXDLIN( 289)											int i19 = (_g50 - 1);
HXDLIN( 289)											v6->data->__unsafe_set(i19,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage7 = v6;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b17 = sInt2;
HXDLIN( 289)								{
HXDLIN( 289)									b17->width = width2;
HXDLIN( 289)									b17->height = height2;
HXDLIN( 289)									b17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 289)									b17->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len5 = b17->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d2 = b17->data;
HXDLIN( 289)										if (::hx::IsNull( d2->head )) {
HXDLIN( 289)											int _g52 = 0;
HXDLIN( 289)											int _g53 = len5;
HXDLIN( 289)											while((_g52 < _g53)){
HXDLIN( 289)												_g52 = (_g52 + 1);
HXDLIN( 289)												int i20 = (_g52 - 1);
HXDLIN( 289)												d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g54 = 0;
HXDLIN( 289)											int _g55 = len5;
HXDLIN( 289)											while((_g54 < _g55)){
HXDLIN( 289)												_g54 = (_g54 + 1);
HXDLIN( 289)												int i21 = (_g54 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l2 = b17->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g56 = 0;
HXDLIN( 289)														int _g57 = i21;
HXDLIN( 289)														while((_g56 < _g57)){
HXDLIN( 289)															_g56 = (_g56 + 1);
HXDLIN( 289)															int i22 = (_g56 - 1);
HXLINE( 345)															prev2 = l2;
HXLINE( 346)															l2 = l2->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev2 )) {
HXDLIN( 289)														b17->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 289)														l2 = null();
            													}
            													else {
HXDLIN( 289)														prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 289)														l2 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage7 = b17;
            							}
            							break;
            						}
HXDLIN( 289)						this69->image = undoImage7;
HXDLIN( 289)						this69->width = width2;
HXDLIN( 289)						this69->height = height2;
HXDLIN( 289)						this69->imageType = ( (int)(imageType2) );
HXDLIN( 289)						undoImage6 = this69;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft2 = xIter32->start;
HXDLIN( 289)							int rectTop2 = yIter32->start;
HXDLIN( 289)							int rectRight2 = xIter32->max;
HXDLIN( 289)							bool forceClear2 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g58 = rectTop2;
HXDLIN( 289)								int _g59 = yIter32->max;
HXDLIN( 289)								while((_g58 < _g59)){
HXDLIN( 289)									_g58 = (_g58 + 1);
HXDLIN( 289)									int dy4 = (_g58 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g60 = rectLeft2;
HXDLIN( 289)										int _g61 = rectRight2;
HXDLIN( 289)										while((_g60 < _g61)){
HXDLIN( 289)											_g60 = (_g60 + 1);
HXDLIN( 289)											int dx4 = (_g60 - 1);
HXDLIN( 289)											::Dynamic this71 = this37->image;
HXDLIN( 289)											int index9;
HXDLIN( 289)											if (this37->useVirtualPos) {
HXDLIN( 289)												index9 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx4) - this37->virtualX));
            											}
            											else {
HXDLIN( 289)												index9 = ::Std_obj::_hx_int(( (Float)(((dy4 * this37->width) + dx4)) ));
            											}
HXDLIN( 289)											int c7 = ::iterMagic::Iimg_obj::get(this71,index9);
HXDLIN( 289)											int col2;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col2 = c7;
            											}
HXDLIN( 289)											bool _hx_tmp16;
HXDLIN( 289)											if (this37->useMask) {
HXDLIN( 289)												_hx_tmp16 = ::hx::IsNotNull( this37->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp16 = false;
            											}
HXDLIN( 289)											if (_hx_tmp16) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this72 = this37->mask;
HXDLIN( 289)												::Dynamic this73 = this72->image;
HXDLIN( 289)												int index10;
HXDLIN( 289)												if (this72->useVirtualPos) {
HXDLIN( 289)													index10 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this72->virtualY) * ( (Float)(this72->width) )) + dx4) - this72->virtualX));
            												}
            												else {
HXDLIN( 289)													index10 = ::Std_obj::_hx_int(( (Float)(((dy4 * this72->width) + dx4)) ));
            												}
HXDLIN( 289)												int c8 = ::iterMagic::Iimg_obj::get(this73,index10);
HXDLIN( 289)												int v7;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v7 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v7 = c8;
            												}
HXDLIN( 289)												int maskPixel2 = v7;
HXDLIN( 289)												int this74 = col2;
HXDLIN( 289)												if ((maskPixel2 == 0)) {
HXDLIN( 289)													col2 = this74;
            												}
            												else {
HXDLIN( 289)													Float m02;
HXDLIN( 289)													int this75 = ((maskPixel2 >> 24) & 255);
HXDLIN( 289)													if ((this75 == 0)) {
HXDLIN( 289)														m02 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m02 = (( (Float)(this75) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m12;
HXDLIN( 289)													int this76 = ((maskPixel2 >> 16) & 255);
HXDLIN( 289)													if ((this76 == 0)) {
HXDLIN( 289)														m12 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m12 = (( (Float)(this76) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m22;
HXDLIN( 289)													int this77 = ((maskPixel2 >> 8) & 255);
HXDLIN( 289)													if ((this77 == 0)) {
HXDLIN( 289)														m22 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m22 = (( (Float)(this77) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m32;
HXDLIN( 289)													int this78 = (maskPixel2 & 255);
HXDLIN( 289)													if ((this78 == 0)) {
HXDLIN( 289)														m32 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m32 = (( (Float)(this78) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this74 >> 24) & 255)) )));
HXDLIN( 289)													int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this74 >> 16) & 255)) )));
HXDLIN( 289)													int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this74 >> 8) & 255)) )));
HXDLIN( 289)													int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this74 & 255)) )));
HXDLIN( 289)													col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col2 != 0)) {
HXDLIN( 289)												int x10 = (dx4 - rectLeft2);
HXDLIN( 289)												int y9 = (dy4 - rectTop2);
HXDLIN( 289)												int c9 = col2;
HXDLIN( 289)												bool _hx_tmp17;
HXDLIN( 289)												if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp17 = undoImage6->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp17 = false;
            												}
HXDLIN( 289)												if (_hx_tmp17) {
HXDLIN( 289)													int location4;
HXDLIN( 289)													if (undoImage6->useVirtualPos) {
HXDLIN( 289)														location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 289)														location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x10)) ));
            													}
HXDLIN( 289)													int this79 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 289)													int this80;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this80 = ((((((this79 >> 24) & 255) << 24) | ((this79 & 255) << 16)) | (((this79 >> 8) & 255) << 8)) | ((this79 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this80 = this79;
            													}
HXDLIN( 289)													Float a14;
HXDLIN( 289)													int this81 = ((this80 >> 24) & 255);
HXDLIN( 289)													if ((this81 == 0)) {
HXDLIN( 289)														a14 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a14 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r14;
HXDLIN( 289)													int this82 = ((this80 >> 16) & 255);
HXDLIN( 289)													if ((this82 == 0)) {
HXDLIN( 289)														r14 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r14 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g14;
HXDLIN( 289)													int this83 = ((this80 >> 8) & 255);
HXDLIN( 289)													if ((this83 == 0)) {
HXDLIN( 289)														g14 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g14 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b18;
HXDLIN( 289)													int this84 = (this80 & 255);
HXDLIN( 289)													if ((this84 == 0)) {
HXDLIN( 289)														b18 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b18 = (( (Float)(this84) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a24;
HXDLIN( 289)													int this85 = ((col2 >> 24) & 255);
HXDLIN( 289)													if ((this85 == 0)) {
HXDLIN( 289)														a24 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a24 = (( (Float)(this85) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r24;
HXDLIN( 289)													int this86 = ((col2 >> 16) & 255);
HXDLIN( 289)													if ((this86 == 0)) {
HXDLIN( 289)														r24 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r24 = (( (Float)(this86) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g24;
HXDLIN( 289)													int this87 = ((col2 >> 8) & 255);
HXDLIN( 289)													if ((this87 == 0)) {
HXDLIN( 289)														g24 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g24 = (( (Float)(this87) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b25;
HXDLIN( 289)													int this88 = (col2 & 255);
HXDLIN( 289)													if ((this88 == 0)) {
HXDLIN( 289)														b25 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b25 = (( (Float)(this88) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 289)													int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 289)													int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 289)													int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a34) + (b25 * a24))));
HXDLIN( 289)													int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 289)													int blended4 = ((((a15 << 24) | (r7 << 16)) | (g7 << 8)) | b19);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp18;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp18 = blended4;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this89 = undoImage6->image;
HXDLIN( 289)													int index11;
HXDLIN( 289)													if (undoImage6->useVirtualPos) {
HXDLIN( 289)														index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 289)														index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x10)) ));
            													}
HXDLIN( 289)													int _hx_tmp19;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp19 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp19 = c9;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this89,index11,_hx_tmp19);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear2) {
HXDLIN( 289)													::Dynamic this90 = undoImage6->image;
HXDLIN( 289)													int x11 = (dx4 - rectLeft2);
HXDLIN( 289)													int y10 = (dy4 - rectTop2);
HXDLIN( 289)													int index12;
HXDLIN( 289)													if (undoImage6->useVirtualPos) {
HXDLIN( 289)														index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            													}
            													else {
HXDLIN( 289)														index12 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x11)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this90,index12,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min4 = xIter32->start;
HXDLIN( 289)						int _g_max4 = xIter32->max;
HXDLIN( 289)						while((_g_min4 < _g_max4)){
HXDLIN( 289)							_g_min4 = (_g_min4 + 1);
HXDLIN( 289)							int px1 = (_g_min4 - 1);
HXDLIN( 289)							Float pcx1 = (( (Float)(px1) ) - x5);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min5 = yIter32->start;
HXDLIN( 289)								int _g_max5 = yIter32->max;
HXDLIN( 289)								while((_g_min5 < _g_max5)){
HXDLIN( 289)									_g_min5 = (_g_min5 + 1);
HXDLIN( 289)									int py1 = (_g_min5 - 1);
HXDLIN( 289)									Float pcy1 = (( (Float)(py1) ) - cy2);
HXDLIN( 289)									Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 289)									Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 289)									Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 289)									Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 289)									Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 289)									bool _hx_tmp20;
HXDLIN( 289)									bool _hx_tmp21;
HXDLIN( 289)									if ((ratioA1 >= 0)) {
HXDLIN( 289)										_hx_tmp21 = (ratioB1 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp21 = false;
            									}
HXDLIN( 289)									if (_hx_tmp21) {
HXDLIN( 289)										_hx_tmp20 = (ratioC1 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp20 = false;
            									}
HXDLIN( 289)									if (_hx_tmp20) {
HXDLIN( 289)										int i23 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 289)										if ((i23 > 255)) {
HXLINE(  24)											i23 = 255;
            										}
HXLINE( 289)										if ((i23 < 0)) {
HXLINE(  25)											i23 = 0;
            										}
HXLINE( 289)										int a16 = i23;
HXDLIN( 289)										int i24 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 289)										if ((i24 > 255)) {
HXLINE(  24)											i24 = 255;
            										}
HXLINE( 289)										if ((i24 < 0)) {
HXLINE(  25)											i24 = 0;
            										}
HXLINE( 289)										int r8 = i24;
HXDLIN( 289)										int i25 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 289)										if ((i25 > 255)) {
HXLINE(  24)											i25 = 255;
            										}
HXLINE( 289)										if ((i25 < 0)) {
HXLINE(  25)											i25 = 0;
            										}
HXLINE( 289)										int g8 = i25;
HXDLIN( 289)										int i26 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 289)										if ((i26 > 255)) {
HXLINE(  24)											i26 = 255;
            										}
HXLINE( 289)										if ((i26 < 0)) {
HXLINE(  25)											i26 = 0;
            										}
HXLINE( 289)										int b20 = i26;
HXDLIN( 289)										{
HXDLIN( 289)											int location5;
HXDLIN( 289)											if (this37->useVirtualPos) {
HXDLIN( 289)												location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this37->virtualY) * ( (Float)(this37->width) )) + px1) - this37->virtualX));
            											}
            											else {
HXDLIN( 289)												location5 = ::Std_obj::_hx_int(( (Float)(((py1 * this37->width) + px1)) ));
            											}
HXDLIN( 289)											bool _hx_tmp22;
HXDLIN( 289)											if (this37->transparent) {
HXDLIN( 289)												_hx_tmp22 = (a16 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp22 = false;
            											}
HXDLIN( 289)											if (_hx_tmp22) {
HXDLIN( 289)												int this91 = ::iterMagic::Iimg_obj::get(this37->image,location5);
HXDLIN( 289)												int old1;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old1 = ((((((this91 >> 24) & 255) << 24) | ((this91 & 255) << 16)) | (((this91 >> 8) & 255) << 8)) | ((this91 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old1 = this91;
            												}
HXDLIN( 289)												int rhs1 = ((((a16 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN( 289)												Float a17;
HXDLIN( 289)												int this92 = ((old1 >> 24) & 255);
HXDLIN( 289)												if ((this92 == 0)) {
HXDLIN( 289)													a17 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a17 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r15;
HXDLIN( 289)												int this93 = ((old1 >> 16) & 255);
HXDLIN( 289)												if ((this93 == 0)) {
HXDLIN( 289)													r15 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r15 = (( (Float)(this93) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g15;
HXDLIN( 289)												int this94 = ((old1 >> 8) & 255);
HXDLIN( 289)												if ((this94 == 0)) {
HXDLIN( 289)													g15 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g15 = (( (Float)(this94) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b110;
HXDLIN( 289)												int this95 = (old1 & 255);
HXDLIN( 289)												if ((this95 == 0)) {
HXDLIN( 289)													b110 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b110 = (( (Float)(this95) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a25;
HXDLIN( 289)												int this96 = ((rhs1 >> 24) & 255);
HXDLIN( 289)												if ((this96 == 0)) {
HXDLIN( 289)													a25 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a25 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r25;
HXDLIN( 289)												int this97 = ((rhs1 >> 16) & 255);
HXDLIN( 289)												if ((this97 == 0)) {
HXDLIN( 289)													r25 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r25 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g25;
HXDLIN( 289)												int this98 = ((rhs1 >> 8) & 255);
HXDLIN( 289)												if ((this98 == 0)) {
HXDLIN( 289)													g25 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g25 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b26;
HXDLIN( 289)												int this99 = (rhs1 & 255);
HXDLIN( 289)												if ((this99 == 0)) {
HXDLIN( 289)													b26 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b26 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a35 = (a17 * (( (Float)(1) ) - a25));
HXDLIN( 289)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 289)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 289)												int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a35) + (b26 * a25))));
HXDLIN( 289)												int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 289)												int blended5 = ((((a18 << 24) | (r9 << 16)) | (g9 << 8)) | b27);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp23;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp23 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp23 = blended5;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this37->image,location5,_hx_tmp23);
            												}
            											}
            											else {
HXDLIN( 289)												int value1;
HXDLIN( 289)												if (this37->isLittle) {
HXDLIN( 289)													value1 = ((((a16 << 24) | (b20 << 16)) | (g8 << 8)) | r8);
            												}
            												else {
HXDLIN( 289)													value1 = ((((a16 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this37->image,location5,value1);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit2 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx1,y,bx1,cy2,x5,cy2,true);
HXDLIN( 289)						if (hasUndo2) {
HXDLIN( 289)							v8->undoImage = undoImage6;
HXDLIN( 289)							v8->undoX = xIter32->start;
HXDLIN( 289)							v8->undoY = yIter32->start;
            						}
            					}
            				}
HXDLIN( 289)				if ((hasHit1 == true)) {
HXDLIN( 289)					 ::pi_xy::algo::HitQuad v9 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x5,y,bx1,y,bx1,cy2,x5,cy2,true);
            				}
            			}
            		}
HXDLIN( 289)		Float inlobj_ax = x5;
HXDLIN( 289)		Float inlobj_ay = y;
HXDLIN( 289)		Float inlobj_bx = bx1;
HXDLIN( 289)		Float inlobj_y = y;
HXDLIN( 289)		Float inlobj_cx = bx1;
HXDLIN( 289)		Float inlobj_cy = cy2;
HXDLIN( 289)		Float inlobj_x = x5;
HXDLIN( 289)		Float inlobj_dy = cy2;
HXDLIN( 289)		{
HXDLIN( 289)			 ::pi_xy::ImageStruct this100 = this1;
HXDLIN( 289)			Float cy3 = (y + dy1);
HXDLIN( 289)			Float ry1 = ( (Float)(dy1) );
HXDLIN( 289)			{
HXDLIN( 289)				 ::Dynamic targetError1 = ((Float)1.05);
HXDLIN( 289)				if (::hx::IsNull( targetError1 )) {
HXLINE( 113)					targetError1 = ((Float)1.05);
            				}
HXLINE( 289)				Float rSmall1;
HXDLIN( 289)				if ((rightRadius > ry1)) {
HXDLIN( 289)					rSmall1 = ry1;
            				}
            				else {
HXDLIN( 289)					rSmall1 = rightRadius;
            				}
HXDLIN( 289)				 ::Dynamic targetE1 = ( (Float)(targetError1) );
HXDLIN( 289)				if (::hx::IsNull( targetE1 )) {
HXLINE(  20)					targetE1 = ((Float)1.05);
            				}
HXLINE( 289)				int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN( 289)				int noSides1;
HXDLIN( 289)				if ((result1 < 12)) {
HXDLIN( 289)					noSides1 = 12;
            				}
            				else {
HXDLIN( 289)					if ((result1 > 500)) {
HXDLIN( 289)						noSides1 = 500;
            					}
            					else {
HXDLIN( 289)						noSides1 = result1;
            					}
            				}
HXDLIN( 289)				int sides1 = (::Math_obj::ceil((( (Float)(noSides1) ) / ( (Float)(4) ))) * 4);
HXDLIN( 289)				Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 289)				Float omega1 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN( 289)				int quarter1 = ::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(4) )));
HXDLIN( 289)				Float lastX1 = ((Float)0.);
HXDLIN( 289)				Float lastY1 = ((Float)0.);
HXDLIN( 289)				{
HXLINE(  26)					lastX1 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides1) ) * theta1) + omega1))));
HXLINE(  27)					lastY1 = (cy3 + (ry1 * ::Math_obj::sin(((( (Float)(sides1) ) * theta1) + omega1))));
            				}
HXLINE( 289)				{
HXDLIN( 289)					int _g62 = 0;
HXDLIN( 289)					int _g63 = (quarter1 + 1);
HXDLIN( 289)					while((_g62 < _g63)){
HXDLIN( 289)						_g62 = (_g62 + 1);
HXDLIN( 289)						int i27 = (_g62 - 1);
HXDLIN( 289)						Float nextX1 = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i27) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN( 289)						Float nextY1 = (cy3 + (ry1 * ::Math_obj::sin((((( (Float)(i27) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN( 289)						{
HXDLIN( 289)							 ::pi_xy::ImageStruct this101 = this100;
HXDLIN( 289)							bool hasHit3 = false;
HXDLIN( 289)							bool hasUndo3 = false;
HXDLIN( 289)							{
HXDLIN( 289)								Float bx2 = lastX1;
HXDLIN( 289)								Float by1 = lastY1;
HXDLIN( 289)								Float cx2 = nextX1;
HXDLIN( 289)								Float cy4 = nextY1;
HXDLIN( 289)								bool adjustWinding1 = (((((farX * by1) - (bx2 * cy3)) + ((bx2 * cy4) - (cx2 * by1))) + ((cx2 * cy3) - (farX * cy4))) > 0);
HXDLIN( 289)								if (!(adjustWinding1)) {
HXDLIN( 289)									Float bx_1 = bx2;
HXDLIN( 289)									Float by_1 = by1;
HXLINE(  25)									bx2 = cx2;
HXLINE(  26)									by1 = cy4;
HXLINE(  27)									cx2 = bx_1;
HXLINE(  28)									cy4 = by_1;
            								}
HXLINE( 289)								{
HXDLIN( 289)									Float s01 = ((cy3 * cx2) - (farX * cy4));
HXDLIN( 289)									Float sx1 = (cy4 - cy3);
HXDLIN( 289)									Float sy1 = (farX - cx2);
HXDLIN( 289)									Float t01 = ((farX * by1) - (cy3 * bx2));
HXDLIN( 289)									Float tx1 = (cy3 - by1);
HXDLIN( 289)									Float ty1 = (bx2 - farX);
HXDLIN( 289)									Float A1 = ((((-(by1) * cx2) + (cy3 * (-(bx2) + cx2))) + (farX * (by1 - cy4))) + (bx2 * cy4));
HXDLIN( 289)									 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 289)									if ((farX > bx2)) {
HXDLIN( 289)										if ((farX > cx2)) {
HXDLIN( 289)											int min12;
HXDLIN( 289)											if ((bx2 > cx2)) {
HXDLIN( 289)												min12 = ::Math_obj::floor(cx2);
            											}
            											else {
HXDLIN( 289)												min12 = ::Math_obj::floor(bx2);
            											}
HXDLIN( 289)											int ii_min24 = min12;
HXDLIN( 289)											int ii_max24 = ::Math_obj::ceil(farX);
HXDLIN( 289)											xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            										}
            										else {
HXDLIN( 289)											int ii_min25 = ::Math_obj::floor(bx2);
HXDLIN( 289)											int ii_max25 = ::Math_obj::ceil(cx2);
HXDLIN( 289)											xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            										}
            									}
            									else {
HXDLIN( 289)										if ((bx2 > cx2)) {
HXDLIN( 289)											int min13;
HXDLIN( 289)											if ((farX > cx2)) {
HXDLIN( 289)												min13 = ::Math_obj::floor(cx2);
            											}
            											else {
HXDLIN( 289)												min13 = ::Math_obj::ceil(farX);
            											}
HXDLIN( 289)											int ii_min26 = min13;
HXDLIN( 289)											int ii_max26 = ::Math_obj::ceil(bx2);
HXDLIN( 289)											xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            										}
            										else {
HXDLIN( 289)											int ii_min27 = ::Math_obj::floor(farX);
HXDLIN( 289)											int ii_max27 = ::Math_obj::ceil(cx2);
HXDLIN( 289)											xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            										}
            									}
HXDLIN( 289)									 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 289)									if ((cy3 > by1)) {
HXDLIN( 289)										if ((cy3 > cy4)) {
HXDLIN( 289)											int min14;
HXDLIN( 289)											if ((by1 > cy4)) {
HXDLIN( 289)												min14 = ::Math_obj::floor(cy4);
            											}
            											else {
HXDLIN( 289)												min14 = ::Math_obj::floor(by1);
            											}
HXDLIN( 289)											int ii_min28 = min14;
HXDLIN( 289)											int ii_max28 = ::Math_obj::ceil(cy3);
HXDLIN( 289)											yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            										}
            										else {
HXDLIN( 289)											int ii_min29 = ::Math_obj::floor(by1);
HXDLIN( 289)											int ii_max29 = ::Math_obj::ceil(cy4);
HXDLIN( 289)											yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            										}
            									}
            									else {
HXDLIN( 289)										if ((by1 > cy4)) {
HXDLIN( 289)											int min15;
HXDLIN( 289)											if ((cy3 > cy4)) {
HXDLIN( 289)												min15 = ::Math_obj::floor(cy4);
            											}
            											else {
HXDLIN( 289)												min15 = ::Math_obj::ceil(cy3);
            											}
HXDLIN( 289)											int ii_min30 = min15;
HXDLIN( 289)											int ii_max30 = ::Math_obj::ceil(by1);
HXDLIN( 289)											yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            										}
            										else {
HXDLIN( 289)											int ii_min31 = ::Math_obj::floor(cy3);
HXDLIN( 289)											int ii_max31 = ::Math_obj::ceil(cy4);
HXDLIN( 289)											yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            										}
            									}
HXDLIN( 289)									 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 289)									if (hasUndo3) {
HXDLIN( 289)										int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 289)										int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 289)										 ::Dynamic imageType3 = null();
HXDLIN( 289)										 ::pi_xy::ImageStruct this102 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)										if (::hx::IsNull( imageType3 )) {
HXLINE(  54)											imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 289)										::Dynamic undoImage10;
HXDLIN( 289)										switch((int)(( (int)(imageType3) ))){
            											case (int)0: {
HXDLIN( 289)												 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::BytesImg b28 = byt3;
HXDLIN( 289)												{
HXDLIN( 289)													b28->width = width3;
HXDLIN( 289)													b28->height = height3;
HXDLIN( 289)													b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 289)													b28->data = ::haxe::io::Bytes_obj::alloc((b28->length * 4));
HXDLIN( 289)													{
HXDLIN( 289)														int len6 = b28->length;
HXDLIN( 289)														int w3 = 0;
HXDLIN( 289)														{
HXDLIN( 289)															int _g64 = 0;
HXDLIN( 289)															int _g65 = b28->height;
HXDLIN( 289)															while((_g64 < _g65)){
HXDLIN( 289)																_g64 = (_g64 + 1);
HXDLIN( 289)																int y11 = (_g64 - 1);
HXDLIN( 289)																{
HXDLIN( 289)																	int _g66 = 0;
HXDLIN( 289)																	int _g67 = b28->width;
HXDLIN( 289)																	while((_g66 < _g67)){
HXDLIN( 289)																		_g66 = (_g66 + 1);
HXDLIN( 289)																		int x12 = (_g66 - 1);
HXDLIN( 289)																		{
HXDLIN( 289)																			w3 = (w3 + 1);
HXDLIN( 289)																			b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w3 = (w3 + 1);
HXDLIN( 289)																			b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w3 = (w3 + 1);
HXDLIN( 289)																			b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w3 = (w3 + 1);
HXDLIN( 289)																			b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage10 = b28;
            											}
            											break;
            											case (int)1: {
HXDLIN( 289)												 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::ArrIntImg a19 = arrI3;
HXDLIN( 289)												{
HXDLIN( 289)													a19->width = width3;
HXDLIN( 289)													a19->height = height3;
HXDLIN( 289)													a19->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)													a19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 289)													{
HXDLIN( 289)														int _g68 = 0;
HXDLIN( 289)														int _g69 = a19->length;
HXDLIN( 289)														while((_g68 < _g69)){
HXDLIN( 289)															_g68 = (_g68 + 1);
HXDLIN( 289)															int i28 = (_g68 - 1);
HXDLIN( 289)															a19->data[i28] = 0;
            														}
            													}
            												}
HXDLIN( 289)												undoImage10 = a19;
            											}
            											break;
            											case (int)2: {
HXDLIN( 289)												 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::U32ArrImg b29 = u32a3;
HXDLIN( 289)												{
HXDLIN( 289)													b29->width = width3;
HXDLIN( 289)													b29->height = height3;
HXDLIN( 289)													b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 289)													int size3 = (b29->length * 4);
HXDLIN( 289)													b29->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 289)													{
HXDLIN( 289)														int _g70 = 0;
HXDLIN( 289)														int _g71 = b29->length;
HXDLIN( 289)														while((_g70 < _g71)){
HXDLIN( 289)															_g70 = (_g70 + 1);
HXDLIN( 289)															int i29 = (_g70 - 1);
HXDLIN( 289)															{
HXDLIN( 289)																 ::haxe::io::ArrayBufferViewImpl this103 = b29->data;
HXDLIN( 289)																bool undoImage11;
HXDLIN( 289)																if ((i29 >= 0)) {
HXDLIN( 289)																	undoImage11 = (i29 < (this103->byteLength >> 2));
            																}
            																else {
HXDLIN( 289)																	undoImage11 = false;
            																}
HXDLIN( 289)																if (undoImage11) {
HXDLIN( 289)																	 ::haxe::io::Bytes _this3 = this103->bytes;
HXDLIN( 289)																	int pos3 = ((i29 << 2) + this103->byteOffset);
HXDLIN( 289)																	_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage10 = b29;
            											}
            											break;
            											case (int)3: {
HXDLIN( 289)												 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::VecIntImg v10 = vec3;
HXDLIN( 289)												{
HXDLIN( 289)													v10->width = width3;
HXDLIN( 289)													v10->height = height3;
HXDLIN( 289)													v10->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 289)													v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN( 289)													{
HXDLIN( 289)														int _g72 = 0;
HXDLIN( 289)														int _g73 = v10->length;
HXDLIN( 289)														while((_g72 < _g73)){
HXDLIN( 289)															_g72 = (_g72 + 1);
HXDLIN( 289)															int i30 = (_g72 - 1);
HXDLIN( 289)															v10->data->__unsafe_set(i30,0);
            														}
            													}
            												}
HXDLIN( 289)												undoImage10 = v10;
            											}
            											break;
            											case (int)4: {
HXDLIN( 289)												 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::StackIntImg b30 = sInt3;
HXDLIN( 289)												{
HXDLIN( 289)													b30->width = width3;
HXDLIN( 289)													b30->height = height3;
HXDLIN( 289)													b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 289)													b30->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)													{
HXDLIN( 289)														int len7 = b30->length;
HXDLIN( 289)														 ::haxe::ds::GenericStack_Int d3 = b30->data;
HXDLIN( 289)														if (::hx::IsNull( d3->head )) {
HXDLIN( 289)															int _g74 = 0;
HXDLIN( 289)															int _g75 = len7;
HXDLIN( 289)															while((_g74 < _g75)){
HXDLIN( 289)																_g74 = (_g74 + 1);
HXDLIN( 289)																int i31 = (_g74 - 1);
HXDLIN( 289)																d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            															}
            														}
            														else {
HXDLIN( 289)															int _g76 = 0;
HXDLIN( 289)															int _g77 = len7;
HXDLIN( 289)															while((_g76 < _g77)){
HXDLIN( 289)																_g76 = (_g76 + 1);
HXDLIN( 289)																int i32 = (_g76 - 1);
HXDLIN( 289)																{
HXDLIN( 289)																	 ::haxe::ds::GenericCell_Int l3 = b30->data->head;
HXDLIN( 289)																	 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 289)																	{
HXDLIN( 289)																		int _g78 = 0;
HXDLIN( 289)																		int _g79 = i32;
HXDLIN( 289)																		while((_g78 < _g79)){
HXDLIN( 289)																			_g78 = (_g78 + 1);
HXDLIN( 289)																			int i33 = (_g78 - 1);
HXLINE( 345)																			prev3 = l3;
HXLINE( 346)																			l3 = l3->next;
            																		}
            																	}
HXLINE( 289)																	if (::hx::IsNull( prev3 )) {
HXDLIN( 289)																		b30->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 289)																		l3 = null();
            																	}
            																	else {
HXDLIN( 289)																		prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 289)																		l3 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage10 = b30;
            											}
            											break;
            										}
HXDLIN( 289)										this102->image = undoImage10;
HXDLIN( 289)										this102->width = width3;
HXDLIN( 289)										this102->height = height3;
HXDLIN( 289)										this102->imageType = ( (int)(imageType3) );
HXDLIN( 289)										undoImage9 = this102;
HXDLIN( 289)										{
HXDLIN( 289)											int rectLeft3 = xIter33->start;
HXDLIN( 289)											int rectTop3 = yIter33->start;
HXDLIN( 289)											int rectRight3 = xIter33->max;
HXDLIN( 289)											bool forceClear3 = false;
HXDLIN( 289)											{
HXDLIN( 289)												int _g80 = rectTop3;
HXDLIN( 289)												int _g81 = yIter33->max;
HXDLIN( 289)												while((_g80 < _g81)){
HXDLIN( 289)													_g80 = (_g80 + 1);
HXDLIN( 289)													int dy5 = (_g80 - 1);
HXDLIN( 289)													{
HXDLIN( 289)														int _g82 = rectLeft3;
HXDLIN( 289)														int _g83 = rectRight3;
HXDLIN( 289)														while((_g82 < _g83)){
HXDLIN( 289)															_g82 = (_g82 + 1);
HXDLIN( 289)															int dx5 = (_g82 - 1);
HXDLIN( 289)															::Dynamic this104 = this101->image;
HXDLIN( 289)															int index13;
HXDLIN( 289)															if (this101->useVirtualPos) {
HXDLIN( 289)																index13 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this101->virtualY) * ( (Float)(this101->width) )) + dx5) - this101->virtualX));
            															}
            															else {
HXDLIN( 289)																index13 = ::Std_obj::_hx_int(( (Float)(((dy5 * this101->width) + dx5)) ));
            															}
HXDLIN( 289)															int c10 = ::iterMagic::Iimg_obj::get(this104,index13);
HXDLIN( 289)															int col3;
HXDLIN( 289)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																col3 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            															}
            															else {
HXDLIN( 289)																col3 = c10;
            															}
HXDLIN( 289)															bool _hx_tmp24;
HXDLIN( 289)															if (this101->useMask) {
HXDLIN( 289)																_hx_tmp24 = ::hx::IsNotNull( this101->mask );
            															}
            															else {
HXDLIN( 289)																_hx_tmp24 = false;
            															}
HXDLIN( 289)															if (_hx_tmp24) {
HXDLIN( 289)																 ::pi_xy::ImageStruct this105 = this101->mask;
HXDLIN( 289)																::Dynamic this106 = this105->image;
HXDLIN( 289)																int index14;
HXDLIN( 289)																if (this105->useVirtualPos) {
HXDLIN( 289)																	index14 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this105->virtualY) * ( (Float)(this105->width) )) + dx5) - this105->virtualX));
            																}
            																else {
HXDLIN( 289)																	index14 = ::Std_obj::_hx_int(( (Float)(((dy5 * this105->width) + dx5)) ));
            																}
HXDLIN( 289)																int c11 = ::iterMagic::Iimg_obj::get(this106,index14);
HXDLIN( 289)																int v11;
HXDLIN( 289)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																	v11 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            																}
            																else {
HXDLIN( 289)																	v11 = c11;
            																}
HXDLIN( 289)																int maskPixel3 = v11;
HXDLIN( 289)																int this107 = col3;
HXDLIN( 289)																if ((maskPixel3 == 0)) {
HXDLIN( 289)																	col3 = this107;
            																}
            																else {
HXDLIN( 289)																	Float m03;
HXDLIN( 289)																	int this108 = ((maskPixel3 >> 24) & 255);
HXDLIN( 289)																	if ((this108 == 0)) {
HXDLIN( 289)																		m03 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m03 = (( (Float)(this108) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m13;
HXDLIN( 289)																	int this109 = ((maskPixel3 >> 16) & 255);
HXDLIN( 289)																	if ((this109 == 0)) {
HXDLIN( 289)																		m13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m13 = (( (Float)(this109) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m23;
HXDLIN( 289)																	int this110 = ((maskPixel3 >> 8) & 255);
HXDLIN( 289)																	if ((this110 == 0)) {
HXDLIN( 289)																		m23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m23 = (( (Float)(this110) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m33;
HXDLIN( 289)																	int this111 = (maskPixel3 & 255);
HXDLIN( 289)																	if ((this111 == 0)) {
HXDLIN( 289)																		m33 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m33 = (( (Float)(this111) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this107 >> 24) & 255)) )));
HXDLIN( 289)																	int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this107 >> 16) & 255)) )));
HXDLIN( 289)																	int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this107 >> 8) & 255)) )));
HXDLIN( 289)																	int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this107 & 255)) )));
HXDLIN( 289)																	col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 289)															if ((col3 != 0)) {
HXDLIN( 289)																int x13 = (dx5 - rectLeft3);
HXDLIN( 289)																int y12 = (dy5 - rectTop3);
HXDLIN( 289)																int c12 = col3;
HXDLIN( 289)																bool _hx_tmp25;
HXDLIN( 289)																if ((((c12 >> 24) & 255) < 254)) {
HXDLIN( 289)																	_hx_tmp25 = undoImage9->transparent;
            																}
            																else {
HXDLIN( 289)																	_hx_tmp25 = false;
            																}
HXDLIN( 289)																if (_hx_tmp25) {
HXDLIN( 289)																	int location6;
HXDLIN( 289)																	if (undoImage9->useVirtualPos) {
HXDLIN( 289)																		location6 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		location6 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage9->width) + x13)) ));
            																	}
HXDLIN( 289)																	int this112 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 289)																	int this113;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		this113 = this112;
            																	}
HXDLIN( 289)																	Float a110;
HXDLIN( 289)																	int this114 = ((this113 >> 24) & 255);
HXDLIN( 289)																	if ((this114 == 0)) {
HXDLIN( 289)																		a110 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a110 = (( (Float)(this114) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r16;
HXDLIN( 289)																	int this115 = ((this113 >> 16) & 255);
HXDLIN( 289)																	if ((this115 == 0)) {
HXDLIN( 289)																		r16 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r16 = (( (Float)(this115) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g16;
HXDLIN( 289)																	int this116 = ((this113 >> 8) & 255);
HXDLIN( 289)																	if ((this116 == 0)) {
HXDLIN( 289)																		g16 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g16 = (( (Float)(this116) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b111;
HXDLIN( 289)																	int this117 = (this113 & 255);
HXDLIN( 289)																	if ((this117 == 0)) {
HXDLIN( 289)																		b111 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b111 = (( (Float)(this117) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a26;
HXDLIN( 289)																	int this118 = ((col3 >> 24) & 255);
HXDLIN( 289)																	if ((this118 == 0)) {
HXDLIN( 289)																		a26 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a26 = (( (Float)(this118) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r26;
HXDLIN( 289)																	int this119 = ((col3 >> 16) & 255);
HXDLIN( 289)																	if ((this119 == 0)) {
HXDLIN( 289)																		r26 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r26 = (( (Float)(this119) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g26;
HXDLIN( 289)																	int this120 = ((col3 >> 8) & 255);
HXDLIN( 289)																	if ((this120 == 0)) {
HXDLIN( 289)																		g26 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g26 = (( (Float)(this120) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b210;
HXDLIN( 289)																	int this121 = (col3 & 255);
HXDLIN( 289)																	if ((this121 == 0)) {
HXDLIN( 289)																		b210 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b210 = (( (Float)(this121) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a36 = (a110 * (( (Float)(1) ) - a26));
HXDLIN( 289)																	int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 289)																	int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 289)																	int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a36) + (b210 * a26))));
HXDLIN( 289)																	int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 289)																	int blended6 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b31);
HXDLIN( 289)																	{
HXDLIN( 289)																		int _hx_tmp26;
HXDLIN( 289)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																			_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 289)																			_hx_tmp26 = blended6;
            																		}
HXDLIN( 289)																		::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            																	}
            																}
            																else {
HXDLIN( 289)																	::Dynamic this122 = undoImage9->image;
HXDLIN( 289)																	int index15;
HXDLIN( 289)																	if (undoImage9->useVirtualPos) {
HXDLIN( 289)																		index15 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index15 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage9->width) + x13)) ));
            																	}
HXDLIN( 289)																	int _hx_tmp27;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		_hx_tmp27 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		_hx_tmp27 = c12;
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this122,index15,_hx_tmp27);
            																}
            															}
            															else {
HXDLIN( 289)																if (forceClear3) {
HXDLIN( 289)																	::Dynamic this123 = undoImage9->image;
HXDLIN( 289)																	int x14 = (dx5 - rectLeft3);
HXDLIN( 289)																	int y13 = (dy5 - rectTop3);
HXDLIN( 289)																	int index16;
HXDLIN( 289)																	if (undoImage9->useVirtualPos) {
HXDLIN( 289)																		index16 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index16 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x14)) ));
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this123,index16,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 289)									bool found1 = false;
HXDLIN( 289)									Float s1 = ((Float)0.);
HXDLIN( 289)									Float t1 = ((Float)0.);
HXDLIN( 289)									Float sxx1 = ((Float)0.);
HXDLIN( 289)									Float txx1 = ((Float)0.);
HXDLIN( 289)									{
HXDLIN( 289)										int _g_min6 = xIter33->start;
HXDLIN( 289)										int _g_max6 = xIter33->max;
HXDLIN( 289)										while((_g_min6 < _g_max6)){
HXDLIN( 289)											_g_min6 = (_g_min6 + 1);
HXDLIN( 289)											int x15 = (_g_min6 - 1);
HXLINE(  60)											sxx1 = (sx1 * ( (Float)(x15) ));
HXLINE(  61)											txx1 = (tx1 * ( (Float)(x15) ));
HXLINE(  62)											found1 = false;
HXLINE( 289)											{
HXDLIN( 289)												int _g_min7 = yIter33->start;
HXDLIN( 289)												int _g_max7 = yIter33->max;
HXDLIN( 289)												while((_g_min7 < _g_max7)){
HXDLIN( 289)													_g_min7 = (_g_min7 + 1);
HXDLIN( 289)													int y14 = (_g_min7 - 1);
HXLINE(  64)													s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y14) )));
HXLINE(  65)													t1 = ((t01 + txx1) + (ty1 * ( (Float)(y14) )));
HXLINE( 289)													bool _hx_tmp28;
HXDLIN( 289)													if (!((s1 <= 0))) {
HXDLIN( 289)														_hx_tmp28 = (t1 <= 0);
            													}
            													else {
HXDLIN( 289)														_hx_tmp28 = true;
            													}
HXDLIN( 289)													if (_hx_tmp28) {
HXDLIN( 289)														if (found1) {
HXDLIN( 289)															goto _hx_goto_549;
            														}
            													}
            													else {
HXDLIN( 289)														if (((s1 + t1) < A1)) {
HXDLIN( 289)															{
HXDLIN( 289)																int c13 = colorC;
HXDLIN( 289)																bool _hx_tmp29;
HXDLIN( 289)																if ((((c13 >> 24) & 255) < 254)) {
HXDLIN( 289)																	_hx_tmp29 = this101->transparent;
            																}
            																else {
HXDLIN( 289)																	_hx_tmp29 = false;
            																}
HXDLIN( 289)																if (_hx_tmp29) {
HXDLIN( 289)																	int location7;
HXDLIN( 289)																	if (this101->useVirtualPos) {
HXDLIN( 289)																		location7 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - this101->virtualY) * ( (Float)(this101->width) )) + x15) - this101->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		location7 = ::Std_obj::_hx_int(( (Float)(((y14 * this101->width) + x15)) ));
            																	}
HXDLIN( 289)																	int this124 = ::iterMagic::Iimg_obj::get(this101->image,location7);
HXDLIN( 289)																	int this125;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		this125 = ((((((this124 >> 24) & 255) << 24) | ((this124 & 255) << 16)) | (((this124 >> 8) & 255) << 8)) | ((this124 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		this125 = this124;
            																	}
HXDLIN( 289)																	Float a111;
HXDLIN( 289)																	int this126 = ((this125 >> 24) & 255);
HXDLIN( 289)																	if ((this126 == 0)) {
HXDLIN( 289)																		a111 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a111 = (( (Float)(this126) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r17;
HXDLIN( 289)																	int this127 = ((this125 >> 16) & 255);
HXDLIN( 289)																	if ((this127 == 0)) {
HXDLIN( 289)																		r17 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r17 = (( (Float)(this127) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g17;
HXDLIN( 289)																	int this128 = ((this125 >> 8) & 255);
HXDLIN( 289)																	if ((this128 == 0)) {
HXDLIN( 289)																		g17 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g17 = (( (Float)(this128) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b112;
HXDLIN( 289)																	int this129 = (this125 & 255);
HXDLIN( 289)																	if ((this129 == 0)) {
HXDLIN( 289)																		b112 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b112 = (( (Float)(this129) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a27;
HXDLIN( 289)																	int this130 = ((colorC >> 24) & 255);
HXDLIN( 289)																	if ((this130 == 0)) {
HXDLIN( 289)																		a27 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a27 = (( (Float)(this130) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r27;
HXDLIN( 289)																	int this131 = ((colorC >> 16) & 255);
HXDLIN( 289)																	if ((this131 == 0)) {
HXDLIN( 289)																		r27 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r27 = (( (Float)(this131) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g27;
HXDLIN( 289)																	int this132 = ((colorC >> 8) & 255);
HXDLIN( 289)																	if ((this132 == 0)) {
HXDLIN( 289)																		g27 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g27 = (( (Float)(this132) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b211;
HXDLIN( 289)																	int this133 = (colorC & 255);
HXDLIN( 289)																	if ((this133 == 0)) {
HXDLIN( 289)																		b211 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b211 = (( (Float)(this133) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a37 = (a111 * (( (Float)(1) ) - a27));
HXDLIN( 289)																	int r18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 289)																	int g18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 289)																	int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a37) + (b211 * a27))));
HXDLIN( 289)																	int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 289)																	int blended7 = ((((a28 << 24) | (r18 << 16)) | (g18 << 8)) | b32);
HXDLIN( 289)																	{
HXDLIN( 289)																		int _hx_tmp30;
HXDLIN( 289)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																			_hx_tmp30 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 289)																			_hx_tmp30 = blended7;
            																		}
HXDLIN( 289)																		::iterMagic::Iimg_obj::set(this101->image,location7,_hx_tmp30);
            																	}
            																}
            																else {
HXDLIN( 289)																	::Dynamic this134 = this101->image;
HXDLIN( 289)																	int index17;
HXDLIN( 289)																	if (this101->useVirtualPos) {
HXDLIN( 289)																		index17 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - this101->virtualY) * ( (Float)(this101->width) )) + x15) - this101->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index17 = ::Std_obj::_hx_int(( (Float)(((y14 * this101->width) + x15)) ));
            																	}
HXDLIN( 289)																	int _hx_tmp31;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		_hx_tmp31 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		_hx_tmp31 = c13;
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this134,index17,_hx_tmp31);
            																}
            															}
HXLINE(  73)															found1 = true;
            														}
            														else {
HXDLIN( 289)															if (found1) {
HXDLIN( 289)																goto _hx_goto_549;
            															}
            														}
            													}
            												}
            												_hx_goto_549:;
            											}
            										}
            									}
HXDLIN( 289)									if ((hasHit3 == true)) {
HXDLIN( 289)										 ::pi_xy::algo::HitTri v12 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX,cy3,bx2,by1,cx2,cy4,true);
HXDLIN( 289)										if (hasUndo3) {
HXDLIN( 289)											v12->undoImage = undoImage9;
HXDLIN( 289)											v12->undoX = xIter33->start;
HXDLIN( 289)											v12->undoY = yIter33->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  46)						lastX1 = nextX1;
HXLINE(  47)						lastY1 = nextY1;
            					}
            				}
            			}
            		}
HXLINE( 289)		 ::pi_xy::ImageStruct this135 = this1;
HXDLIN( 289)		Float y15 = (y + dy1);
HXDLIN( 289)		Float bx3 = (x + ( (Float)(dx1) ));
HXDLIN( 289)		Float cy5 = (y15 + ( (Float)(tall1) ));
HXDLIN( 289)		{
HXDLIN( 289)			bool hasHit4 = true;
HXDLIN( 289)			{
HXDLIN( 289)				{
HXDLIN( 289)					bool hasUndo4 = false;
HXDLIN( 289)					int aA2 = ((colorA >> 24) & 255);
HXDLIN( 289)					int rA2 = ((colorA >> 16) & 255);
HXDLIN( 289)					int gA2 = ((colorA >> 8) & 255);
HXDLIN( 289)					int bA2 = (colorA & 255);
HXDLIN( 289)					int aB2 = ((colorA >> 24) & 255);
HXDLIN( 289)					int rB2 = ((colorA >> 16) & 255);
HXDLIN( 289)					int gB2 = ((colorA >> 8) & 255);
HXDLIN( 289)					int bB2 = (colorA & 255);
HXDLIN( 289)					int aC2 = ((colorD >> 24) & 255);
HXDLIN( 289)					int rC2 = ((colorD >> 16) & 255);
HXDLIN( 289)					int gC2 = ((colorD >> 8) & 255);
HXDLIN( 289)					int bC2 = (colorD & 255);
HXDLIN( 289)					Float bcx2 = (bx3 - x);
HXDLIN( 289)					Float bcy2 = (y15 - cy5);
HXDLIN( 289)					Float acx2 = (x - x);
HXDLIN( 289)					Float acy2 = (y15 - cy5);
HXDLIN( 289)					Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 289)					Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 289)					Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 289)					Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 289)					if ((x > bx3)) {
HXDLIN( 289)						if ((x > x)) {
HXDLIN( 289)							int min16;
HXDLIN( 289)							if ((bx3 > x)) {
HXDLIN( 289)								min16 = ::Math_obj::floor(x);
            							}
            							else {
HXDLIN( 289)								min16 = ::Math_obj::floor(bx3);
            							}
HXDLIN( 289)							int ii_min32 = min16;
HXDLIN( 289)							int ii_max32 = ::Math_obj::ceil(x);
HXDLIN( 289)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            						}
            						else {
HXDLIN( 289)							int ii_min33 = ::Math_obj::floor(bx3);
HXDLIN( 289)							int ii_max33 = ::Math_obj::ceil(x);
HXDLIN( 289)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx3 > x)) {
HXDLIN( 289)							int min17;
HXDLIN( 289)							if ((x > x)) {
HXDLIN( 289)								min17 = ::Math_obj::floor(x);
            							}
            							else {
HXDLIN( 289)								min17 = ::Math_obj::ceil(x);
            							}
HXDLIN( 289)							int ii_min34 = min17;
HXDLIN( 289)							int ii_max34 = ::Math_obj::ceil(bx3);
HXDLIN( 289)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            						}
            						else {
HXDLIN( 289)							int ii_min35 = ::Math_obj::floor(x);
HXDLIN( 289)							int ii_max35 = ::Math_obj::ceil(x);
HXDLIN( 289)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 289)					if ((y15 > y15)) {
HXDLIN( 289)						if ((y15 > cy5)) {
HXDLIN( 289)							int min18;
HXDLIN( 289)							if ((y15 > cy5)) {
HXDLIN( 289)								min18 = ::Math_obj::floor(cy5);
            							}
            							else {
HXDLIN( 289)								min18 = ::Math_obj::floor(y15);
            							}
HXDLIN( 289)							int ii_min36 = min18;
HXDLIN( 289)							int ii_max36 = ::Math_obj::ceil(y15);
HXDLIN( 289)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            						}
            						else {
HXDLIN( 289)							int ii_min37 = ::Math_obj::floor(y15);
HXDLIN( 289)							int ii_max37 = ::Math_obj::ceil(cy5);
HXDLIN( 289)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            						}
            					}
            					else {
HXDLIN( 289)						if ((y15 > cy5)) {
HXDLIN( 289)							int min19;
HXDLIN( 289)							if ((y15 > cy5)) {
HXDLIN( 289)								min19 = ::Math_obj::floor(cy5);
            							}
            							else {
HXDLIN( 289)								min19 = ::Math_obj::ceil(y15);
            							}
HXDLIN( 289)							int ii_min38 = min19;
HXDLIN( 289)							int ii_max38 = ::Math_obj::ceil(y15);
HXDLIN( 289)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            						}
            						else {
HXDLIN( 289)							int ii_min39 = ::Math_obj::floor(y15);
HXDLIN( 289)							int ii_max39 = ::Math_obj::ceil(cy5);
HXDLIN( 289)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 289)					if (hasUndo4) {
HXDLIN( 289)						int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 289)						int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType4 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this136 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType4 )) {
HXLINE(  54)							imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage13;
HXDLIN( 289)						switch((int)(( (int)(imageType4) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b33 = byt4;
HXDLIN( 289)								{
HXDLIN( 289)									b33->width = width4;
HXDLIN( 289)									b33->height = height4;
HXDLIN( 289)									b33->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 289)									b33->data = ::haxe::io::Bytes_obj::alloc((b33->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len8 = b33->length;
HXDLIN( 289)										int w4 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g84 = 0;
HXDLIN( 289)											int _g85 = b33->height;
HXDLIN( 289)											while((_g84 < _g85)){
HXDLIN( 289)												_g84 = (_g84 + 1);
HXDLIN( 289)												int y16 = (_g84 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g86 = 0;
HXDLIN( 289)													int _g87 = b33->width;
HXDLIN( 289)													while((_g86 < _g87)){
HXDLIN( 289)														_g86 = (_g86 + 1);
HXDLIN( 289)														int x16 = (_g86 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w4 = (w4 + 1);
HXDLIN( 289)															b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w4 = (w4 + 1);
HXDLIN( 289)															b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w4 = (w4 + 1);
HXDLIN( 289)															b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w4 = (w4 + 1);
HXDLIN( 289)															b33->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage13 = b33;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a29 = arrI4;
HXDLIN( 289)								{
HXDLIN( 289)									a29->width = width4;
HXDLIN( 289)									a29->height = height4;
HXDLIN( 289)									a29->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a29->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g88 = 0;
HXDLIN( 289)										int _g89 = a29->length;
HXDLIN( 289)										while((_g88 < _g89)){
HXDLIN( 289)											_g88 = (_g88 + 1);
HXDLIN( 289)											int i34 = (_g88 - 1);
HXDLIN( 289)											a29->data[i34] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage13 = a29;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b34 = u32a4;
HXDLIN( 289)								{
HXDLIN( 289)									b34->width = width4;
HXDLIN( 289)									b34->height = height4;
HXDLIN( 289)									b34->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 289)									int size4 = (b34->length * 4);
HXDLIN( 289)									b34->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 289)									{
HXDLIN( 289)										int _g90 = 0;
HXDLIN( 289)										int _g91 = b34->length;
HXDLIN( 289)										while((_g90 < _g91)){
HXDLIN( 289)											_g90 = (_g90 + 1);
HXDLIN( 289)											int i35 = (_g90 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this137 = b34->data;
HXDLIN( 289)												bool undoImage14;
HXDLIN( 289)												if ((i35 >= 0)) {
HXDLIN( 289)													undoImage14 = (i35 < (this137->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage14 = false;
            												}
HXDLIN( 289)												if (undoImage14) {
HXDLIN( 289)													 ::haxe::io::Bytes _this4 = this137->bytes;
HXDLIN( 289)													int pos4 = ((i35 << 2) + this137->byteOffset);
HXDLIN( 289)													_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 289)													_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage13 = b34;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v13 = vec4;
HXDLIN( 289)								{
HXDLIN( 289)									v13->width = width4;
HXDLIN( 289)									v13->height = height4;
HXDLIN( 289)									v13->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 289)									v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g92 = 0;
HXDLIN( 289)										int _g93 = v13->length;
HXDLIN( 289)										while((_g92 < _g93)){
HXDLIN( 289)											_g92 = (_g92 + 1);
HXDLIN( 289)											int i36 = (_g92 - 1);
HXDLIN( 289)											v13->data->__unsafe_set(i36,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage13 = v13;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b35 = sInt4;
HXDLIN( 289)								{
HXDLIN( 289)									b35->width = width4;
HXDLIN( 289)									b35->height = height4;
HXDLIN( 289)									b35->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 289)									b35->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len9 = b35->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d4 = b35->data;
HXDLIN( 289)										if (::hx::IsNull( d4->head )) {
HXDLIN( 289)											int _g94 = 0;
HXDLIN( 289)											int _g95 = len9;
HXDLIN( 289)											while((_g94 < _g95)){
HXDLIN( 289)												_g94 = (_g94 + 1);
HXDLIN( 289)												int i37 = (_g94 - 1);
HXDLIN( 289)												d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g96 = 0;
HXDLIN( 289)											int _g97 = len9;
HXDLIN( 289)											while((_g96 < _g97)){
HXDLIN( 289)												_g96 = (_g96 + 1);
HXDLIN( 289)												int i38 = (_g96 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l4 = b35->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g98 = 0;
HXDLIN( 289)														int _g99 = i38;
HXDLIN( 289)														while((_g98 < _g99)){
HXDLIN( 289)															_g98 = (_g98 + 1);
HXDLIN( 289)															int i39 = (_g98 - 1);
HXLINE( 345)															prev4 = l4;
HXLINE( 346)															l4 = l4->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev4 )) {
HXDLIN( 289)														b35->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 289)														l4 = null();
            													}
            													else {
HXDLIN( 289)														prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 289)														l4 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage13 = b35;
            							}
            							break;
            						}
HXDLIN( 289)						this136->image = undoImage13;
HXDLIN( 289)						this136->width = width4;
HXDLIN( 289)						this136->height = height4;
HXDLIN( 289)						this136->imageType = ( (int)(imageType4) );
HXDLIN( 289)						undoImage12 = this136;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft4 = xIter34->start;
HXDLIN( 289)							int rectTop4 = yIter34->start;
HXDLIN( 289)							int rectRight4 = xIter34->max;
HXDLIN( 289)							bool forceClear4 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g100 = rectTop4;
HXDLIN( 289)								int _g101 = yIter34->max;
HXDLIN( 289)								while((_g100 < _g101)){
HXDLIN( 289)									_g100 = (_g100 + 1);
HXDLIN( 289)									int dy6 = (_g100 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g102 = rectLeft4;
HXDLIN( 289)										int _g103 = rectRight4;
HXDLIN( 289)										while((_g102 < _g103)){
HXDLIN( 289)											_g102 = (_g102 + 1);
HXDLIN( 289)											int dx6 = (_g102 - 1);
HXDLIN( 289)											::Dynamic this138 = this135->image;
HXDLIN( 289)											int index18;
HXDLIN( 289)											if (this135->useVirtualPos) {
HXDLIN( 289)												index18 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this135->virtualY) * ( (Float)(this135->width) )) + dx6) - this135->virtualX));
            											}
            											else {
HXDLIN( 289)												index18 = ::Std_obj::_hx_int(( (Float)(((dy6 * this135->width) + dx6)) ));
            											}
HXDLIN( 289)											int c14 = ::iterMagic::Iimg_obj::get(this138,index18);
HXDLIN( 289)											int col4;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col4 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col4 = c14;
            											}
HXDLIN( 289)											bool _hx_tmp32;
HXDLIN( 289)											if (this135->useMask) {
HXDLIN( 289)												_hx_tmp32 = ::hx::IsNotNull( this135->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp32 = false;
            											}
HXDLIN( 289)											if (_hx_tmp32) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this139 = this135->mask;
HXDLIN( 289)												::Dynamic this140 = this139->image;
HXDLIN( 289)												int index19;
HXDLIN( 289)												if (this139->useVirtualPos) {
HXDLIN( 289)													index19 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this139->virtualY) * ( (Float)(this139->width) )) + dx6) - this139->virtualX));
            												}
            												else {
HXDLIN( 289)													index19 = ::Std_obj::_hx_int(( (Float)(((dy6 * this139->width) + dx6)) ));
            												}
HXDLIN( 289)												int c15 = ::iterMagic::Iimg_obj::get(this140,index19);
HXDLIN( 289)												int v14;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v14 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v14 = c15;
            												}
HXDLIN( 289)												int maskPixel4 = v14;
HXDLIN( 289)												int this141 = col4;
HXDLIN( 289)												if ((maskPixel4 == 0)) {
HXDLIN( 289)													col4 = this141;
            												}
            												else {
HXDLIN( 289)													Float m04;
HXDLIN( 289)													int this142 = ((maskPixel4 >> 24) & 255);
HXDLIN( 289)													if ((this142 == 0)) {
HXDLIN( 289)														m04 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m04 = (( (Float)(this142) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m14;
HXDLIN( 289)													int this143 = ((maskPixel4 >> 16) & 255);
HXDLIN( 289)													if ((this143 == 0)) {
HXDLIN( 289)														m14 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m14 = (( (Float)(this143) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m24;
HXDLIN( 289)													int this144 = ((maskPixel4 >> 8) & 255);
HXDLIN( 289)													if ((this144 == 0)) {
HXDLIN( 289)														m24 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m24 = (( (Float)(this144) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m34;
HXDLIN( 289)													int this145 = (maskPixel4 & 255);
HXDLIN( 289)													if ((this145 == 0)) {
HXDLIN( 289)														m34 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m34 = (( (Float)(this145) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this141 >> 24) & 255)) )));
HXDLIN( 289)													int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this141 >> 16) & 255)) )));
HXDLIN( 289)													int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this141 >> 8) & 255)) )));
HXDLIN( 289)													int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this141 & 255)) )));
HXDLIN( 289)													col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col4 != 0)) {
HXDLIN( 289)												int x17 = (dx6 - rectLeft4);
HXDLIN( 289)												int y17 = (dy6 - rectTop4);
HXDLIN( 289)												int c16 = col4;
HXDLIN( 289)												bool _hx_tmp33;
HXDLIN( 289)												if ((((c16 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp33 = undoImage12->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp33 = false;
            												}
HXDLIN( 289)												if (_hx_tmp33) {
HXDLIN( 289)													int location8;
HXDLIN( 289)													if (undoImage12->useVirtualPos) {
HXDLIN( 289)														location8 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x17) - undoImage12->virtualX));
            													}
            													else {
HXDLIN( 289)														location8 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage12->width) + x17)) ));
            													}
HXDLIN( 289)													int this146 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 289)													int this147;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this147 = ((((((this146 >> 24) & 255) << 24) | ((this146 & 255) << 16)) | (((this146 >> 8) & 255) << 8)) | ((this146 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this147 = this146;
            													}
HXDLIN( 289)													Float a112;
HXDLIN( 289)													int this148 = ((this147 >> 24) & 255);
HXDLIN( 289)													if ((this148 == 0)) {
HXDLIN( 289)														a112 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a112 = (( (Float)(this148) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r19;
HXDLIN( 289)													int this149 = ((this147 >> 16) & 255);
HXDLIN( 289)													if ((this149 == 0)) {
HXDLIN( 289)														r19 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r19 = (( (Float)(this149) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g19;
HXDLIN( 289)													int this150 = ((this147 >> 8) & 255);
HXDLIN( 289)													if ((this150 == 0)) {
HXDLIN( 289)														g19 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g19 = (( (Float)(this150) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b113;
HXDLIN( 289)													int this151 = (this147 & 255);
HXDLIN( 289)													if ((this151 == 0)) {
HXDLIN( 289)														b113 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b113 = (( (Float)(this151) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a210;
HXDLIN( 289)													int this152 = ((col4 >> 24) & 255);
HXDLIN( 289)													if ((this152 == 0)) {
HXDLIN( 289)														a210 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a210 = (( (Float)(this152) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r28;
HXDLIN( 289)													int this153 = ((col4 >> 16) & 255);
HXDLIN( 289)													if ((this153 == 0)) {
HXDLIN( 289)														r28 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r28 = (( (Float)(this153) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g28;
HXDLIN( 289)													int this154 = ((col4 >> 8) & 255);
HXDLIN( 289)													if ((this154 == 0)) {
HXDLIN( 289)														g28 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g28 = (( (Float)(this154) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b212;
HXDLIN( 289)													int this155 = (col4 & 255);
HXDLIN( 289)													if ((this155 == 0)) {
HXDLIN( 289)														b212 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b212 = (( (Float)(this155) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a38 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 289)													int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a38) + (r28 * a210))));
HXDLIN( 289)													int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a38) + (g28 * a210))));
HXDLIN( 289)													int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a38) + (b212 * a210))));
HXDLIN( 289)													int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN( 289)													int blended8 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b36);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp34;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp34 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp34 = blended8;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage12->image,location8,_hx_tmp34);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this156 = undoImage12->image;
HXDLIN( 289)													int index20;
HXDLIN( 289)													if (undoImage12->useVirtualPos) {
HXDLIN( 289)														index20 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x17) - undoImage12->virtualX));
            													}
            													else {
HXDLIN( 289)														index20 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage12->width) + x17)) ));
            													}
HXDLIN( 289)													int _hx_tmp35;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp35 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp35 = c16;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this156,index20,_hx_tmp35);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear4) {
HXDLIN( 289)													::Dynamic this157 = undoImage12->image;
HXDLIN( 289)													int x18 = (dx6 - rectLeft4);
HXDLIN( 289)													int y18 = (dy6 - rectTop4);
HXDLIN( 289)													int index21;
HXDLIN( 289)													if (undoImage12->useVirtualPos) {
HXDLIN( 289)														index21 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x18) - undoImage12->virtualX));
            													}
            													else {
HXDLIN( 289)														index21 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage12->width) + x18)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this157,index21,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min8 = xIter34->start;
HXDLIN( 289)						int _g_max8 = xIter34->max;
HXDLIN( 289)						while((_g_min8 < _g_max8)){
HXDLIN( 289)							_g_min8 = (_g_min8 + 1);
HXDLIN( 289)							int px2 = (_g_min8 - 1);
HXDLIN( 289)							Float pcx2 = (( (Float)(px2) ) - x);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min9 = yIter34->start;
HXDLIN( 289)								int _g_max9 = yIter34->max;
HXDLIN( 289)								while((_g_min9 < _g_max9)){
HXDLIN( 289)									_g_min9 = (_g_min9 + 1);
HXDLIN( 289)									int py2 = (_g_min9 - 1);
HXDLIN( 289)									Float pcy2 = (( (Float)(py2) ) - cy5);
HXDLIN( 289)									Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 289)									Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 289)									Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 289)									Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 289)									Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 289)									bool _hx_tmp36;
HXDLIN( 289)									bool _hx_tmp37;
HXDLIN( 289)									if ((ratioA2 >= 0)) {
HXDLIN( 289)										_hx_tmp37 = (ratioB2 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp37 = false;
            									}
HXDLIN( 289)									if (_hx_tmp37) {
HXDLIN( 289)										_hx_tmp36 = (ratioC2 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp36 = false;
            									}
HXDLIN( 289)									if (_hx_tmp36) {
HXDLIN( 289)										int i40 = ::Std_obj::_hx_int((((( (Float)(aA2) ) * ratioA2) + (( (Float)(aB2) ) * ratioB2)) + (( (Float)(aC2) ) * ratioC2)));
HXDLIN( 289)										if ((i40 > 255)) {
HXLINE(  24)											i40 = 255;
            										}
HXLINE( 289)										if ((i40 < 0)) {
HXLINE(  25)											i40 = 0;
            										}
HXLINE( 289)										int a39 = i40;
HXDLIN( 289)										int i41 = ::Std_obj::_hx_int((((( (Float)(rA2) ) * ratioA2) + (( (Float)(rB2) ) * ratioB2)) + (( (Float)(rC2) ) * ratioC2)));
HXDLIN( 289)										if ((i41 > 255)) {
HXLINE(  24)											i41 = 255;
            										}
HXLINE( 289)										if ((i41 < 0)) {
HXLINE(  25)											i41 = 0;
            										}
HXLINE( 289)										int r29 = i41;
HXDLIN( 289)										int i42 = ::Std_obj::_hx_int((((( (Float)(gA2) ) * ratioA2) + (( (Float)(gB2) ) * ratioB2)) + (( (Float)(gC2) ) * ratioC2)));
HXDLIN( 289)										if ((i42 > 255)) {
HXLINE(  24)											i42 = 255;
            										}
HXLINE( 289)										if ((i42 < 0)) {
HXLINE(  25)											i42 = 0;
            										}
HXLINE( 289)										int g29 = i42;
HXDLIN( 289)										int i43 = ::Std_obj::_hx_int((((( (Float)(bA2) ) * ratioA2) + (( (Float)(bB2) ) * ratioB2)) + (( (Float)(bC2) ) * ratioC2)));
HXDLIN( 289)										if ((i43 > 255)) {
HXLINE(  24)											i43 = 255;
            										}
HXLINE( 289)										if ((i43 < 0)) {
HXLINE(  25)											i43 = 0;
            										}
HXLINE( 289)										int b37 = i43;
HXDLIN( 289)										{
HXDLIN( 289)											int location9;
HXDLIN( 289)											if (this135->useVirtualPos) {
HXDLIN( 289)												location9 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this135->virtualY) * ( (Float)(this135->width) )) + px2) - this135->virtualX));
            											}
            											else {
HXDLIN( 289)												location9 = ::Std_obj::_hx_int(( (Float)(((py2 * this135->width) + px2)) ));
            											}
HXDLIN( 289)											bool _hx_tmp38;
HXDLIN( 289)											if (this135->transparent) {
HXDLIN( 289)												_hx_tmp38 = (a39 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp38 = false;
            											}
HXDLIN( 289)											if (_hx_tmp38) {
HXDLIN( 289)												int this158 = ::iterMagic::Iimg_obj::get(this135->image,location9);
HXDLIN( 289)												int old2;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old2 = ((((((this158 >> 24) & 255) << 24) | ((this158 & 255) << 16)) | (((this158 >> 8) & 255) << 8)) | ((this158 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old2 = this158;
            												}
HXDLIN( 289)												int rhs2 = ((((a39 << 24) | (r29 << 16)) | (g29 << 8)) | b37);
HXDLIN( 289)												Float a113;
HXDLIN( 289)												int this159 = ((old2 >> 24) & 255);
HXDLIN( 289)												if ((this159 == 0)) {
HXDLIN( 289)													a113 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a113 = (( (Float)(this159) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r110;
HXDLIN( 289)												int this160 = ((old2 >> 16) & 255);
HXDLIN( 289)												if ((this160 == 0)) {
HXDLIN( 289)													r110 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r110 = (( (Float)(this160) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g110;
HXDLIN( 289)												int this161 = ((old2 >> 8) & 255);
HXDLIN( 289)												if ((this161 == 0)) {
HXDLIN( 289)													g110 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g110 = (( (Float)(this161) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b114;
HXDLIN( 289)												int this162 = (old2 & 255);
HXDLIN( 289)												if ((this162 == 0)) {
HXDLIN( 289)													b114 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b114 = (( (Float)(this162) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a211;
HXDLIN( 289)												int this163 = ((rhs2 >> 24) & 255);
HXDLIN( 289)												if ((this163 == 0)) {
HXDLIN( 289)													a211 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a211 = (( (Float)(this163) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r210;
HXDLIN( 289)												int this164 = ((rhs2 >> 16) & 255);
HXDLIN( 289)												if ((this164 == 0)) {
HXDLIN( 289)													r210 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r210 = (( (Float)(this164) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g210;
HXDLIN( 289)												int this165 = ((rhs2 >> 8) & 255);
HXDLIN( 289)												if ((this165 == 0)) {
HXDLIN( 289)													g210 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g210 = (( (Float)(this165) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b213;
HXDLIN( 289)												int this166 = (rhs2 & 255);
HXDLIN( 289)												if ((this166 == 0)) {
HXDLIN( 289)													b213 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b213 = (( (Float)(this166) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 289)												int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 289)												int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 289)												int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b213 * a211))));
HXDLIN( 289)												int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 289)												int blended9 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b38);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp39;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp39 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp39 = blended9;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this135->image,location9,_hx_tmp39);
            												}
            											}
            											else {
HXDLIN( 289)												int value2;
HXDLIN( 289)												if (this135->isLittle) {
HXDLIN( 289)													value2 = ((((a39 << 24) | (b37 << 16)) | (g29 << 8)) | r29);
            												}
            												else {
HXDLIN( 289)													value2 = ((((a39 << 24) | (r29 << 16)) | (g29 << 8)) | b37);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this135->image,location9,value2);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit4 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v15 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x,y15,bx3,y15,x,cy5,true);
HXDLIN( 289)						if (hasUndo4) {
HXDLIN( 289)							v15->undoImage = undoImage12;
HXDLIN( 289)							v15->undoX = xIter34->start;
HXDLIN( 289)							v15->undoY = yIter34->start;
            						}
            					}
            				}
HXDLIN( 289)				{
HXDLIN( 289)					bool hasHit5 = false;
HXDLIN( 289)					bool hasUndo5 = false;
HXDLIN( 289)					int aA3 = ((colorD >> 24) & 255);
HXDLIN( 289)					int rA3 = ((colorD >> 16) & 255);
HXDLIN( 289)					int gA3 = ((colorD >> 8) & 255);
HXDLIN( 289)					int bA3 = (colorD & 255);
HXDLIN( 289)					int aB3 = ((colorA >> 24) & 255);
HXDLIN( 289)					int rB3 = ((colorA >> 16) & 255);
HXDLIN( 289)					int gB3 = ((colorA >> 8) & 255);
HXDLIN( 289)					int bB3 = (colorA & 255);
HXDLIN( 289)					int aC3 = ((colorD >> 24) & 255);
HXDLIN( 289)					int rC3 = ((colorD >> 16) & 255);
HXDLIN( 289)					int gC3 = ((colorD >> 8) & 255);
HXDLIN( 289)					int bC3 = (colorD & 255);
HXDLIN( 289)					Float bcx3 = (bx3 - x);
HXDLIN( 289)					Float bcy3 = (cy5 - cy5);
HXDLIN( 289)					Float acx3 = (bx3 - x);
HXDLIN( 289)					Float acy3 = (y15 - cy5);
HXDLIN( 289)					Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 289)					Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 289)					Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 289)					Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 289)					if ((bx3 > bx3)) {
HXDLIN( 289)						if ((bx3 > x)) {
HXDLIN( 289)							int min20;
HXDLIN( 289)							if ((bx3 > x)) {
HXDLIN( 289)								min20 = ::Math_obj::floor(x);
            							}
            							else {
HXDLIN( 289)								min20 = ::Math_obj::floor(bx3);
            							}
HXDLIN( 289)							int ii_min40 = min20;
HXDLIN( 289)							int ii_max40 = ::Math_obj::ceil(bx3);
HXDLIN( 289)							xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            						}
            						else {
HXDLIN( 289)							int ii_min41 = ::Math_obj::floor(bx3);
HXDLIN( 289)							int ii_max41 = ::Math_obj::ceil(x);
HXDLIN( 289)							xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx3 > x)) {
HXDLIN( 289)							int min21;
HXDLIN( 289)							if ((bx3 > x)) {
HXDLIN( 289)								min21 = ::Math_obj::floor(x);
            							}
            							else {
HXDLIN( 289)								min21 = ::Math_obj::ceil(bx3);
            							}
HXDLIN( 289)							int ii_min42 = min21;
HXDLIN( 289)							int ii_max42 = ::Math_obj::ceil(bx3);
HXDLIN( 289)							xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            						}
            						else {
HXDLIN( 289)							int ii_min43 = ::Math_obj::floor(bx3);
HXDLIN( 289)							int ii_max43 = ::Math_obj::ceil(x);
HXDLIN( 289)							xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 289)					if ((y15 > cy5)) {
HXDLIN( 289)						if ((y15 > cy5)) {
HXDLIN( 289)							int min22;
HXDLIN( 289)							if ((cy5 > cy5)) {
HXDLIN( 289)								min22 = ::Math_obj::floor(cy5);
            							}
            							else {
HXDLIN( 289)								min22 = ::Math_obj::floor(cy5);
            							}
HXDLIN( 289)							int ii_min44 = min22;
HXDLIN( 289)							int ii_max44 = ::Math_obj::ceil(y15);
HXDLIN( 289)							yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            						}
            						else {
HXDLIN( 289)							int ii_min45 = ::Math_obj::floor(cy5);
HXDLIN( 289)							int ii_max45 = ::Math_obj::ceil(cy5);
HXDLIN( 289)							yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            						}
            					}
            					else {
HXDLIN( 289)						if ((cy5 > cy5)) {
HXDLIN( 289)							int min23;
HXDLIN( 289)							if ((y15 > cy5)) {
HXDLIN( 289)								min23 = ::Math_obj::floor(cy5);
            							}
            							else {
HXDLIN( 289)								min23 = ::Math_obj::ceil(y15);
            							}
HXDLIN( 289)							int ii_min46 = min23;
HXDLIN( 289)							int ii_max46 = ::Math_obj::ceil(cy5);
HXDLIN( 289)							yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            						}
            						else {
HXDLIN( 289)							int ii_min47 = ::Math_obj::floor(y15);
HXDLIN( 289)							int ii_max47 = ::Math_obj::ceil(cy5);
HXDLIN( 289)							yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 289)					if (hasUndo5) {
HXDLIN( 289)						int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 289)						int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType5 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this167 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType5 )) {
HXLINE(  54)							imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage16;
HXDLIN( 289)						switch((int)(( (int)(imageType5) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b39 = byt5;
HXDLIN( 289)								{
HXDLIN( 289)									b39->width = width5;
HXDLIN( 289)									b39->height = height5;
HXDLIN( 289)									b39->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 289)									b39->data = ::haxe::io::Bytes_obj::alloc((b39->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len10 = b39->length;
HXDLIN( 289)										int w5 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g104 = 0;
HXDLIN( 289)											int _g105 = b39->height;
HXDLIN( 289)											while((_g104 < _g105)){
HXDLIN( 289)												_g104 = (_g104 + 1);
HXDLIN( 289)												int y19 = (_g104 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g106 = 0;
HXDLIN( 289)													int _g107 = b39->width;
HXDLIN( 289)													while((_g106 < _g107)){
HXDLIN( 289)														_g106 = (_g106 + 1);
HXDLIN( 289)														int x19 = (_g106 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w5 = (w5 + 1);
HXDLIN( 289)															b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w5 = (w5 + 1);
HXDLIN( 289)															b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w5 = (w5 + 1);
HXDLIN( 289)															b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w5 = (w5 + 1);
HXDLIN( 289)															b39->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage16 = b39;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a41 = arrI5;
HXDLIN( 289)								{
HXDLIN( 289)									a41->width = width5;
HXDLIN( 289)									a41->height = height5;
HXDLIN( 289)									a41->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g108 = 0;
HXDLIN( 289)										int _g109 = a41->length;
HXDLIN( 289)										while((_g108 < _g109)){
HXDLIN( 289)											_g108 = (_g108 + 1);
HXDLIN( 289)											int i44 = (_g108 - 1);
HXDLIN( 289)											a41->data[i44] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage16 = a41;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b40 = u32a5;
HXDLIN( 289)								{
HXDLIN( 289)									b40->width = width5;
HXDLIN( 289)									b40->height = height5;
HXDLIN( 289)									b40->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 289)									int size5 = (b40->length * 4);
HXDLIN( 289)									b40->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 289)									{
HXDLIN( 289)										int _g110 = 0;
HXDLIN( 289)										int _g111 = b40->length;
HXDLIN( 289)										while((_g110 < _g111)){
HXDLIN( 289)											_g110 = (_g110 + 1);
HXDLIN( 289)											int i45 = (_g110 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this168 = b40->data;
HXDLIN( 289)												bool undoImage17;
HXDLIN( 289)												if ((i45 >= 0)) {
HXDLIN( 289)													undoImage17 = (i45 < (this168->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage17 = false;
            												}
HXDLIN( 289)												if (undoImage17) {
HXDLIN( 289)													 ::haxe::io::Bytes _this5 = this168->bytes;
HXDLIN( 289)													int pos5 = ((i45 << 2) + this168->byteOffset);
HXDLIN( 289)													_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 289)													_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage16 = b40;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v16 = vec5;
HXDLIN( 289)								{
HXDLIN( 289)									v16->width = width5;
HXDLIN( 289)									v16->height = height5;
HXDLIN( 289)									v16->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 289)									v16->data = ::Array_obj< int >::__new(v16->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g112 = 0;
HXDLIN( 289)										int _g113 = v16->length;
HXDLIN( 289)										while((_g112 < _g113)){
HXDLIN( 289)											_g112 = (_g112 + 1);
HXDLIN( 289)											int i46 = (_g112 - 1);
HXDLIN( 289)											v16->data->__unsafe_set(i46,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage16 = v16;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b41 = sInt5;
HXDLIN( 289)								{
HXDLIN( 289)									b41->width = width5;
HXDLIN( 289)									b41->height = height5;
HXDLIN( 289)									b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 289)									b41->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len11 = b41->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d5 = b41->data;
HXDLIN( 289)										if (::hx::IsNull( d5->head )) {
HXDLIN( 289)											int _g114 = 0;
HXDLIN( 289)											int _g115 = len11;
HXDLIN( 289)											while((_g114 < _g115)){
HXDLIN( 289)												_g114 = (_g114 + 1);
HXDLIN( 289)												int i47 = (_g114 - 1);
HXDLIN( 289)												d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g116 = 0;
HXDLIN( 289)											int _g117 = len11;
HXDLIN( 289)											while((_g116 < _g117)){
HXDLIN( 289)												_g116 = (_g116 + 1);
HXDLIN( 289)												int i48 = (_g116 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l5 = b41->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g118 = 0;
HXDLIN( 289)														int _g119 = i48;
HXDLIN( 289)														while((_g118 < _g119)){
HXDLIN( 289)															_g118 = (_g118 + 1);
HXDLIN( 289)															int i49 = (_g118 - 1);
HXLINE( 345)															prev5 = l5;
HXLINE( 346)															l5 = l5->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev5 )) {
HXDLIN( 289)														b41->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 289)														l5 = null();
            													}
            													else {
HXDLIN( 289)														prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 289)														l5 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage16 = b41;
            							}
            							break;
            						}
HXDLIN( 289)						this167->image = undoImage16;
HXDLIN( 289)						this167->width = width5;
HXDLIN( 289)						this167->height = height5;
HXDLIN( 289)						this167->imageType = ( (int)(imageType5) );
HXDLIN( 289)						undoImage15 = this167;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft5 = xIter35->start;
HXDLIN( 289)							int rectTop5 = yIter35->start;
HXDLIN( 289)							int rectRight5 = xIter35->max;
HXDLIN( 289)							bool forceClear5 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g120 = rectTop5;
HXDLIN( 289)								int _g121 = yIter35->max;
HXDLIN( 289)								while((_g120 < _g121)){
HXDLIN( 289)									_g120 = (_g120 + 1);
HXDLIN( 289)									int dy7 = (_g120 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g122 = rectLeft5;
HXDLIN( 289)										int _g123 = rectRight5;
HXDLIN( 289)										while((_g122 < _g123)){
HXDLIN( 289)											_g122 = (_g122 + 1);
HXDLIN( 289)											int dx7 = (_g122 - 1);
HXDLIN( 289)											::Dynamic this169 = this135->image;
HXDLIN( 289)											int index22;
HXDLIN( 289)											if (this135->useVirtualPos) {
HXDLIN( 289)												index22 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this135->virtualY) * ( (Float)(this135->width) )) + dx7) - this135->virtualX));
            											}
            											else {
HXDLIN( 289)												index22 = ::Std_obj::_hx_int(( (Float)(((dy7 * this135->width) + dx7)) ));
            											}
HXDLIN( 289)											int c17 = ::iterMagic::Iimg_obj::get(this169,index22);
HXDLIN( 289)											int col5;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col5 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col5 = c17;
            											}
HXDLIN( 289)											bool _hx_tmp40;
HXDLIN( 289)											if (this135->useMask) {
HXDLIN( 289)												_hx_tmp40 = ::hx::IsNotNull( this135->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp40 = false;
            											}
HXDLIN( 289)											if (_hx_tmp40) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this170 = this135->mask;
HXDLIN( 289)												::Dynamic this171 = this170->image;
HXDLIN( 289)												int index23;
HXDLIN( 289)												if (this170->useVirtualPos) {
HXDLIN( 289)													index23 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this170->virtualY) * ( (Float)(this170->width) )) + dx7) - this170->virtualX));
            												}
            												else {
HXDLIN( 289)													index23 = ::Std_obj::_hx_int(( (Float)(((dy7 * this170->width) + dx7)) ));
            												}
HXDLIN( 289)												int c18 = ::iterMagic::Iimg_obj::get(this171,index23);
HXDLIN( 289)												int v17;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v17 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v17 = c18;
            												}
HXDLIN( 289)												int maskPixel5 = v17;
HXDLIN( 289)												int this172 = col5;
HXDLIN( 289)												if ((maskPixel5 == 0)) {
HXDLIN( 289)													col5 = this172;
            												}
            												else {
HXDLIN( 289)													Float m05;
HXDLIN( 289)													int this173 = ((maskPixel5 >> 24) & 255);
HXDLIN( 289)													if ((this173 == 0)) {
HXDLIN( 289)														m05 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m05 = (( (Float)(this173) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m15;
HXDLIN( 289)													int this174 = ((maskPixel5 >> 16) & 255);
HXDLIN( 289)													if ((this174 == 0)) {
HXDLIN( 289)														m15 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m15 = (( (Float)(this174) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m25;
HXDLIN( 289)													int this175 = ((maskPixel5 >> 8) & 255);
HXDLIN( 289)													if ((this175 == 0)) {
HXDLIN( 289)														m25 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m25 = (( (Float)(this175) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m35;
HXDLIN( 289)													int this176 = (maskPixel5 & 255);
HXDLIN( 289)													if ((this176 == 0)) {
HXDLIN( 289)														m35 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m35 = (( (Float)(this176) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this172 >> 24) & 255)) )));
HXDLIN( 289)													int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this172 >> 16) & 255)) )));
HXDLIN( 289)													int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this172 >> 8) & 255)) )));
HXDLIN( 289)													int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this172 & 255)) )));
HXDLIN( 289)													col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col5 != 0)) {
HXDLIN( 289)												int x20 = (dx7 - rectLeft5);
HXDLIN( 289)												int y20 = (dy7 - rectTop5);
HXDLIN( 289)												int c19 = col5;
HXDLIN( 289)												bool _hx_tmp41;
HXDLIN( 289)												if ((((c19 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp41 = undoImage15->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp41 = false;
            												}
HXDLIN( 289)												if (_hx_tmp41) {
HXDLIN( 289)													int location10;
HXDLIN( 289)													if (undoImage15->useVirtualPos) {
HXDLIN( 289)														location10 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x20) - undoImage15->virtualX));
            													}
            													else {
HXDLIN( 289)														location10 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage15->width) + x20)) ));
            													}
HXDLIN( 289)													int this177 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 289)													int this178;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this178 = ((((((this177 >> 24) & 255) << 24) | ((this177 & 255) << 16)) | (((this177 >> 8) & 255) << 8)) | ((this177 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this178 = this177;
            													}
HXDLIN( 289)													Float a114;
HXDLIN( 289)													int this179 = ((this178 >> 24) & 255);
HXDLIN( 289)													if ((this179 == 0)) {
HXDLIN( 289)														a114 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a114 = (( (Float)(this179) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r111;
HXDLIN( 289)													int this180 = ((this178 >> 16) & 255);
HXDLIN( 289)													if ((this180 == 0)) {
HXDLIN( 289)														r111 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r111 = (( (Float)(this180) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g111;
HXDLIN( 289)													int this181 = ((this178 >> 8) & 255);
HXDLIN( 289)													if ((this181 == 0)) {
HXDLIN( 289)														g111 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g111 = (( (Float)(this181) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b115;
HXDLIN( 289)													int this182 = (this178 & 255);
HXDLIN( 289)													if ((this182 == 0)) {
HXDLIN( 289)														b115 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b115 = (( (Float)(this182) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a212;
HXDLIN( 289)													int this183 = ((col5 >> 24) & 255);
HXDLIN( 289)													if ((this183 == 0)) {
HXDLIN( 289)														a212 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a212 = (( (Float)(this183) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r211;
HXDLIN( 289)													int this184 = ((col5 >> 16) & 255);
HXDLIN( 289)													if ((this184 == 0)) {
HXDLIN( 289)														r211 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r211 = (( (Float)(this184) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g211;
HXDLIN( 289)													int this185 = ((col5 >> 8) & 255);
HXDLIN( 289)													if ((this185 == 0)) {
HXDLIN( 289)														g211 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g211 = (( (Float)(this185) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b214;
HXDLIN( 289)													int this186 = (col5 & 255);
HXDLIN( 289)													if ((this186 == 0)) {
HXDLIN( 289)														b214 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b214 = (( (Float)(this186) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 289)													int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 289)													int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 289)													int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b214 * a212))));
HXDLIN( 289)													int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 289)													int blended10 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b42);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp42;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp42 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp42 = blended10;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage15->image,location10,_hx_tmp42);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this187 = undoImage15->image;
HXDLIN( 289)													int index24;
HXDLIN( 289)													if (undoImage15->useVirtualPos) {
HXDLIN( 289)														index24 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x20) - undoImage15->virtualX));
            													}
            													else {
HXDLIN( 289)														index24 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage15->width) + x20)) ));
            													}
HXDLIN( 289)													int _hx_tmp43;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp43 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp43 = c19;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this187,index24,_hx_tmp43);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear5) {
HXDLIN( 289)													::Dynamic this188 = undoImage15->image;
HXDLIN( 289)													int x21 = (dx7 - rectLeft5);
HXDLIN( 289)													int y21 = (dy7 - rectTop5);
HXDLIN( 289)													int index25;
HXDLIN( 289)													if (undoImage15->useVirtualPos) {
HXDLIN( 289)														index25 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x21) - undoImage15->virtualX));
            													}
            													else {
HXDLIN( 289)														index25 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage15->width) + x21)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this188,index25,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min10 = xIter35->start;
HXDLIN( 289)						int _g_max10 = xIter35->max;
HXDLIN( 289)						while((_g_min10 < _g_max10)){
HXDLIN( 289)							_g_min10 = (_g_min10 + 1);
HXDLIN( 289)							int px3 = (_g_min10 - 1);
HXDLIN( 289)							Float pcx3 = (( (Float)(px3) ) - x);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min11 = yIter35->start;
HXDLIN( 289)								int _g_max11 = yIter35->max;
HXDLIN( 289)								while((_g_min11 < _g_max11)){
HXDLIN( 289)									_g_min11 = (_g_min11 + 1);
HXDLIN( 289)									int py3 = (_g_min11 - 1);
HXDLIN( 289)									Float pcy3 = (( (Float)(py3) ) - cy5);
HXDLIN( 289)									Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 289)									Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 289)									Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 289)									Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 289)									Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 289)									bool _hx_tmp44;
HXDLIN( 289)									bool _hx_tmp45;
HXDLIN( 289)									if ((ratioA3 >= 0)) {
HXDLIN( 289)										_hx_tmp45 = (ratioB3 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp45 = false;
            									}
HXDLIN( 289)									if (_hx_tmp45) {
HXDLIN( 289)										_hx_tmp44 = (ratioC3 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp44 = false;
            									}
HXDLIN( 289)									if (_hx_tmp44) {
HXDLIN( 289)										int i50 = ::Std_obj::_hx_int((((( (Float)(aA3) ) * ratioA3) + (( (Float)(aB3) ) * ratioB3)) + (( (Float)(aC3) ) * ratioC3)));
HXDLIN( 289)										if ((i50 > 255)) {
HXLINE(  24)											i50 = 255;
            										}
HXLINE( 289)										if ((i50 < 0)) {
HXLINE(  25)											i50 = 0;
            										}
HXLINE( 289)										int a43 = i50;
HXDLIN( 289)										int i51 = ::Std_obj::_hx_int((((( (Float)(rA3) ) * ratioA3) + (( (Float)(rB3) ) * ratioB3)) + (( (Float)(rC3) ) * ratioC3)));
HXDLIN( 289)										if ((i51 > 255)) {
HXLINE(  24)											i51 = 255;
            										}
HXLINE( 289)										if ((i51 < 0)) {
HXLINE(  25)											i51 = 0;
            										}
HXLINE( 289)										int r32 = i51;
HXDLIN( 289)										int i52 = ::Std_obj::_hx_int((((( (Float)(gA3) ) * ratioA3) + (( (Float)(gB3) ) * ratioB3)) + (( (Float)(gC3) ) * ratioC3)));
HXDLIN( 289)										if ((i52 > 255)) {
HXLINE(  24)											i52 = 255;
            										}
HXLINE( 289)										if ((i52 < 0)) {
HXLINE(  25)											i52 = 0;
            										}
HXLINE( 289)										int g32 = i52;
HXDLIN( 289)										int i53 = ::Std_obj::_hx_int((((( (Float)(bA3) ) * ratioA3) + (( (Float)(bB3) ) * ratioB3)) + (( (Float)(bC3) ) * ratioC3)));
HXDLIN( 289)										if ((i53 > 255)) {
HXLINE(  24)											i53 = 255;
            										}
HXLINE( 289)										if ((i53 < 0)) {
HXLINE(  25)											i53 = 0;
            										}
HXLINE( 289)										int b43 = i53;
HXDLIN( 289)										{
HXDLIN( 289)											int location11;
HXDLIN( 289)											if (this135->useVirtualPos) {
HXDLIN( 289)												location11 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this135->virtualY) * ( (Float)(this135->width) )) + px3) - this135->virtualX));
            											}
            											else {
HXDLIN( 289)												location11 = ::Std_obj::_hx_int(( (Float)(((py3 * this135->width) + px3)) ));
            											}
HXDLIN( 289)											bool _hx_tmp46;
HXDLIN( 289)											if (this135->transparent) {
HXDLIN( 289)												_hx_tmp46 = (a43 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp46 = false;
            											}
HXDLIN( 289)											if (_hx_tmp46) {
HXDLIN( 289)												int this189 = ::iterMagic::Iimg_obj::get(this135->image,location11);
HXDLIN( 289)												int old3;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old3 = ((((((this189 >> 24) & 255) << 24) | ((this189 & 255) << 16)) | (((this189 >> 8) & 255) << 8)) | ((this189 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old3 = this189;
            												}
HXDLIN( 289)												int rhs3 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b43);
HXDLIN( 289)												Float a115;
HXDLIN( 289)												int this190 = ((old3 >> 24) & 255);
HXDLIN( 289)												if ((this190 == 0)) {
HXDLIN( 289)													a115 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a115 = (( (Float)(this190) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r112;
HXDLIN( 289)												int this191 = ((old3 >> 16) & 255);
HXDLIN( 289)												if ((this191 == 0)) {
HXDLIN( 289)													r112 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r112 = (( (Float)(this191) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g112;
HXDLIN( 289)												int this192 = ((old3 >> 8) & 255);
HXDLIN( 289)												if ((this192 == 0)) {
HXDLIN( 289)													g112 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g112 = (( (Float)(this192) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b116;
HXDLIN( 289)												int this193 = (old3 & 255);
HXDLIN( 289)												if ((this193 == 0)) {
HXDLIN( 289)													b116 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b116 = (( (Float)(this193) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a213;
HXDLIN( 289)												int this194 = ((rhs3 >> 24) & 255);
HXDLIN( 289)												if ((this194 == 0)) {
HXDLIN( 289)													a213 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a213 = (( (Float)(this194) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r212;
HXDLIN( 289)												int this195 = ((rhs3 >> 16) & 255);
HXDLIN( 289)												if ((this195 == 0)) {
HXDLIN( 289)													r212 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r212 = (( (Float)(this195) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g212;
HXDLIN( 289)												int this196 = ((rhs3 >> 8) & 255);
HXDLIN( 289)												if ((this196 == 0)) {
HXDLIN( 289)													g212 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g212 = (( (Float)(this196) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b215;
HXDLIN( 289)												int this197 = (rhs3 & 255);
HXDLIN( 289)												if ((this197 == 0)) {
HXDLIN( 289)													b215 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b215 = (( (Float)(this197) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 289)												int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 289)												int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 289)												int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b215 * a213))));
HXDLIN( 289)												int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 289)												int blended11 = ((((a44 << 24) | (r33 << 16)) | (g33 << 8)) | b44);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp47;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp47 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp47 = blended11;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this135->image,location11,_hx_tmp47);
            												}
            											}
            											else {
HXDLIN( 289)												int value3;
HXDLIN( 289)												if (this135->isLittle) {
HXDLIN( 289)													value3 = ((((a43 << 24) | (b43 << 16)) | (g32 << 8)) | r32);
            												}
            												else {
HXDLIN( 289)													value3 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b43);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this135->image,location11,value3);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit5 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v18 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx3,y15,bx3,cy5,x,cy5,true);
HXDLIN( 289)						if (hasUndo5) {
HXDLIN( 289)							v18->undoImage = undoImage15;
HXDLIN( 289)							v18->undoX = xIter35->start;
HXDLIN( 289)							v18->undoY = yIter35->start;
            						}
            					}
            				}
HXDLIN( 289)				if ((hasHit4 == true)) {
HXDLIN( 289)					 ::pi_xy::algo::HitQuad v19 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x,y15,bx3,y15,bx3,cy5,x,cy5,true);
            				}
            			}
            		}
HXDLIN( 289)		Float inlobj_ax1 = x;
HXDLIN( 289)		Float inlobj_ay1 = y15;
HXDLIN( 289)		Float inlobj_bx1 = bx3;
HXDLIN( 289)		Float inlobj_y1 = y15;
HXDLIN( 289)		Float inlobj_cx1 = bx3;
HXDLIN( 289)		Float inlobj_cy1 = cy5;
HXDLIN( 289)		Float inlobj_x1 = x;
HXDLIN( 289)		Float inlobj_dy1 = cy5;
HXDLIN( 289)		 ::pi_xy::ImageStruct this198 = this1;
HXDLIN( 289)		Float x22 = (x + dx1);
HXDLIN( 289)		Float y22 = (y + dy1);
HXDLIN( 289)		Float bx4 = (x22 + ( (Float)(fat1) ));
HXDLIN( 289)		Float cy6 = (y22 + ( (Float)(tall1) ));
HXDLIN( 289)		{
HXDLIN( 289)			bool hasHit6 = true;
HXDLIN( 289)			{
HXDLIN( 289)				{
HXDLIN( 289)					bool hasUndo6 = false;
HXDLIN( 289)					int aA4 = ((colorC >> 24) & 255);
HXDLIN( 289)					int rA4 = ((colorC >> 16) & 255);
HXDLIN( 289)					int gA4 = ((colorC >> 8) & 255);
HXDLIN( 289)					int bA4 = (colorC & 255);
HXDLIN( 289)					int aB4 = ((colorA >> 24) & 255);
HXDLIN( 289)					int rB4 = ((colorA >> 16) & 255);
HXDLIN( 289)					int gB4 = ((colorA >> 8) & 255);
HXDLIN( 289)					int bB4 = (colorA & 255);
HXDLIN( 289)					int aC4 = ((colorD >> 24) & 255);
HXDLIN( 289)					int rC4 = ((colorD >> 16) & 255);
HXDLIN( 289)					int gC4 = ((colorD >> 8) & 255);
HXDLIN( 289)					int bC4 = (colorD & 255);
HXDLIN( 289)					Float bcx4 = (bx4 - x22);
HXDLIN( 289)					Float bcy4 = (y22 - cy6);
HXDLIN( 289)					Float acx4 = (x22 - x22);
HXDLIN( 289)					Float acy4 = (y22 - cy6);
HXDLIN( 289)					Float dot114 = ((bcx4 * bcx4) + (bcy4 * bcy4));
HXDLIN( 289)					Float dot124 = ((bcx4 * acx4) + (bcy4 * acy4));
HXDLIN( 289)					Float dot224 = ((acx4 * acx4) + (acy4 * acy4));
HXDLIN( 289)					Float denom14 = (( (Float)(1) ) / ((dot114 * dot224) - (dot124 * dot124)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 289)					if ((x22 > bx4)) {
HXDLIN( 289)						if ((x22 > x22)) {
HXDLIN( 289)							int min24;
HXDLIN( 289)							if ((bx4 > x22)) {
HXDLIN( 289)								min24 = ::Math_obj::floor(x22);
            							}
            							else {
HXDLIN( 289)								min24 = ::Math_obj::floor(bx4);
            							}
HXDLIN( 289)							int ii_min48 = min24;
HXDLIN( 289)							int ii_max48 = ::Math_obj::ceil(x22);
HXDLIN( 289)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            						}
            						else {
HXDLIN( 289)							int ii_min49 = ::Math_obj::floor(bx4);
HXDLIN( 289)							int ii_max49 = ::Math_obj::ceil(x22);
HXDLIN( 289)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx4 > x22)) {
HXDLIN( 289)							int min25;
HXDLIN( 289)							if ((x22 > x22)) {
HXDLIN( 289)								min25 = ::Math_obj::floor(x22);
            							}
            							else {
HXDLIN( 289)								min25 = ::Math_obj::ceil(x22);
            							}
HXDLIN( 289)							int ii_min50 = min25;
HXDLIN( 289)							int ii_max50 = ::Math_obj::ceil(bx4);
HXDLIN( 289)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            						}
            						else {
HXDLIN( 289)							int ii_min51 = ::Math_obj::floor(x22);
HXDLIN( 289)							int ii_max51 = ::Math_obj::ceil(x22);
HXDLIN( 289)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 289)					if ((y22 > y22)) {
HXDLIN( 289)						if ((y22 > cy6)) {
HXDLIN( 289)							int min26;
HXDLIN( 289)							if ((y22 > cy6)) {
HXDLIN( 289)								min26 = ::Math_obj::floor(cy6);
            							}
            							else {
HXDLIN( 289)								min26 = ::Math_obj::floor(y22);
            							}
HXDLIN( 289)							int ii_min52 = min26;
HXDLIN( 289)							int ii_max52 = ::Math_obj::ceil(y22);
HXDLIN( 289)							yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            						}
            						else {
HXDLIN( 289)							int ii_min53 = ::Math_obj::floor(y22);
HXDLIN( 289)							int ii_max53 = ::Math_obj::ceil(cy6);
HXDLIN( 289)							yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            						}
            					}
            					else {
HXDLIN( 289)						if ((y22 > cy6)) {
HXDLIN( 289)							int min27;
HXDLIN( 289)							if ((y22 > cy6)) {
HXDLIN( 289)								min27 = ::Math_obj::floor(cy6);
            							}
            							else {
HXDLIN( 289)								min27 = ::Math_obj::ceil(y22);
            							}
HXDLIN( 289)							int ii_min54 = min27;
HXDLIN( 289)							int ii_max54 = ::Math_obj::ceil(y22);
HXDLIN( 289)							yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            						}
            						else {
HXDLIN( 289)							int ii_min55 = ::Math_obj::floor(y22);
HXDLIN( 289)							int ii_max55 = ::Math_obj::ceil(cy6);
HXDLIN( 289)							yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 289)					if (hasUndo6) {
HXDLIN( 289)						int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 289)						int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType6 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this199 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType6 )) {
HXLINE(  54)							imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage19;
HXDLIN( 289)						switch((int)(( (int)(imageType6) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b45 = byt6;
HXDLIN( 289)								{
HXDLIN( 289)									b45->width = width6;
HXDLIN( 289)									b45->height = height6;
HXDLIN( 289)									b45->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 289)									b45->data = ::haxe::io::Bytes_obj::alloc((b45->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len12 = b45->length;
HXDLIN( 289)										int w6 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g124 = 0;
HXDLIN( 289)											int _g125 = b45->height;
HXDLIN( 289)											while((_g124 < _g125)){
HXDLIN( 289)												_g124 = (_g124 + 1);
HXDLIN( 289)												int y23 = (_g124 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g126 = 0;
HXDLIN( 289)													int _g127 = b45->width;
HXDLIN( 289)													while((_g126 < _g127)){
HXDLIN( 289)														_g126 = (_g126 + 1);
HXDLIN( 289)														int x23 = (_g126 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w6 = (w6 + 1);
HXDLIN( 289)															b45->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w6 = (w6 + 1);
HXDLIN( 289)															b45->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w6 = (w6 + 1);
HXDLIN( 289)															b45->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w6 = (w6 + 1);
HXDLIN( 289)															b45->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage19 = b45;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a45 = arrI6;
HXDLIN( 289)								{
HXDLIN( 289)									a45->width = width6;
HXDLIN( 289)									a45->height = height6;
HXDLIN( 289)									a45->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a45->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g128 = 0;
HXDLIN( 289)										int _g129 = a45->length;
HXDLIN( 289)										while((_g128 < _g129)){
HXDLIN( 289)											_g128 = (_g128 + 1);
HXDLIN( 289)											int i54 = (_g128 - 1);
HXDLIN( 289)											a45->data[i54] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage19 = a45;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b46 = u32a6;
HXDLIN( 289)								{
HXDLIN( 289)									b46->width = width6;
HXDLIN( 289)									b46->height = height6;
HXDLIN( 289)									b46->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 289)									int size6 = (b46->length * 4);
HXDLIN( 289)									b46->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 289)									{
HXDLIN( 289)										int _g130 = 0;
HXDLIN( 289)										int _g131 = b46->length;
HXDLIN( 289)										while((_g130 < _g131)){
HXDLIN( 289)											_g130 = (_g130 + 1);
HXDLIN( 289)											int i55 = (_g130 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this200 = b46->data;
HXDLIN( 289)												bool undoImage20;
HXDLIN( 289)												if ((i55 >= 0)) {
HXDLIN( 289)													undoImage20 = (i55 < (this200->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage20 = false;
            												}
HXDLIN( 289)												if (undoImage20) {
HXDLIN( 289)													 ::haxe::io::Bytes _this6 = this200->bytes;
HXDLIN( 289)													int pos6 = ((i55 << 2) + this200->byteOffset);
HXDLIN( 289)													_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 289)													_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage19 = b46;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v20 = vec6;
HXDLIN( 289)								{
HXDLIN( 289)									v20->width = width6;
HXDLIN( 289)									v20->height = height6;
HXDLIN( 289)									v20->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 289)									v20->data = ::Array_obj< int >::__new(v20->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g132 = 0;
HXDLIN( 289)										int _g133 = v20->length;
HXDLIN( 289)										while((_g132 < _g133)){
HXDLIN( 289)											_g132 = (_g132 + 1);
HXDLIN( 289)											int i56 = (_g132 - 1);
HXDLIN( 289)											v20->data->__unsafe_set(i56,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage19 = v20;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b47 = sInt6;
HXDLIN( 289)								{
HXDLIN( 289)									b47->width = width6;
HXDLIN( 289)									b47->height = height6;
HXDLIN( 289)									b47->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 289)									b47->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len13 = b47->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d6 = b47->data;
HXDLIN( 289)										if (::hx::IsNull( d6->head )) {
HXDLIN( 289)											int _g134 = 0;
HXDLIN( 289)											int _g135 = len13;
HXDLIN( 289)											while((_g134 < _g135)){
HXDLIN( 289)												_g134 = (_g134 + 1);
HXDLIN( 289)												int i57 = (_g134 - 1);
HXDLIN( 289)												d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g136 = 0;
HXDLIN( 289)											int _g137 = len13;
HXDLIN( 289)											while((_g136 < _g137)){
HXDLIN( 289)												_g136 = (_g136 + 1);
HXDLIN( 289)												int i58 = (_g136 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l6 = b47->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g138 = 0;
HXDLIN( 289)														int _g139 = i58;
HXDLIN( 289)														while((_g138 < _g139)){
HXDLIN( 289)															_g138 = (_g138 + 1);
HXDLIN( 289)															int i59 = (_g138 - 1);
HXLINE( 345)															prev6 = l6;
HXLINE( 346)															l6 = l6->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev6 )) {
HXDLIN( 289)														b47->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 289)														l6 = null();
            													}
            													else {
HXDLIN( 289)														prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 289)														l6 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage19 = b47;
            							}
            							break;
            						}
HXDLIN( 289)						this199->image = undoImage19;
HXDLIN( 289)						this199->width = width6;
HXDLIN( 289)						this199->height = height6;
HXDLIN( 289)						this199->imageType = ( (int)(imageType6) );
HXDLIN( 289)						undoImage18 = this199;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft6 = xIter36->start;
HXDLIN( 289)							int rectTop6 = yIter36->start;
HXDLIN( 289)							int rectRight6 = xIter36->max;
HXDLIN( 289)							bool forceClear6 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g140 = rectTop6;
HXDLIN( 289)								int _g141 = yIter36->max;
HXDLIN( 289)								while((_g140 < _g141)){
HXDLIN( 289)									_g140 = (_g140 + 1);
HXDLIN( 289)									int dy8 = (_g140 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g142 = rectLeft6;
HXDLIN( 289)										int _g143 = rectRight6;
HXDLIN( 289)										while((_g142 < _g143)){
HXDLIN( 289)											_g142 = (_g142 + 1);
HXDLIN( 289)											int dx8 = (_g142 - 1);
HXDLIN( 289)											::Dynamic this201 = this198->image;
HXDLIN( 289)											int index26;
HXDLIN( 289)											if (this198->useVirtualPos) {
HXDLIN( 289)												index26 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this198->virtualY) * ( (Float)(this198->width) )) + dx8) - this198->virtualX));
            											}
            											else {
HXDLIN( 289)												index26 = ::Std_obj::_hx_int(( (Float)(((dy8 * this198->width) + dx8)) ));
            											}
HXDLIN( 289)											int c20 = ::iterMagic::Iimg_obj::get(this201,index26);
HXDLIN( 289)											int col6;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col6 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col6 = c20;
            											}
HXDLIN( 289)											bool _hx_tmp48;
HXDLIN( 289)											if (this198->useMask) {
HXDLIN( 289)												_hx_tmp48 = ::hx::IsNotNull( this198->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp48 = false;
            											}
HXDLIN( 289)											if (_hx_tmp48) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this202 = this198->mask;
HXDLIN( 289)												::Dynamic this203 = this202->image;
HXDLIN( 289)												int index27;
HXDLIN( 289)												if (this202->useVirtualPos) {
HXDLIN( 289)													index27 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this202->virtualY) * ( (Float)(this202->width) )) + dx8) - this202->virtualX));
            												}
            												else {
HXDLIN( 289)													index27 = ::Std_obj::_hx_int(( (Float)(((dy8 * this202->width) + dx8)) ));
            												}
HXDLIN( 289)												int c21 = ::iterMagic::Iimg_obj::get(this203,index27);
HXDLIN( 289)												int v21;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v21 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v21 = c21;
            												}
HXDLIN( 289)												int maskPixel6 = v21;
HXDLIN( 289)												int this204 = col6;
HXDLIN( 289)												if ((maskPixel6 == 0)) {
HXDLIN( 289)													col6 = this204;
            												}
            												else {
HXDLIN( 289)													Float m06;
HXDLIN( 289)													int this205 = ((maskPixel6 >> 24) & 255);
HXDLIN( 289)													if ((this205 == 0)) {
HXDLIN( 289)														m06 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m06 = (( (Float)(this205) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m16;
HXDLIN( 289)													int this206 = ((maskPixel6 >> 16) & 255);
HXDLIN( 289)													if ((this206 == 0)) {
HXDLIN( 289)														m16 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m16 = (( (Float)(this206) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m26;
HXDLIN( 289)													int this207 = ((maskPixel6 >> 8) & 255);
HXDLIN( 289)													if ((this207 == 0)) {
HXDLIN( 289)														m26 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m26 = (( (Float)(this207) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m36;
HXDLIN( 289)													int this208 = (maskPixel6 & 255);
HXDLIN( 289)													if ((this208 == 0)) {
HXDLIN( 289)														m36 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m36 = (( (Float)(this208) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this204 >> 24) & 255)) )));
HXDLIN( 289)													int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this204 >> 16) & 255)) )));
HXDLIN( 289)													int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this204 >> 8) & 255)) )));
HXDLIN( 289)													int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this204 & 255)) )));
HXDLIN( 289)													col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col6 != 0)) {
HXDLIN( 289)												int x24 = (dx8 - rectLeft6);
HXDLIN( 289)												int y24 = (dy8 - rectTop6);
HXDLIN( 289)												int c22 = col6;
HXDLIN( 289)												bool _hx_tmp49;
HXDLIN( 289)												if ((((c22 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp49 = undoImage18->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp49 = false;
            												}
HXDLIN( 289)												if (_hx_tmp49) {
HXDLIN( 289)													int location12;
HXDLIN( 289)													if (undoImage18->useVirtualPos) {
HXDLIN( 289)														location12 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x24) - undoImage18->virtualX));
            													}
            													else {
HXDLIN( 289)														location12 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage18->width) + x24)) ));
            													}
HXDLIN( 289)													int this209 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 289)													int this210;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this210 = ((((((this209 >> 24) & 255) << 24) | ((this209 & 255) << 16)) | (((this209 >> 8) & 255) << 8)) | ((this209 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this210 = this209;
            													}
HXDLIN( 289)													Float a116;
HXDLIN( 289)													int this211 = ((this210 >> 24) & 255);
HXDLIN( 289)													if ((this211 == 0)) {
HXDLIN( 289)														a116 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a116 = (( (Float)(this211) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r113;
HXDLIN( 289)													int this212 = ((this210 >> 16) & 255);
HXDLIN( 289)													if ((this212 == 0)) {
HXDLIN( 289)														r113 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r113 = (( (Float)(this212) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g113;
HXDLIN( 289)													int this213 = ((this210 >> 8) & 255);
HXDLIN( 289)													if ((this213 == 0)) {
HXDLIN( 289)														g113 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g113 = (( (Float)(this213) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b117;
HXDLIN( 289)													int this214 = (this210 & 255);
HXDLIN( 289)													if ((this214 == 0)) {
HXDLIN( 289)														b117 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b117 = (( (Float)(this214) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a214;
HXDLIN( 289)													int this215 = ((col6 >> 24) & 255);
HXDLIN( 289)													if ((this215 == 0)) {
HXDLIN( 289)														a214 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a214 = (( (Float)(this215) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r213;
HXDLIN( 289)													int this216 = ((col6 >> 16) & 255);
HXDLIN( 289)													if ((this216 == 0)) {
HXDLIN( 289)														r213 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r213 = (( (Float)(this216) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g213;
HXDLIN( 289)													int this217 = ((col6 >> 8) & 255);
HXDLIN( 289)													if ((this217 == 0)) {
HXDLIN( 289)														g213 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g213 = (( (Float)(this217) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b216;
HXDLIN( 289)													int this218 = (col6 & 255);
HXDLIN( 289)													if ((this218 == 0)) {
HXDLIN( 289)														b216 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b216 = (( (Float)(this218) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN( 289)													int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 289)													int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 289)													int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b216 * a214))));
HXDLIN( 289)													int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 289)													int blended12 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b48);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp50;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp50 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp50 = blended12;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp50);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this219 = undoImage18->image;
HXDLIN( 289)													int index28;
HXDLIN( 289)													if (undoImage18->useVirtualPos) {
HXDLIN( 289)														index28 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x24) - undoImage18->virtualX));
            													}
            													else {
HXDLIN( 289)														index28 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage18->width) + x24)) ));
            													}
HXDLIN( 289)													int _hx_tmp51;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp51 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp51 = c22;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this219,index28,_hx_tmp51);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear6) {
HXDLIN( 289)													::Dynamic this220 = undoImage18->image;
HXDLIN( 289)													int x25 = (dx8 - rectLeft6);
HXDLIN( 289)													int y25 = (dy8 - rectTop6);
HXDLIN( 289)													int index29;
HXDLIN( 289)													if (undoImage18->useVirtualPos) {
HXDLIN( 289)														index29 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x25) - undoImage18->virtualX));
            													}
            													else {
HXDLIN( 289)														index29 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage18->width) + x25)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this220,index29,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min12 = xIter36->start;
HXDLIN( 289)						int _g_max12 = xIter36->max;
HXDLIN( 289)						while((_g_min12 < _g_max12)){
HXDLIN( 289)							_g_min12 = (_g_min12 + 1);
HXDLIN( 289)							int px4 = (_g_min12 - 1);
HXDLIN( 289)							Float pcx4 = (( (Float)(px4) ) - x22);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min13 = yIter36->start;
HXDLIN( 289)								int _g_max13 = yIter36->max;
HXDLIN( 289)								while((_g_min13 < _g_max13)){
HXDLIN( 289)									_g_min13 = (_g_min13 + 1);
HXDLIN( 289)									int py4 = (_g_min13 - 1);
HXDLIN( 289)									Float pcy4 = (( (Float)(py4) ) - cy6);
HXDLIN( 289)									Float dot314 = ((pcx4 * bcx4) + (pcy4 * bcy4));
HXDLIN( 289)									Float dot324 = ((pcx4 * acx4) + (pcy4 * acy4));
HXDLIN( 289)									Float ratioA4 = (((dot224 * dot314) - (dot124 * dot324)) * denom14);
HXDLIN( 289)									Float ratioB4 = (((dot114 * dot324) - (dot124 * dot314)) * denom14);
HXDLIN( 289)									Float ratioC4 = ((((Float)1.0) - ratioB4) - ratioA4);
HXDLIN( 289)									bool _hx_tmp52;
HXDLIN( 289)									bool _hx_tmp53;
HXDLIN( 289)									if ((ratioA4 >= 0)) {
HXDLIN( 289)										_hx_tmp53 = (ratioB4 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp53 = false;
            									}
HXDLIN( 289)									if (_hx_tmp53) {
HXDLIN( 289)										_hx_tmp52 = (ratioC4 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp52 = false;
            									}
HXDLIN( 289)									if (_hx_tmp52) {
HXDLIN( 289)										int i60 = ::Std_obj::_hx_int((((( (Float)(aA4) ) * ratioA4) + (( (Float)(aB4) ) * ratioB4)) + (( (Float)(aC4) ) * ratioC4)));
HXDLIN( 289)										if ((i60 > 255)) {
HXLINE(  24)											i60 = 255;
            										}
HXLINE( 289)										if ((i60 < 0)) {
HXLINE(  25)											i60 = 0;
            										}
HXLINE( 289)										int a47 = i60;
HXDLIN( 289)										int i61 = ::Std_obj::_hx_int((((( (Float)(rA4) ) * ratioA4) + (( (Float)(rB4) ) * ratioB4)) + (( (Float)(rC4) ) * ratioC4)));
HXDLIN( 289)										if ((i61 > 255)) {
HXLINE(  24)											i61 = 255;
            										}
HXLINE( 289)										if ((i61 < 0)) {
HXLINE(  25)											i61 = 0;
            										}
HXLINE( 289)										int r35 = i61;
HXDLIN( 289)										int i62 = ::Std_obj::_hx_int((((( (Float)(gA4) ) * ratioA4) + (( (Float)(gB4) ) * ratioB4)) + (( (Float)(gC4) ) * ratioC4)));
HXDLIN( 289)										if ((i62 > 255)) {
HXLINE(  24)											i62 = 255;
            										}
HXLINE( 289)										if ((i62 < 0)) {
HXLINE(  25)											i62 = 0;
            										}
HXLINE( 289)										int g35 = i62;
HXDLIN( 289)										int i63 = ::Std_obj::_hx_int((((( (Float)(bA4) ) * ratioA4) + (( (Float)(bB4) ) * ratioB4)) + (( (Float)(bC4) ) * ratioC4)));
HXDLIN( 289)										if ((i63 > 255)) {
HXLINE(  24)											i63 = 255;
            										}
HXLINE( 289)										if ((i63 < 0)) {
HXLINE(  25)											i63 = 0;
            										}
HXLINE( 289)										int b49 = i63;
HXDLIN( 289)										{
HXDLIN( 289)											int location13;
HXDLIN( 289)											if (this198->useVirtualPos) {
HXDLIN( 289)												location13 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - this198->virtualY) * ( (Float)(this198->width) )) + px4) - this198->virtualX));
            											}
            											else {
HXDLIN( 289)												location13 = ::Std_obj::_hx_int(( (Float)(((py4 * this198->width) + px4)) ));
            											}
HXDLIN( 289)											bool _hx_tmp54;
HXDLIN( 289)											if (this198->transparent) {
HXDLIN( 289)												_hx_tmp54 = (a47 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp54 = false;
            											}
HXDLIN( 289)											if (_hx_tmp54) {
HXDLIN( 289)												int this221 = ::iterMagic::Iimg_obj::get(this198->image,location13);
HXDLIN( 289)												int old4;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old4 = ((((((this221 >> 24) & 255) << 24) | ((this221 & 255) << 16)) | (((this221 >> 8) & 255) << 8)) | ((this221 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old4 = this221;
            												}
HXDLIN( 289)												int rhs4 = ((((a47 << 24) | (r35 << 16)) | (g35 << 8)) | b49);
HXDLIN( 289)												Float a117;
HXDLIN( 289)												int this222 = ((old4 >> 24) & 255);
HXDLIN( 289)												if ((this222 == 0)) {
HXDLIN( 289)													a117 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a117 = (( (Float)(this222) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r114;
HXDLIN( 289)												int this223 = ((old4 >> 16) & 255);
HXDLIN( 289)												if ((this223 == 0)) {
HXDLIN( 289)													r114 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r114 = (( (Float)(this223) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g114;
HXDLIN( 289)												int this224 = ((old4 >> 8) & 255);
HXDLIN( 289)												if ((this224 == 0)) {
HXDLIN( 289)													g114 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g114 = (( (Float)(this224) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b118;
HXDLIN( 289)												int this225 = (old4 & 255);
HXDLIN( 289)												if ((this225 == 0)) {
HXDLIN( 289)													b118 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b118 = (( (Float)(this225) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a215;
HXDLIN( 289)												int this226 = ((rhs4 >> 24) & 255);
HXDLIN( 289)												if ((this226 == 0)) {
HXDLIN( 289)													a215 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a215 = (( (Float)(this226) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r214;
HXDLIN( 289)												int this227 = ((rhs4 >> 16) & 255);
HXDLIN( 289)												if ((this227 == 0)) {
HXDLIN( 289)													r214 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r214 = (( (Float)(this227) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g214;
HXDLIN( 289)												int this228 = ((rhs4 >> 8) & 255);
HXDLIN( 289)												if ((this228 == 0)) {
HXDLIN( 289)													g214 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g214 = (( (Float)(this228) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b217;
HXDLIN( 289)												int this229 = (rhs4 & 255);
HXDLIN( 289)												if ((this229 == 0)) {
HXDLIN( 289)													b217 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b217 = (( (Float)(this229) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN( 289)												int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 289)												int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 289)												int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b217 * a215))));
HXDLIN( 289)												int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 289)												int blended13 = ((((a48 << 24) | (r36 << 16)) | (g36 << 8)) | b50);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp55;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp55 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp55 = blended13;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this198->image,location13,_hx_tmp55);
            												}
            											}
            											else {
HXDLIN( 289)												int value4;
HXDLIN( 289)												if (this198->isLittle) {
HXDLIN( 289)													value4 = ((((a47 << 24) | (b49 << 16)) | (g35 << 8)) | r35);
            												}
            												else {
HXDLIN( 289)													value4 = ((((a47 << 24) | (r35 << 16)) | (g35 << 8)) | b49);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this198->image,location13,value4);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit6 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v22 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x22,y22,bx4,y22,x22,cy6,true);
HXDLIN( 289)						if (hasUndo6) {
HXDLIN( 289)							v22->undoImage = undoImage18;
HXDLIN( 289)							v22->undoX = xIter36->start;
HXDLIN( 289)							v22->undoY = yIter36->start;
            						}
            					}
            				}
HXDLIN( 289)				{
HXDLIN( 289)					bool hasHit7 = false;
HXDLIN( 289)					bool hasUndo7 = false;
HXDLIN( 289)					int aA5 = ((colorB >> 24) & 255);
HXDLIN( 289)					int rA5 = ((colorB >> 16) & 255);
HXDLIN( 289)					int gA5 = ((colorB >> 8) & 255);
HXDLIN( 289)					int bA5 = (colorB & 255);
HXDLIN( 289)					int aB5 = ((colorC >> 24) & 255);
HXDLIN( 289)					int rB5 = ((colorC >> 16) & 255);
HXDLIN( 289)					int gB5 = ((colorC >> 8) & 255);
HXDLIN( 289)					int bB5 = (colorC & 255);
HXDLIN( 289)					int aC5 = ((colorD >> 24) & 255);
HXDLIN( 289)					int rC5 = ((colorD >> 16) & 255);
HXDLIN( 289)					int gC5 = ((colorD >> 8) & 255);
HXDLIN( 289)					int bC5 = (colorD & 255);
HXDLIN( 289)					Float bcx5 = (bx4 - x22);
HXDLIN( 289)					Float bcy5 = (cy6 - cy6);
HXDLIN( 289)					Float acx5 = (bx4 - x22);
HXDLIN( 289)					Float acy5 = (y22 - cy6);
HXDLIN( 289)					Float dot115 = ((bcx5 * bcx5) + (bcy5 * bcy5));
HXDLIN( 289)					Float dot125 = ((bcx5 * acx5) + (bcy5 * acy5));
HXDLIN( 289)					Float dot225 = ((acx5 * acx5) + (acy5 * acy5));
HXDLIN( 289)					Float denom15 = (( (Float)(1) ) / ((dot115 * dot225) - (dot125 * dot125)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter37;
HXDLIN( 289)					if ((bx4 > bx4)) {
HXDLIN( 289)						if ((bx4 > x22)) {
HXDLIN( 289)							int min28;
HXDLIN( 289)							if ((bx4 > x22)) {
HXDLIN( 289)								min28 = ::Math_obj::floor(x22);
            							}
            							else {
HXDLIN( 289)								min28 = ::Math_obj::floor(bx4);
            							}
HXDLIN( 289)							int ii_min56 = min28;
HXDLIN( 289)							int ii_max56 = ::Math_obj::ceil(bx4);
HXDLIN( 289)							xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            						}
            						else {
HXDLIN( 289)							int ii_min57 = ::Math_obj::floor(bx4);
HXDLIN( 289)							int ii_max57 = ::Math_obj::ceil(x22);
HXDLIN( 289)							xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx4 > x22)) {
HXDLIN( 289)							int min29;
HXDLIN( 289)							if ((bx4 > x22)) {
HXDLIN( 289)								min29 = ::Math_obj::floor(x22);
            							}
            							else {
HXDLIN( 289)								min29 = ::Math_obj::ceil(bx4);
            							}
HXDLIN( 289)							int ii_min58 = min29;
HXDLIN( 289)							int ii_max58 = ::Math_obj::ceil(bx4);
HXDLIN( 289)							xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            						}
            						else {
HXDLIN( 289)							int ii_min59 = ::Math_obj::floor(bx4);
HXDLIN( 289)							int ii_max59 = ::Math_obj::ceil(x22);
HXDLIN( 289)							xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter37;
HXDLIN( 289)					if ((y22 > cy6)) {
HXDLIN( 289)						if ((y22 > cy6)) {
HXDLIN( 289)							int min30;
HXDLIN( 289)							if ((cy6 > cy6)) {
HXDLIN( 289)								min30 = ::Math_obj::floor(cy6);
            							}
            							else {
HXDLIN( 289)								min30 = ::Math_obj::floor(cy6);
            							}
HXDLIN( 289)							int ii_min60 = min30;
HXDLIN( 289)							int ii_max60 = ::Math_obj::ceil(y22);
HXDLIN( 289)							yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            						}
            						else {
HXDLIN( 289)							int ii_min61 = ::Math_obj::floor(cy6);
HXDLIN( 289)							int ii_max61 = ::Math_obj::ceil(cy6);
HXDLIN( 289)							yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            						}
            					}
            					else {
HXDLIN( 289)						if ((cy6 > cy6)) {
HXDLIN( 289)							int min31;
HXDLIN( 289)							if ((y22 > cy6)) {
HXDLIN( 289)								min31 = ::Math_obj::floor(cy6);
            							}
            							else {
HXDLIN( 289)								min31 = ::Math_obj::ceil(y22);
            							}
HXDLIN( 289)							int ii_min62 = min31;
HXDLIN( 289)							int ii_max62 = ::Math_obj::ceil(cy6);
HXDLIN( 289)							yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            						}
            						else {
HXDLIN( 289)							int ii_min63 = ::Math_obj::floor(y22);
HXDLIN( 289)							int ii_max63 = ::Math_obj::ceil(cy6);
HXDLIN( 289)							yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage21 = null();
HXDLIN( 289)					if (hasUndo7) {
HXDLIN( 289)						int width7 = ((xIter37->max - xIter37->start) + 1);
HXDLIN( 289)						int height7 = ((yIter37->max - yIter37->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType7 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this230 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType7 )) {
HXLINE(  54)							imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage22;
HXDLIN( 289)						switch((int)(( (int)(imageType7) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b51 = byt7;
HXDLIN( 289)								{
HXDLIN( 289)									b51->width = width7;
HXDLIN( 289)									b51->height = height7;
HXDLIN( 289)									b51->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 289)									b51->data = ::haxe::io::Bytes_obj::alloc((b51->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len14 = b51->length;
HXDLIN( 289)										int w7 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g144 = 0;
HXDLIN( 289)											int _g145 = b51->height;
HXDLIN( 289)											while((_g144 < _g145)){
HXDLIN( 289)												_g144 = (_g144 + 1);
HXDLIN( 289)												int y26 = (_g144 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g146 = 0;
HXDLIN( 289)													int _g147 = b51->width;
HXDLIN( 289)													while((_g146 < _g147)){
HXDLIN( 289)														_g146 = (_g146 + 1);
HXDLIN( 289)														int x26 = (_g146 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w7 = (w7 + 1);
HXDLIN( 289)															b51->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w7 = (w7 + 1);
HXDLIN( 289)															b51->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w7 = (w7 + 1);
HXDLIN( 289)															b51->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w7 = (w7 + 1);
HXDLIN( 289)															b51->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage22 = b51;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a49 = arrI7;
HXDLIN( 289)								{
HXDLIN( 289)									a49->width = width7;
HXDLIN( 289)									a49->height = height7;
HXDLIN( 289)									a49->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a49->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g148 = 0;
HXDLIN( 289)										int _g149 = a49->length;
HXDLIN( 289)										while((_g148 < _g149)){
HXDLIN( 289)											_g148 = (_g148 + 1);
HXDLIN( 289)											int i64 = (_g148 - 1);
HXDLIN( 289)											a49->data[i64] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage22 = a49;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b52 = u32a7;
HXDLIN( 289)								{
HXDLIN( 289)									b52->width = width7;
HXDLIN( 289)									b52->height = height7;
HXDLIN( 289)									b52->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 289)									int size7 = (b52->length * 4);
HXDLIN( 289)									b52->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN( 289)									{
HXDLIN( 289)										int _g150 = 0;
HXDLIN( 289)										int _g151 = b52->length;
HXDLIN( 289)										while((_g150 < _g151)){
HXDLIN( 289)											_g150 = (_g150 + 1);
HXDLIN( 289)											int i65 = (_g150 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this231 = b52->data;
HXDLIN( 289)												bool undoImage23;
HXDLIN( 289)												if ((i65 >= 0)) {
HXDLIN( 289)													undoImage23 = (i65 < (this231->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage23 = false;
            												}
HXDLIN( 289)												if (undoImage23) {
HXDLIN( 289)													 ::haxe::io::Bytes _this7 = this231->bytes;
HXDLIN( 289)													int pos7 = ((i65 << 2) + this231->byteOffset);
HXDLIN( 289)													_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN( 289)													_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage22 = b52;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v23 = vec7;
HXDLIN( 289)								{
HXDLIN( 289)									v23->width = width7;
HXDLIN( 289)									v23->height = height7;
HXDLIN( 289)									v23->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 289)									v23->data = ::Array_obj< int >::__new(v23->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g152 = 0;
HXDLIN( 289)										int _g153 = v23->length;
HXDLIN( 289)										while((_g152 < _g153)){
HXDLIN( 289)											_g152 = (_g152 + 1);
HXDLIN( 289)											int i66 = (_g152 - 1);
HXDLIN( 289)											v23->data->__unsafe_set(i66,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage22 = v23;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b53 = sInt7;
HXDLIN( 289)								{
HXDLIN( 289)									b53->width = width7;
HXDLIN( 289)									b53->height = height7;
HXDLIN( 289)									b53->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 289)									b53->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len15 = b53->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d7 = b53->data;
HXDLIN( 289)										if (::hx::IsNull( d7->head )) {
HXDLIN( 289)											int _g154 = 0;
HXDLIN( 289)											int _g155 = len15;
HXDLIN( 289)											while((_g154 < _g155)){
HXDLIN( 289)												_g154 = (_g154 + 1);
HXDLIN( 289)												int i67 = (_g154 - 1);
HXDLIN( 289)												d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g156 = 0;
HXDLIN( 289)											int _g157 = len15;
HXDLIN( 289)											while((_g156 < _g157)){
HXDLIN( 289)												_g156 = (_g156 + 1);
HXDLIN( 289)												int i68 = (_g156 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l7 = b53->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g158 = 0;
HXDLIN( 289)														int _g159 = i68;
HXDLIN( 289)														while((_g158 < _g159)){
HXDLIN( 289)															_g158 = (_g158 + 1);
HXDLIN( 289)															int i69 = (_g158 - 1);
HXLINE( 345)															prev7 = l7;
HXLINE( 346)															l7 = l7->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev7 )) {
HXDLIN( 289)														b53->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 289)														l7 = null();
            													}
            													else {
HXDLIN( 289)														prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 289)														l7 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage22 = b53;
            							}
            							break;
            						}
HXDLIN( 289)						this230->image = undoImage22;
HXDLIN( 289)						this230->width = width7;
HXDLIN( 289)						this230->height = height7;
HXDLIN( 289)						this230->imageType = ( (int)(imageType7) );
HXDLIN( 289)						undoImage21 = this230;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft7 = xIter37->start;
HXDLIN( 289)							int rectTop7 = yIter37->start;
HXDLIN( 289)							int rectRight7 = xIter37->max;
HXDLIN( 289)							bool forceClear7 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g160 = rectTop7;
HXDLIN( 289)								int _g161 = yIter37->max;
HXDLIN( 289)								while((_g160 < _g161)){
HXDLIN( 289)									_g160 = (_g160 + 1);
HXDLIN( 289)									int dy9 = (_g160 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g162 = rectLeft7;
HXDLIN( 289)										int _g163 = rectRight7;
HXDLIN( 289)										while((_g162 < _g163)){
HXDLIN( 289)											_g162 = (_g162 + 1);
HXDLIN( 289)											int dx9 = (_g162 - 1);
HXDLIN( 289)											::Dynamic this232 = this198->image;
HXDLIN( 289)											int index30;
HXDLIN( 289)											if (this198->useVirtualPos) {
HXDLIN( 289)												index30 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this198->virtualY) * ( (Float)(this198->width) )) + dx9) - this198->virtualX));
            											}
            											else {
HXDLIN( 289)												index30 = ::Std_obj::_hx_int(( (Float)(((dy9 * this198->width) + dx9)) ));
            											}
HXDLIN( 289)											int c23 = ::iterMagic::Iimg_obj::get(this232,index30);
HXDLIN( 289)											int col7;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col7 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col7 = c23;
            											}
HXDLIN( 289)											bool _hx_tmp56;
HXDLIN( 289)											if (this198->useMask) {
HXDLIN( 289)												_hx_tmp56 = ::hx::IsNotNull( this198->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp56 = false;
            											}
HXDLIN( 289)											if (_hx_tmp56) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this233 = this198->mask;
HXDLIN( 289)												::Dynamic this234 = this233->image;
HXDLIN( 289)												int index31;
HXDLIN( 289)												if (this233->useVirtualPos) {
HXDLIN( 289)													index31 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this233->virtualY) * ( (Float)(this233->width) )) + dx9) - this233->virtualX));
            												}
            												else {
HXDLIN( 289)													index31 = ::Std_obj::_hx_int(( (Float)(((dy9 * this233->width) + dx9)) ));
            												}
HXDLIN( 289)												int c24 = ::iterMagic::Iimg_obj::get(this234,index31);
HXDLIN( 289)												int v24;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v24 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v24 = c24;
            												}
HXDLIN( 289)												int maskPixel7 = v24;
HXDLIN( 289)												int this235 = col7;
HXDLIN( 289)												if ((maskPixel7 == 0)) {
HXDLIN( 289)													col7 = this235;
            												}
            												else {
HXDLIN( 289)													Float m07;
HXDLIN( 289)													int this236 = ((maskPixel7 >> 24) & 255);
HXDLIN( 289)													if ((this236 == 0)) {
HXDLIN( 289)														m07 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m07 = (( (Float)(this236) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m17;
HXDLIN( 289)													int this237 = ((maskPixel7 >> 16) & 255);
HXDLIN( 289)													if ((this237 == 0)) {
HXDLIN( 289)														m17 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m17 = (( (Float)(this237) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m27;
HXDLIN( 289)													int this238 = ((maskPixel7 >> 8) & 255);
HXDLIN( 289)													if ((this238 == 0)) {
HXDLIN( 289)														m27 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m27 = (( (Float)(this238) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m37;
HXDLIN( 289)													int this239 = (maskPixel7 & 255);
HXDLIN( 289)													if ((this239 == 0)) {
HXDLIN( 289)														m37 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m37 = (( (Float)(this239) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this235 >> 24) & 255)) )));
HXDLIN( 289)													int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this235 >> 16) & 255)) )));
HXDLIN( 289)													int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this235 >> 8) & 255)) )));
HXDLIN( 289)													int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this235 & 255)) )));
HXDLIN( 289)													col7 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col7 != 0)) {
HXDLIN( 289)												int x27 = (dx9 - rectLeft7);
HXDLIN( 289)												int y27 = (dy9 - rectTop7);
HXDLIN( 289)												int c25 = col7;
HXDLIN( 289)												bool _hx_tmp57;
HXDLIN( 289)												if ((((c25 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp57 = undoImage21->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp57 = false;
            												}
HXDLIN( 289)												if (_hx_tmp57) {
HXDLIN( 289)													int location14;
HXDLIN( 289)													if (undoImage21->useVirtualPos) {
HXDLIN( 289)														location14 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x27) - undoImage21->virtualX));
            													}
            													else {
HXDLIN( 289)														location14 = ::Std_obj::_hx_int(( (Float)(((y27 * undoImage21->width) + x27)) ));
            													}
HXDLIN( 289)													int this240 = ::iterMagic::Iimg_obj::get(undoImage21->image,location14);
HXDLIN( 289)													int this241;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this241 = ((((((this240 >> 24) & 255) << 24) | ((this240 & 255) << 16)) | (((this240 >> 8) & 255) << 8)) | ((this240 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this241 = this240;
            													}
HXDLIN( 289)													Float a118;
HXDLIN( 289)													int this242 = ((this241 >> 24) & 255);
HXDLIN( 289)													if ((this242 == 0)) {
HXDLIN( 289)														a118 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a118 = (( (Float)(this242) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r115;
HXDLIN( 289)													int this243 = ((this241 >> 16) & 255);
HXDLIN( 289)													if ((this243 == 0)) {
HXDLIN( 289)														r115 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r115 = (( (Float)(this243) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g115;
HXDLIN( 289)													int this244 = ((this241 >> 8) & 255);
HXDLIN( 289)													if ((this244 == 0)) {
HXDLIN( 289)														g115 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g115 = (( (Float)(this244) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b119;
HXDLIN( 289)													int this245 = (this241 & 255);
HXDLIN( 289)													if ((this245 == 0)) {
HXDLIN( 289)														b119 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b119 = (( (Float)(this245) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a216;
HXDLIN( 289)													int this246 = ((col7 >> 24) & 255);
HXDLIN( 289)													if ((this246 == 0)) {
HXDLIN( 289)														a216 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a216 = (( (Float)(this246) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r215;
HXDLIN( 289)													int this247 = ((col7 >> 16) & 255);
HXDLIN( 289)													if ((this247 == 0)) {
HXDLIN( 289)														r215 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r215 = (( (Float)(this247) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g215;
HXDLIN( 289)													int this248 = ((col7 >> 8) & 255);
HXDLIN( 289)													if ((this248 == 0)) {
HXDLIN( 289)														g215 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g215 = (( (Float)(this248) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b218;
HXDLIN( 289)													int this249 = (col7 & 255);
HXDLIN( 289)													if ((this249 == 0)) {
HXDLIN( 289)														b218 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b218 = (( (Float)(this249) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN( 289)													int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 289)													int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 289)													int b54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a315) + (b218 * a216))));
HXDLIN( 289)													int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 289)													int blended14 = ((((a50 << 24) | (r37 << 16)) | (g37 << 8)) | b54);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp58;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp58 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp58 = blended14;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage21->image,location14,_hx_tmp58);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this250 = undoImage21->image;
HXDLIN( 289)													int index32;
HXDLIN( 289)													if (undoImage21->useVirtualPos) {
HXDLIN( 289)														index32 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x27) - undoImage21->virtualX));
            													}
            													else {
HXDLIN( 289)														index32 = ::Std_obj::_hx_int(( (Float)(((y27 * undoImage21->width) + x27)) ));
            													}
HXDLIN( 289)													int _hx_tmp59;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp59 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp59 = c25;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this250,index32,_hx_tmp59);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear7) {
HXDLIN( 289)													::Dynamic this251 = undoImage21->image;
HXDLIN( 289)													int x28 = (dx9 - rectLeft7);
HXDLIN( 289)													int y28 = (dy9 - rectTop7);
HXDLIN( 289)													int index33;
HXDLIN( 289)													if (undoImage21->useVirtualPos) {
HXDLIN( 289)														index33 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x28) - undoImage21->virtualX));
            													}
            													else {
HXDLIN( 289)														index33 = ::Std_obj::_hx_int(( (Float)(((y28 * undoImage21->width) + x28)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this251,index33,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min14 = xIter37->start;
HXDLIN( 289)						int _g_max14 = xIter37->max;
HXDLIN( 289)						while((_g_min14 < _g_max14)){
HXDLIN( 289)							_g_min14 = (_g_min14 + 1);
HXDLIN( 289)							int px5 = (_g_min14 - 1);
HXDLIN( 289)							Float pcx5 = (( (Float)(px5) ) - x22);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min15 = yIter37->start;
HXDLIN( 289)								int _g_max15 = yIter37->max;
HXDLIN( 289)								while((_g_min15 < _g_max15)){
HXDLIN( 289)									_g_min15 = (_g_min15 + 1);
HXDLIN( 289)									int py5 = (_g_min15 - 1);
HXDLIN( 289)									Float pcy5 = (( (Float)(py5) ) - cy6);
HXDLIN( 289)									Float dot315 = ((pcx5 * bcx5) + (pcy5 * bcy5));
HXDLIN( 289)									Float dot325 = ((pcx5 * acx5) + (pcy5 * acy5));
HXDLIN( 289)									Float ratioA5 = (((dot225 * dot315) - (dot125 * dot325)) * denom15);
HXDLIN( 289)									Float ratioB5 = (((dot115 * dot325) - (dot125 * dot315)) * denom15);
HXDLIN( 289)									Float ratioC5 = ((((Float)1.0) - ratioB5) - ratioA5);
HXDLIN( 289)									bool _hx_tmp60;
HXDLIN( 289)									bool _hx_tmp61;
HXDLIN( 289)									if ((ratioA5 >= 0)) {
HXDLIN( 289)										_hx_tmp61 = (ratioB5 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp61 = false;
            									}
HXDLIN( 289)									if (_hx_tmp61) {
HXDLIN( 289)										_hx_tmp60 = (ratioC5 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp60 = false;
            									}
HXDLIN( 289)									if (_hx_tmp60) {
HXDLIN( 289)										int i70 = ::Std_obj::_hx_int((((( (Float)(aA5) ) * ratioA5) + (( (Float)(aB5) ) * ratioB5)) + (( (Float)(aC5) ) * ratioC5)));
HXDLIN( 289)										if ((i70 > 255)) {
HXLINE(  24)											i70 = 255;
            										}
HXLINE( 289)										if ((i70 < 0)) {
HXLINE(  25)											i70 = 0;
            										}
HXLINE( 289)										int a51 = i70;
HXDLIN( 289)										int i71 = ::Std_obj::_hx_int((((( (Float)(rA5) ) * ratioA5) + (( (Float)(rB5) ) * ratioB5)) + (( (Float)(rC5) ) * ratioC5)));
HXDLIN( 289)										if ((i71 > 255)) {
HXLINE(  24)											i71 = 255;
            										}
HXLINE( 289)										if ((i71 < 0)) {
HXLINE(  25)											i71 = 0;
            										}
HXLINE( 289)										int r38 = i71;
HXDLIN( 289)										int i72 = ::Std_obj::_hx_int((((( (Float)(gA5) ) * ratioA5) + (( (Float)(gB5) ) * ratioB5)) + (( (Float)(gC5) ) * ratioC5)));
HXDLIN( 289)										if ((i72 > 255)) {
HXLINE(  24)											i72 = 255;
            										}
HXLINE( 289)										if ((i72 < 0)) {
HXLINE(  25)											i72 = 0;
            										}
HXLINE( 289)										int g38 = i72;
HXDLIN( 289)										int i73 = ::Std_obj::_hx_int((((( (Float)(bA5) ) * ratioA5) + (( (Float)(bB5) ) * ratioB5)) + (( (Float)(bC5) ) * ratioC5)));
HXDLIN( 289)										if ((i73 > 255)) {
HXLINE(  24)											i73 = 255;
            										}
HXLINE( 289)										if ((i73 < 0)) {
HXLINE(  25)											i73 = 0;
            										}
HXLINE( 289)										int b55 = i73;
HXDLIN( 289)										{
HXDLIN( 289)											int location15;
HXDLIN( 289)											if (this198->useVirtualPos) {
HXDLIN( 289)												location15 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - this198->virtualY) * ( (Float)(this198->width) )) + px5) - this198->virtualX));
            											}
            											else {
HXDLIN( 289)												location15 = ::Std_obj::_hx_int(( (Float)(((py5 * this198->width) + px5)) ));
            											}
HXDLIN( 289)											bool _hx_tmp62;
HXDLIN( 289)											if (this198->transparent) {
HXDLIN( 289)												_hx_tmp62 = (a51 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp62 = false;
            											}
HXDLIN( 289)											if (_hx_tmp62) {
HXDLIN( 289)												int this252 = ::iterMagic::Iimg_obj::get(this198->image,location15);
HXDLIN( 289)												int old5;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old5 = ((((((this252 >> 24) & 255) << 24) | ((this252 & 255) << 16)) | (((this252 >> 8) & 255) << 8)) | ((this252 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old5 = this252;
            												}
HXDLIN( 289)												int rhs5 = ((((a51 << 24) | (r38 << 16)) | (g38 << 8)) | b55);
HXDLIN( 289)												Float a119;
HXDLIN( 289)												int this253 = ((old5 >> 24) & 255);
HXDLIN( 289)												if ((this253 == 0)) {
HXDLIN( 289)													a119 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a119 = (( (Float)(this253) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r116;
HXDLIN( 289)												int this254 = ((old5 >> 16) & 255);
HXDLIN( 289)												if ((this254 == 0)) {
HXDLIN( 289)													r116 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r116 = (( (Float)(this254) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g116;
HXDLIN( 289)												int this255 = ((old5 >> 8) & 255);
HXDLIN( 289)												if ((this255 == 0)) {
HXDLIN( 289)													g116 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g116 = (( (Float)(this255) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b120;
HXDLIN( 289)												int this256 = (old5 & 255);
HXDLIN( 289)												if ((this256 == 0)) {
HXDLIN( 289)													b120 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b120 = (( (Float)(this256) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a217;
HXDLIN( 289)												int this257 = ((rhs5 >> 24) & 255);
HXDLIN( 289)												if ((this257 == 0)) {
HXDLIN( 289)													a217 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a217 = (( (Float)(this257) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r216;
HXDLIN( 289)												int this258 = ((rhs5 >> 16) & 255);
HXDLIN( 289)												if ((this258 == 0)) {
HXDLIN( 289)													r216 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r216 = (( (Float)(this258) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g216;
HXDLIN( 289)												int this259 = ((rhs5 >> 8) & 255);
HXDLIN( 289)												if ((this259 == 0)) {
HXDLIN( 289)													g216 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g216 = (( (Float)(this259) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b219;
HXDLIN( 289)												int this260 = (rhs5 & 255);
HXDLIN( 289)												if ((this260 == 0)) {
HXDLIN( 289)													b219 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b219 = (( (Float)(this260) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a316 = (a119 * (( (Float)(1) ) - a217));
HXDLIN( 289)												int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 289)												int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 289)												int b56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a316) + (b219 * a217))));
HXDLIN( 289)												int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 289)												int blended15 = ((((a52 << 24) | (r39 << 16)) | (g39 << 8)) | b56);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp63;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp63 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp63 = blended15;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this198->image,location15,_hx_tmp63);
            												}
            											}
            											else {
HXDLIN( 289)												int value5;
HXDLIN( 289)												if (this198->isLittle) {
HXDLIN( 289)													value5 = ((((a51 << 24) | (b55 << 16)) | (g38 << 8)) | r38);
            												}
            												else {
HXDLIN( 289)													value5 = ((((a51 << 24) | (r38 << 16)) | (g38 << 8)) | b55);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this198->image,location15,value5);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit7 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v25 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx4,y22,bx4,cy6,x22,cy6,true);
HXDLIN( 289)						if (hasUndo7) {
HXDLIN( 289)							v25->undoImage = undoImage21;
HXDLIN( 289)							v25->undoX = xIter37->start;
HXDLIN( 289)							v25->undoY = yIter37->start;
            						}
            					}
            				}
HXDLIN( 289)				if ((hasHit6 == true)) {
HXDLIN( 289)					 ::pi_xy::algo::HitQuad v26 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x22,y22,bx4,y22,bx4,cy6,x22,cy6,true);
            				}
            			}
            		}
HXDLIN( 289)		Float inlobj_ax2 = x22;
HXDLIN( 289)		Float inlobj_ay2 = y22;
HXDLIN( 289)		Float inlobj_bx2 = bx4;
HXDLIN( 289)		Float inlobj_y2 = y22;
HXDLIN( 289)		Float inlobj_cx2 = bx4;
HXDLIN( 289)		Float inlobj_cy2 = cy6;
HXDLIN( 289)		Float inlobj_x2 = x22;
HXDLIN( 289)		Float inlobj_dy2 = cy6;
HXDLIN( 289)		 ::pi_xy::ImageStruct this261 = this1;
HXDLIN( 289)		Float y29 = (y + dy1);
HXDLIN( 289)		Float bx5 = (farX + rightRadius);
HXDLIN( 289)		Float cy7 = (y29 + ( (Float)(tall1) ));
HXDLIN( 289)		{
HXDLIN( 289)			bool hasHit8 = true;
HXDLIN( 289)			{
HXDLIN( 289)				{
HXDLIN( 289)					bool hasUndo8 = false;
HXDLIN( 289)					int aA6 = ((colorC >> 24) & 255);
HXDLIN( 289)					int rA6 = ((colorC >> 16) & 255);
HXDLIN( 289)					int gA6 = ((colorC >> 8) & 255);
HXDLIN( 289)					int bA6 = (colorC & 255);
HXDLIN( 289)					int aB6 = ((colorC >> 24) & 255);
HXDLIN( 289)					int rB6 = ((colorC >> 16) & 255);
HXDLIN( 289)					int gB6 = ((colorC >> 8) & 255);
HXDLIN( 289)					int bB6 = (colorC & 255);
HXDLIN( 289)					int aC6 = ((colorB >> 24) & 255);
HXDLIN( 289)					int rC6 = ((colorB >> 16) & 255);
HXDLIN( 289)					int gC6 = ((colorB >> 8) & 255);
HXDLIN( 289)					int bC6 = (colorB & 255);
HXDLIN( 289)					Float bcx6 = (bx5 - farX);
HXDLIN( 289)					Float bcy6 = (y29 - cy7);
HXDLIN( 289)					Float acx6 = (farX - farX);
HXDLIN( 289)					Float acy6 = (y29 - cy7);
HXDLIN( 289)					Float dot116 = ((bcx6 * bcx6) + (bcy6 * bcy6));
HXDLIN( 289)					Float dot126 = ((bcx6 * acx6) + (bcy6 * acy6));
HXDLIN( 289)					Float dot226 = ((acx6 * acx6) + (acy6 * acy6));
HXDLIN( 289)					Float denom16 = (( (Float)(1) ) / ((dot116 * dot226) - (dot126 * dot126)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter38;
HXDLIN( 289)					if ((farX > bx5)) {
HXDLIN( 289)						if ((farX > farX)) {
HXDLIN( 289)							int min32;
HXDLIN( 289)							if ((bx5 > farX)) {
HXDLIN( 289)								min32 = ::Math_obj::floor(farX);
            							}
            							else {
HXDLIN( 289)								min32 = ::Math_obj::floor(bx5);
            							}
HXDLIN( 289)							int ii_min64 = min32;
HXDLIN( 289)							int ii_max64 = ::Math_obj::ceil(farX);
HXDLIN( 289)							xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            						}
            						else {
HXDLIN( 289)							int ii_min65 = ::Math_obj::floor(bx5);
HXDLIN( 289)							int ii_max65 = ::Math_obj::ceil(farX);
HXDLIN( 289)							xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx5 > farX)) {
HXDLIN( 289)							int min33;
HXDLIN( 289)							if ((farX > farX)) {
HXDLIN( 289)								min33 = ::Math_obj::floor(farX);
            							}
            							else {
HXDLIN( 289)								min33 = ::Math_obj::ceil(farX);
            							}
HXDLIN( 289)							int ii_min66 = min33;
HXDLIN( 289)							int ii_max66 = ::Math_obj::ceil(bx5);
HXDLIN( 289)							xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            						}
            						else {
HXDLIN( 289)							int ii_min67 = ::Math_obj::floor(farX);
HXDLIN( 289)							int ii_max67 = ::Math_obj::ceil(farX);
HXDLIN( 289)							xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter38;
HXDLIN( 289)					if ((y29 > y29)) {
HXDLIN( 289)						if ((y29 > cy7)) {
HXDLIN( 289)							int min34;
HXDLIN( 289)							if ((y29 > cy7)) {
HXDLIN( 289)								min34 = ::Math_obj::floor(cy7);
            							}
            							else {
HXDLIN( 289)								min34 = ::Math_obj::floor(y29);
            							}
HXDLIN( 289)							int ii_min68 = min34;
HXDLIN( 289)							int ii_max68 = ::Math_obj::ceil(y29);
HXDLIN( 289)							yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            						}
            						else {
HXDLIN( 289)							int ii_min69 = ::Math_obj::floor(y29);
HXDLIN( 289)							int ii_max69 = ::Math_obj::ceil(cy7);
HXDLIN( 289)							yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            						}
            					}
            					else {
HXDLIN( 289)						if ((y29 > cy7)) {
HXDLIN( 289)							int min35;
HXDLIN( 289)							if ((y29 > cy7)) {
HXDLIN( 289)								min35 = ::Math_obj::floor(cy7);
            							}
            							else {
HXDLIN( 289)								min35 = ::Math_obj::ceil(y29);
            							}
HXDLIN( 289)							int ii_min70 = min35;
HXDLIN( 289)							int ii_max70 = ::Math_obj::ceil(y29);
HXDLIN( 289)							yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            						}
            						else {
HXDLIN( 289)							int ii_min71 = ::Math_obj::floor(y29);
HXDLIN( 289)							int ii_max71 = ::Math_obj::ceil(cy7);
HXDLIN( 289)							yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage24 = null();
HXDLIN( 289)					if (hasUndo8) {
HXDLIN( 289)						int width8 = ((xIter38->max - xIter38->start) + 1);
HXDLIN( 289)						int height8 = ((yIter38->max - yIter38->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType8 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this262 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType8 )) {
HXLINE(  54)							imageType8 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage25;
HXDLIN( 289)						switch((int)(( (int)(imageType8) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt8 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b57 = byt8;
HXDLIN( 289)								{
HXDLIN( 289)									b57->width = width8;
HXDLIN( 289)									b57->height = height8;
HXDLIN( 289)									b57->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 289)									b57->data = ::haxe::io::Bytes_obj::alloc((b57->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len16 = b57->length;
HXDLIN( 289)										int w8 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g164 = 0;
HXDLIN( 289)											int _g165 = b57->height;
HXDLIN( 289)											while((_g164 < _g165)){
HXDLIN( 289)												_g164 = (_g164 + 1);
HXDLIN( 289)												int y30 = (_g164 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g166 = 0;
HXDLIN( 289)													int _g167 = b57->width;
HXDLIN( 289)													while((_g166 < _g167)){
HXDLIN( 289)														_g166 = (_g166 + 1);
HXDLIN( 289)														int x29 = (_g166 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w8 = (w8 + 1);
HXDLIN( 289)															b57->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w8 = (w8 + 1);
HXDLIN( 289)															b57->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w8 = (w8 + 1);
HXDLIN( 289)															b57->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w8 = (w8 + 1);
HXDLIN( 289)															b57->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage25 = b57;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI8 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a53 = arrI8;
HXDLIN( 289)								{
HXDLIN( 289)									a53->width = width8;
HXDLIN( 289)									a53->height = height8;
HXDLIN( 289)									a53->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a53->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g168 = 0;
HXDLIN( 289)										int _g169 = a53->length;
HXDLIN( 289)										while((_g168 < _g169)){
HXDLIN( 289)											_g168 = (_g168 + 1);
HXDLIN( 289)											int i74 = (_g168 - 1);
HXDLIN( 289)											a53->data[i74] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage25 = a53;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a8 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b58 = u32a8;
HXDLIN( 289)								{
HXDLIN( 289)									b58->width = width8;
HXDLIN( 289)									b58->height = height8;
HXDLIN( 289)									b58->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 289)									int size8 = (b58->length * 4);
HXDLIN( 289)									b58->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size8),0,size8);
HXDLIN( 289)									{
HXDLIN( 289)										int _g170 = 0;
HXDLIN( 289)										int _g171 = b58->length;
HXDLIN( 289)										while((_g170 < _g171)){
HXDLIN( 289)											_g170 = (_g170 + 1);
HXDLIN( 289)											int i75 = (_g170 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this263 = b58->data;
HXDLIN( 289)												bool undoImage26;
HXDLIN( 289)												if ((i75 >= 0)) {
HXDLIN( 289)													undoImage26 = (i75 < (this263->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage26 = false;
            												}
HXDLIN( 289)												if (undoImage26) {
HXDLIN( 289)													 ::haxe::io::Bytes _this8 = this263->bytes;
HXDLIN( 289)													int pos8 = ((i75 << 2) + this263->byteOffset);
HXDLIN( 289)													_this8->b[pos8] = ( (unsigned char)(0) );
HXDLIN( 289)													_this8->b[(pos8 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this8->b[(pos8 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this8->b[(pos8 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage25 = b58;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec8 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v27 = vec8;
HXDLIN( 289)								{
HXDLIN( 289)									v27->width = width8;
HXDLIN( 289)									v27->height = height8;
HXDLIN( 289)									v27->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 289)									v27->data = ::Array_obj< int >::__new(v27->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g172 = 0;
HXDLIN( 289)										int _g173 = v27->length;
HXDLIN( 289)										while((_g172 < _g173)){
HXDLIN( 289)											_g172 = (_g172 + 1);
HXDLIN( 289)											int i76 = (_g172 - 1);
HXDLIN( 289)											v27->data->__unsafe_set(i76,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage25 = v27;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt8 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b59 = sInt8;
HXDLIN( 289)								{
HXDLIN( 289)									b59->width = width8;
HXDLIN( 289)									b59->height = height8;
HXDLIN( 289)									b59->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 289)									b59->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len17 = b59->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d8 = b59->data;
HXDLIN( 289)										if (::hx::IsNull( d8->head )) {
HXDLIN( 289)											int _g174 = 0;
HXDLIN( 289)											int _g175 = len17;
HXDLIN( 289)											while((_g174 < _g175)){
HXDLIN( 289)												_g174 = (_g174 + 1);
HXDLIN( 289)												int i77 = (_g174 - 1);
HXDLIN( 289)												d8->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d8->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g176 = 0;
HXDLIN( 289)											int _g177 = len17;
HXDLIN( 289)											while((_g176 < _g177)){
HXDLIN( 289)												_g176 = (_g176 + 1);
HXDLIN( 289)												int i78 = (_g176 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l8 = b59->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev8 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g178 = 0;
HXDLIN( 289)														int _g179 = i78;
HXDLIN( 289)														while((_g178 < _g179)){
HXDLIN( 289)															_g178 = (_g178 + 1);
HXDLIN( 289)															int i79 = (_g178 - 1);
HXLINE( 345)															prev8 = l8;
HXLINE( 346)															l8 = l8->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev8 )) {
HXDLIN( 289)														b59->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 289)														l8 = null();
            													}
            													else {
HXDLIN( 289)														prev8->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 289)														l8 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage25 = b59;
            							}
            							break;
            						}
HXDLIN( 289)						this262->image = undoImage25;
HXDLIN( 289)						this262->width = width8;
HXDLIN( 289)						this262->height = height8;
HXDLIN( 289)						this262->imageType = ( (int)(imageType8) );
HXDLIN( 289)						undoImage24 = this262;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft8 = xIter38->start;
HXDLIN( 289)							int rectTop8 = yIter38->start;
HXDLIN( 289)							int rectRight8 = xIter38->max;
HXDLIN( 289)							bool forceClear8 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g180 = rectTop8;
HXDLIN( 289)								int _g181 = yIter38->max;
HXDLIN( 289)								while((_g180 < _g181)){
HXDLIN( 289)									_g180 = (_g180 + 1);
HXDLIN( 289)									int dy10 = (_g180 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g182 = rectLeft8;
HXDLIN( 289)										int _g183 = rectRight8;
HXDLIN( 289)										while((_g182 < _g183)){
HXDLIN( 289)											_g182 = (_g182 + 1);
HXDLIN( 289)											int dx10 = (_g182 - 1);
HXDLIN( 289)											::Dynamic this264 = this261->image;
HXDLIN( 289)											int index34;
HXDLIN( 289)											if (this261->useVirtualPos) {
HXDLIN( 289)												index34 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - this261->virtualY) * ( (Float)(this261->width) )) + dx10) - this261->virtualX));
            											}
            											else {
HXDLIN( 289)												index34 = ::Std_obj::_hx_int(( (Float)(((dy10 * this261->width) + dx10)) ));
            											}
HXDLIN( 289)											int c26 = ::iterMagic::Iimg_obj::get(this264,index34);
HXDLIN( 289)											int col8;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col8 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col8 = c26;
            											}
HXDLIN( 289)											bool _hx_tmp64;
HXDLIN( 289)											if (this261->useMask) {
HXDLIN( 289)												_hx_tmp64 = ::hx::IsNotNull( this261->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp64 = false;
            											}
HXDLIN( 289)											if (_hx_tmp64) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this265 = this261->mask;
HXDLIN( 289)												::Dynamic this266 = this265->image;
HXDLIN( 289)												int index35;
HXDLIN( 289)												if (this265->useVirtualPos) {
HXDLIN( 289)													index35 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - this265->virtualY) * ( (Float)(this265->width) )) + dx10) - this265->virtualX));
            												}
            												else {
HXDLIN( 289)													index35 = ::Std_obj::_hx_int(( (Float)(((dy10 * this265->width) + dx10)) ));
            												}
HXDLIN( 289)												int c27 = ::iterMagic::Iimg_obj::get(this266,index35);
HXDLIN( 289)												int v28;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v28 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v28 = c27;
            												}
HXDLIN( 289)												int maskPixel8 = v28;
HXDLIN( 289)												int this267 = col8;
HXDLIN( 289)												if ((maskPixel8 == 0)) {
HXDLIN( 289)													col8 = this267;
            												}
            												else {
HXDLIN( 289)													Float m08;
HXDLIN( 289)													int this268 = ((maskPixel8 >> 24) & 255);
HXDLIN( 289)													if ((this268 == 0)) {
HXDLIN( 289)														m08 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m08 = (( (Float)(this268) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m18;
HXDLIN( 289)													int this269 = ((maskPixel8 >> 16) & 255);
HXDLIN( 289)													if ((this269 == 0)) {
HXDLIN( 289)														m18 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m18 = (( (Float)(this269) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m28;
HXDLIN( 289)													int this270 = ((maskPixel8 >> 8) & 255);
HXDLIN( 289)													if ((this270 == 0)) {
HXDLIN( 289)														m28 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m28 = (( (Float)(this270) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m38;
HXDLIN( 289)													int this271 = (maskPixel8 & 255);
HXDLIN( 289)													if ((this271 == 0)) {
HXDLIN( 289)														m38 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m38 = (( (Float)(this271) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch08 = ::Std_obj::_hx_int(((((Float)1.) - m08) * ( (Float)(((this267 >> 24) & 255)) )));
HXDLIN( 289)													int ch18 = ::Std_obj::_hx_int(((((Float)1.) - m18) * ( (Float)(((this267 >> 16) & 255)) )));
HXDLIN( 289)													int ch28 = ::Std_obj::_hx_int(((((Float)1.) - m28) * ( (Float)(((this267 >> 8) & 255)) )));
HXDLIN( 289)													int ch38 = ::Std_obj::_hx_int(((((Float)1.) - m38) * ( (Float)((this267 & 255)) )));
HXDLIN( 289)													col8 = ((((::Math_obj::round((( (Float)(ch08) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch18) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch28) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch38) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col8 != 0)) {
HXDLIN( 289)												int x30 = (dx10 - rectLeft8);
HXDLIN( 289)												int y31 = (dy10 - rectTop8);
HXDLIN( 289)												int c28 = col8;
HXDLIN( 289)												bool _hx_tmp65;
HXDLIN( 289)												if ((((c28 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp65 = undoImage24->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp65 = false;
            												}
HXDLIN( 289)												if (_hx_tmp65) {
HXDLIN( 289)													int location16;
HXDLIN( 289)													if (undoImage24->useVirtualPos) {
HXDLIN( 289)														location16 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x30) - undoImage24->virtualX));
            													}
            													else {
HXDLIN( 289)														location16 = ::Std_obj::_hx_int(( (Float)(((y31 * undoImage24->width) + x30)) ));
            													}
HXDLIN( 289)													int this272 = ::iterMagic::Iimg_obj::get(undoImage24->image,location16);
HXDLIN( 289)													int this273;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this273 = ((((((this272 >> 24) & 255) << 24) | ((this272 & 255) << 16)) | (((this272 >> 8) & 255) << 8)) | ((this272 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this273 = this272;
            													}
HXDLIN( 289)													Float a120;
HXDLIN( 289)													int this274 = ((this273 >> 24) & 255);
HXDLIN( 289)													if ((this274 == 0)) {
HXDLIN( 289)														a120 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a120 = (( (Float)(this274) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r117;
HXDLIN( 289)													int this275 = ((this273 >> 16) & 255);
HXDLIN( 289)													if ((this275 == 0)) {
HXDLIN( 289)														r117 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r117 = (( (Float)(this275) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g117;
HXDLIN( 289)													int this276 = ((this273 >> 8) & 255);
HXDLIN( 289)													if ((this276 == 0)) {
HXDLIN( 289)														g117 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g117 = (( (Float)(this276) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b121;
HXDLIN( 289)													int this277 = (this273 & 255);
HXDLIN( 289)													if ((this277 == 0)) {
HXDLIN( 289)														b121 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b121 = (( (Float)(this277) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a218;
HXDLIN( 289)													int this278 = ((col8 >> 24) & 255);
HXDLIN( 289)													if ((this278 == 0)) {
HXDLIN( 289)														a218 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a218 = (( (Float)(this278) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r217;
HXDLIN( 289)													int this279 = ((col8 >> 16) & 255);
HXDLIN( 289)													if ((this279 == 0)) {
HXDLIN( 289)														r217 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r217 = (( (Float)(this279) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g217;
HXDLIN( 289)													int this280 = ((col8 >> 8) & 255);
HXDLIN( 289)													if ((this280 == 0)) {
HXDLIN( 289)														g217 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g217 = (( (Float)(this280) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b220;
HXDLIN( 289)													int this281 = (col8 & 255);
HXDLIN( 289)													if ((this281 == 0)) {
HXDLIN( 289)														b220 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b220 = (( (Float)(this281) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a317 = (a120 * (( (Float)(1) ) - a218));
HXDLIN( 289)													int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 289)													int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 289)													int b60 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a317) + (b220 * a218))));
HXDLIN( 289)													int a54 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 289)													int blended16 = ((((a54 << 24) | (r40 << 16)) | (g40 << 8)) | b60);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp66;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp66 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp66 = blended16;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage24->image,location16,_hx_tmp66);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this282 = undoImage24->image;
HXDLIN( 289)													int index36;
HXDLIN( 289)													if (undoImage24->useVirtualPos) {
HXDLIN( 289)														index36 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x30) - undoImage24->virtualX));
            													}
            													else {
HXDLIN( 289)														index36 = ::Std_obj::_hx_int(( (Float)(((y31 * undoImage24->width) + x30)) ));
            													}
HXDLIN( 289)													int _hx_tmp67;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp67 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp67 = c28;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this282,index36,_hx_tmp67);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear8) {
HXDLIN( 289)													::Dynamic this283 = undoImage24->image;
HXDLIN( 289)													int x31 = (dx10 - rectLeft8);
HXDLIN( 289)													int y32 = (dy10 - rectTop8);
HXDLIN( 289)													int index37;
HXDLIN( 289)													if (undoImage24->useVirtualPos) {
HXDLIN( 289)														index37 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x31) - undoImage24->virtualX));
            													}
            													else {
HXDLIN( 289)														index37 = ::Std_obj::_hx_int(( (Float)(((y32 * undoImage24->width) + x31)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this283,index37,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min16 = xIter38->start;
HXDLIN( 289)						int _g_max16 = xIter38->max;
HXDLIN( 289)						while((_g_min16 < _g_max16)){
HXDLIN( 289)							_g_min16 = (_g_min16 + 1);
HXDLIN( 289)							int px6 = (_g_min16 - 1);
HXDLIN( 289)							Float pcx6 = (( (Float)(px6) ) - farX);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min17 = yIter38->start;
HXDLIN( 289)								int _g_max17 = yIter38->max;
HXDLIN( 289)								while((_g_min17 < _g_max17)){
HXDLIN( 289)									_g_min17 = (_g_min17 + 1);
HXDLIN( 289)									int py6 = (_g_min17 - 1);
HXDLIN( 289)									Float pcy6 = (( (Float)(py6) ) - cy7);
HXDLIN( 289)									Float dot316 = ((pcx6 * bcx6) + (pcy6 * bcy6));
HXDLIN( 289)									Float dot326 = ((pcx6 * acx6) + (pcy6 * acy6));
HXDLIN( 289)									Float ratioA6 = (((dot226 * dot316) - (dot126 * dot326)) * denom16);
HXDLIN( 289)									Float ratioB6 = (((dot116 * dot326) - (dot126 * dot316)) * denom16);
HXDLIN( 289)									Float ratioC6 = ((((Float)1.0) - ratioB6) - ratioA6);
HXDLIN( 289)									bool _hx_tmp68;
HXDLIN( 289)									bool _hx_tmp69;
HXDLIN( 289)									if ((ratioA6 >= 0)) {
HXDLIN( 289)										_hx_tmp69 = (ratioB6 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp69 = false;
            									}
HXDLIN( 289)									if (_hx_tmp69) {
HXDLIN( 289)										_hx_tmp68 = (ratioC6 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp68 = false;
            									}
HXDLIN( 289)									if (_hx_tmp68) {
HXDLIN( 289)										int i80 = ::Std_obj::_hx_int((((( (Float)(aA6) ) * ratioA6) + (( (Float)(aB6) ) * ratioB6)) + (( (Float)(aC6) ) * ratioC6)));
HXDLIN( 289)										if ((i80 > 255)) {
HXLINE(  24)											i80 = 255;
            										}
HXLINE( 289)										if ((i80 < 0)) {
HXLINE(  25)											i80 = 0;
            										}
HXLINE( 289)										int a55 = i80;
HXDLIN( 289)										int i81 = ::Std_obj::_hx_int((((( (Float)(rA6) ) * ratioA6) + (( (Float)(rB6) ) * ratioB6)) + (( (Float)(rC6) ) * ratioC6)));
HXDLIN( 289)										if ((i81 > 255)) {
HXLINE(  24)											i81 = 255;
            										}
HXLINE( 289)										if ((i81 < 0)) {
HXLINE(  25)											i81 = 0;
            										}
HXLINE( 289)										int r41 = i81;
HXDLIN( 289)										int i82 = ::Std_obj::_hx_int((((( (Float)(gA6) ) * ratioA6) + (( (Float)(gB6) ) * ratioB6)) + (( (Float)(gC6) ) * ratioC6)));
HXDLIN( 289)										if ((i82 > 255)) {
HXLINE(  24)											i82 = 255;
            										}
HXLINE( 289)										if ((i82 < 0)) {
HXLINE(  25)											i82 = 0;
            										}
HXLINE( 289)										int g41 = i82;
HXDLIN( 289)										int i83 = ::Std_obj::_hx_int((((( (Float)(bA6) ) * ratioA6) + (( (Float)(bB6) ) * ratioB6)) + (( (Float)(bC6) ) * ratioC6)));
HXDLIN( 289)										if ((i83 > 255)) {
HXLINE(  24)											i83 = 255;
            										}
HXLINE( 289)										if ((i83 < 0)) {
HXLINE(  25)											i83 = 0;
            										}
HXLINE( 289)										int b61 = i83;
HXDLIN( 289)										{
HXDLIN( 289)											int location17;
HXDLIN( 289)											if (this261->useVirtualPos) {
HXDLIN( 289)												location17 = ::Std_obj::_hx_int(((((( (Float)(py6) ) - this261->virtualY) * ( (Float)(this261->width) )) + px6) - this261->virtualX));
            											}
            											else {
HXDLIN( 289)												location17 = ::Std_obj::_hx_int(( (Float)(((py6 * this261->width) + px6)) ));
            											}
HXDLIN( 289)											bool _hx_tmp70;
HXDLIN( 289)											if (this261->transparent) {
HXDLIN( 289)												_hx_tmp70 = (a55 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp70 = false;
            											}
HXDLIN( 289)											if (_hx_tmp70) {
HXDLIN( 289)												int this284 = ::iterMagic::Iimg_obj::get(this261->image,location17);
HXDLIN( 289)												int old6;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old6 = ((((((this284 >> 24) & 255) << 24) | ((this284 & 255) << 16)) | (((this284 >> 8) & 255) << 8)) | ((this284 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old6 = this284;
            												}
HXDLIN( 289)												int rhs6 = ((((a55 << 24) | (r41 << 16)) | (g41 << 8)) | b61);
HXDLIN( 289)												Float a121;
HXDLIN( 289)												int this285 = ((old6 >> 24) & 255);
HXDLIN( 289)												if ((this285 == 0)) {
HXDLIN( 289)													a121 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a121 = (( (Float)(this285) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r118;
HXDLIN( 289)												int this286 = ((old6 >> 16) & 255);
HXDLIN( 289)												if ((this286 == 0)) {
HXDLIN( 289)													r118 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r118 = (( (Float)(this286) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g118;
HXDLIN( 289)												int this287 = ((old6 >> 8) & 255);
HXDLIN( 289)												if ((this287 == 0)) {
HXDLIN( 289)													g118 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g118 = (( (Float)(this287) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b122;
HXDLIN( 289)												int this288 = (old6 & 255);
HXDLIN( 289)												if ((this288 == 0)) {
HXDLIN( 289)													b122 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b122 = (( (Float)(this288) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a219;
HXDLIN( 289)												int this289 = ((rhs6 >> 24) & 255);
HXDLIN( 289)												if ((this289 == 0)) {
HXDLIN( 289)													a219 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a219 = (( (Float)(this289) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r218;
HXDLIN( 289)												int this290 = ((rhs6 >> 16) & 255);
HXDLIN( 289)												if ((this290 == 0)) {
HXDLIN( 289)													r218 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r218 = (( (Float)(this290) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g218;
HXDLIN( 289)												int this291 = ((rhs6 >> 8) & 255);
HXDLIN( 289)												if ((this291 == 0)) {
HXDLIN( 289)													g218 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g218 = (( (Float)(this291) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b221;
HXDLIN( 289)												int this292 = (rhs6 & 255);
HXDLIN( 289)												if ((this292 == 0)) {
HXDLIN( 289)													b221 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b221 = (( (Float)(this292) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a318 = (a121 * (( (Float)(1) ) - a219));
HXDLIN( 289)												int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 289)												int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 289)												int b62 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a318) + (b221 * a219))));
HXDLIN( 289)												int a56 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 289)												int blended17 = ((((a56 << 24) | (r42 << 16)) | (g42 << 8)) | b62);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp71;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp71 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp71 = blended17;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this261->image,location17,_hx_tmp71);
            												}
            											}
            											else {
HXDLIN( 289)												int value6;
HXDLIN( 289)												if (this261->isLittle) {
HXDLIN( 289)													value6 = ((((a55 << 24) | (b61 << 16)) | (g41 << 8)) | r41);
            												}
            												else {
HXDLIN( 289)													value6 = ((((a55 << 24) | (r41 << 16)) | (g41 << 8)) | b61);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this261->image,location17,value6);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit8 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v29 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX,y29,bx5,y29,farX,cy7,true);
HXDLIN( 289)						if (hasUndo8) {
HXDLIN( 289)							v29->undoImage = undoImage24;
HXDLIN( 289)							v29->undoX = xIter38->start;
HXDLIN( 289)							v29->undoY = yIter38->start;
            						}
            					}
            				}
HXDLIN( 289)				{
HXDLIN( 289)					bool hasHit9 = false;
HXDLIN( 289)					bool hasUndo9 = false;
HXDLIN( 289)					int aA7 = ((colorB >> 24) & 255);
HXDLIN( 289)					int rA7 = ((colorB >> 16) & 255);
HXDLIN( 289)					int gA7 = ((colorB >> 8) & 255);
HXDLIN( 289)					int bA7 = (colorB & 255);
HXDLIN( 289)					int aB7 = ((colorC >> 24) & 255);
HXDLIN( 289)					int rB7 = ((colorC >> 16) & 255);
HXDLIN( 289)					int gB7 = ((colorC >> 8) & 255);
HXDLIN( 289)					int bB7 = (colorC & 255);
HXDLIN( 289)					int aC7 = ((colorB >> 24) & 255);
HXDLIN( 289)					int rC7 = ((colorB >> 16) & 255);
HXDLIN( 289)					int gC7 = ((colorB >> 8) & 255);
HXDLIN( 289)					int bC7 = (colorB & 255);
HXDLIN( 289)					Float bcx7 = (bx5 - farX);
HXDLIN( 289)					Float bcy7 = (cy7 - cy7);
HXDLIN( 289)					Float acx7 = (bx5 - farX);
HXDLIN( 289)					Float acy7 = (y29 - cy7);
HXDLIN( 289)					Float dot117 = ((bcx7 * bcx7) + (bcy7 * bcy7));
HXDLIN( 289)					Float dot127 = ((bcx7 * acx7) + (bcy7 * acy7));
HXDLIN( 289)					Float dot227 = ((acx7 * acx7) + (acy7 * acy7));
HXDLIN( 289)					Float denom17 = (( (Float)(1) ) / ((dot117 * dot227) - (dot127 * dot127)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter39;
HXDLIN( 289)					if ((bx5 > bx5)) {
HXDLIN( 289)						if ((bx5 > farX)) {
HXDLIN( 289)							int min36;
HXDLIN( 289)							if ((bx5 > farX)) {
HXDLIN( 289)								min36 = ::Math_obj::floor(farX);
            							}
            							else {
HXDLIN( 289)								min36 = ::Math_obj::floor(bx5);
            							}
HXDLIN( 289)							int ii_min72 = min36;
HXDLIN( 289)							int ii_max72 = ::Math_obj::ceil(bx5);
HXDLIN( 289)							xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            						}
            						else {
HXDLIN( 289)							int ii_min73 = ::Math_obj::floor(bx5);
HXDLIN( 289)							int ii_max73 = ::Math_obj::ceil(farX);
HXDLIN( 289)							xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx5 > farX)) {
HXDLIN( 289)							int min37;
HXDLIN( 289)							if ((bx5 > farX)) {
HXDLIN( 289)								min37 = ::Math_obj::floor(farX);
            							}
            							else {
HXDLIN( 289)								min37 = ::Math_obj::ceil(bx5);
            							}
HXDLIN( 289)							int ii_min74 = min37;
HXDLIN( 289)							int ii_max74 = ::Math_obj::ceil(bx5);
HXDLIN( 289)							xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min74,ii_max74);
            						}
            						else {
HXDLIN( 289)							int ii_min75 = ::Math_obj::floor(bx5);
HXDLIN( 289)							int ii_max75 = ::Math_obj::ceil(farX);
HXDLIN( 289)							xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min75,ii_max75);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter39;
HXDLIN( 289)					if ((y29 > cy7)) {
HXDLIN( 289)						if ((y29 > cy7)) {
HXDLIN( 289)							int min38;
HXDLIN( 289)							if ((cy7 > cy7)) {
HXDLIN( 289)								min38 = ::Math_obj::floor(cy7);
            							}
            							else {
HXDLIN( 289)								min38 = ::Math_obj::floor(cy7);
            							}
HXDLIN( 289)							int ii_min76 = min38;
HXDLIN( 289)							int ii_max76 = ::Math_obj::ceil(y29);
HXDLIN( 289)							yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min76,ii_max76);
            						}
            						else {
HXDLIN( 289)							int ii_min77 = ::Math_obj::floor(cy7);
HXDLIN( 289)							int ii_max77 = ::Math_obj::ceil(cy7);
HXDLIN( 289)							yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min77,ii_max77);
            						}
            					}
            					else {
HXDLIN( 289)						if ((cy7 > cy7)) {
HXDLIN( 289)							int min39;
HXDLIN( 289)							if ((y29 > cy7)) {
HXDLIN( 289)								min39 = ::Math_obj::floor(cy7);
            							}
            							else {
HXDLIN( 289)								min39 = ::Math_obj::ceil(y29);
            							}
HXDLIN( 289)							int ii_min78 = min39;
HXDLIN( 289)							int ii_max78 = ::Math_obj::ceil(cy7);
HXDLIN( 289)							yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min78,ii_max78);
            						}
            						else {
HXDLIN( 289)							int ii_min79 = ::Math_obj::floor(y29);
HXDLIN( 289)							int ii_max79 = ::Math_obj::ceil(cy7);
HXDLIN( 289)							yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min79,ii_max79);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage27 = null();
HXDLIN( 289)					if (hasUndo9) {
HXDLIN( 289)						int width9 = ((xIter39->max - xIter39->start) + 1);
HXDLIN( 289)						int height9 = ((yIter39->max - yIter39->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType9 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this293 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType9 )) {
HXLINE(  54)							imageType9 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage28;
HXDLIN( 289)						switch((int)(( (int)(imageType9) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt9 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b63 = byt9;
HXDLIN( 289)								{
HXDLIN( 289)									b63->width = width9;
HXDLIN( 289)									b63->height = height9;
HXDLIN( 289)									b63->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 289)									b63->data = ::haxe::io::Bytes_obj::alloc((b63->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len18 = b63->length;
HXDLIN( 289)										int w9 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g184 = 0;
HXDLIN( 289)											int _g185 = b63->height;
HXDLIN( 289)											while((_g184 < _g185)){
HXDLIN( 289)												_g184 = (_g184 + 1);
HXDLIN( 289)												int y33 = (_g184 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g186 = 0;
HXDLIN( 289)													int _g187 = b63->width;
HXDLIN( 289)													while((_g186 < _g187)){
HXDLIN( 289)														_g186 = (_g186 + 1);
HXDLIN( 289)														int x32 = (_g186 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w9 = (w9 + 1);
HXDLIN( 289)															b63->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w9 = (w9 + 1);
HXDLIN( 289)															b63->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w9 = (w9 + 1);
HXDLIN( 289)															b63->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w9 = (w9 + 1);
HXDLIN( 289)															b63->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage28 = b63;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI9 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a57 = arrI9;
HXDLIN( 289)								{
HXDLIN( 289)									a57->width = width9;
HXDLIN( 289)									a57->height = height9;
HXDLIN( 289)									a57->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a57->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g188 = 0;
HXDLIN( 289)										int _g189 = a57->length;
HXDLIN( 289)										while((_g188 < _g189)){
HXDLIN( 289)											_g188 = (_g188 + 1);
HXDLIN( 289)											int i84 = (_g188 - 1);
HXDLIN( 289)											a57->data[i84] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage28 = a57;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a9 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b64 = u32a9;
HXDLIN( 289)								{
HXDLIN( 289)									b64->width = width9;
HXDLIN( 289)									b64->height = height9;
HXDLIN( 289)									b64->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 289)									int size9 = (b64->length * 4);
HXDLIN( 289)									b64->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size9),0,size9);
HXDLIN( 289)									{
HXDLIN( 289)										int _g190 = 0;
HXDLIN( 289)										int _g191 = b64->length;
HXDLIN( 289)										while((_g190 < _g191)){
HXDLIN( 289)											_g190 = (_g190 + 1);
HXDLIN( 289)											int i85 = (_g190 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this294 = b64->data;
HXDLIN( 289)												bool undoImage29;
HXDLIN( 289)												if ((i85 >= 0)) {
HXDLIN( 289)													undoImage29 = (i85 < (this294->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage29 = false;
            												}
HXDLIN( 289)												if (undoImage29) {
HXDLIN( 289)													 ::haxe::io::Bytes _this9 = this294->bytes;
HXDLIN( 289)													int pos9 = ((i85 << 2) + this294->byteOffset);
HXDLIN( 289)													_this9->b[pos9] = ( (unsigned char)(0) );
HXDLIN( 289)													_this9->b[(pos9 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this9->b[(pos9 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this9->b[(pos9 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage28 = b64;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec9 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v30 = vec9;
HXDLIN( 289)								{
HXDLIN( 289)									v30->width = width9;
HXDLIN( 289)									v30->height = height9;
HXDLIN( 289)									v30->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 289)									v30->data = ::Array_obj< int >::__new(v30->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g192 = 0;
HXDLIN( 289)										int _g193 = v30->length;
HXDLIN( 289)										while((_g192 < _g193)){
HXDLIN( 289)											_g192 = (_g192 + 1);
HXDLIN( 289)											int i86 = (_g192 - 1);
HXDLIN( 289)											v30->data->__unsafe_set(i86,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage28 = v30;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt9 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b65 = sInt9;
HXDLIN( 289)								{
HXDLIN( 289)									b65->width = width9;
HXDLIN( 289)									b65->height = height9;
HXDLIN( 289)									b65->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 289)									b65->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len19 = b65->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d9 = b65->data;
HXDLIN( 289)										if (::hx::IsNull( d9->head )) {
HXDLIN( 289)											int _g194 = 0;
HXDLIN( 289)											int _g195 = len19;
HXDLIN( 289)											while((_g194 < _g195)){
HXDLIN( 289)												_g194 = (_g194 + 1);
HXDLIN( 289)												int i87 = (_g194 - 1);
HXDLIN( 289)												d9->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d9->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g196 = 0;
HXDLIN( 289)											int _g197 = len19;
HXDLIN( 289)											while((_g196 < _g197)){
HXDLIN( 289)												_g196 = (_g196 + 1);
HXDLIN( 289)												int i88 = (_g196 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l9 = b65->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev9 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g198 = 0;
HXDLIN( 289)														int _g199 = i88;
HXDLIN( 289)														while((_g198 < _g199)){
HXDLIN( 289)															_g198 = (_g198 + 1);
HXDLIN( 289)															int i89 = (_g198 - 1);
HXLINE( 345)															prev9 = l9;
HXLINE( 346)															l9 = l9->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev9 )) {
HXDLIN( 289)														b65->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l9->next);
HXDLIN( 289)														l9 = null();
            													}
            													else {
HXDLIN( 289)														prev9->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l9->next);
HXDLIN( 289)														l9 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage28 = b65;
            							}
            							break;
            						}
HXDLIN( 289)						this293->image = undoImage28;
HXDLIN( 289)						this293->width = width9;
HXDLIN( 289)						this293->height = height9;
HXDLIN( 289)						this293->imageType = ( (int)(imageType9) );
HXDLIN( 289)						undoImage27 = this293;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft9 = xIter39->start;
HXDLIN( 289)							int rectTop9 = yIter39->start;
HXDLIN( 289)							int rectRight9 = xIter39->max;
HXDLIN( 289)							bool forceClear9 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g200 = rectTop9;
HXDLIN( 289)								int _g201 = yIter39->max;
HXDLIN( 289)								while((_g200 < _g201)){
HXDLIN( 289)									_g200 = (_g200 + 1);
HXDLIN( 289)									int dy11 = (_g200 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g202 = rectLeft9;
HXDLIN( 289)										int _g203 = rectRight9;
HXDLIN( 289)										while((_g202 < _g203)){
HXDLIN( 289)											_g202 = (_g202 + 1);
HXDLIN( 289)											int dx11 = (_g202 - 1);
HXDLIN( 289)											::Dynamic this295 = this261->image;
HXDLIN( 289)											int index38;
HXDLIN( 289)											if (this261->useVirtualPos) {
HXDLIN( 289)												index38 = ::Std_obj::_hx_int(((((( (Float)(dy11) ) - this261->virtualY) * ( (Float)(this261->width) )) + dx11) - this261->virtualX));
            											}
            											else {
HXDLIN( 289)												index38 = ::Std_obj::_hx_int(( (Float)(((dy11 * this261->width) + dx11)) ));
            											}
HXDLIN( 289)											int c29 = ::iterMagic::Iimg_obj::get(this295,index38);
HXDLIN( 289)											int col9;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col9 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col9 = c29;
            											}
HXDLIN( 289)											bool _hx_tmp72;
HXDLIN( 289)											if (this261->useMask) {
HXDLIN( 289)												_hx_tmp72 = ::hx::IsNotNull( this261->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp72 = false;
            											}
HXDLIN( 289)											if (_hx_tmp72) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this296 = this261->mask;
HXDLIN( 289)												::Dynamic this297 = this296->image;
HXDLIN( 289)												int index39;
HXDLIN( 289)												if (this296->useVirtualPos) {
HXDLIN( 289)													index39 = ::Std_obj::_hx_int(((((( (Float)(dy11) ) - this296->virtualY) * ( (Float)(this296->width) )) + dx11) - this296->virtualX));
            												}
            												else {
HXDLIN( 289)													index39 = ::Std_obj::_hx_int(( (Float)(((dy11 * this296->width) + dx11)) ));
            												}
HXDLIN( 289)												int c30 = ::iterMagic::Iimg_obj::get(this297,index39);
HXDLIN( 289)												int v31;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v31 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v31 = c30;
            												}
HXDLIN( 289)												int maskPixel9 = v31;
HXDLIN( 289)												int this298 = col9;
HXDLIN( 289)												if ((maskPixel9 == 0)) {
HXDLIN( 289)													col9 = this298;
            												}
            												else {
HXDLIN( 289)													Float m09;
HXDLIN( 289)													int this299 = ((maskPixel9 >> 24) & 255);
HXDLIN( 289)													if ((this299 == 0)) {
HXDLIN( 289)														m09 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m09 = (( (Float)(this299) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m19;
HXDLIN( 289)													int this300 = ((maskPixel9 >> 16) & 255);
HXDLIN( 289)													if ((this300 == 0)) {
HXDLIN( 289)														m19 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m19 = (( (Float)(this300) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m29;
HXDLIN( 289)													int this301 = ((maskPixel9 >> 8) & 255);
HXDLIN( 289)													if ((this301 == 0)) {
HXDLIN( 289)														m29 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m29 = (( (Float)(this301) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m39;
HXDLIN( 289)													int this302 = (maskPixel9 & 255);
HXDLIN( 289)													if ((this302 == 0)) {
HXDLIN( 289)														m39 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m39 = (( (Float)(this302) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch09 = ::Std_obj::_hx_int(((((Float)1.) - m09) * ( (Float)(((this298 >> 24) & 255)) )));
HXDLIN( 289)													int ch19 = ::Std_obj::_hx_int(((((Float)1.) - m19) * ( (Float)(((this298 >> 16) & 255)) )));
HXDLIN( 289)													int ch29 = ::Std_obj::_hx_int(((((Float)1.) - m29) * ( (Float)(((this298 >> 8) & 255)) )));
HXDLIN( 289)													int ch39 = ::Std_obj::_hx_int(((((Float)1.) - m39) * ( (Float)((this298 & 255)) )));
HXDLIN( 289)													col9 = ((((::Math_obj::round((( (Float)(ch09) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch19) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch29) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch39) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col9 != 0)) {
HXDLIN( 289)												int x33 = (dx11 - rectLeft9);
HXDLIN( 289)												int y34 = (dy11 - rectTop9);
HXDLIN( 289)												int c31 = col9;
HXDLIN( 289)												bool _hx_tmp73;
HXDLIN( 289)												if ((((c31 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp73 = undoImage27->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp73 = false;
            												}
HXDLIN( 289)												if (_hx_tmp73) {
HXDLIN( 289)													int location18;
HXDLIN( 289)													if (undoImage27->useVirtualPos) {
HXDLIN( 289)														location18 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x33) - undoImage27->virtualX));
            													}
            													else {
HXDLIN( 289)														location18 = ::Std_obj::_hx_int(( (Float)(((y34 * undoImage27->width) + x33)) ));
            													}
HXDLIN( 289)													int this303 = ::iterMagic::Iimg_obj::get(undoImage27->image,location18);
HXDLIN( 289)													int this304;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this304 = ((((((this303 >> 24) & 255) << 24) | ((this303 & 255) << 16)) | (((this303 >> 8) & 255) << 8)) | ((this303 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this304 = this303;
            													}
HXDLIN( 289)													Float a122;
HXDLIN( 289)													int this305 = ((this304 >> 24) & 255);
HXDLIN( 289)													if ((this305 == 0)) {
HXDLIN( 289)														a122 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a122 = (( (Float)(this305) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r119;
HXDLIN( 289)													int this306 = ((this304 >> 16) & 255);
HXDLIN( 289)													if ((this306 == 0)) {
HXDLIN( 289)														r119 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r119 = (( (Float)(this306) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g119;
HXDLIN( 289)													int this307 = ((this304 >> 8) & 255);
HXDLIN( 289)													if ((this307 == 0)) {
HXDLIN( 289)														g119 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g119 = (( (Float)(this307) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b123;
HXDLIN( 289)													int this308 = (this304 & 255);
HXDLIN( 289)													if ((this308 == 0)) {
HXDLIN( 289)														b123 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b123 = (( (Float)(this308) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a220;
HXDLIN( 289)													int this309 = ((col9 >> 24) & 255);
HXDLIN( 289)													if ((this309 == 0)) {
HXDLIN( 289)														a220 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a220 = (( (Float)(this309) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r219;
HXDLIN( 289)													int this310 = ((col9 >> 16) & 255);
HXDLIN( 289)													if ((this310 == 0)) {
HXDLIN( 289)														r219 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r219 = (( (Float)(this310) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g219;
HXDLIN( 289)													int this311 = ((col9 >> 8) & 255);
HXDLIN( 289)													if ((this311 == 0)) {
HXDLIN( 289)														g219 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g219 = (( (Float)(this311) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b222;
HXDLIN( 289)													int this312 = (col9 & 255);
HXDLIN( 289)													if ((this312 == 0)) {
HXDLIN( 289)														b222 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b222 = (( (Float)(this312) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a319 = (a122 * (( (Float)(1) ) - a220));
HXDLIN( 289)													int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 289)													int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 289)													int b66 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a319) + (b222 * a220))));
HXDLIN( 289)													int a58 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 289)													int blended18 = ((((a58 << 24) | (r43 << 16)) | (g43 << 8)) | b66);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp74;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp74 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp74 = blended18;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage27->image,location18,_hx_tmp74);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this313 = undoImage27->image;
HXDLIN( 289)													int index40;
HXDLIN( 289)													if (undoImage27->useVirtualPos) {
HXDLIN( 289)														index40 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x33) - undoImage27->virtualX));
            													}
            													else {
HXDLIN( 289)														index40 = ::Std_obj::_hx_int(( (Float)(((y34 * undoImage27->width) + x33)) ));
            													}
HXDLIN( 289)													int _hx_tmp75;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp75 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp75 = c31;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this313,index40,_hx_tmp75);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear9) {
HXDLIN( 289)													::Dynamic this314 = undoImage27->image;
HXDLIN( 289)													int x34 = (dx11 - rectLeft9);
HXDLIN( 289)													int y35 = (dy11 - rectTop9);
HXDLIN( 289)													int index41;
HXDLIN( 289)													if (undoImage27->useVirtualPos) {
HXDLIN( 289)														index41 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x34) - undoImage27->virtualX));
            													}
            													else {
HXDLIN( 289)														index41 = ::Std_obj::_hx_int(( (Float)(((y35 * undoImage27->width) + x34)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this314,index41,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min18 = xIter39->start;
HXDLIN( 289)						int _g_max18 = xIter39->max;
HXDLIN( 289)						while((_g_min18 < _g_max18)){
HXDLIN( 289)							_g_min18 = (_g_min18 + 1);
HXDLIN( 289)							int px7 = (_g_min18 - 1);
HXDLIN( 289)							Float pcx7 = (( (Float)(px7) ) - farX);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min19 = yIter39->start;
HXDLIN( 289)								int _g_max19 = yIter39->max;
HXDLIN( 289)								while((_g_min19 < _g_max19)){
HXDLIN( 289)									_g_min19 = (_g_min19 + 1);
HXDLIN( 289)									int py7 = (_g_min19 - 1);
HXDLIN( 289)									Float pcy7 = (( (Float)(py7) ) - cy7);
HXDLIN( 289)									Float dot317 = ((pcx7 * bcx7) + (pcy7 * bcy7));
HXDLIN( 289)									Float dot327 = ((pcx7 * acx7) + (pcy7 * acy7));
HXDLIN( 289)									Float ratioA7 = (((dot227 * dot317) - (dot127 * dot327)) * denom17);
HXDLIN( 289)									Float ratioB7 = (((dot117 * dot327) - (dot127 * dot317)) * denom17);
HXDLIN( 289)									Float ratioC7 = ((((Float)1.0) - ratioB7) - ratioA7);
HXDLIN( 289)									bool _hx_tmp76;
HXDLIN( 289)									bool _hx_tmp77;
HXDLIN( 289)									if ((ratioA7 >= 0)) {
HXDLIN( 289)										_hx_tmp77 = (ratioB7 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp77 = false;
            									}
HXDLIN( 289)									if (_hx_tmp77) {
HXDLIN( 289)										_hx_tmp76 = (ratioC7 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp76 = false;
            									}
HXDLIN( 289)									if (_hx_tmp76) {
HXDLIN( 289)										int i90 = ::Std_obj::_hx_int((((( (Float)(aA7) ) * ratioA7) + (( (Float)(aB7) ) * ratioB7)) + (( (Float)(aC7) ) * ratioC7)));
HXDLIN( 289)										if ((i90 > 255)) {
HXLINE(  24)											i90 = 255;
            										}
HXLINE( 289)										if ((i90 < 0)) {
HXLINE(  25)											i90 = 0;
            										}
HXLINE( 289)										int a59 = i90;
HXDLIN( 289)										int i91 = ::Std_obj::_hx_int((((( (Float)(rA7) ) * ratioA7) + (( (Float)(rB7) ) * ratioB7)) + (( (Float)(rC7) ) * ratioC7)));
HXDLIN( 289)										if ((i91 > 255)) {
HXLINE(  24)											i91 = 255;
            										}
HXLINE( 289)										if ((i91 < 0)) {
HXLINE(  25)											i91 = 0;
            										}
HXLINE( 289)										int r44 = i91;
HXDLIN( 289)										int i92 = ::Std_obj::_hx_int((((( (Float)(gA7) ) * ratioA7) + (( (Float)(gB7) ) * ratioB7)) + (( (Float)(gC7) ) * ratioC7)));
HXDLIN( 289)										if ((i92 > 255)) {
HXLINE(  24)											i92 = 255;
            										}
HXLINE( 289)										if ((i92 < 0)) {
HXLINE(  25)											i92 = 0;
            										}
HXLINE( 289)										int g44 = i92;
HXDLIN( 289)										int i93 = ::Std_obj::_hx_int((((( (Float)(bA7) ) * ratioA7) + (( (Float)(bB7) ) * ratioB7)) + (( (Float)(bC7) ) * ratioC7)));
HXDLIN( 289)										if ((i93 > 255)) {
HXLINE(  24)											i93 = 255;
            										}
HXLINE( 289)										if ((i93 < 0)) {
HXLINE(  25)											i93 = 0;
            										}
HXLINE( 289)										int b67 = i93;
HXDLIN( 289)										{
HXDLIN( 289)											int location19;
HXDLIN( 289)											if (this261->useVirtualPos) {
HXDLIN( 289)												location19 = ::Std_obj::_hx_int(((((( (Float)(py7) ) - this261->virtualY) * ( (Float)(this261->width) )) + px7) - this261->virtualX));
            											}
            											else {
HXDLIN( 289)												location19 = ::Std_obj::_hx_int(( (Float)(((py7 * this261->width) + px7)) ));
            											}
HXDLIN( 289)											bool _hx_tmp78;
HXDLIN( 289)											if (this261->transparent) {
HXDLIN( 289)												_hx_tmp78 = (a59 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp78 = false;
            											}
HXDLIN( 289)											if (_hx_tmp78) {
HXDLIN( 289)												int this315 = ::iterMagic::Iimg_obj::get(this261->image,location19);
HXDLIN( 289)												int old7;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old7 = ((((((this315 >> 24) & 255) << 24) | ((this315 & 255) << 16)) | (((this315 >> 8) & 255) << 8)) | ((this315 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old7 = this315;
            												}
HXDLIN( 289)												int rhs7 = ((((a59 << 24) | (r44 << 16)) | (g44 << 8)) | b67);
HXDLIN( 289)												Float a123;
HXDLIN( 289)												int this316 = ((old7 >> 24) & 255);
HXDLIN( 289)												if ((this316 == 0)) {
HXDLIN( 289)													a123 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a123 = (( (Float)(this316) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r120;
HXDLIN( 289)												int this317 = ((old7 >> 16) & 255);
HXDLIN( 289)												if ((this317 == 0)) {
HXDLIN( 289)													r120 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r120 = (( (Float)(this317) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g120;
HXDLIN( 289)												int this318 = ((old7 >> 8) & 255);
HXDLIN( 289)												if ((this318 == 0)) {
HXDLIN( 289)													g120 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g120 = (( (Float)(this318) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b124;
HXDLIN( 289)												int this319 = (old7 & 255);
HXDLIN( 289)												if ((this319 == 0)) {
HXDLIN( 289)													b124 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b124 = (( (Float)(this319) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a221;
HXDLIN( 289)												int this320 = ((rhs7 >> 24) & 255);
HXDLIN( 289)												if ((this320 == 0)) {
HXDLIN( 289)													a221 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a221 = (( (Float)(this320) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r220;
HXDLIN( 289)												int this321 = ((rhs7 >> 16) & 255);
HXDLIN( 289)												if ((this321 == 0)) {
HXDLIN( 289)													r220 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r220 = (( (Float)(this321) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g220;
HXDLIN( 289)												int this322 = ((rhs7 >> 8) & 255);
HXDLIN( 289)												if ((this322 == 0)) {
HXDLIN( 289)													g220 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g220 = (( (Float)(this322) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b223;
HXDLIN( 289)												int this323 = (rhs7 & 255);
HXDLIN( 289)												if ((this323 == 0)) {
HXDLIN( 289)													b223 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b223 = (( (Float)(this323) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a320 = (a123 * (( (Float)(1) ) - a221));
HXDLIN( 289)												int r45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 289)												int g45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 289)												int b68 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a320) + (b223 * a221))));
HXDLIN( 289)												int a60 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 289)												int blended19 = ((((a60 << 24) | (r45 << 16)) | (g45 << 8)) | b68);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp79;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp79 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp79 = blended19;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this261->image,location19,_hx_tmp79);
            												}
            											}
            											else {
HXDLIN( 289)												int value7;
HXDLIN( 289)												if (this261->isLittle) {
HXDLIN( 289)													value7 = ((((a59 << 24) | (b67 << 16)) | (g44 << 8)) | r44);
            												}
            												else {
HXDLIN( 289)													value7 = ((((a59 << 24) | (r44 << 16)) | (g44 << 8)) | b67);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this261->image,location19,value7);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit9 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v32 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx5,y29,bx5,cy7,farX,cy7,true);
HXDLIN( 289)						if (hasUndo9) {
HXDLIN( 289)							v32->undoImage = undoImage27;
HXDLIN( 289)							v32->undoX = xIter39->start;
HXDLIN( 289)							v32->undoY = yIter39->start;
            						}
            					}
            				}
HXDLIN( 289)				if ((hasHit8 == true)) {
HXDLIN( 289)					 ::pi_xy::algo::HitQuad v33 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,farX,y29,bx5,y29,bx5,cy7,farX,cy7,true);
            				}
            			}
            		}
HXDLIN( 289)		Float inlobj_ax3 = farX;
HXDLIN( 289)		Float inlobj_ay3 = y29;
HXDLIN( 289)		Float inlobj_bx3 = bx5;
HXDLIN( 289)		Float inlobj_y3 = y29;
HXDLIN( 289)		Float inlobj_cx3 = bx5;
HXDLIN( 289)		Float inlobj_cy3 = cy7;
HXDLIN( 289)		Float inlobj_x3 = farX;
HXDLIN( 289)		Float inlobj_dy3 = cy7;
HXDLIN( 289)		{
HXDLIN( 289)			 ::pi_xy::ImageStruct this324 = this1;
HXDLIN( 289)			Float cx3 = (x + dx1);
HXDLIN( 289)			Float rx1 = ( (Float)(dx1) );
HXDLIN( 289)			{
HXDLIN( 289)				 ::Dynamic targetError2 = ((Float)1.05);
HXDLIN( 289)				if (::hx::IsNull( targetError2 )) {
HXLINE( 113)					targetError2 = ((Float)1.05);
            				}
HXLINE( 289)				Float rSmall2;
HXDLIN( 289)				if ((rx1 > bottomRadius)) {
HXDLIN( 289)					rSmall2 = bottomRadius;
            				}
            				else {
HXDLIN( 289)					rSmall2 = rx1;
            				}
HXDLIN( 289)				 ::Dynamic targetE2 = ( (Float)(targetError2) );
HXDLIN( 289)				if (::hx::IsNull( targetE2 )) {
HXLINE(  20)					targetE2 = ((Float)1.05);
            				}
HXLINE( 289)				int result2 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE2) ) / rSmall2)))));
HXDLIN( 289)				int noSides2;
HXDLIN( 289)				if ((result2 < 12)) {
HXDLIN( 289)					noSides2 = 12;
            				}
            				else {
HXDLIN( 289)					if ((result2 > 500)) {
HXDLIN( 289)						noSides2 = 500;
            					}
            					else {
HXDLIN( 289)						noSides2 = result2;
            					}
            				}
HXDLIN( 289)				int sides2 = (::Math_obj::ceil((( (Float)(noSides2) ) / ( (Float)(4) ))) * 4);
HXDLIN( 289)				Float theta2 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides2) ));
HXDLIN( 289)				Float omega2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 289)				int quarter2 = ::Std_obj::_hx_int((( (Float)(sides2) ) / ( (Float)(4) )));
HXDLIN( 289)				Float lastX2 = ((Float)0.);
HXDLIN( 289)				Float lastY2 = ((Float)0.);
HXDLIN( 289)				{
HXLINE(  26)					lastX2 = (cx3 + (rx1 * ::Math_obj::cos(((( (Float)(sides2) ) * theta2) + omega2))));
HXLINE(  27)					lastY2 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides2) ) * theta2) + omega2))));
            				}
HXLINE( 289)				{
HXDLIN( 289)					int _g204 = 0;
HXDLIN( 289)					int _g205 = (quarter2 + 1);
HXDLIN( 289)					while((_g204 < _g205)){
HXDLIN( 289)						_g204 = (_g204 + 1);
HXDLIN( 289)						int i94 = (_g204 - 1);
HXDLIN( 289)						Float nextX2 = (cx3 + (rx1 * ::Math_obj::cos((((( (Float)(i94) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN( 289)						Float nextY2 = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i94) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN( 289)						{
HXDLIN( 289)							 ::pi_xy::ImageStruct this325 = this324;
HXDLIN( 289)							bool hasHit10 = false;
HXDLIN( 289)							bool hasUndo10 = false;
HXDLIN( 289)							{
HXDLIN( 289)								Float bx6 = lastX2;
HXDLIN( 289)								Float by2 = lastY2;
HXDLIN( 289)								Float cx4 = nextX2;
HXDLIN( 289)								Float cy8 = nextY2;
HXDLIN( 289)								bool adjustWinding2 = (((((cx3 * by2) - (bx6 * lowerY)) + ((bx6 * cy8) - (cx4 * by2))) + ((cx4 * lowerY) - (cx3 * cy8))) > 0);
HXDLIN( 289)								if (!(adjustWinding2)) {
HXDLIN( 289)									Float bx_2 = bx6;
HXDLIN( 289)									Float by_2 = by2;
HXLINE(  25)									bx6 = cx4;
HXLINE(  26)									by2 = cy8;
HXLINE(  27)									cx4 = bx_2;
HXLINE(  28)									cy8 = by_2;
            								}
HXLINE( 289)								{
HXDLIN( 289)									Float s02 = ((lowerY * cx4) - (cx3 * cy8));
HXDLIN( 289)									Float sx2 = (cy8 - lowerY);
HXDLIN( 289)									Float sy2 = (cx3 - cx4);
HXDLIN( 289)									Float t02 = ((cx3 * by2) - (lowerY * bx6));
HXDLIN( 289)									Float tx2 = (lowerY - by2);
HXDLIN( 289)									Float ty2 = (bx6 - cx3);
HXDLIN( 289)									Float A2 = ((((-(by2) * cx4) + (lowerY * (-(bx6) + cx4))) + (cx3 * (by2 - cy8))) + (bx6 * cy8));
HXDLIN( 289)									 ::pi_xy::iter::IntIterStart xIter310;
HXDLIN( 289)									if ((cx3 > bx6)) {
HXDLIN( 289)										if ((cx3 > cx4)) {
HXDLIN( 289)											int min40;
HXDLIN( 289)											if ((bx6 > cx4)) {
HXDLIN( 289)												min40 = ::Math_obj::floor(cx4);
            											}
            											else {
HXDLIN( 289)												min40 = ::Math_obj::floor(bx6);
            											}
HXDLIN( 289)											int ii_min80 = min40;
HXDLIN( 289)											int ii_max80 = ::Math_obj::ceil(cx3);
HXDLIN( 289)											xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min80,ii_max80);
            										}
            										else {
HXDLIN( 289)											int ii_min81 = ::Math_obj::floor(bx6);
HXDLIN( 289)											int ii_max81 = ::Math_obj::ceil(cx4);
HXDLIN( 289)											xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min81,ii_max81);
            										}
            									}
            									else {
HXDLIN( 289)										if ((bx6 > cx4)) {
HXDLIN( 289)											int min41;
HXDLIN( 289)											if ((cx3 > cx4)) {
HXDLIN( 289)												min41 = ::Math_obj::floor(cx4);
            											}
            											else {
HXDLIN( 289)												min41 = ::Math_obj::ceil(cx3);
            											}
HXDLIN( 289)											int ii_min82 = min41;
HXDLIN( 289)											int ii_max82 = ::Math_obj::ceil(bx6);
HXDLIN( 289)											xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min82,ii_max82);
            										}
            										else {
HXDLIN( 289)											int ii_min83 = ::Math_obj::floor(cx3);
HXDLIN( 289)											int ii_max83 = ::Math_obj::ceil(cx4);
HXDLIN( 289)											xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min83,ii_max83);
            										}
            									}
HXDLIN( 289)									 ::pi_xy::iter::IntIterStart yIter310;
HXDLIN( 289)									if ((lowerY > by2)) {
HXDLIN( 289)										if ((lowerY > cy8)) {
HXDLIN( 289)											int min42;
HXDLIN( 289)											if ((by2 > cy8)) {
HXDLIN( 289)												min42 = ::Math_obj::floor(cy8);
            											}
            											else {
HXDLIN( 289)												min42 = ::Math_obj::floor(by2);
            											}
HXDLIN( 289)											int ii_min84 = min42;
HXDLIN( 289)											int ii_max84 = ::Math_obj::ceil(lowerY);
HXDLIN( 289)											yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min84,ii_max84);
            										}
            										else {
HXDLIN( 289)											int ii_min85 = ::Math_obj::floor(by2);
HXDLIN( 289)											int ii_max85 = ::Math_obj::ceil(cy8);
HXDLIN( 289)											yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min85,ii_max85);
            										}
            									}
            									else {
HXDLIN( 289)										if ((by2 > cy8)) {
HXDLIN( 289)											int min43;
HXDLIN( 289)											if ((lowerY > cy8)) {
HXDLIN( 289)												min43 = ::Math_obj::floor(cy8);
            											}
            											else {
HXDLIN( 289)												min43 = ::Math_obj::ceil(lowerY);
            											}
HXDLIN( 289)											int ii_min86 = min43;
HXDLIN( 289)											int ii_max86 = ::Math_obj::ceil(by2);
HXDLIN( 289)											yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min86,ii_max86);
            										}
            										else {
HXDLIN( 289)											int ii_min87 = ::Math_obj::floor(lowerY);
HXDLIN( 289)											int ii_max87 = ::Math_obj::ceil(cy8);
HXDLIN( 289)											yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min87,ii_max87);
            										}
            									}
HXDLIN( 289)									 ::pi_xy::ImageStruct undoImage30 = null();
HXDLIN( 289)									if (hasUndo10) {
HXDLIN( 289)										int width10 = ((xIter310->max - xIter310->start) + 1);
HXDLIN( 289)										int height10 = ((yIter310->max - yIter310->start) + 1);
HXDLIN( 289)										 ::Dynamic imageType10 = null();
HXDLIN( 289)										 ::pi_xy::ImageStruct this326 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)										if (::hx::IsNull( imageType10 )) {
HXLINE(  54)											imageType10 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 289)										::Dynamic undoImage31;
HXDLIN( 289)										switch((int)(( (int)(imageType10) ))){
            											case (int)0: {
HXDLIN( 289)												 ::iterMagic::BytesImg byt10 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::BytesImg b69 = byt10;
HXDLIN( 289)												{
HXDLIN( 289)													b69->width = width10;
HXDLIN( 289)													b69->height = height10;
HXDLIN( 289)													b69->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 289)													b69->data = ::haxe::io::Bytes_obj::alloc((b69->length * 4));
HXDLIN( 289)													{
HXDLIN( 289)														int len20 = b69->length;
HXDLIN( 289)														int w10 = 0;
HXDLIN( 289)														{
HXDLIN( 289)															int _g206 = 0;
HXDLIN( 289)															int _g207 = b69->height;
HXDLIN( 289)															while((_g206 < _g207)){
HXDLIN( 289)																_g206 = (_g206 + 1);
HXDLIN( 289)																int y36 = (_g206 - 1);
HXDLIN( 289)																{
HXDLIN( 289)																	int _g208 = 0;
HXDLIN( 289)																	int _g209 = b69->width;
HXDLIN( 289)																	while((_g208 < _g209)){
HXDLIN( 289)																		_g208 = (_g208 + 1);
HXDLIN( 289)																		int x35 = (_g208 - 1);
HXDLIN( 289)																		{
HXDLIN( 289)																			w10 = (w10 + 1);
HXDLIN( 289)																			b69->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w10 = (w10 + 1);
HXDLIN( 289)																			b69->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w10 = (w10 + 1);
HXDLIN( 289)																			b69->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w10 = (w10 + 1);
HXDLIN( 289)																			b69->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage31 = b69;
            											}
            											break;
            											case (int)1: {
HXDLIN( 289)												 ::iterMagic::ArrIntImg arrI10 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::ArrIntImg a61 = arrI10;
HXDLIN( 289)												{
HXDLIN( 289)													a61->width = width10;
HXDLIN( 289)													a61->height = height10;
HXDLIN( 289)													a61->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)													a61->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 289)													{
HXDLIN( 289)														int _g210 = 0;
HXDLIN( 289)														int _g211 = a61->length;
HXDLIN( 289)														while((_g210 < _g211)){
HXDLIN( 289)															_g210 = (_g210 + 1);
HXDLIN( 289)															int i95 = (_g210 - 1);
HXDLIN( 289)															a61->data[i95] = 0;
            														}
            													}
            												}
HXDLIN( 289)												undoImage31 = a61;
            											}
            											break;
            											case (int)2: {
HXDLIN( 289)												 ::iterMagic::U32ArrImg u32a10 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::U32ArrImg b70 = u32a10;
HXDLIN( 289)												{
HXDLIN( 289)													b70->width = width10;
HXDLIN( 289)													b70->height = height10;
HXDLIN( 289)													b70->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 289)													int size10 = (b70->length * 4);
HXDLIN( 289)													b70->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size10),0,size10);
HXDLIN( 289)													{
HXDLIN( 289)														int _g212 = 0;
HXDLIN( 289)														int _g213 = b70->length;
HXDLIN( 289)														while((_g212 < _g213)){
HXDLIN( 289)															_g212 = (_g212 + 1);
HXDLIN( 289)															int i96 = (_g212 - 1);
HXDLIN( 289)															{
HXDLIN( 289)																 ::haxe::io::ArrayBufferViewImpl this327 = b70->data;
HXDLIN( 289)																bool undoImage32;
HXDLIN( 289)																if ((i96 >= 0)) {
HXDLIN( 289)																	undoImage32 = (i96 < (this327->byteLength >> 2));
            																}
            																else {
HXDLIN( 289)																	undoImage32 = false;
            																}
HXDLIN( 289)																if (undoImage32) {
HXDLIN( 289)																	 ::haxe::io::Bytes _this10 = this327->bytes;
HXDLIN( 289)																	int pos10 = ((i96 << 2) + this327->byteOffset);
HXDLIN( 289)																	_this10->b[pos10] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this10->b[(pos10 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this10->b[(pos10 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this10->b[(pos10 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage31 = b70;
            											}
            											break;
            											case (int)3: {
HXDLIN( 289)												 ::iterMagic::VecIntImg vec10 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::VecIntImg v34 = vec10;
HXDLIN( 289)												{
HXDLIN( 289)													v34->width = width10;
HXDLIN( 289)													v34->height = height10;
HXDLIN( 289)													v34->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 289)													v34->data = ::Array_obj< int >::__new(v34->length);
HXDLIN( 289)													{
HXDLIN( 289)														int _g214 = 0;
HXDLIN( 289)														int _g215 = v34->length;
HXDLIN( 289)														while((_g214 < _g215)){
HXDLIN( 289)															_g214 = (_g214 + 1);
HXDLIN( 289)															int i97 = (_g214 - 1);
HXDLIN( 289)															v34->data->__unsafe_set(i97,0);
            														}
            													}
            												}
HXDLIN( 289)												undoImage31 = v34;
            											}
            											break;
            											case (int)4: {
HXDLIN( 289)												 ::iterMagic::StackIntImg sInt10 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::StackIntImg b71 = sInt10;
HXDLIN( 289)												{
HXDLIN( 289)													b71->width = width10;
HXDLIN( 289)													b71->height = height10;
HXDLIN( 289)													b71->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 289)													b71->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)													{
HXDLIN( 289)														int len21 = b71->length;
HXDLIN( 289)														 ::haxe::ds::GenericStack_Int d10 = b71->data;
HXDLIN( 289)														if (::hx::IsNull( d10->head )) {
HXDLIN( 289)															int _g216 = 0;
HXDLIN( 289)															int _g217 = len21;
HXDLIN( 289)															while((_g216 < _g217)){
HXDLIN( 289)																_g216 = (_g216 + 1);
HXDLIN( 289)																int i98 = (_g216 - 1);
HXDLIN( 289)																d10->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d10->head);
            															}
            														}
            														else {
HXDLIN( 289)															int _g218 = 0;
HXDLIN( 289)															int _g219 = len21;
HXDLIN( 289)															while((_g218 < _g219)){
HXDLIN( 289)																_g218 = (_g218 + 1);
HXDLIN( 289)																int i99 = (_g218 - 1);
HXDLIN( 289)																{
HXDLIN( 289)																	 ::haxe::ds::GenericCell_Int l10 = b71->data->head;
HXDLIN( 289)																	 ::haxe::ds::GenericCell_Int prev10 = null();
HXDLIN( 289)																	{
HXDLIN( 289)																		int _g220 = 0;
HXDLIN( 289)																		int _g221 = i99;
HXDLIN( 289)																		while((_g220 < _g221)){
HXDLIN( 289)																			_g220 = (_g220 + 1);
HXDLIN( 289)																			int i100 = (_g220 - 1);
HXLINE( 345)																			prev10 = l10;
HXLINE( 346)																			l10 = l10->next;
            																		}
            																	}
HXLINE( 289)																	if (::hx::IsNull( prev10 )) {
HXDLIN( 289)																		b71->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l10->next);
HXDLIN( 289)																		l10 = null();
            																	}
            																	else {
HXDLIN( 289)																		prev10->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l10->next);
HXDLIN( 289)																		l10 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage31 = b71;
            											}
            											break;
            										}
HXDLIN( 289)										this326->image = undoImage31;
HXDLIN( 289)										this326->width = width10;
HXDLIN( 289)										this326->height = height10;
HXDLIN( 289)										this326->imageType = ( (int)(imageType10) );
HXDLIN( 289)										undoImage30 = this326;
HXDLIN( 289)										{
HXDLIN( 289)											int rectLeft10 = xIter310->start;
HXDLIN( 289)											int rectTop10 = yIter310->start;
HXDLIN( 289)											int rectRight10 = xIter310->max;
HXDLIN( 289)											bool forceClear10 = false;
HXDLIN( 289)											{
HXDLIN( 289)												int _g222 = rectTop10;
HXDLIN( 289)												int _g223 = yIter310->max;
HXDLIN( 289)												while((_g222 < _g223)){
HXDLIN( 289)													_g222 = (_g222 + 1);
HXDLIN( 289)													int dy12 = (_g222 - 1);
HXDLIN( 289)													{
HXDLIN( 289)														int _g224 = rectLeft10;
HXDLIN( 289)														int _g225 = rectRight10;
HXDLIN( 289)														while((_g224 < _g225)){
HXDLIN( 289)															_g224 = (_g224 + 1);
HXDLIN( 289)															int dx12 = (_g224 - 1);
HXDLIN( 289)															::Dynamic this328 = this325->image;
HXDLIN( 289)															int index42;
HXDLIN( 289)															if (this325->useVirtualPos) {
HXDLIN( 289)																index42 = ::Std_obj::_hx_int(((((( (Float)(dy12) ) - this325->virtualY) * ( (Float)(this325->width) )) + dx12) - this325->virtualX));
            															}
            															else {
HXDLIN( 289)																index42 = ::Std_obj::_hx_int(( (Float)(((dy12 * this325->width) + dx12)) ));
            															}
HXDLIN( 289)															int c32 = ::iterMagic::Iimg_obj::get(this328,index42);
HXDLIN( 289)															int col10;
HXDLIN( 289)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																col10 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            															}
            															else {
HXDLIN( 289)																col10 = c32;
            															}
HXDLIN( 289)															bool _hx_tmp80;
HXDLIN( 289)															if (this325->useMask) {
HXDLIN( 289)																_hx_tmp80 = ::hx::IsNotNull( this325->mask );
            															}
            															else {
HXDLIN( 289)																_hx_tmp80 = false;
            															}
HXDLIN( 289)															if (_hx_tmp80) {
HXDLIN( 289)																 ::pi_xy::ImageStruct this329 = this325->mask;
HXDLIN( 289)																::Dynamic this330 = this329->image;
HXDLIN( 289)																int index43;
HXDLIN( 289)																if (this329->useVirtualPos) {
HXDLIN( 289)																	index43 = ::Std_obj::_hx_int(((((( (Float)(dy12) ) - this329->virtualY) * ( (Float)(this329->width) )) + dx12) - this329->virtualX));
            																}
            																else {
HXDLIN( 289)																	index43 = ::Std_obj::_hx_int(( (Float)(((dy12 * this329->width) + dx12)) ));
            																}
HXDLIN( 289)																int c33 = ::iterMagic::Iimg_obj::get(this330,index43);
HXDLIN( 289)																int v35;
HXDLIN( 289)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																	v35 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            																}
            																else {
HXDLIN( 289)																	v35 = c33;
            																}
HXDLIN( 289)																int maskPixel10 = v35;
HXDLIN( 289)																int this331 = col10;
HXDLIN( 289)																if ((maskPixel10 == 0)) {
HXDLIN( 289)																	col10 = this331;
            																}
            																else {
HXDLIN( 289)																	Float m010;
HXDLIN( 289)																	int this332 = ((maskPixel10 >> 24) & 255);
HXDLIN( 289)																	if ((this332 == 0)) {
HXDLIN( 289)																		m010 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m010 = (( (Float)(this332) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m110;
HXDLIN( 289)																	int this333 = ((maskPixel10 >> 16) & 255);
HXDLIN( 289)																	if ((this333 == 0)) {
HXDLIN( 289)																		m110 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m110 = (( (Float)(this333) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m210;
HXDLIN( 289)																	int this334 = ((maskPixel10 >> 8) & 255);
HXDLIN( 289)																	if ((this334 == 0)) {
HXDLIN( 289)																		m210 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m210 = (( (Float)(this334) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m310;
HXDLIN( 289)																	int this335 = (maskPixel10 & 255);
HXDLIN( 289)																	if ((this335 == 0)) {
HXDLIN( 289)																		m310 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m310 = (( (Float)(this335) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	int ch010 = ::Std_obj::_hx_int(((((Float)1.) - m010) * ( (Float)(((this331 >> 24) & 255)) )));
HXDLIN( 289)																	int ch110 = ::Std_obj::_hx_int(((((Float)1.) - m110) * ( (Float)(((this331 >> 16) & 255)) )));
HXDLIN( 289)																	int ch210 = ::Std_obj::_hx_int(((((Float)1.) - m210) * ( (Float)(((this331 >> 8) & 255)) )));
HXDLIN( 289)																	int ch310 = ::Std_obj::_hx_int(((((Float)1.) - m310) * ( (Float)((this331 & 255)) )));
HXDLIN( 289)																	col10 = ((((::Math_obj::round((( (Float)(ch010) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch110) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch210) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch310) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 289)															if ((col10 != 0)) {
HXDLIN( 289)																int x36 = (dx12 - rectLeft10);
HXDLIN( 289)																int y37 = (dy12 - rectTop10);
HXDLIN( 289)																int c34 = col10;
HXDLIN( 289)																bool _hx_tmp81;
HXDLIN( 289)																if ((((c34 >> 24) & 255) < 254)) {
HXDLIN( 289)																	_hx_tmp81 = undoImage30->transparent;
            																}
            																else {
HXDLIN( 289)																	_hx_tmp81 = false;
            																}
HXDLIN( 289)																if (_hx_tmp81) {
HXDLIN( 289)																	int location20;
HXDLIN( 289)																	if (undoImage30->useVirtualPos) {
HXDLIN( 289)																		location20 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x36) - undoImage30->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		location20 = ::Std_obj::_hx_int(( (Float)(((y37 * undoImage30->width) + x36)) ));
            																	}
HXDLIN( 289)																	int this336 = ::iterMagic::Iimg_obj::get(undoImage30->image,location20);
HXDLIN( 289)																	int this337;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		this337 = ((((((this336 >> 24) & 255) << 24) | ((this336 & 255) << 16)) | (((this336 >> 8) & 255) << 8)) | ((this336 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		this337 = this336;
            																	}
HXDLIN( 289)																	Float a124;
HXDLIN( 289)																	int this338 = ((this337 >> 24) & 255);
HXDLIN( 289)																	if ((this338 == 0)) {
HXDLIN( 289)																		a124 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a124 = (( (Float)(this338) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r121;
HXDLIN( 289)																	int this339 = ((this337 >> 16) & 255);
HXDLIN( 289)																	if ((this339 == 0)) {
HXDLIN( 289)																		r121 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r121 = (( (Float)(this339) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g121;
HXDLIN( 289)																	int this340 = ((this337 >> 8) & 255);
HXDLIN( 289)																	if ((this340 == 0)) {
HXDLIN( 289)																		g121 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g121 = (( (Float)(this340) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b125;
HXDLIN( 289)																	int this341 = (this337 & 255);
HXDLIN( 289)																	if ((this341 == 0)) {
HXDLIN( 289)																		b125 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b125 = (( (Float)(this341) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a222;
HXDLIN( 289)																	int this342 = ((col10 >> 24) & 255);
HXDLIN( 289)																	if ((this342 == 0)) {
HXDLIN( 289)																		a222 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a222 = (( (Float)(this342) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r221;
HXDLIN( 289)																	int this343 = ((col10 >> 16) & 255);
HXDLIN( 289)																	if ((this343 == 0)) {
HXDLIN( 289)																		r221 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r221 = (( (Float)(this343) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g221;
HXDLIN( 289)																	int this344 = ((col10 >> 8) & 255);
HXDLIN( 289)																	if ((this344 == 0)) {
HXDLIN( 289)																		g221 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g221 = (( (Float)(this344) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b224;
HXDLIN( 289)																	int this345 = (col10 & 255);
HXDLIN( 289)																	if ((this345 == 0)) {
HXDLIN( 289)																		b224 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b224 = (( (Float)(this345) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a321 = (a124 * (( (Float)(1) ) - a222));
HXDLIN( 289)																	int r46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 289)																	int g46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 289)																	int b72 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a321) + (b224 * a222))));
HXDLIN( 289)																	int a62 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 289)																	int blended20 = ((((a62 << 24) | (r46 << 16)) | (g46 << 8)) | b72);
HXDLIN( 289)																	{
HXDLIN( 289)																		int _hx_tmp82;
HXDLIN( 289)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																			_hx_tmp82 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 289)																			_hx_tmp82 = blended20;
            																		}
HXDLIN( 289)																		::iterMagic::Iimg_obj::set(undoImage30->image,location20,_hx_tmp82);
            																	}
            																}
            																else {
HXDLIN( 289)																	::Dynamic this346 = undoImage30->image;
HXDLIN( 289)																	int index44;
HXDLIN( 289)																	if (undoImage30->useVirtualPos) {
HXDLIN( 289)																		index44 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x36) - undoImage30->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index44 = ::Std_obj::_hx_int(( (Float)(((y37 * undoImage30->width) + x36)) ));
            																	}
HXDLIN( 289)																	int _hx_tmp83;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		_hx_tmp83 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		_hx_tmp83 = c34;
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this346,index44,_hx_tmp83);
            																}
            															}
            															else {
HXDLIN( 289)																if (forceClear10) {
HXDLIN( 289)																	::Dynamic this347 = undoImage30->image;
HXDLIN( 289)																	int x37 = (dx12 - rectLeft10);
HXDLIN( 289)																	int y38 = (dy12 - rectTop10);
HXDLIN( 289)																	int index45;
HXDLIN( 289)																	if (undoImage30->useVirtualPos) {
HXDLIN( 289)																		index45 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x37) - undoImage30->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index45 = ::Std_obj::_hx_int(( (Float)(((y38 * undoImage30->width) + x37)) ));
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this347,index45,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 289)									bool found2 = false;
HXDLIN( 289)									Float s2 = ((Float)0.);
HXDLIN( 289)									Float t2 = ((Float)0.);
HXDLIN( 289)									Float sxx2 = ((Float)0.);
HXDLIN( 289)									Float txx2 = ((Float)0.);
HXDLIN( 289)									{
HXDLIN( 289)										int _g_min20 = xIter310->start;
HXDLIN( 289)										int _g_max20 = xIter310->max;
HXDLIN( 289)										while((_g_min20 < _g_max20)){
HXDLIN( 289)											_g_min20 = (_g_min20 + 1);
HXDLIN( 289)											int x38 = (_g_min20 - 1);
HXLINE(  60)											sxx2 = (sx2 * ( (Float)(x38) ));
HXLINE(  61)											txx2 = (tx2 * ( (Float)(x38) ));
HXLINE(  62)											found2 = false;
HXLINE( 289)											{
HXDLIN( 289)												int _g_min21 = yIter310->start;
HXDLIN( 289)												int _g_max21 = yIter310->max;
HXDLIN( 289)												while((_g_min21 < _g_max21)){
HXDLIN( 289)													_g_min21 = (_g_min21 + 1);
HXDLIN( 289)													int y39 = (_g_min21 - 1);
HXLINE(  64)													s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y39) )));
HXLINE(  65)													t2 = ((t02 + txx2) + (ty2 * ( (Float)(y39) )));
HXLINE( 289)													bool _hx_tmp84;
HXDLIN( 289)													if (!((s2 <= 0))) {
HXDLIN( 289)														_hx_tmp84 = (t2 <= 0);
            													}
            													else {
HXDLIN( 289)														_hx_tmp84 = true;
            													}
HXDLIN( 289)													if (_hx_tmp84) {
HXDLIN( 289)														if (found2) {
HXDLIN( 289)															goto _hx_goto_634;
            														}
            													}
            													else {
HXDLIN( 289)														if (((s2 + t2) < A2)) {
HXDLIN( 289)															{
HXDLIN( 289)																int c35 = colorD;
HXDLIN( 289)																bool _hx_tmp85;
HXDLIN( 289)																if ((((c35 >> 24) & 255) < 254)) {
HXDLIN( 289)																	_hx_tmp85 = this325->transparent;
            																}
            																else {
HXDLIN( 289)																	_hx_tmp85 = false;
            																}
HXDLIN( 289)																if (_hx_tmp85) {
HXDLIN( 289)																	int location21;
HXDLIN( 289)																	if (this325->useVirtualPos) {
HXDLIN( 289)																		location21 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - this325->virtualY) * ( (Float)(this325->width) )) + x38) - this325->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		location21 = ::Std_obj::_hx_int(( (Float)(((y39 * this325->width) + x38)) ));
            																	}
HXDLIN( 289)																	int this348 = ::iterMagic::Iimg_obj::get(this325->image,location21);
HXDLIN( 289)																	int this349;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		this349 = ((((((this348 >> 24) & 255) << 24) | ((this348 & 255) << 16)) | (((this348 >> 8) & 255) << 8)) | ((this348 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		this349 = this348;
            																	}
HXDLIN( 289)																	Float a125;
HXDLIN( 289)																	int this350 = ((this349 >> 24) & 255);
HXDLIN( 289)																	if ((this350 == 0)) {
HXDLIN( 289)																		a125 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a125 = (( (Float)(this350) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r122;
HXDLIN( 289)																	int this351 = ((this349 >> 16) & 255);
HXDLIN( 289)																	if ((this351 == 0)) {
HXDLIN( 289)																		r122 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r122 = (( (Float)(this351) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g122;
HXDLIN( 289)																	int this352 = ((this349 >> 8) & 255);
HXDLIN( 289)																	if ((this352 == 0)) {
HXDLIN( 289)																		g122 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g122 = (( (Float)(this352) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b126;
HXDLIN( 289)																	int this353 = (this349 & 255);
HXDLIN( 289)																	if ((this353 == 0)) {
HXDLIN( 289)																		b126 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b126 = (( (Float)(this353) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a223;
HXDLIN( 289)																	int this354 = ((colorD >> 24) & 255);
HXDLIN( 289)																	if ((this354 == 0)) {
HXDLIN( 289)																		a223 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a223 = (( (Float)(this354) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r222;
HXDLIN( 289)																	int this355 = ((colorD >> 16) & 255);
HXDLIN( 289)																	if ((this355 == 0)) {
HXDLIN( 289)																		r222 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r222 = (( (Float)(this355) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g222;
HXDLIN( 289)																	int this356 = ((colorD >> 8) & 255);
HXDLIN( 289)																	if ((this356 == 0)) {
HXDLIN( 289)																		g222 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g222 = (( (Float)(this356) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b225;
HXDLIN( 289)																	int this357 = (colorD & 255);
HXDLIN( 289)																	if ((this357 == 0)) {
HXDLIN( 289)																		b225 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b225 = (( (Float)(this357) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a322 = (a125 * (( (Float)(1) ) - a223));
HXDLIN( 289)																	int r47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 289)																	int g47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 289)																	int b73 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a322) + (b225 * a223))));
HXDLIN( 289)																	int a63 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 289)																	int blended21 = ((((a63 << 24) | (r47 << 16)) | (g47 << 8)) | b73);
HXDLIN( 289)																	{
HXDLIN( 289)																		int _hx_tmp86;
HXDLIN( 289)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																			_hx_tmp86 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 289)																			_hx_tmp86 = blended21;
            																		}
HXDLIN( 289)																		::iterMagic::Iimg_obj::set(this325->image,location21,_hx_tmp86);
            																	}
            																}
            																else {
HXDLIN( 289)																	::Dynamic this358 = this325->image;
HXDLIN( 289)																	int index46;
HXDLIN( 289)																	if (this325->useVirtualPos) {
HXDLIN( 289)																		index46 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - this325->virtualY) * ( (Float)(this325->width) )) + x38) - this325->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index46 = ::Std_obj::_hx_int(( (Float)(((y39 * this325->width) + x38)) ));
            																	}
HXDLIN( 289)																	int _hx_tmp87;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		_hx_tmp87 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		_hx_tmp87 = c35;
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this358,index46,_hx_tmp87);
            																}
            															}
HXLINE(  73)															found2 = true;
            														}
            														else {
HXDLIN( 289)															if (found2) {
HXDLIN( 289)																goto _hx_goto_634;
            															}
            														}
            													}
            												}
            												_hx_goto_634:;
            											}
            										}
            									}
HXDLIN( 289)									if ((hasHit10 == true)) {
HXDLIN( 289)										 ::pi_xy::algo::HitTri v36 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx3,lowerY,bx6,by2,cx4,cy8,true);
HXDLIN( 289)										if (hasUndo10) {
HXDLIN( 289)											v36->undoImage = undoImage30;
HXDLIN( 289)											v36->undoX = xIter310->start;
HXDLIN( 289)											v36->undoY = yIter310->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  46)						lastX2 = nextX2;
HXLINE(  47)						lastY2 = nextY2;
            					}
            				}
            			}
            		}
HXLINE( 289)		 ::pi_xy::ImageStruct this359 = this1;
HXDLIN( 289)		Float x39 = (x + dx1);
HXDLIN( 289)		Float bx7 = (x39 + ( (Float)(fat1) ));
HXDLIN( 289)		Float cy9 = (lowerY + bottomRadius);
HXDLIN( 289)		{
HXDLIN( 289)			bool hasHit11 = true;
HXDLIN( 289)			{
HXDLIN( 289)				{
HXDLIN( 289)					bool hasUndo11 = false;
HXDLIN( 289)					int aA8 = ((colorB >> 24) & 255);
HXDLIN( 289)					int rA8 = ((colorB >> 16) & 255);
HXDLIN( 289)					int gA8 = ((colorB >> 8) & 255);
HXDLIN( 289)					int bA8 = (colorB & 255);
HXDLIN( 289)					int aB8 = ((colorD >> 24) & 255);
HXDLIN( 289)					int rB8 = ((colorD >> 16) & 255);
HXDLIN( 289)					int gB8 = ((colorD >> 8) & 255);
HXDLIN( 289)					int bB8 = (colorD & 255);
HXDLIN( 289)					int aC8 = ((colorD >> 24) & 255);
HXDLIN( 289)					int rC8 = ((colorD >> 16) & 255);
HXDLIN( 289)					int gC8 = ((colorD >> 8) & 255);
HXDLIN( 289)					int bC8 = (colorD & 255);
HXDLIN( 289)					Float bcx8 = (bx7 - x39);
HXDLIN( 289)					Float bcy8 = (lowerY - cy9);
HXDLIN( 289)					Float acx8 = (x39 - x39);
HXDLIN( 289)					Float acy8 = (lowerY - cy9);
HXDLIN( 289)					Float dot118 = ((bcx8 * bcx8) + (bcy8 * bcy8));
HXDLIN( 289)					Float dot128 = ((bcx8 * acx8) + (bcy8 * acy8));
HXDLIN( 289)					Float dot228 = ((acx8 * acx8) + (acy8 * acy8));
HXDLIN( 289)					Float denom18 = (( (Float)(1) ) / ((dot118 * dot228) - (dot128 * dot128)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter311;
HXDLIN( 289)					if ((x39 > bx7)) {
HXDLIN( 289)						if ((x39 > x39)) {
HXDLIN( 289)							int min44;
HXDLIN( 289)							if ((bx7 > x39)) {
HXDLIN( 289)								min44 = ::Math_obj::floor(x39);
            							}
            							else {
HXDLIN( 289)								min44 = ::Math_obj::floor(bx7);
            							}
HXDLIN( 289)							int ii_min88 = min44;
HXDLIN( 289)							int ii_max88 = ::Math_obj::ceil(x39);
HXDLIN( 289)							xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min88,ii_max88);
            						}
            						else {
HXDLIN( 289)							int ii_min89 = ::Math_obj::floor(bx7);
HXDLIN( 289)							int ii_max89 = ::Math_obj::ceil(x39);
HXDLIN( 289)							xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min89,ii_max89);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx7 > x39)) {
HXDLIN( 289)							int min45;
HXDLIN( 289)							if ((x39 > x39)) {
HXDLIN( 289)								min45 = ::Math_obj::floor(x39);
            							}
            							else {
HXDLIN( 289)								min45 = ::Math_obj::ceil(x39);
            							}
HXDLIN( 289)							int ii_min90 = min45;
HXDLIN( 289)							int ii_max90 = ::Math_obj::ceil(bx7);
HXDLIN( 289)							xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min90,ii_max90);
            						}
            						else {
HXDLIN( 289)							int ii_min91 = ::Math_obj::floor(x39);
HXDLIN( 289)							int ii_max91 = ::Math_obj::ceil(x39);
HXDLIN( 289)							xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min91,ii_max91);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter311;
HXDLIN( 289)					if ((lowerY > lowerY)) {
HXDLIN( 289)						if ((lowerY > cy9)) {
HXDLIN( 289)							int min46;
HXDLIN( 289)							if ((lowerY > cy9)) {
HXDLIN( 289)								min46 = ::Math_obj::floor(cy9);
            							}
            							else {
HXDLIN( 289)								min46 = ::Math_obj::floor(lowerY);
            							}
HXDLIN( 289)							int ii_min92 = min46;
HXDLIN( 289)							int ii_max92 = ::Math_obj::ceil(lowerY);
HXDLIN( 289)							yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min92,ii_max92);
            						}
            						else {
HXDLIN( 289)							int ii_min93 = ::Math_obj::floor(lowerY);
HXDLIN( 289)							int ii_max93 = ::Math_obj::ceil(cy9);
HXDLIN( 289)							yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min93,ii_max93);
            						}
            					}
            					else {
HXDLIN( 289)						if ((lowerY > cy9)) {
HXDLIN( 289)							int min47;
HXDLIN( 289)							if ((lowerY > cy9)) {
HXDLIN( 289)								min47 = ::Math_obj::floor(cy9);
            							}
            							else {
HXDLIN( 289)								min47 = ::Math_obj::ceil(lowerY);
            							}
HXDLIN( 289)							int ii_min94 = min47;
HXDLIN( 289)							int ii_max94 = ::Math_obj::ceil(lowerY);
HXDLIN( 289)							yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min94,ii_max94);
            						}
            						else {
HXDLIN( 289)							int ii_min95 = ::Math_obj::floor(lowerY);
HXDLIN( 289)							int ii_max95 = ::Math_obj::ceil(cy9);
HXDLIN( 289)							yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min95,ii_max95);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage33 = null();
HXDLIN( 289)					if (hasUndo11) {
HXDLIN( 289)						int width11 = ((xIter311->max - xIter311->start) + 1);
HXDLIN( 289)						int height11 = ((yIter311->max - yIter311->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType11 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this360 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType11 )) {
HXLINE(  54)							imageType11 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage34;
HXDLIN( 289)						switch((int)(( (int)(imageType11) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt11 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b74 = byt11;
HXDLIN( 289)								{
HXDLIN( 289)									b74->width = width11;
HXDLIN( 289)									b74->height = height11;
HXDLIN( 289)									b74->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 289)									b74->data = ::haxe::io::Bytes_obj::alloc((b74->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len22 = b74->length;
HXDLIN( 289)										int w11 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g226 = 0;
HXDLIN( 289)											int _g227 = b74->height;
HXDLIN( 289)											while((_g226 < _g227)){
HXDLIN( 289)												_g226 = (_g226 + 1);
HXDLIN( 289)												int y40 = (_g226 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g228 = 0;
HXDLIN( 289)													int _g229 = b74->width;
HXDLIN( 289)													while((_g228 < _g229)){
HXDLIN( 289)														_g228 = (_g228 + 1);
HXDLIN( 289)														int x40 = (_g228 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w11 = (w11 + 1);
HXDLIN( 289)															b74->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w11 = (w11 + 1);
HXDLIN( 289)															b74->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w11 = (w11 + 1);
HXDLIN( 289)															b74->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w11 = (w11 + 1);
HXDLIN( 289)															b74->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage34 = b74;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI11 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a64 = arrI11;
HXDLIN( 289)								{
HXDLIN( 289)									a64->width = width11;
HXDLIN( 289)									a64->height = height11;
HXDLIN( 289)									a64->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a64->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g230 = 0;
HXDLIN( 289)										int _g231 = a64->length;
HXDLIN( 289)										while((_g230 < _g231)){
HXDLIN( 289)											_g230 = (_g230 + 1);
HXDLIN( 289)											int i101 = (_g230 - 1);
HXDLIN( 289)											a64->data[i101] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage34 = a64;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a11 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b75 = u32a11;
HXDLIN( 289)								{
HXDLIN( 289)									b75->width = width11;
HXDLIN( 289)									b75->height = height11;
HXDLIN( 289)									b75->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 289)									int size11 = (b75->length * 4);
HXDLIN( 289)									b75->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size11),0,size11);
HXDLIN( 289)									{
HXDLIN( 289)										int _g232 = 0;
HXDLIN( 289)										int _g233 = b75->length;
HXDLIN( 289)										while((_g232 < _g233)){
HXDLIN( 289)											_g232 = (_g232 + 1);
HXDLIN( 289)											int i102 = (_g232 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this361 = b75->data;
HXDLIN( 289)												bool undoImage35;
HXDLIN( 289)												if ((i102 >= 0)) {
HXDLIN( 289)													undoImage35 = (i102 < (this361->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage35 = false;
            												}
HXDLIN( 289)												if (undoImage35) {
HXDLIN( 289)													 ::haxe::io::Bytes _this11 = this361->bytes;
HXDLIN( 289)													int pos11 = ((i102 << 2) + this361->byteOffset);
HXDLIN( 289)													_this11->b[pos11] = ( (unsigned char)(0) );
HXDLIN( 289)													_this11->b[(pos11 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this11->b[(pos11 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this11->b[(pos11 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage34 = b75;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec11 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v37 = vec11;
HXDLIN( 289)								{
HXDLIN( 289)									v37->width = width11;
HXDLIN( 289)									v37->height = height11;
HXDLIN( 289)									v37->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 289)									v37->data = ::Array_obj< int >::__new(v37->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g234 = 0;
HXDLIN( 289)										int _g235 = v37->length;
HXDLIN( 289)										while((_g234 < _g235)){
HXDLIN( 289)											_g234 = (_g234 + 1);
HXDLIN( 289)											int i103 = (_g234 - 1);
HXDLIN( 289)											v37->data->__unsafe_set(i103,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage34 = v37;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt11 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b76 = sInt11;
HXDLIN( 289)								{
HXDLIN( 289)									b76->width = width11;
HXDLIN( 289)									b76->height = height11;
HXDLIN( 289)									b76->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 289)									b76->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len23 = b76->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d11 = b76->data;
HXDLIN( 289)										if (::hx::IsNull( d11->head )) {
HXDLIN( 289)											int _g236 = 0;
HXDLIN( 289)											int _g237 = len23;
HXDLIN( 289)											while((_g236 < _g237)){
HXDLIN( 289)												_g236 = (_g236 + 1);
HXDLIN( 289)												int i104 = (_g236 - 1);
HXDLIN( 289)												d11->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d11->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g238 = 0;
HXDLIN( 289)											int _g239 = len23;
HXDLIN( 289)											while((_g238 < _g239)){
HXDLIN( 289)												_g238 = (_g238 + 1);
HXDLIN( 289)												int i105 = (_g238 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l11 = b76->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev11 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g240 = 0;
HXDLIN( 289)														int _g241 = i105;
HXDLIN( 289)														while((_g240 < _g241)){
HXDLIN( 289)															_g240 = (_g240 + 1);
HXDLIN( 289)															int i106 = (_g240 - 1);
HXLINE( 345)															prev11 = l11;
HXLINE( 346)															l11 = l11->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev11 )) {
HXDLIN( 289)														b76->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l11->next);
HXDLIN( 289)														l11 = null();
            													}
            													else {
HXDLIN( 289)														prev11->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l11->next);
HXDLIN( 289)														l11 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage34 = b76;
            							}
            							break;
            						}
HXDLIN( 289)						this360->image = undoImage34;
HXDLIN( 289)						this360->width = width11;
HXDLIN( 289)						this360->height = height11;
HXDLIN( 289)						this360->imageType = ( (int)(imageType11) );
HXDLIN( 289)						undoImage33 = this360;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft11 = xIter311->start;
HXDLIN( 289)							int rectTop11 = yIter311->start;
HXDLIN( 289)							int rectRight11 = xIter311->max;
HXDLIN( 289)							bool forceClear11 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g242 = rectTop11;
HXDLIN( 289)								int _g243 = yIter311->max;
HXDLIN( 289)								while((_g242 < _g243)){
HXDLIN( 289)									_g242 = (_g242 + 1);
HXDLIN( 289)									int dy13 = (_g242 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g244 = rectLeft11;
HXDLIN( 289)										int _g245 = rectRight11;
HXDLIN( 289)										while((_g244 < _g245)){
HXDLIN( 289)											_g244 = (_g244 + 1);
HXDLIN( 289)											int dx13 = (_g244 - 1);
HXDLIN( 289)											::Dynamic this362 = this359->image;
HXDLIN( 289)											int index47;
HXDLIN( 289)											if (this359->useVirtualPos) {
HXDLIN( 289)												index47 = ::Std_obj::_hx_int(((((( (Float)(dy13) ) - this359->virtualY) * ( (Float)(this359->width) )) + dx13) - this359->virtualX));
            											}
            											else {
HXDLIN( 289)												index47 = ::Std_obj::_hx_int(( (Float)(((dy13 * this359->width) + dx13)) ));
            											}
HXDLIN( 289)											int c36 = ::iterMagic::Iimg_obj::get(this362,index47);
HXDLIN( 289)											int col11;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col11 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col11 = c36;
            											}
HXDLIN( 289)											bool _hx_tmp88;
HXDLIN( 289)											if (this359->useMask) {
HXDLIN( 289)												_hx_tmp88 = ::hx::IsNotNull( this359->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp88 = false;
            											}
HXDLIN( 289)											if (_hx_tmp88) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this363 = this359->mask;
HXDLIN( 289)												::Dynamic this364 = this363->image;
HXDLIN( 289)												int index48;
HXDLIN( 289)												if (this363->useVirtualPos) {
HXDLIN( 289)													index48 = ::Std_obj::_hx_int(((((( (Float)(dy13) ) - this363->virtualY) * ( (Float)(this363->width) )) + dx13) - this363->virtualX));
            												}
            												else {
HXDLIN( 289)													index48 = ::Std_obj::_hx_int(( (Float)(((dy13 * this363->width) + dx13)) ));
            												}
HXDLIN( 289)												int c37 = ::iterMagic::Iimg_obj::get(this364,index48);
HXDLIN( 289)												int v38;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v38 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v38 = c37;
            												}
HXDLIN( 289)												int maskPixel11 = v38;
HXDLIN( 289)												int this365 = col11;
HXDLIN( 289)												if ((maskPixel11 == 0)) {
HXDLIN( 289)													col11 = this365;
            												}
            												else {
HXDLIN( 289)													Float m011;
HXDLIN( 289)													int this366 = ((maskPixel11 >> 24) & 255);
HXDLIN( 289)													if ((this366 == 0)) {
HXDLIN( 289)														m011 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m011 = (( (Float)(this366) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m111;
HXDLIN( 289)													int this367 = ((maskPixel11 >> 16) & 255);
HXDLIN( 289)													if ((this367 == 0)) {
HXDLIN( 289)														m111 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m111 = (( (Float)(this367) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m211;
HXDLIN( 289)													int this368 = ((maskPixel11 >> 8) & 255);
HXDLIN( 289)													if ((this368 == 0)) {
HXDLIN( 289)														m211 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m211 = (( (Float)(this368) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m311;
HXDLIN( 289)													int this369 = (maskPixel11 & 255);
HXDLIN( 289)													if ((this369 == 0)) {
HXDLIN( 289)														m311 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m311 = (( (Float)(this369) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch011 = ::Std_obj::_hx_int(((((Float)1.) - m011) * ( (Float)(((this365 >> 24) & 255)) )));
HXDLIN( 289)													int ch111 = ::Std_obj::_hx_int(((((Float)1.) - m111) * ( (Float)(((this365 >> 16) & 255)) )));
HXDLIN( 289)													int ch211 = ::Std_obj::_hx_int(((((Float)1.) - m211) * ( (Float)(((this365 >> 8) & 255)) )));
HXDLIN( 289)													int ch311 = ::Std_obj::_hx_int(((((Float)1.) - m311) * ( (Float)((this365 & 255)) )));
HXDLIN( 289)													col11 = ((((::Math_obj::round((( (Float)(ch011) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch111) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch211) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch311) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col11 != 0)) {
HXDLIN( 289)												int x41 = (dx13 - rectLeft11);
HXDLIN( 289)												int y41 = (dy13 - rectTop11);
HXDLIN( 289)												int c38 = col11;
HXDLIN( 289)												bool _hx_tmp89;
HXDLIN( 289)												if ((((c38 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp89 = undoImage33->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp89 = false;
            												}
HXDLIN( 289)												if (_hx_tmp89) {
HXDLIN( 289)													int location22;
HXDLIN( 289)													if (undoImage33->useVirtualPos) {
HXDLIN( 289)														location22 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x41) - undoImage33->virtualX));
            													}
            													else {
HXDLIN( 289)														location22 = ::Std_obj::_hx_int(( (Float)(((y41 * undoImage33->width) + x41)) ));
            													}
HXDLIN( 289)													int this370 = ::iterMagic::Iimg_obj::get(undoImage33->image,location22);
HXDLIN( 289)													int this371;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this371 = ((((((this370 >> 24) & 255) << 24) | ((this370 & 255) << 16)) | (((this370 >> 8) & 255) << 8)) | ((this370 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this371 = this370;
            													}
HXDLIN( 289)													Float a126;
HXDLIN( 289)													int this372 = ((this371 >> 24) & 255);
HXDLIN( 289)													if ((this372 == 0)) {
HXDLIN( 289)														a126 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a126 = (( (Float)(this372) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r123;
HXDLIN( 289)													int this373 = ((this371 >> 16) & 255);
HXDLIN( 289)													if ((this373 == 0)) {
HXDLIN( 289)														r123 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r123 = (( (Float)(this373) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g123;
HXDLIN( 289)													int this374 = ((this371 >> 8) & 255);
HXDLIN( 289)													if ((this374 == 0)) {
HXDLIN( 289)														g123 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g123 = (( (Float)(this374) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b127;
HXDLIN( 289)													int this375 = (this371 & 255);
HXDLIN( 289)													if ((this375 == 0)) {
HXDLIN( 289)														b127 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b127 = (( (Float)(this375) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a224;
HXDLIN( 289)													int this376 = ((col11 >> 24) & 255);
HXDLIN( 289)													if ((this376 == 0)) {
HXDLIN( 289)														a224 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a224 = (( (Float)(this376) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r223;
HXDLIN( 289)													int this377 = ((col11 >> 16) & 255);
HXDLIN( 289)													if ((this377 == 0)) {
HXDLIN( 289)														r223 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r223 = (( (Float)(this377) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g223;
HXDLIN( 289)													int this378 = ((col11 >> 8) & 255);
HXDLIN( 289)													if ((this378 == 0)) {
HXDLIN( 289)														g223 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g223 = (( (Float)(this378) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b226;
HXDLIN( 289)													int this379 = (col11 & 255);
HXDLIN( 289)													if ((this379 == 0)) {
HXDLIN( 289)														b226 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b226 = (( (Float)(this379) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a323 = (a126 * (( (Float)(1) ) - a224));
HXDLIN( 289)													int r48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 289)													int g48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 289)													int b77 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b127 * a323) + (b226 * a224))));
HXDLIN( 289)													int a65 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 289)													int blended22 = ((((a65 << 24) | (r48 << 16)) | (g48 << 8)) | b77);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp90;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp90 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp90 = blended22;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage33->image,location22,_hx_tmp90);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this380 = undoImage33->image;
HXDLIN( 289)													int index49;
HXDLIN( 289)													if (undoImage33->useVirtualPos) {
HXDLIN( 289)														index49 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x41) - undoImage33->virtualX));
            													}
            													else {
HXDLIN( 289)														index49 = ::Std_obj::_hx_int(( (Float)(((y41 * undoImage33->width) + x41)) ));
            													}
HXDLIN( 289)													int _hx_tmp91;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp91 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp91 = c38;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this380,index49,_hx_tmp91);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear11) {
HXDLIN( 289)													::Dynamic this381 = undoImage33->image;
HXDLIN( 289)													int x42 = (dx13 - rectLeft11);
HXDLIN( 289)													int y42 = (dy13 - rectTop11);
HXDLIN( 289)													int index50;
HXDLIN( 289)													if (undoImage33->useVirtualPos) {
HXDLIN( 289)														index50 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x42) - undoImage33->virtualX));
            													}
            													else {
HXDLIN( 289)														index50 = ::Std_obj::_hx_int(( (Float)(((y42 * undoImage33->width) + x42)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this381,index50,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min22 = xIter311->start;
HXDLIN( 289)						int _g_max22 = xIter311->max;
HXDLIN( 289)						while((_g_min22 < _g_max22)){
HXDLIN( 289)							_g_min22 = (_g_min22 + 1);
HXDLIN( 289)							int px8 = (_g_min22 - 1);
HXDLIN( 289)							Float pcx8 = (( (Float)(px8) ) - x39);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min23 = yIter311->start;
HXDLIN( 289)								int _g_max23 = yIter311->max;
HXDLIN( 289)								while((_g_min23 < _g_max23)){
HXDLIN( 289)									_g_min23 = (_g_min23 + 1);
HXDLIN( 289)									int py8 = (_g_min23 - 1);
HXDLIN( 289)									Float pcy8 = (( (Float)(py8) ) - cy9);
HXDLIN( 289)									Float dot318 = ((pcx8 * bcx8) + (pcy8 * bcy8));
HXDLIN( 289)									Float dot328 = ((pcx8 * acx8) + (pcy8 * acy8));
HXDLIN( 289)									Float ratioA8 = (((dot228 * dot318) - (dot128 * dot328)) * denom18);
HXDLIN( 289)									Float ratioB8 = (((dot118 * dot328) - (dot128 * dot318)) * denom18);
HXDLIN( 289)									Float ratioC8 = ((((Float)1.0) - ratioB8) - ratioA8);
HXDLIN( 289)									bool _hx_tmp92;
HXDLIN( 289)									bool _hx_tmp93;
HXDLIN( 289)									if ((ratioA8 >= 0)) {
HXDLIN( 289)										_hx_tmp93 = (ratioB8 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp93 = false;
            									}
HXDLIN( 289)									if (_hx_tmp93) {
HXDLIN( 289)										_hx_tmp92 = (ratioC8 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp92 = false;
            									}
HXDLIN( 289)									if (_hx_tmp92) {
HXDLIN( 289)										int i107 = ::Std_obj::_hx_int((((( (Float)(aA8) ) * ratioA8) + (( (Float)(aB8) ) * ratioB8)) + (( (Float)(aC8) ) * ratioC8)));
HXDLIN( 289)										if ((i107 > 255)) {
HXLINE(  24)											i107 = 255;
            										}
HXLINE( 289)										if ((i107 < 0)) {
HXLINE(  25)											i107 = 0;
            										}
HXLINE( 289)										int a66 = i107;
HXDLIN( 289)										int i108 = ::Std_obj::_hx_int((((( (Float)(rA8) ) * ratioA8) + (( (Float)(rB8) ) * ratioB8)) + (( (Float)(rC8) ) * ratioC8)));
HXDLIN( 289)										if ((i108 > 255)) {
HXLINE(  24)											i108 = 255;
            										}
HXLINE( 289)										if ((i108 < 0)) {
HXLINE(  25)											i108 = 0;
            										}
HXLINE( 289)										int r49 = i108;
HXDLIN( 289)										int i109 = ::Std_obj::_hx_int((((( (Float)(gA8) ) * ratioA8) + (( (Float)(gB8) ) * ratioB8)) + (( (Float)(gC8) ) * ratioC8)));
HXDLIN( 289)										if ((i109 > 255)) {
HXLINE(  24)											i109 = 255;
            										}
HXLINE( 289)										if ((i109 < 0)) {
HXLINE(  25)											i109 = 0;
            										}
HXLINE( 289)										int g49 = i109;
HXDLIN( 289)										int i110 = ::Std_obj::_hx_int((((( (Float)(bA8) ) * ratioA8) + (( (Float)(bB8) ) * ratioB8)) + (( (Float)(bC8) ) * ratioC8)));
HXDLIN( 289)										if ((i110 > 255)) {
HXLINE(  24)											i110 = 255;
            										}
HXLINE( 289)										if ((i110 < 0)) {
HXLINE(  25)											i110 = 0;
            										}
HXLINE( 289)										int b78 = i110;
HXDLIN( 289)										{
HXDLIN( 289)											int location23;
HXDLIN( 289)											if (this359->useVirtualPos) {
HXDLIN( 289)												location23 = ::Std_obj::_hx_int(((((( (Float)(py8) ) - this359->virtualY) * ( (Float)(this359->width) )) + px8) - this359->virtualX));
            											}
            											else {
HXDLIN( 289)												location23 = ::Std_obj::_hx_int(( (Float)(((py8 * this359->width) + px8)) ));
            											}
HXDLIN( 289)											bool _hx_tmp94;
HXDLIN( 289)											if (this359->transparent) {
HXDLIN( 289)												_hx_tmp94 = (a66 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp94 = false;
            											}
HXDLIN( 289)											if (_hx_tmp94) {
HXDLIN( 289)												int this382 = ::iterMagic::Iimg_obj::get(this359->image,location23);
HXDLIN( 289)												int old8;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old8 = ((((((this382 >> 24) & 255) << 24) | ((this382 & 255) << 16)) | (((this382 >> 8) & 255) << 8)) | ((this382 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old8 = this382;
            												}
HXDLIN( 289)												int rhs8 = ((((a66 << 24) | (r49 << 16)) | (g49 << 8)) | b78);
HXDLIN( 289)												Float a127;
HXDLIN( 289)												int this383 = ((old8 >> 24) & 255);
HXDLIN( 289)												if ((this383 == 0)) {
HXDLIN( 289)													a127 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a127 = (( (Float)(this383) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r124;
HXDLIN( 289)												int this384 = ((old8 >> 16) & 255);
HXDLIN( 289)												if ((this384 == 0)) {
HXDLIN( 289)													r124 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r124 = (( (Float)(this384) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g124;
HXDLIN( 289)												int this385 = ((old8 >> 8) & 255);
HXDLIN( 289)												if ((this385 == 0)) {
HXDLIN( 289)													g124 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g124 = (( (Float)(this385) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b128;
HXDLIN( 289)												int this386 = (old8 & 255);
HXDLIN( 289)												if ((this386 == 0)) {
HXDLIN( 289)													b128 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b128 = (( (Float)(this386) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a225;
HXDLIN( 289)												int this387 = ((rhs8 >> 24) & 255);
HXDLIN( 289)												if ((this387 == 0)) {
HXDLIN( 289)													a225 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a225 = (( (Float)(this387) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r224;
HXDLIN( 289)												int this388 = ((rhs8 >> 16) & 255);
HXDLIN( 289)												if ((this388 == 0)) {
HXDLIN( 289)													r224 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r224 = (( (Float)(this388) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g224;
HXDLIN( 289)												int this389 = ((rhs8 >> 8) & 255);
HXDLIN( 289)												if ((this389 == 0)) {
HXDLIN( 289)													g224 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g224 = (( (Float)(this389) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b227;
HXDLIN( 289)												int this390 = (rhs8 & 255);
HXDLIN( 289)												if ((this390 == 0)) {
HXDLIN( 289)													b227 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b227 = (( (Float)(this390) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a324 = (a127 * (( (Float)(1) ) - a225));
HXDLIN( 289)												int r50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r124 * a324) + (r224 * a225))));
HXDLIN( 289)												int g50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g124 * a324) + (g224 * a225))));
HXDLIN( 289)												int b79 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b128 * a324) + (b227 * a225))));
HXDLIN( 289)												int a67 = ::Std_obj::_hx_int((( (Float)(255) ) * (a324 + a225)));
HXDLIN( 289)												int blended23 = ((((a67 << 24) | (r50 << 16)) | (g50 << 8)) | b79);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp95;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp95 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp95 = blended23;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this359->image,location23,_hx_tmp95);
            												}
            											}
            											else {
HXDLIN( 289)												int value8;
HXDLIN( 289)												if (this359->isLittle) {
HXDLIN( 289)													value8 = ((((a66 << 24) | (b78 << 16)) | (g49 << 8)) | r49);
            												}
            												else {
HXDLIN( 289)													value8 = ((((a66 << 24) | (r49 << 16)) | (g49 << 8)) | b78);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this359->image,location23,value8);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit11 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v39 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x39,lowerY,bx7,lowerY,x39,cy9,true);
HXDLIN( 289)						if (hasUndo11) {
HXDLIN( 289)							v39->undoImage = undoImage33;
HXDLIN( 289)							v39->undoX = xIter311->start;
HXDLIN( 289)							v39->undoY = yIter311->start;
            						}
            					}
            				}
HXDLIN( 289)				{
HXDLIN( 289)					bool hasHit12 = false;
HXDLIN( 289)					bool hasUndo12 = false;
HXDLIN( 289)					int aA9 = ((colorB >> 24) & 255);
HXDLIN( 289)					int rA9 = ((colorB >> 16) & 255);
HXDLIN( 289)					int gA9 = ((colorB >> 8) & 255);
HXDLIN( 289)					int bA9 = (colorB & 255);
HXDLIN( 289)					int aB9 = ((colorB >> 24) & 255);
HXDLIN( 289)					int rB9 = ((colorB >> 16) & 255);
HXDLIN( 289)					int gB9 = ((colorB >> 8) & 255);
HXDLIN( 289)					int bB9 = (colorB & 255);
HXDLIN( 289)					int aC9 = ((colorD >> 24) & 255);
HXDLIN( 289)					int rC9 = ((colorD >> 16) & 255);
HXDLIN( 289)					int gC9 = ((colorD >> 8) & 255);
HXDLIN( 289)					int bC9 = (colorD & 255);
HXDLIN( 289)					Float bcx9 = (bx7 - x39);
HXDLIN( 289)					Float bcy9 = (cy9 - cy9);
HXDLIN( 289)					Float acx9 = (bx7 - x39);
HXDLIN( 289)					Float acy9 = (lowerY - cy9);
HXDLIN( 289)					Float dot119 = ((bcx9 * bcx9) + (bcy9 * bcy9));
HXDLIN( 289)					Float dot129 = ((bcx9 * acx9) + (bcy9 * acy9));
HXDLIN( 289)					Float dot229 = ((acx9 * acx9) + (acy9 * acy9));
HXDLIN( 289)					Float denom19 = (( (Float)(1) ) / ((dot119 * dot229) - (dot129 * dot129)));
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart xIter312;
HXDLIN( 289)					if ((bx7 > bx7)) {
HXDLIN( 289)						if ((bx7 > x39)) {
HXDLIN( 289)							int min48;
HXDLIN( 289)							if ((bx7 > x39)) {
HXDLIN( 289)								min48 = ::Math_obj::floor(x39);
            							}
            							else {
HXDLIN( 289)								min48 = ::Math_obj::floor(bx7);
            							}
HXDLIN( 289)							int ii_min96 = min48;
HXDLIN( 289)							int ii_max96 = ::Math_obj::ceil(bx7);
HXDLIN( 289)							xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min96,ii_max96);
            						}
            						else {
HXDLIN( 289)							int ii_min97 = ::Math_obj::floor(bx7);
HXDLIN( 289)							int ii_max97 = ::Math_obj::ceil(x39);
HXDLIN( 289)							xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min97,ii_max97);
            						}
            					}
            					else {
HXDLIN( 289)						if ((bx7 > x39)) {
HXDLIN( 289)							int min49;
HXDLIN( 289)							if ((bx7 > x39)) {
HXDLIN( 289)								min49 = ::Math_obj::floor(x39);
            							}
            							else {
HXDLIN( 289)								min49 = ::Math_obj::ceil(bx7);
            							}
HXDLIN( 289)							int ii_min98 = min49;
HXDLIN( 289)							int ii_max98 = ::Math_obj::ceil(bx7);
HXDLIN( 289)							xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min98,ii_max98);
            						}
            						else {
HXDLIN( 289)							int ii_min99 = ::Math_obj::floor(bx7);
HXDLIN( 289)							int ii_max99 = ::Math_obj::ceil(x39);
HXDLIN( 289)							xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min99,ii_max99);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::iter::IntIterStart yIter312;
HXDLIN( 289)					if ((lowerY > cy9)) {
HXDLIN( 289)						if ((lowerY > cy9)) {
HXDLIN( 289)							int min50;
HXDLIN( 289)							if ((cy9 > cy9)) {
HXDLIN( 289)								min50 = ::Math_obj::floor(cy9);
            							}
            							else {
HXDLIN( 289)								min50 = ::Math_obj::floor(cy9);
            							}
HXDLIN( 289)							int ii_min100 = min50;
HXDLIN( 289)							int ii_max100 = ::Math_obj::ceil(lowerY);
HXDLIN( 289)							yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min100,ii_max100);
            						}
            						else {
HXDLIN( 289)							int ii_min101 = ::Math_obj::floor(cy9);
HXDLIN( 289)							int ii_max101 = ::Math_obj::ceil(cy9);
HXDLIN( 289)							yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min101,ii_max101);
            						}
            					}
            					else {
HXDLIN( 289)						if ((cy9 > cy9)) {
HXDLIN( 289)							int min51;
HXDLIN( 289)							if ((lowerY > cy9)) {
HXDLIN( 289)								min51 = ::Math_obj::floor(cy9);
            							}
            							else {
HXDLIN( 289)								min51 = ::Math_obj::ceil(lowerY);
            							}
HXDLIN( 289)							int ii_min102 = min51;
HXDLIN( 289)							int ii_max102 = ::Math_obj::ceil(cy9);
HXDLIN( 289)							yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min102,ii_max102);
            						}
            						else {
HXDLIN( 289)							int ii_min103 = ::Math_obj::floor(lowerY);
HXDLIN( 289)							int ii_max103 = ::Math_obj::ceil(cy9);
HXDLIN( 289)							yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min103,ii_max103);
            						}
            					}
HXDLIN( 289)					 ::pi_xy::ImageStruct undoImage36 = null();
HXDLIN( 289)					if (hasUndo12) {
HXDLIN( 289)						int width12 = ((xIter312->max - xIter312->start) + 1);
HXDLIN( 289)						int height12 = ((yIter312->max - yIter312->start) + 1);
HXDLIN( 289)						 ::Dynamic imageType12 = null();
HXDLIN( 289)						 ::pi_xy::ImageStruct this391 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)						if (::hx::IsNull( imageType12 )) {
HXLINE(  54)							imageType12 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE( 289)						::Dynamic undoImage37;
HXDLIN( 289)						switch((int)(( (int)(imageType12) ))){
            							case (int)0: {
HXDLIN( 289)								 ::iterMagic::BytesImg byt12 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::BytesImg b80 = byt12;
HXDLIN( 289)								{
HXDLIN( 289)									b80->width = width12;
HXDLIN( 289)									b80->height = height12;
HXDLIN( 289)									b80->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 289)									b80->data = ::haxe::io::Bytes_obj::alloc((b80->length * 4));
HXDLIN( 289)									{
HXDLIN( 289)										int len24 = b80->length;
HXDLIN( 289)										int w12 = 0;
HXDLIN( 289)										{
HXDLIN( 289)											int _g246 = 0;
HXDLIN( 289)											int _g247 = b80->height;
HXDLIN( 289)											while((_g246 < _g247)){
HXDLIN( 289)												_g246 = (_g246 + 1);
HXDLIN( 289)												int y43 = (_g246 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													int _g248 = 0;
HXDLIN( 289)													int _g249 = b80->width;
HXDLIN( 289)													while((_g248 < _g249)){
HXDLIN( 289)														_g248 = (_g248 + 1);
HXDLIN( 289)														int x43 = (_g248 - 1);
HXDLIN( 289)														{
HXDLIN( 289)															w12 = (w12 + 1);
HXDLIN( 289)															b80->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w12 = (w12 + 1);
HXDLIN( 289)															b80->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w12 = (w12 + 1);
HXDLIN( 289)															b80->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN( 289)														{
HXDLIN( 289)															w12 = (w12 + 1);
HXDLIN( 289)															b80->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage37 = b80;
            							}
            							break;
            							case (int)1: {
HXDLIN( 289)								 ::iterMagic::ArrIntImg arrI12 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::ArrIntImg a68 = arrI12;
HXDLIN( 289)								{
HXDLIN( 289)									a68->width = width12;
HXDLIN( 289)									a68->height = height12;
HXDLIN( 289)									a68->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)									a68->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 289)									{
HXDLIN( 289)										int _g250 = 0;
HXDLIN( 289)										int _g251 = a68->length;
HXDLIN( 289)										while((_g250 < _g251)){
HXDLIN( 289)											_g250 = (_g250 + 1);
HXDLIN( 289)											int i111 = (_g250 - 1);
HXDLIN( 289)											a68->data[i111] = 0;
            										}
            									}
            								}
HXDLIN( 289)								undoImage37 = a68;
            							}
            							break;
            							case (int)2: {
HXDLIN( 289)								 ::iterMagic::U32ArrImg u32a12 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::U32ArrImg b81 = u32a12;
HXDLIN( 289)								{
HXDLIN( 289)									b81->width = width12;
HXDLIN( 289)									b81->height = height12;
HXDLIN( 289)									b81->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 289)									int size12 = (b81->length * 4);
HXDLIN( 289)									b81->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size12),0,size12);
HXDLIN( 289)									{
HXDLIN( 289)										int _g252 = 0;
HXDLIN( 289)										int _g253 = b81->length;
HXDLIN( 289)										while((_g252 < _g253)){
HXDLIN( 289)											_g252 = (_g252 + 1);
HXDLIN( 289)											int i112 = (_g252 - 1);
HXDLIN( 289)											{
HXDLIN( 289)												 ::haxe::io::ArrayBufferViewImpl this392 = b81->data;
HXDLIN( 289)												bool undoImage38;
HXDLIN( 289)												if ((i112 >= 0)) {
HXDLIN( 289)													undoImage38 = (i112 < (this392->byteLength >> 2));
            												}
            												else {
HXDLIN( 289)													undoImage38 = false;
            												}
HXDLIN( 289)												if (undoImage38) {
HXDLIN( 289)													 ::haxe::io::Bytes _this12 = this392->bytes;
HXDLIN( 289)													int pos12 = ((i112 << 2) + this392->byteOffset);
HXDLIN( 289)													_this12->b[pos12] = ( (unsigned char)(0) );
HXDLIN( 289)													_this12->b[(pos12 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this12->b[(pos12 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)													_this12->b[(pos12 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage37 = b81;
            							}
            							break;
            							case (int)3: {
HXDLIN( 289)								 ::iterMagic::VecIntImg vec12 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::VecIntImg v40 = vec12;
HXDLIN( 289)								{
HXDLIN( 289)									v40->width = width12;
HXDLIN( 289)									v40->height = height12;
HXDLIN( 289)									v40->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 289)									v40->data = ::Array_obj< int >::__new(v40->length);
HXDLIN( 289)									{
HXDLIN( 289)										int _g254 = 0;
HXDLIN( 289)										int _g255 = v40->length;
HXDLIN( 289)										while((_g254 < _g255)){
HXDLIN( 289)											_g254 = (_g254 + 1);
HXDLIN( 289)											int i113 = (_g254 - 1);
HXDLIN( 289)											v40->data->__unsafe_set(i113,0);
            										}
            									}
            								}
HXDLIN( 289)								undoImage37 = v40;
            							}
            							break;
            							case (int)4: {
HXDLIN( 289)								 ::iterMagic::StackIntImg sInt12 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)								 ::iterMagic::StackIntImg b82 = sInt12;
HXDLIN( 289)								{
HXDLIN( 289)									b82->width = width12;
HXDLIN( 289)									b82->height = height12;
HXDLIN( 289)									b82->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 289)									b82->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)									{
HXDLIN( 289)										int len25 = b82->length;
HXDLIN( 289)										 ::haxe::ds::GenericStack_Int d12 = b82->data;
HXDLIN( 289)										if (::hx::IsNull( d12->head )) {
HXDLIN( 289)											int _g256 = 0;
HXDLIN( 289)											int _g257 = len25;
HXDLIN( 289)											while((_g256 < _g257)){
HXDLIN( 289)												_g256 = (_g256 + 1);
HXDLIN( 289)												int i114 = (_g256 - 1);
HXDLIN( 289)												d12->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d12->head);
            											}
            										}
            										else {
HXDLIN( 289)											int _g258 = 0;
HXDLIN( 289)											int _g259 = len25;
HXDLIN( 289)											while((_g258 < _g259)){
HXDLIN( 289)												_g258 = (_g258 + 1);
HXDLIN( 289)												int i115 = (_g258 - 1);
HXDLIN( 289)												{
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int l12 = b82->data->head;
HXDLIN( 289)													 ::haxe::ds::GenericCell_Int prev12 = null();
HXDLIN( 289)													{
HXDLIN( 289)														int _g260 = 0;
HXDLIN( 289)														int _g261 = i115;
HXDLIN( 289)														while((_g260 < _g261)){
HXDLIN( 289)															_g260 = (_g260 + 1);
HXDLIN( 289)															int i116 = (_g260 - 1);
HXLINE( 345)															prev12 = l12;
HXLINE( 346)															l12 = l12->next;
            														}
            													}
HXLINE( 289)													if (::hx::IsNull( prev12 )) {
HXDLIN( 289)														b82->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l12->next);
HXDLIN( 289)														l12 = null();
            													}
            													else {
HXDLIN( 289)														prev12->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l12->next);
HXDLIN( 289)														l12 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 289)								undoImage37 = b82;
            							}
            							break;
            						}
HXDLIN( 289)						this391->image = undoImage37;
HXDLIN( 289)						this391->width = width12;
HXDLIN( 289)						this391->height = height12;
HXDLIN( 289)						this391->imageType = ( (int)(imageType12) );
HXDLIN( 289)						undoImage36 = this391;
HXDLIN( 289)						{
HXDLIN( 289)							int rectLeft12 = xIter312->start;
HXDLIN( 289)							int rectTop12 = yIter312->start;
HXDLIN( 289)							int rectRight12 = xIter312->max;
HXDLIN( 289)							bool forceClear12 = false;
HXDLIN( 289)							{
HXDLIN( 289)								int _g262 = rectTop12;
HXDLIN( 289)								int _g263 = yIter312->max;
HXDLIN( 289)								while((_g262 < _g263)){
HXDLIN( 289)									_g262 = (_g262 + 1);
HXDLIN( 289)									int dy14 = (_g262 - 1);
HXDLIN( 289)									{
HXDLIN( 289)										int _g264 = rectLeft12;
HXDLIN( 289)										int _g265 = rectRight12;
HXDLIN( 289)										while((_g264 < _g265)){
HXDLIN( 289)											_g264 = (_g264 + 1);
HXDLIN( 289)											int dx14 = (_g264 - 1);
HXDLIN( 289)											::Dynamic this393 = this359->image;
HXDLIN( 289)											int index51;
HXDLIN( 289)											if (this359->useVirtualPos) {
HXDLIN( 289)												index51 = ::Std_obj::_hx_int(((((( (Float)(dy14) ) - this359->virtualY) * ( (Float)(this359->width) )) + dx14) - this359->virtualX));
            											}
            											else {
HXDLIN( 289)												index51 = ::Std_obj::_hx_int(( (Float)(((dy14 * this359->width) + dx14)) ));
            											}
HXDLIN( 289)											int c39 = ::iterMagic::Iimg_obj::get(this393,index51);
HXDLIN( 289)											int col12;
HXDLIN( 289)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)												col12 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            											}
            											else {
HXDLIN( 289)												col12 = c39;
            											}
HXDLIN( 289)											bool _hx_tmp96;
HXDLIN( 289)											if (this359->useMask) {
HXDLIN( 289)												_hx_tmp96 = ::hx::IsNotNull( this359->mask );
            											}
            											else {
HXDLIN( 289)												_hx_tmp96 = false;
            											}
HXDLIN( 289)											if (_hx_tmp96) {
HXDLIN( 289)												 ::pi_xy::ImageStruct this394 = this359->mask;
HXDLIN( 289)												::Dynamic this395 = this394->image;
HXDLIN( 289)												int index52;
HXDLIN( 289)												if (this394->useVirtualPos) {
HXDLIN( 289)													index52 = ::Std_obj::_hx_int(((((( (Float)(dy14) ) - this394->virtualY) * ( (Float)(this394->width) )) + dx14) - this394->virtualX));
            												}
            												else {
HXDLIN( 289)													index52 = ::Std_obj::_hx_int(( (Float)(((dy14 * this394->width) + dx14)) ));
            												}
HXDLIN( 289)												int c40 = ::iterMagic::Iimg_obj::get(this395,index52);
HXDLIN( 289)												int v41;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													v41 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													v41 = c40;
            												}
HXDLIN( 289)												int maskPixel12 = v41;
HXDLIN( 289)												int this396 = col12;
HXDLIN( 289)												if ((maskPixel12 == 0)) {
HXDLIN( 289)													col12 = this396;
            												}
            												else {
HXDLIN( 289)													Float m012;
HXDLIN( 289)													int this397 = ((maskPixel12 >> 24) & 255);
HXDLIN( 289)													if ((this397 == 0)) {
HXDLIN( 289)														m012 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m012 = (( (Float)(this397) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m112;
HXDLIN( 289)													int this398 = ((maskPixel12 >> 16) & 255);
HXDLIN( 289)													if ((this398 == 0)) {
HXDLIN( 289)														m112 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m112 = (( (Float)(this398) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m212;
HXDLIN( 289)													int this399 = ((maskPixel12 >> 8) & 255);
HXDLIN( 289)													if ((this399 == 0)) {
HXDLIN( 289)														m212 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m212 = (( (Float)(this399) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float m312;
HXDLIN( 289)													int this400 = (maskPixel12 & 255);
HXDLIN( 289)													if ((this400 == 0)) {
HXDLIN( 289)														m312 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														m312 = (( (Float)(this400) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													int ch012 = ::Std_obj::_hx_int(((((Float)1.) - m012) * ( (Float)(((this396 >> 24) & 255)) )));
HXDLIN( 289)													int ch112 = ::Std_obj::_hx_int(((((Float)1.) - m112) * ( (Float)(((this396 >> 16) & 255)) )));
HXDLIN( 289)													int ch212 = ::Std_obj::_hx_int(((((Float)1.) - m212) * ( (Float)(((this396 >> 8) & 255)) )));
HXDLIN( 289)													int ch312 = ::Std_obj::_hx_int(((((Float)1.) - m312) * ( (Float)((this396 & 255)) )));
HXDLIN( 289)													col12 = ((((::Math_obj::round((( (Float)(ch012) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch112) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch212) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch312) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN( 289)											if ((col12 != 0)) {
HXDLIN( 289)												int x44 = (dx14 - rectLeft12);
HXDLIN( 289)												int y44 = (dy14 - rectTop12);
HXDLIN( 289)												int c41 = col12;
HXDLIN( 289)												bool _hx_tmp97;
HXDLIN( 289)												if ((((c41 >> 24) & 255) < 254)) {
HXDLIN( 289)													_hx_tmp97 = undoImage36->transparent;
            												}
            												else {
HXDLIN( 289)													_hx_tmp97 = false;
            												}
HXDLIN( 289)												if (_hx_tmp97) {
HXDLIN( 289)													int location24;
HXDLIN( 289)													if (undoImage36->useVirtualPos) {
HXDLIN( 289)														location24 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x44) - undoImage36->virtualX));
            													}
            													else {
HXDLIN( 289)														location24 = ::Std_obj::_hx_int(( (Float)(((y44 * undoImage36->width) + x44)) ));
            													}
HXDLIN( 289)													int this401 = ::iterMagic::Iimg_obj::get(undoImage36->image,location24);
HXDLIN( 289)													int this402;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														this402 = ((((((this401 >> 24) & 255) << 24) | ((this401 & 255) << 16)) | (((this401 >> 8) & 255) << 8)) | ((this401 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														this402 = this401;
            													}
HXDLIN( 289)													Float a128;
HXDLIN( 289)													int this403 = ((this402 >> 24) & 255);
HXDLIN( 289)													if ((this403 == 0)) {
HXDLIN( 289)														a128 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a128 = (( (Float)(this403) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r125;
HXDLIN( 289)													int this404 = ((this402 >> 16) & 255);
HXDLIN( 289)													if ((this404 == 0)) {
HXDLIN( 289)														r125 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r125 = (( (Float)(this404) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g125;
HXDLIN( 289)													int this405 = ((this402 >> 8) & 255);
HXDLIN( 289)													if ((this405 == 0)) {
HXDLIN( 289)														g125 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g125 = (( (Float)(this405) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b129;
HXDLIN( 289)													int this406 = (this402 & 255);
HXDLIN( 289)													if ((this406 == 0)) {
HXDLIN( 289)														b129 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b129 = (( (Float)(this406) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a226;
HXDLIN( 289)													int this407 = ((col12 >> 24) & 255);
HXDLIN( 289)													if ((this407 == 0)) {
HXDLIN( 289)														a226 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														a226 = (( (Float)(this407) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float r225;
HXDLIN( 289)													int this408 = ((col12 >> 16) & 255);
HXDLIN( 289)													if ((this408 == 0)) {
HXDLIN( 289)														r225 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														r225 = (( (Float)(this408) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float g225;
HXDLIN( 289)													int this409 = ((col12 >> 8) & 255);
HXDLIN( 289)													if ((this409 == 0)) {
HXDLIN( 289)														g225 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														g225 = (( (Float)(this409) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float b228;
HXDLIN( 289)													int this410 = (col12 & 255);
HXDLIN( 289)													if ((this410 == 0)) {
HXDLIN( 289)														b228 = ((Float)0.);
            													}
            													else {
HXDLIN( 289)														b228 = (( (Float)(this410) ) / ( (Float)(255) ));
            													}
HXDLIN( 289)													Float a325 = (a128 * (( (Float)(1) ) - a226));
HXDLIN( 289)													int r51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r125 * a325) + (r225 * a226))));
HXDLIN( 289)													int g51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g125 * a325) + (g225 * a226))));
HXDLIN( 289)													int b83 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b129 * a325) + (b228 * a226))));
HXDLIN( 289)													int a69 = ::Std_obj::_hx_int((( (Float)(255) ) * (a325 + a226)));
HXDLIN( 289)													int blended24 = ((((a69 << 24) | (r51 << 16)) | (g51 << 8)) | b83);
HXDLIN( 289)													{
HXDLIN( 289)														int _hx_tmp98;
HXDLIN( 289)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)															_hx_tmp98 = ((((((blended24 >> 24) & 255) << 24) | ((blended24 & 255) << 16)) | (((blended24 >> 8) & 255) << 8)) | ((blended24 >> 16) & 255));
            														}
            														else {
HXDLIN( 289)															_hx_tmp98 = blended24;
            														}
HXDLIN( 289)														::iterMagic::Iimg_obj::set(undoImage36->image,location24,_hx_tmp98);
            													}
            												}
            												else {
HXDLIN( 289)													::Dynamic this411 = undoImage36->image;
HXDLIN( 289)													int index53;
HXDLIN( 289)													if (undoImage36->useVirtualPos) {
HXDLIN( 289)														index53 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x44) - undoImage36->virtualX));
            													}
            													else {
HXDLIN( 289)														index53 = ::Std_obj::_hx_int(( (Float)(((y44 * undoImage36->width) + x44)) ));
            													}
HXDLIN( 289)													int _hx_tmp99;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp99 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp99 = c41;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this411,index53,_hx_tmp99);
            												}
            											}
            											else {
HXDLIN( 289)												if (forceClear12) {
HXDLIN( 289)													::Dynamic this412 = undoImage36->image;
HXDLIN( 289)													int x45 = (dx14 - rectLeft12);
HXDLIN( 289)													int y45 = (dy14 - rectTop12);
HXDLIN( 289)													int index54;
HXDLIN( 289)													if (undoImage36->useVirtualPos) {
HXDLIN( 289)														index54 = ::Std_obj::_hx_int(((((( (Float)(y45) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x45) - undoImage36->virtualX));
            													}
            													else {
HXDLIN( 289)														index54 = ::Std_obj::_hx_int(( (Float)(((y45 * undoImage36->width) + x45)) ));
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this412,index54,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					{
HXDLIN( 289)						int _g_min24 = xIter312->start;
HXDLIN( 289)						int _g_max24 = xIter312->max;
HXDLIN( 289)						while((_g_min24 < _g_max24)){
HXDLIN( 289)							_g_min24 = (_g_min24 + 1);
HXDLIN( 289)							int px9 = (_g_min24 - 1);
HXDLIN( 289)							Float pcx9 = (( (Float)(px9) ) - x39);
HXDLIN( 289)							{
HXDLIN( 289)								int _g_min25 = yIter312->start;
HXDLIN( 289)								int _g_max25 = yIter312->max;
HXDLIN( 289)								while((_g_min25 < _g_max25)){
HXDLIN( 289)									_g_min25 = (_g_min25 + 1);
HXDLIN( 289)									int py9 = (_g_min25 - 1);
HXDLIN( 289)									Float pcy9 = (( (Float)(py9) ) - cy9);
HXDLIN( 289)									Float dot319 = ((pcx9 * bcx9) + (pcy9 * bcy9));
HXDLIN( 289)									Float dot329 = ((pcx9 * acx9) + (pcy9 * acy9));
HXDLIN( 289)									Float ratioA9 = (((dot229 * dot319) - (dot129 * dot329)) * denom19);
HXDLIN( 289)									Float ratioB9 = (((dot119 * dot329) - (dot129 * dot319)) * denom19);
HXDLIN( 289)									Float ratioC9 = ((((Float)1.0) - ratioB9) - ratioA9);
HXDLIN( 289)									bool _hx_tmp100;
HXDLIN( 289)									bool _hx_tmp101;
HXDLIN( 289)									if ((ratioA9 >= 0)) {
HXDLIN( 289)										_hx_tmp101 = (ratioB9 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp101 = false;
            									}
HXDLIN( 289)									if (_hx_tmp101) {
HXDLIN( 289)										_hx_tmp100 = (ratioC9 >= 0);
            									}
            									else {
HXDLIN( 289)										_hx_tmp100 = false;
            									}
HXDLIN( 289)									if (_hx_tmp100) {
HXDLIN( 289)										int i117 = ::Std_obj::_hx_int((((( (Float)(aA9) ) * ratioA9) + (( (Float)(aB9) ) * ratioB9)) + (( (Float)(aC9) ) * ratioC9)));
HXDLIN( 289)										if ((i117 > 255)) {
HXLINE(  24)											i117 = 255;
            										}
HXLINE( 289)										if ((i117 < 0)) {
HXLINE(  25)											i117 = 0;
            										}
HXLINE( 289)										int a70 = i117;
HXDLIN( 289)										int i118 = ::Std_obj::_hx_int((((( (Float)(rA9) ) * ratioA9) + (( (Float)(rB9) ) * ratioB9)) + (( (Float)(rC9) ) * ratioC9)));
HXDLIN( 289)										if ((i118 > 255)) {
HXLINE(  24)											i118 = 255;
            										}
HXLINE( 289)										if ((i118 < 0)) {
HXLINE(  25)											i118 = 0;
            										}
HXLINE( 289)										int r52 = i118;
HXDLIN( 289)										int i119 = ::Std_obj::_hx_int((((( (Float)(gA9) ) * ratioA9) + (( (Float)(gB9) ) * ratioB9)) + (( (Float)(gC9) ) * ratioC9)));
HXDLIN( 289)										if ((i119 > 255)) {
HXLINE(  24)											i119 = 255;
            										}
HXLINE( 289)										if ((i119 < 0)) {
HXLINE(  25)											i119 = 0;
            										}
HXLINE( 289)										int g52 = i119;
HXDLIN( 289)										int i120 = ::Std_obj::_hx_int((((( (Float)(bA9) ) * ratioA9) + (( (Float)(bB9) ) * ratioB9)) + (( (Float)(bC9) ) * ratioC9)));
HXDLIN( 289)										if ((i120 > 255)) {
HXLINE(  24)											i120 = 255;
            										}
HXLINE( 289)										if ((i120 < 0)) {
HXLINE(  25)											i120 = 0;
            										}
HXLINE( 289)										int b84 = i120;
HXDLIN( 289)										{
HXDLIN( 289)											int location25;
HXDLIN( 289)											if (this359->useVirtualPos) {
HXDLIN( 289)												location25 = ::Std_obj::_hx_int(((((( (Float)(py9) ) - this359->virtualY) * ( (Float)(this359->width) )) + px9) - this359->virtualX));
            											}
            											else {
HXDLIN( 289)												location25 = ::Std_obj::_hx_int(( (Float)(((py9 * this359->width) + px9)) ));
            											}
HXDLIN( 289)											bool _hx_tmp102;
HXDLIN( 289)											if (this359->transparent) {
HXDLIN( 289)												_hx_tmp102 = (a70 < 254);
            											}
            											else {
HXDLIN( 289)												_hx_tmp102 = false;
            											}
HXDLIN( 289)											if (_hx_tmp102) {
HXDLIN( 289)												int this413 = ::iterMagic::Iimg_obj::get(this359->image,location25);
HXDLIN( 289)												int old9;
HXDLIN( 289)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)													old9 = ((((((this413 >> 24) & 255) << 24) | ((this413 & 255) << 16)) | (((this413 >> 8) & 255) << 8)) | ((this413 >> 16) & 255));
            												}
            												else {
HXDLIN( 289)													old9 = this413;
            												}
HXDLIN( 289)												int rhs9 = ((((a70 << 24) | (r52 << 16)) | (g52 << 8)) | b84);
HXDLIN( 289)												Float a129;
HXDLIN( 289)												int this414 = ((old9 >> 24) & 255);
HXDLIN( 289)												if ((this414 == 0)) {
HXDLIN( 289)													a129 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a129 = (( (Float)(this414) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r126;
HXDLIN( 289)												int this415 = ((old9 >> 16) & 255);
HXDLIN( 289)												if ((this415 == 0)) {
HXDLIN( 289)													r126 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r126 = (( (Float)(this415) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g126;
HXDLIN( 289)												int this416 = ((old9 >> 8) & 255);
HXDLIN( 289)												if ((this416 == 0)) {
HXDLIN( 289)													g126 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g126 = (( (Float)(this416) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b130;
HXDLIN( 289)												int this417 = (old9 & 255);
HXDLIN( 289)												if ((this417 == 0)) {
HXDLIN( 289)													b130 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b130 = (( (Float)(this417) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a227;
HXDLIN( 289)												int this418 = ((rhs9 >> 24) & 255);
HXDLIN( 289)												if ((this418 == 0)) {
HXDLIN( 289)													a227 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													a227 = (( (Float)(this418) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float r226;
HXDLIN( 289)												int this419 = ((rhs9 >> 16) & 255);
HXDLIN( 289)												if ((this419 == 0)) {
HXDLIN( 289)													r226 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													r226 = (( (Float)(this419) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float g226;
HXDLIN( 289)												int this420 = ((rhs9 >> 8) & 255);
HXDLIN( 289)												if ((this420 == 0)) {
HXDLIN( 289)													g226 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													g226 = (( (Float)(this420) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float b229;
HXDLIN( 289)												int this421 = (rhs9 & 255);
HXDLIN( 289)												if ((this421 == 0)) {
HXDLIN( 289)													b229 = ((Float)0.);
            												}
            												else {
HXDLIN( 289)													b229 = (( (Float)(this421) ) / ( (Float)(255) ));
            												}
HXDLIN( 289)												Float a326 = (a129 * (( (Float)(1) ) - a227));
HXDLIN( 289)												int r53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r126 * a326) + (r226 * a227))));
HXDLIN( 289)												int g53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g126 * a326) + (g226 * a227))));
HXDLIN( 289)												int b85 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b130 * a326) + (b229 * a227))));
HXDLIN( 289)												int a71 = ::Std_obj::_hx_int((( (Float)(255) ) * (a326 + a227)));
HXDLIN( 289)												int blended25 = ((((a71 << 24) | (r53 << 16)) | (g53 << 8)) | b85);
HXDLIN( 289)												{
HXDLIN( 289)													int _hx_tmp103;
HXDLIN( 289)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)														_hx_tmp103 = ((((((blended25 >> 24) & 255) << 24) | ((blended25 & 255) << 16)) | (((blended25 >> 8) & 255) << 8)) | ((blended25 >> 16) & 255));
            													}
            													else {
HXDLIN( 289)														_hx_tmp103 = blended25;
            													}
HXDLIN( 289)													::iterMagic::Iimg_obj::set(this359->image,location25,_hx_tmp103);
            												}
            											}
            											else {
HXDLIN( 289)												int value9;
HXDLIN( 289)												if (this359->isLittle) {
HXDLIN( 289)													value9 = ((((a70 << 24) | (b84 << 16)) | (g52 << 8)) | r52);
            												}
            												else {
HXDLIN( 289)													value9 = ((((a70 << 24) | (r52 << 16)) | (g52 << 8)) | b84);
            												}
HXDLIN( 289)												::iterMagic::Iimg_obj::set(this359->image,location25,value9);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 289)					if ((hasHit12 == false)) {
HXDLIN( 289)						 ::pi_xy::algo::HitTri v42 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx7,lowerY,bx7,cy9,x39,cy9,true);
HXDLIN( 289)						if (hasUndo12) {
HXDLIN( 289)							v42->undoImage = undoImage36;
HXDLIN( 289)							v42->undoX = xIter312->start;
HXDLIN( 289)							v42->undoY = yIter312->start;
            						}
            					}
            				}
HXDLIN( 289)				if ((hasHit11 == true)) {
HXDLIN( 289)					 ::pi_xy::algo::HitQuad v43 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x39,lowerY,bx7,lowerY,bx7,cy9,x39,cy9,true);
            				}
            			}
            		}
HXDLIN( 289)		Float inlobj_ax4 = x39;
HXDLIN( 289)		Float inlobj_ay4 = lowerY;
HXDLIN( 289)		Float inlobj_bx4 = bx7;
HXDLIN( 289)		Float inlobj_y4 = lowerY;
HXDLIN( 289)		Float inlobj_cx4 = bx7;
HXDLIN( 289)		Float inlobj_cy4 = cy9;
HXDLIN( 289)		Float inlobj_x4 = x39;
HXDLIN( 289)		Float inlobj_dy4 = cy9;
HXDLIN( 289)		{
HXDLIN( 289)			 ::pi_xy::ImageStruct this422 = this1;
HXDLIN( 289)			{
HXDLIN( 289)				 ::Dynamic targetError3 = ((Float)1.05);
HXDLIN( 289)				if (::hx::IsNull( targetError3 )) {
HXLINE( 113)					targetError3 = ((Float)1.05);
            				}
HXLINE( 289)				Float rSmall3;
HXDLIN( 289)				if ((rightRadius > bottomRadius)) {
HXDLIN( 289)					rSmall3 = bottomRadius;
            				}
            				else {
HXDLIN( 289)					rSmall3 = rightRadius;
            				}
HXDLIN( 289)				 ::Dynamic targetE3 = ( (Float)(targetError3) );
HXDLIN( 289)				if (::hx::IsNull( targetE3 )) {
HXLINE(  20)					targetE3 = ((Float)1.05);
            				}
HXLINE( 289)				int result3 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE3) ) / rSmall3)))));
HXDLIN( 289)				int noSides3;
HXDLIN( 289)				if ((result3 < 12)) {
HXDLIN( 289)					noSides3 = 12;
            				}
            				else {
HXDLIN( 289)					if ((result3 > 500)) {
HXDLIN( 289)						noSides3 = 500;
            					}
            					else {
HXDLIN( 289)						noSides3 = result3;
            					}
            				}
HXDLIN( 289)				int sides3 = (::Math_obj::ceil((( (Float)(noSides3) ) / ( (Float)(4) ))) * 4);
HXDLIN( 289)				Float theta3 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN( 289)				Float omega3 = ( (Float)(0) );
HXDLIN( 289)				int quarter3 = ::Std_obj::_hx_int((( (Float)(sides3) ) / ( (Float)(4) )));
HXDLIN( 289)				Float lastX3 = ((Float)0.);
HXDLIN( 289)				Float lastY3 = ((Float)0.);
HXDLIN( 289)				{
HXLINE(  26)					lastX3 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides3) ) * theta3) + omega3))));
HXLINE(  27)					lastY3 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides3) ) * theta3) + omega3))));
            				}
HXLINE( 289)				{
HXDLIN( 289)					int _g266 = 0;
HXDLIN( 289)					int _g267 = (quarter3 + 1);
HXDLIN( 289)					while((_g266 < _g267)){
HXDLIN( 289)						_g266 = (_g266 + 1);
HXDLIN( 289)						int i121 = (_g266 - 1);
HXDLIN( 289)						Float nextX3 = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i121) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN( 289)						Float nextY3 = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i121) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN( 289)						{
HXDLIN( 289)							 ::pi_xy::ImageStruct this423 = this422;
HXDLIN( 289)							bool hasHit13 = false;
HXDLIN( 289)							bool hasUndo13 = false;
HXDLIN( 289)							{
HXDLIN( 289)								Float bx8 = lastX3;
HXDLIN( 289)								Float by3 = lastY3;
HXDLIN( 289)								Float cx5 = nextX3;
HXDLIN( 289)								Float cy10 = nextY3;
HXDLIN( 289)								bool adjustWinding3 = (((((farX * by3) - (bx8 * lowerY)) + ((bx8 * cy10) - (cx5 * by3))) + ((cx5 * lowerY) - (farX * cy10))) > 0);
HXDLIN( 289)								if (!(adjustWinding3)) {
HXDLIN( 289)									Float bx_3 = bx8;
HXDLIN( 289)									Float by_3 = by3;
HXLINE(  25)									bx8 = cx5;
HXLINE(  26)									by3 = cy10;
HXLINE(  27)									cx5 = bx_3;
HXLINE(  28)									cy10 = by_3;
            								}
HXLINE( 289)								{
HXDLIN( 289)									Float s03 = ((lowerY * cx5) - (farX * cy10));
HXDLIN( 289)									Float sx3 = (cy10 - lowerY);
HXDLIN( 289)									Float sy3 = (farX - cx5);
HXDLIN( 289)									Float t03 = ((farX * by3) - (lowerY * bx8));
HXDLIN( 289)									Float tx3 = (lowerY - by3);
HXDLIN( 289)									Float ty3 = (bx8 - farX);
HXDLIN( 289)									Float A3 = ((((-(by3) * cx5) + (lowerY * (-(bx8) + cx5))) + (farX * (by3 - cy10))) + (bx8 * cy10));
HXDLIN( 289)									 ::pi_xy::iter::IntIterStart xIter313;
HXDLIN( 289)									if ((farX > bx8)) {
HXDLIN( 289)										if ((farX > cx5)) {
HXDLIN( 289)											int min52;
HXDLIN( 289)											if ((bx8 > cx5)) {
HXDLIN( 289)												min52 = ::Math_obj::floor(cx5);
            											}
            											else {
HXDLIN( 289)												min52 = ::Math_obj::floor(bx8);
            											}
HXDLIN( 289)											int ii_min104 = min52;
HXDLIN( 289)											int ii_max104 = ::Math_obj::ceil(farX);
HXDLIN( 289)											xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min104,ii_max104);
            										}
            										else {
HXDLIN( 289)											int ii_min105 = ::Math_obj::floor(bx8);
HXDLIN( 289)											int ii_max105 = ::Math_obj::ceil(cx5);
HXDLIN( 289)											xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min105,ii_max105);
            										}
            									}
            									else {
HXDLIN( 289)										if ((bx8 > cx5)) {
HXDLIN( 289)											int min53;
HXDLIN( 289)											if ((farX > cx5)) {
HXDLIN( 289)												min53 = ::Math_obj::floor(cx5);
            											}
            											else {
HXDLIN( 289)												min53 = ::Math_obj::ceil(farX);
            											}
HXDLIN( 289)											int ii_min106 = min53;
HXDLIN( 289)											int ii_max106 = ::Math_obj::ceil(bx8);
HXDLIN( 289)											xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min106,ii_max106);
            										}
            										else {
HXDLIN( 289)											int ii_min107 = ::Math_obj::floor(farX);
HXDLIN( 289)											int ii_max107 = ::Math_obj::ceil(cx5);
HXDLIN( 289)											xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min107,ii_max107);
            										}
            									}
HXDLIN( 289)									 ::pi_xy::iter::IntIterStart yIter313;
HXDLIN( 289)									if ((lowerY > by3)) {
HXDLIN( 289)										if ((lowerY > cy10)) {
HXDLIN( 289)											int min54;
HXDLIN( 289)											if ((by3 > cy10)) {
HXDLIN( 289)												min54 = ::Math_obj::floor(cy10);
            											}
            											else {
HXDLIN( 289)												min54 = ::Math_obj::floor(by3);
            											}
HXDLIN( 289)											int ii_min108 = min54;
HXDLIN( 289)											int ii_max108 = ::Math_obj::ceil(lowerY);
HXDLIN( 289)											yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min108,ii_max108);
            										}
            										else {
HXDLIN( 289)											int ii_min109 = ::Math_obj::floor(by3);
HXDLIN( 289)											int ii_max109 = ::Math_obj::ceil(cy10);
HXDLIN( 289)											yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min109,ii_max109);
            										}
            									}
            									else {
HXDLIN( 289)										if ((by3 > cy10)) {
HXDLIN( 289)											int min55;
HXDLIN( 289)											if ((lowerY > cy10)) {
HXDLIN( 289)												min55 = ::Math_obj::floor(cy10);
            											}
            											else {
HXDLIN( 289)												min55 = ::Math_obj::ceil(lowerY);
            											}
HXDLIN( 289)											int ii_min110 = min55;
HXDLIN( 289)											int ii_max110 = ::Math_obj::ceil(by3);
HXDLIN( 289)											yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min110,ii_max110);
            										}
            										else {
HXDLIN( 289)											int ii_min111 = ::Math_obj::floor(lowerY);
HXDLIN( 289)											int ii_max111 = ::Math_obj::ceil(cy10);
HXDLIN( 289)											yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min111,ii_max111);
            										}
            									}
HXDLIN( 289)									 ::pi_xy::ImageStruct undoImage39 = null();
HXDLIN( 289)									if (hasUndo13) {
HXDLIN( 289)										int width13 = ((xIter313->max - xIter313->start) + 1);
HXDLIN( 289)										int height13 = ((yIter313->max - yIter313->start) + 1);
HXDLIN( 289)										 ::Dynamic imageType13 = null();
HXDLIN( 289)										 ::pi_xy::ImageStruct this424 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 289)										if (::hx::IsNull( imageType13 )) {
HXLINE(  54)											imageType13 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 289)										::Dynamic undoImage40;
HXDLIN( 289)										switch((int)(( (int)(imageType13) ))){
            											case (int)0: {
HXDLIN( 289)												 ::iterMagic::BytesImg byt13 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::BytesImg b86 = byt13;
HXDLIN( 289)												{
HXDLIN( 289)													b86->width = width13;
HXDLIN( 289)													b86->height = height13;
HXDLIN( 289)													b86->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 289)													b86->data = ::haxe::io::Bytes_obj::alloc((b86->length * 4));
HXDLIN( 289)													{
HXDLIN( 289)														int len26 = b86->length;
HXDLIN( 289)														int w13 = 0;
HXDLIN( 289)														{
HXDLIN( 289)															int _g268 = 0;
HXDLIN( 289)															int _g269 = b86->height;
HXDLIN( 289)															while((_g268 < _g269)){
HXDLIN( 289)																_g268 = (_g268 + 1);
HXDLIN( 289)																int y46 = (_g268 - 1);
HXDLIN( 289)																{
HXDLIN( 289)																	int _g270 = 0;
HXDLIN( 289)																	int _g271 = b86->width;
HXDLIN( 289)																	while((_g270 < _g271)){
HXDLIN( 289)																		_g270 = (_g270 + 1);
HXDLIN( 289)																		int x46 = (_g270 - 1);
HXDLIN( 289)																		{
HXDLIN( 289)																			w13 = (w13 + 1);
HXDLIN( 289)																			b86->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w13 = (w13 + 1);
HXDLIN( 289)																			b86->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w13 = (w13 + 1);
HXDLIN( 289)																			b86->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 289)																		{
HXDLIN( 289)																			w13 = (w13 + 1);
HXDLIN( 289)																			b86->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage40 = b86;
            											}
            											break;
            											case (int)1: {
HXDLIN( 289)												 ::iterMagic::ArrIntImg arrI13 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::ArrIntImg a72 = arrI13;
HXDLIN( 289)												{
HXDLIN( 289)													a72->width = width13;
HXDLIN( 289)													a72->height = height13;
HXDLIN( 289)													a72->data = ::Array_obj< int >::__new(0);
HXDLIN( 289)													a72->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 289)													{
HXDLIN( 289)														int _g272 = 0;
HXDLIN( 289)														int _g273 = a72->length;
HXDLIN( 289)														while((_g272 < _g273)){
HXDLIN( 289)															_g272 = (_g272 + 1);
HXDLIN( 289)															int i122 = (_g272 - 1);
HXDLIN( 289)															a72->data[i122] = 0;
            														}
            													}
            												}
HXDLIN( 289)												undoImage40 = a72;
            											}
            											break;
            											case (int)2: {
HXDLIN( 289)												 ::iterMagic::U32ArrImg u32a13 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::U32ArrImg b87 = u32a13;
HXDLIN( 289)												{
HXDLIN( 289)													b87->width = width13;
HXDLIN( 289)													b87->height = height13;
HXDLIN( 289)													b87->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 289)													int size13 = (b87->length * 4);
HXDLIN( 289)													b87->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size13),0,size13);
HXDLIN( 289)													{
HXDLIN( 289)														int _g274 = 0;
HXDLIN( 289)														int _g275 = b87->length;
HXDLIN( 289)														while((_g274 < _g275)){
HXDLIN( 289)															_g274 = (_g274 + 1);
HXDLIN( 289)															int i123 = (_g274 - 1);
HXDLIN( 289)															{
HXDLIN( 289)																 ::haxe::io::ArrayBufferViewImpl this425 = b87->data;
HXDLIN( 289)																bool undoImage41;
HXDLIN( 289)																if ((i123 >= 0)) {
HXDLIN( 289)																	undoImage41 = (i123 < (this425->byteLength >> 2));
            																}
            																else {
HXDLIN( 289)																	undoImage41 = false;
            																}
HXDLIN( 289)																if (undoImage41) {
HXDLIN( 289)																	 ::haxe::io::Bytes _this13 = this425->bytes;
HXDLIN( 289)																	int pos13 = ((i123 << 2) + this425->byteOffset);
HXDLIN( 289)																	_this13->b[pos13] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this13->b[(pos13 + 1)] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this13->b[(pos13 + 2)] = ( (unsigned char)(0) );
HXDLIN( 289)																	_this13->b[(pos13 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage40 = b87;
            											}
            											break;
            											case (int)3: {
HXDLIN( 289)												 ::iterMagic::VecIntImg vec13 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::VecIntImg v44 = vec13;
HXDLIN( 289)												{
HXDLIN( 289)													v44->width = width13;
HXDLIN( 289)													v44->height = height13;
HXDLIN( 289)													v44->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 289)													v44->data = ::Array_obj< int >::__new(v44->length);
HXDLIN( 289)													{
HXDLIN( 289)														int _g276 = 0;
HXDLIN( 289)														int _g277 = v44->length;
HXDLIN( 289)														while((_g276 < _g277)){
HXDLIN( 289)															_g276 = (_g276 + 1);
HXDLIN( 289)															int i124 = (_g276 - 1);
HXDLIN( 289)															v44->data->__unsafe_set(i124,0);
            														}
            													}
            												}
HXDLIN( 289)												undoImage40 = v44;
            											}
            											break;
            											case (int)4: {
HXDLIN( 289)												 ::iterMagic::StackIntImg sInt13 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 289)												 ::iterMagic::StackIntImg b88 = sInt13;
HXDLIN( 289)												{
HXDLIN( 289)													b88->width = width13;
HXDLIN( 289)													b88->height = height13;
HXDLIN( 289)													b88->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 289)													b88->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 289)													{
HXDLIN( 289)														int len27 = b88->length;
HXDLIN( 289)														 ::haxe::ds::GenericStack_Int d13 = b88->data;
HXDLIN( 289)														if (::hx::IsNull( d13->head )) {
HXDLIN( 289)															int _g278 = 0;
HXDLIN( 289)															int _g279 = len27;
HXDLIN( 289)															while((_g278 < _g279)){
HXDLIN( 289)																_g278 = (_g278 + 1);
HXDLIN( 289)																int i125 = (_g278 - 1);
HXDLIN( 289)																d13->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d13->head);
            															}
            														}
            														else {
HXDLIN( 289)															int _g280 = 0;
HXDLIN( 289)															int _g281 = len27;
HXDLIN( 289)															while((_g280 < _g281)){
HXDLIN( 289)																_g280 = (_g280 + 1);
HXDLIN( 289)																int i126 = (_g280 - 1);
HXDLIN( 289)																{
HXDLIN( 289)																	 ::haxe::ds::GenericCell_Int l13 = b88->data->head;
HXDLIN( 289)																	 ::haxe::ds::GenericCell_Int prev13 = null();
HXDLIN( 289)																	{
HXDLIN( 289)																		int _g282 = 0;
HXDLIN( 289)																		int _g283 = i126;
HXDLIN( 289)																		while((_g282 < _g283)){
HXDLIN( 289)																			_g282 = (_g282 + 1);
HXDLIN( 289)																			int i127 = (_g282 - 1);
HXLINE( 345)																			prev13 = l13;
HXLINE( 346)																			l13 = l13->next;
            																		}
            																	}
HXLINE( 289)																	if (::hx::IsNull( prev13 )) {
HXDLIN( 289)																		b88->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l13->next);
HXDLIN( 289)																		l13 = null();
            																	}
            																	else {
HXDLIN( 289)																		prev13->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l13->next);
HXDLIN( 289)																		l13 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 289)												undoImage40 = b88;
            											}
            											break;
            										}
HXDLIN( 289)										this424->image = undoImage40;
HXDLIN( 289)										this424->width = width13;
HXDLIN( 289)										this424->height = height13;
HXDLIN( 289)										this424->imageType = ( (int)(imageType13) );
HXDLIN( 289)										undoImage39 = this424;
HXDLIN( 289)										{
HXDLIN( 289)											int rectLeft13 = xIter313->start;
HXDLIN( 289)											int rectTop13 = yIter313->start;
HXDLIN( 289)											int rectRight13 = xIter313->max;
HXDLIN( 289)											bool forceClear13 = false;
HXDLIN( 289)											{
HXDLIN( 289)												int _g284 = rectTop13;
HXDLIN( 289)												int _g285 = yIter313->max;
HXDLIN( 289)												while((_g284 < _g285)){
HXDLIN( 289)													_g284 = (_g284 + 1);
HXDLIN( 289)													int dy15 = (_g284 - 1);
HXDLIN( 289)													{
HXDLIN( 289)														int _g286 = rectLeft13;
HXDLIN( 289)														int _g287 = rectRight13;
HXDLIN( 289)														while((_g286 < _g287)){
HXDLIN( 289)															_g286 = (_g286 + 1);
HXDLIN( 289)															int dx15 = (_g286 - 1);
HXDLIN( 289)															::Dynamic this426 = this423->image;
HXDLIN( 289)															int index55;
HXDLIN( 289)															if (this423->useVirtualPos) {
HXDLIN( 289)																index55 = ::Std_obj::_hx_int(((((( (Float)(dy15) ) - this423->virtualY) * ( (Float)(this423->width) )) + dx15) - this423->virtualX));
            															}
            															else {
HXDLIN( 289)																index55 = ::Std_obj::_hx_int(( (Float)(((dy15 * this423->width) + dx15)) ));
            															}
HXDLIN( 289)															int c42 = ::iterMagic::Iimg_obj::get(this426,index55);
HXDLIN( 289)															int col13;
HXDLIN( 289)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																col13 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            															}
            															else {
HXDLIN( 289)																col13 = c42;
            															}
HXDLIN( 289)															bool _hx_tmp104;
HXDLIN( 289)															if (this423->useMask) {
HXDLIN( 289)																_hx_tmp104 = ::hx::IsNotNull( this423->mask );
            															}
            															else {
HXDLIN( 289)																_hx_tmp104 = false;
            															}
HXDLIN( 289)															if (_hx_tmp104) {
HXDLIN( 289)																 ::pi_xy::ImageStruct this427 = this423->mask;
HXDLIN( 289)																::Dynamic this428 = this427->image;
HXDLIN( 289)																int index56;
HXDLIN( 289)																if (this427->useVirtualPos) {
HXDLIN( 289)																	index56 = ::Std_obj::_hx_int(((((( (Float)(dy15) ) - this427->virtualY) * ( (Float)(this427->width) )) + dx15) - this427->virtualX));
            																}
            																else {
HXDLIN( 289)																	index56 = ::Std_obj::_hx_int(( (Float)(((dy15 * this427->width) + dx15)) ));
            																}
HXDLIN( 289)																int c43 = ::iterMagic::Iimg_obj::get(this428,index56);
HXDLIN( 289)																int v45;
HXDLIN( 289)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																	v45 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            																}
            																else {
HXDLIN( 289)																	v45 = c43;
            																}
HXDLIN( 289)																int maskPixel13 = v45;
HXDLIN( 289)																int this429 = col13;
HXDLIN( 289)																if ((maskPixel13 == 0)) {
HXDLIN( 289)																	col13 = this429;
            																}
            																else {
HXDLIN( 289)																	Float m013;
HXDLIN( 289)																	int this430 = ((maskPixel13 >> 24) & 255);
HXDLIN( 289)																	if ((this430 == 0)) {
HXDLIN( 289)																		m013 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m013 = (( (Float)(this430) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m113;
HXDLIN( 289)																	int this431 = ((maskPixel13 >> 16) & 255);
HXDLIN( 289)																	if ((this431 == 0)) {
HXDLIN( 289)																		m113 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m113 = (( (Float)(this431) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m213;
HXDLIN( 289)																	int this432 = ((maskPixel13 >> 8) & 255);
HXDLIN( 289)																	if ((this432 == 0)) {
HXDLIN( 289)																		m213 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m213 = (( (Float)(this432) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float m313;
HXDLIN( 289)																	int this433 = (maskPixel13 & 255);
HXDLIN( 289)																	if ((this433 == 0)) {
HXDLIN( 289)																		m313 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		m313 = (( (Float)(this433) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	int ch013 = ::Std_obj::_hx_int(((((Float)1.) - m013) * ( (Float)(((this429 >> 24) & 255)) )));
HXDLIN( 289)																	int ch113 = ::Std_obj::_hx_int(((((Float)1.) - m113) * ( (Float)(((this429 >> 16) & 255)) )));
HXDLIN( 289)																	int ch213 = ::Std_obj::_hx_int(((((Float)1.) - m213) * ( (Float)(((this429 >> 8) & 255)) )));
HXDLIN( 289)																	int ch313 = ::Std_obj::_hx_int(((((Float)1.) - m313) * ( (Float)((this429 & 255)) )));
HXDLIN( 289)																	col13 = ((((::Math_obj::round((( (Float)(ch013) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch113) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch213) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch313) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 289)															if ((col13 != 0)) {
HXDLIN( 289)																int x47 = (dx15 - rectLeft13);
HXDLIN( 289)																int y47 = (dy15 - rectTop13);
HXDLIN( 289)																int c44 = col13;
HXDLIN( 289)																bool _hx_tmp105;
HXDLIN( 289)																if ((((c44 >> 24) & 255) < 254)) {
HXDLIN( 289)																	_hx_tmp105 = undoImage39->transparent;
            																}
            																else {
HXDLIN( 289)																	_hx_tmp105 = false;
            																}
HXDLIN( 289)																if (_hx_tmp105) {
HXDLIN( 289)																	int location26;
HXDLIN( 289)																	if (undoImage39->useVirtualPos) {
HXDLIN( 289)																		location26 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x47) - undoImage39->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		location26 = ::Std_obj::_hx_int(( (Float)(((y47 * undoImage39->width) + x47)) ));
            																	}
HXDLIN( 289)																	int this434 = ::iterMagic::Iimg_obj::get(undoImage39->image,location26);
HXDLIN( 289)																	int this435;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		this435 = ((((((this434 >> 24) & 255) << 24) | ((this434 & 255) << 16)) | (((this434 >> 8) & 255) << 8)) | ((this434 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		this435 = this434;
            																	}
HXDLIN( 289)																	Float a130;
HXDLIN( 289)																	int this436 = ((this435 >> 24) & 255);
HXDLIN( 289)																	if ((this436 == 0)) {
HXDLIN( 289)																		a130 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a130 = (( (Float)(this436) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r127;
HXDLIN( 289)																	int this437 = ((this435 >> 16) & 255);
HXDLIN( 289)																	if ((this437 == 0)) {
HXDLIN( 289)																		r127 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r127 = (( (Float)(this437) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g127;
HXDLIN( 289)																	int this438 = ((this435 >> 8) & 255);
HXDLIN( 289)																	if ((this438 == 0)) {
HXDLIN( 289)																		g127 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g127 = (( (Float)(this438) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b131;
HXDLIN( 289)																	int this439 = (this435 & 255);
HXDLIN( 289)																	if ((this439 == 0)) {
HXDLIN( 289)																		b131 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b131 = (( (Float)(this439) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a228;
HXDLIN( 289)																	int this440 = ((col13 >> 24) & 255);
HXDLIN( 289)																	if ((this440 == 0)) {
HXDLIN( 289)																		a228 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a228 = (( (Float)(this440) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r227;
HXDLIN( 289)																	int this441 = ((col13 >> 16) & 255);
HXDLIN( 289)																	if ((this441 == 0)) {
HXDLIN( 289)																		r227 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r227 = (( (Float)(this441) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g227;
HXDLIN( 289)																	int this442 = ((col13 >> 8) & 255);
HXDLIN( 289)																	if ((this442 == 0)) {
HXDLIN( 289)																		g227 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g227 = (( (Float)(this442) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b230;
HXDLIN( 289)																	int this443 = (col13 & 255);
HXDLIN( 289)																	if ((this443 == 0)) {
HXDLIN( 289)																		b230 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b230 = (( (Float)(this443) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a327 = (a130 * (( (Float)(1) ) - a228));
HXDLIN( 289)																	int r54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r127 * a327) + (r227 * a228))));
HXDLIN( 289)																	int g54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g127 * a327) + (g227 * a228))));
HXDLIN( 289)																	int b89 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b131 * a327) + (b230 * a228))));
HXDLIN( 289)																	int a73 = ::Std_obj::_hx_int((( (Float)(255) ) * (a327 + a228)));
HXDLIN( 289)																	int blended26 = ((((a73 << 24) | (r54 << 16)) | (g54 << 8)) | b89);
HXDLIN( 289)																	{
HXDLIN( 289)																		int _hx_tmp106;
HXDLIN( 289)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																			_hx_tmp106 = ((((((blended26 >> 24) & 255) << 24) | ((blended26 & 255) << 16)) | (((blended26 >> 8) & 255) << 8)) | ((blended26 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 289)																			_hx_tmp106 = blended26;
            																		}
HXDLIN( 289)																		::iterMagic::Iimg_obj::set(undoImage39->image,location26,_hx_tmp106);
            																	}
            																}
            																else {
HXDLIN( 289)																	::Dynamic this444 = undoImage39->image;
HXDLIN( 289)																	int index57;
HXDLIN( 289)																	if (undoImage39->useVirtualPos) {
HXDLIN( 289)																		index57 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x47) - undoImage39->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index57 = ::Std_obj::_hx_int(( (Float)(((y47 * undoImage39->width) + x47)) ));
            																	}
HXDLIN( 289)																	int _hx_tmp107;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		_hx_tmp107 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		_hx_tmp107 = c44;
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this444,index57,_hx_tmp107);
            																}
            															}
            															else {
HXDLIN( 289)																if (forceClear13) {
HXDLIN( 289)																	::Dynamic this445 = undoImage39->image;
HXDLIN( 289)																	int x48 = (dx15 - rectLeft13);
HXDLIN( 289)																	int y48 = (dy15 - rectTop13);
HXDLIN( 289)																	int index58;
HXDLIN( 289)																	if (undoImage39->useVirtualPos) {
HXDLIN( 289)																		index58 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x48) - undoImage39->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index58 = ::Std_obj::_hx_int(( (Float)(((y48 * undoImage39->width) + x48)) ));
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this445,index58,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 289)									bool found3 = false;
HXDLIN( 289)									Float s3 = ((Float)0.);
HXDLIN( 289)									Float t3 = ((Float)0.);
HXDLIN( 289)									Float sxx3 = ((Float)0.);
HXDLIN( 289)									Float txx3 = ((Float)0.);
HXDLIN( 289)									{
HXDLIN( 289)										int _g_min26 = xIter313->start;
HXDLIN( 289)										int _g_max26 = xIter313->max;
HXDLIN( 289)										while((_g_min26 < _g_max26)){
HXDLIN( 289)											_g_min26 = (_g_min26 + 1);
HXDLIN( 289)											int x49 = (_g_min26 - 1);
HXLINE(  60)											sxx3 = (sx3 * ( (Float)(x49) ));
HXLINE(  61)											txx3 = (tx3 * ( (Float)(x49) ));
HXLINE(  62)											found3 = false;
HXLINE( 289)											{
HXDLIN( 289)												int _g_min27 = yIter313->start;
HXDLIN( 289)												int _g_max27 = yIter313->max;
HXDLIN( 289)												while((_g_min27 < _g_max27)){
HXDLIN( 289)													_g_min27 = (_g_min27 + 1);
HXDLIN( 289)													int y49 = (_g_min27 - 1);
HXLINE(  64)													s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y49) )));
HXLINE(  65)													t3 = ((t03 + txx3) + (ty3 * ( (Float)(y49) )));
HXLINE( 289)													bool _hx_tmp108;
HXDLIN( 289)													if (!((s3 <= 0))) {
HXDLIN( 289)														_hx_tmp108 = (t3 <= 0);
            													}
            													else {
HXDLIN( 289)														_hx_tmp108 = true;
            													}
HXDLIN( 289)													if (_hx_tmp108) {
HXDLIN( 289)														if (found3) {
HXDLIN( 289)															goto _hx_goto_671;
            														}
            													}
            													else {
HXDLIN( 289)														if (((s3 + t3) < A3)) {
HXDLIN( 289)															{
HXDLIN( 289)																int c45 = colorB;
HXDLIN( 289)																bool _hx_tmp109;
HXDLIN( 289)																if ((((c45 >> 24) & 255) < 254)) {
HXDLIN( 289)																	_hx_tmp109 = this423->transparent;
            																}
            																else {
HXDLIN( 289)																	_hx_tmp109 = false;
            																}
HXDLIN( 289)																if (_hx_tmp109) {
HXDLIN( 289)																	int location27;
HXDLIN( 289)																	if (this423->useVirtualPos) {
HXDLIN( 289)																		location27 = ::Std_obj::_hx_int(((((( (Float)(y49) ) - this423->virtualY) * ( (Float)(this423->width) )) + x49) - this423->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		location27 = ::Std_obj::_hx_int(( (Float)(((y49 * this423->width) + x49)) ));
            																	}
HXDLIN( 289)																	int this446 = ::iterMagic::Iimg_obj::get(this423->image,location27);
HXDLIN( 289)																	int this447;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		this447 = ((((((this446 >> 24) & 255) << 24) | ((this446 & 255) << 16)) | (((this446 >> 8) & 255) << 8)) | ((this446 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		this447 = this446;
            																	}
HXDLIN( 289)																	Float a131;
HXDLIN( 289)																	int this448 = ((this447 >> 24) & 255);
HXDLIN( 289)																	if ((this448 == 0)) {
HXDLIN( 289)																		a131 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a131 = (( (Float)(this448) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r128;
HXDLIN( 289)																	int this449 = ((this447 >> 16) & 255);
HXDLIN( 289)																	if ((this449 == 0)) {
HXDLIN( 289)																		r128 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r128 = (( (Float)(this449) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g128;
HXDLIN( 289)																	int this450 = ((this447 >> 8) & 255);
HXDLIN( 289)																	if ((this450 == 0)) {
HXDLIN( 289)																		g128 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g128 = (( (Float)(this450) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b132;
HXDLIN( 289)																	int this451 = (this447 & 255);
HXDLIN( 289)																	if ((this451 == 0)) {
HXDLIN( 289)																		b132 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b132 = (( (Float)(this451) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a229;
HXDLIN( 289)																	int this452 = ((colorB >> 24) & 255);
HXDLIN( 289)																	if ((this452 == 0)) {
HXDLIN( 289)																		a229 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		a229 = (( (Float)(this452) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float r228;
HXDLIN( 289)																	int this453 = ((colorB >> 16) & 255);
HXDLIN( 289)																	if ((this453 == 0)) {
HXDLIN( 289)																		r228 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		r228 = (( (Float)(this453) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float g228;
HXDLIN( 289)																	int this454 = ((colorB >> 8) & 255);
HXDLIN( 289)																	if ((this454 == 0)) {
HXDLIN( 289)																		g228 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		g228 = (( (Float)(this454) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float b231;
HXDLIN( 289)																	int this455 = (colorB & 255);
HXDLIN( 289)																	if ((this455 == 0)) {
HXDLIN( 289)																		b231 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 289)																		b231 = (( (Float)(this455) ) / ( (Float)(255) ));
            																	}
HXDLIN( 289)																	Float a328 = (a131 * (( (Float)(1) ) - a229));
HXDLIN( 289)																	int r55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r128 * a328) + (r228 * a229))));
HXDLIN( 289)																	int g55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g128 * a328) + (g228 * a229))));
HXDLIN( 289)																	int b90 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b132 * a328) + (b231 * a229))));
HXDLIN( 289)																	int a74 = ::Std_obj::_hx_int((( (Float)(255) ) * (a328 + a229)));
HXDLIN( 289)																	int blended27 = ((((a74 << 24) | (r55 << 16)) | (g55 << 8)) | b90);
HXDLIN( 289)																	{
HXDLIN( 289)																		int _hx_tmp110;
HXDLIN( 289)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																			_hx_tmp110 = ((((((blended27 >> 24) & 255) << 24) | ((blended27 & 255) << 16)) | (((blended27 >> 8) & 255) << 8)) | ((blended27 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 289)																			_hx_tmp110 = blended27;
            																		}
HXDLIN( 289)																		::iterMagic::Iimg_obj::set(this423->image,location27,_hx_tmp110);
            																	}
            																}
            																else {
HXDLIN( 289)																	::Dynamic this456 = this423->image;
HXDLIN( 289)																	int index59;
HXDLIN( 289)																	if (this423->useVirtualPos) {
HXDLIN( 289)																		index59 = ::Std_obj::_hx_int(((((( (Float)(y49) ) - this423->virtualY) * ( (Float)(this423->width) )) + x49) - this423->virtualX));
            																	}
            																	else {
HXDLIN( 289)																		index59 = ::Std_obj::_hx_int(( (Float)(((y49 * this423->width) + x49)) ));
            																	}
HXDLIN( 289)																	int _hx_tmp111;
HXDLIN( 289)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)																		_hx_tmp111 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 289)																		_hx_tmp111 = c45;
            																	}
HXDLIN( 289)																	::iterMagic::Iimg_obj::set(this456,index59,_hx_tmp111);
            																}
            															}
HXLINE(  73)															found3 = true;
            														}
            														else {
HXDLIN( 289)															if (found3) {
HXDLIN( 289)																goto _hx_goto_671;
            															}
            														}
            													}
            												}
            												_hx_goto_671:;
            											}
            										}
            									}
HXDLIN( 289)									if ((hasHit13 == true)) {
HXDLIN( 289)										 ::pi_xy::algo::HitTri v46 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX,lowerY,bx8,by3,cx5,cy10,true);
HXDLIN( 289)										if (hasUndo13) {
HXDLIN( 289)											v46->undoImage = undoImage39;
HXDLIN( 289)											v46->undoX = xIter313->start;
HXDLIN( 289)											v46->undoY = yIter313->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  46)						lastX3 = nextX3;
HXLINE(  47)						lastY3 = nextY3;
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC13(GradientShape_Impl__obj,RoundRectangle,(void))

void GradientShape_Impl__obj::lineRoundRectangle( ::pi_xy::ImageStruct this1,Float x,Float y,Float hi,Float wid,Float thick,int colorA,int colorB,int colorC,int colorD, ::Dynamic __o_dx, ::Dynamic __o_dy, ::Dynamic __o_fat, ::Dynamic __o_tall){
            		 ::Dynamic dx = __o_dx;
            		if (::hx::IsNull(__o_dx)) dx = ((Float)-1.);
            		 ::Dynamic dy = __o_dy;
            		if (::hx::IsNull(__o_dy)) dy = ((Float)-1.);
            		 ::Dynamic fat = __o_fat;
            		if (::hx::IsNull(__o_fat)) fat = ((Float)-1.);
            		 ::Dynamic tall = __o_tall;
            		if (::hx::IsNull(__o_tall)) tall = ((Float)-1.);
            	HX_GC_STACKFRAME(&_hx_pos_70834771d18fdc01_303_lineRoundRectangle)
HXLINE( 304)		int width = ::Math_obj::ceil(hi);
HXDLIN( 304)		int height = ::Math_obj::ceil(wid);
HXDLIN( 304)		 ::Dynamic imageType = null();
HXDLIN( 304)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 304)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE( 304)		::Dynamic _hx_tmp;
HXDLIN( 304)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 304)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 304)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 304)				{
HXLINE( 304)					b->width = width;
HXDLIN( 304)					b->height = height;
HXDLIN( 304)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 304)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 304)					{
HXLINE( 304)						int len = b->length;
HXDLIN( 304)						int w = 0;
HXDLIN( 304)						{
HXLINE( 304)							int _g = 0;
HXDLIN( 304)							int _g1 = b->height;
HXDLIN( 304)							while((_g < _g1)){
HXLINE( 304)								_g = (_g + 1);
HXDLIN( 304)								int y1 = (_g - 1);
HXDLIN( 304)								{
HXLINE( 304)									int _g2 = 0;
HXDLIN( 304)									int _g3 = b->width;
HXDLIN( 304)									while((_g2 < _g3)){
HXLINE( 304)										_g2 = (_g2 + 1);
HXDLIN( 304)										int x1 = (_g2 - 1);
HXDLIN( 304)										{
HXLINE( 304)											w = (w + 1);
HXDLIN( 304)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 304)										{
HXLINE( 304)											w = (w + 1);
HXDLIN( 304)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 304)										{
HXLINE( 304)											w = (w + 1);
HXDLIN( 304)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 304)										{
HXLINE( 304)											w = (w + 1);
HXDLIN( 304)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 304)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 304)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 304)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 304)				{
HXLINE( 304)					a->width = width;
HXDLIN( 304)					a->height = height;
HXDLIN( 304)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 304)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 304)					{
HXLINE( 304)						int _g4 = 0;
HXDLIN( 304)						int _g5 = a->length;
HXDLIN( 304)						while((_g4 < _g5)){
HXLINE( 304)							_g4 = (_g4 + 1);
HXDLIN( 304)							int i = (_g4 - 1);
HXDLIN( 304)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 304)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 304)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 304)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 304)				{
HXLINE( 304)					b1->width = width;
HXDLIN( 304)					b1->height = height;
HXDLIN( 304)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 304)					int size = (b1->length * 4);
HXDLIN( 304)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 304)					{
HXLINE( 304)						int _g6 = 0;
HXDLIN( 304)						int _g7 = b1->length;
HXDLIN( 304)						while((_g6 < _g7)){
HXLINE( 304)							_g6 = (_g6 + 1);
HXDLIN( 304)							int i1 = (_g6 - 1);
HXDLIN( 304)							{
HXLINE( 304)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 304)								bool _hx_tmp1;
HXDLIN( 304)								if ((i1 >= 0)) {
HXLINE( 304)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 304)									_hx_tmp1 = false;
            								}
HXDLIN( 304)								if (_hx_tmp1) {
HXLINE( 304)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 304)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 304)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 304)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 304)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 304)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 304)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 304)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 304)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 304)				{
HXLINE( 304)					v->width = width;
HXDLIN( 304)					v->height = height;
HXDLIN( 304)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 304)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 304)					{
HXLINE( 304)						int _g8 = 0;
HXDLIN( 304)						int _g9 = v->length;
HXDLIN( 304)						while((_g8 < _g9)){
HXLINE( 304)							_g8 = (_g8 + 1);
HXDLIN( 304)							int i2 = (_g8 - 1);
HXDLIN( 304)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 304)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 304)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 304)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 304)				{
HXLINE( 304)					b2->width = width;
HXDLIN( 304)					b2->height = height;
HXDLIN( 304)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 304)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 304)					{
HXLINE( 304)						int len1 = b2->length;
HXDLIN( 304)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 304)						if (::hx::IsNull( d->head )) {
HXLINE( 304)							int _g10 = 0;
HXDLIN( 304)							int _g11 = len1;
HXDLIN( 304)							while((_g10 < _g11)){
HXLINE( 304)								_g10 = (_g10 + 1);
HXDLIN( 304)								int i3 = (_g10 - 1);
HXDLIN( 304)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 304)							int _g12 = 0;
HXDLIN( 304)							int _g13 = len1;
HXDLIN( 304)							while((_g12 < _g13)){
HXLINE( 304)								_g12 = (_g12 + 1);
HXDLIN( 304)								int i4 = (_g12 - 1);
HXDLIN( 304)								{
HXLINE( 304)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 304)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 304)									{
HXLINE( 304)										int _g14 = 0;
HXDLIN( 304)										int _g15 = i4;
HXDLIN( 304)										while((_g14 < _g15)){
HXLINE( 304)											_g14 = (_g14 + 1);
HXDLIN( 304)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE( 304)									if (::hx::IsNull( prev )) {
HXLINE( 304)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 304)										l = null();
            									}
            									else {
HXLINE( 304)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 304)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 304)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 304)		this2->image = _hx_tmp;
HXDLIN( 304)		this2->width = width;
HXDLIN( 304)		this2->height = height;
HXDLIN( 304)		this2->imageType = ( (int)(imageType) );
HXDLIN( 304)		 ::pi_xy::ImageStruct temp = this2;
HXLINE( 305)		temp->transparent = false;
HXLINE( 306)		{
HXLINE( 306)			 ::Dynamic dx1 = dx;
HXDLIN( 306)			 ::Dynamic dy1 = dy;
HXDLIN( 306)			 ::Dynamic fat1 = fat;
HXDLIN( 306)			 ::Dynamic tall1 = tall;
HXLINE( 311)			if (::hx::IsNull( tall1 )) {
HXLINE( 311)				tall1 = ((Float)-1.);
            			}
HXDLIN( 311)			if (::hx::IsNull( fat1 )) {
HXLINE( 311)				fat1 = ((Float)-1.);
            			}
HXLINE( 310)			if (::hx::IsNull( dy1 )) {
HXLINE( 310)				dy1 = ((Float)-1.);
            			}
HXDLIN( 310)			if (::hx::IsNull( dx1 )) {
HXLINE( 310)				dx1 = ((Float)-1.);
            			}
HXLINE( 306)			if (::hx::IsLess( dx1,((Float)0.) )) {
HXLINE( 306)				Float smallest;
HXDLIN( 306)				if ((hi < wid)) {
HXLINE( 306)					smallest = hi;
            				}
            				else {
HXLINE( 306)					smallest = wid;
            				}
HXDLIN( 306)				Float goldenRatio = ((Float)1.61803398875);
HXLINE( 106)				dx1 = (smallest / (goldenRatio + 2));
            			}
HXLINE( 306)			if (::hx::IsLess( dy1,((Float)0.) )) {
HXLINE( 108)				dy1 = dx1;
            			}
HXLINE( 306)			if (::hx::IsLess( fat1,((Float)0.) )) {
HXLINE( 109)				fat1 = (wid - (( (Float)(2) ) * ( (Float)(dx1) )));
            			}
HXLINE( 306)			if (::hx::IsLess( tall1,((Float)0.) )) {
HXLINE( 110)				tall1 = (hi - (( (Float)(2) ) * ( (Float)(dy1) )));
            			}
HXLINE( 306)			Float rightRadius = ((wid - ( (Float)(fat1) )) - ( (Float)(dx1) ));
HXDLIN( 306)			Float bottomRadius = ((hi - ( (Float)(tall1) )) - ( (Float)(dy1) ));
HXDLIN( 306)			Float farX = (dx1 + fat1);
HXDLIN( 306)			Float lowerY = (dy1 + tall1);
HXDLIN( 306)			{
HXLINE( 306)				 ::pi_xy::ImageStruct this4 = temp;
HXDLIN( 306)				Float cx = ( (Float)(dx1) );
HXDLIN( 306)				Float cy = ( (Float)(dy1) );
HXDLIN( 306)				Float rx = ( (Float)(dx1) );
HXDLIN( 306)				Float ry = ( (Float)(dy1) );
HXDLIN( 306)				{
HXLINE( 306)					 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 306)					if (::hx::IsNull( targetError )) {
HXLINE( 113)						targetError = ((Float)1.05);
            					}
HXLINE( 306)					Float rSmall;
HXDLIN( 306)					if ((rx > ry)) {
HXLINE( 306)						rSmall = ry;
            					}
            					else {
HXLINE( 306)						rSmall = rx;
            					}
HXDLIN( 306)					 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 306)					if (::hx::IsNull( targetE )) {
HXLINE(  20)						targetE = ((Float)1.05);
            					}
HXLINE( 306)					int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 306)					int noSides;
HXDLIN( 306)					if ((result < 12)) {
HXLINE( 306)						noSides = 12;
            					}
            					else {
HXLINE( 306)						if ((result > 500)) {
HXLINE( 306)							noSides = 500;
            						}
            						else {
HXLINE( 306)							noSides = result;
            						}
            					}
HXDLIN( 306)					int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 306)					Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 306)					Float omega = ::Math_obj::PI;
HXDLIN( 306)					int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 306)					Float lastX = ((Float)0.);
HXDLIN( 306)					Float lastY = ((Float)0.);
HXDLIN( 306)					{
HXLINE(  26)						lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)						lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            					}
HXLINE( 306)					{
HXLINE( 306)						int _g16 = 0;
HXDLIN( 306)						int _g17 = (quarter + 1);
HXDLIN( 306)						while((_g16 < _g17)){
HXLINE( 306)							_g16 = (_g16 + 1);
HXDLIN( 306)							int i6 = (_g16 - 1);
HXDLIN( 306)							Float nextX = (cx + (rx * ::Math_obj::cos((((( (Float)(i6) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 306)							Float nextY = (cy + (ry * ::Math_obj::sin((((( (Float)(i6) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 306)							{
HXLINE( 306)								 ::pi_xy::ImageStruct this5 = this4;
HXDLIN( 306)								bool hasHit = false;
HXDLIN( 306)								bool hasUndo = false;
HXDLIN( 306)								{
HXLINE( 306)									Float bx = lastX;
HXDLIN( 306)									Float by = lastY;
HXDLIN( 306)									Float cx1 = nextX;
HXDLIN( 306)									Float cy1 = nextY;
HXDLIN( 306)									bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 306)									if (!(adjustWinding)) {
HXLINE( 306)										Float bx_ = bx;
HXDLIN( 306)										Float by_ = by;
HXLINE(  25)										bx = cx1;
HXLINE(  26)										by = cy1;
HXLINE(  27)										cx1 = bx_;
HXLINE(  28)										cy1 = by_;
            									}
HXLINE( 306)									{
HXLINE( 306)										Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 306)										Float sx = (cy1 - cy);
HXDLIN( 306)										Float sy = (cx - cx1);
HXDLIN( 306)										Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 306)										Float tx = (cy - by);
HXDLIN( 306)										Float ty = (bx - cx);
HXDLIN( 306)										Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 306)										 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 306)										if ((cx > bx)) {
HXLINE( 306)											if ((cx > cx1)) {
HXLINE( 306)												int min;
HXDLIN( 306)												if ((bx > cx1)) {
HXLINE( 306)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE( 306)													min = ::Math_obj::floor(bx);
            												}
HXDLIN( 306)												int ii_min = min;
HXDLIN( 306)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 306)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            											}
            											else {
HXLINE( 306)												int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 306)												int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 306)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            											}
            										}
            										else {
HXLINE( 306)											if ((bx > cx1)) {
HXLINE( 306)												int min1;
HXDLIN( 306)												if ((cx > cx1)) {
HXLINE( 306)													min1 = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE( 306)													min1 = ::Math_obj::ceil(cx);
            												}
HXDLIN( 306)												int ii_min2 = min1;
HXDLIN( 306)												int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 306)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            											}
            											else {
HXLINE( 306)												int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 306)												int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 306)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            											}
            										}
HXDLIN( 306)										 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 306)										if ((cy > by)) {
HXLINE( 306)											if ((cy > cy1)) {
HXLINE( 306)												int min2;
HXDLIN( 306)												if ((by > cy1)) {
HXLINE( 306)													min2 = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE( 306)													min2 = ::Math_obj::floor(by);
            												}
HXDLIN( 306)												int ii_min4 = min2;
HXDLIN( 306)												int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 306)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            											}
            											else {
HXLINE( 306)												int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 306)												int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 306)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            											}
            										}
            										else {
HXLINE( 306)											if ((by > cy1)) {
HXLINE( 306)												int min3;
HXDLIN( 306)												if ((cy > cy1)) {
HXLINE( 306)													min3 = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE( 306)													min3 = ::Math_obj::ceil(cy);
            												}
HXDLIN( 306)												int ii_min6 = min3;
HXDLIN( 306)												int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 306)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            											}
            											else {
HXLINE( 306)												int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 306)												int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 306)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            											}
            										}
HXDLIN( 306)										 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 306)										if (hasUndo) {
HXLINE( 306)											int width1 = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 306)											int height1 = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 306)											 ::Dynamic imageType1 = null();
HXDLIN( 306)											 ::pi_xy::ImageStruct this6 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)											if (::hx::IsNull( imageType1 )) {
HXLINE(  54)												imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 306)											::Dynamic undoImage1;
HXDLIN( 306)											switch((int)(( (int)(imageType1) ))){
            												case (int)0: {
HXLINE( 306)													 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::BytesImg b3 = byt1;
HXDLIN( 306)													{
HXLINE( 306)														b3->width = width1;
HXDLIN( 306)														b3->height = height1;
HXDLIN( 306)														b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 306)														b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN( 306)														{
HXLINE( 306)															int len2 = b3->length;
HXDLIN( 306)															int w1 = 0;
HXDLIN( 306)															{
HXLINE( 306)																int _g18 = 0;
HXDLIN( 306)																int _g19 = b3->height;
HXDLIN( 306)																while((_g18 < _g19)){
HXLINE( 306)																	_g18 = (_g18 + 1);
HXDLIN( 306)																	int y2 = (_g18 - 1);
HXDLIN( 306)																	{
HXLINE( 306)																		int _g20 = 0;
HXDLIN( 306)																		int _g21 = b3->width;
HXDLIN( 306)																		while((_g20 < _g21)){
HXLINE( 306)																			_g20 = (_g20 + 1);
HXDLIN( 306)																			int x2 = (_g20 - 1);
HXDLIN( 306)																			{
HXLINE( 306)																				w1 = (w1 + 1);
HXDLIN( 306)																				b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w1 = (w1 + 1);
HXDLIN( 306)																				b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w1 = (w1 + 1);
HXDLIN( 306)																				b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w1 = (w1 + 1);
HXDLIN( 306)																				b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage1 = b3;
            												}
            												break;
            												case (int)1: {
HXLINE( 306)													 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN( 306)													{
HXLINE( 306)														a1->width = width1;
HXDLIN( 306)														a1->height = height1;
HXDLIN( 306)														a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)														a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 306)														{
HXLINE( 306)															int _g22 = 0;
HXDLIN( 306)															int _g23 = a1->length;
HXDLIN( 306)															while((_g22 < _g23)){
HXLINE( 306)																_g22 = (_g22 + 1);
HXDLIN( 306)																int i7 = (_g22 - 1);
HXDLIN( 306)																a1->data[i7] = 0;
            															}
            														}
            													}
HXDLIN( 306)													undoImage1 = a1;
            												}
            												break;
            												case (int)2: {
HXLINE( 306)													 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN( 306)													{
HXLINE( 306)														b4->width = width1;
HXDLIN( 306)														b4->height = height1;
HXDLIN( 306)														b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 306)														int size1 = (b4->length * 4);
HXDLIN( 306)														b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 306)														{
HXLINE( 306)															int _g24 = 0;
HXDLIN( 306)															int _g25 = b4->length;
HXDLIN( 306)															while((_g24 < _g25)){
HXLINE( 306)																_g24 = (_g24 + 1);
HXDLIN( 306)																int i8 = (_g24 - 1);
HXDLIN( 306)																{
HXLINE( 306)																	 ::haxe::io::ArrayBufferViewImpl this7 = b4->data;
HXDLIN( 306)																	bool undoImage2;
HXDLIN( 306)																	if ((i8 >= 0)) {
HXLINE( 306)																		undoImage2 = (i8 < (this7->byteLength >> 2));
            																	}
            																	else {
HXLINE( 306)																		undoImage2 = false;
            																	}
HXDLIN( 306)																	if (undoImage2) {
HXLINE( 306)																		 ::haxe::io::Bytes _this1 = this7->bytes;
HXDLIN( 306)																		int pos1 = ((i8 << 2) + this7->byteOffset);
HXDLIN( 306)																		_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage1 = b4;
            												}
            												break;
            												case (int)3: {
HXLINE( 306)													 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN( 306)													{
HXLINE( 306)														v1->width = width1;
HXDLIN( 306)														v1->height = height1;
HXDLIN( 306)														v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 306)														v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 306)														{
HXLINE( 306)															int _g26 = 0;
HXDLIN( 306)															int _g27 = v1->length;
HXDLIN( 306)															while((_g26 < _g27)){
HXLINE( 306)																_g26 = (_g26 + 1);
HXDLIN( 306)																int i9 = (_g26 - 1);
HXDLIN( 306)																v1->data->__unsafe_set(i9,0);
            															}
            														}
            													}
HXDLIN( 306)													undoImage1 = v1;
            												}
            												break;
            												case (int)4: {
HXLINE( 306)													 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN( 306)													{
HXLINE( 306)														b5->width = width1;
HXDLIN( 306)														b5->height = height1;
HXDLIN( 306)														b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 306)														b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)														{
HXLINE( 306)															int len3 = b5->length;
HXDLIN( 306)															 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN( 306)															if (::hx::IsNull( d1->head )) {
HXLINE( 306)																int _g28 = 0;
HXDLIN( 306)																int _g29 = len3;
HXDLIN( 306)																while((_g28 < _g29)){
HXLINE( 306)																	_g28 = (_g28 + 1);
HXDLIN( 306)																	int i10 = (_g28 - 1);
HXDLIN( 306)																	d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            																}
            															}
            															else {
HXLINE( 306)																int _g30 = 0;
HXDLIN( 306)																int _g31 = len3;
HXDLIN( 306)																while((_g30 < _g31)){
HXLINE( 306)																	_g30 = (_g30 + 1);
HXDLIN( 306)																	int i11 = (_g30 - 1);
HXDLIN( 306)																	{
HXLINE( 306)																		 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN( 306)																		 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 306)																		{
HXLINE( 306)																			int _g32 = 0;
HXDLIN( 306)																			int _g33 = i11;
HXDLIN( 306)																			while((_g32 < _g33)){
HXLINE( 306)																				_g32 = (_g32 + 1);
HXDLIN( 306)																				int i12 = (_g32 - 1);
HXLINE( 345)																				prev1 = l1;
HXLINE( 346)																				l1 = l1->next;
            																			}
            																		}
HXLINE( 306)																		if (::hx::IsNull( prev1 )) {
HXLINE( 306)																			b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 306)																			l1 = null();
            																		}
            																		else {
HXLINE( 306)																			prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 306)																			l1 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage1 = b5;
            												}
            												break;
            											}
HXDLIN( 306)											this6->image = undoImage1;
HXDLIN( 306)											this6->width = width1;
HXDLIN( 306)											this6->height = height1;
HXDLIN( 306)											this6->imageType = ( (int)(imageType1) );
HXDLIN( 306)											undoImage = this6;
HXDLIN( 306)											{
HXLINE( 306)												int rectLeft = xIter3->start;
HXDLIN( 306)												int rectTop = yIter3->start;
HXDLIN( 306)												int rectRight = xIter3->max;
HXDLIN( 306)												bool forceClear = false;
HXDLIN( 306)												{
HXLINE( 306)													int _g34 = rectTop;
HXDLIN( 306)													int _g35 = yIter3->max;
HXDLIN( 306)													while((_g34 < _g35)){
HXLINE( 306)														_g34 = (_g34 + 1);
HXDLIN( 306)														int dy2 = (_g34 - 1);
HXDLIN( 306)														{
HXLINE( 306)															int _g36 = rectLeft;
HXDLIN( 306)															int _g37 = rectRight;
HXDLIN( 306)															while((_g36 < _g37)){
HXLINE( 306)																_g36 = (_g36 + 1);
HXDLIN( 306)																int dx2 = (_g36 - 1);
HXDLIN( 306)																::Dynamic this8 = this5->image;
HXDLIN( 306)																int index;
HXDLIN( 306)																if (this5->useVirtualPos) {
HXLINE( 306)																	index = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx2) - this5->virtualX));
            																}
            																else {
HXLINE( 306)																	index = ::Std_obj::_hx_int(( (Float)(((dy2 * this5->width) + dx2)) ));
            																}
HXDLIN( 306)																int c = ::iterMagic::Iimg_obj::get(this8,index);
HXDLIN( 306)																int col;
HXDLIN( 306)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE( 306)																	col = c;
            																}
HXDLIN( 306)																bool _hx_tmp2;
HXDLIN( 306)																if (this5->useMask) {
HXLINE( 306)																	_hx_tmp2 = ::hx::IsNotNull( this5->mask );
            																}
            																else {
HXLINE( 306)																	_hx_tmp2 = false;
            																}
HXDLIN( 306)																if (_hx_tmp2) {
HXLINE( 306)																	 ::pi_xy::ImageStruct this9 = this5->mask;
HXDLIN( 306)																	::Dynamic this10 = this9->image;
HXDLIN( 306)																	int index1;
HXDLIN( 306)																	if (this9->useVirtualPos) {
HXLINE( 306)																		index1 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this9->virtualY) * ( (Float)(this9->width) )) + dx2) - this9->virtualX));
            																	}
            																	else {
HXLINE( 306)																		index1 = ::Std_obj::_hx_int(( (Float)(((dy2 * this9->width) + dx2)) ));
            																	}
HXDLIN( 306)																	int c1 = ::iterMagic::Iimg_obj::get(this10,index1);
HXDLIN( 306)																	int v2;
HXDLIN( 306)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																		v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																	}
            																	else {
HXLINE( 306)																		v2 = c1;
            																	}
HXDLIN( 306)																	int maskPixel = v2;
HXDLIN( 306)																	int this11 = col;
HXDLIN( 306)																	if ((maskPixel == 0)) {
HXLINE( 306)																		col = this11;
            																	}
            																	else {
HXLINE( 306)																		Float m0;
HXDLIN( 306)																		int this12 = ((maskPixel >> 24) & 255);
HXDLIN( 306)																		if ((this12 == 0)) {
HXLINE( 306)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m0 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m1;
HXDLIN( 306)																		int this13 = ((maskPixel >> 16) & 255);
HXDLIN( 306)																		if ((this13 == 0)) {
HXLINE( 306)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m1 = (( (Float)(this13) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m2;
HXDLIN( 306)																		int this14 = ((maskPixel >> 8) & 255);
HXDLIN( 306)																		if ((this14 == 0)) {
HXLINE( 306)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m2 = (( (Float)(this14) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m3;
HXDLIN( 306)																		int this15 = (maskPixel & 255);
HXDLIN( 306)																		if ((this15 == 0)) {
HXLINE( 306)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m3 = (( (Float)(this15) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this11 >> 24) & 255)) )));
HXDLIN( 306)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this11 >> 16) & 255)) )));
HXDLIN( 306)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this11 >> 8) & 255)) )));
HXDLIN( 306)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this11 & 255)) )));
HXDLIN( 306)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 306)																if ((col != 0)) {
HXLINE( 306)																	int x3 = (dx2 - rectLeft);
HXDLIN( 306)																	int y3 = (dy2 - rectTop);
HXDLIN( 306)																	int c2 = col;
HXDLIN( 306)																	bool _hx_tmp3;
HXDLIN( 306)																	if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 306)																		_hx_tmp3 = undoImage->transparent;
            																	}
            																	else {
HXLINE( 306)																		_hx_tmp3 = false;
            																	}
HXDLIN( 306)																	if (_hx_tmp3) {
HXLINE( 306)																		int location;
HXDLIN( 306)																		if (undoImage->useVirtualPos) {
HXLINE( 306)																			location = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 306)																			location = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            																		}
HXDLIN( 306)																		int this16 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 306)																		int this17;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			this17 = ((((((this16 >> 24) & 255) << 24) | ((this16 & 255) << 16)) | (((this16 >> 8) & 255) << 8)) | ((this16 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			this17 = this16;
            																		}
HXDLIN( 306)																		Float a11;
HXDLIN( 306)																		int this18 = ((this17 >> 24) & 255);
HXDLIN( 306)																		if ((this18 == 0)) {
HXLINE( 306)																			a11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r1;
HXDLIN( 306)																		int this19 = ((this17 >> 16) & 255);
HXDLIN( 306)																		if ((this19 == 0)) {
HXLINE( 306)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r1 = (( (Float)(this19) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g1;
HXDLIN( 306)																		int this20 = ((this17 >> 8) & 255);
HXDLIN( 306)																		if ((this20 == 0)) {
HXLINE( 306)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g1 = (( (Float)(this20) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b11;
HXDLIN( 306)																		int this21 = (this17 & 255);
HXDLIN( 306)																		if ((this21 == 0)) {
HXLINE( 306)																			b11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b11 = (( (Float)(this21) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a2;
HXDLIN( 306)																		int this22 = ((col >> 24) & 255);
HXDLIN( 306)																		if ((this22 == 0)) {
HXLINE( 306)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a2 = (( (Float)(this22) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r2;
HXDLIN( 306)																		int this23 = ((col >> 16) & 255);
HXDLIN( 306)																		if ((this23 == 0)) {
HXLINE( 306)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r2 = (( (Float)(this23) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g2;
HXDLIN( 306)																		int this24 = ((col >> 8) & 255);
HXDLIN( 306)																		if ((this24 == 0)) {
HXLINE( 306)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g2 = (( (Float)(this24) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b21;
HXDLIN( 306)																		int this25 = (col & 255);
HXDLIN( 306)																		if ((this25 == 0)) {
HXLINE( 306)																			b21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b21 = (( (Float)(this25) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 306)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 306)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 306)																		int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 306)																		int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 306)																		int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN( 306)																		{
HXLINE( 306)																			int _hx_tmp4;
HXDLIN( 306)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																				_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE( 306)																				_hx_tmp4 = blended;
            																			}
HXDLIN( 306)																			::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp4);
            																		}
            																	}
            																	else {
HXLINE( 306)																		::Dynamic this26 = undoImage->image;
HXDLIN( 306)																		int index2;
HXDLIN( 306)																		if (undoImage->useVirtualPos) {
HXLINE( 306)																			index2 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index2 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            																		}
HXDLIN( 306)																		int _hx_tmp5;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			_hx_tmp5 = c2;
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this26,index2,_hx_tmp5);
            																	}
            																}
            																else {
HXLINE( 306)																	if (forceClear) {
HXLINE( 306)																		::Dynamic this27 = undoImage->image;
HXDLIN( 306)																		int x4 = (dx2 - rectLeft);
HXDLIN( 306)																		int y4 = (dy2 - rectTop);
HXDLIN( 306)																		int index3;
HXDLIN( 306)																		if (undoImage->useVirtualPos) {
HXLINE( 306)																			index3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x4) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index3 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x4)) ));
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this27,index3,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 306)										bool found = false;
HXDLIN( 306)										Float s = ((Float)0.);
HXDLIN( 306)										Float t = ((Float)0.);
HXDLIN( 306)										Float sxx = ((Float)0.);
HXDLIN( 306)										Float txx = ((Float)0.);
HXDLIN( 306)										{
HXLINE( 306)											int _g_min = xIter3->start;
HXDLIN( 306)											int _g_max = xIter3->max;
HXDLIN( 306)											while((_g_min < _g_max)){
HXLINE( 306)												_g_min = (_g_min + 1);
HXDLIN( 306)												int x5 = (_g_min - 1);
HXLINE(  60)												sxx = (sx * ( (Float)(x5) ));
HXLINE(  61)												txx = (tx * ( (Float)(x5) ));
HXLINE(  62)												found = false;
HXLINE( 306)												{
HXLINE( 306)													int _g_min1 = yIter3->start;
HXDLIN( 306)													int _g_max1 = yIter3->max;
HXDLIN( 306)													while((_g_min1 < _g_max1)){
HXLINE( 306)														_g_min1 = (_g_min1 + 1);
HXDLIN( 306)														int y5 = (_g_min1 - 1);
HXLINE(  64)														s = ((s0 + sxx) + (sy * ( (Float)(y5) )));
HXLINE(  65)														t = ((t0 + txx) + (ty * ( (Float)(y5) )));
HXLINE( 306)														bool _hx_tmp6;
HXDLIN( 306)														if (!((s <= 0))) {
HXLINE( 306)															_hx_tmp6 = (t <= 0);
            														}
            														else {
HXLINE( 306)															_hx_tmp6 = true;
            														}
HXDLIN( 306)														if (_hx_tmp6) {
HXLINE( 306)															if (found) {
HXLINE( 306)																goto _hx_goto_693;
            															}
            														}
            														else {
HXLINE( 306)															if (((s + t) < A)) {
HXLINE( 306)																{
HXLINE( 306)																	int c3 = colorA;
HXDLIN( 306)																	bool _hx_tmp7;
HXDLIN( 306)																	if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 306)																		_hx_tmp7 = this5->transparent;
            																	}
            																	else {
HXLINE( 306)																		_hx_tmp7 = false;
            																	}
HXDLIN( 306)																	if (_hx_tmp7) {
HXLINE( 306)																		int location1;
HXDLIN( 306)																		if (this5->useVirtualPos) {
HXLINE( 306)																			location1 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this5->virtualY) * ( (Float)(this5->width) )) + x5) - this5->virtualX));
            																		}
            																		else {
HXLINE( 306)																			location1 = ::Std_obj::_hx_int(( (Float)(((y5 * this5->width) + x5)) ));
            																		}
HXDLIN( 306)																		int this28 = ::iterMagic::Iimg_obj::get(this5->image,location1);
HXDLIN( 306)																		int this29;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			this29 = this28;
            																		}
HXDLIN( 306)																		Float a12;
HXDLIN( 306)																		int this30 = ((this29 >> 24) & 255);
HXDLIN( 306)																		if ((this30 == 0)) {
HXLINE( 306)																			a12 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r11;
HXDLIN( 306)																		int this31 = ((this29 >> 16) & 255);
HXDLIN( 306)																		if ((this31 == 0)) {
HXLINE( 306)																			r11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g11;
HXDLIN( 306)																		int this32 = ((this29 >> 8) & 255);
HXDLIN( 306)																		if ((this32 == 0)) {
HXLINE( 306)																			g11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b12;
HXDLIN( 306)																		int this33 = (this29 & 255);
HXDLIN( 306)																		if ((this33 == 0)) {
HXLINE( 306)																			b12 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a21;
HXDLIN( 306)																		int this34 = ((colorA >> 24) & 255);
HXDLIN( 306)																		if ((this34 == 0)) {
HXLINE( 306)																			a21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r21;
HXDLIN( 306)																		int this35 = ((colorA >> 16) & 255);
HXDLIN( 306)																		if ((this35 == 0)) {
HXLINE( 306)																			r21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g21;
HXDLIN( 306)																		int this36 = ((colorA >> 8) & 255);
HXDLIN( 306)																		if ((this36 == 0)) {
HXLINE( 306)																			g21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b22;
HXDLIN( 306)																		int this37 = (colorA & 255);
HXDLIN( 306)																		if ((this37 == 0)) {
HXLINE( 306)																			b22 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 306)																		int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 306)																		int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 306)																		int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 306)																		int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 306)																		int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN( 306)																		{
HXLINE( 306)																			int _hx_tmp8;
HXDLIN( 306)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																				_hx_tmp8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																			}
            																			else {
HXLINE( 306)																				_hx_tmp8 = blended1;
            																			}
HXDLIN( 306)																			::iterMagic::Iimg_obj::set(this5->image,location1,_hx_tmp8);
            																		}
            																	}
            																	else {
HXLINE( 306)																		::Dynamic this38 = this5->image;
HXDLIN( 306)																		int index4;
HXDLIN( 306)																		if (this5->useVirtualPos) {
HXLINE( 306)																			index4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this5->virtualY) * ( (Float)(this5->width) )) + x5) - this5->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index4 = ::Std_obj::_hx_int(( (Float)(((y5 * this5->width) + x5)) ));
            																		}
HXDLIN( 306)																		int _hx_tmp9;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			_hx_tmp9 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			_hx_tmp9 = c3;
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this38,index4,_hx_tmp9);
            																	}
            																}
HXLINE(  73)																found = true;
            															}
            															else {
HXLINE( 306)																if (found) {
HXLINE( 306)																	goto _hx_goto_693;
            																}
            															}
            														}
            													}
            													_hx_goto_693:;
            												}
            											}
            										}
HXDLIN( 306)										if ((hasHit == true)) {
HXLINE( 306)											 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 306)											if (hasUndo) {
HXLINE( 306)												v3->undoImage = undoImage;
HXDLIN( 306)												v3->undoX = xIter3->start;
HXDLIN( 306)												v3->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX = nextX;
HXLINE(  47)							lastY = nextY;
            						}
            					}
            				}
            			}
HXLINE( 306)			 ::pi_xy::ImageStruct this39 = temp;
HXDLIN( 306)			Float x6 = ( (Float)(dx1) );
HXDLIN( 306)			Float bx1 = (x6 + ( (Float)(fat1) ));
HXDLIN( 306)			Float cy2 = ( (Float)(dy1) );
HXDLIN( 306)			{
HXLINE( 306)				bool hasHit1 = true;
HXDLIN( 306)				{
HXLINE( 306)					{
HXLINE( 306)						bool hasUndo1 = false;
HXDLIN( 306)						int aA = ((colorC >> 24) & 255);
HXDLIN( 306)						int rA = ((colorC >> 16) & 255);
HXDLIN( 306)						int gA = ((colorC >> 8) & 255);
HXDLIN( 306)						int bA = (colorC & 255);
HXDLIN( 306)						int aB = ((colorA >> 24) & 255);
HXDLIN( 306)						int rB = ((colorA >> 16) & 255);
HXDLIN( 306)						int gB = ((colorA >> 8) & 255);
HXDLIN( 306)						int bB = (colorA & 255);
HXDLIN( 306)						int aC = ((colorA >> 24) & 255);
HXDLIN( 306)						int rC = ((colorA >> 16) & 255);
HXDLIN( 306)						int gC = ((colorA >> 8) & 255);
HXDLIN( 306)						int bC = (colorA & 255);
HXDLIN( 306)						Float bcx = (bx1 - x6);
HXDLIN( 306)						Float bcy = (( (Float)(0) ) - cy2);
HXDLIN( 306)						Float acx = (x6 - x6);
HXDLIN( 306)						Float acy = (( (Float)(0) ) - cy2);
HXDLIN( 306)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 306)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 306)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 306)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 306)						if ((x6 > bx1)) {
HXLINE( 306)							if ((x6 > x6)) {
HXLINE( 306)								int min4;
HXDLIN( 306)								if ((bx1 > x6)) {
HXLINE( 306)									min4 = ::Math_obj::floor(x6);
            								}
            								else {
HXLINE( 306)									min4 = ::Math_obj::floor(bx1);
            								}
HXDLIN( 306)								int ii_min8 = min4;
HXDLIN( 306)								int ii_max8 = ::Math_obj::ceil(x6);
HXDLIN( 306)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            							else {
HXLINE( 306)								int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 306)								int ii_max9 = ::Math_obj::ceil(x6);
HXDLIN( 306)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx1 > x6)) {
HXLINE( 306)								int min5;
HXDLIN( 306)								if ((x6 > x6)) {
HXLINE( 306)									min5 = ::Math_obj::floor(x6);
            								}
            								else {
HXLINE( 306)									min5 = ::Math_obj::ceil(x6);
            								}
HXDLIN( 306)								int ii_min10 = min5;
HXDLIN( 306)								int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 306)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            							else {
HXLINE( 306)								int ii_min11 = ::Math_obj::floor(x6);
HXDLIN( 306)								int ii_max11 = ::Math_obj::ceil(x6);
HXDLIN( 306)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 306)						if ((0 > cy2)) {
HXLINE( 306)							int min6;
HXDLIN( 306)							if ((0 > cy2)) {
HXLINE( 306)								min6 = ::Math_obj::floor(cy2);
            							}
            							else {
HXLINE( 306)								min6 = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN( 306)							int ii_min12 = min6;
HXDLIN( 306)							int ii_max12 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 306)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXLINE( 306)							int ii_min13 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN( 306)							int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 306)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 306)						if (hasUndo1) {
HXLINE( 306)							int width2 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 306)							int height2 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType2 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this40 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType2 )) {
HXLINE(  54)								imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage4;
HXDLIN( 306)							switch((int)(( (int)(imageType2) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b8 = byt2;
HXDLIN( 306)									{
HXLINE( 306)										b8->width = width2;
HXDLIN( 306)										b8->height = height2;
HXDLIN( 306)										b8->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 306)										b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len4 = b8->length;
HXDLIN( 306)											int w2 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g38 = 0;
HXDLIN( 306)												int _g39 = b8->height;
HXDLIN( 306)												while((_g38 < _g39)){
HXLINE( 306)													_g38 = (_g38 + 1);
HXDLIN( 306)													int y6 = (_g38 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g40 = 0;
HXDLIN( 306)														int _g41 = b8->width;
HXDLIN( 306)														while((_g40 < _g41)){
HXLINE( 306)															_g40 = (_g40 + 1);
HXDLIN( 306)															int x7 = (_g40 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w2 = (w2 + 1);
HXDLIN( 306)																b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w2 = (w2 + 1);
HXDLIN( 306)																b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w2 = (w2 + 1);
HXDLIN( 306)																b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w2 = (w2 + 1);
HXDLIN( 306)																b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage4 = b8;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a6 = arrI2;
HXDLIN( 306)									{
HXLINE( 306)										a6->width = width2;
HXDLIN( 306)										a6->height = height2;
HXDLIN( 306)										a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g42 = 0;
HXDLIN( 306)											int _g43 = a6->length;
HXDLIN( 306)											while((_g42 < _g43)){
HXLINE( 306)												_g42 = (_g42 + 1);
HXDLIN( 306)												int i13 = (_g42 - 1);
HXDLIN( 306)												a6->data[i13] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage4 = a6;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b9 = u32a2;
HXDLIN( 306)									{
HXLINE( 306)										b9->width = width2;
HXDLIN( 306)										b9->height = height2;
HXDLIN( 306)										b9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 306)										int size2 = (b9->length * 4);
HXDLIN( 306)										b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 306)										{
HXLINE( 306)											int _g44 = 0;
HXDLIN( 306)											int _g45 = b9->length;
HXDLIN( 306)											while((_g44 < _g45)){
HXLINE( 306)												_g44 = (_g44 + 1);
HXDLIN( 306)												int i14 = (_g44 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this41 = b9->data;
HXDLIN( 306)													bool undoImage5;
HXDLIN( 306)													if ((i14 >= 0)) {
HXLINE( 306)														undoImage5 = (i14 < (this41->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage5 = false;
            													}
HXDLIN( 306)													if (undoImage5) {
HXLINE( 306)														 ::haxe::io::Bytes _this2 = this41->bytes;
HXDLIN( 306)														int pos2 = ((i14 << 2) + this41->byteOffset);
HXDLIN( 306)														_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 306)														_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage4 = b9;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN( 306)									{
HXLINE( 306)										v4->width = width2;
HXDLIN( 306)										v4->height = height2;
HXDLIN( 306)										v4->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 306)										v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g46 = 0;
HXDLIN( 306)											int _g47 = v4->length;
HXDLIN( 306)											while((_g46 < _g47)){
HXLINE( 306)												_g46 = (_g46 + 1);
HXDLIN( 306)												int i15 = (_g46 - 1);
HXDLIN( 306)												v4->data->__unsafe_set(i15,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage4 = v4;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b10 = sInt2;
HXDLIN( 306)									{
HXLINE( 306)										b10->width = width2;
HXDLIN( 306)										b10->height = height2;
HXDLIN( 306)										b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 306)										b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len5 = b10->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d2 = b10->data;
HXDLIN( 306)											if (::hx::IsNull( d2->head )) {
HXLINE( 306)												int _g48 = 0;
HXDLIN( 306)												int _g49 = len5;
HXDLIN( 306)												while((_g48 < _g49)){
HXLINE( 306)													_g48 = (_g48 + 1);
HXDLIN( 306)													int i16 = (_g48 - 1);
HXDLIN( 306)													d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g50 = 0;
HXDLIN( 306)												int _g51 = len5;
HXDLIN( 306)												while((_g50 < _g51)){
HXLINE( 306)													_g50 = (_g50 + 1);
HXDLIN( 306)													int i17 = (_g50 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l2 = b10->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g52 = 0;
HXDLIN( 306)															int _g53 = i17;
HXDLIN( 306)															while((_g52 < _g53)){
HXLINE( 306)																_g52 = (_g52 + 1);
HXDLIN( 306)																int i18 = (_g52 - 1);
HXLINE( 345)																prev2 = l2;
HXLINE( 346)																l2 = l2->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev2 )) {
HXLINE( 306)															b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 306)															l2 = null();
            														}
            														else {
HXLINE( 306)															prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 306)															l2 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage4 = b10;
            								}
            								break;
            							}
HXDLIN( 306)							this40->image = undoImage4;
HXDLIN( 306)							this40->width = width2;
HXDLIN( 306)							this40->height = height2;
HXDLIN( 306)							this40->imageType = ( (int)(imageType2) );
HXDLIN( 306)							undoImage3 = this40;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft1 = xIter31->start;
HXDLIN( 306)								int rectTop1 = yIter31->start;
HXDLIN( 306)								int rectRight1 = xIter31->max;
HXDLIN( 306)								bool forceClear1 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g54 = rectTop1;
HXDLIN( 306)									int _g55 = yIter31->max;
HXDLIN( 306)									while((_g54 < _g55)){
HXLINE( 306)										_g54 = (_g54 + 1);
HXDLIN( 306)										int dy3 = (_g54 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g56 = rectLeft1;
HXDLIN( 306)											int _g57 = rectRight1;
HXDLIN( 306)											while((_g56 < _g57)){
HXLINE( 306)												_g56 = (_g56 + 1);
HXDLIN( 306)												int dx3 = (_g56 - 1);
HXDLIN( 306)												::Dynamic this42 = this39->image;
HXDLIN( 306)												int index5;
HXDLIN( 306)												if (this39->useVirtualPos) {
HXLINE( 306)													index5 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this39->virtualY) * ( (Float)(this39->width) )) + dx3) - this39->virtualX));
            												}
            												else {
HXLINE( 306)													index5 = ::Std_obj::_hx_int(( (Float)(((dy3 * this39->width) + dx3)) ));
            												}
HXDLIN( 306)												int c4 = ::iterMagic::Iimg_obj::get(this42,index5);
HXDLIN( 306)												int col1;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col1 = c4;
            												}
HXDLIN( 306)												bool _hx_tmp10;
HXDLIN( 306)												if (this39->useMask) {
HXLINE( 306)													_hx_tmp10 = ::hx::IsNotNull( this39->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp10 = false;
            												}
HXDLIN( 306)												if (_hx_tmp10) {
HXLINE( 306)													 ::pi_xy::ImageStruct this43 = this39->mask;
HXDLIN( 306)													::Dynamic this44 = this43->image;
HXDLIN( 306)													int index6;
HXDLIN( 306)													if (this43->useVirtualPos) {
HXLINE( 306)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this43->virtualY) * ( (Float)(this43->width) )) + dx3) - this43->virtualX));
            													}
            													else {
HXLINE( 306)														index6 = ::Std_obj::_hx_int(( (Float)(((dy3 * this43->width) + dx3)) ));
            													}
HXDLIN( 306)													int c5 = ::iterMagic::Iimg_obj::get(this44,index6);
HXDLIN( 306)													int v5;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v5 = c5;
            													}
HXDLIN( 306)													int maskPixel1 = v5;
HXDLIN( 306)													int this45 = col1;
HXDLIN( 306)													if ((maskPixel1 == 0)) {
HXLINE( 306)														col1 = this45;
            													}
            													else {
HXLINE( 306)														Float m01;
HXDLIN( 306)														int this46 = ((maskPixel1 >> 24) & 255);
HXDLIN( 306)														if ((this46 == 0)) {
HXLINE( 306)															m01 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m01 = (( (Float)(this46) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m11;
HXDLIN( 306)														int this47 = ((maskPixel1 >> 16) & 255);
HXDLIN( 306)														if ((this47 == 0)) {
HXLINE( 306)															m11 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m11 = (( (Float)(this47) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m21;
HXDLIN( 306)														int this48 = ((maskPixel1 >> 8) & 255);
HXDLIN( 306)														if ((this48 == 0)) {
HXLINE( 306)															m21 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m21 = (( (Float)(this48) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m31;
HXDLIN( 306)														int this49 = (maskPixel1 & 255);
HXDLIN( 306)														if ((this49 == 0)) {
HXLINE( 306)															m31 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m31 = (( (Float)(this49) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this45 >> 24) & 255)) )));
HXDLIN( 306)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this45 >> 16) & 255)) )));
HXDLIN( 306)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this45 >> 8) & 255)) )));
HXDLIN( 306)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this45 & 255)) )));
HXDLIN( 306)														col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col1 != 0)) {
HXLINE( 306)													int x8 = (dx3 - rectLeft1);
HXDLIN( 306)													int y7 = (dy3 - rectTop1);
HXDLIN( 306)													int c6 = col1;
HXDLIN( 306)													bool _hx_tmp11;
HXDLIN( 306)													if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp11 = undoImage3->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp11 = false;
            													}
HXDLIN( 306)													if (_hx_tmp11) {
HXLINE( 306)														int location2;
HXDLIN( 306)														if (undoImage3->useVirtualPos) {
HXLINE( 306)															location2 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 306)															location2 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x8)) ));
            														}
HXDLIN( 306)														int this50 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 306)														int this51;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this51 = ((((((this50 >> 24) & 255) << 24) | ((this50 & 255) << 16)) | (((this50 >> 8) & 255) << 8)) | ((this50 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this51 = this50;
            														}
HXDLIN( 306)														Float a13;
HXDLIN( 306)														int this52 = ((this51 >> 24) & 255);
HXDLIN( 306)														if ((this52 == 0)) {
HXLINE( 306)															a13 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a13 = (( (Float)(this52) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r12;
HXDLIN( 306)														int this53 = ((this51 >> 16) & 255);
HXDLIN( 306)														if ((this53 == 0)) {
HXLINE( 306)															r12 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r12 = (( (Float)(this53) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g12;
HXDLIN( 306)														int this54 = ((this51 >> 8) & 255);
HXDLIN( 306)														if ((this54 == 0)) {
HXLINE( 306)															g12 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g12 = (( (Float)(this54) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b13;
HXDLIN( 306)														int this55 = (this51 & 255);
HXDLIN( 306)														if ((this55 == 0)) {
HXLINE( 306)															b13 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b13 = (( (Float)(this55) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a22;
HXDLIN( 306)														int this56 = ((col1 >> 24) & 255);
HXDLIN( 306)														if ((this56 == 0)) {
HXLINE( 306)															a22 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a22 = (( (Float)(this56) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r22;
HXDLIN( 306)														int this57 = ((col1 >> 16) & 255);
HXDLIN( 306)														if ((this57 == 0)) {
HXLINE( 306)															r22 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r22 = (( (Float)(this57) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g22;
HXDLIN( 306)														int this58 = ((col1 >> 8) & 255);
HXDLIN( 306)														if ((this58 == 0)) {
HXLINE( 306)															g22 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g22 = (( (Float)(this58) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b23;
HXDLIN( 306)														int this59 = (col1 & 255);
HXDLIN( 306)														if ((this59 == 0)) {
HXLINE( 306)															b23 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b23 = (( (Float)(this59) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 306)														int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 306)														int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 306)														int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 306)														int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 306)														int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b14);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp12;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp12 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp12 = blended2;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp12);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this60 = undoImage3->image;
HXDLIN( 306)														int index7;
HXDLIN( 306)														if (undoImage3->useVirtualPos) {
HXLINE( 306)															index7 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 306)															index7 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x8)) ));
            														}
HXDLIN( 306)														int _hx_tmp13;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp13 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp13 = c6;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this60,index7,_hx_tmp13);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear1) {
HXLINE( 306)														::Dynamic this61 = undoImage3->image;
HXDLIN( 306)														int x9 = (dx3 - rectLeft1);
HXDLIN( 306)														int y8 = (dy3 - rectTop1);
HXDLIN( 306)														int index8;
HXDLIN( 306)														if (undoImage3->useVirtualPos) {
HXLINE( 306)															index8 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 306)															index8 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this61,index8,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min2 = xIter31->start;
HXDLIN( 306)							int _g_max2 = xIter31->max;
HXDLIN( 306)							while((_g_min2 < _g_max2)){
HXLINE( 306)								_g_min2 = (_g_min2 + 1);
HXDLIN( 306)								int px = (_g_min2 - 1);
HXDLIN( 306)								Float pcx = (( (Float)(px) ) - x6);
HXDLIN( 306)								{
HXLINE( 306)									int _g_min3 = yIter31->start;
HXDLIN( 306)									int _g_max3 = yIter31->max;
HXDLIN( 306)									while((_g_min3 < _g_max3)){
HXLINE( 306)										_g_min3 = (_g_min3 + 1);
HXDLIN( 306)										int py = (_g_min3 - 1);
HXDLIN( 306)										Float pcy = (( (Float)(py) ) - cy2);
HXDLIN( 306)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 306)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 306)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 306)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 306)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 306)										bool _hx_tmp14;
HXDLIN( 306)										bool _hx_tmp15;
HXDLIN( 306)										if ((ratioA >= 0)) {
HXLINE( 306)											_hx_tmp15 = (ratioB >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp15 = false;
            										}
HXDLIN( 306)										if (_hx_tmp15) {
HXLINE( 306)											_hx_tmp14 = (ratioC >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp14 = false;
            										}
HXDLIN( 306)										if (_hx_tmp14) {
HXLINE( 306)											int i19 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 306)											if ((i19 > 255)) {
HXLINE(  24)												i19 = 255;
            											}
HXLINE( 306)											if ((i19 < 0)) {
HXLINE(  25)												i19 = 0;
            											}
HXLINE( 306)											int a8 = i19;
HXDLIN( 306)											int i20 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 306)											if ((i20 > 255)) {
HXLINE(  24)												i20 = 255;
            											}
HXLINE( 306)											if ((i20 < 0)) {
HXLINE(  25)												i20 = 0;
            											}
HXLINE( 306)											int r5 = i20;
HXDLIN( 306)											int i21 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 306)											if ((i21 > 255)) {
HXLINE(  24)												i21 = 255;
            											}
HXLINE( 306)											if ((i21 < 0)) {
HXLINE(  25)												i21 = 0;
            											}
HXLINE( 306)											int g5 = i21;
HXDLIN( 306)											int i22 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 306)											if ((i22 > 255)) {
HXLINE(  24)												i22 = 255;
            											}
HXLINE( 306)											if ((i22 < 0)) {
HXLINE(  25)												i22 = 0;
            											}
HXLINE( 306)											int b15 = i22;
HXDLIN( 306)											{
HXLINE( 306)												int location3;
HXDLIN( 306)												if (this39->useVirtualPos) {
HXLINE( 306)													location3 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this39->virtualY) * ( (Float)(this39->width) )) + px) - this39->virtualX));
            												}
            												else {
HXLINE( 306)													location3 = ::Std_obj::_hx_int(( (Float)(((py * this39->width) + px)) ));
            												}
HXDLIN( 306)												bool _hx_tmp16;
HXDLIN( 306)												if (this39->transparent) {
HXLINE( 306)													_hx_tmp16 = (a8 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp16 = false;
            												}
HXDLIN( 306)												if (_hx_tmp16) {
HXLINE( 306)													int this62 = ::iterMagic::Iimg_obj::get(this39->image,location3);
HXDLIN( 306)													int old;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old = ((((((this62 >> 24) & 255) << 24) | ((this62 & 255) << 16)) | (((this62 >> 8) & 255) << 8)) | ((this62 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old = this62;
            													}
HXDLIN( 306)													int rhs = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b15);
HXDLIN( 306)													Float a14;
HXDLIN( 306)													int this63 = ((old >> 24) & 255);
HXDLIN( 306)													if ((this63 == 0)) {
HXLINE( 306)														a14 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a14 = (( (Float)(this63) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r13;
HXDLIN( 306)													int this64 = ((old >> 16) & 255);
HXDLIN( 306)													if ((this64 == 0)) {
HXLINE( 306)														r13 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g13;
HXDLIN( 306)													int this65 = ((old >> 8) & 255);
HXDLIN( 306)													if ((this65 == 0)) {
HXLINE( 306)														g13 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b16;
HXDLIN( 306)													int this66 = (old & 255);
HXDLIN( 306)													if ((this66 == 0)) {
HXLINE( 306)														b16 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b16 = (( (Float)(this66) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a23;
HXDLIN( 306)													int this67 = ((rhs >> 24) & 255);
HXDLIN( 306)													if ((this67 == 0)) {
HXLINE( 306)														a23 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r23;
HXDLIN( 306)													int this68 = ((rhs >> 16) & 255);
HXDLIN( 306)													if ((this68 == 0)) {
HXLINE( 306)														r23 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g23;
HXDLIN( 306)													int this69 = ((rhs >> 8) & 255);
HXDLIN( 306)													if ((this69 == 0)) {
HXLINE( 306)														g23 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b24;
HXDLIN( 306)													int this70 = (rhs & 255);
HXDLIN( 306)													if ((this70 == 0)) {
HXLINE( 306)														b24 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 306)													int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 306)													int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 306)													int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a33) + (b24 * a23))));
HXDLIN( 306)													int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 306)													int blended3 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b17);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp17;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp17 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp17 = blended3;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this39->image,location3,_hx_tmp17);
            													}
            												}
            												else {
HXLINE( 306)													int value;
HXDLIN( 306)													if (this39->isLittle) {
HXLINE( 306)														value = ((((a8 << 24) | (b15 << 16)) | (g5 << 8)) | r5);
            													}
            													else {
HXLINE( 306)														value = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b15);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this39->image,location3,value);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit1 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x6,( (Float)(0) ),bx1,( (Float)(0) ),x6,cy2,true);
HXDLIN( 306)							if (hasUndo1) {
HXLINE( 306)								v6->undoImage = undoImage3;
HXDLIN( 306)								v6->undoX = xIter31->start;
HXDLIN( 306)								v6->undoY = yIter31->start;
            							}
            						}
            					}
HXDLIN( 306)					{
HXLINE( 306)						bool hasHit2 = false;
HXDLIN( 306)						bool hasUndo2 = false;
HXDLIN( 306)						int aA1 = ((colorC >> 24) & 255);
HXDLIN( 306)						int rA1 = ((colorC >> 16) & 255);
HXDLIN( 306)						int gA1 = ((colorC >> 8) & 255);
HXDLIN( 306)						int bA1 = (colorC & 255);
HXDLIN( 306)						int aB1 = ((colorC >> 24) & 255);
HXDLIN( 306)						int rB1 = ((colorC >> 16) & 255);
HXDLIN( 306)						int gB1 = ((colorC >> 8) & 255);
HXDLIN( 306)						int bB1 = (colorC & 255);
HXDLIN( 306)						int aC1 = ((colorA >> 24) & 255);
HXDLIN( 306)						int rC1 = ((colorA >> 16) & 255);
HXDLIN( 306)						int gC1 = ((colorA >> 8) & 255);
HXDLIN( 306)						int bC1 = (colorA & 255);
HXDLIN( 306)						Float bcx1 = (bx1 - x6);
HXDLIN( 306)						Float bcy1 = (cy2 - cy2);
HXDLIN( 306)						Float acx1 = (bx1 - x6);
HXDLIN( 306)						Float acy1 = (( (Float)(0) ) - cy2);
HXDLIN( 306)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 306)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 306)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 306)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 306)						if ((bx1 > bx1)) {
HXLINE( 306)							if ((bx1 > x6)) {
HXLINE( 306)								int min7;
HXDLIN( 306)								if ((bx1 > x6)) {
HXLINE( 306)									min7 = ::Math_obj::floor(x6);
            								}
            								else {
HXLINE( 306)									min7 = ::Math_obj::floor(bx1);
            								}
HXDLIN( 306)								int ii_min14 = min7;
HXDLIN( 306)								int ii_max14 = ::Math_obj::ceil(bx1);
HXDLIN( 306)								xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            							else {
HXLINE( 306)								int ii_min15 = ::Math_obj::floor(bx1);
HXDLIN( 306)								int ii_max15 = ::Math_obj::ceil(x6);
HXDLIN( 306)								xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx1 > x6)) {
HXLINE( 306)								int min8;
HXDLIN( 306)								if ((bx1 > x6)) {
HXLINE( 306)									min8 = ::Math_obj::floor(x6);
            								}
            								else {
HXLINE( 306)									min8 = ::Math_obj::ceil(bx1);
            								}
HXDLIN( 306)								int ii_min16 = min8;
HXDLIN( 306)								int ii_max16 = ::Math_obj::ceil(bx1);
HXDLIN( 306)								xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            							}
            							else {
HXLINE( 306)								int ii_min17 = ::Math_obj::floor(bx1);
HXDLIN( 306)								int ii_max17 = ::Math_obj::ceil(x6);
HXDLIN( 306)								xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 306)						if ((0 > cy2)) {
HXLINE( 306)							if ((0 > cy2)) {
HXLINE( 306)								int min9;
HXDLIN( 306)								if ((cy2 > cy2)) {
HXLINE( 306)									min9 = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE( 306)									min9 = ::Math_obj::floor(cy2);
            								}
HXDLIN( 306)								int ii_min18 = min9;
HXDLIN( 306)								int ii_max18 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 306)								yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            							}
            							else {
HXLINE( 306)								int ii_min19 = ::Math_obj::floor(cy2);
HXDLIN( 306)								int ii_max19 = ::Math_obj::ceil(cy2);
HXDLIN( 306)								yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            							}
            						}
            						else {
HXLINE( 306)							if ((cy2 > cy2)) {
HXLINE( 306)								int min10;
HXDLIN( 306)								if ((0 > cy2)) {
HXLINE( 306)									min10 = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE( 306)									min10 = ::Math_obj::ceil(( (Float)(0) ));
            								}
HXDLIN( 306)								int ii_min20 = min10;
HXDLIN( 306)								int ii_max20 = ::Math_obj::ceil(cy2);
HXDLIN( 306)								yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            							}
            							else {
HXLINE( 306)								int ii_min21 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN( 306)								int ii_max21 = ::Math_obj::ceil(cy2);
HXDLIN( 306)								yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 306)						if (hasUndo2) {
HXLINE( 306)							int width3 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 306)							int height3 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType3 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this71 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType3 )) {
HXLINE(  54)								imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage7;
HXDLIN( 306)							switch((int)(( (int)(imageType3) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b18 = byt3;
HXDLIN( 306)									{
HXLINE( 306)										b18->width = width3;
HXDLIN( 306)										b18->height = height3;
HXDLIN( 306)										b18->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 306)										b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len6 = b18->length;
HXDLIN( 306)											int w3 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g58 = 0;
HXDLIN( 306)												int _g59 = b18->height;
HXDLIN( 306)												while((_g58 < _g59)){
HXLINE( 306)													_g58 = (_g58 + 1);
HXDLIN( 306)													int y9 = (_g58 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g60 = 0;
HXDLIN( 306)														int _g61 = b18->width;
HXDLIN( 306)														while((_g60 < _g61)){
HXLINE( 306)															_g60 = (_g60 + 1);
HXDLIN( 306)															int x10 = (_g60 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w3 = (w3 + 1);
HXDLIN( 306)																b18->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w3 = (w3 + 1);
HXDLIN( 306)																b18->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w3 = (w3 + 1);
HXDLIN( 306)																b18->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w3 = (w3 + 1);
HXDLIN( 306)																b18->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage7 = b18;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a10 = arrI3;
HXDLIN( 306)									{
HXLINE( 306)										a10->width = width3;
HXDLIN( 306)										a10->height = height3;
HXDLIN( 306)										a10->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a10->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g62 = 0;
HXDLIN( 306)											int _g63 = a10->length;
HXDLIN( 306)											while((_g62 < _g63)){
HXLINE( 306)												_g62 = (_g62 + 1);
HXDLIN( 306)												int i23 = (_g62 - 1);
HXDLIN( 306)												a10->data[i23] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage7 = a10;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b19 = u32a3;
HXDLIN( 306)									{
HXLINE( 306)										b19->width = width3;
HXDLIN( 306)										b19->height = height3;
HXDLIN( 306)										b19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 306)										int size3 = (b19->length * 4);
HXDLIN( 306)										b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 306)										{
HXLINE( 306)											int _g64 = 0;
HXDLIN( 306)											int _g65 = b19->length;
HXDLIN( 306)											while((_g64 < _g65)){
HXLINE( 306)												_g64 = (_g64 + 1);
HXDLIN( 306)												int i24 = (_g64 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this72 = b19->data;
HXDLIN( 306)													bool undoImage8;
HXDLIN( 306)													if ((i24 >= 0)) {
HXLINE( 306)														undoImage8 = (i24 < (this72->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage8 = false;
            													}
HXDLIN( 306)													if (undoImage8) {
HXLINE( 306)														 ::haxe::io::Bytes _this3 = this72->bytes;
HXDLIN( 306)														int pos3 = ((i24 << 2) + this72->byteOffset);
HXDLIN( 306)														_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 306)														_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage7 = b19;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v7 = vec3;
HXDLIN( 306)									{
HXLINE( 306)										v7->width = width3;
HXDLIN( 306)										v7->height = height3;
HXDLIN( 306)										v7->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 306)										v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g66 = 0;
HXDLIN( 306)											int _g67 = v7->length;
HXDLIN( 306)											while((_g66 < _g67)){
HXLINE( 306)												_g66 = (_g66 + 1);
HXDLIN( 306)												int i25 = (_g66 - 1);
HXDLIN( 306)												v7->data->__unsafe_set(i25,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage7 = v7;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b20 = sInt3;
HXDLIN( 306)									{
HXLINE( 306)										b20->width = width3;
HXDLIN( 306)										b20->height = height3;
HXDLIN( 306)										b20->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 306)										b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len7 = b20->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d3 = b20->data;
HXDLIN( 306)											if (::hx::IsNull( d3->head )) {
HXLINE( 306)												int _g68 = 0;
HXDLIN( 306)												int _g69 = len7;
HXDLIN( 306)												while((_g68 < _g69)){
HXLINE( 306)													_g68 = (_g68 + 1);
HXDLIN( 306)													int i26 = (_g68 - 1);
HXDLIN( 306)													d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g70 = 0;
HXDLIN( 306)												int _g71 = len7;
HXDLIN( 306)												while((_g70 < _g71)){
HXLINE( 306)													_g70 = (_g70 + 1);
HXDLIN( 306)													int i27 = (_g70 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l3 = b20->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g72 = 0;
HXDLIN( 306)															int _g73 = i27;
HXDLIN( 306)															while((_g72 < _g73)){
HXLINE( 306)																_g72 = (_g72 + 1);
HXDLIN( 306)																int i28 = (_g72 - 1);
HXLINE( 345)																prev3 = l3;
HXLINE( 346)																l3 = l3->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev3 )) {
HXLINE( 306)															b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 306)															l3 = null();
            														}
            														else {
HXLINE( 306)															prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 306)															l3 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage7 = b20;
            								}
            								break;
            							}
HXDLIN( 306)							this71->image = undoImage7;
HXDLIN( 306)							this71->width = width3;
HXDLIN( 306)							this71->height = height3;
HXDLIN( 306)							this71->imageType = ( (int)(imageType3) );
HXDLIN( 306)							undoImage6 = this71;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft2 = xIter32->start;
HXDLIN( 306)								int rectTop2 = yIter32->start;
HXDLIN( 306)								int rectRight2 = xIter32->max;
HXDLIN( 306)								bool forceClear2 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g74 = rectTop2;
HXDLIN( 306)									int _g75 = yIter32->max;
HXDLIN( 306)									while((_g74 < _g75)){
HXLINE( 306)										_g74 = (_g74 + 1);
HXDLIN( 306)										int dy4 = (_g74 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g76 = rectLeft2;
HXDLIN( 306)											int _g77 = rectRight2;
HXDLIN( 306)											while((_g76 < _g77)){
HXLINE( 306)												_g76 = (_g76 + 1);
HXDLIN( 306)												int dx4 = (_g76 - 1);
HXDLIN( 306)												::Dynamic this73 = this39->image;
HXDLIN( 306)												int index9;
HXDLIN( 306)												if (this39->useVirtualPos) {
HXLINE( 306)													index9 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this39->virtualY) * ( (Float)(this39->width) )) + dx4) - this39->virtualX));
            												}
            												else {
HXLINE( 306)													index9 = ::Std_obj::_hx_int(( (Float)(((dy4 * this39->width) + dx4)) ));
            												}
HXDLIN( 306)												int c7 = ::iterMagic::Iimg_obj::get(this73,index9);
HXDLIN( 306)												int col2;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col2 = c7;
            												}
HXDLIN( 306)												bool _hx_tmp18;
HXDLIN( 306)												if (this39->useMask) {
HXLINE( 306)													_hx_tmp18 = ::hx::IsNotNull( this39->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp18 = false;
            												}
HXDLIN( 306)												if (_hx_tmp18) {
HXLINE( 306)													 ::pi_xy::ImageStruct this74 = this39->mask;
HXDLIN( 306)													::Dynamic this75 = this74->image;
HXDLIN( 306)													int index10;
HXDLIN( 306)													if (this74->useVirtualPos) {
HXLINE( 306)														index10 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this74->virtualY) * ( (Float)(this74->width) )) + dx4) - this74->virtualX));
            													}
            													else {
HXLINE( 306)														index10 = ::Std_obj::_hx_int(( (Float)(((dy4 * this74->width) + dx4)) ));
            													}
HXDLIN( 306)													int c8 = ::iterMagic::Iimg_obj::get(this75,index10);
HXDLIN( 306)													int v8;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v8 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v8 = c8;
            													}
HXDLIN( 306)													int maskPixel2 = v8;
HXDLIN( 306)													int this76 = col2;
HXDLIN( 306)													if ((maskPixel2 == 0)) {
HXLINE( 306)														col2 = this76;
            													}
            													else {
HXLINE( 306)														Float m02;
HXDLIN( 306)														int this77 = ((maskPixel2 >> 24) & 255);
HXDLIN( 306)														if ((this77 == 0)) {
HXLINE( 306)															m02 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m02 = (( (Float)(this77) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m12;
HXDLIN( 306)														int this78 = ((maskPixel2 >> 16) & 255);
HXDLIN( 306)														if ((this78 == 0)) {
HXLINE( 306)															m12 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m12 = (( (Float)(this78) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m22;
HXDLIN( 306)														int this79 = ((maskPixel2 >> 8) & 255);
HXDLIN( 306)														if ((this79 == 0)) {
HXLINE( 306)															m22 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m22 = (( (Float)(this79) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m32;
HXDLIN( 306)														int this80 = (maskPixel2 & 255);
HXDLIN( 306)														if ((this80 == 0)) {
HXLINE( 306)															m32 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m32 = (( (Float)(this80) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this76 >> 24) & 255)) )));
HXDLIN( 306)														int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this76 >> 16) & 255)) )));
HXDLIN( 306)														int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this76 >> 8) & 255)) )));
HXDLIN( 306)														int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this76 & 255)) )));
HXDLIN( 306)														col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col2 != 0)) {
HXLINE( 306)													int x11 = (dx4 - rectLeft2);
HXDLIN( 306)													int y10 = (dy4 - rectTop2);
HXDLIN( 306)													int c9 = col2;
HXDLIN( 306)													bool _hx_tmp19;
HXDLIN( 306)													if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp19 = undoImage6->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp19 = false;
            													}
HXDLIN( 306)													if (_hx_tmp19) {
HXLINE( 306)														int location4;
HXDLIN( 306)														if (undoImage6->useVirtualPos) {
HXLINE( 306)															location4 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            														}
            														else {
HXLINE( 306)															location4 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x11)) ));
            														}
HXDLIN( 306)														int this81 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 306)														int this82;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this82 = ((((((this81 >> 24) & 255) << 24) | ((this81 & 255) << 16)) | (((this81 >> 8) & 255) << 8)) | ((this81 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this82 = this81;
            														}
HXDLIN( 306)														Float a15;
HXDLIN( 306)														int this83 = ((this82 >> 24) & 255);
HXDLIN( 306)														if ((this83 == 0)) {
HXLINE( 306)															a15 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a15 = (( (Float)(this83) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r14;
HXDLIN( 306)														int this84 = ((this82 >> 16) & 255);
HXDLIN( 306)														if ((this84 == 0)) {
HXLINE( 306)															r14 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r14 = (( (Float)(this84) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g14;
HXDLIN( 306)														int this85 = ((this82 >> 8) & 255);
HXDLIN( 306)														if ((this85 == 0)) {
HXLINE( 306)															g14 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g14 = (( (Float)(this85) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b110;
HXDLIN( 306)														int this86 = (this82 & 255);
HXDLIN( 306)														if ((this86 == 0)) {
HXLINE( 306)															b110 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b110 = (( (Float)(this86) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a24;
HXDLIN( 306)														int this87 = ((col2 >> 24) & 255);
HXDLIN( 306)														if ((this87 == 0)) {
HXLINE( 306)															a24 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a24 = (( (Float)(this87) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r24;
HXDLIN( 306)														int this88 = ((col2 >> 16) & 255);
HXDLIN( 306)														if ((this88 == 0)) {
HXLINE( 306)															r24 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r24 = (( (Float)(this88) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g24;
HXDLIN( 306)														int this89 = ((col2 >> 8) & 255);
HXDLIN( 306)														if ((this89 == 0)) {
HXLINE( 306)															g24 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g24 = (( (Float)(this89) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b25;
HXDLIN( 306)														int this90 = (col2 & 255);
HXDLIN( 306)														if ((this90 == 0)) {
HXLINE( 306)															b25 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b25 = (( (Float)(this90) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN( 306)														int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 306)														int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 306)														int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN( 306)														int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 306)														int blended4 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b26);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp20;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp20 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp20 = blended4;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp20);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this91 = undoImage6->image;
HXDLIN( 306)														int index11;
HXDLIN( 306)														if (undoImage6->useVirtualPos) {
HXLINE( 306)															index11 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            														}
            														else {
HXLINE( 306)															index11 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x11)) ));
            														}
HXDLIN( 306)														int _hx_tmp21;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp21 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp21 = c9;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this91,index11,_hx_tmp21);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear2) {
HXLINE( 306)														::Dynamic this92 = undoImage6->image;
HXDLIN( 306)														int x12 = (dx4 - rectLeft2);
HXDLIN( 306)														int y11 = (dy4 - rectTop2);
HXDLIN( 306)														int index12;
HXDLIN( 306)														if (undoImage6->useVirtualPos) {
HXLINE( 306)															index12 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x12) - undoImage6->virtualX));
            														}
            														else {
HXLINE( 306)															index12 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x12)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this92,index12,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min4 = xIter32->start;
HXDLIN( 306)							int _g_max4 = xIter32->max;
HXDLIN( 306)							while((_g_min4 < _g_max4)){
HXLINE( 306)								_g_min4 = (_g_min4 + 1);
HXDLIN( 306)								int px1 = (_g_min4 - 1);
HXDLIN( 306)								Float pcx1 = (( (Float)(px1) ) - x6);
HXDLIN( 306)								{
HXLINE( 306)									int _g_min5 = yIter32->start;
HXDLIN( 306)									int _g_max5 = yIter32->max;
HXDLIN( 306)									while((_g_min5 < _g_max5)){
HXLINE( 306)										_g_min5 = (_g_min5 + 1);
HXDLIN( 306)										int py1 = (_g_min5 - 1);
HXDLIN( 306)										Float pcy1 = (( (Float)(py1) ) - cy2);
HXDLIN( 306)										Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 306)										Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 306)										Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 306)										Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 306)										Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 306)										bool _hx_tmp22;
HXDLIN( 306)										bool _hx_tmp23;
HXDLIN( 306)										if ((ratioA1 >= 0)) {
HXLINE( 306)											_hx_tmp23 = (ratioB1 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp23 = false;
            										}
HXDLIN( 306)										if (_hx_tmp23) {
HXLINE( 306)											_hx_tmp22 = (ratioC1 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp22 = false;
            										}
HXDLIN( 306)										if (_hx_tmp22) {
HXLINE( 306)											int i29 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 306)											if ((i29 > 255)) {
HXLINE(  24)												i29 = 255;
            											}
HXLINE( 306)											if ((i29 < 0)) {
HXLINE(  25)												i29 = 0;
            											}
HXLINE( 306)											int a17 = i29;
HXDLIN( 306)											int i30 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 306)											if ((i30 > 255)) {
HXLINE(  24)												i30 = 255;
            											}
HXLINE( 306)											if ((i30 < 0)) {
HXLINE(  25)												i30 = 0;
            											}
HXLINE( 306)											int r8 = i30;
HXDLIN( 306)											int i31 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 306)											if ((i31 > 255)) {
HXLINE(  24)												i31 = 255;
            											}
HXLINE( 306)											if ((i31 < 0)) {
HXLINE(  25)												i31 = 0;
            											}
HXLINE( 306)											int g8 = i31;
HXDLIN( 306)											int i32 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 306)											if ((i32 > 255)) {
HXLINE(  24)												i32 = 255;
            											}
HXLINE( 306)											if ((i32 < 0)) {
HXLINE(  25)												i32 = 0;
            											}
HXLINE( 306)											int b27 = i32;
HXDLIN( 306)											{
HXLINE( 306)												int location5;
HXDLIN( 306)												if (this39->useVirtualPos) {
HXLINE( 306)													location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this39->virtualY) * ( (Float)(this39->width) )) + px1) - this39->virtualX));
            												}
            												else {
HXLINE( 306)													location5 = ::Std_obj::_hx_int(( (Float)(((py1 * this39->width) + px1)) ));
            												}
HXDLIN( 306)												bool _hx_tmp24;
HXDLIN( 306)												if (this39->transparent) {
HXLINE( 306)													_hx_tmp24 = (a17 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp24 = false;
            												}
HXDLIN( 306)												if (_hx_tmp24) {
HXLINE( 306)													int this93 = ::iterMagic::Iimg_obj::get(this39->image,location5);
HXDLIN( 306)													int old1;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old1 = ((((((this93 >> 24) & 255) << 24) | ((this93 & 255) << 16)) | (((this93 >> 8) & 255) << 8)) | ((this93 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old1 = this93;
            													}
HXDLIN( 306)													int rhs1 = ((((a17 << 24) | (r8 << 16)) | (g8 << 8)) | b27);
HXDLIN( 306)													Float a18;
HXDLIN( 306)													int this94 = ((old1 >> 24) & 255);
HXDLIN( 306)													if ((this94 == 0)) {
HXLINE( 306)														a18 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a18 = (( (Float)(this94) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r15;
HXDLIN( 306)													int this95 = ((old1 >> 16) & 255);
HXDLIN( 306)													if ((this95 == 0)) {
HXLINE( 306)														r15 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r15 = (( (Float)(this95) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g15;
HXDLIN( 306)													int this96 = ((old1 >> 8) & 255);
HXDLIN( 306)													if ((this96 == 0)) {
HXLINE( 306)														g15 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g15 = (( (Float)(this96) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b111;
HXDLIN( 306)													int this97 = (old1 & 255);
HXDLIN( 306)													if ((this97 == 0)) {
HXLINE( 306)														b111 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b111 = (( (Float)(this97) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a25;
HXDLIN( 306)													int this98 = ((rhs1 >> 24) & 255);
HXDLIN( 306)													if ((this98 == 0)) {
HXLINE( 306)														a25 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a25 = (( (Float)(this98) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r25;
HXDLIN( 306)													int this99 = ((rhs1 >> 16) & 255);
HXDLIN( 306)													if ((this99 == 0)) {
HXLINE( 306)														r25 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r25 = (( (Float)(this99) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g25;
HXDLIN( 306)													int this100 = ((rhs1 >> 8) & 255);
HXDLIN( 306)													if ((this100 == 0)) {
HXLINE( 306)														g25 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g25 = (( (Float)(this100) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b28;
HXDLIN( 306)													int this101 = (rhs1 & 255);
HXDLIN( 306)													if ((this101 == 0)) {
HXLINE( 306)														b28 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b28 = (( (Float)(this101) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a35 = (a18 * (( (Float)(1) ) - a25));
HXDLIN( 306)													int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 306)													int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 306)													int b29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b28 * a25))));
HXDLIN( 306)													int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 306)													int blended5 = ((((a19 << 24) | (r9 << 16)) | (g9 << 8)) | b29);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp25;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp25 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp25 = blended5;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this39->image,location5,_hx_tmp25);
            													}
            												}
            												else {
HXLINE( 306)													int value1;
HXDLIN( 306)													if (this39->isLittle) {
HXLINE( 306)														value1 = ((((a17 << 24) | (b27 << 16)) | (g8 << 8)) | r8);
            													}
            													else {
HXLINE( 306)														value1 = ((((a17 << 24) | (r8 << 16)) | (g8 << 8)) | b27);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this39->image,location5,value1);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit2 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v9 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx1,( (Float)(0) ),bx1,cy2,x6,cy2,true);
HXDLIN( 306)							if (hasUndo2) {
HXLINE( 306)								v9->undoImage = undoImage6;
HXDLIN( 306)								v9->undoX = xIter32->start;
HXDLIN( 306)								v9->undoY = yIter32->start;
            							}
            						}
            					}
HXDLIN( 306)					if ((hasHit1 == true)) {
HXLINE( 306)						 ::pi_xy::algo::HitQuad v10 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x6,( (Float)(0) ),bx1,( (Float)(0) ),bx1,cy2,x6,cy2,true);
            					}
            				}
            			}
HXDLIN( 306)			Float inlobj_ax = x6;
HXDLIN( 306)			int inlobj_ay = 0;
HXDLIN( 306)			Float inlobj_bx = bx1;
HXDLIN( 306)			int inlobj_y = 0;
HXDLIN( 306)			Float inlobj_cx = bx1;
HXDLIN( 306)			Float inlobj_cy = cy2;
HXDLIN( 306)			Float inlobj_x = x6;
HXDLIN( 306)			Float inlobj_dy = cy2;
HXDLIN( 306)			{
HXLINE( 306)				 ::pi_xy::ImageStruct this102 = temp;
HXDLIN( 306)				Float cy3 = ( (Float)(dy1) );
HXDLIN( 306)				Float ry1 = ( (Float)(dy1) );
HXDLIN( 306)				{
HXLINE( 306)					 ::Dynamic targetError1 = ((Float)1.05);
HXDLIN( 306)					if (::hx::IsNull( targetError1 )) {
HXLINE( 113)						targetError1 = ((Float)1.05);
            					}
HXLINE( 306)					Float rSmall1;
HXDLIN( 306)					if ((rightRadius > ry1)) {
HXLINE( 306)						rSmall1 = ry1;
            					}
            					else {
HXLINE( 306)						rSmall1 = rightRadius;
            					}
HXDLIN( 306)					 ::Dynamic targetE1 = ( (Float)(targetError1) );
HXDLIN( 306)					if (::hx::IsNull( targetE1 )) {
HXLINE(  20)						targetE1 = ((Float)1.05);
            					}
HXLINE( 306)					int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN( 306)					int noSides1;
HXDLIN( 306)					if ((result1 < 12)) {
HXLINE( 306)						noSides1 = 12;
            					}
            					else {
HXLINE( 306)						if ((result1 > 500)) {
HXLINE( 306)							noSides1 = 500;
            						}
            						else {
HXLINE( 306)							noSides1 = result1;
            						}
            					}
HXDLIN( 306)					int sides1 = (::Math_obj::ceil((( (Float)(noSides1) ) / ( (Float)(4) ))) * 4);
HXDLIN( 306)					Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 306)					Float omega1 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN( 306)					int quarter1 = ::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(4) )));
HXDLIN( 306)					Float lastX1 = ((Float)0.);
HXDLIN( 306)					Float lastY1 = ((Float)0.);
HXDLIN( 306)					{
HXLINE(  26)						lastX1 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides1) ) * theta1) + omega1))));
HXLINE(  27)						lastY1 = (cy3 + (ry1 * ::Math_obj::sin(((( (Float)(sides1) ) * theta1) + omega1))));
            					}
HXLINE( 306)					{
HXLINE( 306)						int _g78 = 0;
HXDLIN( 306)						int _g79 = (quarter1 + 1);
HXDLIN( 306)						while((_g78 < _g79)){
HXLINE( 306)							_g78 = (_g78 + 1);
HXDLIN( 306)							int i33 = (_g78 - 1);
HXDLIN( 306)							Float nextX1 = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i33) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN( 306)							Float nextY1 = (cy3 + (ry1 * ::Math_obj::sin((((( (Float)(i33) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN( 306)							{
HXLINE( 306)								 ::pi_xy::ImageStruct this103 = this102;
HXDLIN( 306)								bool hasHit3 = false;
HXDLIN( 306)								bool hasUndo3 = false;
HXDLIN( 306)								{
HXLINE( 306)									Float bx2 = lastX1;
HXDLIN( 306)									Float by1 = lastY1;
HXDLIN( 306)									Float cx2 = nextX1;
HXDLIN( 306)									Float cy4 = nextY1;
HXDLIN( 306)									bool adjustWinding1 = (((((farX * by1) - (bx2 * cy3)) + ((bx2 * cy4) - (cx2 * by1))) + ((cx2 * cy3) - (farX * cy4))) > 0);
HXDLIN( 306)									if (!(adjustWinding1)) {
HXLINE( 306)										Float bx_1 = bx2;
HXDLIN( 306)										Float by_1 = by1;
HXLINE(  25)										bx2 = cx2;
HXLINE(  26)										by1 = cy4;
HXLINE(  27)										cx2 = bx_1;
HXLINE(  28)										cy4 = by_1;
            									}
HXLINE( 306)									{
HXLINE( 306)										Float s01 = ((cy3 * cx2) - (farX * cy4));
HXDLIN( 306)										Float sx1 = (cy4 - cy3);
HXDLIN( 306)										Float sy1 = (farX - cx2);
HXDLIN( 306)										Float t01 = ((farX * by1) - (cy3 * bx2));
HXDLIN( 306)										Float tx1 = (cy3 - by1);
HXDLIN( 306)										Float ty1 = (bx2 - farX);
HXDLIN( 306)										Float A1 = ((((-(by1) * cx2) + (cy3 * (-(bx2) + cx2))) + (farX * (by1 - cy4))) + (bx2 * cy4));
HXDLIN( 306)										 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 306)										if ((farX > bx2)) {
HXLINE( 306)											if ((farX > cx2)) {
HXLINE( 306)												int min11;
HXDLIN( 306)												if ((bx2 > cx2)) {
HXLINE( 306)													min11 = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE( 306)													min11 = ::Math_obj::floor(bx2);
            												}
HXDLIN( 306)												int ii_min22 = min11;
HXDLIN( 306)												int ii_max22 = ::Math_obj::ceil(farX);
HXDLIN( 306)												xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            											}
            											else {
HXLINE( 306)												int ii_min23 = ::Math_obj::floor(bx2);
HXDLIN( 306)												int ii_max23 = ::Math_obj::ceil(cx2);
HXDLIN( 306)												xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            											}
            										}
            										else {
HXLINE( 306)											if ((bx2 > cx2)) {
HXLINE( 306)												int min12;
HXDLIN( 306)												if ((farX > cx2)) {
HXLINE( 306)													min12 = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE( 306)													min12 = ::Math_obj::ceil(farX);
            												}
HXDLIN( 306)												int ii_min24 = min12;
HXDLIN( 306)												int ii_max24 = ::Math_obj::ceil(bx2);
HXDLIN( 306)												xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            											}
            											else {
HXLINE( 306)												int ii_min25 = ::Math_obj::floor(farX);
HXDLIN( 306)												int ii_max25 = ::Math_obj::ceil(cx2);
HXDLIN( 306)												xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            											}
            										}
HXDLIN( 306)										 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 306)										if ((cy3 > by1)) {
HXLINE( 306)											if ((cy3 > cy4)) {
HXLINE( 306)												int min13;
HXDLIN( 306)												if ((by1 > cy4)) {
HXLINE( 306)													min13 = ::Math_obj::floor(cy4);
            												}
            												else {
HXLINE( 306)													min13 = ::Math_obj::floor(by1);
            												}
HXDLIN( 306)												int ii_min26 = min13;
HXDLIN( 306)												int ii_max26 = ::Math_obj::ceil(cy3);
HXDLIN( 306)												yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            											}
            											else {
HXLINE( 306)												int ii_min27 = ::Math_obj::floor(by1);
HXDLIN( 306)												int ii_max27 = ::Math_obj::ceil(cy4);
HXDLIN( 306)												yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            											}
            										}
            										else {
HXLINE( 306)											if ((by1 > cy4)) {
HXLINE( 306)												int min14;
HXDLIN( 306)												if ((cy3 > cy4)) {
HXLINE( 306)													min14 = ::Math_obj::floor(cy4);
            												}
            												else {
HXLINE( 306)													min14 = ::Math_obj::ceil(cy3);
            												}
HXDLIN( 306)												int ii_min28 = min14;
HXDLIN( 306)												int ii_max28 = ::Math_obj::ceil(by1);
HXDLIN( 306)												yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            											}
            											else {
HXLINE( 306)												int ii_min29 = ::Math_obj::floor(cy3);
HXDLIN( 306)												int ii_max29 = ::Math_obj::ceil(cy4);
HXDLIN( 306)												yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            											}
            										}
HXDLIN( 306)										 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 306)										if (hasUndo3) {
HXLINE( 306)											int width4 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 306)											int height4 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 306)											 ::Dynamic imageType4 = null();
HXDLIN( 306)											 ::pi_xy::ImageStruct this104 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)											if (::hx::IsNull( imageType4 )) {
HXLINE(  54)												imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 306)											::Dynamic undoImage10;
HXDLIN( 306)											switch((int)(( (int)(imageType4) ))){
            												case (int)0: {
HXLINE( 306)													 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::BytesImg b30 = byt4;
HXDLIN( 306)													{
HXLINE( 306)														b30->width = width4;
HXDLIN( 306)														b30->height = height4;
HXDLIN( 306)														b30->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 306)														b30->data = ::haxe::io::Bytes_obj::alloc((b30->length * 4));
HXDLIN( 306)														{
HXLINE( 306)															int len8 = b30->length;
HXDLIN( 306)															int w4 = 0;
HXDLIN( 306)															{
HXLINE( 306)																int _g80 = 0;
HXDLIN( 306)																int _g81 = b30->height;
HXDLIN( 306)																while((_g80 < _g81)){
HXLINE( 306)																	_g80 = (_g80 + 1);
HXDLIN( 306)																	int y12 = (_g80 - 1);
HXDLIN( 306)																	{
HXLINE( 306)																		int _g82 = 0;
HXDLIN( 306)																		int _g83 = b30->width;
HXDLIN( 306)																		while((_g82 < _g83)){
HXLINE( 306)																			_g82 = (_g82 + 1);
HXDLIN( 306)																			int x13 = (_g82 - 1);
HXDLIN( 306)																			{
HXLINE( 306)																				w4 = (w4 + 1);
HXDLIN( 306)																				b30->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w4 = (w4 + 1);
HXDLIN( 306)																				b30->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w4 = (w4 + 1);
HXDLIN( 306)																				b30->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w4 = (w4 + 1);
HXDLIN( 306)																				b30->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage10 = b30;
            												}
            												break;
            												case (int)1: {
HXLINE( 306)													 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::ArrIntImg a20 = arrI4;
HXDLIN( 306)													{
HXLINE( 306)														a20->width = width4;
HXDLIN( 306)														a20->height = height4;
HXDLIN( 306)														a20->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)														a20->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 306)														{
HXLINE( 306)															int _g84 = 0;
HXDLIN( 306)															int _g85 = a20->length;
HXDLIN( 306)															while((_g84 < _g85)){
HXLINE( 306)																_g84 = (_g84 + 1);
HXDLIN( 306)																int i34 = (_g84 - 1);
HXDLIN( 306)																a20->data[i34] = 0;
            															}
            														}
            													}
HXDLIN( 306)													undoImage10 = a20;
            												}
            												break;
            												case (int)2: {
HXLINE( 306)													 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::U32ArrImg b31 = u32a4;
HXDLIN( 306)													{
HXLINE( 306)														b31->width = width4;
HXDLIN( 306)														b31->height = height4;
HXDLIN( 306)														b31->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 306)														int size4 = (b31->length * 4);
HXDLIN( 306)														b31->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 306)														{
HXLINE( 306)															int _g86 = 0;
HXDLIN( 306)															int _g87 = b31->length;
HXDLIN( 306)															while((_g86 < _g87)){
HXLINE( 306)																_g86 = (_g86 + 1);
HXDLIN( 306)																int i35 = (_g86 - 1);
HXDLIN( 306)																{
HXLINE( 306)																	 ::haxe::io::ArrayBufferViewImpl this105 = b31->data;
HXDLIN( 306)																	bool undoImage11;
HXDLIN( 306)																	if ((i35 >= 0)) {
HXLINE( 306)																		undoImage11 = (i35 < (this105->byteLength >> 2));
            																	}
            																	else {
HXLINE( 306)																		undoImage11 = false;
            																	}
HXDLIN( 306)																	if (undoImage11) {
HXLINE( 306)																		 ::haxe::io::Bytes _this4 = this105->bytes;
HXDLIN( 306)																		int pos4 = ((i35 << 2) + this105->byteOffset);
HXDLIN( 306)																		_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage10 = b31;
            												}
            												break;
            												case (int)3: {
HXLINE( 306)													 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::VecIntImg v11 = vec4;
HXDLIN( 306)													{
HXLINE( 306)														v11->width = width4;
HXDLIN( 306)														v11->height = height4;
HXDLIN( 306)														v11->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 306)														v11->data = ::Array_obj< int >::__new(v11->length);
HXDLIN( 306)														{
HXLINE( 306)															int _g88 = 0;
HXDLIN( 306)															int _g89 = v11->length;
HXDLIN( 306)															while((_g88 < _g89)){
HXLINE( 306)																_g88 = (_g88 + 1);
HXDLIN( 306)																int i36 = (_g88 - 1);
HXDLIN( 306)																v11->data->__unsafe_set(i36,0);
            															}
            														}
            													}
HXDLIN( 306)													undoImage10 = v11;
            												}
            												break;
            												case (int)4: {
HXLINE( 306)													 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::StackIntImg b32 = sInt4;
HXDLIN( 306)													{
HXLINE( 306)														b32->width = width4;
HXDLIN( 306)														b32->height = height4;
HXDLIN( 306)														b32->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 306)														b32->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)														{
HXLINE( 306)															int len9 = b32->length;
HXDLIN( 306)															 ::haxe::ds::GenericStack_Int d4 = b32->data;
HXDLIN( 306)															if (::hx::IsNull( d4->head )) {
HXLINE( 306)																int _g90 = 0;
HXDLIN( 306)																int _g91 = len9;
HXDLIN( 306)																while((_g90 < _g91)){
HXLINE( 306)																	_g90 = (_g90 + 1);
HXDLIN( 306)																	int i37 = (_g90 - 1);
HXDLIN( 306)																	d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            																}
            															}
            															else {
HXLINE( 306)																int _g92 = 0;
HXDLIN( 306)																int _g93 = len9;
HXDLIN( 306)																while((_g92 < _g93)){
HXLINE( 306)																	_g92 = (_g92 + 1);
HXDLIN( 306)																	int i38 = (_g92 - 1);
HXDLIN( 306)																	{
HXLINE( 306)																		 ::haxe::ds::GenericCell_Int l4 = b32->data->head;
HXDLIN( 306)																		 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 306)																		{
HXLINE( 306)																			int _g94 = 0;
HXDLIN( 306)																			int _g95 = i38;
HXDLIN( 306)																			while((_g94 < _g95)){
HXLINE( 306)																				_g94 = (_g94 + 1);
HXDLIN( 306)																				int i39 = (_g94 - 1);
HXLINE( 345)																				prev4 = l4;
HXLINE( 346)																				l4 = l4->next;
            																			}
            																		}
HXLINE( 306)																		if (::hx::IsNull( prev4 )) {
HXLINE( 306)																			b32->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 306)																			l4 = null();
            																		}
            																		else {
HXLINE( 306)																			prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 306)																			l4 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage10 = b32;
            												}
            												break;
            											}
HXDLIN( 306)											this104->image = undoImage10;
HXDLIN( 306)											this104->width = width4;
HXDLIN( 306)											this104->height = height4;
HXDLIN( 306)											this104->imageType = ( (int)(imageType4) );
HXDLIN( 306)											undoImage9 = this104;
HXDLIN( 306)											{
HXLINE( 306)												int rectLeft3 = xIter33->start;
HXDLIN( 306)												int rectTop3 = yIter33->start;
HXDLIN( 306)												int rectRight3 = xIter33->max;
HXDLIN( 306)												bool forceClear3 = false;
HXDLIN( 306)												{
HXLINE( 306)													int _g96 = rectTop3;
HXDLIN( 306)													int _g97 = yIter33->max;
HXDLIN( 306)													while((_g96 < _g97)){
HXLINE( 306)														_g96 = (_g96 + 1);
HXDLIN( 306)														int dy5 = (_g96 - 1);
HXDLIN( 306)														{
HXLINE( 306)															int _g98 = rectLeft3;
HXDLIN( 306)															int _g99 = rectRight3;
HXDLIN( 306)															while((_g98 < _g99)){
HXLINE( 306)																_g98 = (_g98 + 1);
HXDLIN( 306)																int dx5 = (_g98 - 1);
HXDLIN( 306)																::Dynamic this106 = this103->image;
HXDLIN( 306)																int index13;
HXDLIN( 306)																if (this103->useVirtualPos) {
HXLINE( 306)																	index13 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this103->virtualY) * ( (Float)(this103->width) )) + dx5) - this103->virtualX));
            																}
            																else {
HXLINE( 306)																	index13 = ::Std_obj::_hx_int(( (Float)(((dy5 * this103->width) + dx5)) ));
            																}
HXDLIN( 306)																int c10 = ::iterMagic::Iimg_obj::get(this106,index13);
HXDLIN( 306)																int col3;
HXDLIN( 306)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																	col3 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            																}
            																else {
HXLINE( 306)																	col3 = c10;
            																}
HXDLIN( 306)																bool _hx_tmp26;
HXDLIN( 306)																if (this103->useMask) {
HXLINE( 306)																	_hx_tmp26 = ::hx::IsNotNull( this103->mask );
            																}
            																else {
HXLINE( 306)																	_hx_tmp26 = false;
            																}
HXDLIN( 306)																if (_hx_tmp26) {
HXLINE( 306)																	 ::pi_xy::ImageStruct this107 = this103->mask;
HXDLIN( 306)																	::Dynamic this108 = this107->image;
HXDLIN( 306)																	int index14;
HXDLIN( 306)																	if (this107->useVirtualPos) {
HXLINE( 306)																		index14 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this107->virtualY) * ( (Float)(this107->width) )) + dx5) - this107->virtualX));
            																	}
            																	else {
HXLINE( 306)																		index14 = ::Std_obj::_hx_int(( (Float)(((dy5 * this107->width) + dx5)) ));
            																	}
HXDLIN( 306)																	int c11 = ::iterMagic::Iimg_obj::get(this108,index14);
HXDLIN( 306)																	int v12;
HXDLIN( 306)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																		v12 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            																	}
            																	else {
HXLINE( 306)																		v12 = c11;
            																	}
HXDLIN( 306)																	int maskPixel3 = v12;
HXDLIN( 306)																	int this109 = col3;
HXDLIN( 306)																	if ((maskPixel3 == 0)) {
HXLINE( 306)																		col3 = this109;
            																	}
            																	else {
HXLINE( 306)																		Float m03;
HXDLIN( 306)																		int this110 = ((maskPixel3 >> 24) & 255);
HXDLIN( 306)																		if ((this110 == 0)) {
HXLINE( 306)																			m03 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m03 = (( (Float)(this110) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m13;
HXDLIN( 306)																		int this111 = ((maskPixel3 >> 16) & 255);
HXDLIN( 306)																		if ((this111 == 0)) {
HXLINE( 306)																			m13 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m13 = (( (Float)(this111) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m23;
HXDLIN( 306)																		int this112 = ((maskPixel3 >> 8) & 255);
HXDLIN( 306)																		if ((this112 == 0)) {
HXLINE( 306)																			m23 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m23 = (( (Float)(this112) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m33;
HXDLIN( 306)																		int this113 = (maskPixel3 & 255);
HXDLIN( 306)																		if ((this113 == 0)) {
HXLINE( 306)																			m33 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m33 = (( (Float)(this113) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this109 >> 24) & 255)) )));
HXDLIN( 306)																		int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this109 >> 16) & 255)) )));
HXDLIN( 306)																		int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this109 >> 8) & 255)) )));
HXDLIN( 306)																		int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this109 & 255)) )));
HXDLIN( 306)																		col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 306)																if ((col3 != 0)) {
HXLINE( 306)																	int x14 = (dx5 - rectLeft3);
HXDLIN( 306)																	int y13 = (dy5 - rectTop3);
HXDLIN( 306)																	int c12 = col3;
HXDLIN( 306)																	bool _hx_tmp27;
HXDLIN( 306)																	if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 306)																		_hx_tmp27 = undoImage9->transparent;
            																	}
            																	else {
HXLINE( 306)																		_hx_tmp27 = false;
            																	}
HXDLIN( 306)																	if (_hx_tmp27) {
HXLINE( 306)																		int location6;
HXDLIN( 306)																		if (undoImage9->useVirtualPos) {
HXLINE( 306)																			location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            																		}
            																		else {
HXLINE( 306)																			location6 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x14)) ));
            																		}
HXDLIN( 306)																		int this114 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 306)																		int this115;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			this115 = ((((((this114 >> 24) & 255) << 24) | ((this114 & 255) << 16)) | (((this114 >> 8) & 255) << 8)) | ((this114 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			this115 = this114;
            																		}
HXDLIN( 306)																		Float a110;
HXDLIN( 306)																		int this116 = ((this115 >> 24) & 255);
HXDLIN( 306)																		if ((this116 == 0)) {
HXLINE( 306)																			a110 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a110 = (( (Float)(this116) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r16;
HXDLIN( 306)																		int this117 = ((this115 >> 16) & 255);
HXDLIN( 306)																		if ((this117 == 0)) {
HXLINE( 306)																			r16 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r16 = (( (Float)(this117) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g16;
HXDLIN( 306)																		int this118 = ((this115 >> 8) & 255);
HXDLIN( 306)																		if ((this118 == 0)) {
HXLINE( 306)																			g16 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g16 = (( (Float)(this118) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b112;
HXDLIN( 306)																		int this119 = (this115 & 255);
HXDLIN( 306)																		if ((this119 == 0)) {
HXLINE( 306)																			b112 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b112 = (( (Float)(this119) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a26;
HXDLIN( 306)																		int this120 = ((col3 >> 24) & 255);
HXDLIN( 306)																		if ((this120 == 0)) {
HXLINE( 306)																			a26 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a26 = (( (Float)(this120) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r26;
HXDLIN( 306)																		int this121 = ((col3 >> 16) & 255);
HXDLIN( 306)																		if ((this121 == 0)) {
HXLINE( 306)																			r26 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r26 = (( (Float)(this121) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g26;
HXDLIN( 306)																		int this122 = ((col3 >> 8) & 255);
HXDLIN( 306)																		if ((this122 == 0)) {
HXLINE( 306)																			g26 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g26 = (( (Float)(this122) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b210;
HXDLIN( 306)																		int this123 = (col3 & 255);
HXDLIN( 306)																		if ((this123 == 0)) {
HXLINE( 306)																			b210 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b210 = (( (Float)(this123) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a36 = (a110 * (( (Float)(1) ) - a26));
HXDLIN( 306)																		int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 306)																		int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 306)																		int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a26))));
HXDLIN( 306)																		int a27 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 306)																		int blended6 = ((((a27 << 24) | (r10 << 16)) | (g10 << 8)) | b33);
HXDLIN( 306)																		{
HXLINE( 306)																			int _hx_tmp28;
HXDLIN( 306)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																				_hx_tmp28 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            																			}
            																			else {
HXLINE( 306)																				_hx_tmp28 = blended6;
            																			}
HXDLIN( 306)																			::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp28);
            																		}
            																	}
            																	else {
HXLINE( 306)																		::Dynamic this124 = undoImage9->image;
HXDLIN( 306)																		int index15;
HXDLIN( 306)																		if (undoImage9->useVirtualPos) {
HXLINE( 306)																			index15 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index15 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x14)) ));
            																		}
HXDLIN( 306)																		int _hx_tmp29;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			_hx_tmp29 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			_hx_tmp29 = c12;
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this124,index15,_hx_tmp29);
            																	}
            																}
            																else {
HXLINE( 306)																	if (forceClear3) {
HXLINE( 306)																		::Dynamic this125 = undoImage9->image;
HXDLIN( 306)																		int x15 = (dx5 - rectLeft3);
HXDLIN( 306)																		int y14 = (dy5 - rectTop3);
HXDLIN( 306)																		int index16;
HXDLIN( 306)																		if (undoImage9->useVirtualPos) {
HXLINE( 306)																			index16 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index16 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x15)) ));
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this125,index16,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 306)										bool found1 = false;
HXDLIN( 306)										Float s1 = ((Float)0.);
HXDLIN( 306)										Float t1 = ((Float)0.);
HXDLIN( 306)										Float sxx1 = ((Float)0.);
HXDLIN( 306)										Float txx1 = ((Float)0.);
HXDLIN( 306)										{
HXLINE( 306)											int _g_min6 = xIter33->start;
HXDLIN( 306)											int _g_max6 = xIter33->max;
HXDLIN( 306)											while((_g_min6 < _g_max6)){
HXLINE( 306)												_g_min6 = (_g_min6 + 1);
HXDLIN( 306)												int x16 = (_g_min6 - 1);
HXLINE(  60)												sxx1 = (sx1 * ( (Float)(x16) ));
HXLINE(  61)												txx1 = (tx1 * ( (Float)(x16) ));
HXLINE(  62)												found1 = false;
HXLINE( 306)												{
HXLINE( 306)													int _g_min7 = yIter33->start;
HXDLIN( 306)													int _g_max7 = yIter33->max;
HXDLIN( 306)													while((_g_min7 < _g_max7)){
HXLINE( 306)														_g_min7 = (_g_min7 + 1);
HXDLIN( 306)														int y15 = (_g_min7 - 1);
HXLINE(  64)														s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y15) )));
HXLINE(  65)														t1 = ((t01 + txx1) + (ty1 * ( (Float)(y15) )));
HXLINE( 306)														bool _hx_tmp30;
HXDLIN( 306)														if (!((s1 <= 0))) {
HXLINE( 306)															_hx_tmp30 = (t1 <= 0);
            														}
            														else {
HXLINE( 306)															_hx_tmp30 = true;
            														}
HXDLIN( 306)														if (_hx_tmp30) {
HXLINE( 306)															if (found1) {
HXLINE( 306)																goto _hx_goto_730;
            															}
            														}
            														else {
HXLINE( 306)															if (((s1 + t1) < A1)) {
HXLINE( 306)																{
HXLINE( 306)																	int c13 = colorC;
HXDLIN( 306)																	bool _hx_tmp31;
HXDLIN( 306)																	if ((((c13 >> 24) & 255) < 254)) {
HXLINE( 306)																		_hx_tmp31 = this103->transparent;
            																	}
            																	else {
HXLINE( 306)																		_hx_tmp31 = false;
            																	}
HXDLIN( 306)																	if (_hx_tmp31) {
HXLINE( 306)																		int location7;
HXDLIN( 306)																		if (this103->useVirtualPos) {
HXLINE( 306)																			location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this103->virtualY) * ( (Float)(this103->width) )) + x16) - this103->virtualX));
            																		}
            																		else {
HXLINE( 306)																			location7 = ::Std_obj::_hx_int(( (Float)(((y15 * this103->width) + x16)) ));
            																		}
HXDLIN( 306)																		int this126 = ::iterMagic::Iimg_obj::get(this103->image,location7);
HXDLIN( 306)																		int this127;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			this127 = ((((((this126 >> 24) & 255) << 24) | ((this126 & 255) << 16)) | (((this126 >> 8) & 255) << 8)) | ((this126 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			this127 = this126;
            																		}
HXDLIN( 306)																		Float a111;
HXDLIN( 306)																		int this128 = ((this127 >> 24) & 255);
HXDLIN( 306)																		if ((this128 == 0)) {
HXLINE( 306)																			a111 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a111 = (( (Float)(this128) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r17;
HXDLIN( 306)																		int this129 = ((this127 >> 16) & 255);
HXDLIN( 306)																		if ((this129 == 0)) {
HXLINE( 306)																			r17 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r17 = (( (Float)(this129) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g17;
HXDLIN( 306)																		int this130 = ((this127 >> 8) & 255);
HXDLIN( 306)																		if ((this130 == 0)) {
HXLINE( 306)																			g17 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g17 = (( (Float)(this130) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b113;
HXDLIN( 306)																		int this131 = (this127 & 255);
HXDLIN( 306)																		if ((this131 == 0)) {
HXLINE( 306)																			b113 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b113 = (( (Float)(this131) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a28;
HXDLIN( 306)																		int this132 = ((colorC >> 24) & 255);
HXDLIN( 306)																		if ((this132 == 0)) {
HXLINE( 306)																			a28 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a28 = (( (Float)(this132) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r27;
HXDLIN( 306)																		int this133 = ((colorC >> 16) & 255);
HXDLIN( 306)																		if ((this133 == 0)) {
HXLINE( 306)																			r27 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r27 = (( (Float)(this133) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g27;
HXDLIN( 306)																		int this134 = ((colorC >> 8) & 255);
HXDLIN( 306)																		if ((this134 == 0)) {
HXLINE( 306)																			g27 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g27 = (( (Float)(this134) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b211;
HXDLIN( 306)																		int this135 = (colorC & 255);
HXDLIN( 306)																		if ((this135 == 0)) {
HXLINE( 306)																			b211 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b211 = (( (Float)(this135) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a37 = (a111 * (( (Float)(1) ) - a28));
HXDLIN( 306)																		int r18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a28))));
HXDLIN( 306)																		int g18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a28))));
HXDLIN( 306)																		int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a28))));
HXDLIN( 306)																		int a29 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a28)));
HXDLIN( 306)																		int blended7 = ((((a29 << 24) | (r18 << 16)) | (g18 << 8)) | b34);
HXDLIN( 306)																		{
HXLINE( 306)																			int _hx_tmp32;
HXDLIN( 306)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																				_hx_tmp32 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																			}
            																			else {
HXLINE( 306)																				_hx_tmp32 = blended7;
            																			}
HXDLIN( 306)																			::iterMagic::Iimg_obj::set(this103->image,location7,_hx_tmp32);
            																		}
            																	}
            																	else {
HXLINE( 306)																		::Dynamic this136 = this103->image;
HXDLIN( 306)																		int index17;
HXDLIN( 306)																		if (this103->useVirtualPos) {
HXLINE( 306)																			index17 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this103->virtualY) * ( (Float)(this103->width) )) + x16) - this103->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index17 = ::Std_obj::_hx_int(( (Float)(((y15 * this103->width) + x16)) ));
            																		}
HXDLIN( 306)																		int _hx_tmp33;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			_hx_tmp33 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			_hx_tmp33 = c13;
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this136,index17,_hx_tmp33);
            																	}
            																}
HXLINE(  73)																found1 = true;
            															}
            															else {
HXLINE( 306)																if (found1) {
HXLINE( 306)																	goto _hx_goto_730;
            																}
            															}
            														}
            													}
            													_hx_goto_730:;
            												}
            											}
            										}
HXDLIN( 306)										if ((hasHit3 == true)) {
HXLINE( 306)											 ::pi_xy::algo::HitTri v13 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX,cy3,bx2,by1,cx2,cy4,true);
HXDLIN( 306)											if (hasUndo3) {
HXLINE( 306)												v13->undoImage = undoImage9;
HXDLIN( 306)												v13->undoX = xIter33->start;
HXDLIN( 306)												v13->undoY = yIter33->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX1 = nextX1;
HXLINE(  47)							lastY1 = nextY1;
            						}
            					}
            				}
            			}
HXLINE( 306)			 ::pi_xy::ImageStruct this137 = temp;
HXDLIN( 306)			Float y16 = ( (Float)(dy1) );
HXDLIN( 306)			Float bx3 = ( (Float)(dx1) );
HXDLIN( 306)			Float cy5 = (y16 + ( (Float)(tall1) ));
HXDLIN( 306)			{
HXLINE( 306)				bool hasHit4 = true;
HXDLIN( 306)				{
HXLINE( 306)					{
HXLINE( 306)						bool hasUndo4 = false;
HXDLIN( 306)						int aA2 = ((colorA >> 24) & 255);
HXDLIN( 306)						int rA2 = ((colorA >> 16) & 255);
HXDLIN( 306)						int gA2 = ((colorA >> 8) & 255);
HXDLIN( 306)						int bA2 = (colorA & 255);
HXDLIN( 306)						int aB2 = ((colorA >> 24) & 255);
HXDLIN( 306)						int rB2 = ((colorA >> 16) & 255);
HXDLIN( 306)						int gB2 = ((colorA >> 8) & 255);
HXDLIN( 306)						int bB2 = (colorA & 255);
HXDLIN( 306)						int aC2 = ((colorD >> 24) & 255);
HXDLIN( 306)						int rC2 = ((colorD >> 16) & 255);
HXDLIN( 306)						int gC2 = ((colorD >> 8) & 255);
HXDLIN( 306)						int bC2 = (colorD & 255);
HXDLIN( 306)						Float bcx2 = bx3;
HXDLIN( 306)						Float bcy2 = (y16 - cy5);
HXDLIN( 306)						Float acx2 = ( (Float)(0) );
HXDLIN( 306)						Float acy2 = (y16 - cy5);
HXDLIN( 306)						Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 306)						Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 306)						Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 306)						Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 306)						if ((0 > bx3)) {
HXLINE( 306)							int ii_min30 = ::Math_obj::floor(bx3);
HXDLIN( 306)							int ii_max30 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 306)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            						}
            						else {
HXLINE( 306)							if ((bx3 > 0)) {
HXLINE( 306)								int ii_min31 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 306)								int ii_max31 = ::Math_obj::ceil(bx3);
HXDLIN( 306)								xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            							}
            							else {
HXLINE( 306)								int ii_min32 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN( 306)								int ii_max32 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 306)								xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 306)						if ((y16 > y16)) {
HXLINE( 306)							if ((y16 > cy5)) {
HXLINE( 306)								int min15;
HXDLIN( 306)								if ((y16 > cy5)) {
HXLINE( 306)									min15 = ::Math_obj::floor(cy5);
            								}
            								else {
HXLINE( 306)									min15 = ::Math_obj::floor(y16);
            								}
HXDLIN( 306)								int ii_min33 = min15;
HXDLIN( 306)								int ii_max33 = ::Math_obj::ceil(y16);
HXDLIN( 306)								yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            							}
            							else {
HXLINE( 306)								int ii_min34 = ::Math_obj::floor(y16);
HXDLIN( 306)								int ii_max34 = ::Math_obj::ceil(cy5);
HXDLIN( 306)								yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            							}
            						}
            						else {
HXLINE( 306)							if ((y16 > cy5)) {
HXLINE( 306)								int min16;
HXDLIN( 306)								if ((y16 > cy5)) {
HXLINE( 306)									min16 = ::Math_obj::floor(cy5);
            								}
            								else {
HXLINE( 306)									min16 = ::Math_obj::ceil(y16);
            								}
HXDLIN( 306)								int ii_min35 = min16;
HXDLIN( 306)								int ii_max35 = ::Math_obj::ceil(y16);
HXDLIN( 306)								yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            							}
            							else {
HXLINE( 306)								int ii_min36 = ::Math_obj::floor(y16);
HXDLIN( 306)								int ii_max36 = ::Math_obj::ceil(cy5);
HXDLIN( 306)								yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 306)						if (hasUndo4) {
HXLINE( 306)							int width5 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 306)							int height5 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType5 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this138 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType5 )) {
HXLINE(  54)								imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage13;
HXDLIN( 306)							switch((int)(( (int)(imageType5) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b35 = byt5;
HXDLIN( 306)									{
HXLINE( 306)										b35->width = width5;
HXDLIN( 306)										b35->height = height5;
HXDLIN( 306)										b35->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 306)										b35->data = ::haxe::io::Bytes_obj::alloc((b35->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len10 = b35->length;
HXDLIN( 306)											int w5 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g100 = 0;
HXDLIN( 306)												int _g101 = b35->height;
HXDLIN( 306)												while((_g100 < _g101)){
HXLINE( 306)													_g100 = (_g100 + 1);
HXDLIN( 306)													int y17 = (_g100 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g102 = 0;
HXDLIN( 306)														int _g103 = b35->width;
HXDLIN( 306)														while((_g102 < _g103)){
HXLINE( 306)															_g102 = (_g102 + 1);
HXDLIN( 306)															int x17 = (_g102 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w5 = (w5 + 1);
HXDLIN( 306)																b35->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w5 = (w5 + 1);
HXDLIN( 306)																b35->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w5 = (w5 + 1);
HXDLIN( 306)																b35->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w5 = (w5 + 1);
HXDLIN( 306)																b35->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage13 = b35;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a30 = arrI5;
HXDLIN( 306)									{
HXLINE( 306)										a30->width = width5;
HXDLIN( 306)										a30->height = height5;
HXDLIN( 306)										a30->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a30->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g104 = 0;
HXDLIN( 306)											int _g105 = a30->length;
HXDLIN( 306)											while((_g104 < _g105)){
HXLINE( 306)												_g104 = (_g104 + 1);
HXDLIN( 306)												int i40 = (_g104 - 1);
HXDLIN( 306)												a30->data[i40] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage13 = a30;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b36 = u32a5;
HXDLIN( 306)									{
HXLINE( 306)										b36->width = width5;
HXDLIN( 306)										b36->height = height5;
HXDLIN( 306)										b36->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 306)										int size5 = (b36->length * 4);
HXDLIN( 306)										b36->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 306)										{
HXLINE( 306)											int _g106 = 0;
HXDLIN( 306)											int _g107 = b36->length;
HXDLIN( 306)											while((_g106 < _g107)){
HXLINE( 306)												_g106 = (_g106 + 1);
HXDLIN( 306)												int i41 = (_g106 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this139 = b36->data;
HXDLIN( 306)													bool undoImage14;
HXDLIN( 306)													if ((i41 >= 0)) {
HXLINE( 306)														undoImage14 = (i41 < (this139->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage14 = false;
            													}
HXDLIN( 306)													if (undoImage14) {
HXLINE( 306)														 ::haxe::io::Bytes _this5 = this139->bytes;
HXDLIN( 306)														int pos5 = ((i41 << 2) + this139->byteOffset);
HXDLIN( 306)														_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 306)														_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage13 = b36;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v14 = vec5;
HXDLIN( 306)									{
HXLINE( 306)										v14->width = width5;
HXDLIN( 306)										v14->height = height5;
HXDLIN( 306)										v14->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 306)										v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g108 = 0;
HXDLIN( 306)											int _g109 = v14->length;
HXDLIN( 306)											while((_g108 < _g109)){
HXLINE( 306)												_g108 = (_g108 + 1);
HXDLIN( 306)												int i42 = (_g108 - 1);
HXDLIN( 306)												v14->data->__unsafe_set(i42,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage13 = v14;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b37 = sInt5;
HXDLIN( 306)									{
HXLINE( 306)										b37->width = width5;
HXDLIN( 306)										b37->height = height5;
HXDLIN( 306)										b37->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 306)										b37->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len11 = b37->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d5 = b37->data;
HXDLIN( 306)											if (::hx::IsNull( d5->head )) {
HXLINE( 306)												int _g110 = 0;
HXDLIN( 306)												int _g111 = len11;
HXDLIN( 306)												while((_g110 < _g111)){
HXLINE( 306)													_g110 = (_g110 + 1);
HXDLIN( 306)													int i43 = (_g110 - 1);
HXDLIN( 306)													d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g112 = 0;
HXDLIN( 306)												int _g113 = len11;
HXDLIN( 306)												while((_g112 < _g113)){
HXLINE( 306)													_g112 = (_g112 + 1);
HXDLIN( 306)													int i44 = (_g112 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l5 = b37->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g114 = 0;
HXDLIN( 306)															int _g115 = i44;
HXDLIN( 306)															while((_g114 < _g115)){
HXLINE( 306)																_g114 = (_g114 + 1);
HXDLIN( 306)																int i45 = (_g114 - 1);
HXLINE( 345)																prev5 = l5;
HXLINE( 346)																l5 = l5->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev5 )) {
HXLINE( 306)															b37->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 306)															l5 = null();
            														}
            														else {
HXLINE( 306)															prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 306)															l5 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage13 = b37;
            								}
            								break;
            							}
HXDLIN( 306)							this138->image = undoImage13;
HXDLIN( 306)							this138->width = width5;
HXDLIN( 306)							this138->height = height5;
HXDLIN( 306)							this138->imageType = ( (int)(imageType5) );
HXDLIN( 306)							undoImage12 = this138;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft4 = xIter34->start;
HXDLIN( 306)								int rectTop4 = yIter34->start;
HXDLIN( 306)								int rectRight4 = xIter34->max;
HXDLIN( 306)								bool forceClear4 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g116 = rectTop4;
HXDLIN( 306)									int _g117 = yIter34->max;
HXDLIN( 306)									while((_g116 < _g117)){
HXLINE( 306)										_g116 = (_g116 + 1);
HXDLIN( 306)										int dy6 = (_g116 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g118 = rectLeft4;
HXDLIN( 306)											int _g119 = rectRight4;
HXDLIN( 306)											while((_g118 < _g119)){
HXLINE( 306)												_g118 = (_g118 + 1);
HXDLIN( 306)												int dx6 = (_g118 - 1);
HXDLIN( 306)												::Dynamic this140 = this137->image;
HXDLIN( 306)												int index18;
HXDLIN( 306)												if (this137->useVirtualPos) {
HXLINE( 306)													index18 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this137->virtualY) * ( (Float)(this137->width) )) + dx6) - this137->virtualX));
            												}
            												else {
HXLINE( 306)													index18 = ::Std_obj::_hx_int(( (Float)(((dy6 * this137->width) + dx6)) ));
            												}
HXDLIN( 306)												int c14 = ::iterMagic::Iimg_obj::get(this140,index18);
HXDLIN( 306)												int col4;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col4 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col4 = c14;
            												}
HXDLIN( 306)												bool _hx_tmp34;
HXDLIN( 306)												if (this137->useMask) {
HXLINE( 306)													_hx_tmp34 = ::hx::IsNotNull( this137->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp34 = false;
            												}
HXDLIN( 306)												if (_hx_tmp34) {
HXLINE( 306)													 ::pi_xy::ImageStruct this141 = this137->mask;
HXDLIN( 306)													::Dynamic this142 = this141->image;
HXDLIN( 306)													int index19;
HXDLIN( 306)													if (this141->useVirtualPos) {
HXLINE( 306)														index19 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this141->virtualY) * ( (Float)(this141->width) )) + dx6) - this141->virtualX));
            													}
            													else {
HXLINE( 306)														index19 = ::Std_obj::_hx_int(( (Float)(((dy6 * this141->width) + dx6)) ));
            													}
HXDLIN( 306)													int c15 = ::iterMagic::Iimg_obj::get(this142,index19);
HXDLIN( 306)													int v15;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v15 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v15 = c15;
            													}
HXDLIN( 306)													int maskPixel4 = v15;
HXDLIN( 306)													int this143 = col4;
HXDLIN( 306)													if ((maskPixel4 == 0)) {
HXLINE( 306)														col4 = this143;
            													}
            													else {
HXLINE( 306)														Float m04;
HXDLIN( 306)														int this144 = ((maskPixel4 >> 24) & 255);
HXDLIN( 306)														if ((this144 == 0)) {
HXLINE( 306)															m04 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m04 = (( (Float)(this144) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m14;
HXDLIN( 306)														int this145 = ((maskPixel4 >> 16) & 255);
HXDLIN( 306)														if ((this145 == 0)) {
HXLINE( 306)															m14 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m14 = (( (Float)(this145) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m24;
HXDLIN( 306)														int this146 = ((maskPixel4 >> 8) & 255);
HXDLIN( 306)														if ((this146 == 0)) {
HXLINE( 306)															m24 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m24 = (( (Float)(this146) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m34;
HXDLIN( 306)														int this147 = (maskPixel4 & 255);
HXDLIN( 306)														if ((this147 == 0)) {
HXLINE( 306)															m34 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m34 = (( (Float)(this147) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this143 >> 24) & 255)) )));
HXDLIN( 306)														int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this143 >> 16) & 255)) )));
HXDLIN( 306)														int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this143 >> 8) & 255)) )));
HXDLIN( 306)														int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this143 & 255)) )));
HXDLIN( 306)														col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col4 != 0)) {
HXLINE( 306)													int x18 = (dx6 - rectLeft4);
HXDLIN( 306)													int y18 = (dy6 - rectTop4);
HXDLIN( 306)													int c16 = col4;
HXDLIN( 306)													bool _hx_tmp35;
HXDLIN( 306)													if ((((c16 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp35 = undoImage12->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp35 = false;
            													}
HXDLIN( 306)													if (_hx_tmp35) {
HXLINE( 306)														int location8;
HXDLIN( 306)														if (undoImage12->useVirtualPos) {
HXLINE( 306)															location8 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x18) - undoImage12->virtualX));
            														}
            														else {
HXLINE( 306)															location8 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage12->width) + x18)) ));
            														}
HXDLIN( 306)														int this148 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 306)														int this149;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this149 = ((((((this148 >> 24) & 255) << 24) | ((this148 & 255) << 16)) | (((this148 >> 8) & 255) << 8)) | ((this148 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this149 = this148;
            														}
HXDLIN( 306)														Float a112;
HXDLIN( 306)														int this150 = ((this149 >> 24) & 255);
HXDLIN( 306)														if ((this150 == 0)) {
HXLINE( 306)															a112 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a112 = (( (Float)(this150) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r19;
HXDLIN( 306)														int this151 = ((this149 >> 16) & 255);
HXDLIN( 306)														if ((this151 == 0)) {
HXLINE( 306)															r19 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r19 = (( (Float)(this151) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g19;
HXDLIN( 306)														int this152 = ((this149 >> 8) & 255);
HXDLIN( 306)														if ((this152 == 0)) {
HXLINE( 306)															g19 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g19 = (( (Float)(this152) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b114;
HXDLIN( 306)														int this153 = (this149 & 255);
HXDLIN( 306)														if ((this153 == 0)) {
HXLINE( 306)															b114 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b114 = (( (Float)(this153) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a210;
HXDLIN( 306)														int this154 = ((col4 >> 24) & 255);
HXDLIN( 306)														if ((this154 == 0)) {
HXLINE( 306)															a210 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a210 = (( (Float)(this154) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r28;
HXDLIN( 306)														int this155 = ((col4 >> 16) & 255);
HXDLIN( 306)														if ((this155 == 0)) {
HXLINE( 306)															r28 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r28 = (( (Float)(this155) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g28;
HXDLIN( 306)														int this156 = ((col4 >> 8) & 255);
HXDLIN( 306)														if ((this156 == 0)) {
HXLINE( 306)															g28 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g28 = (( (Float)(this156) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b212;
HXDLIN( 306)														int this157 = (col4 & 255);
HXDLIN( 306)														if ((this157 == 0)) {
HXLINE( 306)															b212 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b212 = (( (Float)(this157) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a38 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 306)														int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a38) + (r28 * a210))));
HXDLIN( 306)														int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a38) + (g28 * a210))));
HXDLIN( 306)														int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a38) + (b212 * a210))));
HXDLIN( 306)														int a39 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN( 306)														int blended8 = ((((a39 << 24) | (r20 << 16)) | (g20 << 8)) | b38);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp36;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp36 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp36 = blended8;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage12->image,location8,_hx_tmp36);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this158 = undoImage12->image;
HXDLIN( 306)														int index20;
HXDLIN( 306)														if (undoImage12->useVirtualPos) {
HXLINE( 306)															index20 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x18) - undoImage12->virtualX));
            														}
            														else {
HXLINE( 306)															index20 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage12->width) + x18)) ));
            														}
HXDLIN( 306)														int _hx_tmp37;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp37 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp37 = c16;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this158,index20,_hx_tmp37);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear4) {
HXLINE( 306)														::Dynamic this159 = undoImage12->image;
HXDLIN( 306)														int x19 = (dx6 - rectLeft4);
HXDLIN( 306)														int y19 = (dy6 - rectTop4);
HXDLIN( 306)														int index21;
HXDLIN( 306)														if (undoImage12->useVirtualPos) {
HXLINE( 306)															index21 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x19) - undoImage12->virtualX));
            														}
            														else {
HXLINE( 306)															index21 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage12->width) + x19)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this159,index21,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min8 = xIter34->start;
HXDLIN( 306)							int _g_max8 = xIter34->max;
HXDLIN( 306)							while((_g_min8 < _g_max8)){
HXLINE( 306)								_g_min8 = (_g_min8 + 1);
HXDLIN( 306)								int px2 = (_g_min8 - 1);
HXDLIN( 306)								Float pcx2 = ( (Float)(px2) );
HXDLIN( 306)								{
HXLINE( 306)									int _g_min9 = yIter34->start;
HXDLIN( 306)									int _g_max9 = yIter34->max;
HXDLIN( 306)									while((_g_min9 < _g_max9)){
HXLINE( 306)										_g_min9 = (_g_min9 + 1);
HXDLIN( 306)										int py2 = (_g_min9 - 1);
HXDLIN( 306)										Float pcy2 = (( (Float)(py2) ) - cy5);
HXDLIN( 306)										Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 306)										Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 306)										Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 306)										Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 306)										Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 306)										bool _hx_tmp38;
HXDLIN( 306)										bool _hx_tmp39;
HXDLIN( 306)										if ((ratioA2 >= 0)) {
HXLINE( 306)											_hx_tmp39 = (ratioB2 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp39 = false;
            										}
HXDLIN( 306)										if (_hx_tmp39) {
HXLINE( 306)											_hx_tmp38 = (ratioC2 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp38 = false;
            										}
HXDLIN( 306)										if (_hx_tmp38) {
HXLINE( 306)											int i46 = ::Std_obj::_hx_int((((( (Float)(aA2) ) * ratioA2) + (( (Float)(aB2) ) * ratioB2)) + (( (Float)(aC2) ) * ratioC2)));
HXDLIN( 306)											if ((i46 > 255)) {
HXLINE(  24)												i46 = 255;
            											}
HXLINE( 306)											if ((i46 < 0)) {
HXLINE(  25)												i46 = 0;
            											}
HXLINE( 306)											int a40 = i46;
HXDLIN( 306)											int i47 = ::Std_obj::_hx_int((((( (Float)(rA2) ) * ratioA2) + (( (Float)(rB2) ) * ratioB2)) + (( (Float)(rC2) ) * ratioC2)));
HXDLIN( 306)											if ((i47 > 255)) {
HXLINE(  24)												i47 = 255;
            											}
HXLINE( 306)											if ((i47 < 0)) {
HXLINE(  25)												i47 = 0;
            											}
HXLINE( 306)											int r29 = i47;
HXDLIN( 306)											int i48 = ::Std_obj::_hx_int((((( (Float)(gA2) ) * ratioA2) + (( (Float)(gB2) ) * ratioB2)) + (( (Float)(gC2) ) * ratioC2)));
HXDLIN( 306)											if ((i48 > 255)) {
HXLINE(  24)												i48 = 255;
            											}
HXLINE( 306)											if ((i48 < 0)) {
HXLINE(  25)												i48 = 0;
            											}
HXLINE( 306)											int g29 = i48;
HXDLIN( 306)											int i49 = ::Std_obj::_hx_int((((( (Float)(bA2) ) * ratioA2) + (( (Float)(bB2) ) * ratioB2)) + (( (Float)(bC2) ) * ratioC2)));
HXDLIN( 306)											if ((i49 > 255)) {
HXLINE(  24)												i49 = 255;
            											}
HXLINE( 306)											if ((i49 < 0)) {
HXLINE(  25)												i49 = 0;
            											}
HXLINE( 306)											int b39 = i49;
HXDLIN( 306)											{
HXLINE( 306)												int location9;
HXDLIN( 306)												if (this137->useVirtualPos) {
HXLINE( 306)													location9 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this137->virtualY) * ( (Float)(this137->width) )) + px2) - this137->virtualX));
            												}
            												else {
HXLINE( 306)													location9 = ::Std_obj::_hx_int(( (Float)(((py2 * this137->width) + px2)) ));
            												}
HXDLIN( 306)												bool _hx_tmp40;
HXDLIN( 306)												if (this137->transparent) {
HXLINE( 306)													_hx_tmp40 = (a40 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp40 = false;
            												}
HXDLIN( 306)												if (_hx_tmp40) {
HXLINE( 306)													int this160 = ::iterMagic::Iimg_obj::get(this137->image,location9);
HXDLIN( 306)													int old2;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old2 = ((((((this160 >> 24) & 255) << 24) | ((this160 & 255) << 16)) | (((this160 >> 8) & 255) << 8)) | ((this160 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old2 = this160;
            													}
HXDLIN( 306)													int rhs2 = ((((a40 << 24) | (r29 << 16)) | (g29 << 8)) | b39);
HXDLIN( 306)													Float a113;
HXDLIN( 306)													int this161 = ((old2 >> 24) & 255);
HXDLIN( 306)													if ((this161 == 0)) {
HXLINE( 306)														a113 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a113 = (( (Float)(this161) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r110;
HXDLIN( 306)													int this162 = ((old2 >> 16) & 255);
HXDLIN( 306)													if ((this162 == 0)) {
HXLINE( 306)														r110 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r110 = (( (Float)(this162) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g110;
HXDLIN( 306)													int this163 = ((old2 >> 8) & 255);
HXDLIN( 306)													if ((this163 == 0)) {
HXLINE( 306)														g110 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g110 = (( (Float)(this163) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b115;
HXDLIN( 306)													int this164 = (old2 & 255);
HXDLIN( 306)													if ((this164 == 0)) {
HXLINE( 306)														b115 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b115 = (( (Float)(this164) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a211;
HXDLIN( 306)													int this165 = ((rhs2 >> 24) & 255);
HXDLIN( 306)													if ((this165 == 0)) {
HXLINE( 306)														a211 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a211 = (( (Float)(this165) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r210;
HXDLIN( 306)													int this166 = ((rhs2 >> 16) & 255);
HXDLIN( 306)													if ((this166 == 0)) {
HXLINE( 306)														r210 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r210 = (( (Float)(this166) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g210;
HXDLIN( 306)													int this167 = ((rhs2 >> 8) & 255);
HXDLIN( 306)													if ((this167 == 0)) {
HXLINE( 306)														g210 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g210 = (( (Float)(this167) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b213;
HXDLIN( 306)													int this168 = (rhs2 & 255);
HXDLIN( 306)													if ((this168 == 0)) {
HXLINE( 306)														b213 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b213 = (( (Float)(this168) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 306)													int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 306)													int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 306)													int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a310) + (b213 * a211))));
HXDLIN( 306)													int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 306)													int blended9 = ((((a41 << 24) | (r30 << 16)) | (g30 << 8)) | b40);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp41;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp41 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp41 = blended9;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this137->image,location9,_hx_tmp41);
            													}
            												}
            												else {
HXLINE( 306)													int value2;
HXDLIN( 306)													if (this137->isLittle) {
HXLINE( 306)														value2 = ((((a40 << 24) | (b39 << 16)) | (g29 << 8)) | r29);
            													}
            													else {
HXLINE( 306)														value2 = ((((a40 << 24) | (r29 << 16)) | (g29 << 8)) | b39);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this137->image,location9,value2);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit4 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v16 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,( (Float)(0) ),y16,bx3,y16,( (Float)(0) ),cy5,true);
HXDLIN( 306)							if (hasUndo4) {
HXLINE( 306)								v16->undoImage = undoImage12;
HXDLIN( 306)								v16->undoX = xIter34->start;
HXDLIN( 306)								v16->undoY = yIter34->start;
            							}
            						}
            					}
HXDLIN( 306)					{
HXLINE( 306)						bool hasHit5 = false;
HXDLIN( 306)						bool hasUndo5 = false;
HXDLIN( 306)						int aA3 = ((colorD >> 24) & 255);
HXDLIN( 306)						int rA3 = ((colorD >> 16) & 255);
HXDLIN( 306)						int gA3 = ((colorD >> 8) & 255);
HXDLIN( 306)						int bA3 = (colorD & 255);
HXDLIN( 306)						int aB3 = ((colorA >> 24) & 255);
HXDLIN( 306)						int rB3 = ((colorA >> 16) & 255);
HXDLIN( 306)						int gB3 = ((colorA >> 8) & 255);
HXDLIN( 306)						int bB3 = (colorA & 255);
HXDLIN( 306)						int aC3 = ((colorD >> 24) & 255);
HXDLIN( 306)						int rC3 = ((colorD >> 16) & 255);
HXDLIN( 306)						int gC3 = ((colorD >> 8) & 255);
HXDLIN( 306)						int bC3 = (colorD & 255);
HXDLIN( 306)						Float bcx3 = bx3;
HXDLIN( 306)						Float bcy3 = (cy5 - cy5);
HXDLIN( 306)						Float acx3 = bx3;
HXDLIN( 306)						Float acy3 = (y16 - cy5);
HXDLIN( 306)						Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 306)						Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 306)						Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 306)						Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 306)						if ((bx3 > bx3)) {
HXLINE( 306)							if ((bx3 > 0)) {
HXLINE( 306)								int min17;
HXDLIN( 306)								if ((bx3 > 0)) {
HXLINE( 306)									min17 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE( 306)									min17 = ::Math_obj::floor(bx3);
            								}
HXDLIN( 306)								int ii_min37 = min17;
HXDLIN( 306)								int ii_max37 = ::Math_obj::ceil(bx3);
HXDLIN( 306)								xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            							}
            							else {
HXLINE( 306)								int ii_min38 = ::Math_obj::floor(bx3);
HXDLIN( 306)								int ii_max38 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 306)								xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx3 > 0)) {
HXLINE( 306)								int min18;
HXDLIN( 306)								if ((bx3 > 0)) {
HXLINE( 306)									min18 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE( 306)									min18 = ::Math_obj::ceil(bx3);
            								}
HXDLIN( 306)								int ii_min39 = min18;
HXDLIN( 306)								int ii_max39 = ::Math_obj::ceil(bx3);
HXDLIN( 306)								xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            							}
            							else {
HXLINE( 306)								int ii_min40 = ::Math_obj::floor(bx3);
HXDLIN( 306)								int ii_max40 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 306)								xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 306)						if ((y16 > cy5)) {
HXLINE( 306)							if ((y16 > cy5)) {
HXLINE( 306)								int min19;
HXDLIN( 306)								if ((cy5 > cy5)) {
HXLINE( 306)									min19 = ::Math_obj::floor(cy5);
            								}
            								else {
HXLINE( 306)									min19 = ::Math_obj::floor(cy5);
            								}
HXDLIN( 306)								int ii_min41 = min19;
HXDLIN( 306)								int ii_max41 = ::Math_obj::ceil(y16);
HXDLIN( 306)								yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            							}
            							else {
HXLINE( 306)								int ii_min42 = ::Math_obj::floor(cy5);
HXDLIN( 306)								int ii_max42 = ::Math_obj::ceil(cy5);
HXDLIN( 306)								yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            							}
            						}
            						else {
HXLINE( 306)							if ((cy5 > cy5)) {
HXLINE( 306)								int min20;
HXDLIN( 306)								if ((y16 > cy5)) {
HXLINE( 306)									min20 = ::Math_obj::floor(cy5);
            								}
            								else {
HXLINE( 306)									min20 = ::Math_obj::ceil(y16);
            								}
HXDLIN( 306)								int ii_min43 = min20;
HXDLIN( 306)								int ii_max43 = ::Math_obj::ceil(cy5);
HXDLIN( 306)								yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            							}
            							else {
HXLINE( 306)								int ii_min44 = ::Math_obj::floor(y16);
HXDLIN( 306)								int ii_max44 = ::Math_obj::ceil(cy5);
HXDLIN( 306)								yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 306)						if (hasUndo5) {
HXLINE( 306)							int width6 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 306)							int height6 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType6 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this169 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType6 )) {
HXLINE(  54)								imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage16;
HXDLIN( 306)							switch((int)(( (int)(imageType6) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b41 = byt6;
HXDLIN( 306)									{
HXLINE( 306)										b41->width = width6;
HXDLIN( 306)										b41->height = height6;
HXDLIN( 306)										b41->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 306)										b41->data = ::haxe::io::Bytes_obj::alloc((b41->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len12 = b41->length;
HXDLIN( 306)											int w6 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g120 = 0;
HXDLIN( 306)												int _g121 = b41->height;
HXDLIN( 306)												while((_g120 < _g121)){
HXLINE( 306)													_g120 = (_g120 + 1);
HXDLIN( 306)													int y20 = (_g120 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g122 = 0;
HXDLIN( 306)														int _g123 = b41->width;
HXDLIN( 306)														while((_g122 < _g123)){
HXLINE( 306)															_g122 = (_g122 + 1);
HXDLIN( 306)															int x20 = (_g122 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w6 = (w6 + 1);
HXDLIN( 306)																b41->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w6 = (w6 + 1);
HXDLIN( 306)																b41->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w6 = (w6 + 1);
HXDLIN( 306)																b41->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w6 = (w6 + 1);
HXDLIN( 306)																b41->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage16 = b41;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a42 = arrI6;
HXDLIN( 306)									{
HXLINE( 306)										a42->width = width6;
HXDLIN( 306)										a42->height = height6;
HXDLIN( 306)										a42->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a42->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g124 = 0;
HXDLIN( 306)											int _g125 = a42->length;
HXDLIN( 306)											while((_g124 < _g125)){
HXLINE( 306)												_g124 = (_g124 + 1);
HXDLIN( 306)												int i50 = (_g124 - 1);
HXDLIN( 306)												a42->data[i50] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage16 = a42;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b42 = u32a6;
HXDLIN( 306)									{
HXLINE( 306)										b42->width = width6;
HXDLIN( 306)										b42->height = height6;
HXDLIN( 306)										b42->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 306)										int size6 = (b42->length * 4);
HXDLIN( 306)										b42->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 306)										{
HXLINE( 306)											int _g126 = 0;
HXDLIN( 306)											int _g127 = b42->length;
HXDLIN( 306)											while((_g126 < _g127)){
HXLINE( 306)												_g126 = (_g126 + 1);
HXDLIN( 306)												int i51 = (_g126 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this170 = b42->data;
HXDLIN( 306)													bool undoImage17;
HXDLIN( 306)													if ((i51 >= 0)) {
HXLINE( 306)														undoImage17 = (i51 < (this170->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage17 = false;
            													}
HXDLIN( 306)													if (undoImage17) {
HXLINE( 306)														 ::haxe::io::Bytes _this6 = this170->bytes;
HXDLIN( 306)														int pos6 = ((i51 << 2) + this170->byteOffset);
HXDLIN( 306)														_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 306)														_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage16 = b42;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v17 = vec6;
HXDLIN( 306)									{
HXLINE( 306)										v17->width = width6;
HXDLIN( 306)										v17->height = height6;
HXDLIN( 306)										v17->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 306)										v17->data = ::Array_obj< int >::__new(v17->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g128 = 0;
HXDLIN( 306)											int _g129 = v17->length;
HXDLIN( 306)											while((_g128 < _g129)){
HXLINE( 306)												_g128 = (_g128 + 1);
HXDLIN( 306)												int i52 = (_g128 - 1);
HXDLIN( 306)												v17->data->__unsafe_set(i52,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage16 = v17;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b43 = sInt6;
HXDLIN( 306)									{
HXLINE( 306)										b43->width = width6;
HXDLIN( 306)										b43->height = height6;
HXDLIN( 306)										b43->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 306)										b43->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len13 = b43->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d6 = b43->data;
HXDLIN( 306)											if (::hx::IsNull( d6->head )) {
HXLINE( 306)												int _g130 = 0;
HXDLIN( 306)												int _g131 = len13;
HXDLIN( 306)												while((_g130 < _g131)){
HXLINE( 306)													_g130 = (_g130 + 1);
HXDLIN( 306)													int i53 = (_g130 - 1);
HXDLIN( 306)													d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g132 = 0;
HXDLIN( 306)												int _g133 = len13;
HXDLIN( 306)												while((_g132 < _g133)){
HXLINE( 306)													_g132 = (_g132 + 1);
HXDLIN( 306)													int i54 = (_g132 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l6 = b43->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g134 = 0;
HXDLIN( 306)															int _g135 = i54;
HXDLIN( 306)															while((_g134 < _g135)){
HXLINE( 306)																_g134 = (_g134 + 1);
HXDLIN( 306)																int i55 = (_g134 - 1);
HXLINE( 345)																prev6 = l6;
HXLINE( 346)																l6 = l6->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev6 )) {
HXLINE( 306)															b43->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 306)															l6 = null();
            														}
            														else {
HXLINE( 306)															prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 306)															l6 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage16 = b43;
            								}
            								break;
            							}
HXDLIN( 306)							this169->image = undoImage16;
HXDLIN( 306)							this169->width = width6;
HXDLIN( 306)							this169->height = height6;
HXDLIN( 306)							this169->imageType = ( (int)(imageType6) );
HXDLIN( 306)							undoImage15 = this169;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft5 = xIter35->start;
HXDLIN( 306)								int rectTop5 = yIter35->start;
HXDLIN( 306)								int rectRight5 = xIter35->max;
HXDLIN( 306)								bool forceClear5 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g136 = rectTop5;
HXDLIN( 306)									int _g137 = yIter35->max;
HXDLIN( 306)									while((_g136 < _g137)){
HXLINE( 306)										_g136 = (_g136 + 1);
HXDLIN( 306)										int dy7 = (_g136 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g138 = rectLeft5;
HXDLIN( 306)											int _g139 = rectRight5;
HXDLIN( 306)											while((_g138 < _g139)){
HXLINE( 306)												_g138 = (_g138 + 1);
HXDLIN( 306)												int dx7 = (_g138 - 1);
HXDLIN( 306)												::Dynamic this171 = this137->image;
HXDLIN( 306)												int index22;
HXDLIN( 306)												if (this137->useVirtualPos) {
HXLINE( 306)													index22 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this137->virtualY) * ( (Float)(this137->width) )) + dx7) - this137->virtualX));
            												}
            												else {
HXLINE( 306)													index22 = ::Std_obj::_hx_int(( (Float)(((dy7 * this137->width) + dx7)) ));
            												}
HXDLIN( 306)												int c17 = ::iterMagic::Iimg_obj::get(this171,index22);
HXDLIN( 306)												int col5;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col5 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col5 = c17;
            												}
HXDLIN( 306)												bool _hx_tmp42;
HXDLIN( 306)												if (this137->useMask) {
HXLINE( 306)													_hx_tmp42 = ::hx::IsNotNull( this137->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp42 = false;
            												}
HXDLIN( 306)												if (_hx_tmp42) {
HXLINE( 306)													 ::pi_xy::ImageStruct this172 = this137->mask;
HXDLIN( 306)													::Dynamic this173 = this172->image;
HXDLIN( 306)													int index23;
HXDLIN( 306)													if (this172->useVirtualPos) {
HXLINE( 306)														index23 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this172->virtualY) * ( (Float)(this172->width) )) + dx7) - this172->virtualX));
            													}
            													else {
HXLINE( 306)														index23 = ::Std_obj::_hx_int(( (Float)(((dy7 * this172->width) + dx7)) ));
            													}
HXDLIN( 306)													int c18 = ::iterMagic::Iimg_obj::get(this173,index23);
HXDLIN( 306)													int v18;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v18 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v18 = c18;
            													}
HXDLIN( 306)													int maskPixel5 = v18;
HXDLIN( 306)													int this174 = col5;
HXDLIN( 306)													if ((maskPixel5 == 0)) {
HXLINE( 306)														col5 = this174;
            													}
            													else {
HXLINE( 306)														Float m05;
HXDLIN( 306)														int this175 = ((maskPixel5 >> 24) & 255);
HXDLIN( 306)														if ((this175 == 0)) {
HXLINE( 306)															m05 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m05 = (( (Float)(this175) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m15;
HXDLIN( 306)														int this176 = ((maskPixel5 >> 16) & 255);
HXDLIN( 306)														if ((this176 == 0)) {
HXLINE( 306)															m15 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m15 = (( (Float)(this176) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m25;
HXDLIN( 306)														int this177 = ((maskPixel5 >> 8) & 255);
HXDLIN( 306)														if ((this177 == 0)) {
HXLINE( 306)															m25 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m25 = (( (Float)(this177) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m35;
HXDLIN( 306)														int this178 = (maskPixel5 & 255);
HXDLIN( 306)														if ((this178 == 0)) {
HXLINE( 306)															m35 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m35 = (( (Float)(this178) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this174 >> 24) & 255)) )));
HXDLIN( 306)														int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this174 >> 16) & 255)) )));
HXDLIN( 306)														int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this174 >> 8) & 255)) )));
HXDLIN( 306)														int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this174 & 255)) )));
HXDLIN( 306)														col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col5 != 0)) {
HXLINE( 306)													int x21 = (dx7 - rectLeft5);
HXDLIN( 306)													int y21 = (dy7 - rectTop5);
HXDLIN( 306)													int c19 = col5;
HXDLIN( 306)													bool _hx_tmp43;
HXDLIN( 306)													if ((((c19 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp43 = undoImage15->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp43 = false;
            													}
HXDLIN( 306)													if (_hx_tmp43) {
HXLINE( 306)														int location10;
HXDLIN( 306)														if (undoImage15->useVirtualPos) {
HXLINE( 306)															location10 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x21) - undoImage15->virtualX));
            														}
            														else {
HXLINE( 306)															location10 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage15->width) + x21)) ));
            														}
HXDLIN( 306)														int this179 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 306)														int this180;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this180 = ((((((this179 >> 24) & 255) << 24) | ((this179 & 255) << 16)) | (((this179 >> 8) & 255) << 8)) | ((this179 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this180 = this179;
            														}
HXDLIN( 306)														Float a114;
HXDLIN( 306)														int this181 = ((this180 >> 24) & 255);
HXDLIN( 306)														if ((this181 == 0)) {
HXLINE( 306)															a114 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a114 = (( (Float)(this181) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r111;
HXDLIN( 306)														int this182 = ((this180 >> 16) & 255);
HXDLIN( 306)														if ((this182 == 0)) {
HXLINE( 306)															r111 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r111 = (( (Float)(this182) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g111;
HXDLIN( 306)														int this183 = ((this180 >> 8) & 255);
HXDLIN( 306)														if ((this183 == 0)) {
HXLINE( 306)															g111 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g111 = (( (Float)(this183) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b116;
HXDLIN( 306)														int this184 = (this180 & 255);
HXDLIN( 306)														if ((this184 == 0)) {
HXLINE( 306)															b116 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b116 = (( (Float)(this184) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a212;
HXDLIN( 306)														int this185 = ((col5 >> 24) & 255);
HXDLIN( 306)														if ((this185 == 0)) {
HXLINE( 306)															a212 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a212 = (( (Float)(this185) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r211;
HXDLIN( 306)														int this186 = ((col5 >> 16) & 255);
HXDLIN( 306)														if ((this186 == 0)) {
HXLINE( 306)															r211 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r211 = (( (Float)(this186) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g211;
HXDLIN( 306)														int this187 = ((col5 >> 8) & 255);
HXDLIN( 306)														if ((this187 == 0)) {
HXLINE( 306)															g211 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g211 = (( (Float)(this187) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b214;
HXDLIN( 306)														int this188 = (col5 & 255);
HXDLIN( 306)														if ((this188 == 0)) {
HXLINE( 306)															b214 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b214 = (( (Float)(this188) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 306)														int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 306)														int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 306)														int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a311) + (b214 * a212))));
HXDLIN( 306)														int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 306)														int blended10 = ((((a43 << 24) | (r31 << 16)) | (g31 << 8)) | b44);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp44;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp44 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp44 = blended10;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage15->image,location10,_hx_tmp44);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this189 = undoImage15->image;
HXDLIN( 306)														int index24;
HXDLIN( 306)														if (undoImage15->useVirtualPos) {
HXLINE( 306)															index24 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x21) - undoImage15->virtualX));
            														}
            														else {
HXLINE( 306)															index24 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage15->width) + x21)) ));
            														}
HXDLIN( 306)														int _hx_tmp45;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp45 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp45 = c19;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this189,index24,_hx_tmp45);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear5) {
HXLINE( 306)														::Dynamic this190 = undoImage15->image;
HXDLIN( 306)														int x22 = (dx7 - rectLeft5);
HXDLIN( 306)														int y22 = (dy7 - rectTop5);
HXDLIN( 306)														int index25;
HXDLIN( 306)														if (undoImage15->useVirtualPos) {
HXLINE( 306)															index25 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x22) - undoImage15->virtualX));
            														}
            														else {
HXLINE( 306)															index25 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage15->width) + x22)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this190,index25,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min10 = xIter35->start;
HXDLIN( 306)							int _g_max10 = xIter35->max;
HXDLIN( 306)							while((_g_min10 < _g_max10)){
HXLINE( 306)								_g_min10 = (_g_min10 + 1);
HXDLIN( 306)								int px3 = (_g_min10 - 1);
HXDLIN( 306)								Float pcx3 = ( (Float)(px3) );
HXDLIN( 306)								{
HXLINE( 306)									int _g_min11 = yIter35->start;
HXDLIN( 306)									int _g_max11 = yIter35->max;
HXDLIN( 306)									while((_g_min11 < _g_max11)){
HXLINE( 306)										_g_min11 = (_g_min11 + 1);
HXDLIN( 306)										int py3 = (_g_min11 - 1);
HXDLIN( 306)										Float pcy3 = (( (Float)(py3) ) - cy5);
HXDLIN( 306)										Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 306)										Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 306)										Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 306)										Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 306)										Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 306)										bool _hx_tmp46;
HXDLIN( 306)										bool _hx_tmp47;
HXDLIN( 306)										if ((ratioA3 >= 0)) {
HXLINE( 306)											_hx_tmp47 = (ratioB3 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp47 = false;
            										}
HXDLIN( 306)										if (_hx_tmp47) {
HXLINE( 306)											_hx_tmp46 = (ratioC3 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp46 = false;
            										}
HXDLIN( 306)										if (_hx_tmp46) {
HXLINE( 306)											int i56 = ::Std_obj::_hx_int((((( (Float)(aA3) ) * ratioA3) + (( (Float)(aB3) ) * ratioB3)) + (( (Float)(aC3) ) * ratioC3)));
HXDLIN( 306)											if ((i56 > 255)) {
HXLINE(  24)												i56 = 255;
            											}
HXLINE( 306)											if ((i56 < 0)) {
HXLINE(  25)												i56 = 0;
            											}
HXLINE( 306)											int a44 = i56;
HXDLIN( 306)											int i57 = ::Std_obj::_hx_int((((( (Float)(rA3) ) * ratioA3) + (( (Float)(rB3) ) * ratioB3)) + (( (Float)(rC3) ) * ratioC3)));
HXDLIN( 306)											if ((i57 > 255)) {
HXLINE(  24)												i57 = 255;
            											}
HXLINE( 306)											if ((i57 < 0)) {
HXLINE(  25)												i57 = 0;
            											}
HXLINE( 306)											int r32 = i57;
HXDLIN( 306)											int i58 = ::Std_obj::_hx_int((((( (Float)(gA3) ) * ratioA3) + (( (Float)(gB3) ) * ratioB3)) + (( (Float)(gC3) ) * ratioC3)));
HXDLIN( 306)											if ((i58 > 255)) {
HXLINE(  24)												i58 = 255;
            											}
HXLINE( 306)											if ((i58 < 0)) {
HXLINE(  25)												i58 = 0;
            											}
HXLINE( 306)											int g32 = i58;
HXDLIN( 306)											int i59 = ::Std_obj::_hx_int((((( (Float)(bA3) ) * ratioA3) + (( (Float)(bB3) ) * ratioB3)) + (( (Float)(bC3) ) * ratioC3)));
HXDLIN( 306)											if ((i59 > 255)) {
HXLINE(  24)												i59 = 255;
            											}
HXLINE( 306)											if ((i59 < 0)) {
HXLINE(  25)												i59 = 0;
            											}
HXLINE( 306)											int b45 = i59;
HXDLIN( 306)											{
HXLINE( 306)												int location11;
HXDLIN( 306)												if (this137->useVirtualPos) {
HXLINE( 306)													location11 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this137->virtualY) * ( (Float)(this137->width) )) + px3) - this137->virtualX));
            												}
            												else {
HXLINE( 306)													location11 = ::Std_obj::_hx_int(( (Float)(((py3 * this137->width) + px3)) ));
            												}
HXDLIN( 306)												bool _hx_tmp48;
HXDLIN( 306)												if (this137->transparent) {
HXLINE( 306)													_hx_tmp48 = (a44 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp48 = false;
            												}
HXDLIN( 306)												if (_hx_tmp48) {
HXLINE( 306)													int this191 = ::iterMagic::Iimg_obj::get(this137->image,location11);
HXDLIN( 306)													int old3;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old3 = ((((((this191 >> 24) & 255) << 24) | ((this191 & 255) << 16)) | (((this191 >> 8) & 255) << 8)) | ((this191 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old3 = this191;
            													}
HXDLIN( 306)													int rhs3 = ((((a44 << 24) | (r32 << 16)) | (g32 << 8)) | b45);
HXDLIN( 306)													Float a115;
HXDLIN( 306)													int this192 = ((old3 >> 24) & 255);
HXDLIN( 306)													if ((this192 == 0)) {
HXLINE( 306)														a115 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a115 = (( (Float)(this192) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r112;
HXDLIN( 306)													int this193 = ((old3 >> 16) & 255);
HXDLIN( 306)													if ((this193 == 0)) {
HXLINE( 306)														r112 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r112 = (( (Float)(this193) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g112;
HXDLIN( 306)													int this194 = ((old3 >> 8) & 255);
HXDLIN( 306)													if ((this194 == 0)) {
HXLINE( 306)														g112 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g112 = (( (Float)(this194) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b117;
HXDLIN( 306)													int this195 = (old3 & 255);
HXDLIN( 306)													if ((this195 == 0)) {
HXLINE( 306)														b117 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b117 = (( (Float)(this195) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a213;
HXDLIN( 306)													int this196 = ((rhs3 >> 24) & 255);
HXDLIN( 306)													if ((this196 == 0)) {
HXLINE( 306)														a213 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a213 = (( (Float)(this196) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r212;
HXDLIN( 306)													int this197 = ((rhs3 >> 16) & 255);
HXDLIN( 306)													if ((this197 == 0)) {
HXLINE( 306)														r212 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r212 = (( (Float)(this197) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g212;
HXDLIN( 306)													int this198 = ((rhs3 >> 8) & 255);
HXDLIN( 306)													if ((this198 == 0)) {
HXLINE( 306)														g212 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g212 = (( (Float)(this198) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b215;
HXDLIN( 306)													int this199 = (rhs3 & 255);
HXDLIN( 306)													if ((this199 == 0)) {
HXLINE( 306)														b215 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b215 = (( (Float)(this199) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 306)													int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 306)													int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 306)													int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a312) + (b215 * a213))));
HXDLIN( 306)													int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 306)													int blended11 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b46);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp49;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp49 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp49 = blended11;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this137->image,location11,_hx_tmp49);
            													}
            												}
            												else {
HXLINE( 306)													int value3;
HXDLIN( 306)													if (this137->isLittle) {
HXLINE( 306)														value3 = ((((a44 << 24) | (b45 << 16)) | (g32 << 8)) | r32);
            													}
            													else {
HXLINE( 306)														value3 = ((((a44 << 24) | (r32 << 16)) | (g32 << 8)) | b45);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this137->image,location11,value3);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit5 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v19 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx3,y16,bx3,cy5,( (Float)(0) ),cy5,true);
HXDLIN( 306)							if (hasUndo5) {
HXLINE( 306)								v19->undoImage = undoImage15;
HXDLIN( 306)								v19->undoX = xIter35->start;
HXDLIN( 306)								v19->undoY = yIter35->start;
            							}
            						}
            					}
HXDLIN( 306)					if ((hasHit4 == true)) {
HXLINE( 306)						 ::pi_xy::algo::HitQuad v20 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,( (Float)(0) ),y16,bx3,y16,bx3,cy5,( (Float)(0) ),cy5,true);
            					}
            				}
            			}
HXDLIN( 306)			int inlobj_ax1 = 0;
HXDLIN( 306)			Float inlobj_ay1 = y16;
HXDLIN( 306)			Float inlobj_bx1 = bx3;
HXDLIN( 306)			Float inlobj_y1 = y16;
HXDLIN( 306)			Float inlobj_cx1 = bx3;
HXDLIN( 306)			Float inlobj_cy1 = cy5;
HXDLIN( 306)			int inlobj_x1 = 0;
HXDLIN( 306)			Float inlobj_dy1 = cy5;
HXDLIN( 306)			 ::pi_xy::ImageStruct this200 = temp;
HXDLIN( 306)			Float x23 = ( (Float)(dx1) );
HXDLIN( 306)			Float y23 = ( (Float)(dy1) );
HXDLIN( 306)			Float bx4 = (x23 + ( (Float)(fat1) ));
HXDLIN( 306)			Float cy6 = (y23 + ( (Float)(tall1) ));
HXDLIN( 306)			{
HXLINE( 306)				bool hasHit6 = true;
HXDLIN( 306)				{
HXLINE( 306)					{
HXLINE( 306)						bool hasUndo6 = false;
HXDLIN( 306)						int aA4 = ((colorC >> 24) & 255);
HXDLIN( 306)						int rA4 = ((colorC >> 16) & 255);
HXDLIN( 306)						int gA4 = ((colorC >> 8) & 255);
HXDLIN( 306)						int bA4 = (colorC & 255);
HXDLIN( 306)						int aB4 = ((colorA >> 24) & 255);
HXDLIN( 306)						int rB4 = ((colorA >> 16) & 255);
HXDLIN( 306)						int gB4 = ((colorA >> 8) & 255);
HXDLIN( 306)						int bB4 = (colorA & 255);
HXDLIN( 306)						int aC4 = ((colorD >> 24) & 255);
HXDLIN( 306)						int rC4 = ((colorD >> 16) & 255);
HXDLIN( 306)						int gC4 = ((colorD >> 8) & 255);
HXDLIN( 306)						int bC4 = (colorD & 255);
HXDLIN( 306)						Float bcx4 = (bx4 - x23);
HXDLIN( 306)						Float bcy4 = (y23 - cy6);
HXDLIN( 306)						Float acx4 = (x23 - x23);
HXDLIN( 306)						Float acy4 = (y23 - cy6);
HXDLIN( 306)						Float dot114 = ((bcx4 * bcx4) + (bcy4 * bcy4));
HXDLIN( 306)						Float dot124 = ((bcx4 * acx4) + (bcy4 * acy4));
HXDLIN( 306)						Float dot224 = ((acx4 * acx4) + (acy4 * acy4));
HXDLIN( 306)						Float denom14 = (( (Float)(1) ) / ((dot114 * dot224) - (dot124 * dot124)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 306)						if ((x23 > bx4)) {
HXLINE( 306)							if ((x23 > x23)) {
HXLINE( 306)								int min21;
HXDLIN( 306)								if ((bx4 > x23)) {
HXLINE( 306)									min21 = ::Math_obj::floor(x23);
            								}
            								else {
HXLINE( 306)									min21 = ::Math_obj::floor(bx4);
            								}
HXDLIN( 306)								int ii_min45 = min21;
HXDLIN( 306)								int ii_max45 = ::Math_obj::ceil(x23);
HXDLIN( 306)								xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            							}
            							else {
HXLINE( 306)								int ii_min46 = ::Math_obj::floor(bx4);
HXDLIN( 306)								int ii_max46 = ::Math_obj::ceil(x23);
HXDLIN( 306)								xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx4 > x23)) {
HXLINE( 306)								int min22;
HXDLIN( 306)								if ((x23 > x23)) {
HXLINE( 306)									min22 = ::Math_obj::floor(x23);
            								}
            								else {
HXLINE( 306)									min22 = ::Math_obj::ceil(x23);
            								}
HXDLIN( 306)								int ii_min47 = min22;
HXDLIN( 306)								int ii_max47 = ::Math_obj::ceil(bx4);
HXDLIN( 306)								xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            							}
            							else {
HXLINE( 306)								int ii_min48 = ::Math_obj::floor(x23);
HXDLIN( 306)								int ii_max48 = ::Math_obj::ceil(x23);
HXDLIN( 306)								xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 306)						if ((y23 > y23)) {
HXLINE( 306)							if ((y23 > cy6)) {
HXLINE( 306)								int min23;
HXDLIN( 306)								if ((y23 > cy6)) {
HXLINE( 306)									min23 = ::Math_obj::floor(cy6);
            								}
            								else {
HXLINE( 306)									min23 = ::Math_obj::floor(y23);
            								}
HXDLIN( 306)								int ii_min49 = min23;
HXDLIN( 306)								int ii_max49 = ::Math_obj::ceil(y23);
HXDLIN( 306)								yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            							}
            							else {
HXLINE( 306)								int ii_min50 = ::Math_obj::floor(y23);
HXDLIN( 306)								int ii_max50 = ::Math_obj::ceil(cy6);
HXDLIN( 306)								yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            							}
            						}
            						else {
HXLINE( 306)							if ((y23 > cy6)) {
HXLINE( 306)								int min24;
HXDLIN( 306)								if ((y23 > cy6)) {
HXLINE( 306)									min24 = ::Math_obj::floor(cy6);
            								}
            								else {
HXLINE( 306)									min24 = ::Math_obj::ceil(y23);
            								}
HXDLIN( 306)								int ii_min51 = min24;
HXDLIN( 306)								int ii_max51 = ::Math_obj::ceil(y23);
HXDLIN( 306)								yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            							}
            							else {
HXLINE( 306)								int ii_min52 = ::Math_obj::floor(y23);
HXDLIN( 306)								int ii_max52 = ::Math_obj::ceil(cy6);
HXDLIN( 306)								yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 306)						if (hasUndo6) {
HXLINE( 306)							int width7 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 306)							int height7 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType7 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this201 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType7 )) {
HXLINE(  54)								imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage19;
HXDLIN( 306)							switch((int)(( (int)(imageType7) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b47 = byt7;
HXDLIN( 306)									{
HXLINE( 306)										b47->width = width7;
HXDLIN( 306)										b47->height = height7;
HXDLIN( 306)										b47->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 306)										b47->data = ::haxe::io::Bytes_obj::alloc((b47->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len14 = b47->length;
HXDLIN( 306)											int w7 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g140 = 0;
HXDLIN( 306)												int _g141 = b47->height;
HXDLIN( 306)												while((_g140 < _g141)){
HXLINE( 306)													_g140 = (_g140 + 1);
HXDLIN( 306)													int y24 = (_g140 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g142 = 0;
HXDLIN( 306)														int _g143 = b47->width;
HXDLIN( 306)														while((_g142 < _g143)){
HXLINE( 306)															_g142 = (_g142 + 1);
HXDLIN( 306)															int x24 = (_g142 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w7 = (w7 + 1);
HXDLIN( 306)																b47->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w7 = (w7 + 1);
HXDLIN( 306)																b47->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w7 = (w7 + 1);
HXDLIN( 306)																b47->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w7 = (w7 + 1);
HXDLIN( 306)																b47->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage19 = b47;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a46 = arrI7;
HXDLIN( 306)									{
HXLINE( 306)										a46->width = width7;
HXDLIN( 306)										a46->height = height7;
HXDLIN( 306)										a46->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a46->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g144 = 0;
HXDLIN( 306)											int _g145 = a46->length;
HXDLIN( 306)											while((_g144 < _g145)){
HXLINE( 306)												_g144 = (_g144 + 1);
HXDLIN( 306)												int i60 = (_g144 - 1);
HXDLIN( 306)												a46->data[i60] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage19 = a46;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b48 = u32a7;
HXDLIN( 306)									{
HXLINE( 306)										b48->width = width7;
HXDLIN( 306)										b48->height = height7;
HXDLIN( 306)										b48->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 306)										int size7 = (b48->length * 4);
HXDLIN( 306)										b48->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN( 306)										{
HXLINE( 306)											int _g146 = 0;
HXDLIN( 306)											int _g147 = b48->length;
HXDLIN( 306)											while((_g146 < _g147)){
HXLINE( 306)												_g146 = (_g146 + 1);
HXDLIN( 306)												int i61 = (_g146 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this202 = b48->data;
HXDLIN( 306)													bool undoImage20;
HXDLIN( 306)													if ((i61 >= 0)) {
HXLINE( 306)														undoImage20 = (i61 < (this202->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage20 = false;
            													}
HXDLIN( 306)													if (undoImage20) {
HXLINE( 306)														 ::haxe::io::Bytes _this7 = this202->bytes;
HXDLIN( 306)														int pos7 = ((i61 << 2) + this202->byteOffset);
HXDLIN( 306)														_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN( 306)														_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage19 = b48;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v21 = vec7;
HXDLIN( 306)									{
HXLINE( 306)										v21->width = width7;
HXDLIN( 306)										v21->height = height7;
HXDLIN( 306)										v21->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 306)										v21->data = ::Array_obj< int >::__new(v21->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g148 = 0;
HXDLIN( 306)											int _g149 = v21->length;
HXDLIN( 306)											while((_g148 < _g149)){
HXLINE( 306)												_g148 = (_g148 + 1);
HXDLIN( 306)												int i62 = (_g148 - 1);
HXDLIN( 306)												v21->data->__unsafe_set(i62,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage19 = v21;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b49 = sInt7;
HXDLIN( 306)									{
HXLINE( 306)										b49->width = width7;
HXDLIN( 306)										b49->height = height7;
HXDLIN( 306)										b49->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 306)										b49->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len15 = b49->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d7 = b49->data;
HXDLIN( 306)											if (::hx::IsNull( d7->head )) {
HXLINE( 306)												int _g150 = 0;
HXDLIN( 306)												int _g151 = len15;
HXDLIN( 306)												while((_g150 < _g151)){
HXLINE( 306)													_g150 = (_g150 + 1);
HXDLIN( 306)													int i63 = (_g150 - 1);
HXDLIN( 306)													d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g152 = 0;
HXDLIN( 306)												int _g153 = len15;
HXDLIN( 306)												while((_g152 < _g153)){
HXLINE( 306)													_g152 = (_g152 + 1);
HXDLIN( 306)													int i64 = (_g152 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l7 = b49->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g154 = 0;
HXDLIN( 306)															int _g155 = i64;
HXDLIN( 306)															while((_g154 < _g155)){
HXLINE( 306)																_g154 = (_g154 + 1);
HXDLIN( 306)																int i65 = (_g154 - 1);
HXLINE( 345)																prev7 = l7;
HXLINE( 346)																l7 = l7->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev7 )) {
HXLINE( 306)															b49->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 306)															l7 = null();
            														}
            														else {
HXLINE( 306)															prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 306)															l7 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage19 = b49;
            								}
            								break;
            							}
HXDLIN( 306)							this201->image = undoImage19;
HXDLIN( 306)							this201->width = width7;
HXDLIN( 306)							this201->height = height7;
HXDLIN( 306)							this201->imageType = ( (int)(imageType7) );
HXDLIN( 306)							undoImage18 = this201;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft6 = xIter36->start;
HXDLIN( 306)								int rectTop6 = yIter36->start;
HXDLIN( 306)								int rectRight6 = xIter36->max;
HXDLIN( 306)								bool forceClear6 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g156 = rectTop6;
HXDLIN( 306)									int _g157 = yIter36->max;
HXDLIN( 306)									while((_g156 < _g157)){
HXLINE( 306)										_g156 = (_g156 + 1);
HXDLIN( 306)										int dy8 = (_g156 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g158 = rectLeft6;
HXDLIN( 306)											int _g159 = rectRight6;
HXDLIN( 306)											while((_g158 < _g159)){
HXLINE( 306)												_g158 = (_g158 + 1);
HXDLIN( 306)												int dx8 = (_g158 - 1);
HXDLIN( 306)												::Dynamic this203 = this200->image;
HXDLIN( 306)												int index26;
HXDLIN( 306)												if (this200->useVirtualPos) {
HXLINE( 306)													index26 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this200->virtualY) * ( (Float)(this200->width) )) + dx8) - this200->virtualX));
            												}
            												else {
HXLINE( 306)													index26 = ::Std_obj::_hx_int(( (Float)(((dy8 * this200->width) + dx8)) ));
            												}
HXDLIN( 306)												int c20 = ::iterMagic::Iimg_obj::get(this203,index26);
HXDLIN( 306)												int col6;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col6 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col6 = c20;
            												}
HXDLIN( 306)												bool _hx_tmp50;
HXDLIN( 306)												if (this200->useMask) {
HXLINE( 306)													_hx_tmp50 = ::hx::IsNotNull( this200->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp50 = false;
            												}
HXDLIN( 306)												if (_hx_tmp50) {
HXLINE( 306)													 ::pi_xy::ImageStruct this204 = this200->mask;
HXDLIN( 306)													::Dynamic this205 = this204->image;
HXDLIN( 306)													int index27;
HXDLIN( 306)													if (this204->useVirtualPos) {
HXLINE( 306)														index27 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this204->virtualY) * ( (Float)(this204->width) )) + dx8) - this204->virtualX));
            													}
            													else {
HXLINE( 306)														index27 = ::Std_obj::_hx_int(( (Float)(((dy8 * this204->width) + dx8)) ));
            													}
HXDLIN( 306)													int c21 = ::iterMagic::Iimg_obj::get(this205,index27);
HXDLIN( 306)													int v22;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v22 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v22 = c21;
            													}
HXDLIN( 306)													int maskPixel6 = v22;
HXDLIN( 306)													int this206 = col6;
HXDLIN( 306)													if ((maskPixel6 == 0)) {
HXLINE( 306)														col6 = this206;
            													}
            													else {
HXLINE( 306)														Float m06;
HXDLIN( 306)														int this207 = ((maskPixel6 >> 24) & 255);
HXDLIN( 306)														if ((this207 == 0)) {
HXLINE( 306)															m06 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m06 = (( (Float)(this207) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m16;
HXDLIN( 306)														int this208 = ((maskPixel6 >> 16) & 255);
HXDLIN( 306)														if ((this208 == 0)) {
HXLINE( 306)															m16 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m16 = (( (Float)(this208) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m26;
HXDLIN( 306)														int this209 = ((maskPixel6 >> 8) & 255);
HXDLIN( 306)														if ((this209 == 0)) {
HXLINE( 306)															m26 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m26 = (( (Float)(this209) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m36;
HXDLIN( 306)														int this210 = (maskPixel6 & 255);
HXDLIN( 306)														if ((this210 == 0)) {
HXLINE( 306)															m36 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m36 = (( (Float)(this210) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this206 >> 24) & 255)) )));
HXDLIN( 306)														int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this206 >> 16) & 255)) )));
HXDLIN( 306)														int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this206 >> 8) & 255)) )));
HXDLIN( 306)														int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this206 & 255)) )));
HXDLIN( 306)														col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col6 != 0)) {
HXLINE( 306)													int x25 = (dx8 - rectLeft6);
HXDLIN( 306)													int y25 = (dy8 - rectTop6);
HXDLIN( 306)													int c22 = col6;
HXDLIN( 306)													bool _hx_tmp51;
HXDLIN( 306)													if ((((c22 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp51 = undoImage18->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp51 = false;
            													}
HXDLIN( 306)													if (_hx_tmp51) {
HXLINE( 306)														int location12;
HXDLIN( 306)														if (undoImage18->useVirtualPos) {
HXLINE( 306)															location12 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x25) - undoImage18->virtualX));
            														}
            														else {
HXLINE( 306)															location12 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage18->width) + x25)) ));
            														}
HXDLIN( 306)														int this211 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 306)														int this212;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this212 = ((((((this211 >> 24) & 255) << 24) | ((this211 & 255) << 16)) | (((this211 >> 8) & 255) << 8)) | ((this211 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this212 = this211;
            														}
HXDLIN( 306)														Float a116;
HXDLIN( 306)														int this213 = ((this212 >> 24) & 255);
HXDLIN( 306)														if ((this213 == 0)) {
HXLINE( 306)															a116 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a116 = (( (Float)(this213) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r113;
HXDLIN( 306)														int this214 = ((this212 >> 16) & 255);
HXDLIN( 306)														if ((this214 == 0)) {
HXLINE( 306)															r113 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r113 = (( (Float)(this214) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g113;
HXDLIN( 306)														int this215 = ((this212 >> 8) & 255);
HXDLIN( 306)														if ((this215 == 0)) {
HXLINE( 306)															g113 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g113 = (( (Float)(this215) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b118;
HXDLIN( 306)														int this216 = (this212 & 255);
HXDLIN( 306)														if ((this216 == 0)) {
HXLINE( 306)															b118 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b118 = (( (Float)(this216) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a214;
HXDLIN( 306)														int this217 = ((col6 >> 24) & 255);
HXDLIN( 306)														if ((this217 == 0)) {
HXLINE( 306)															a214 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a214 = (( (Float)(this217) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r213;
HXDLIN( 306)														int this218 = ((col6 >> 16) & 255);
HXDLIN( 306)														if ((this218 == 0)) {
HXLINE( 306)															r213 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r213 = (( (Float)(this218) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g213;
HXDLIN( 306)														int this219 = ((col6 >> 8) & 255);
HXDLIN( 306)														if ((this219 == 0)) {
HXLINE( 306)															g213 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g213 = (( (Float)(this219) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b216;
HXDLIN( 306)														int this220 = (col6 & 255);
HXDLIN( 306)														if ((this220 == 0)) {
HXLINE( 306)															b216 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b216 = (( (Float)(this220) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN( 306)														int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 306)														int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 306)														int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a313) + (b216 * a214))));
HXDLIN( 306)														int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 306)														int blended12 = ((((a47 << 24) | (r34 << 16)) | (g34 << 8)) | b50);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp52;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp52 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp52 = blended12;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp52);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this221 = undoImage18->image;
HXDLIN( 306)														int index28;
HXDLIN( 306)														if (undoImage18->useVirtualPos) {
HXLINE( 306)															index28 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x25) - undoImage18->virtualX));
            														}
            														else {
HXLINE( 306)															index28 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage18->width) + x25)) ));
            														}
HXDLIN( 306)														int _hx_tmp53;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp53 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp53 = c22;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this221,index28,_hx_tmp53);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear6) {
HXLINE( 306)														::Dynamic this222 = undoImage18->image;
HXDLIN( 306)														int x26 = (dx8 - rectLeft6);
HXDLIN( 306)														int y26 = (dy8 - rectTop6);
HXDLIN( 306)														int index29;
HXDLIN( 306)														if (undoImage18->useVirtualPos) {
HXLINE( 306)															index29 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x26) - undoImage18->virtualX));
            														}
            														else {
HXLINE( 306)															index29 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage18->width) + x26)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this222,index29,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min12 = xIter36->start;
HXDLIN( 306)							int _g_max12 = xIter36->max;
HXDLIN( 306)							while((_g_min12 < _g_max12)){
HXLINE( 306)								_g_min12 = (_g_min12 + 1);
HXDLIN( 306)								int px4 = (_g_min12 - 1);
HXDLIN( 306)								Float pcx4 = (( (Float)(px4) ) - x23);
HXDLIN( 306)								{
HXLINE( 306)									int _g_min13 = yIter36->start;
HXDLIN( 306)									int _g_max13 = yIter36->max;
HXDLIN( 306)									while((_g_min13 < _g_max13)){
HXLINE( 306)										_g_min13 = (_g_min13 + 1);
HXDLIN( 306)										int py4 = (_g_min13 - 1);
HXDLIN( 306)										Float pcy4 = (( (Float)(py4) ) - cy6);
HXDLIN( 306)										Float dot314 = ((pcx4 * bcx4) + (pcy4 * bcy4));
HXDLIN( 306)										Float dot324 = ((pcx4 * acx4) + (pcy4 * acy4));
HXDLIN( 306)										Float ratioA4 = (((dot224 * dot314) - (dot124 * dot324)) * denom14);
HXDLIN( 306)										Float ratioB4 = (((dot114 * dot324) - (dot124 * dot314)) * denom14);
HXDLIN( 306)										Float ratioC4 = ((((Float)1.0) - ratioB4) - ratioA4);
HXDLIN( 306)										bool _hx_tmp54;
HXDLIN( 306)										bool _hx_tmp55;
HXDLIN( 306)										if ((ratioA4 >= 0)) {
HXLINE( 306)											_hx_tmp55 = (ratioB4 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp55 = false;
            										}
HXDLIN( 306)										if (_hx_tmp55) {
HXLINE( 306)											_hx_tmp54 = (ratioC4 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp54 = false;
            										}
HXDLIN( 306)										if (_hx_tmp54) {
HXLINE( 306)											int i66 = ::Std_obj::_hx_int((((( (Float)(aA4) ) * ratioA4) + (( (Float)(aB4) ) * ratioB4)) + (( (Float)(aC4) ) * ratioC4)));
HXDLIN( 306)											if ((i66 > 255)) {
HXLINE(  24)												i66 = 255;
            											}
HXLINE( 306)											if ((i66 < 0)) {
HXLINE(  25)												i66 = 0;
            											}
HXLINE( 306)											int a48 = i66;
HXDLIN( 306)											int i67 = ::Std_obj::_hx_int((((( (Float)(rA4) ) * ratioA4) + (( (Float)(rB4) ) * ratioB4)) + (( (Float)(rC4) ) * ratioC4)));
HXDLIN( 306)											if ((i67 > 255)) {
HXLINE(  24)												i67 = 255;
            											}
HXLINE( 306)											if ((i67 < 0)) {
HXLINE(  25)												i67 = 0;
            											}
HXLINE( 306)											int r35 = i67;
HXDLIN( 306)											int i68 = ::Std_obj::_hx_int((((( (Float)(gA4) ) * ratioA4) + (( (Float)(gB4) ) * ratioB4)) + (( (Float)(gC4) ) * ratioC4)));
HXDLIN( 306)											if ((i68 > 255)) {
HXLINE(  24)												i68 = 255;
            											}
HXLINE( 306)											if ((i68 < 0)) {
HXLINE(  25)												i68 = 0;
            											}
HXLINE( 306)											int g35 = i68;
HXDLIN( 306)											int i69 = ::Std_obj::_hx_int((((( (Float)(bA4) ) * ratioA4) + (( (Float)(bB4) ) * ratioB4)) + (( (Float)(bC4) ) * ratioC4)));
HXDLIN( 306)											if ((i69 > 255)) {
HXLINE(  24)												i69 = 255;
            											}
HXLINE( 306)											if ((i69 < 0)) {
HXLINE(  25)												i69 = 0;
            											}
HXLINE( 306)											int b51 = i69;
HXDLIN( 306)											{
HXLINE( 306)												int location13;
HXDLIN( 306)												if (this200->useVirtualPos) {
HXLINE( 306)													location13 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - this200->virtualY) * ( (Float)(this200->width) )) + px4) - this200->virtualX));
            												}
            												else {
HXLINE( 306)													location13 = ::Std_obj::_hx_int(( (Float)(((py4 * this200->width) + px4)) ));
            												}
HXDLIN( 306)												bool _hx_tmp56;
HXDLIN( 306)												if (this200->transparent) {
HXLINE( 306)													_hx_tmp56 = (a48 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp56 = false;
            												}
HXDLIN( 306)												if (_hx_tmp56) {
HXLINE( 306)													int this223 = ::iterMagic::Iimg_obj::get(this200->image,location13);
HXDLIN( 306)													int old4;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old4 = ((((((this223 >> 24) & 255) << 24) | ((this223 & 255) << 16)) | (((this223 >> 8) & 255) << 8)) | ((this223 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old4 = this223;
            													}
HXDLIN( 306)													int rhs4 = ((((a48 << 24) | (r35 << 16)) | (g35 << 8)) | b51);
HXDLIN( 306)													Float a117;
HXDLIN( 306)													int this224 = ((old4 >> 24) & 255);
HXDLIN( 306)													if ((this224 == 0)) {
HXLINE( 306)														a117 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a117 = (( (Float)(this224) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r114;
HXDLIN( 306)													int this225 = ((old4 >> 16) & 255);
HXDLIN( 306)													if ((this225 == 0)) {
HXLINE( 306)														r114 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r114 = (( (Float)(this225) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g114;
HXDLIN( 306)													int this226 = ((old4 >> 8) & 255);
HXDLIN( 306)													if ((this226 == 0)) {
HXLINE( 306)														g114 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g114 = (( (Float)(this226) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b119;
HXDLIN( 306)													int this227 = (old4 & 255);
HXDLIN( 306)													if ((this227 == 0)) {
HXLINE( 306)														b119 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b119 = (( (Float)(this227) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a215;
HXDLIN( 306)													int this228 = ((rhs4 >> 24) & 255);
HXDLIN( 306)													if ((this228 == 0)) {
HXLINE( 306)														a215 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a215 = (( (Float)(this228) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r214;
HXDLIN( 306)													int this229 = ((rhs4 >> 16) & 255);
HXDLIN( 306)													if ((this229 == 0)) {
HXLINE( 306)														r214 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r214 = (( (Float)(this229) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g214;
HXDLIN( 306)													int this230 = ((rhs4 >> 8) & 255);
HXDLIN( 306)													if ((this230 == 0)) {
HXLINE( 306)														g214 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g214 = (( (Float)(this230) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b217;
HXDLIN( 306)													int this231 = (rhs4 & 255);
HXDLIN( 306)													if ((this231 == 0)) {
HXLINE( 306)														b217 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b217 = (( (Float)(this231) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN( 306)													int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 306)													int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 306)													int b52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a314) + (b217 * a215))));
HXDLIN( 306)													int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 306)													int blended13 = ((((a49 << 24) | (r36 << 16)) | (g36 << 8)) | b52);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp57;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp57 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp57 = blended13;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this200->image,location13,_hx_tmp57);
            													}
            												}
            												else {
HXLINE( 306)													int value4;
HXDLIN( 306)													if (this200->isLittle) {
HXLINE( 306)														value4 = ((((a48 << 24) | (b51 << 16)) | (g35 << 8)) | r35);
            													}
            													else {
HXLINE( 306)														value4 = ((((a48 << 24) | (r35 << 16)) | (g35 << 8)) | b51);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this200->image,location13,value4);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit6 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v23 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x23,y23,bx4,y23,x23,cy6,true);
HXDLIN( 306)							if (hasUndo6) {
HXLINE( 306)								v23->undoImage = undoImage18;
HXDLIN( 306)								v23->undoX = xIter36->start;
HXDLIN( 306)								v23->undoY = yIter36->start;
            							}
            						}
            					}
HXDLIN( 306)					{
HXLINE( 306)						bool hasHit7 = false;
HXDLIN( 306)						bool hasUndo7 = false;
HXDLIN( 306)						int aA5 = ((colorB >> 24) & 255);
HXDLIN( 306)						int rA5 = ((colorB >> 16) & 255);
HXDLIN( 306)						int gA5 = ((colorB >> 8) & 255);
HXDLIN( 306)						int bA5 = (colorB & 255);
HXDLIN( 306)						int aB5 = ((colorC >> 24) & 255);
HXDLIN( 306)						int rB5 = ((colorC >> 16) & 255);
HXDLIN( 306)						int gB5 = ((colorC >> 8) & 255);
HXDLIN( 306)						int bB5 = (colorC & 255);
HXDLIN( 306)						int aC5 = ((colorD >> 24) & 255);
HXDLIN( 306)						int rC5 = ((colorD >> 16) & 255);
HXDLIN( 306)						int gC5 = ((colorD >> 8) & 255);
HXDLIN( 306)						int bC5 = (colorD & 255);
HXDLIN( 306)						Float bcx5 = (bx4 - x23);
HXDLIN( 306)						Float bcy5 = (cy6 - cy6);
HXDLIN( 306)						Float acx5 = (bx4 - x23);
HXDLIN( 306)						Float acy5 = (y23 - cy6);
HXDLIN( 306)						Float dot115 = ((bcx5 * bcx5) + (bcy5 * bcy5));
HXDLIN( 306)						Float dot125 = ((bcx5 * acx5) + (bcy5 * acy5));
HXDLIN( 306)						Float dot225 = ((acx5 * acx5) + (acy5 * acy5));
HXDLIN( 306)						Float denom15 = (( (Float)(1) ) / ((dot115 * dot225) - (dot125 * dot125)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter37;
HXDLIN( 306)						if ((bx4 > bx4)) {
HXLINE( 306)							if ((bx4 > x23)) {
HXLINE( 306)								int min25;
HXDLIN( 306)								if ((bx4 > x23)) {
HXLINE( 306)									min25 = ::Math_obj::floor(x23);
            								}
            								else {
HXLINE( 306)									min25 = ::Math_obj::floor(bx4);
            								}
HXDLIN( 306)								int ii_min53 = min25;
HXDLIN( 306)								int ii_max53 = ::Math_obj::ceil(bx4);
HXDLIN( 306)								xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            							}
            							else {
HXLINE( 306)								int ii_min54 = ::Math_obj::floor(bx4);
HXDLIN( 306)								int ii_max54 = ::Math_obj::ceil(x23);
HXDLIN( 306)								xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx4 > x23)) {
HXLINE( 306)								int min26;
HXDLIN( 306)								if ((bx4 > x23)) {
HXLINE( 306)									min26 = ::Math_obj::floor(x23);
            								}
            								else {
HXLINE( 306)									min26 = ::Math_obj::ceil(bx4);
            								}
HXDLIN( 306)								int ii_min55 = min26;
HXDLIN( 306)								int ii_max55 = ::Math_obj::ceil(bx4);
HXDLIN( 306)								xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            							}
            							else {
HXLINE( 306)								int ii_min56 = ::Math_obj::floor(bx4);
HXDLIN( 306)								int ii_max56 = ::Math_obj::ceil(x23);
HXDLIN( 306)								xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter37;
HXDLIN( 306)						if ((y23 > cy6)) {
HXLINE( 306)							if ((y23 > cy6)) {
HXLINE( 306)								int min27;
HXDLIN( 306)								if ((cy6 > cy6)) {
HXLINE( 306)									min27 = ::Math_obj::floor(cy6);
            								}
            								else {
HXLINE( 306)									min27 = ::Math_obj::floor(cy6);
            								}
HXDLIN( 306)								int ii_min57 = min27;
HXDLIN( 306)								int ii_max57 = ::Math_obj::ceil(y23);
HXDLIN( 306)								yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            							}
            							else {
HXLINE( 306)								int ii_min58 = ::Math_obj::floor(cy6);
HXDLIN( 306)								int ii_max58 = ::Math_obj::ceil(cy6);
HXDLIN( 306)								yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            							}
            						}
            						else {
HXLINE( 306)							if ((cy6 > cy6)) {
HXLINE( 306)								int min28;
HXDLIN( 306)								if ((y23 > cy6)) {
HXLINE( 306)									min28 = ::Math_obj::floor(cy6);
            								}
            								else {
HXLINE( 306)									min28 = ::Math_obj::ceil(y23);
            								}
HXDLIN( 306)								int ii_min59 = min28;
HXDLIN( 306)								int ii_max59 = ::Math_obj::ceil(cy6);
HXDLIN( 306)								yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            							}
            							else {
HXLINE( 306)								int ii_min60 = ::Math_obj::floor(y23);
HXDLIN( 306)								int ii_max60 = ::Math_obj::ceil(cy6);
HXDLIN( 306)								yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage21 = null();
HXDLIN( 306)						if (hasUndo7) {
HXLINE( 306)							int width8 = ((xIter37->max - xIter37->start) + 1);
HXDLIN( 306)							int height8 = ((yIter37->max - yIter37->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType8 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this232 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType8 )) {
HXLINE(  54)								imageType8 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage22;
HXDLIN( 306)							switch((int)(( (int)(imageType8) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt8 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b53 = byt8;
HXDLIN( 306)									{
HXLINE( 306)										b53->width = width8;
HXDLIN( 306)										b53->height = height8;
HXDLIN( 306)										b53->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 306)										b53->data = ::haxe::io::Bytes_obj::alloc((b53->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len16 = b53->length;
HXDLIN( 306)											int w8 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g160 = 0;
HXDLIN( 306)												int _g161 = b53->height;
HXDLIN( 306)												while((_g160 < _g161)){
HXLINE( 306)													_g160 = (_g160 + 1);
HXDLIN( 306)													int y27 = (_g160 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g162 = 0;
HXDLIN( 306)														int _g163 = b53->width;
HXDLIN( 306)														while((_g162 < _g163)){
HXLINE( 306)															_g162 = (_g162 + 1);
HXDLIN( 306)															int x27 = (_g162 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w8 = (w8 + 1);
HXDLIN( 306)																b53->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w8 = (w8 + 1);
HXDLIN( 306)																b53->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w8 = (w8 + 1);
HXDLIN( 306)																b53->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w8 = (w8 + 1);
HXDLIN( 306)																b53->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage22 = b53;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI8 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a50 = arrI8;
HXDLIN( 306)									{
HXLINE( 306)										a50->width = width8;
HXDLIN( 306)										a50->height = height8;
HXDLIN( 306)										a50->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a50->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g164 = 0;
HXDLIN( 306)											int _g165 = a50->length;
HXDLIN( 306)											while((_g164 < _g165)){
HXLINE( 306)												_g164 = (_g164 + 1);
HXDLIN( 306)												int i70 = (_g164 - 1);
HXDLIN( 306)												a50->data[i70] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage22 = a50;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a8 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b54 = u32a8;
HXDLIN( 306)									{
HXLINE( 306)										b54->width = width8;
HXDLIN( 306)										b54->height = height8;
HXDLIN( 306)										b54->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 306)										int size8 = (b54->length * 4);
HXDLIN( 306)										b54->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size8),0,size8);
HXDLIN( 306)										{
HXLINE( 306)											int _g166 = 0;
HXDLIN( 306)											int _g167 = b54->length;
HXDLIN( 306)											while((_g166 < _g167)){
HXLINE( 306)												_g166 = (_g166 + 1);
HXDLIN( 306)												int i71 = (_g166 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this233 = b54->data;
HXDLIN( 306)													bool undoImage23;
HXDLIN( 306)													if ((i71 >= 0)) {
HXLINE( 306)														undoImage23 = (i71 < (this233->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage23 = false;
            													}
HXDLIN( 306)													if (undoImage23) {
HXLINE( 306)														 ::haxe::io::Bytes _this8 = this233->bytes;
HXDLIN( 306)														int pos8 = ((i71 << 2) + this233->byteOffset);
HXDLIN( 306)														_this8->b[pos8] = ( (unsigned char)(0) );
HXDLIN( 306)														_this8->b[(pos8 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this8->b[(pos8 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this8->b[(pos8 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage22 = b54;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec8 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v24 = vec8;
HXDLIN( 306)									{
HXLINE( 306)										v24->width = width8;
HXDLIN( 306)										v24->height = height8;
HXDLIN( 306)										v24->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 306)										v24->data = ::Array_obj< int >::__new(v24->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g168 = 0;
HXDLIN( 306)											int _g169 = v24->length;
HXDLIN( 306)											while((_g168 < _g169)){
HXLINE( 306)												_g168 = (_g168 + 1);
HXDLIN( 306)												int i72 = (_g168 - 1);
HXDLIN( 306)												v24->data->__unsafe_set(i72,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage22 = v24;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt8 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b55 = sInt8;
HXDLIN( 306)									{
HXLINE( 306)										b55->width = width8;
HXDLIN( 306)										b55->height = height8;
HXDLIN( 306)										b55->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 306)										b55->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len17 = b55->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d8 = b55->data;
HXDLIN( 306)											if (::hx::IsNull( d8->head )) {
HXLINE( 306)												int _g170 = 0;
HXDLIN( 306)												int _g171 = len17;
HXDLIN( 306)												while((_g170 < _g171)){
HXLINE( 306)													_g170 = (_g170 + 1);
HXDLIN( 306)													int i73 = (_g170 - 1);
HXDLIN( 306)													d8->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d8->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g172 = 0;
HXDLIN( 306)												int _g173 = len17;
HXDLIN( 306)												while((_g172 < _g173)){
HXLINE( 306)													_g172 = (_g172 + 1);
HXDLIN( 306)													int i74 = (_g172 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l8 = b55->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev8 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g174 = 0;
HXDLIN( 306)															int _g175 = i74;
HXDLIN( 306)															while((_g174 < _g175)){
HXLINE( 306)																_g174 = (_g174 + 1);
HXDLIN( 306)																int i75 = (_g174 - 1);
HXLINE( 345)																prev8 = l8;
HXLINE( 346)																l8 = l8->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev8 )) {
HXLINE( 306)															b55->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 306)															l8 = null();
            														}
            														else {
HXLINE( 306)															prev8->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 306)															l8 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage22 = b55;
            								}
            								break;
            							}
HXDLIN( 306)							this232->image = undoImage22;
HXDLIN( 306)							this232->width = width8;
HXDLIN( 306)							this232->height = height8;
HXDLIN( 306)							this232->imageType = ( (int)(imageType8) );
HXDLIN( 306)							undoImage21 = this232;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft7 = xIter37->start;
HXDLIN( 306)								int rectTop7 = yIter37->start;
HXDLIN( 306)								int rectRight7 = xIter37->max;
HXDLIN( 306)								bool forceClear7 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g176 = rectTop7;
HXDLIN( 306)									int _g177 = yIter37->max;
HXDLIN( 306)									while((_g176 < _g177)){
HXLINE( 306)										_g176 = (_g176 + 1);
HXDLIN( 306)										int dy9 = (_g176 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g178 = rectLeft7;
HXDLIN( 306)											int _g179 = rectRight7;
HXDLIN( 306)											while((_g178 < _g179)){
HXLINE( 306)												_g178 = (_g178 + 1);
HXDLIN( 306)												int dx9 = (_g178 - 1);
HXDLIN( 306)												::Dynamic this234 = this200->image;
HXDLIN( 306)												int index30;
HXDLIN( 306)												if (this200->useVirtualPos) {
HXLINE( 306)													index30 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this200->virtualY) * ( (Float)(this200->width) )) + dx9) - this200->virtualX));
            												}
            												else {
HXLINE( 306)													index30 = ::Std_obj::_hx_int(( (Float)(((dy9 * this200->width) + dx9)) ));
            												}
HXDLIN( 306)												int c23 = ::iterMagic::Iimg_obj::get(this234,index30);
HXDLIN( 306)												int col7;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col7 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col7 = c23;
            												}
HXDLIN( 306)												bool _hx_tmp58;
HXDLIN( 306)												if (this200->useMask) {
HXLINE( 306)													_hx_tmp58 = ::hx::IsNotNull( this200->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp58 = false;
            												}
HXDLIN( 306)												if (_hx_tmp58) {
HXLINE( 306)													 ::pi_xy::ImageStruct this235 = this200->mask;
HXDLIN( 306)													::Dynamic this236 = this235->image;
HXDLIN( 306)													int index31;
HXDLIN( 306)													if (this235->useVirtualPos) {
HXLINE( 306)														index31 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this235->virtualY) * ( (Float)(this235->width) )) + dx9) - this235->virtualX));
            													}
            													else {
HXLINE( 306)														index31 = ::Std_obj::_hx_int(( (Float)(((dy9 * this235->width) + dx9)) ));
            													}
HXDLIN( 306)													int c24 = ::iterMagic::Iimg_obj::get(this236,index31);
HXDLIN( 306)													int v25;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v25 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v25 = c24;
            													}
HXDLIN( 306)													int maskPixel7 = v25;
HXDLIN( 306)													int this237 = col7;
HXDLIN( 306)													if ((maskPixel7 == 0)) {
HXLINE( 306)														col7 = this237;
            													}
            													else {
HXLINE( 306)														Float m07;
HXDLIN( 306)														int this238 = ((maskPixel7 >> 24) & 255);
HXDLIN( 306)														if ((this238 == 0)) {
HXLINE( 306)															m07 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m07 = (( (Float)(this238) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m17;
HXDLIN( 306)														int this239 = ((maskPixel7 >> 16) & 255);
HXDLIN( 306)														if ((this239 == 0)) {
HXLINE( 306)															m17 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m17 = (( (Float)(this239) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m27;
HXDLIN( 306)														int this240 = ((maskPixel7 >> 8) & 255);
HXDLIN( 306)														if ((this240 == 0)) {
HXLINE( 306)															m27 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m27 = (( (Float)(this240) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m37;
HXDLIN( 306)														int this241 = (maskPixel7 & 255);
HXDLIN( 306)														if ((this241 == 0)) {
HXLINE( 306)															m37 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m37 = (( (Float)(this241) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this237 >> 24) & 255)) )));
HXDLIN( 306)														int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this237 >> 16) & 255)) )));
HXDLIN( 306)														int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this237 >> 8) & 255)) )));
HXDLIN( 306)														int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this237 & 255)) )));
HXDLIN( 306)														col7 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col7 != 0)) {
HXLINE( 306)													int x28 = (dx9 - rectLeft7);
HXDLIN( 306)													int y28 = (dy9 - rectTop7);
HXDLIN( 306)													int c25 = col7;
HXDLIN( 306)													bool _hx_tmp59;
HXDLIN( 306)													if ((((c25 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp59 = undoImage21->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp59 = false;
            													}
HXDLIN( 306)													if (_hx_tmp59) {
HXLINE( 306)														int location14;
HXDLIN( 306)														if (undoImage21->useVirtualPos) {
HXLINE( 306)															location14 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x28) - undoImage21->virtualX));
            														}
            														else {
HXLINE( 306)															location14 = ::Std_obj::_hx_int(( (Float)(((y28 * undoImage21->width) + x28)) ));
            														}
HXDLIN( 306)														int this242 = ::iterMagic::Iimg_obj::get(undoImage21->image,location14);
HXDLIN( 306)														int this243;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this243 = ((((((this242 >> 24) & 255) << 24) | ((this242 & 255) << 16)) | (((this242 >> 8) & 255) << 8)) | ((this242 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this243 = this242;
            														}
HXDLIN( 306)														Float a118;
HXDLIN( 306)														int this244 = ((this243 >> 24) & 255);
HXDLIN( 306)														if ((this244 == 0)) {
HXLINE( 306)															a118 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a118 = (( (Float)(this244) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r115;
HXDLIN( 306)														int this245 = ((this243 >> 16) & 255);
HXDLIN( 306)														if ((this245 == 0)) {
HXLINE( 306)															r115 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r115 = (( (Float)(this245) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g115;
HXDLIN( 306)														int this246 = ((this243 >> 8) & 255);
HXDLIN( 306)														if ((this246 == 0)) {
HXLINE( 306)															g115 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g115 = (( (Float)(this246) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b120;
HXDLIN( 306)														int this247 = (this243 & 255);
HXDLIN( 306)														if ((this247 == 0)) {
HXLINE( 306)															b120 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b120 = (( (Float)(this247) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a216;
HXDLIN( 306)														int this248 = ((col7 >> 24) & 255);
HXDLIN( 306)														if ((this248 == 0)) {
HXLINE( 306)															a216 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a216 = (( (Float)(this248) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r215;
HXDLIN( 306)														int this249 = ((col7 >> 16) & 255);
HXDLIN( 306)														if ((this249 == 0)) {
HXLINE( 306)															r215 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r215 = (( (Float)(this249) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g215;
HXDLIN( 306)														int this250 = ((col7 >> 8) & 255);
HXDLIN( 306)														if ((this250 == 0)) {
HXLINE( 306)															g215 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g215 = (( (Float)(this250) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b218;
HXDLIN( 306)														int this251 = (col7 & 255);
HXDLIN( 306)														if ((this251 == 0)) {
HXLINE( 306)															b218 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b218 = (( (Float)(this251) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN( 306)														int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 306)														int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 306)														int b56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a315) + (b218 * a216))));
HXDLIN( 306)														int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 306)														int blended14 = ((((a51 << 24) | (r37 << 16)) | (g37 << 8)) | b56);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp60;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp60 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp60 = blended14;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage21->image,location14,_hx_tmp60);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this252 = undoImage21->image;
HXDLIN( 306)														int index32;
HXDLIN( 306)														if (undoImage21->useVirtualPos) {
HXLINE( 306)															index32 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x28) - undoImage21->virtualX));
            														}
            														else {
HXLINE( 306)															index32 = ::Std_obj::_hx_int(( (Float)(((y28 * undoImage21->width) + x28)) ));
            														}
HXDLIN( 306)														int _hx_tmp61;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp61 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp61 = c25;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this252,index32,_hx_tmp61);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear7) {
HXLINE( 306)														::Dynamic this253 = undoImage21->image;
HXDLIN( 306)														int x29 = (dx9 - rectLeft7);
HXDLIN( 306)														int y29 = (dy9 - rectTop7);
HXDLIN( 306)														int index33;
HXDLIN( 306)														if (undoImage21->useVirtualPos) {
HXLINE( 306)															index33 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x29) - undoImage21->virtualX));
            														}
            														else {
HXLINE( 306)															index33 = ::Std_obj::_hx_int(( (Float)(((y29 * undoImage21->width) + x29)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this253,index33,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min14 = xIter37->start;
HXDLIN( 306)							int _g_max14 = xIter37->max;
HXDLIN( 306)							while((_g_min14 < _g_max14)){
HXLINE( 306)								_g_min14 = (_g_min14 + 1);
HXDLIN( 306)								int px5 = (_g_min14 - 1);
HXDLIN( 306)								Float pcx5 = (( (Float)(px5) ) - x23);
HXDLIN( 306)								{
HXLINE( 306)									int _g_min15 = yIter37->start;
HXDLIN( 306)									int _g_max15 = yIter37->max;
HXDLIN( 306)									while((_g_min15 < _g_max15)){
HXLINE( 306)										_g_min15 = (_g_min15 + 1);
HXDLIN( 306)										int py5 = (_g_min15 - 1);
HXDLIN( 306)										Float pcy5 = (( (Float)(py5) ) - cy6);
HXDLIN( 306)										Float dot315 = ((pcx5 * bcx5) + (pcy5 * bcy5));
HXDLIN( 306)										Float dot325 = ((pcx5 * acx5) + (pcy5 * acy5));
HXDLIN( 306)										Float ratioA5 = (((dot225 * dot315) - (dot125 * dot325)) * denom15);
HXDLIN( 306)										Float ratioB5 = (((dot115 * dot325) - (dot125 * dot315)) * denom15);
HXDLIN( 306)										Float ratioC5 = ((((Float)1.0) - ratioB5) - ratioA5);
HXDLIN( 306)										bool _hx_tmp62;
HXDLIN( 306)										bool _hx_tmp63;
HXDLIN( 306)										if ((ratioA5 >= 0)) {
HXLINE( 306)											_hx_tmp63 = (ratioB5 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp63 = false;
            										}
HXDLIN( 306)										if (_hx_tmp63) {
HXLINE( 306)											_hx_tmp62 = (ratioC5 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp62 = false;
            										}
HXDLIN( 306)										if (_hx_tmp62) {
HXLINE( 306)											int i76 = ::Std_obj::_hx_int((((( (Float)(aA5) ) * ratioA5) + (( (Float)(aB5) ) * ratioB5)) + (( (Float)(aC5) ) * ratioC5)));
HXDLIN( 306)											if ((i76 > 255)) {
HXLINE(  24)												i76 = 255;
            											}
HXLINE( 306)											if ((i76 < 0)) {
HXLINE(  25)												i76 = 0;
            											}
HXLINE( 306)											int a52 = i76;
HXDLIN( 306)											int i77 = ::Std_obj::_hx_int((((( (Float)(rA5) ) * ratioA5) + (( (Float)(rB5) ) * ratioB5)) + (( (Float)(rC5) ) * ratioC5)));
HXDLIN( 306)											if ((i77 > 255)) {
HXLINE(  24)												i77 = 255;
            											}
HXLINE( 306)											if ((i77 < 0)) {
HXLINE(  25)												i77 = 0;
            											}
HXLINE( 306)											int r38 = i77;
HXDLIN( 306)											int i78 = ::Std_obj::_hx_int((((( (Float)(gA5) ) * ratioA5) + (( (Float)(gB5) ) * ratioB5)) + (( (Float)(gC5) ) * ratioC5)));
HXDLIN( 306)											if ((i78 > 255)) {
HXLINE(  24)												i78 = 255;
            											}
HXLINE( 306)											if ((i78 < 0)) {
HXLINE(  25)												i78 = 0;
            											}
HXLINE( 306)											int g38 = i78;
HXDLIN( 306)											int i79 = ::Std_obj::_hx_int((((( (Float)(bA5) ) * ratioA5) + (( (Float)(bB5) ) * ratioB5)) + (( (Float)(bC5) ) * ratioC5)));
HXDLIN( 306)											if ((i79 > 255)) {
HXLINE(  24)												i79 = 255;
            											}
HXLINE( 306)											if ((i79 < 0)) {
HXLINE(  25)												i79 = 0;
            											}
HXLINE( 306)											int b57 = i79;
HXDLIN( 306)											{
HXLINE( 306)												int location15;
HXDLIN( 306)												if (this200->useVirtualPos) {
HXLINE( 306)													location15 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - this200->virtualY) * ( (Float)(this200->width) )) + px5) - this200->virtualX));
            												}
            												else {
HXLINE( 306)													location15 = ::Std_obj::_hx_int(( (Float)(((py5 * this200->width) + px5)) ));
            												}
HXDLIN( 306)												bool _hx_tmp64;
HXDLIN( 306)												if (this200->transparent) {
HXLINE( 306)													_hx_tmp64 = (a52 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp64 = false;
            												}
HXDLIN( 306)												if (_hx_tmp64) {
HXLINE( 306)													int this254 = ::iterMagic::Iimg_obj::get(this200->image,location15);
HXDLIN( 306)													int old5;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old5 = ((((((this254 >> 24) & 255) << 24) | ((this254 & 255) << 16)) | (((this254 >> 8) & 255) << 8)) | ((this254 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old5 = this254;
            													}
HXDLIN( 306)													int rhs5 = ((((a52 << 24) | (r38 << 16)) | (g38 << 8)) | b57);
HXDLIN( 306)													Float a119;
HXDLIN( 306)													int this255 = ((old5 >> 24) & 255);
HXDLIN( 306)													if ((this255 == 0)) {
HXLINE( 306)														a119 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a119 = (( (Float)(this255) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r116;
HXDLIN( 306)													int this256 = ((old5 >> 16) & 255);
HXDLIN( 306)													if ((this256 == 0)) {
HXLINE( 306)														r116 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r116 = (( (Float)(this256) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g116;
HXDLIN( 306)													int this257 = ((old5 >> 8) & 255);
HXDLIN( 306)													if ((this257 == 0)) {
HXLINE( 306)														g116 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g116 = (( (Float)(this257) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b121;
HXDLIN( 306)													int this258 = (old5 & 255);
HXDLIN( 306)													if ((this258 == 0)) {
HXLINE( 306)														b121 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b121 = (( (Float)(this258) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a217;
HXDLIN( 306)													int this259 = ((rhs5 >> 24) & 255);
HXDLIN( 306)													if ((this259 == 0)) {
HXLINE( 306)														a217 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a217 = (( (Float)(this259) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r216;
HXDLIN( 306)													int this260 = ((rhs5 >> 16) & 255);
HXDLIN( 306)													if ((this260 == 0)) {
HXLINE( 306)														r216 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r216 = (( (Float)(this260) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g216;
HXDLIN( 306)													int this261 = ((rhs5 >> 8) & 255);
HXDLIN( 306)													if ((this261 == 0)) {
HXLINE( 306)														g216 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g216 = (( (Float)(this261) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b219;
HXDLIN( 306)													int this262 = (rhs5 & 255);
HXDLIN( 306)													if ((this262 == 0)) {
HXLINE( 306)														b219 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b219 = (( (Float)(this262) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a316 = (a119 * (( (Float)(1) ) - a217));
HXDLIN( 306)													int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 306)													int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 306)													int b58 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a316) + (b219 * a217))));
HXDLIN( 306)													int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 306)													int blended15 = ((((a53 << 24) | (r39 << 16)) | (g39 << 8)) | b58);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp65;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp65 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp65 = blended15;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this200->image,location15,_hx_tmp65);
            													}
            												}
            												else {
HXLINE( 306)													int value5;
HXDLIN( 306)													if (this200->isLittle) {
HXLINE( 306)														value5 = ((((a52 << 24) | (b57 << 16)) | (g38 << 8)) | r38);
            													}
            													else {
HXLINE( 306)														value5 = ((((a52 << 24) | (r38 << 16)) | (g38 << 8)) | b57);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this200->image,location15,value5);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit7 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v26 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx4,y23,bx4,cy6,x23,cy6,true);
HXDLIN( 306)							if (hasUndo7) {
HXLINE( 306)								v26->undoImage = undoImage21;
HXDLIN( 306)								v26->undoX = xIter37->start;
HXDLIN( 306)								v26->undoY = yIter37->start;
            							}
            						}
            					}
HXDLIN( 306)					if ((hasHit6 == true)) {
HXLINE( 306)						 ::pi_xy::algo::HitQuad v27 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x23,y23,bx4,y23,bx4,cy6,x23,cy6,true);
            					}
            				}
            			}
HXDLIN( 306)			Float inlobj_ax2 = x23;
HXDLIN( 306)			Float inlobj_ay2 = y23;
HXDLIN( 306)			Float inlobj_bx2 = bx4;
HXDLIN( 306)			Float inlobj_y2 = y23;
HXDLIN( 306)			Float inlobj_cx2 = bx4;
HXDLIN( 306)			Float inlobj_cy2 = cy6;
HXDLIN( 306)			Float inlobj_x2 = x23;
HXDLIN( 306)			Float inlobj_dy2 = cy6;
HXDLIN( 306)			 ::pi_xy::ImageStruct this263 = temp;
HXDLIN( 306)			Float y30 = ( (Float)(dy1) );
HXDLIN( 306)			Float bx5 = (farX + rightRadius);
HXDLIN( 306)			Float cy7 = (y30 + ( (Float)(tall1) ));
HXDLIN( 306)			{
HXLINE( 306)				bool hasHit8 = true;
HXDLIN( 306)				{
HXLINE( 306)					{
HXLINE( 306)						bool hasUndo8 = false;
HXDLIN( 306)						int aA6 = ((colorC >> 24) & 255);
HXDLIN( 306)						int rA6 = ((colorC >> 16) & 255);
HXDLIN( 306)						int gA6 = ((colorC >> 8) & 255);
HXDLIN( 306)						int bA6 = (colorC & 255);
HXDLIN( 306)						int aB6 = ((colorC >> 24) & 255);
HXDLIN( 306)						int rB6 = ((colorC >> 16) & 255);
HXDLIN( 306)						int gB6 = ((colorC >> 8) & 255);
HXDLIN( 306)						int bB6 = (colorC & 255);
HXDLIN( 306)						int aC6 = ((colorB >> 24) & 255);
HXDLIN( 306)						int rC6 = ((colorB >> 16) & 255);
HXDLIN( 306)						int gC6 = ((colorB >> 8) & 255);
HXDLIN( 306)						int bC6 = (colorB & 255);
HXDLIN( 306)						Float bcx6 = (bx5 - farX);
HXDLIN( 306)						Float bcy6 = (y30 - cy7);
HXDLIN( 306)						Float acx6 = (farX - farX);
HXDLIN( 306)						Float acy6 = (y30 - cy7);
HXDLIN( 306)						Float dot116 = ((bcx6 * bcx6) + (bcy6 * bcy6));
HXDLIN( 306)						Float dot126 = ((bcx6 * acx6) + (bcy6 * acy6));
HXDLIN( 306)						Float dot226 = ((acx6 * acx6) + (acy6 * acy6));
HXDLIN( 306)						Float denom16 = (( (Float)(1) ) / ((dot116 * dot226) - (dot126 * dot126)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter38;
HXDLIN( 306)						if ((farX > bx5)) {
HXLINE( 306)							if ((farX > farX)) {
HXLINE( 306)								int min29;
HXDLIN( 306)								if ((bx5 > farX)) {
HXLINE( 306)									min29 = ::Math_obj::floor(farX);
            								}
            								else {
HXLINE( 306)									min29 = ::Math_obj::floor(bx5);
            								}
HXDLIN( 306)								int ii_min61 = min29;
HXDLIN( 306)								int ii_max61 = ::Math_obj::ceil(farX);
HXDLIN( 306)								xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            							}
            							else {
HXLINE( 306)								int ii_min62 = ::Math_obj::floor(bx5);
HXDLIN( 306)								int ii_max62 = ::Math_obj::ceil(farX);
HXDLIN( 306)								xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx5 > farX)) {
HXLINE( 306)								int min30;
HXDLIN( 306)								if ((farX > farX)) {
HXLINE( 306)									min30 = ::Math_obj::floor(farX);
            								}
            								else {
HXLINE( 306)									min30 = ::Math_obj::ceil(farX);
            								}
HXDLIN( 306)								int ii_min63 = min30;
HXDLIN( 306)								int ii_max63 = ::Math_obj::ceil(bx5);
HXDLIN( 306)								xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            							}
            							else {
HXLINE( 306)								int ii_min64 = ::Math_obj::floor(farX);
HXDLIN( 306)								int ii_max64 = ::Math_obj::ceil(farX);
HXDLIN( 306)								xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter38;
HXDLIN( 306)						if ((y30 > y30)) {
HXLINE( 306)							if ((y30 > cy7)) {
HXLINE( 306)								int min31;
HXDLIN( 306)								if ((y30 > cy7)) {
HXLINE( 306)									min31 = ::Math_obj::floor(cy7);
            								}
            								else {
HXLINE( 306)									min31 = ::Math_obj::floor(y30);
            								}
HXDLIN( 306)								int ii_min65 = min31;
HXDLIN( 306)								int ii_max65 = ::Math_obj::ceil(y30);
HXDLIN( 306)								yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            							}
            							else {
HXLINE( 306)								int ii_min66 = ::Math_obj::floor(y30);
HXDLIN( 306)								int ii_max66 = ::Math_obj::ceil(cy7);
HXDLIN( 306)								yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            							}
            						}
            						else {
HXLINE( 306)							if ((y30 > cy7)) {
HXLINE( 306)								int min32;
HXDLIN( 306)								if ((y30 > cy7)) {
HXLINE( 306)									min32 = ::Math_obj::floor(cy7);
            								}
            								else {
HXLINE( 306)									min32 = ::Math_obj::ceil(y30);
            								}
HXDLIN( 306)								int ii_min67 = min32;
HXDLIN( 306)								int ii_max67 = ::Math_obj::ceil(y30);
HXDLIN( 306)								yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            							}
            							else {
HXLINE( 306)								int ii_min68 = ::Math_obj::floor(y30);
HXDLIN( 306)								int ii_max68 = ::Math_obj::ceil(cy7);
HXDLIN( 306)								yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage24 = null();
HXDLIN( 306)						if (hasUndo8) {
HXLINE( 306)							int width9 = ((xIter38->max - xIter38->start) + 1);
HXDLIN( 306)							int height9 = ((yIter38->max - yIter38->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType9 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this264 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType9 )) {
HXLINE(  54)								imageType9 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage25;
HXDLIN( 306)							switch((int)(( (int)(imageType9) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt9 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b59 = byt9;
HXDLIN( 306)									{
HXLINE( 306)										b59->width = width9;
HXDLIN( 306)										b59->height = height9;
HXDLIN( 306)										b59->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 306)										b59->data = ::haxe::io::Bytes_obj::alloc((b59->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len18 = b59->length;
HXDLIN( 306)											int w9 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g180 = 0;
HXDLIN( 306)												int _g181 = b59->height;
HXDLIN( 306)												while((_g180 < _g181)){
HXLINE( 306)													_g180 = (_g180 + 1);
HXDLIN( 306)													int y31 = (_g180 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g182 = 0;
HXDLIN( 306)														int _g183 = b59->width;
HXDLIN( 306)														while((_g182 < _g183)){
HXLINE( 306)															_g182 = (_g182 + 1);
HXDLIN( 306)															int x30 = (_g182 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w9 = (w9 + 1);
HXDLIN( 306)																b59->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w9 = (w9 + 1);
HXDLIN( 306)																b59->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w9 = (w9 + 1);
HXDLIN( 306)																b59->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w9 = (w9 + 1);
HXDLIN( 306)																b59->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage25 = b59;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI9 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a54 = arrI9;
HXDLIN( 306)									{
HXLINE( 306)										a54->width = width9;
HXDLIN( 306)										a54->height = height9;
HXDLIN( 306)										a54->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a54->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g184 = 0;
HXDLIN( 306)											int _g185 = a54->length;
HXDLIN( 306)											while((_g184 < _g185)){
HXLINE( 306)												_g184 = (_g184 + 1);
HXDLIN( 306)												int i80 = (_g184 - 1);
HXDLIN( 306)												a54->data[i80] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage25 = a54;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a9 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b60 = u32a9;
HXDLIN( 306)									{
HXLINE( 306)										b60->width = width9;
HXDLIN( 306)										b60->height = height9;
HXDLIN( 306)										b60->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 306)										int size9 = (b60->length * 4);
HXDLIN( 306)										b60->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size9),0,size9);
HXDLIN( 306)										{
HXLINE( 306)											int _g186 = 0;
HXDLIN( 306)											int _g187 = b60->length;
HXDLIN( 306)											while((_g186 < _g187)){
HXLINE( 306)												_g186 = (_g186 + 1);
HXDLIN( 306)												int i81 = (_g186 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this265 = b60->data;
HXDLIN( 306)													bool undoImage26;
HXDLIN( 306)													if ((i81 >= 0)) {
HXLINE( 306)														undoImage26 = (i81 < (this265->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage26 = false;
            													}
HXDLIN( 306)													if (undoImage26) {
HXLINE( 306)														 ::haxe::io::Bytes _this9 = this265->bytes;
HXDLIN( 306)														int pos9 = ((i81 << 2) + this265->byteOffset);
HXDLIN( 306)														_this9->b[pos9] = ( (unsigned char)(0) );
HXDLIN( 306)														_this9->b[(pos9 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this9->b[(pos9 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this9->b[(pos9 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage25 = b60;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec9 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v28 = vec9;
HXDLIN( 306)									{
HXLINE( 306)										v28->width = width9;
HXDLIN( 306)										v28->height = height9;
HXDLIN( 306)										v28->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 306)										v28->data = ::Array_obj< int >::__new(v28->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g188 = 0;
HXDLIN( 306)											int _g189 = v28->length;
HXDLIN( 306)											while((_g188 < _g189)){
HXLINE( 306)												_g188 = (_g188 + 1);
HXDLIN( 306)												int i82 = (_g188 - 1);
HXDLIN( 306)												v28->data->__unsafe_set(i82,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage25 = v28;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt9 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b61 = sInt9;
HXDLIN( 306)									{
HXLINE( 306)										b61->width = width9;
HXDLIN( 306)										b61->height = height9;
HXDLIN( 306)										b61->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 306)										b61->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len19 = b61->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d9 = b61->data;
HXDLIN( 306)											if (::hx::IsNull( d9->head )) {
HXLINE( 306)												int _g190 = 0;
HXDLIN( 306)												int _g191 = len19;
HXDLIN( 306)												while((_g190 < _g191)){
HXLINE( 306)													_g190 = (_g190 + 1);
HXDLIN( 306)													int i83 = (_g190 - 1);
HXDLIN( 306)													d9->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d9->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g192 = 0;
HXDLIN( 306)												int _g193 = len19;
HXDLIN( 306)												while((_g192 < _g193)){
HXLINE( 306)													_g192 = (_g192 + 1);
HXDLIN( 306)													int i84 = (_g192 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l9 = b61->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev9 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g194 = 0;
HXDLIN( 306)															int _g195 = i84;
HXDLIN( 306)															while((_g194 < _g195)){
HXLINE( 306)																_g194 = (_g194 + 1);
HXDLIN( 306)																int i85 = (_g194 - 1);
HXLINE( 345)																prev9 = l9;
HXLINE( 346)																l9 = l9->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev9 )) {
HXLINE( 306)															b61->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l9->next);
HXDLIN( 306)															l9 = null();
            														}
            														else {
HXLINE( 306)															prev9->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l9->next);
HXDLIN( 306)															l9 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage25 = b61;
            								}
            								break;
            							}
HXDLIN( 306)							this264->image = undoImage25;
HXDLIN( 306)							this264->width = width9;
HXDLIN( 306)							this264->height = height9;
HXDLIN( 306)							this264->imageType = ( (int)(imageType9) );
HXDLIN( 306)							undoImage24 = this264;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft8 = xIter38->start;
HXDLIN( 306)								int rectTop8 = yIter38->start;
HXDLIN( 306)								int rectRight8 = xIter38->max;
HXDLIN( 306)								bool forceClear8 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g196 = rectTop8;
HXDLIN( 306)									int _g197 = yIter38->max;
HXDLIN( 306)									while((_g196 < _g197)){
HXLINE( 306)										_g196 = (_g196 + 1);
HXDLIN( 306)										int dy10 = (_g196 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g198 = rectLeft8;
HXDLIN( 306)											int _g199 = rectRight8;
HXDLIN( 306)											while((_g198 < _g199)){
HXLINE( 306)												_g198 = (_g198 + 1);
HXDLIN( 306)												int dx10 = (_g198 - 1);
HXDLIN( 306)												::Dynamic this266 = this263->image;
HXDLIN( 306)												int index34;
HXDLIN( 306)												if (this263->useVirtualPos) {
HXLINE( 306)													index34 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - this263->virtualY) * ( (Float)(this263->width) )) + dx10) - this263->virtualX));
            												}
            												else {
HXLINE( 306)													index34 = ::Std_obj::_hx_int(( (Float)(((dy10 * this263->width) + dx10)) ));
            												}
HXDLIN( 306)												int c26 = ::iterMagic::Iimg_obj::get(this266,index34);
HXDLIN( 306)												int col8;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col8 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col8 = c26;
            												}
HXDLIN( 306)												bool _hx_tmp66;
HXDLIN( 306)												if (this263->useMask) {
HXLINE( 306)													_hx_tmp66 = ::hx::IsNotNull( this263->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp66 = false;
            												}
HXDLIN( 306)												if (_hx_tmp66) {
HXLINE( 306)													 ::pi_xy::ImageStruct this267 = this263->mask;
HXDLIN( 306)													::Dynamic this268 = this267->image;
HXDLIN( 306)													int index35;
HXDLIN( 306)													if (this267->useVirtualPos) {
HXLINE( 306)														index35 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - this267->virtualY) * ( (Float)(this267->width) )) + dx10) - this267->virtualX));
            													}
            													else {
HXLINE( 306)														index35 = ::Std_obj::_hx_int(( (Float)(((dy10 * this267->width) + dx10)) ));
            													}
HXDLIN( 306)													int c27 = ::iterMagic::Iimg_obj::get(this268,index35);
HXDLIN( 306)													int v29;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v29 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v29 = c27;
            													}
HXDLIN( 306)													int maskPixel8 = v29;
HXDLIN( 306)													int this269 = col8;
HXDLIN( 306)													if ((maskPixel8 == 0)) {
HXLINE( 306)														col8 = this269;
            													}
            													else {
HXLINE( 306)														Float m08;
HXDLIN( 306)														int this270 = ((maskPixel8 >> 24) & 255);
HXDLIN( 306)														if ((this270 == 0)) {
HXLINE( 306)															m08 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m08 = (( (Float)(this270) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m18;
HXDLIN( 306)														int this271 = ((maskPixel8 >> 16) & 255);
HXDLIN( 306)														if ((this271 == 0)) {
HXLINE( 306)															m18 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m18 = (( (Float)(this271) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m28;
HXDLIN( 306)														int this272 = ((maskPixel8 >> 8) & 255);
HXDLIN( 306)														if ((this272 == 0)) {
HXLINE( 306)															m28 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m28 = (( (Float)(this272) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m38;
HXDLIN( 306)														int this273 = (maskPixel8 & 255);
HXDLIN( 306)														if ((this273 == 0)) {
HXLINE( 306)															m38 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m38 = (( (Float)(this273) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch08 = ::Std_obj::_hx_int(((((Float)1.) - m08) * ( (Float)(((this269 >> 24) & 255)) )));
HXDLIN( 306)														int ch18 = ::Std_obj::_hx_int(((((Float)1.) - m18) * ( (Float)(((this269 >> 16) & 255)) )));
HXDLIN( 306)														int ch28 = ::Std_obj::_hx_int(((((Float)1.) - m28) * ( (Float)(((this269 >> 8) & 255)) )));
HXDLIN( 306)														int ch38 = ::Std_obj::_hx_int(((((Float)1.) - m38) * ( (Float)((this269 & 255)) )));
HXDLIN( 306)														col8 = ((((::Math_obj::round((( (Float)(ch08) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch18) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch28) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch38) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col8 != 0)) {
HXLINE( 306)													int x31 = (dx10 - rectLeft8);
HXDLIN( 306)													int y32 = (dy10 - rectTop8);
HXDLIN( 306)													int c28 = col8;
HXDLIN( 306)													bool _hx_tmp67;
HXDLIN( 306)													if ((((c28 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp67 = undoImage24->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp67 = false;
            													}
HXDLIN( 306)													if (_hx_tmp67) {
HXLINE( 306)														int location16;
HXDLIN( 306)														if (undoImage24->useVirtualPos) {
HXLINE( 306)															location16 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x31) - undoImage24->virtualX));
            														}
            														else {
HXLINE( 306)															location16 = ::Std_obj::_hx_int(( (Float)(((y32 * undoImage24->width) + x31)) ));
            														}
HXDLIN( 306)														int this274 = ::iterMagic::Iimg_obj::get(undoImage24->image,location16);
HXDLIN( 306)														int this275;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this275 = ((((((this274 >> 24) & 255) << 24) | ((this274 & 255) << 16)) | (((this274 >> 8) & 255) << 8)) | ((this274 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this275 = this274;
            														}
HXDLIN( 306)														Float a120;
HXDLIN( 306)														int this276 = ((this275 >> 24) & 255);
HXDLIN( 306)														if ((this276 == 0)) {
HXLINE( 306)															a120 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a120 = (( (Float)(this276) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r117;
HXDLIN( 306)														int this277 = ((this275 >> 16) & 255);
HXDLIN( 306)														if ((this277 == 0)) {
HXLINE( 306)															r117 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r117 = (( (Float)(this277) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g117;
HXDLIN( 306)														int this278 = ((this275 >> 8) & 255);
HXDLIN( 306)														if ((this278 == 0)) {
HXLINE( 306)															g117 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g117 = (( (Float)(this278) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b122;
HXDLIN( 306)														int this279 = (this275 & 255);
HXDLIN( 306)														if ((this279 == 0)) {
HXLINE( 306)															b122 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b122 = (( (Float)(this279) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a218;
HXDLIN( 306)														int this280 = ((col8 >> 24) & 255);
HXDLIN( 306)														if ((this280 == 0)) {
HXLINE( 306)															a218 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a218 = (( (Float)(this280) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r217;
HXDLIN( 306)														int this281 = ((col8 >> 16) & 255);
HXDLIN( 306)														if ((this281 == 0)) {
HXLINE( 306)															r217 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r217 = (( (Float)(this281) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g217;
HXDLIN( 306)														int this282 = ((col8 >> 8) & 255);
HXDLIN( 306)														if ((this282 == 0)) {
HXLINE( 306)															g217 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g217 = (( (Float)(this282) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b220;
HXDLIN( 306)														int this283 = (col8 & 255);
HXDLIN( 306)														if ((this283 == 0)) {
HXLINE( 306)															b220 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b220 = (( (Float)(this283) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a317 = (a120 * (( (Float)(1) ) - a218));
HXDLIN( 306)														int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 306)														int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 306)														int b62 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a317) + (b220 * a218))));
HXDLIN( 306)														int a55 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 306)														int blended16 = ((((a55 << 24) | (r40 << 16)) | (g40 << 8)) | b62);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp68;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp68 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp68 = blended16;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage24->image,location16,_hx_tmp68);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this284 = undoImage24->image;
HXDLIN( 306)														int index36;
HXDLIN( 306)														if (undoImage24->useVirtualPos) {
HXLINE( 306)															index36 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x31) - undoImage24->virtualX));
            														}
            														else {
HXLINE( 306)															index36 = ::Std_obj::_hx_int(( (Float)(((y32 * undoImage24->width) + x31)) ));
            														}
HXDLIN( 306)														int _hx_tmp69;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp69 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp69 = c28;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this284,index36,_hx_tmp69);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear8) {
HXLINE( 306)														::Dynamic this285 = undoImage24->image;
HXDLIN( 306)														int x32 = (dx10 - rectLeft8);
HXDLIN( 306)														int y33 = (dy10 - rectTop8);
HXDLIN( 306)														int index37;
HXDLIN( 306)														if (undoImage24->useVirtualPos) {
HXLINE( 306)															index37 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x32) - undoImage24->virtualX));
            														}
            														else {
HXLINE( 306)															index37 = ::Std_obj::_hx_int(( (Float)(((y33 * undoImage24->width) + x32)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this285,index37,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min16 = xIter38->start;
HXDLIN( 306)							int _g_max16 = xIter38->max;
HXDLIN( 306)							while((_g_min16 < _g_max16)){
HXLINE( 306)								_g_min16 = (_g_min16 + 1);
HXDLIN( 306)								int px6 = (_g_min16 - 1);
HXDLIN( 306)								Float pcx6 = (( (Float)(px6) ) - farX);
HXDLIN( 306)								{
HXLINE( 306)									int _g_min17 = yIter38->start;
HXDLIN( 306)									int _g_max17 = yIter38->max;
HXDLIN( 306)									while((_g_min17 < _g_max17)){
HXLINE( 306)										_g_min17 = (_g_min17 + 1);
HXDLIN( 306)										int py6 = (_g_min17 - 1);
HXDLIN( 306)										Float pcy6 = (( (Float)(py6) ) - cy7);
HXDLIN( 306)										Float dot316 = ((pcx6 * bcx6) + (pcy6 * bcy6));
HXDLIN( 306)										Float dot326 = ((pcx6 * acx6) + (pcy6 * acy6));
HXDLIN( 306)										Float ratioA6 = (((dot226 * dot316) - (dot126 * dot326)) * denom16);
HXDLIN( 306)										Float ratioB6 = (((dot116 * dot326) - (dot126 * dot316)) * denom16);
HXDLIN( 306)										Float ratioC6 = ((((Float)1.0) - ratioB6) - ratioA6);
HXDLIN( 306)										bool _hx_tmp70;
HXDLIN( 306)										bool _hx_tmp71;
HXDLIN( 306)										if ((ratioA6 >= 0)) {
HXLINE( 306)											_hx_tmp71 = (ratioB6 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp71 = false;
            										}
HXDLIN( 306)										if (_hx_tmp71) {
HXLINE( 306)											_hx_tmp70 = (ratioC6 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp70 = false;
            										}
HXDLIN( 306)										if (_hx_tmp70) {
HXLINE( 306)											int i86 = ::Std_obj::_hx_int((((( (Float)(aA6) ) * ratioA6) + (( (Float)(aB6) ) * ratioB6)) + (( (Float)(aC6) ) * ratioC6)));
HXDLIN( 306)											if ((i86 > 255)) {
HXLINE(  24)												i86 = 255;
            											}
HXLINE( 306)											if ((i86 < 0)) {
HXLINE(  25)												i86 = 0;
            											}
HXLINE( 306)											int a56 = i86;
HXDLIN( 306)											int i87 = ::Std_obj::_hx_int((((( (Float)(rA6) ) * ratioA6) + (( (Float)(rB6) ) * ratioB6)) + (( (Float)(rC6) ) * ratioC6)));
HXDLIN( 306)											if ((i87 > 255)) {
HXLINE(  24)												i87 = 255;
            											}
HXLINE( 306)											if ((i87 < 0)) {
HXLINE(  25)												i87 = 0;
            											}
HXLINE( 306)											int r41 = i87;
HXDLIN( 306)											int i88 = ::Std_obj::_hx_int((((( (Float)(gA6) ) * ratioA6) + (( (Float)(gB6) ) * ratioB6)) + (( (Float)(gC6) ) * ratioC6)));
HXDLIN( 306)											if ((i88 > 255)) {
HXLINE(  24)												i88 = 255;
            											}
HXLINE( 306)											if ((i88 < 0)) {
HXLINE(  25)												i88 = 0;
            											}
HXLINE( 306)											int g41 = i88;
HXDLIN( 306)											int i89 = ::Std_obj::_hx_int((((( (Float)(bA6) ) * ratioA6) + (( (Float)(bB6) ) * ratioB6)) + (( (Float)(bC6) ) * ratioC6)));
HXDLIN( 306)											if ((i89 > 255)) {
HXLINE(  24)												i89 = 255;
            											}
HXLINE( 306)											if ((i89 < 0)) {
HXLINE(  25)												i89 = 0;
            											}
HXLINE( 306)											int b63 = i89;
HXDLIN( 306)											{
HXLINE( 306)												int location17;
HXDLIN( 306)												if (this263->useVirtualPos) {
HXLINE( 306)													location17 = ::Std_obj::_hx_int(((((( (Float)(py6) ) - this263->virtualY) * ( (Float)(this263->width) )) + px6) - this263->virtualX));
            												}
            												else {
HXLINE( 306)													location17 = ::Std_obj::_hx_int(( (Float)(((py6 * this263->width) + px6)) ));
            												}
HXDLIN( 306)												bool _hx_tmp72;
HXDLIN( 306)												if (this263->transparent) {
HXLINE( 306)													_hx_tmp72 = (a56 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp72 = false;
            												}
HXDLIN( 306)												if (_hx_tmp72) {
HXLINE( 306)													int this286 = ::iterMagic::Iimg_obj::get(this263->image,location17);
HXDLIN( 306)													int old6;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old6 = ((((((this286 >> 24) & 255) << 24) | ((this286 & 255) << 16)) | (((this286 >> 8) & 255) << 8)) | ((this286 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old6 = this286;
            													}
HXDLIN( 306)													int rhs6 = ((((a56 << 24) | (r41 << 16)) | (g41 << 8)) | b63);
HXDLIN( 306)													Float a121;
HXDLIN( 306)													int this287 = ((old6 >> 24) & 255);
HXDLIN( 306)													if ((this287 == 0)) {
HXLINE( 306)														a121 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a121 = (( (Float)(this287) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r118;
HXDLIN( 306)													int this288 = ((old6 >> 16) & 255);
HXDLIN( 306)													if ((this288 == 0)) {
HXLINE( 306)														r118 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r118 = (( (Float)(this288) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g118;
HXDLIN( 306)													int this289 = ((old6 >> 8) & 255);
HXDLIN( 306)													if ((this289 == 0)) {
HXLINE( 306)														g118 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g118 = (( (Float)(this289) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b123;
HXDLIN( 306)													int this290 = (old6 & 255);
HXDLIN( 306)													if ((this290 == 0)) {
HXLINE( 306)														b123 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b123 = (( (Float)(this290) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a219;
HXDLIN( 306)													int this291 = ((rhs6 >> 24) & 255);
HXDLIN( 306)													if ((this291 == 0)) {
HXLINE( 306)														a219 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a219 = (( (Float)(this291) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r218;
HXDLIN( 306)													int this292 = ((rhs6 >> 16) & 255);
HXDLIN( 306)													if ((this292 == 0)) {
HXLINE( 306)														r218 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r218 = (( (Float)(this292) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g218;
HXDLIN( 306)													int this293 = ((rhs6 >> 8) & 255);
HXDLIN( 306)													if ((this293 == 0)) {
HXLINE( 306)														g218 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g218 = (( (Float)(this293) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b221;
HXDLIN( 306)													int this294 = (rhs6 & 255);
HXDLIN( 306)													if ((this294 == 0)) {
HXLINE( 306)														b221 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b221 = (( (Float)(this294) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a318 = (a121 * (( (Float)(1) ) - a219));
HXDLIN( 306)													int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 306)													int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 306)													int b64 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a318) + (b221 * a219))));
HXDLIN( 306)													int a57 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 306)													int blended17 = ((((a57 << 24) | (r42 << 16)) | (g42 << 8)) | b64);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp73;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp73 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp73 = blended17;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this263->image,location17,_hx_tmp73);
            													}
            												}
            												else {
HXLINE( 306)													int value6;
HXDLIN( 306)													if (this263->isLittle) {
HXLINE( 306)														value6 = ((((a56 << 24) | (b63 << 16)) | (g41 << 8)) | r41);
            													}
            													else {
HXLINE( 306)														value6 = ((((a56 << 24) | (r41 << 16)) | (g41 << 8)) | b63);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this263->image,location17,value6);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit8 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v30 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX,y30,bx5,y30,farX,cy7,true);
HXDLIN( 306)							if (hasUndo8) {
HXLINE( 306)								v30->undoImage = undoImage24;
HXDLIN( 306)								v30->undoX = xIter38->start;
HXDLIN( 306)								v30->undoY = yIter38->start;
            							}
            						}
            					}
HXDLIN( 306)					{
HXLINE( 306)						bool hasHit9 = false;
HXDLIN( 306)						bool hasUndo9 = false;
HXDLIN( 306)						int aA7 = ((colorB >> 24) & 255);
HXDLIN( 306)						int rA7 = ((colorB >> 16) & 255);
HXDLIN( 306)						int gA7 = ((colorB >> 8) & 255);
HXDLIN( 306)						int bA7 = (colorB & 255);
HXDLIN( 306)						int aB7 = ((colorC >> 24) & 255);
HXDLIN( 306)						int rB7 = ((colorC >> 16) & 255);
HXDLIN( 306)						int gB7 = ((colorC >> 8) & 255);
HXDLIN( 306)						int bB7 = (colorC & 255);
HXDLIN( 306)						int aC7 = ((colorB >> 24) & 255);
HXDLIN( 306)						int rC7 = ((colorB >> 16) & 255);
HXDLIN( 306)						int gC7 = ((colorB >> 8) & 255);
HXDLIN( 306)						int bC7 = (colorB & 255);
HXDLIN( 306)						Float bcx7 = (bx5 - farX);
HXDLIN( 306)						Float bcy7 = (cy7 - cy7);
HXDLIN( 306)						Float acx7 = (bx5 - farX);
HXDLIN( 306)						Float acy7 = (y30 - cy7);
HXDLIN( 306)						Float dot117 = ((bcx7 * bcx7) + (bcy7 * bcy7));
HXDLIN( 306)						Float dot127 = ((bcx7 * acx7) + (bcy7 * acy7));
HXDLIN( 306)						Float dot227 = ((acx7 * acx7) + (acy7 * acy7));
HXDLIN( 306)						Float denom17 = (( (Float)(1) ) / ((dot117 * dot227) - (dot127 * dot127)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter39;
HXDLIN( 306)						if ((bx5 > bx5)) {
HXLINE( 306)							if ((bx5 > farX)) {
HXLINE( 306)								int min33;
HXDLIN( 306)								if ((bx5 > farX)) {
HXLINE( 306)									min33 = ::Math_obj::floor(farX);
            								}
            								else {
HXLINE( 306)									min33 = ::Math_obj::floor(bx5);
            								}
HXDLIN( 306)								int ii_min69 = min33;
HXDLIN( 306)								int ii_max69 = ::Math_obj::ceil(bx5);
HXDLIN( 306)								xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            							}
            							else {
HXLINE( 306)								int ii_min70 = ::Math_obj::floor(bx5);
HXDLIN( 306)								int ii_max70 = ::Math_obj::ceil(farX);
HXDLIN( 306)								xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx5 > farX)) {
HXLINE( 306)								int min34;
HXDLIN( 306)								if ((bx5 > farX)) {
HXLINE( 306)									min34 = ::Math_obj::floor(farX);
            								}
            								else {
HXLINE( 306)									min34 = ::Math_obj::ceil(bx5);
            								}
HXDLIN( 306)								int ii_min71 = min34;
HXDLIN( 306)								int ii_max71 = ::Math_obj::ceil(bx5);
HXDLIN( 306)								xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            							}
            							else {
HXLINE( 306)								int ii_min72 = ::Math_obj::floor(bx5);
HXDLIN( 306)								int ii_max72 = ::Math_obj::ceil(farX);
HXDLIN( 306)								xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter39;
HXDLIN( 306)						if ((y30 > cy7)) {
HXLINE( 306)							if ((y30 > cy7)) {
HXLINE( 306)								int min35;
HXDLIN( 306)								if ((cy7 > cy7)) {
HXLINE( 306)									min35 = ::Math_obj::floor(cy7);
            								}
            								else {
HXLINE( 306)									min35 = ::Math_obj::floor(cy7);
            								}
HXDLIN( 306)								int ii_min73 = min35;
HXDLIN( 306)								int ii_max73 = ::Math_obj::ceil(y30);
HXDLIN( 306)								yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            							}
            							else {
HXLINE( 306)								int ii_min74 = ::Math_obj::floor(cy7);
HXDLIN( 306)								int ii_max74 = ::Math_obj::ceil(cy7);
HXDLIN( 306)								yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min74,ii_max74);
            							}
            						}
            						else {
HXLINE( 306)							if ((cy7 > cy7)) {
HXLINE( 306)								int min36;
HXDLIN( 306)								if ((y30 > cy7)) {
HXLINE( 306)									min36 = ::Math_obj::floor(cy7);
            								}
            								else {
HXLINE( 306)									min36 = ::Math_obj::ceil(y30);
            								}
HXDLIN( 306)								int ii_min75 = min36;
HXDLIN( 306)								int ii_max75 = ::Math_obj::ceil(cy7);
HXDLIN( 306)								yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min75,ii_max75);
            							}
            							else {
HXLINE( 306)								int ii_min76 = ::Math_obj::floor(y30);
HXDLIN( 306)								int ii_max76 = ::Math_obj::ceil(cy7);
HXDLIN( 306)								yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min76,ii_max76);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage27 = null();
HXDLIN( 306)						if (hasUndo9) {
HXLINE( 306)							int width10 = ((xIter39->max - xIter39->start) + 1);
HXDLIN( 306)							int height10 = ((yIter39->max - yIter39->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType10 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this295 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType10 )) {
HXLINE(  54)								imageType10 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage28;
HXDLIN( 306)							switch((int)(( (int)(imageType10) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt10 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b65 = byt10;
HXDLIN( 306)									{
HXLINE( 306)										b65->width = width10;
HXDLIN( 306)										b65->height = height10;
HXDLIN( 306)										b65->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 306)										b65->data = ::haxe::io::Bytes_obj::alloc((b65->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len20 = b65->length;
HXDLIN( 306)											int w10 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g200 = 0;
HXDLIN( 306)												int _g201 = b65->height;
HXDLIN( 306)												while((_g200 < _g201)){
HXLINE( 306)													_g200 = (_g200 + 1);
HXDLIN( 306)													int y34 = (_g200 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g202 = 0;
HXDLIN( 306)														int _g203 = b65->width;
HXDLIN( 306)														while((_g202 < _g203)){
HXLINE( 306)															_g202 = (_g202 + 1);
HXDLIN( 306)															int x33 = (_g202 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w10 = (w10 + 1);
HXDLIN( 306)																b65->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w10 = (w10 + 1);
HXDLIN( 306)																b65->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w10 = (w10 + 1);
HXDLIN( 306)																b65->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w10 = (w10 + 1);
HXDLIN( 306)																b65->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage28 = b65;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI10 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a58 = arrI10;
HXDLIN( 306)									{
HXLINE( 306)										a58->width = width10;
HXDLIN( 306)										a58->height = height10;
HXDLIN( 306)										a58->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a58->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g204 = 0;
HXDLIN( 306)											int _g205 = a58->length;
HXDLIN( 306)											while((_g204 < _g205)){
HXLINE( 306)												_g204 = (_g204 + 1);
HXDLIN( 306)												int i90 = (_g204 - 1);
HXDLIN( 306)												a58->data[i90] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage28 = a58;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a10 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b66 = u32a10;
HXDLIN( 306)									{
HXLINE( 306)										b66->width = width10;
HXDLIN( 306)										b66->height = height10;
HXDLIN( 306)										b66->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 306)										int size10 = (b66->length * 4);
HXDLIN( 306)										b66->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size10),0,size10);
HXDLIN( 306)										{
HXLINE( 306)											int _g206 = 0;
HXDLIN( 306)											int _g207 = b66->length;
HXDLIN( 306)											while((_g206 < _g207)){
HXLINE( 306)												_g206 = (_g206 + 1);
HXDLIN( 306)												int i91 = (_g206 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this296 = b66->data;
HXDLIN( 306)													bool undoImage29;
HXDLIN( 306)													if ((i91 >= 0)) {
HXLINE( 306)														undoImage29 = (i91 < (this296->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage29 = false;
            													}
HXDLIN( 306)													if (undoImage29) {
HXLINE( 306)														 ::haxe::io::Bytes _this10 = this296->bytes;
HXDLIN( 306)														int pos10 = ((i91 << 2) + this296->byteOffset);
HXDLIN( 306)														_this10->b[pos10] = ( (unsigned char)(0) );
HXDLIN( 306)														_this10->b[(pos10 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this10->b[(pos10 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this10->b[(pos10 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage28 = b66;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec10 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v31 = vec10;
HXDLIN( 306)									{
HXLINE( 306)										v31->width = width10;
HXDLIN( 306)										v31->height = height10;
HXDLIN( 306)										v31->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 306)										v31->data = ::Array_obj< int >::__new(v31->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g208 = 0;
HXDLIN( 306)											int _g209 = v31->length;
HXDLIN( 306)											while((_g208 < _g209)){
HXLINE( 306)												_g208 = (_g208 + 1);
HXDLIN( 306)												int i92 = (_g208 - 1);
HXDLIN( 306)												v31->data->__unsafe_set(i92,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage28 = v31;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt10 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b67 = sInt10;
HXDLIN( 306)									{
HXLINE( 306)										b67->width = width10;
HXDLIN( 306)										b67->height = height10;
HXDLIN( 306)										b67->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 306)										b67->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len21 = b67->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d10 = b67->data;
HXDLIN( 306)											if (::hx::IsNull( d10->head )) {
HXLINE( 306)												int _g210 = 0;
HXDLIN( 306)												int _g211 = len21;
HXDLIN( 306)												while((_g210 < _g211)){
HXLINE( 306)													_g210 = (_g210 + 1);
HXDLIN( 306)													int i93 = (_g210 - 1);
HXDLIN( 306)													d10->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d10->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g212 = 0;
HXDLIN( 306)												int _g213 = len21;
HXDLIN( 306)												while((_g212 < _g213)){
HXLINE( 306)													_g212 = (_g212 + 1);
HXDLIN( 306)													int i94 = (_g212 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l10 = b67->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev10 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g214 = 0;
HXDLIN( 306)															int _g215 = i94;
HXDLIN( 306)															while((_g214 < _g215)){
HXLINE( 306)																_g214 = (_g214 + 1);
HXDLIN( 306)																int i95 = (_g214 - 1);
HXLINE( 345)																prev10 = l10;
HXLINE( 346)																l10 = l10->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev10 )) {
HXLINE( 306)															b67->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l10->next);
HXDLIN( 306)															l10 = null();
            														}
            														else {
HXLINE( 306)															prev10->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l10->next);
HXDLIN( 306)															l10 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage28 = b67;
            								}
            								break;
            							}
HXDLIN( 306)							this295->image = undoImage28;
HXDLIN( 306)							this295->width = width10;
HXDLIN( 306)							this295->height = height10;
HXDLIN( 306)							this295->imageType = ( (int)(imageType10) );
HXDLIN( 306)							undoImage27 = this295;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft9 = xIter39->start;
HXDLIN( 306)								int rectTop9 = yIter39->start;
HXDLIN( 306)								int rectRight9 = xIter39->max;
HXDLIN( 306)								bool forceClear9 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g216 = rectTop9;
HXDLIN( 306)									int _g217 = yIter39->max;
HXDLIN( 306)									while((_g216 < _g217)){
HXLINE( 306)										_g216 = (_g216 + 1);
HXDLIN( 306)										int dy11 = (_g216 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g218 = rectLeft9;
HXDLIN( 306)											int _g219 = rectRight9;
HXDLIN( 306)											while((_g218 < _g219)){
HXLINE( 306)												_g218 = (_g218 + 1);
HXDLIN( 306)												int dx11 = (_g218 - 1);
HXDLIN( 306)												::Dynamic this297 = this263->image;
HXDLIN( 306)												int index38;
HXDLIN( 306)												if (this263->useVirtualPos) {
HXLINE( 306)													index38 = ::Std_obj::_hx_int(((((( (Float)(dy11) ) - this263->virtualY) * ( (Float)(this263->width) )) + dx11) - this263->virtualX));
            												}
            												else {
HXLINE( 306)													index38 = ::Std_obj::_hx_int(( (Float)(((dy11 * this263->width) + dx11)) ));
            												}
HXDLIN( 306)												int c29 = ::iterMagic::Iimg_obj::get(this297,index38);
HXDLIN( 306)												int col9;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col9 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col9 = c29;
            												}
HXDLIN( 306)												bool _hx_tmp74;
HXDLIN( 306)												if (this263->useMask) {
HXLINE( 306)													_hx_tmp74 = ::hx::IsNotNull( this263->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp74 = false;
            												}
HXDLIN( 306)												if (_hx_tmp74) {
HXLINE( 306)													 ::pi_xy::ImageStruct this298 = this263->mask;
HXDLIN( 306)													::Dynamic this299 = this298->image;
HXDLIN( 306)													int index39;
HXDLIN( 306)													if (this298->useVirtualPos) {
HXLINE( 306)														index39 = ::Std_obj::_hx_int(((((( (Float)(dy11) ) - this298->virtualY) * ( (Float)(this298->width) )) + dx11) - this298->virtualX));
            													}
            													else {
HXLINE( 306)														index39 = ::Std_obj::_hx_int(( (Float)(((dy11 * this298->width) + dx11)) ));
            													}
HXDLIN( 306)													int c30 = ::iterMagic::Iimg_obj::get(this299,index39);
HXDLIN( 306)													int v32;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v32 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v32 = c30;
            													}
HXDLIN( 306)													int maskPixel9 = v32;
HXDLIN( 306)													int this300 = col9;
HXDLIN( 306)													if ((maskPixel9 == 0)) {
HXLINE( 306)														col9 = this300;
            													}
            													else {
HXLINE( 306)														Float m09;
HXDLIN( 306)														int this301 = ((maskPixel9 >> 24) & 255);
HXDLIN( 306)														if ((this301 == 0)) {
HXLINE( 306)															m09 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m09 = (( (Float)(this301) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m19;
HXDLIN( 306)														int this302 = ((maskPixel9 >> 16) & 255);
HXDLIN( 306)														if ((this302 == 0)) {
HXLINE( 306)															m19 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m19 = (( (Float)(this302) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m29;
HXDLIN( 306)														int this303 = ((maskPixel9 >> 8) & 255);
HXDLIN( 306)														if ((this303 == 0)) {
HXLINE( 306)															m29 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m29 = (( (Float)(this303) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m39;
HXDLIN( 306)														int this304 = (maskPixel9 & 255);
HXDLIN( 306)														if ((this304 == 0)) {
HXLINE( 306)															m39 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m39 = (( (Float)(this304) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch09 = ::Std_obj::_hx_int(((((Float)1.) - m09) * ( (Float)(((this300 >> 24) & 255)) )));
HXDLIN( 306)														int ch19 = ::Std_obj::_hx_int(((((Float)1.) - m19) * ( (Float)(((this300 >> 16) & 255)) )));
HXDLIN( 306)														int ch29 = ::Std_obj::_hx_int(((((Float)1.) - m29) * ( (Float)(((this300 >> 8) & 255)) )));
HXDLIN( 306)														int ch39 = ::Std_obj::_hx_int(((((Float)1.) - m39) * ( (Float)((this300 & 255)) )));
HXDLIN( 306)														col9 = ((((::Math_obj::round((( (Float)(ch09) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch19) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch29) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch39) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col9 != 0)) {
HXLINE( 306)													int x34 = (dx11 - rectLeft9);
HXDLIN( 306)													int y35 = (dy11 - rectTop9);
HXDLIN( 306)													int c31 = col9;
HXDLIN( 306)													bool _hx_tmp75;
HXDLIN( 306)													if ((((c31 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp75 = undoImage27->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp75 = false;
            													}
HXDLIN( 306)													if (_hx_tmp75) {
HXLINE( 306)														int location18;
HXDLIN( 306)														if (undoImage27->useVirtualPos) {
HXLINE( 306)															location18 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x34) - undoImage27->virtualX));
            														}
            														else {
HXLINE( 306)															location18 = ::Std_obj::_hx_int(( (Float)(((y35 * undoImage27->width) + x34)) ));
            														}
HXDLIN( 306)														int this305 = ::iterMagic::Iimg_obj::get(undoImage27->image,location18);
HXDLIN( 306)														int this306;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this306 = ((((((this305 >> 24) & 255) << 24) | ((this305 & 255) << 16)) | (((this305 >> 8) & 255) << 8)) | ((this305 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this306 = this305;
            														}
HXDLIN( 306)														Float a122;
HXDLIN( 306)														int this307 = ((this306 >> 24) & 255);
HXDLIN( 306)														if ((this307 == 0)) {
HXLINE( 306)															a122 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a122 = (( (Float)(this307) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r119;
HXDLIN( 306)														int this308 = ((this306 >> 16) & 255);
HXDLIN( 306)														if ((this308 == 0)) {
HXLINE( 306)															r119 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r119 = (( (Float)(this308) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g119;
HXDLIN( 306)														int this309 = ((this306 >> 8) & 255);
HXDLIN( 306)														if ((this309 == 0)) {
HXLINE( 306)															g119 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g119 = (( (Float)(this309) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b124;
HXDLIN( 306)														int this310 = (this306 & 255);
HXDLIN( 306)														if ((this310 == 0)) {
HXLINE( 306)															b124 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b124 = (( (Float)(this310) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a220;
HXDLIN( 306)														int this311 = ((col9 >> 24) & 255);
HXDLIN( 306)														if ((this311 == 0)) {
HXLINE( 306)															a220 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a220 = (( (Float)(this311) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r219;
HXDLIN( 306)														int this312 = ((col9 >> 16) & 255);
HXDLIN( 306)														if ((this312 == 0)) {
HXLINE( 306)															r219 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r219 = (( (Float)(this312) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g219;
HXDLIN( 306)														int this313 = ((col9 >> 8) & 255);
HXDLIN( 306)														if ((this313 == 0)) {
HXLINE( 306)															g219 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g219 = (( (Float)(this313) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b222;
HXDLIN( 306)														int this314 = (col9 & 255);
HXDLIN( 306)														if ((this314 == 0)) {
HXLINE( 306)															b222 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b222 = (( (Float)(this314) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a319 = (a122 * (( (Float)(1) ) - a220));
HXDLIN( 306)														int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 306)														int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 306)														int b68 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a319) + (b222 * a220))));
HXDLIN( 306)														int a59 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 306)														int blended18 = ((((a59 << 24) | (r43 << 16)) | (g43 << 8)) | b68);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp76;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp76 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp76 = blended18;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage27->image,location18,_hx_tmp76);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this315 = undoImage27->image;
HXDLIN( 306)														int index40;
HXDLIN( 306)														if (undoImage27->useVirtualPos) {
HXLINE( 306)															index40 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x34) - undoImage27->virtualX));
            														}
            														else {
HXLINE( 306)															index40 = ::Std_obj::_hx_int(( (Float)(((y35 * undoImage27->width) + x34)) ));
            														}
HXDLIN( 306)														int _hx_tmp77;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp77 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp77 = c31;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this315,index40,_hx_tmp77);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear9) {
HXLINE( 306)														::Dynamic this316 = undoImage27->image;
HXDLIN( 306)														int x35 = (dx11 - rectLeft9);
HXDLIN( 306)														int y36 = (dy11 - rectTop9);
HXDLIN( 306)														int index41;
HXDLIN( 306)														if (undoImage27->useVirtualPos) {
HXLINE( 306)															index41 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x35) - undoImage27->virtualX));
            														}
            														else {
HXLINE( 306)															index41 = ::Std_obj::_hx_int(( (Float)(((y36 * undoImage27->width) + x35)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this316,index41,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min18 = xIter39->start;
HXDLIN( 306)							int _g_max18 = xIter39->max;
HXDLIN( 306)							while((_g_min18 < _g_max18)){
HXLINE( 306)								_g_min18 = (_g_min18 + 1);
HXDLIN( 306)								int px7 = (_g_min18 - 1);
HXDLIN( 306)								Float pcx7 = (( (Float)(px7) ) - farX);
HXDLIN( 306)								{
HXLINE( 306)									int _g_min19 = yIter39->start;
HXDLIN( 306)									int _g_max19 = yIter39->max;
HXDLIN( 306)									while((_g_min19 < _g_max19)){
HXLINE( 306)										_g_min19 = (_g_min19 + 1);
HXDLIN( 306)										int py7 = (_g_min19 - 1);
HXDLIN( 306)										Float pcy7 = (( (Float)(py7) ) - cy7);
HXDLIN( 306)										Float dot317 = ((pcx7 * bcx7) + (pcy7 * bcy7));
HXDLIN( 306)										Float dot327 = ((pcx7 * acx7) + (pcy7 * acy7));
HXDLIN( 306)										Float ratioA7 = (((dot227 * dot317) - (dot127 * dot327)) * denom17);
HXDLIN( 306)										Float ratioB7 = (((dot117 * dot327) - (dot127 * dot317)) * denom17);
HXDLIN( 306)										Float ratioC7 = ((((Float)1.0) - ratioB7) - ratioA7);
HXDLIN( 306)										bool _hx_tmp78;
HXDLIN( 306)										bool _hx_tmp79;
HXDLIN( 306)										if ((ratioA7 >= 0)) {
HXLINE( 306)											_hx_tmp79 = (ratioB7 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp79 = false;
            										}
HXDLIN( 306)										if (_hx_tmp79) {
HXLINE( 306)											_hx_tmp78 = (ratioC7 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp78 = false;
            										}
HXDLIN( 306)										if (_hx_tmp78) {
HXLINE( 306)											int i96 = ::Std_obj::_hx_int((((( (Float)(aA7) ) * ratioA7) + (( (Float)(aB7) ) * ratioB7)) + (( (Float)(aC7) ) * ratioC7)));
HXDLIN( 306)											if ((i96 > 255)) {
HXLINE(  24)												i96 = 255;
            											}
HXLINE( 306)											if ((i96 < 0)) {
HXLINE(  25)												i96 = 0;
            											}
HXLINE( 306)											int a60 = i96;
HXDLIN( 306)											int i97 = ::Std_obj::_hx_int((((( (Float)(rA7) ) * ratioA7) + (( (Float)(rB7) ) * ratioB7)) + (( (Float)(rC7) ) * ratioC7)));
HXDLIN( 306)											if ((i97 > 255)) {
HXLINE(  24)												i97 = 255;
            											}
HXLINE( 306)											if ((i97 < 0)) {
HXLINE(  25)												i97 = 0;
            											}
HXLINE( 306)											int r44 = i97;
HXDLIN( 306)											int i98 = ::Std_obj::_hx_int((((( (Float)(gA7) ) * ratioA7) + (( (Float)(gB7) ) * ratioB7)) + (( (Float)(gC7) ) * ratioC7)));
HXDLIN( 306)											if ((i98 > 255)) {
HXLINE(  24)												i98 = 255;
            											}
HXLINE( 306)											if ((i98 < 0)) {
HXLINE(  25)												i98 = 0;
            											}
HXLINE( 306)											int g44 = i98;
HXDLIN( 306)											int i99 = ::Std_obj::_hx_int((((( (Float)(bA7) ) * ratioA7) + (( (Float)(bB7) ) * ratioB7)) + (( (Float)(bC7) ) * ratioC7)));
HXDLIN( 306)											if ((i99 > 255)) {
HXLINE(  24)												i99 = 255;
            											}
HXLINE( 306)											if ((i99 < 0)) {
HXLINE(  25)												i99 = 0;
            											}
HXLINE( 306)											int b69 = i99;
HXDLIN( 306)											{
HXLINE( 306)												int location19;
HXDLIN( 306)												if (this263->useVirtualPos) {
HXLINE( 306)													location19 = ::Std_obj::_hx_int(((((( (Float)(py7) ) - this263->virtualY) * ( (Float)(this263->width) )) + px7) - this263->virtualX));
            												}
            												else {
HXLINE( 306)													location19 = ::Std_obj::_hx_int(( (Float)(((py7 * this263->width) + px7)) ));
            												}
HXDLIN( 306)												bool _hx_tmp80;
HXDLIN( 306)												if (this263->transparent) {
HXLINE( 306)													_hx_tmp80 = (a60 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp80 = false;
            												}
HXDLIN( 306)												if (_hx_tmp80) {
HXLINE( 306)													int this317 = ::iterMagic::Iimg_obj::get(this263->image,location19);
HXDLIN( 306)													int old7;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old7 = ((((((this317 >> 24) & 255) << 24) | ((this317 & 255) << 16)) | (((this317 >> 8) & 255) << 8)) | ((this317 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old7 = this317;
            													}
HXDLIN( 306)													int rhs7 = ((((a60 << 24) | (r44 << 16)) | (g44 << 8)) | b69);
HXDLIN( 306)													Float a123;
HXDLIN( 306)													int this318 = ((old7 >> 24) & 255);
HXDLIN( 306)													if ((this318 == 0)) {
HXLINE( 306)														a123 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a123 = (( (Float)(this318) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r120;
HXDLIN( 306)													int this319 = ((old7 >> 16) & 255);
HXDLIN( 306)													if ((this319 == 0)) {
HXLINE( 306)														r120 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r120 = (( (Float)(this319) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g120;
HXDLIN( 306)													int this320 = ((old7 >> 8) & 255);
HXDLIN( 306)													if ((this320 == 0)) {
HXLINE( 306)														g120 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g120 = (( (Float)(this320) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b125;
HXDLIN( 306)													int this321 = (old7 & 255);
HXDLIN( 306)													if ((this321 == 0)) {
HXLINE( 306)														b125 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b125 = (( (Float)(this321) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a221;
HXDLIN( 306)													int this322 = ((rhs7 >> 24) & 255);
HXDLIN( 306)													if ((this322 == 0)) {
HXLINE( 306)														a221 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a221 = (( (Float)(this322) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r220;
HXDLIN( 306)													int this323 = ((rhs7 >> 16) & 255);
HXDLIN( 306)													if ((this323 == 0)) {
HXLINE( 306)														r220 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r220 = (( (Float)(this323) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g220;
HXDLIN( 306)													int this324 = ((rhs7 >> 8) & 255);
HXDLIN( 306)													if ((this324 == 0)) {
HXLINE( 306)														g220 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g220 = (( (Float)(this324) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b223;
HXDLIN( 306)													int this325 = (rhs7 & 255);
HXDLIN( 306)													if ((this325 == 0)) {
HXLINE( 306)														b223 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b223 = (( (Float)(this325) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a320 = (a123 * (( (Float)(1) ) - a221));
HXDLIN( 306)													int r45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 306)													int g45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 306)													int b70 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a320) + (b223 * a221))));
HXDLIN( 306)													int a61 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 306)													int blended19 = ((((a61 << 24) | (r45 << 16)) | (g45 << 8)) | b70);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp81;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp81 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp81 = blended19;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this263->image,location19,_hx_tmp81);
            													}
            												}
            												else {
HXLINE( 306)													int value7;
HXDLIN( 306)													if (this263->isLittle) {
HXLINE( 306)														value7 = ((((a60 << 24) | (b69 << 16)) | (g44 << 8)) | r44);
            													}
            													else {
HXLINE( 306)														value7 = ((((a60 << 24) | (r44 << 16)) | (g44 << 8)) | b69);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this263->image,location19,value7);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit9 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v33 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx5,y30,bx5,cy7,farX,cy7,true);
HXDLIN( 306)							if (hasUndo9) {
HXLINE( 306)								v33->undoImage = undoImage27;
HXDLIN( 306)								v33->undoX = xIter39->start;
HXDLIN( 306)								v33->undoY = yIter39->start;
            							}
            						}
            					}
HXDLIN( 306)					if ((hasHit8 == true)) {
HXLINE( 306)						 ::pi_xy::algo::HitQuad v34 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,farX,y30,bx5,y30,bx5,cy7,farX,cy7,true);
            					}
            				}
            			}
HXDLIN( 306)			Float inlobj_ax3 = farX;
HXDLIN( 306)			Float inlobj_ay3 = y30;
HXDLIN( 306)			Float inlobj_bx3 = bx5;
HXDLIN( 306)			Float inlobj_y3 = y30;
HXDLIN( 306)			Float inlobj_cx3 = bx5;
HXDLIN( 306)			Float inlobj_cy3 = cy7;
HXDLIN( 306)			Float inlobj_x3 = farX;
HXDLIN( 306)			Float inlobj_dy3 = cy7;
HXDLIN( 306)			{
HXLINE( 306)				 ::pi_xy::ImageStruct this326 = temp;
HXDLIN( 306)				Float cx3 = ( (Float)(dx1) );
HXDLIN( 306)				Float rx1 = ( (Float)(dx1) );
HXDLIN( 306)				{
HXLINE( 306)					 ::Dynamic targetError2 = ((Float)1.05);
HXDLIN( 306)					if (::hx::IsNull( targetError2 )) {
HXLINE( 113)						targetError2 = ((Float)1.05);
            					}
HXLINE( 306)					Float rSmall2;
HXDLIN( 306)					if ((rx1 > bottomRadius)) {
HXLINE( 306)						rSmall2 = bottomRadius;
            					}
            					else {
HXLINE( 306)						rSmall2 = rx1;
            					}
HXDLIN( 306)					 ::Dynamic targetE2 = ( (Float)(targetError2) );
HXDLIN( 306)					if (::hx::IsNull( targetE2 )) {
HXLINE(  20)						targetE2 = ((Float)1.05);
            					}
HXLINE( 306)					int result2 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE2) ) / rSmall2)))));
HXDLIN( 306)					int noSides2;
HXDLIN( 306)					if ((result2 < 12)) {
HXLINE( 306)						noSides2 = 12;
            					}
            					else {
HXLINE( 306)						if ((result2 > 500)) {
HXLINE( 306)							noSides2 = 500;
            						}
            						else {
HXLINE( 306)							noSides2 = result2;
            						}
            					}
HXDLIN( 306)					int sides2 = (::Math_obj::ceil((( (Float)(noSides2) ) / ( (Float)(4) ))) * 4);
HXDLIN( 306)					Float theta2 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides2) ));
HXDLIN( 306)					Float omega2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 306)					int quarter2 = ::Std_obj::_hx_int((( (Float)(sides2) ) / ( (Float)(4) )));
HXDLIN( 306)					Float lastX2 = ((Float)0.);
HXDLIN( 306)					Float lastY2 = ((Float)0.);
HXDLIN( 306)					{
HXLINE(  26)						lastX2 = (cx3 + (rx1 * ::Math_obj::cos(((( (Float)(sides2) ) * theta2) + omega2))));
HXLINE(  27)						lastY2 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides2) ) * theta2) + omega2))));
            					}
HXLINE( 306)					{
HXLINE( 306)						int _g220 = 0;
HXDLIN( 306)						int _g221 = (quarter2 + 1);
HXDLIN( 306)						while((_g220 < _g221)){
HXLINE( 306)							_g220 = (_g220 + 1);
HXDLIN( 306)							int i100 = (_g220 - 1);
HXDLIN( 306)							Float nextX2 = (cx3 + (rx1 * ::Math_obj::cos((((( (Float)(i100) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN( 306)							Float nextY2 = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i100) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN( 306)							{
HXLINE( 306)								 ::pi_xy::ImageStruct this327 = this326;
HXDLIN( 306)								bool hasHit10 = false;
HXDLIN( 306)								bool hasUndo10 = false;
HXDLIN( 306)								{
HXLINE( 306)									Float bx6 = lastX2;
HXDLIN( 306)									Float by2 = lastY2;
HXDLIN( 306)									Float cx4 = nextX2;
HXDLIN( 306)									Float cy8 = nextY2;
HXDLIN( 306)									bool adjustWinding2 = (((((cx3 * by2) - (bx6 * lowerY)) + ((bx6 * cy8) - (cx4 * by2))) + ((cx4 * lowerY) - (cx3 * cy8))) > 0);
HXDLIN( 306)									if (!(adjustWinding2)) {
HXLINE( 306)										Float bx_2 = bx6;
HXDLIN( 306)										Float by_2 = by2;
HXLINE(  25)										bx6 = cx4;
HXLINE(  26)										by2 = cy8;
HXLINE(  27)										cx4 = bx_2;
HXLINE(  28)										cy8 = by_2;
            									}
HXLINE( 306)									{
HXLINE( 306)										Float s02 = ((lowerY * cx4) - (cx3 * cy8));
HXDLIN( 306)										Float sx2 = (cy8 - lowerY);
HXDLIN( 306)										Float sy2 = (cx3 - cx4);
HXDLIN( 306)										Float t02 = ((cx3 * by2) - (lowerY * bx6));
HXDLIN( 306)										Float tx2 = (lowerY - by2);
HXDLIN( 306)										Float ty2 = (bx6 - cx3);
HXDLIN( 306)										Float A2 = ((((-(by2) * cx4) + (lowerY * (-(bx6) + cx4))) + (cx3 * (by2 - cy8))) + (bx6 * cy8));
HXDLIN( 306)										 ::pi_xy::iter::IntIterStart xIter310;
HXDLIN( 306)										if ((cx3 > bx6)) {
HXLINE( 306)											if ((cx3 > cx4)) {
HXLINE( 306)												int min37;
HXDLIN( 306)												if ((bx6 > cx4)) {
HXLINE( 306)													min37 = ::Math_obj::floor(cx4);
            												}
            												else {
HXLINE( 306)													min37 = ::Math_obj::floor(bx6);
            												}
HXDLIN( 306)												int ii_min77 = min37;
HXDLIN( 306)												int ii_max77 = ::Math_obj::ceil(cx3);
HXDLIN( 306)												xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min77,ii_max77);
            											}
            											else {
HXLINE( 306)												int ii_min78 = ::Math_obj::floor(bx6);
HXDLIN( 306)												int ii_max78 = ::Math_obj::ceil(cx4);
HXDLIN( 306)												xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min78,ii_max78);
            											}
            										}
            										else {
HXLINE( 306)											if ((bx6 > cx4)) {
HXLINE( 306)												int min38;
HXDLIN( 306)												if ((cx3 > cx4)) {
HXLINE( 306)													min38 = ::Math_obj::floor(cx4);
            												}
            												else {
HXLINE( 306)													min38 = ::Math_obj::ceil(cx3);
            												}
HXDLIN( 306)												int ii_min79 = min38;
HXDLIN( 306)												int ii_max79 = ::Math_obj::ceil(bx6);
HXDLIN( 306)												xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min79,ii_max79);
            											}
            											else {
HXLINE( 306)												int ii_min80 = ::Math_obj::floor(cx3);
HXDLIN( 306)												int ii_max80 = ::Math_obj::ceil(cx4);
HXDLIN( 306)												xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min80,ii_max80);
            											}
            										}
HXDLIN( 306)										 ::pi_xy::iter::IntIterStart yIter310;
HXDLIN( 306)										if ((lowerY > by2)) {
HXLINE( 306)											if ((lowerY > cy8)) {
HXLINE( 306)												int min39;
HXDLIN( 306)												if ((by2 > cy8)) {
HXLINE( 306)													min39 = ::Math_obj::floor(cy8);
            												}
            												else {
HXLINE( 306)													min39 = ::Math_obj::floor(by2);
            												}
HXDLIN( 306)												int ii_min81 = min39;
HXDLIN( 306)												int ii_max81 = ::Math_obj::ceil(lowerY);
HXDLIN( 306)												yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min81,ii_max81);
            											}
            											else {
HXLINE( 306)												int ii_min82 = ::Math_obj::floor(by2);
HXDLIN( 306)												int ii_max82 = ::Math_obj::ceil(cy8);
HXDLIN( 306)												yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min82,ii_max82);
            											}
            										}
            										else {
HXLINE( 306)											if ((by2 > cy8)) {
HXLINE( 306)												int min40;
HXDLIN( 306)												if ((lowerY > cy8)) {
HXLINE( 306)													min40 = ::Math_obj::floor(cy8);
            												}
            												else {
HXLINE( 306)													min40 = ::Math_obj::ceil(lowerY);
            												}
HXDLIN( 306)												int ii_min83 = min40;
HXDLIN( 306)												int ii_max83 = ::Math_obj::ceil(by2);
HXDLIN( 306)												yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min83,ii_max83);
            											}
            											else {
HXLINE( 306)												int ii_min84 = ::Math_obj::floor(lowerY);
HXDLIN( 306)												int ii_max84 = ::Math_obj::ceil(cy8);
HXDLIN( 306)												yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min84,ii_max84);
            											}
            										}
HXDLIN( 306)										 ::pi_xy::ImageStruct undoImage30 = null();
HXDLIN( 306)										if (hasUndo10) {
HXLINE( 306)											int width11 = ((xIter310->max - xIter310->start) + 1);
HXDLIN( 306)											int height11 = ((yIter310->max - yIter310->start) + 1);
HXDLIN( 306)											 ::Dynamic imageType11 = null();
HXDLIN( 306)											 ::pi_xy::ImageStruct this328 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)											if (::hx::IsNull( imageType11 )) {
HXLINE(  54)												imageType11 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 306)											::Dynamic undoImage31;
HXDLIN( 306)											switch((int)(( (int)(imageType11) ))){
            												case (int)0: {
HXLINE( 306)													 ::iterMagic::BytesImg byt11 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::BytesImg b71 = byt11;
HXDLIN( 306)													{
HXLINE( 306)														b71->width = width11;
HXDLIN( 306)														b71->height = height11;
HXDLIN( 306)														b71->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 306)														b71->data = ::haxe::io::Bytes_obj::alloc((b71->length * 4));
HXDLIN( 306)														{
HXLINE( 306)															int len22 = b71->length;
HXDLIN( 306)															int w11 = 0;
HXDLIN( 306)															{
HXLINE( 306)																int _g222 = 0;
HXDLIN( 306)																int _g223 = b71->height;
HXDLIN( 306)																while((_g222 < _g223)){
HXLINE( 306)																	_g222 = (_g222 + 1);
HXDLIN( 306)																	int y37 = (_g222 - 1);
HXDLIN( 306)																	{
HXLINE( 306)																		int _g224 = 0;
HXDLIN( 306)																		int _g225 = b71->width;
HXDLIN( 306)																		while((_g224 < _g225)){
HXLINE( 306)																			_g224 = (_g224 + 1);
HXDLIN( 306)																			int x36 = (_g224 - 1);
HXDLIN( 306)																			{
HXLINE( 306)																				w11 = (w11 + 1);
HXDLIN( 306)																				b71->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w11 = (w11 + 1);
HXDLIN( 306)																				b71->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w11 = (w11 + 1);
HXDLIN( 306)																				b71->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w11 = (w11 + 1);
HXDLIN( 306)																				b71->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage31 = b71;
            												}
            												break;
            												case (int)1: {
HXLINE( 306)													 ::iterMagic::ArrIntImg arrI11 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::ArrIntImg a62 = arrI11;
HXDLIN( 306)													{
HXLINE( 306)														a62->width = width11;
HXDLIN( 306)														a62->height = height11;
HXDLIN( 306)														a62->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)														a62->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 306)														{
HXLINE( 306)															int _g226 = 0;
HXDLIN( 306)															int _g227 = a62->length;
HXDLIN( 306)															while((_g226 < _g227)){
HXLINE( 306)																_g226 = (_g226 + 1);
HXDLIN( 306)																int i101 = (_g226 - 1);
HXDLIN( 306)																a62->data[i101] = 0;
            															}
            														}
            													}
HXDLIN( 306)													undoImage31 = a62;
            												}
            												break;
            												case (int)2: {
HXLINE( 306)													 ::iterMagic::U32ArrImg u32a11 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::U32ArrImg b72 = u32a11;
HXDLIN( 306)													{
HXLINE( 306)														b72->width = width11;
HXDLIN( 306)														b72->height = height11;
HXDLIN( 306)														b72->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 306)														int size11 = (b72->length * 4);
HXDLIN( 306)														b72->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size11),0,size11);
HXDLIN( 306)														{
HXLINE( 306)															int _g228 = 0;
HXDLIN( 306)															int _g229 = b72->length;
HXDLIN( 306)															while((_g228 < _g229)){
HXLINE( 306)																_g228 = (_g228 + 1);
HXDLIN( 306)																int i102 = (_g228 - 1);
HXDLIN( 306)																{
HXLINE( 306)																	 ::haxe::io::ArrayBufferViewImpl this329 = b72->data;
HXDLIN( 306)																	bool undoImage32;
HXDLIN( 306)																	if ((i102 >= 0)) {
HXLINE( 306)																		undoImage32 = (i102 < (this329->byteLength >> 2));
            																	}
            																	else {
HXLINE( 306)																		undoImage32 = false;
            																	}
HXDLIN( 306)																	if (undoImage32) {
HXLINE( 306)																		 ::haxe::io::Bytes _this11 = this329->bytes;
HXDLIN( 306)																		int pos11 = ((i102 << 2) + this329->byteOffset);
HXDLIN( 306)																		_this11->b[pos11] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this11->b[(pos11 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this11->b[(pos11 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this11->b[(pos11 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage31 = b72;
            												}
            												break;
            												case (int)3: {
HXLINE( 306)													 ::iterMagic::VecIntImg vec11 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::VecIntImg v35 = vec11;
HXDLIN( 306)													{
HXLINE( 306)														v35->width = width11;
HXDLIN( 306)														v35->height = height11;
HXDLIN( 306)														v35->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 306)														v35->data = ::Array_obj< int >::__new(v35->length);
HXDLIN( 306)														{
HXLINE( 306)															int _g230 = 0;
HXDLIN( 306)															int _g231 = v35->length;
HXDLIN( 306)															while((_g230 < _g231)){
HXLINE( 306)																_g230 = (_g230 + 1);
HXDLIN( 306)																int i103 = (_g230 - 1);
HXDLIN( 306)																v35->data->__unsafe_set(i103,0);
            															}
            														}
            													}
HXDLIN( 306)													undoImage31 = v35;
            												}
            												break;
            												case (int)4: {
HXLINE( 306)													 ::iterMagic::StackIntImg sInt11 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::StackIntImg b73 = sInt11;
HXDLIN( 306)													{
HXLINE( 306)														b73->width = width11;
HXDLIN( 306)														b73->height = height11;
HXDLIN( 306)														b73->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 306)														b73->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)														{
HXLINE( 306)															int len23 = b73->length;
HXDLIN( 306)															 ::haxe::ds::GenericStack_Int d11 = b73->data;
HXDLIN( 306)															if (::hx::IsNull( d11->head )) {
HXLINE( 306)																int _g232 = 0;
HXDLIN( 306)																int _g233 = len23;
HXDLIN( 306)																while((_g232 < _g233)){
HXLINE( 306)																	_g232 = (_g232 + 1);
HXDLIN( 306)																	int i104 = (_g232 - 1);
HXDLIN( 306)																	d11->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d11->head);
            																}
            															}
            															else {
HXLINE( 306)																int _g234 = 0;
HXDLIN( 306)																int _g235 = len23;
HXDLIN( 306)																while((_g234 < _g235)){
HXLINE( 306)																	_g234 = (_g234 + 1);
HXDLIN( 306)																	int i105 = (_g234 - 1);
HXDLIN( 306)																	{
HXLINE( 306)																		 ::haxe::ds::GenericCell_Int l11 = b73->data->head;
HXDLIN( 306)																		 ::haxe::ds::GenericCell_Int prev11 = null();
HXDLIN( 306)																		{
HXLINE( 306)																			int _g236 = 0;
HXDLIN( 306)																			int _g237 = i105;
HXDLIN( 306)																			while((_g236 < _g237)){
HXLINE( 306)																				_g236 = (_g236 + 1);
HXDLIN( 306)																				int i106 = (_g236 - 1);
HXLINE( 345)																				prev11 = l11;
HXLINE( 346)																				l11 = l11->next;
            																			}
            																		}
HXLINE( 306)																		if (::hx::IsNull( prev11 )) {
HXLINE( 306)																			b73->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l11->next);
HXDLIN( 306)																			l11 = null();
            																		}
            																		else {
HXLINE( 306)																			prev11->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l11->next);
HXDLIN( 306)																			l11 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage31 = b73;
            												}
            												break;
            											}
HXDLIN( 306)											this328->image = undoImage31;
HXDLIN( 306)											this328->width = width11;
HXDLIN( 306)											this328->height = height11;
HXDLIN( 306)											this328->imageType = ( (int)(imageType11) );
HXDLIN( 306)											undoImage30 = this328;
HXDLIN( 306)											{
HXLINE( 306)												int rectLeft10 = xIter310->start;
HXDLIN( 306)												int rectTop10 = yIter310->start;
HXDLIN( 306)												int rectRight10 = xIter310->max;
HXDLIN( 306)												bool forceClear10 = false;
HXDLIN( 306)												{
HXLINE( 306)													int _g238 = rectTop10;
HXDLIN( 306)													int _g239 = yIter310->max;
HXDLIN( 306)													while((_g238 < _g239)){
HXLINE( 306)														_g238 = (_g238 + 1);
HXDLIN( 306)														int dy12 = (_g238 - 1);
HXDLIN( 306)														{
HXLINE( 306)															int _g240 = rectLeft10;
HXDLIN( 306)															int _g241 = rectRight10;
HXDLIN( 306)															while((_g240 < _g241)){
HXLINE( 306)																_g240 = (_g240 + 1);
HXDLIN( 306)																int dx12 = (_g240 - 1);
HXDLIN( 306)																::Dynamic this330 = this327->image;
HXDLIN( 306)																int index42;
HXDLIN( 306)																if (this327->useVirtualPos) {
HXLINE( 306)																	index42 = ::Std_obj::_hx_int(((((( (Float)(dy12) ) - this327->virtualY) * ( (Float)(this327->width) )) + dx12) - this327->virtualX));
            																}
            																else {
HXLINE( 306)																	index42 = ::Std_obj::_hx_int(( (Float)(((dy12 * this327->width) + dx12)) ));
            																}
HXDLIN( 306)																int c32 = ::iterMagic::Iimg_obj::get(this330,index42);
HXDLIN( 306)																int col10;
HXDLIN( 306)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																	col10 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            																}
            																else {
HXLINE( 306)																	col10 = c32;
            																}
HXDLIN( 306)																bool _hx_tmp82;
HXDLIN( 306)																if (this327->useMask) {
HXLINE( 306)																	_hx_tmp82 = ::hx::IsNotNull( this327->mask );
            																}
            																else {
HXLINE( 306)																	_hx_tmp82 = false;
            																}
HXDLIN( 306)																if (_hx_tmp82) {
HXLINE( 306)																	 ::pi_xy::ImageStruct this331 = this327->mask;
HXDLIN( 306)																	::Dynamic this332 = this331->image;
HXDLIN( 306)																	int index43;
HXDLIN( 306)																	if (this331->useVirtualPos) {
HXLINE( 306)																		index43 = ::Std_obj::_hx_int(((((( (Float)(dy12) ) - this331->virtualY) * ( (Float)(this331->width) )) + dx12) - this331->virtualX));
            																	}
            																	else {
HXLINE( 306)																		index43 = ::Std_obj::_hx_int(( (Float)(((dy12 * this331->width) + dx12)) ));
            																	}
HXDLIN( 306)																	int c33 = ::iterMagic::Iimg_obj::get(this332,index43);
HXDLIN( 306)																	int v36;
HXDLIN( 306)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																		v36 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            																	}
            																	else {
HXLINE( 306)																		v36 = c33;
            																	}
HXDLIN( 306)																	int maskPixel10 = v36;
HXDLIN( 306)																	int this333 = col10;
HXDLIN( 306)																	if ((maskPixel10 == 0)) {
HXLINE( 306)																		col10 = this333;
            																	}
            																	else {
HXLINE( 306)																		Float m010;
HXDLIN( 306)																		int this334 = ((maskPixel10 >> 24) & 255);
HXDLIN( 306)																		if ((this334 == 0)) {
HXLINE( 306)																			m010 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m010 = (( (Float)(this334) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m110;
HXDLIN( 306)																		int this335 = ((maskPixel10 >> 16) & 255);
HXDLIN( 306)																		if ((this335 == 0)) {
HXLINE( 306)																			m110 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m110 = (( (Float)(this335) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m210;
HXDLIN( 306)																		int this336 = ((maskPixel10 >> 8) & 255);
HXDLIN( 306)																		if ((this336 == 0)) {
HXLINE( 306)																			m210 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m210 = (( (Float)(this336) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m310;
HXDLIN( 306)																		int this337 = (maskPixel10 & 255);
HXDLIN( 306)																		if ((this337 == 0)) {
HXLINE( 306)																			m310 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m310 = (( (Float)(this337) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		int ch010 = ::Std_obj::_hx_int(((((Float)1.) - m010) * ( (Float)(((this333 >> 24) & 255)) )));
HXDLIN( 306)																		int ch110 = ::Std_obj::_hx_int(((((Float)1.) - m110) * ( (Float)(((this333 >> 16) & 255)) )));
HXDLIN( 306)																		int ch210 = ::Std_obj::_hx_int(((((Float)1.) - m210) * ( (Float)(((this333 >> 8) & 255)) )));
HXDLIN( 306)																		int ch310 = ::Std_obj::_hx_int(((((Float)1.) - m310) * ( (Float)((this333 & 255)) )));
HXDLIN( 306)																		col10 = ((((::Math_obj::round((( (Float)(ch010) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch110) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch210) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch310) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 306)																if ((col10 != 0)) {
HXLINE( 306)																	int x37 = (dx12 - rectLeft10);
HXDLIN( 306)																	int y38 = (dy12 - rectTop10);
HXDLIN( 306)																	int c34 = col10;
HXDLIN( 306)																	bool _hx_tmp83;
HXDLIN( 306)																	if ((((c34 >> 24) & 255) < 254)) {
HXLINE( 306)																		_hx_tmp83 = undoImage30->transparent;
            																	}
            																	else {
HXLINE( 306)																		_hx_tmp83 = false;
            																	}
HXDLIN( 306)																	if (_hx_tmp83) {
HXLINE( 306)																		int location20;
HXDLIN( 306)																		if (undoImage30->useVirtualPos) {
HXLINE( 306)																			location20 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x37) - undoImage30->virtualX));
            																		}
            																		else {
HXLINE( 306)																			location20 = ::Std_obj::_hx_int(( (Float)(((y38 * undoImage30->width) + x37)) ));
            																		}
HXDLIN( 306)																		int this338 = ::iterMagic::Iimg_obj::get(undoImage30->image,location20);
HXDLIN( 306)																		int this339;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			this339 = ((((((this338 >> 24) & 255) << 24) | ((this338 & 255) << 16)) | (((this338 >> 8) & 255) << 8)) | ((this338 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			this339 = this338;
            																		}
HXDLIN( 306)																		Float a124;
HXDLIN( 306)																		int this340 = ((this339 >> 24) & 255);
HXDLIN( 306)																		if ((this340 == 0)) {
HXLINE( 306)																			a124 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a124 = (( (Float)(this340) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r121;
HXDLIN( 306)																		int this341 = ((this339 >> 16) & 255);
HXDLIN( 306)																		if ((this341 == 0)) {
HXLINE( 306)																			r121 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r121 = (( (Float)(this341) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g121;
HXDLIN( 306)																		int this342 = ((this339 >> 8) & 255);
HXDLIN( 306)																		if ((this342 == 0)) {
HXLINE( 306)																			g121 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g121 = (( (Float)(this342) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b126;
HXDLIN( 306)																		int this343 = (this339 & 255);
HXDLIN( 306)																		if ((this343 == 0)) {
HXLINE( 306)																			b126 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b126 = (( (Float)(this343) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a222;
HXDLIN( 306)																		int this344 = ((col10 >> 24) & 255);
HXDLIN( 306)																		if ((this344 == 0)) {
HXLINE( 306)																			a222 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a222 = (( (Float)(this344) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r221;
HXDLIN( 306)																		int this345 = ((col10 >> 16) & 255);
HXDLIN( 306)																		if ((this345 == 0)) {
HXLINE( 306)																			r221 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r221 = (( (Float)(this345) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g221;
HXDLIN( 306)																		int this346 = ((col10 >> 8) & 255);
HXDLIN( 306)																		if ((this346 == 0)) {
HXLINE( 306)																			g221 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g221 = (( (Float)(this346) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b224;
HXDLIN( 306)																		int this347 = (col10 & 255);
HXDLIN( 306)																		if ((this347 == 0)) {
HXLINE( 306)																			b224 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b224 = (( (Float)(this347) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a321 = (a124 * (( (Float)(1) ) - a222));
HXDLIN( 306)																		int r46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 306)																		int g46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 306)																		int b74 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a321) + (b224 * a222))));
HXDLIN( 306)																		int a63 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 306)																		int blended20 = ((((a63 << 24) | (r46 << 16)) | (g46 << 8)) | b74);
HXDLIN( 306)																		{
HXLINE( 306)																			int _hx_tmp84;
HXDLIN( 306)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																				_hx_tmp84 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            																			}
            																			else {
HXLINE( 306)																				_hx_tmp84 = blended20;
            																			}
HXDLIN( 306)																			::iterMagic::Iimg_obj::set(undoImage30->image,location20,_hx_tmp84);
            																		}
            																	}
            																	else {
HXLINE( 306)																		::Dynamic this348 = undoImage30->image;
HXDLIN( 306)																		int index44;
HXDLIN( 306)																		if (undoImage30->useVirtualPos) {
HXLINE( 306)																			index44 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x37) - undoImage30->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index44 = ::Std_obj::_hx_int(( (Float)(((y38 * undoImage30->width) + x37)) ));
            																		}
HXDLIN( 306)																		int _hx_tmp85;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			_hx_tmp85 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			_hx_tmp85 = c34;
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this348,index44,_hx_tmp85);
            																	}
            																}
            																else {
HXLINE( 306)																	if (forceClear10) {
HXLINE( 306)																		::Dynamic this349 = undoImage30->image;
HXDLIN( 306)																		int x38 = (dx12 - rectLeft10);
HXDLIN( 306)																		int y39 = (dy12 - rectTop10);
HXDLIN( 306)																		int index45;
HXDLIN( 306)																		if (undoImage30->useVirtualPos) {
HXLINE( 306)																			index45 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x38) - undoImage30->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index45 = ::Std_obj::_hx_int(( (Float)(((y39 * undoImage30->width) + x38)) ));
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this349,index45,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 306)										bool found2 = false;
HXDLIN( 306)										Float s2 = ((Float)0.);
HXDLIN( 306)										Float t2 = ((Float)0.);
HXDLIN( 306)										Float sxx2 = ((Float)0.);
HXDLIN( 306)										Float txx2 = ((Float)0.);
HXDLIN( 306)										{
HXLINE( 306)											int _g_min20 = xIter310->start;
HXDLIN( 306)											int _g_max20 = xIter310->max;
HXDLIN( 306)											while((_g_min20 < _g_max20)){
HXLINE( 306)												_g_min20 = (_g_min20 + 1);
HXDLIN( 306)												int x39 = (_g_min20 - 1);
HXLINE(  60)												sxx2 = (sx2 * ( (Float)(x39) ));
HXLINE(  61)												txx2 = (tx2 * ( (Float)(x39) ));
HXLINE(  62)												found2 = false;
HXLINE( 306)												{
HXLINE( 306)													int _g_min21 = yIter310->start;
HXDLIN( 306)													int _g_max21 = yIter310->max;
HXDLIN( 306)													while((_g_min21 < _g_max21)){
HXLINE( 306)														_g_min21 = (_g_min21 + 1);
HXDLIN( 306)														int y40 = (_g_min21 - 1);
HXLINE(  64)														s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y40) )));
HXLINE(  65)														t2 = ((t02 + txx2) + (ty2 * ( (Float)(y40) )));
HXLINE( 306)														bool _hx_tmp86;
HXDLIN( 306)														if (!((s2 <= 0))) {
HXLINE( 306)															_hx_tmp86 = (t2 <= 0);
            														}
            														else {
HXLINE( 306)															_hx_tmp86 = true;
            														}
HXDLIN( 306)														if (_hx_tmp86) {
HXLINE( 306)															if (found2) {
HXLINE( 306)																goto _hx_goto_815;
            															}
            														}
            														else {
HXLINE( 306)															if (((s2 + t2) < A2)) {
HXLINE( 306)																{
HXLINE( 306)																	int c35 = colorD;
HXDLIN( 306)																	bool _hx_tmp87;
HXDLIN( 306)																	if ((((c35 >> 24) & 255) < 254)) {
HXLINE( 306)																		_hx_tmp87 = this327->transparent;
            																	}
            																	else {
HXLINE( 306)																		_hx_tmp87 = false;
            																	}
HXDLIN( 306)																	if (_hx_tmp87) {
HXLINE( 306)																		int location21;
HXDLIN( 306)																		if (this327->useVirtualPos) {
HXLINE( 306)																			location21 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - this327->virtualY) * ( (Float)(this327->width) )) + x39) - this327->virtualX));
            																		}
            																		else {
HXLINE( 306)																			location21 = ::Std_obj::_hx_int(( (Float)(((y40 * this327->width) + x39)) ));
            																		}
HXDLIN( 306)																		int this350 = ::iterMagic::Iimg_obj::get(this327->image,location21);
HXDLIN( 306)																		int this351;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			this351 = ((((((this350 >> 24) & 255) << 24) | ((this350 & 255) << 16)) | (((this350 >> 8) & 255) << 8)) | ((this350 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			this351 = this350;
            																		}
HXDLIN( 306)																		Float a125;
HXDLIN( 306)																		int this352 = ((this351 >> 24) & 255);
HXDLIN( 306)																		if ((this352 == 0)) {
HXLINE( 306)																			a125 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a125 = (( (Float)(this352) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r122;
HXDLIN( 306)																		int this353 = ((this351 >> 16) & 255);
HXDLIN( 306)																		if ((this353 == 0)) {
HXLINE( 306)																			r122 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r122 = (( (Float)(this353) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g122;
HXDLIN( 306)																		int this354 = ((this351 >> 8) & 255);
HXDLIN( 306)																		if ((this354 == 0)) {
HXLINE( 306)																			g122 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g122 = (( (Float)(this354) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b127;
HXDLIN( 306)																		int this355 = (this351 & 255);
HXDLIN( 306)																		if ((this355 == 0)) {
HXLINE( 306)																			b127 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b127 = (( (Float)(this355) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a223;
HXDLIN( 306)																		int this356 = ((colorD >> 24) & 255);
HXDLIN( 306)																		if ((this356 == 0)) {
HXLINE( 306)																			a223 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a223 = (( (Float)(this356) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r222;
HXDLIN( 306)																		int this357 = ((colorD >> 16) & 255);
HXDLIN( 306)																		if ((this357 == 0)) {
HXLINE( 306)																			r222 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r222 = (( (Float)(this357) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g222;
HXDLIN( 306)																		int this358 = ((colorD >> 8) & 255);
HXDLIN( 306)																		if ((this358 == 0)) {
HXLINE( 306)																			g222 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g222 = (( (Float)(this358) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b225;
HXDLIN( 306)																		int this359 = (colorD & 255);
HXDLIN( 306)																		if ((this359 == 0)) {
HXLINE( 306)																			b225 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b225 = (( (Float)(this359) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a322 = (a125 * (( (Float)(1) ) - a223));
HXDLIN( 306)																		int r47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 306)																		int g47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 306)																		int b75 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b127 * a322) + (b225 * a223))));
HXDLIN( 306)																		int a64 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 306)																		int blended21 = ((((a64 << 24) | (r47 << 16)) | (g47 << 8)) | b75);
HXDLIN( 306)																		{
HXLINE( 306)																			int _hx_tmp88;
HXDLIN( 306)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																				_hx_tmp88 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            																			}
            																			else {
HXLINE( 306)																				_hx_tmp88 = blended21;
            																			}
HXDLIN( 306)																			::iterMagic::Iimg_obj::set(this327->image,location21,_hx_tmp88);
            																		}
            																	}
            																	else {
HXLINE( 306)																		::Dynamic this360 = this327->image;
HXDLIN( 306)																		int index46;
HXDLIN( 306)																		if (this327->useVirtualPos) {
HXLINE( 306)																			index46 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - this327->virtualY) * ( (Float)(this327->width) )) + x39) - this327->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index46 = ::Std_obj::_hx_int(( (Float)(((y40 * this327->width) + x39)) ));
            																		}
HXDLIN( 306)																		int _hx_tmp89;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			_hx_tmp89 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			_hx_tmp89 = c35;
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this360,index46,_hx_tmp89);
            																	}
            																}
HXLINE(  73)																found2 = true;
            															}
            															else {
HXLINE( 306)																if (found2) {
HXLINE( 306)																	goto _hx_goto_815;
            																}
            															}
            														}
            													}
            													_hx_goto_815:;
            												}
            											}
            										}
HXDLIN( 306)										if ((hasHit10 == true)) {
HXLINE( 306)											 ::pi_xy::algo::HitTri v37 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx3,lowerY,bx6,by2,cx4,cy8,true);
HXDLIN( 306)											if (hasUndo10) {
HXLINE( 306)												v37->undoImage = undoImage30;
HXDLIN( 306)												v37->undoX = xIter310->start;
HXDLIN( 306)												v37->undoY = yIter310->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX2 = nextX2;
HXLINE(  47)							lastY2 = nextY2;
            						}
            					}
            				}
            			}
HXLINE( 306)			 ::pi_xy::ImageStruct this361 = temp;
HXDLIN( 306)			Float x40 = ( (Float)(dx1) );
HXDLIN( 306)			Float bx7 = (x40 + ( (Float)(fat1) ));
HXDLIN( 306)			Float cy9 = (lowerY + bottomRadius);
HXDLIN( 306)			{
HXLINE( 306)				bool hasHit11 = true;
HXDLIN( 306)				{
HXLINE( 306)					{
HXLINE( 306)						bool hasUndo11 = false;
HXDLIN( 306)						int aA8 = ((colorB >> 24) & 255);
HXDLIN( 306)						int rA8 = ((colorB >> 16) & 255);
HXDLIN( 306)						int gA8 = ((colorB >> 8) & 255);
HXDLIN( 306)						int bA8 = (colorB & 255);
HXDLIN( 306)						int aB8 = ((colorD >> 24) & 255);
HXDLIN( 306)						int rB8 = ((colorD >> 16) & 255);
HXDLIN( 306)						int gB8 = ((colorD >> 8) & 255);
HXDLIN( 306)						int bB8 = (colorD & 255);
HXDLIN( 306)						int aC8 = ((colorD >> 24) & 255);
HXDLIN( 306)						int rC8 = ((colorD >> 16) & 255);
HXDLIN( 306)						int gC8 = ((colorD >> 8) & 255);
HXDLIN( 306)						int bC8 = (colorD & 255);
HXDLIN( 306)						Float bcx8 = (bx7 - x40);
HXDLIN( 306)						Float bcy8 = (lowerY - cy9);
HXDLIN( 306)						Float acx8 = (x40 - x40);
HXDLIN( 306)						Float acy8 = (lowerY - cy9);
HXDLIN( 306)						Float dot118 = ((bcx8 * bcx8) + (bcy8 * bcy8));
HXDLIN( 306)						Float dot128 = ((bcx8 * acx8) + (bcy8 * acy8));
HXDLIN( 306)						Float dot228 = ((acx8 * acx8) + (acy8 * acy8));
HXDLIN( 306)						Float denom18 = (( (Float)(1) ) / ((dot118 * dot228) - (dot128 * dot128)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter311;
HXDLIN( 306)						if ((x40 > bx7)) {
HXLINE( 306)							if ((x40 > x40)) {
HXLINE( 306)								int min41;
HXDLIN( 306)								if ((bx7 > x40)) {
HXLINE( 306)									min41 = ::Math_obj::floor(x40);
            								}
            								else {
HXLINE( 306)									min41 = ::Math_obj::floor(bx7);
            								}
HXDLIN( 306)								int ii_min85 = min41;
HXDLIN( 306)								int ii_max85 = ::Math_obj::ceil(x40);
HXDLIN( 306)								xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min85,ii_max85);
            							}
            							else {
HXLINE( 306)								int ii_min86 = ::Math_obj::floor(bx7);
HXDLIN( 306)								int ii_max86 = ::Math_obj::ceil(x40);
HXDLIN( 306)								xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min86,ii_max86);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx7 > x40)) {
HXLINE( 306)								int min42;
HXDLIN( 306)								if ((x40 > x40)) {
HXLINE( 306)									min42 = ::Math_obj::floor(x40);
            								}
            								else {
HXLINE( 306)									min42 = ::Math_obj::ceil(x40);
            								}
HXDLIN( 306)								int ii_min87 = min42;
HXDLIN( 306)								int ii_max87 = ::Math_obj::ceil(bx7);
HXDLIN( 306)								xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min87,ii_max87);
            							}
            							else {
HXLINE( 306)								int ii_min88 = ::Math_obj::floor(x40);
HXDLIN( 306)								int ii_max88 = ::Math_obj::ceil(x40);
HXDLIN( 306)								xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min88,ii_max88);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter311;
HXDLIN( 306)						if ((lowerY > lowerY)) {
HXLINE( 306)							if ((lowerY > cy9)) {
HXLINE( 306)								int min43;
HXDLIN( 306)								if ((lowerY > cy9)) {
HXLINE( 306)									min43 = ::Math_obj::floor(cy9);
            								}
            								else {
HXLINE( 306)									min43 = ::Math_obj::floor(lowerY);
            								}
HXDLIN( 306)								int ii_min89 = min43;
HXDLIN( 306)								int ii_max89 = ::Math_obj::ceil(lowerY);
HXDLIN( 306)								yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min89,ii_max89);
            							}
            							else {
HXLINE( 306)								int ii_min90 = ::Math_obj::floor(lowerY);
HXDLIN( 306)								int ii_max90 = ::Math_obj::ceil(cy9);
HXDLIN( 306)								yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min90,ii_max90);
            							}
            						}
            						else {
HXLINE( 306)							if ((lowerY > cy9)) {
HXLINE( 306)								int min44;
HXDLIN( 306)								if ((lowerY > cy9)) {
HXLINE( 306)									min44 = ::Math_obj::floor(cy9);
            								}
            								else {
HXLINE( 306)									min44 = ::Math_obj::ceil(lowerY);
            								}
HXDLIN( 306)								int ii_min91 = min44;
HXDLIN( 306)								int ii_max91 = ::Math_obj::ceil(lowerY);
HXDLIN( 306)								yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min91,ii_max91);
            							}
            							else {
HXLINE( 306)								int ii_min92 = ::Math_obj::floor(lowerY);
HXDLIN( 306)								int ii_max92 = ::Math_obj::ceil(cy9);
HXDLIN( 306)								yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min92,ii_max92);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage33 = null();
HXDLIN( 306)						if (hasUndo11) {
HXLINE( 306)							int width12 = ((xIter311->max - xIter311->start) + 1);
HXDLIN( 306)							int height12 = ((yIter311->max - yIter311->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType12 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this362 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType12 )) {
HXLINE(  54)								imageType12 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage34;
HXDLIN( 306)							switch((int)(( (int)(imageType12) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt12 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b76 = byt12;
HXDLIN( 306)									{
HXLINE( 306)										b76->width = width12;
HXDLIN( 306)										b76->height = height12;
HXDLIN( 306)										b76->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 306)										b76->data = ::haxe::io::Bytes_obj::alloc((b76->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len24 = b76->length;
HXDLIN( 306)											int w12 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g242 = 0;
HXDLIN( 306)												int _g243 = b76->height;
HXDLIN( 306)												while((_g242 < _g243)){
HXLINE( 306)													_g242 = (_g242 + 1);
HXDLIN( 306)													int y41 = (_g242 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g244 = 0;
HXDLIN( 306)														int _g245 = b76->width;
HXDLIN( 306)														while((_g244 < _g245)){
HXLINE( 306)															_g244 = (_g244 + 1);
HXDLIN( 306)															int x41 = (_g244 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w12 = (w12 + 1);
HXDLIN( 306)																b76->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w12 = (w12 + 1);
HXDLIN( 306)																b76->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w12 = (w12 + 1);
HXDLIN( 306)																b76->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w12 = (w12 + 1);
HXDLIN( 306)																b76->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage34 = b76;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI12 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a65 = arrI12;
HXDLIN( 306)									{
HXLINE( 306)										a65->width = width12;
HXDLIN( 306)										a65->height = height12;
HXDLIN( 306)										a65->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a65->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g246 = 0;
HXDLIN( 306)											int _g247 = a65->length;
HXDLIN( 306)											while((_g246 < _g247)){
HXLINE( 306)												_g246 = (_g246 + 1);
HXDLIN( 306)												int i107 = (_g246 - 1);
HXDLIN( 306)												a65->data[i107] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage34 = a65;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a12 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b77 = u32a12;
HXDLIN( 306)									{
HXLINE( 306)										b77->width = width12;
HXDLIN( 306)										b77->height = height12;
HXDLIN( 306)										b77->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 306)										int size12 = (b77->length * 4);
HXDLIN( 306)										b77->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size12),0,size12);
HXDLIN( 306)										{
HXLINE( 306)											int _g248 = 0;
HXDLIN( 306)											int _g249 = b77->length;
HXDLIN( 306)											while((_g248 < _g249)){
HXLINE( 306)												_g248 = (_g248 + 1);
HXDLIN( 306)												int i108 = (_g248 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this363 = b77->data;
HXDLIN( 306)													bool undoImage35;
HXDLIN( 306)													if ((i108 >= 0)) {
HXLINE( 306)														undoImage35 = (i108 < (this363->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage35 = false;
            													}
HXDLIN( 306)													if (undoImage35) {
HXLINE( 306)														 ::haxe::io::Bytes _this12 = this363->bytes;
HXDLIN( 306)														int pos12 = ((i108 << 2) + this363->byteOffset);
HXDLIN( 306)														_this12->b[pos12] = ( (unsigned char)(0) );
HXDLIN( 306)														_this12->b[(pos12 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this12->b[(pos12 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this12->b[(pos12 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage34 = b77;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec12 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v38 = vec12;
HXDLIN( 306)									{
HXLINE( 306)										v38->width = width12;
HXDLIN( 306)										v38->height = height12;
HXDLIN( 306)										v38->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 306)										v38->data = ::Array_obj< int >::__new(v38->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g250 = 0;
HXDLIN( 306)											int _g251 = v38->length;
HXDLIN( 306)											while((_g250 < _g251)){
HXLINE( 306)												_g250 = (_g250 + 1);
HXDLIN( 306)												int i109 = (_g250 - 1);
HXDLIN( 306)												v38->data->__unsafe_set(i109,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage34 = v38;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt12 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b78 = sInt12;
HXDLIN( 306)									{
HXLINE( 306)										b78->width = width12;
HXDLIN( 306)										b78->height = height12;
HXDLIN( 306)										b78->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 306)										b78->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len25 = b78->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d12 = b78->data;
HXDLIN( 306)											if (::hx::IsNull( d12->head )) {
HXLINE( 306)												int _g252 = 0;
HXDLIN( 306)												int _g253 = len25;
HXDLIN( 306)												while((_g252 < _g253)){
HXLINE( 306)													_g252 = (_g252 + 1);
HXDLIN( 306)													int i110 = (_g252 - 1);
HXDLIN( 306)													d12->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d12->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g254 = 0;
HXDLIN( 306)												int _g255 = len25;
HXDLIN( 306)												while((_g254 < _g255)){
HXLINE( 306)													_g254 = (_g254 + 1);
HXDLIN( 306)													int i111 = (_g254 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l12 = b78->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev12 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g256 = 0;
HXDLIN( 306)															int _g257 = i111;
HXDLIN( 306)															while((_g256 < _g257)){
HXLINE( 306)																_g256 = (_g256 + 1);
HXDLIN( 306)																int i112 = (_g256 - 1);
HXLINE( 345)																prev12 = l12;
HXLINE( 346)																l12 = l12->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev12 )) {
HXLINE( 306)															b78->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l12->next);
HXDLIN( 306)															l12 = null();
            														}
            														else {
HXLINE( 306)															prev12->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l12->next);
HXDLIN( 306)															l12 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage34 = b78;
            								}
            								break;
            							}
HXDLIN( 306)							this362->image = undoImage34;
HXDLIN( 306)							this362->width = width12;
HXDLIN( 306)							this362->height = height12;
HXDLIN( 306)							this362->imageType = ( (int)(imageType12) );
HXDLIN( 306)							undoImage33 = this362;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft11 = xIter311->start;
HXDLIN( 306)								int rectTop11 = yIter311->start;
HXDLIN( 306)								int rectRight11 = xIter311->max;
HXDLIN( 306)								bool forceClear11 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g258 = rectTop11;
HXDLIN( 306)									int _g259 = yIter311->max;
HXDLIN( 306)									while((_g258 < _g259)){
HXLINE( 306)										_g258 = (_g258 + 1);
HXDLIN( 306)										int dy13 = (_g258 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g260 = rectLeft11;
HXDLIN( 306)											int _g261 = rectRight11;
HXDLIN( 306)											while((_g260 < _g261)){
HXLINE( 306)												_g260 = (_g260 + 1);
HXDLIN( 306)												int dx13 = (_g260 - 1);
HXDLIN( 306)												::Dynamic this364 = this361->image;
HXDLIN( 306)												int index47;
HXDLIN( 306)												if (this361->useVirtualPos) {
HXLINE( 306)													index47 = ::Std_obj::_hx_int(((((( (Float)(dy13) ) - this361->virtualY) * ( (Float)(this361->width) )) + dx13) - this361->virtualX));
            												}
            												else {
HXLINE( 306)													index47 = ::Std_obj::_hx_int(( (Float)(((dy13 * this361->width) + dx13)) ));
            												}
HXDLIN( 306)												int c36 = ::iterMagic::Iimg_obj::get(this364,index47);
HXDLIN( 306)												int col11;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col11 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col11 = c36;
            												}
HXDLIN( 306)												bool _hx_tmp90;
HXDLIN( 306)												if (this361->useMask) {
HXLINE( 306)													_hx_tmp90 = ::hx::IsNotNull( this361->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp90 = false;
            												}
HXDLIN( 306)												if (_hx_tmp90) {
HXLINE( 306)													 ::pi_xy::ImageStruct this365 = this361->mask;
HXDLIN( 306)													::Dynamic this366 = this365->image;
HXDLIN( 306)													int index48;
HXDLIN( 306)													if (this365->useVirtualPos) {
HXLINE( 306)														index48 = ::Std_obj::_hx_int(((((( (Float)(dy13) ) - this365->virtualY) * ( (Float)(this365->width) )) + dx13) - this365->virtualX));
            													}
            													else {
HXLINE( 306)														index48 = ::Std_obj::_hx_int(( (Float)(((dy13 * this365->width) + dx13)) ));
            													}
HXDLIN( 306)													int c37 = ::iterMagic::Iimg_obj::get(this366,index48);
HXDLIN( 306)													int v39;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v39 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v39 = c37;
            													}
HXDLIN( 306)													int maskPixel11 = v39;
HXDLIN( 306)													int this367 = col11;
HXDLIN( 306)													if ((maskPixel11 == 0)) {
HXLINE( 306)														col11 = this367;
            													}
            													else {
HXLINE( 306)														Float m011;
HXDLIN( 306)														int this368 = ((maskPixel11 >> 24) & 255);
HXDLIN( 306)														if ((this368 == 0)) {
HXLINE( 306)															m011 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m011 = (( (Float)(this368) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m111;
HXDLIN( 306)														int this369 = ((maskPixel11 >> 16) & 255);
HXDLIN( 306)														if ((this369 == 0)) {
HXLINE( 306)															m111 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m111 = (( (Float)(this369) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m211;
HXDLIN( 306)														int this370 = ((maskPixel11 >> 8) & 255);
HXDLIN( 306)														if ((this370 == 0)) {
HXLINE( 306)															m211 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m211 = (( (Float)(this370) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m311;
HXDLIN( 306)														int this371 = (maskPixel11 & 255);
HXDLIN( 306)														if ((this371 == 0)) {
HXLINE( 306)															m311 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m311 = (( (Float)(this371) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch011 = ::Std_obj::_hx_int(((((Float)1.) - m011) * ( (Float)(((this367 >> 24) & 255)) )));
HXDLIN( 306)														int ch111 = ::Std_obj::_hx_int(((((Float)1.) - m111) * ( (Float)(((this367 >> 16) & 255)) )));
HXDLIN( 306)														int ch211 = ::Std_obj::_hx_int(((((Float)1.) - m211) * ( (Float)(((this367 >> 8) & 255)) )));
HXDLIN( 306)														int ch311 = ::Std_obj::_hx_int(((((Float)1.) - m311) * ( (Float)((this367 & 255)) )));
HXDLIN( 306)														col11 = ((((::Math_obj::round((( (Float)(ch011) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch111) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch211) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch311) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col11 != 0)) {
HXLINE( 306)													int x42 = (dx13 - rectLeft11);
HXDLIN( 306)													int y42 = (dy13 - rectTop11);
HXDLIN( 306)													int c38 = col11;
HXDLIN( 306)													bool _hx_tmp91;
HXDLIN( 306)													if ((((c38 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp91 = undoImage33->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp91 = false;
            													}
HXDLIN( 306)													if (_hx_tmp91) {
HXLINE( 306)														int location22;
HXDLIN( 306)														if (undoImage33->useVirtualPos) {
HXLINE( 306)															location22 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x42) - undoImage33->virtualX));
            														}
            														else {
HXLINE( 306)															location22 = ::Std_obj::_hx_int(( (Float)(((y42 * undoImage33->width) + x42)) ));
            														}
HXDLIN( 306)														int this372 = ::iterMagic::Iimg_obj::get(undoImage33->image,location22);
HXDLIN( 306)														int this373;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this373 = ((((((this372 >> 24) & 255) << 24) | ((this372 & 255) << 16)) | (((this372 >> 8) & 255) << 8)) | ((this372 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this373 = this372;
            														}
HXDLIN( 306)														Float a126;
HXDLIN( 306)														int this374 = ((this373 >> 24) & 255);
HXDLIN( 306)														if ((this374 == 0)) {
HXLINE( 306)															a126 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a126 = (( (Float)(this374) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r123;
HXDLIN( 306)														int this375 = ((this373 >> 16) & 255);
HXDLIN( 306)														if ((this375 == 0)) {
HXLINE( 306)															r123 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r123 = (( (Float)(this375) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g123;
HXDLIN( 306)														int this376 = ((this373 >> 8) & 255);
HXDLIN( 306)														if ((this376 == 0)) {
HXLINE( 306)															g123 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g123 = (( (Float)(this376) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b128;
HXDLIN( 306)														int this377 = (this373 & 255);
HXDLIN( 306)														if ((this377 == 0)) {
HXLINE( 306)															b128 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b128 = (( (Float)(this377) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a224;
HXDLIN( 306)														int this378 = ((col11 >> 24) & 255);
HXDLIN( 306)														if ((this378 == 0)) {
HXLINE( 306)															a224 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a224 = (( (Float)(this378) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r223;
HXDLIN( 306)														int this379 = ((col11 >> 16) & 255);
HXDLIN( 306)														if ((this379 == 0)) {
HXLINE( 306)															r223 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r223 = (( (Float)(this379) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g223;
HXDLIN( 306)														int this380 = ((col11 >> 8) & 255);
HXDLIN( 306)														if ((this380 == 0)) {
HXLINE( 306)															g223 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g223 = (( (Float)(this380) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b226;
HXDLIN( 306)														int this381 = (col11 & 255);
HXDLIN( 306)														if ((this381 == 0)) {
HXLINE( 306)															b226 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b226 = (( (Float)(this381) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a323 = (a126 * (( (Float)(1) ) - a224));
HXDLIN( 306)														int r48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 306)														int g48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 306)														int b79 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b128 * a323) + (b226 * a224))));
HXDLIN( 306)														int a66 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 306)														int blended22 = ((((a66 << 24) | (r48 << 16)) | (g48 << 8)) | b79);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp92;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp92 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp92 = blended22;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage33->image,location22,_hx_tmp92);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this382 = undoImage33->image;
HXDLIN( 306)														int index49;
HXDLIN( 306)														if (undoImage33->useVirtualPos) {
HXLINE( 306)															index49 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x42) - undoImage33->virtualX));
            														}
            														else {
HXLINE( 306)															index49 = ::Std_obj::_hx_int(( (Float)(((y42 * undoImage33->width) + x42)) ));
            														}
HXDLIN( 306)														int _hx_tmp93;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp93 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp93 = c38;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this382,index49,_hx_tmp93);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear11) {
HXLINE( 306)														::Dynamic this383 = undoImage33->image;
HXDLIN( 306)														int x43 = (dx13 - rectLeft11);
HXDLIN( 306)														int y43 = (dy13 - rectTop11);
HXDLIN( 306)														int index50;
HXDLIN( 306)														if (undoImage33->useVirtualPos) {
HXLINE( 306)															index50 = ::Std_obj::_hx_int(((((( (Float)(y43) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x43) - undoImage33->virtualX));
            														}
            														else {
HXLINE( 306)															index50 = ::Std_obj::_hx_int(( (Float)(((y43 * undoImage33->width) + x43)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this383,index50,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min22 = xIter311->start;
HXDLIN( 306)							int _g_max22 = xIter311->max;
HXDLIN( 306)							while((_g_min22 < _g_max22)){
HXLINE( 306)								_g_min22 = (_g_min22 + 1);
HXDLIN( 306)								int px8 = (_g_min22 - 1);
HXDLIN( 306)								Float pcx8 = (( (Float)(px8) ) - x40);
HXDLIN( 306)								{
HXLINE( 306)									int _g_min23 = yIter311->start;
HXDLIN( 306)									int _g_max23 = yIter311->max;
HXDLIN( 306)									while((_g_min23 < _g_max23)){
HXLINE( 306)										_g_min23 = (_g_min23 + 1);
HXDLIN( 306)										int py8 = (_g_min23 - 1);
HXDLIN( 306)										Float pcy8 = (( (Float)(py8) ) - cy9);
HXDLIN( 306)										Float dot318 = ((pcx8 * bcx8) + (pcy8 * bcy8));
HXDLIN( 306)										Float dot328 = ((pcx8 * acx8) + (pcy8 * acy8));
HXDLIN( 306)										Float ratioA8 = (((dot228 * dot318) - (dot128 * dot328)) * denom18);
HXDLIN( 306)										Float ratioB8 = (((dot118 * dot328) - (dot128 * dot318)) * denom18);
HXDLIN( 306)										Float ratioC8 = ((((Float)1.0) - ratioB8) - ratioA8);
HXDLIN( 306)										bool _hx_tmp94;
HXDLIN( 306)										bool _hx_tmp95;
HXDLIN( 306)										if ((ratioA8 >= 0)) {
HXLINE( 306)											_hx_tmp95 = (ratioB8 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp95 = false;
            										}
HXDLIN( 306)										if (_hx_tmp95) {
HXLINE( 306)											_hx_tmp94 = (ratioC8 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp94 = false;
            										}
HXDLIN( 306)										if (_hx_tmp94) {
HXLINE( 306)											int i113 = ::Std_obj::_hx_int((((( (Float)(aA8) ) * ratioA8) + (( (Float)(aB8) ) * ratioB8)) + (( (Float)(aC8) ) * ratioC8)));
HXDLIN( 306)											if ((i113 > 255)) {
HXLINE(  24)												i113 = 255;
            											}
HXLINE( 306)											if ((i113 < 0)) {
HXLINE(  25)												i113 = 0;
            											}
HXLINE( 306)											int a67 = i113;
HXDLIN( 306)											int i114 = ::Std_obj::_hx_int((((( (Float)(rA8) ) * ratioA8) + (( (Float)(rB8) ) * ratioB8)) + (( (Float)(rC8) ) * ratioC8)));
HXDLIN( 306)											if ((i114 > 255)) {
HXLINE(  24)												i114 = 255;
            											}
HXLINE( 306)											if ((i114 < 0)) {
HXLINE(  25)												i114 = 0;
            											}
HXLINE( 306)											int r49 = i114;
HXDLIN( 306)											int i115 = ::Std_obj::_hx_int((((( (Float)(gA8) ) * ratioA8) + (( (Float)(gB8) ) * ratioB8)) + (( (Float)(gC8) ) * ratioC8)));
HXDLIN( 306)											if ((i115 > 255)) {
HXLINE(  24)												i115 = 255;
            											}
HXLINE( 306)											if ((i115 < 0)) {
HXLINE(  25)												i115 = 0;
            											}
HXLINE( 306)											int g49 = i115;
HXDLIN( 306)											int i116 = ::Std_obj::_hx_int((((( (Float)(bA8) ) * ratioA8) + (( (Float)(bB8) ) * ratioB8)) + (( (Float)(bC8) ) * ratioC8)));
HXDLIN( 306)											if ((i116 > 255)) {
HXLINE(  24)												i116 = 255;
            											}
HXLINE( 306)											if ((i116 < 0)) {
HXLINE(  25)												i116 = 0;
            											}
HXLINE( 306)											int b80 = i116;
HXDLIN( 306)											{
HXLINE( 306)												int location23;
HXDLIN( 306)												if (this361->useVirtualPos) {
HXLINE( 306)													location23 = ::Std_obj::_hx_int(((((( (Float)(py8) ) - this361->virtualY) * ( (Float)(this361->width) )) + px8) - this361->virtualX));
            												}
            												else {
HXLINE( 306)													location23 = ::Std_obj::_hx_int(( (Float)(((py8 * this361->width) + px8)) ));
            												}
HXDLIN( 306)												bool _hx_tmp96;
HXDLIN( 306)												if (this361->transparent) {
HXLINE( 306)													_hx_tmp96 = (a67 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp96 = false;
            												}
HXDLIN( 306)												if (_hx_tmp96) {
HXLINE( 306)													int this384 = ::iterMagic::Iimg_obj::get(this361->image,location23);
HXDLIN( 306)													int old8;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old8 = ((((((this384 >> 24) & 255) << 24) | ((this384 & 255) << 16)) | (((this384 >> 8) & 255) << 8)) | ((this384 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old8 = this384;
            													}
HXDLIN( 306)													int rhs8 = ((((a67 << 24) | (r49 << 16)) | (g49 << 8)) | b80);
HXDLIN( 306)													Float a127;
HXDLIN( 306)													int this385 = ((old8 >> 24) & 255);
HXDLIN( 306)													if ((this385 == 0)) {
HXLINE( 306)														a127 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a127 = (( (Float)(this385) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r124;
HXDLIN( 306)													int this386 = ((old8 >> 16) & 255);
HXDLIN( 306)													if ((this386 == 0)) {
HXLINE( 306)														r124 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r124 = (( (Float)(this386) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g124;
HXDLIN( 306)													int this387 = ((old8 >> 8) & 255);
HXDLIN( 306)													if ((this387 == 0)) {
HXLINE( 306)														g124 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g124 = (( (Float)(this387) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b129;
HXDLIN( 306)													int this388 = (old8 & 255);
HXDLIN( 306)													if ((this388 == 0)) {
HXLINE( 306)														b129 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b129 = (( (Float)(this388) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a225;
HXDLIN( 306)													int this389 = ((rhs8 >> 24) & 255);
HXDLIN( 306)													if ((this389 == 0)) {
HXLINE( 306)														a225 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a225 = (( (Float)(this389) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r224;
HXDLIN( 306)													int this390 = ((rhs8 >> 16) & 255);
HXDLIN( 306)													if ((this390 == 0)) {
HXLINE( 306)														r224 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r224 = (( (Float)(this390) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g224;
HXDLIN( 306)													int this391 = ((rhs8 >> 8) & 255);
HXDLIN( 306)													if ((this391 == 0)) {
HXLINE( 306)														g224 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g224 = (( (Float)(this391) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b227;
HXDLIN( 306)													int this392 = (rhs8 & 255);
HXDLIN( 306)													if ((this392 == 0)) {
HXLINE( 306)														b227 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b227 = (( (Float)(this392) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a324 = (a127 * (( (Float)(1) ) - a225));
HXDLIN( 306)													int r50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r124 * a324) + (r224 * a225))));
HXDLIN( 306)													int g50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g124 * a324) + (g224 * a225))));
HXDLIN( 306)													int b81 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b129 * a324) + (b227 * a225))));
HXDLIN( 306)													int a68 = ::Std_obj::_hx_int((( (Float)(255) ) * (a324 + a225)));
HXDLIN( 306)													int blended23 = ((((a68 << 24) | (r50 << 16)) | (g50 << 8)) | b81);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp97;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp97 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp97 = blended23;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this361->image,location23,_hx_tmp97);
            													}
            												}
            												else {
HXLINE( 306)													int value8;
HXDLIN( 306)													if (this361->isLittle) {
HXLINE( 306)														value8 = ((((a67 << 24) | (b80 << 16)) | (g49 << 8)) | r49);
            													}
            													else {
HXLINE( 306)														value8 = ((((a67 << 24) | (r49 << 16)) | (g49 << 8)) | b80);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this361->image,location23,value8);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit11 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v40 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x40,lowerY,bx7,lowerY,x40,cy9,true);
HXDLIN( 306)							if (hasUndo11) {
HXLINE( 306)								v40->undoImage = undoImage33;
HXDLIN( 306)								v40->undoX = xIter311->start;
HXDLIN( 306)								v40->undoY = yIter311->start;
            							}
            						}
            					}
HXDLIN( 306)					{
HXLINE( 306)						bool hasHit12 = false;
HXDLIN( 306)						bool hasUndo12 = false;
HXDLIN( 306)						int aA9 = ((colorB >> 24) & 255);
HXDLIN( 306)						int rA9 = ((colorB >> 16) & 255);
HXDLIN( 306)						int gA9 = ((colorB >> 8) & 255);
HXDLIN( 306)						int bA9 = (colorB & 255);
HXDLIN( 306)						int aB9 = ((colorB >> 24) & 255);
HXDLIN( 306)						int rB9 = ((colorB >> 16) & 255);
HXDLIN( 306)						int gB9 = ((colorB >> 8) & 255);
HXDLIN( 306)						int bB9 = (colorB & 255);
HXDLIN( 306)						int aC9 = ((colorD >> 24) & 255);
HXDLIN( 306)						int rC9 = ((colorD >> 16) & 255);
HXDLIN( 306)						int gC9 = ((colorD >> 8) & 255);
HXDLIN( 306)						int bC9 = (colorD & 255);
HXDLIN( 306)						Float bcx9 = (bx7 - x40);
HXDLIN( 306)						Float bcy9 = (cy9 - cy9);
HXDLIN( 306)						Float acx9 = (bx7 - x40);
HXDLIN( 306)						Float acy9 = (lowerY - cy9);
HXDLIN( 306)						Float dot119 = ((bcx9 * bcx9) + (bcy9 * bcy9));
HXDLIN( 306)						Float dot129 = ((bcx9 * acx9) + (bcy9 * acy9));
HXDLIN( 306)						Float dot229 = ((acx9 * acx9) + (acy9 * acy9));
HXDLIN( 306)						Float denom19 = (( (Float)(1) ) / ((dot119 * dot229) - (dot129 * dot129)));
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart xIter312;
HXDLIN( 306)						if ((bx7 > bx7)) {
HXLINE( 306)							if ((bx7 > x40)) {
HXLINE( 306)								int min45;
HXDLIN( 306)								if ((bx7 > x40)) {
HXLINE( 306)									min45 = ::Math_obj::floor(x40);
            								}
            								else {
HXLINE( 306)									min45 = ::Math_obj::floor(bx7);
            								}
HXDLIN( 306)								int ii_min93 = min45;
HXDLIN( 306)								int ii_max93 = ::Math_obj::ceil(bx7);
HXDLIN( 306)								xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min93,ii_max93);
            							}
            							else {
HXLINE( 306)								int ii_min94 = ::Math_obj::floor(bx7);
HXDLIN( 306)								int ii_max94 = ::Math_obj::ceil(x40);
HXDLIN( 306)								xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min94,ii_max94);
            							}
            						}
            						else {
HXLINE( 306)							if ((bx7 > x40)) {
HXLINE( 306)								int min46;
HXDLIN( 306)								if ((bx7 > x40)) {
HXLINE( 306)									min46 = ::Math_obj::floor(x40);
            								}
            								else {
HXLINE( 306)									min46 = ::Math_obj::ceil(bx7);
            								}
HXDLIN( 306)								int ii_min95 = min46;
HXDLIN( 306)								int ii_max95 = ::Math_obj::ceil(bx7);
HXDLIN( 306)								xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min95,ii_max95);
            							}
            							else {
HXLINE( 306)								int ii_min96 = ::Math_obj::floor(bx7);
HXDLIN( 306)								int ii_max96 = ::Math_obj::ceil(x40);
HXDLIN( 306)								xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min96,ii_max96);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::iter::IntIterStart yIter312;
HXDLIN( 306)						if ((lowerY > cy9)) {
HXLINE( 306)							if ((lowerY > cy9)) {
HXLINE( 306)								int min47;
HXDLIN( 306)								if ((cy9 > cy9)) {
HXLINE( 306)									min47 = ::Math_obj::floor(cy9);
            								}
            								else {
HXLINE( 306)									min47 = ::Math_obj::floor(cy9);
            								}
HXDLIN( 306)								int ii_min97 = min47;
HXDLIN( 306)								int ii_max97 = ::Math_obj::ceil(lowerY);
HXDLIN( 306)								yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min97,ii_max97);
            							}
            							else {
HXLINE( 306)								int ii_min98 = ::Math_obj::floor(cy9);
HXDLIN( 306)								int ii_max98 = ::Math_obj::ceil(cy9);
HXDLIN( 306)								yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min98,ii_max98);
            							}
            						}
            						else {
HXLINE( 306)							if ((cy9 > cy9)) {
HXLINE( 306)								int min48;
HXDLIN( 306)								if ((lowerY > cy9)) {
HXLINE( 306)									min48 = ::Math_obj::floor(cy9);
            								}
            								else {
HXLINE( 306)									min48 = ::Math_obj::ceil(lowerY);
            								}
HXDLIN( 306)								int ii_min99 = min48;
HXDLIN( 306)								int ii_max99 = ::Math_obj::ceil(cy9);
HXDLIN( 306)								yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min99,ii_max99);
            							}
            							else {
HXLINE( 306)								int ii_min100 = ::Math_obj::floor(lowerY);
HXDLIN( 306)								int ii_max100 = ::Math_obj::ceil(cy9);
HXDLIN( 306)								yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min100,ii_max100);
            							}
            						}
HXDLIN( 306)						 ::pi_xy::ImageStruct undoImage36 = null();
HXDLIN( 306)						if (hasUndo12) {
HXLINE( 306)							int width13 = ((xIter312->max - xIter312->start) + 1);
HXDLIN( 306)							int height13 = ((yIter312->max - yIter312->start) + 1);
HXDLIN( 306)							 ::Dynamic imageType13 = null();
HXDLIN( 306)							 ::pi_xy::ImageStruct this393 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)							if (::hx::IsNull( imageType13 )) {
HXLINE(  54)								imageType13 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 306)							::Dynamic undoImage37;
HXDLIN( 306)							switch((int)(( (int)(imageType13) ))){
            								case (int)0: {
HXLINE( 306)									 ::iterMagic::BytesImg byt13 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::BytesImg b82 = byt13;
HXDLIN( 306)									{
HXLINE( 306)										b82->width = width13;
HXDLIN( 306)										b82->height = height13;
HXDLIN( 306)										b82->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 306)										b82->data = ::haxe::io::Bytes_obj::alloc((b82->length * 4));
HXDLIN( 306)										{
HXLINE( 306)											int len26 = b82->length;
HXDLIN( 306)											int w13 = 0;
HXDLIN( 306)											{
HXLINE( 306)												int _g262 = 0;
HXDLIN( 306)												int _g263 = b82->height;
HXDLIN( 306)												while((_g262 < _g263)){
HXLINE( 306)													_g262 = (_g262 + 1);
HXDLIN( 306)													int y44 = (_g262 - 1);
HXDLIN( 306)													{
HXLINE( 306)														int _g264 = 0;
HXDLIN( 306)														int _g265 = b82->width;
HXDLIN( 306)														while((_g264 < _g265)){
HXLINE( 306)															_g264 = (_g264 + 1);
HXDLIN( 306)															int x44 = (_g264 - 1);
HXDLIN( 306)															{
HXLINE( 306)																w13 = (w13 + 1);
HXDLIN( 306)																b82->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w13 = (w13 + 1);
HXDLIN( 306)																b82->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w13 = (w13 + 1);
HXDLIN( 306)																b82->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 306)															{
HXLINE( 306)																w13 = (w13 + 1);
HXDLIN( 306)																b82->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage37 = b82;
            								}
            								break;
            								case (int)1: {
HXLINE( 306)									 ::iterMagic::ArrIntImg arrI13 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::ArrIntImg a69 = arrI13;
HXDLIN( 306)									{
HXLINE( 306)										a69->width = width13;
HXDLIN( 306)										a69->height = height13;
HXDLIN( 306)										a69->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)										a69->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 306)										{
HXLINE( 306)											int _g266 = 0;
HXDLIN( 306)											int _g267 = a69->length;
HXDLIN( 306)											while((_g266 < _g267)){
HXLINE( 306)												_g266 = (_g266 + 1);
HXDLIN( 306)												int i117 = (_g266 - 1);
HXDLIN( 306)												a69->data[i117] = 0;
            											}
            										}
            									}
HXDLIN( 306)									undoImage37 = a69;
            								}
            								break;
            								case (int)2: {
HXLINE( 306)									 ::iterMagic::U32ArrImg u32a13 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::U32ArrImg b83 = u32a13;
HXDLIN( 306)									{
HXLINE( 306)										b83->width = width13;
HXDLIN( 306)										b83->height = height13;
HXDLIN( 306)										b83->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 306)										int size13 = (b83->length * 4);
HXDLIN( 306)										b83->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size13),0,size13);
HXDLIN( 306)										{
HXLINE( 306)											int _g268 = 0;
HXDLIN( 306)											int _g269 = b83->length;
HXDLIN( 306)											while((_g268 < _g269)){
HXLINE( 306)												_g268 = (_g268 + 1);
HXDLIN( 306)												int i118 = (_g268 - 1);
HXDLIN( 306)												{
HXLINE( 306)													 ::haxe::io::ArrayBufferViewImpl this394 = b83->data;
HXDLIN( 306)													bool undoImage38;
HXDLIN( 306)													if ((i118 >= 0)) {
HXLINE( 306)														undoImage38 = (i118 < (this394->byteLength >> 2));
            													}
            													else {
HXLINE( 306)														undoImage38 = false;
            													}
HXDLIN( 306)													if (undoImage38) {
HXLINE( 306)														 ::haxe::io::Bytes _this13 = this394->bytes;
HXDLIN( 306)														int pos13 = ((i118 << 2) + this394->byteOffset);
HXDLIN( 306)														_this13->b[pos13] = ( (unsigned char)(0) );
HXDLIN( 306)														_this13->b[(pos13 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this13->b[(pos13 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)														_this13->b[(pos13 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage37 = b83;
            								}
            								break;
            								case (int)3: {
HXLINE( 306)									 ::iterMagic::VecIntImg vec13 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::VecIntImg v41 = vec13;
HXDLIN( 306)									{
HXLINE( 306)										v41->width = width13;
HXDLIN( 306)										v41->height = height13;
HXDLIN( 306)										v41->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 306)										v41->data = ::Array_obj< int >::__new(v41->length);
HXDLIN( 306)										{
HXLINE( 306)											int _g270 = 0;
HXDLIN( 306)											int _g271 = v41->length;
HXDLIN( 306)											while((_g270 < _g271)){
HXLINE( 306)												_g270 = (_g270 + 1);
HXDLIN( 306)												int i119 = (_g270 - 1);
HXDLIN( 306)												v41->data->__unsafe_set(i119,0);
            											}
            										}
            									}
HXDLIN( 306)									undoImage37 = v41;
            								}
            								break;
            								case (int)4: {
HXLINE( 306)									 ::iterMagic::StackIntImg sInt13 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)									 ::iterMagic::StackIntImg b84 = sInt13;
HXDLIN( 306)									{
HXLINE( 306)										b84->width = width13;
HXDLIN( 306)										b84->height = height13;
HXDLIN( 306)										b84->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 306)										b84->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)										{
HXLINE( 306)											int len27 = b84->length;
HXDLIN( 306)											 ::haxe::ds::GenericStack_Int d13 = b84->data;
HXDLIN( 306)											if (::hx::IsNull( d13->head )) {
HXLINE( 306)												int _g272 = 0;
HXDLIN( 306)												int _g273 = len27;
HXDLIN( 306)												while((_g272 < _g273)){
HXLINE( 306)													_g272 = (_g272 + 1);
HXDLIN( 306)													int i120 = (_g272 - 1);
HXDLIN( 306)													d13->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d13->head);
            												}
            											}
            											else {
HXLINE( 306)												int _g274 = 0;
HXDLIN( 306)												int _g275 = len27;
HXDLIN( 306)												while((_g274 < _g275)){
HXLINE( 306)													_g274 = (_g274 + 1);
HXDLIN( 306)													int i121 = (_g274 - 1);
HXDLIN( 306)													{
HXLINE( 306)														 ::haxe::ds::GenericCell_Int l13 = b84->data->head;
HXDLIN( 306)														 ::haxe::ds::GenericCell_Int prev13 = null();
HXDLIN( 306)														{
HXLINE( 306)															int _g276 = 0;
HXDLIN( 306)															int _g277 = i121;
HXDLIN( 306)															while((_g276 < _g277)){
HXLINE( 306)																_g276 = (_g276 + 1);
HXDLIN( 306)																int i122 = (_g276 - 1);
HXLINE( 345)																prev13 = l13;
HXLINE( 346)																l13 = l13->next;
            															}
            														}
HXLINE( 306)														if (::hx::IsNull( prev13 )) {
HXLINE( 306)															b84->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l13->next);
HXDLIN( 306)															l13 = null();
            														}
            														else {
HXLINE( 306)															prev13->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l13->next);
HXDLIN( 306)															l13 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 306)									undoImage37 = b84;
            								}
            								break;
            							}
HXDLIN( 306)							this393->image = undoImage37;
HXDLIN( 306)							this393->width = width13;
HXDLIN( 306)							this393->height = height13;
HXDLIN( 306)							this393->imageType = ( (int)(imageType13) );
HXDLIN( 306)							undoImage36 = this393;
HXDLIN( 306)							{
HXLINE( 306)								int rectLeft12 = xIter312->start;
HXDLIN( 306)								int rectTop12 = yIter312->start;
HXDLIN( 306)								int rectRight12 = xIter312->max;
HXDLIN( 306)								bool forceClear12 = false;
HXDLIN( 306)								{
HXLINE( 306)									int _g278 = rectTop12;
HXDLIN( 306)									int _g279 = yIter312->max;
HXDLIN( 306)									while((_g278 < _g279)){
HXLINE( 306)										_g278 = (_g278 + 1);
HXDLIN( 306)										int dy14 = (_g278 - 1);
HXDLIN( 306)										{
HXLINE( 306)											int _g280 = rectLeft12;
HXDLIN( 306)											int _g281 = rectRight12;
HXDLIN( 306)											while((_g280 < _g281)){
HXLINE( 306)												_g280 = (_g280 + 1);
HXDLIN( 306)												int dx14 = (_g280 - 1);
HXDLIN( 306)												::Dynamic this395 = this361->image;
HXDLIN( 306)												int index51;
HXDLIN( 306)												if (this361->useVirtualPos) {
HXLINE( 306)													index51 = ::Std_obj::_hx_int(((((( (Float)(dy14) ) - this361->virtualY) * ( (Float)(this361->width) )) + dx14) - this361->virtualX));
            												}
            												else {
HXLINE( 306)													index51 = ::Std_obj::_hx_int(( (Float)(((dy14 * this361->width) + dx14)) ));
            												}
HXDLIN( 306)												int c39 = ::iterMagic::Iimg_obj::get(this395,index51);
HXDLIN( 306)												int col12;
HXDLIN( 306)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)													col12 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            												}
            												else {
HXLINE( 306)													col12 = c39;
            												}
HXDLIN( 306)												bool _hx_tmp98;
HXDLIN( 306)												if (this361->useMask) {
HXLINE( 306)													_hx_tmp98 = ::hx::IsNotNull( this361->mask );
            												}
            												else {
HXLINE( 306)													_hx_tmp98 = false;
            												}
HXDLIN( 306)												if (_hx_tmp98) {
HXLINE( 306)													 ::pi_xy::ImageStruct this396 = this361->mask;
HXDLIN( 306)													::Dynamic this397 = this396->image;
HXDLIN( 306)													int index52;
HXDLIN( 306)													if (this396->useVirtualPos) {
HXLINE( 306)														index52 = ::Std_obj::_hx_int(((((( (Float)(dy14) ) - this396->virtualY) * ( (Float)(this396->width) )) + dx14) - this396->virtualX));
            													}
            													else {
HXLINE( 306)														index52 = ::Std_obj::_hx_int(( (Float)(((dy14 * this396->width) + dx14)) ));
            													}
HXDLIN( 306)													int c40 = ::iterMagic::Iimg_obj::get(this397,index52);
HXDLIN( 306)													int v42;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														v42 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														v42 = c40;
            													}
HXDLIN( 306)													int maskPixel12 = v42;
HXDLIN( 306)													int this398 = col12;
HXDLIN( 306)													if ((maskPixel12 == 0)) {
HXLINE( 306)														col12 = this398;
            													}
            													else {
HXLINE( 306)														Float m012;
HXDLIN( 306)														int this399 = ((maskPixel12 >> 24) & 255);
HXDLIN( 306)														if ((this399 == 0)) {
HXLINE( 306)															m012 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m012 = (( (Float)(this399) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m112;
HXDLIN( 306)														int this400 = ((maskPixel12 >> 16) & 255);
HXDLIN( 306)														if ((this400 == 0)) {
HXLINE( 306)															m112 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m112 = (( (Float)(this400) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m212;
HXDLIN( 306)														int this401 = ((maskPixel12 >> 8) & 255);
HXDLIN( 306)														if ((this401 == 0)) {
HXLINE( 306)															m212 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m212 = (( (Float)(this401) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float m312;
HXDLIN( 306)														int this402 = (maskPixel12 & 255);
HXDLIN( 306)														if ((this402 == 0)) {
HXLINE( 306)															m312 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															m312 = (( (Float)(this402) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														int ch012 = ::Std_obj::_hx_int(((((Float)1.) - m012) * ( (Float)(((this398 >> 24) & 255)) )));
HXDLIN( 306)														int ch112 = ::Std_obj::_hx_int(((((Float)1.) - m112) * ( (Float)(((this398 >> 16) & 255)) )));
HXDLIN( 306)														int ch212 = ::Std_obj::_hx_int(((((Float)1.) - m212) * ( (Float)(((this398 >> 8) & 255)) )));
HXDLIN( 306)														int ch312 = ::Std_obj::_hx_int(((((Float)1.) - m312) * ( (Float)((this398 & 255)) )));
HXDLIN( 306)														col12 = ((((::Math_obj::round((( (Float)(ch012) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch112) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch212) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch312) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 306)												if ((col12 != 0)) {
HXLINE( 306)													int x45 = (dx14 - rectLeft12);
HXDLIN( 306)													int y45 = (dy14 - rectTop12);
HXDLIN( 306)													int c41 = col12;
HXDLIN( 306)													bool _hx_tmp99;
HXDLIN( 306)													if ((((c41 >> 24) & 255) < 254)) {
HXLINE( 306)														_hx_tmp99 = undoImage36->transparent;
            													}
            													else {
HXLINE( 306)														_hx_tmp99 = false;
            													}
HXDLIN( 306)													if (_hx_tmp99) {
HXLINE( 306)														int location24;
HXDLIN( 306)														if (undoImage36->useVirtualPos) {
HXLINE( 306)															location24 = ::Std_obj::_hx_int(((((( (Float)(y45) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x45) - undoImage36->virtualX));
            														}
            														else {
HXLINE( 306)															location24 = ::Std_obj::_hx_int(( (Float)(((y45 * undoImage36->width) + x45)) ));
            														}
HXDLIN( 306)														int this403 = ::iterMagic::Iimg_obj::get(undoImage36->image,location24);
HXDLIN( 306)														int this404;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															this404 = ((((((this403 >> 24) & 255) << 24) | ((this403 & 255) << 16)) | (((this403 >> 8) & 255) << 8)) | ((this403 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															this404 = this403;
            														}
HXDLIN( 306)														Float a128;
HXDLIN( 306)														int this405 = ((this404 >> 24) & 255);
HXDLIN( 306)														if ((this405 == 0)) {
HXLINE( 306)															a128 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a128 = (( (Float)(this405) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r125;
HXDLIN( 306)														int this406 = ((this404 >> 16) & 255);
HXDLIN( 306)														if ((this406 == 0)) {
HXLINE( 306)															r125 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r125 = (( (Float)(this406) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g125;
HXDLIN( 306)														int this407 = ((this404 >> 8) & 255);
HXDLIN( 306)														if ((this407 == 0)) {
HXLINE( 306)															g125 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g125 = (( (Float)(this407) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b130;
HXDLIN( 306)														int this408 = (this404 & 255);
HXDLIN( 306)														if ((this408 == 0)) {
HXLINE( 306)															b130 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b130 = (( (Float)(this408) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a226;
HXDLIN( 306)														int this409 = ((col12 >> 24) & 255);
HXDLIN( 306)														if ((this409 == 0)) {
HXLINE( 306)															a226 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															a226 = (( (Float)(this409) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float r225;
HXDLIN( 306)														int this410 = ((col12 >> 16) & 255);
HXDLIN( 306)														if ((this410 == 0)) {
HXLINE( 306)															r225 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															r225 = (( (Float)(this410) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float g225;
HXDLIN( 306)														int this411 = ((col12 >> 8) & 255);
HXDLIN( 306)														if ((this411 == 0)) {
HXLINE( 306)															g225 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															g225 = (( (Float)(this411) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float b228;
HXDLIN( 306)														int this412 = (col12 & 255);
HXDLIN( 306)														if ((this412 == 0)) {
HXLINE( 306)															b228 = ((Float)0.);
            														}
            														else {
HXLINE( 306)															b228 = (( (Float)(this412) ) / ( (Float)(255) ));
            														}
HXDLIN( 306)														Float a325 = (a128 * (( (Float)(1) ) - a226));
HXDLIN( 306)														int r51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r125 * a325) + (r225 * a226))));
HXDLIN( 306)														int g51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g125 * a325) + (g225 * a226))));
HXDLIN( 306)														int b85 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b130 * a325) + (b228 * a226))));
HXDLIN( 306)														int a70 = ::Std_obj::_hx_int((( (Float)(255) ) * (a325 + a226)));
HXDLIN( 306)														int blended24 = ((((a70 << 24) | (r51 << 16)) | (g51 << 8)) | b85);
HXDLIN( 306)														{
HXLINE( 306)															int _hx_tmp100;
HXDLIN( 306)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																_hx_tmp100 = ((((((blended24 >> 24) & 255) << 24) | ((blended24 & 255) << 16)) | (((blended24 >> 8) & 255) << 8)) | ((blended24 >> 16) & 255));
            															}
            															else {
HXLINE( 306)																_hx_tmp100 = blended24;
            															}
HXDLIN( 306)															::iterMagic::Iimg_obj::set(undoImage36->image,location24,_hx_tmp100);
            														}
            													}
            													else {
HXLINE( 306)														::Dynamic this413 = undoImage36->image;
HXDLIN( 306)														int index53;
HXDLIN( 306)														if (undoImage36->useVirtualPos) {
HXLINE( 306)															index53 = ::Std_obj::_hx_int(((((( (Float)(y45) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x45) - undoImage36->virtualX));
            														}
            														else {
HXLINE( 306)															index53 = ::Std_obj::_hx_int(( (Float)(((y45 * undoImage36->width) + x45)) ));
            														}
HXDLIN( 306)														int _hx_tmp101;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp101 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp101 = c41;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this413,index53,_hx_tmp101);
            													}
            												}
            												else {
HXLINE( 306)													if (forceClear12) {
HXLINE( 306)														::Dynamic this414 = undoImage36->image;
HXDLIN( 306)														int x46 = (dx14 - rectLeft12);
HXDLIN( 306)														int y46 = (dy14 - rectTop12);
HXDLIN( 306)														int index54;
HXDLIN( 306)														if (undoImage36->useVirtualPos) {
HXLINE( 306)															index54 = ::Std_obj::_hx_int(((((( (Float)(y46) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x46) - undoImage36->virtualX));
            														}
            														else {
HXLINE( 306)															index54 = ::Std_obj::_hx_int(( (Float)(((y46 * undoImage36->width) + x46)) ));
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this414,index54,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						{
HXLINE( 306)							int _g_min24 = xIter312->start;
HXDLIN( 306)							int _g_max24 = xIter312->max;
HXDLIN( 306)							while((_g_min24 < _g_max24)){
HXLINE( 306)								_g_min24 = (_g_min24 + 1);
HXDLIN( 306)								int px9 = (_g_min24 - 1);
HXDLIN( 306)								Float pcx9 = (( (Float)(px9) ) - x40);
HXDLIN( 306)								{
HXLINE( 306)									int _g_min25 = yIter312->start;
HXDLIN( 306)									int _g_max25 = yIter312->max;
HXDLIN( 306)									while((_g_min25 < _g_max25)){
HXLINE( 306)										_g_min25 = (_g_min25 + 1);
HXDLIN( 306)										int py9 = (_g_min25 - 1);
HXDLIN( 306)										Float pcy9 = (( (Float)(py9) ) - cy9);
HXDLIN( 306)										Float dot319 = ((pcx9 * bcx9) + (pcy9 * bcy9));
HXDLIN( 306)										Float dot329 = ((pcx9 * acx9) + (pcy9 * acy9));
HXDLIN( 306)										Float ratioA9 = (((dot229 * dot319) - (dot129 * dot329)) * denom19);
HXDLIN( 306)										Float ratioB9 = (((dot119 * dot329) - (dot129 * dot319)) * denom19);
HXDLIN( 306)										Float ratioC9 = ((((Float)1.0) - ratioB9) - ratioA9);
HXDLIN( 306)										bool _hx_tmp102;
HXDLIN( 306)										bool _hx_tmp103;
HXDLIN( 306)										if ((ratioA9 >= 0)) {
HXLINE( 306)											_hx_tmp103 = (ratioB9 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp103 = false;
            										}
HXDLIN( 306)										if (_hx_tmp103) {
HXLINE( 306)											_hx_tmp102 = (ratioC9 >= 0);
            										}
            										else {
HXLINE( 306)											_hx_tmp102 = false;
            										}
HXDLIN( 306)										if (_hx_tmp102) {
HXLINE( 306)											int i123 = ::Std_obj::_hx_int((((( (Float)(aA9) ) * ratioA9) + (( (Float)(aB9) ) * ratioB9)) + (( (Float)(aC9) ) * ratioC9)));
HXDLIN( 306)											if ((i123 > 255)) {
HXLINE(  24)												i123 = 255;
            											}
HXLINE( 306)											if ((i123 < 0)) {
HXLINE(  25)												i123 = 0;
            											}
HXLINE( 306)											int a71 = i123;
HXDLIN( 306)											int i124 = ::Std_obj::_hx_int((((( (Float)(rA9) ) * ratioA9) + (( (Float)(rB9) ) * ratioB9)) + (( (Float)(rC9) ) * ratioC9)));
HXDLIN( 306)											if ((i124 > 255)) {
HXLINE(  24)												i124 = 255;
            											}
HXLINE( 306)											if ((i124 < 0)) {
HXLINE(  25)												i124 = 0;
            											}
HXLINE( 306)											int r52 = i124;
HXDLIN( 306)											int i125 = ::Std_obj::_hx_int((((( (Float)(gA9) ) * ratioA9) + (( (Float)(gB9) ) * ratioB9)) + (( (Float)(gC9) ) * ratioC9)));
HXDLIN( 306)											if ((i125 > 255)) {
HXLINE(  24)												i125 = 255;
            											}
HXLINE( 306)											if ((i125 < 0)) {
HXLINE(  25)												i125 = 0;
            											}
HXLINE( 306)											int g52 = i125;
HXDLIN( 306)											int i126 = ::Std_obj::_hx_int((((( (Float)(bA9) ) * ratioA9) + (( (Float)(bB9) ) * ratioB9)) + (( (Float)(bC9) ) * ratioC9)));
HXDLIN( 306)											if ((i126 > 255)) {
HXLINE(  24)												i126 = 255;
            											}
HXLINE( 306)											if ((i126 < 0)) {
HXLINE(  25)												i126 = 0;
            											}
HXLINE( 306)											int b86 = i126;
HXDLIN( 306)											{
HXLINE( 306)												int location25;
HXDLIN( 306)												if (this361->useVirtualPos) {
HXLINE( 306)													location25 = ::Std_obj::_hx_int(((((( (Float)(py9) ) - this361->virtualY) * ( (Float)(this361->width) )) + px9) - this361->virtualX));
            												}
            												else {
HXLINE( 306)													location25 = ::Std_obj::_hx_int(( (Float)(((py9 * this361->width) + px9)) ));
            												}
HXDLIN( 306)												bool _hx_tmp104;
HXDLIN( 306)												if (this361->transparent) {
HXLINE( 306)													_hx_tmp104 = (a71 < 254);
            												}
            												else {
HXLINE( 306)													_hx_tmp104 = false;
            												}
HXDLIN( 306)												if (_hx_tmp104) {
HXLINE( 306)													int this415 = ::iterMagic::Iimg_obj::get(this361->image,location25);
HXDLIN( 306)													int old9;
HXDLIN( 306)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)														old9 = ((((((this415 >> 24) & 255) << 24) | ((this415 & 255) << 16)) | (((this415 >> 8) & 255) << 8)) | ((this415 >> 16) & 255));
            													}
            													else {
HXLINE( 306)														old9 = this415;
            													}
HXDLIN( 306)													int rhs9 = ((((a71 << 24) | (r52 << 16)) | (g52 << 8)) | b86);
HXDLIN( 306)													Float a129;
HXDLIN( 306)													int this416 = ((old9 >> 24) & 255);
HXDLIN( 306)													if ((this416 == 0)) {
HXLINE( 306)														a129 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a129 = (( (Float)(this416) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r126;
HXDLIN( 306)													int this417 = ((old9 >> 16) & 255);
HXDLIN( 306)													if ((this417 == 0)) {
HXLINE( 306)														r126 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r126 = (( (Float)(this417) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g126;
HXDLIN( 306)													int this418 = ((old9 >> 8) & 255);
HXDLIN( 306)													if ((this418 == 0)) {
HXLINE( 306)														g126 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g126 = (( (Float)(this418) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b131;
HXDLIN( 306)													int this419 = (old9 & 255);
HXDLIN( 306)													if ((this419 == 0)) {
HXLINE( 306)														b131 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b131 = (( (Float)(this419) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a227;
HXDLIN( 306)													int this420 = ((rhs9 >> 24) & 255);
HXDLIN( 306)													if ((this420 == 0)) {
HXLINE( 306)														a227 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														a227 = (( (Float)(this420) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float r226;
HXDLIN( 306)													int this421 = ((rhs9 >> 16) & 255);
HXDLIN( 306)													if ((this421 == 0)) {
HXLINE( 306)														r226 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														r226 = (( (Float)(this421) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float g226;
HXDLIN( 306)													int this422 = ((rhs9 >> 8) & 255);
HXDLIN( 306)													if ((this422 == 0)) {
HXLINE( 306)														g226 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														g226 = (( (Float)(this422) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float b229;
HXDLIN( 306)													int this423 = (rhs9 & 255);
HXDLIN( 306)													if ((this423 == 0)) {
HXLINE( 306)														b229 = ((Float)0.);
            													}
            													else {
HXLINE( 306)														b229 = (( (Float)(this423) ) / ( (Float)(255) ));
            													}
HXDLIN( 306)													Float a326 = (a129 * (( (Float)(1) ) - a227));
HXDLIN( 306)													int r53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r126 * a326) + (r226 * a227))));
HXDLIN( 306)													int g53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g126 * a326) + (g226 * a227))));
HXDLIN( 306)													int b87 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b131 * a326) + (b229 * a227))));
HXDLIN( 306)													int a72 = ::Std_obj::_hx_int((( (Float)(255) ) * (a326 + a227)));
HXDLIN( 306)													int blended25 = ((((a72 << 24) | (r53 << 16)) | (g53 << 8)) | b87);
HXDLIN( 306)													{
HXLINE( 306)														int _hx_tmp105;
HXDLIN( 306)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)															_hx_tmp105 = ((((((blended25 >> 24) & 255) << 24) | ((blended25 & 255) << 16)) | (((blended25 >> 8) & 255) << 8)) | ((blended25 >> 16) & 255));
            														}
            														else {
HXLINE( 306)															_hx_tmp105 = blended25;
            														}
HXDLIN( 306)														::iterMagic::Iimg_obj::set(this361->image,location25,_hx_tmp105);
            													}
            												}
            												else {
HXLINE( 306)													int value9;
HXDLIN( 306)													if (this361->isLittle) {
HXLINE( 306)														value9 = ((((a71 << 24) | (b86 << 16)) | (g52 << 8)) | r52);
            													}
            													else {
HXLINE( 306)														value9 = ((((a71 << 24) | (r52 << 16)) | (g52 << 8)) | b86);
            													}
HXDLIN( 306)													::iterMagic::Iimg_obj::set(this361->image,location25,value9);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 306)						if ((hasHit12 == false)) {
HXLINE( 306)							 ::pi_xy::algo::HitTri v43 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx7,lowerY,bx7,cy9,x40,cy9,true);
HXDLIN( 306)							if (hasUndo12) {
HXLINE( 306)								v43->undoImage = undoImage36;
HXDLIN( 306)								v43->undoX = xIter312->start;
HXDLIN( 306)								v43->undoY = yIter312->start;
            							}
            						}
            					}
HXDLIN( 306)					if ((hasHit11 == true)) {
HXLINE( 306)						 ::pi_xy::algo::HitQuad v44 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x40,lowerY,bx7,lowerY,bx7,cy9,x40,cy9,true);
            					}
            				}
            			}
HXDLIN( 306)			Float inlobj_ax4 = x40;
HXDLIN( 306)			Float inlobj_ay4 = lowerY;
HXDLIN( 306)			Float inlobj_bx4 = bx7;
HXDLIN( 306)			Float inlobj_y4 = lowerY;
HXDLIN( 306)			Float inlobj_cx4 = bx7;
HXDLIN( 306)			Float inlobj_cy4 = cy9;
HXDLIN( 306)			Float inlobj_x4 = x40;
HXDLIN( 306)			Float inlobj_dy4 = cy9;
HXDLIN( 306)			{
HXLINE( 306)				 ::pi_xy::ImageStruct this424 = temp;
HXDLIN( 306)				{
HXLINE( 306)					 ::Dynamic targetError3 = ((Float)1.05);
HXDLIN( 306)					if (::hx::IsNull( targetError3 )) {
HXLINE( 113)						targetError3 = ((Float)1.05);
            					}
HXLINE( 306)					Float rSmall3;
HXDLIN( 306)					if ((rightRadius > bottomRadius)) {
HXLINE( 306)						rSmall3 = bottomRadius;
            					}
            					else {
HXLINE( 306)						rSmall3 = rightRadius;
            					}
HXDLIN( 306)					 ::Dynamic targetE3 = ( (Float)(targetError3) );
HXDLIN( 306)					if (::hx::IsNull( targetE3 )) {
HXLINE(  20)						targetE3 = ((Float)1.05);
            					}
HXLINE( 306)					int result3 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE3) ) / rSmall3)))));
HXDLIN( 306)					int noSides3;
HXDLIN( 306)					if ((result3 < 12)) {
HXLINE( 306)						noSides3 = 12;
            					}
            					else {
HXLINE( 306)						if ((result3 > 500)) {
HXLINE( 306)							noSides3 = 500;
            						}
            						else {
HXLINE( 306)							noSides3 = result3;
            						}
            					}
HXDLIN( 306)					int sides3 = (::Math_obj::ceil((( (Float)(noSides3) ) / ( (Float)(4) ))) * 4);
HXDLIN( 306)					Float theta3 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN( 306)					Float omega3 = ( (Float)(0) );
HXDLIN( 306)					int quarter3 = ::Std_obj::_hx_int((( (Float)(sides3) ) / ( (Float)(4) )));
HXDLIN( 306)					Float lastX3 = ((Float)0.);
HXDLIN( 306)					Float lastY3 = ((Float)0.);
HXDLIN( 306)					{
HXLINE(  26)						lastX3 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides3) ) * theta3) + omega3))));
HXLINE(  27)						lastY3 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides3) ) * theta3) + omega3))));
            					}
HXLINE( 306)					{
HXLINE( 306)						int _g282 = 0;
HXDLIN( 306)						int _g283 = (quarter3 + 1);
HXDLIN( 306)						while((_g282 < _g283)){
HXLINE( 306)							_g282 = (_g282 + 1);
HXDLIN( 306)							int i127 = (_g282 - 1);
HXDLIN( 306)							Float nextX3 = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i127) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN( 306)							Float nextY3 = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i127) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN( 306)							{
HXLINE( 306)								 ::pi_xy::ImageStruct this425 = this424;
HXDLIN( 306)								bool hasHit13 = false;
HXDLIN( 306)								bool hasUndo13 = false;
HXDLIN( 306)								{
HXLINE( 306)									Float bx8 = lastX3;
HXDLIN( 306)									Float by3 = lastY3;
HXDLIN( 306)									Float cx5 = nextX3;
HXDLIN( 306)									Float cy10 = nextY3;
HXDLIN( 306)									bool adjustWinding3 = (((((farX * by3) - (bx8 * lowerY)) + ((bx8 * cy10) - (cx5 * by3))) + ((cx5 * lowerY) - (farX * cy10))) > 0);
HXDLIN( 306)									if (!(adjustWinding3)) {
HXLINE( 306)										Float bx_3 = bx8;
HXDLIN( 306)										Float by_3 = by3;
HXLINE(  25)										bx8 = cx5;
HXLINE(  26)										by3 = cy10;
HXLINE(  27)										cx5 = bx_3;
HXLINE(  28)										cy10 = by_3;
            									}
HXLINE( 306)									{
HXLINE( 306)										Float s03 = ((lowerY * cx5) - (farX * cy10));
HXDLIN( 306)										Float sx3 = (cy10 - lowerY);
HXDLIN( 306)										Float sy3 = (farX - cx5);
HXDLIN( 306)										Float t03 = ((farX * by3) - (lowerY * bx8));
HXDLIN( 306)										Float tx3 = (lowerY - by3);
HXDLIN( 306)										Float ty3 = (bx8 - farX);
HXDLIN( 306)										Float A3 = ((((-(by3) * cx5) + (lowerY * (-(bx8) + cx5))) + (farX * (by3 - cy10))) + (bx8 * cy10));
HXDLIN( 306)										 ::pi_xy::iter::IntIterStart xIter313;
HXDLIN( 306)										if ((farX > bx8)) {
HXLINE( 306)											if ((farX > cx5)) {
HXLINE( 306)												int min49;
HXDLIN( 306)												if ((bx8 > cx5)) {
HXLINE( 306)													min49 = ::Math_obj::floor(cx5);
            												}
            												else {
HXLINE( 306)													min49 = ::Math_obj::floor(bx8);
            												}
HXDLIN( 306)												int ii_min101 = min49;
HXDLIN( 306)												int ii_max101 = ::Math_obj::ceil(farX);
HXDLIN( 306)												xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min101,ii_max101);
            											}
            											else {
HXLINE( 306)												int ii_min102 = ::Math_obj::floor(bx8);
HXDLIN( 306)												int ii_max102 = ::Math_obj::ceil(cx5);
HXDLIN( 306)												xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min102,ii_max102);
            											}
            										}
            										else {
HXLINE( 306)											if ((bx8 > cx5)) {
HXLINE( 306)												int min50;
HXDLIN( 306)												if ((farX > cx5)) {
HXLINE( 306)													min50 = ::Math_obj::floor(cx5);
            												}
            												else {
HXLINE( 306)													min50 = ::Math_obj::ceil(farX);
            												}
HXDLIN( 306)												int ii_min103 = min50;
HXDLIN( 306)												int ii_max103 = ::Math_obj::ceil(bx8);
HXDLIN( 306)												xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min103,ii_max103);
            											}
            											else {
HXLINE( 306)												int ii_min104 = ::Math_obj::floor(farX);
HXDLIN( 306)												int ii_max104 = ::Math_obj::ceil(cx5);
HXDLIN( 306)												xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min104,ii_max104);
            											}
            										}
HXDLIN( 306)										 ::pi_xy::iter::IntIterStart yIter313;
HXDLIN( 306)										if ((lowerY > by3)) {
HXLINE( 306)											if ((lowerY > cy10)) {
HXLINE( 306)												int min51;
HXDLIN( 306)												if ((by3 > cy10)) {
HXLINE( 306)													min51 = ::Math_obj::floor(cy10);
            												}
            												else {
HXLINE( 306)													min51 = ::Math_obj::floor(by3);
            												}
HXDLIN( 306)												int ii_min105 = min51;
HXDLIN( 306)												int ii_max105 = ::Math_obj::ceil(lowerY);
HXDLIN( 306)												yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min105,ii_max105);
            											}
            											else {
HXLINE( 306)												int ii_min106 = ::Math_obj::floor(by3);
HXDLIN( 306)												int ii_max106 = ::Math_obj::ceil(cy10);
HXDLIN( 306)												yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min106,ii_max106);
            											}
            										}
            										else {
HXLINE( 306)											if ((by3 > cy10)) {
HXLINE( 306)												int min52;
HXDLIN( 306)												if ((lowerY > cy10)) {
HXLINE( 306)													min52 = ::Math_obj::floor(cy10);
            												}
            												else {
HXLINE( 306)													min52 = ::Math_obj::ceil(lowerY);
            												}
HXDLIN( 306)												int ii_min107 = min52;
HXDLIN( 306)												int ii_max107 = ::Math_obj::ceil(by3);
HXDLIN( 306)												yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min107,ii_max107);
            											}
            											else {
HXLINE( 306)												int ii_min108 = ::Math_obj::floor(lowerY);
HXDLIN( 306)												int ii_max108 = ::Math_obj::ceil(cy10);
HXDLIN( 306)												yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min108,ii_max108);
            											}
            										}
HXDLIN( 306)										 ::pi_xy::ImageStruct undoImage39 = null();
HXDLIN( 306)										if (hasUndo13) {
HXLINE( 306)											int width14 = ((xIter313->max - xIter313->start) + 1);
HXDLIN( 306)											int height14 = ((yIter313->max - yIter313->start) + 1);
HXDLIN( 306)											 ::Dynamic imageType14 = null();
HXDLIN( 306)											 ::pi_xy::ImageStruct this426 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 306)											if (::hx::IsNull( imageType14 )) {
HXLINE(  54)												imageType14 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 306)											::Dynamic undoImage40;
HXDLIN( 306)											switch((int)(( (int)(imageType14) ))){
            												case (int)0: {
HXLINE( 306)													 ::iterMagic::BytesImg byt14 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::BytesImg b88 = byt14;
HXDLIN( 306)													{
HXLINE( 306)														b88->width = width14;
HXDLIN( 306)														b88->height = height14;
HXDLIN( 306)														b88->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 306)														b88->data = ::haxe::io::Bytes_obj::alloc((b88->length * 4));
HXDLIN( 306)														{
HXLINE( 306)															int len28 = b88->length;
HXDLIN( 306)															int w14 = 0;
HXDLIN( 306)															{
HXLINE( 306)																int _g284 = 0;
HXDLIN( 306)																int _g285 = b88->height;
HXDLIN( 306)																while((_g284 < _g285)){
HXLINE( 306)																	_g284 = (_g284 + 1);
HXDLIN( 306)																	int y47 = (_g284 - 1);
HXDLIN( 306)																	{
HXLINE( 306)																		int _g286 = 0;
HXDLIN( 306)																		int _g287 = b88->width;
HXDLIN( 306)																		while((_g286 < _g287)){
HXLINE( 306)																			_g286 = (_g286 + 1);
HXDLIN( 306)																			int x47 = (_g286 - 1);
HXDLIN( 306)																			{
HXLINE( 306)																				w14 = (w14 + 1);
HXDLIN( 306)																				b88->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w14 = (w14 + 1);
HXDLIN( 306)																				b88->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w14 = (w14 + 1);
HXDLIN( 306)																				b88->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 306)																			{
HXLINE( 306)																				w14 = (w14 + 1);
HXDLIN( 306)																				b88->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage40 = b88;
            												}
            												break;
            												case (int)1: {
HXLINE( 306)													 ::iterMagic::ArrIntImg arrI14 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::ArrIntImg a73 = arrI14;
HXDLIN( 306)													{
HXLINE( 306)														a73->width = width14;
HXDLIN( 306)														a73->height = height14;
HXDLIN( 306)														a73->data = ::Array_obj< int >::__new(0);
HXDLIN( 306)														a73->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 306)														{
HXLINE( 306)															int _g288 = 0;
HXDLIN( 306)															int _g289 = a73->length;
HXDLIN( 306)															while((_g288 < _g289)){
HXLINE( 306)																_g288 = (_g288 + 1);
HXDLIN( 306)																int i128 = (_g288 - 1);
HXDLIN( 306)																a73->data[i128] = 0;
            															}
            														}
            													}
HXDLIN( 306)													undoImage40 = a73;
            												}
            												break;
            												case (int)2: {
HXLINE( 306)													 ::iterMagic::U32ArrImg u32a14 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::U32ArrImg b89 = u32a14;
HXDLIN( 306)													{
HXLINE( 306)														b89->width = width14;
HXDLIN( 306)														b89->height = height14;
HXDLIN( 306)														b89->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 306)														int size14 = (b89->length * 4);
HXDLIN( 306)														b89->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size14),0,size14);
HXDLIN( 306)														{
HXLINE( 306)															int _g290 = 0;
HXDLIN( 306)															int _g291 = b89->length;
HXDLIN( 306)															while((_g290 < _g291)){
HXLINE( 306)																_g290 = (_g290 + 1);
HXDLIN( 306)																int i129 = (_g290 - 1);
HXDLIN( 306)																{
HXLINE( 306)																	 ::haxe::io::ArrayBufferViewImpl this427 = b89->data;
HXDLIN( 306)																	bool undoImage41;
HXDLIN( 306)																	if ((i129 >= 0)) {
HXLINE( 306)																		undoImage41 = (i129 < (this427->byteLength >> 2));
            																	}
            																	else {
HXLINE( 306)																		undoImage41 = false;
            																	}
HXDLIN( 306)																	if (undoImage41) {
HXLINE( 306)																		 ::haxe::io::Bytes _this14 = this427->bytes;
HXDLIN( 306)																		int pos14 = ((i129 << 2) + this427->byteOffset);
HXDLIN( 306)																		_this14->b[pos14] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this14->b[(pos14 + 1)] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this14->b[(pos14 + 2)] = ( (unsigned char)(0) );
HXDLIN( 306)																		_this14->b[(pos14 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage40 = b89;
            												}
            												break;
            												case (int)3: {
HXLINE( 306)													 ::iterMagic::VecIntImg vec14 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::VecIntImg v45 = vec14;
HXDLIN( 306)													{
HXLINE( 306)														v45->width = width14;
HXDLIN( 306)														v45->height = height14;
HXDLIN( 306)														v45->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 306)														v45->data = ::Array_obj< int >::__new(v45->length);
HXDLIN( 306)														{
HXLINE( 306)															int _g292 = 0;
HXDLIN( 306)															int _g293 = v45->length;
HXDLIN( 306)															while((_g292 < _g293)){
HXLINE( 306)																_g292 = (_g292 + 1);
HXDLIN( 306)																int i130 = (_g292 - 1);
HXDLIN( 306)																v45->data->__unsafe_set(i130,0);
            															}
            														}
            													}
HXDLIN( 306)													undoImage40 = v45;
            												}
            												break;
            												case (int)4: {
HXLINE( 306)													 ::iterMagic::StackIntImg sInt14 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 306)													 ::iterMagic::StackIntImg b90 = sInt14;
HXDLIN( 306)													{
HXLINE( 306)														b90->width = width14;
HXDLIN( 306)														b90->height = height14;
HXDLIN( 306)														b90->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 306)														b90->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 306)														{
HXLINE( 306)															int len29 = b90->length;
HXDLIN( 306)															 ::haxe::ds::GenericStack_Int d14 = b90->data;
HXDLIN( 306)															if (::hx::IsNull( d14->head )) {
HXLINE( 306)																int _g294 = 0;
HXDLIN( 306)																int _g295 = len29;
HXDLIN( 306)																while((_g294 < _g295)){
HXLINE( 306)																	_g294 = (_g294 + 1);
HXDLIN( 306)																	int i131 = (_g294 - 1);
HXDLIN( 306)																	d14->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d14->head);
            																}
            															}
            															else {
HXLINE( 306)																int _g296 = 0;
HXDLIN( 306)																int _g297 = len29;
HXDLIN( 306)																while((_g296 < _g297)){
HXLINE( 306)																	_g296 = (_g296 + 1);
HXDLIN( 306)																	int i132 = (_g296 - 1);
HXDLIN( 306)																	{
HXLINE( 306)																		 ::haxe::ds::GenericCell_Int l14 = b90->data->head;
HXDLIN( 306)																		 ::haxe::ds::GenericCell_Int prev14 = null();
HXDLIN( 306)																		{
HXLINE( 306)																			int _g298 = 0;
HXDLIN( 306)																			int _g299 = i132;
HXDLIN( 306)																			while((_g298 < _g299)){
HXLINE( 306)																				_g298 = (_g298 + 1);
HXDLIN( 306)																				int i133 = (_g298 - 1);
HXLINE( 345)																				prev14 = l14;
HXLINE( 346)																				l14 = l14->next;
            																			}
            																		}
HXLINE( 306)																		if (::hx::IsNull( prev14 )) {
HXLINE( 306)																			b90->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l14->next);
HXDLIN( 306)																			l14 = null();
            																		}
            																		else {
HXLINE( 306)																			prev14->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l14->next);
HXDLIN( 306)																			l14 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 306)													undoImage40 = b90;
            												}
            												break;
            											}
HXDLIN( 306)											this426->image = undoImage40;
HXDLIN( 306)											this426->width = width14;
HXDLIN( 306)											this426->height = height14;
HXDLIN( 306)											this426->imageType = ( (int)(imageType14) );
HXDLIN( 306)											undoImage39 = this426;
HXDLIN( 306)											{
HXLINE( 306)												int rectLeft13 = xIter313->start;
HXDLIN( 306)												int rectTop13 = yIter313->start;
HXDLIN( 306)												int rectRight13 = xIter313->max;
HXDLIN( 306)												bool forceClear13 = false;
HXDLIN( 306)												{
HXLINE( 306)													int _g300 = rectTop13;
HXDLIN( 306)													int _g301 = yIter313->max;
HXDLIN( 306)													while((_g300 < _g301)){
HXLINE( 306)														_g300 = (_g300 + 1);
HXDLIN( 306)														int dy15 = (_g300 - 1);
HXDLIN( 306)														{
HXLINE( 306)															int _g302 = rectLeft13;
HXDLIN( 306)															int _g303 = rectRight13;
HXDLIN( 306)															while((_g302 < _g303)){
HXLINE( 306)																_g302 = (_g302 + 1);
HXDLIN( 306)																int dx15 = (_g302 - 1);
HXDLIN( 306)																::Dynamic this428 = this425->image;
HXDLIN( 306)																int index55;
HXDLIN( 306)																if (this425->useVirtualPos) {
HXLINE( 306)																	index55 = ::Std_obj::_hx_int(((((( (Float)(dy15) ) - this425->virtualY) * ( (Float)(this425->width) )) + dx15) - this425->virtualX));
            																}
            																else {
HXLINE( 306)																	index55 = ::Std_obj::_hx_int(( (Float)(((dy15 * this425->width) + dx15)) ));
            																}
HXDLIN( 306)																int c42 = ::iterMagic::Iimg_obj::get(this428,index55);
HXDLIN( 306)																int col13;
HXDLIN( 306)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																	col13 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            																}
            																else {
HXLINE( 306)																	col13 = c42;
            																}
HXDLIN( 306)																bool _hx_tmp106;
HXDLIN( 306)																if (this425->useMask) {
HXLINE( 306)																	_hx_tmp106 = ::hx::IsNotNull( this425->mask );
            																}
            																else {
HXLINE( 306)																	_hx_tmp106 = false;
            																}
HXDLIN( 306)																if (_hx_tmp106) {
HXLINE( 306)																	 ::pi_xy::ImageStruct this429 = this425->mask;
HXDLIN( 306)																	::Dynamic this430 = this429->image;
HXDLIN( 306)																	int index56;
HXDLIN( 306)																	if (this429->useVirtualPos) {
HXLINE( 306)																		index56 = ::Std_obj::_hx_int(((((( (Float)(dy15) ) - this429->virtualY) * ( (Float)(this429->width) )) + dx15) - this429->virtualX));
            																	}
            																	else {
HXLINE( 306)																		index56 = ::Std_obj::_hx_int(( (Float)(((dy15 * this429->width) + dx15)) ));
            																	}
HXDLIN( 306)																	int c43 = ::iterMagic::Iimg_obj::get(this430,index56);
HXDLIN( 306)																	int v46;
HXDLIN( 306)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																		v46 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            																	}
            																	else {
HXLINE( 306)																		v46 = c43;
            																	}
HXDLIN( 306)																	int maskPixel13 = v46;
HXDLIN( 306)																	int this431 = col13;
HXDLIN( 306)																	if ((maskPixel13 == 0)) {
HXLINE( 306)																		col13 = this431;
            																	}
            																	else {
HXLINE( 306)																		Float m013;
HXDLIN( 306)																		int this432 = ((maskPixel13 >> 24) & 255);
HXDLIN( 306)																		if ((this432 == 0)) {
HXLINE( 306)																			m013 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m013 = (( (Float)(this432) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m113;
HXDLIN( 306)																		int this433 = ((maskPixel13 >> 16) & 255);
HXDLIN( 306)																		if ((this433 == 0)) {
HXLINE( 306)																			m113 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m113 = (( (Float)(this433) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m213;
HXDLIN( 306)																		int this434 = ((maskPixel13 >> 8) & 255);
HXDLIN( 306)																		if ((this434 == 0)) {
HXLINE( 306)																			m213 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m213 = (( (Float)(this434) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float m313;
HXDLIN( 306)																		int this435 = (maskPixel13 & 255);
HXDLIN( 306)																		if ((this435 == 0)) {
HXLINE( 306)																			m313 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			m313 = (( (Float)(this435) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		int ch013 = ::Std_obj::_hx_int(((((Float)1.) - m013) * ( (Float)(((this431 >> 24) & 255)) )));
HXDLIN( 306)																		int ch113 = ::Std_obj::_hx_int(((((Float)1.) - m113) * ( (Float)(((this431 >> 16) & 255)) )));
HXDLIN( 306)																		int ch213 = ::Std_obj::_hx_int(((((Float)1.) - m213) * ( (Float)(((this431 >> 8) & 255)) )));
HXDLIN( 306)																		int ch313 = ::Std_obj::_hx_int(((((Float)1.) - m313) * ( (Float)((this431 & 255)) )));
HXDLIN( 306)																		col13 = ((((::Math_obj::round((( (Float)(ch013) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch113) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch213) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch313) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 306)																if ((col13 != 0)) {
HXLINE( 306)																	int x48 = (dx15 - rectLeft13);
HXDLIN( 306)																	int y48 = (dy15 - rectTop13);
HXDLIN( 306)																	int c44 = col13;
HXDLIN( 306)																	bool _hx_tmp107;
HXDLIN( 306)																	if ((((c44 >> 24) & 255) < 254)) {
HXLINE( 306)																		_hx_tmp107 = undoImage39->transparent;
            																	}
            																	else {
HXLINE( 306)																		_hx_tmp107 = false;
            																	}
HXDLIN( 306)																	if (_hx_tmp107) {
HXLINE( 306)																		int location26;
HXDLIN( 306)																		if (undoImage39->useVirtualPos) {
HXLINE( 306)																			location26 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x48) - undoImage39->virtualX));
            																		}
            																		else {
HXLINE( 306)																			location26 = ::Std_obj::_hx_int(( (Float)(((y48 * undoImage39->width) + x48)) ));
            																		}
HXDLIN( 306)																		int this436 = ::iterMagic::Iimg_obj::get(undoImage39->image,location26);
HXDLIN( 306)																		int this437;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			this437 = ((((((this436 >> 24) & 255) << 24) | ((this436 & 255) << 16)) | (((this436 >> 8) & 255) << 8)) | ((this436 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			this437 = this436;
            																		}
HXDLIN( 306)																		Float a130;
HXDLIN( 306)																		int this438 = ((this437 >> 24) & 255);
HXDLIN( 306)																		if ((this438 == 0)) {
HXLINE( 306)																			a130 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a130 = (( (Float)(this438) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r127;
HXDLIN( 306)																		int this439 = ((this437 >> 16) & 255);
HXDLIN( 306)																		if ((this439 == 0)) {
HXLINE( 306)																			r127 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r127 = (( (Float)(this439) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g127;
HXDLIN( 306)																		int this440 = ((this437 >> 8) & 255);
HXDLIN( 306)																		if ((this440 == 0)) {
HXLINE( 306)																			g127 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g127 = (( (Float)(this440) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b132;
HXDLIN( 306)																		int this441 = (this437 & 255);
HXDLIN( 306)																		if ((this441 == 0)) {
HXLINE( 306)																			b132 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b132 = (( (Float)(this441) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a228;
HXDLIN( 306)																		int this442 = ((col13 >> 24) & 255);
HXDLIN( 306)																		if ((this442 == 0)) {
HXLINE( 306)																			a228 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a228 = (( (Float)(this442) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r227;
HXDLIN( 306)																		int this443 = ((col13 >> 16) & 255);
HXDLIN( 306)																		if ((this443 == 0)) {
HXLINE( 306)																			r227 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r227 = (( (Float)(this443) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g227;
HXDLIN( 306)																		int this444 = ((col13 >> 8) & 255);
HXDLIN( 306)																		if ((this444 == 0)) {
HXLINE( 306)																			g227 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g227 = (( (Float)(this444) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b230;
HXDLIN( 306)																		int this445 = (col13 & 255);
HXDLIN( 306)																		if ((this445 == 0)) {
HXLINE( 306)																			b230 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b230 = (( (Float)(this445) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a327 = (a130 * (( (Float)(1) ) - a228));
HXDLIN( 306)																		int r54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r127 * a327) + (r227 * a228))));
HXDLIN( 306)																		int g54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g127 * a327) + (g227 * a228))));
HXDLIN( 306)																		int b91 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b132 * a327) + (b230 * a228))));
HXDLIN( 306)																		int a74 = ::Std_obj::_hx_int((( (Float)(255) ) * (a327 + a228)));
HXDLIN( 306)																		int blended26 = ((((a74 << 24) | (r54 << 16)) | (g54 << 8)) | b91);
HXDLIN( 306)																		{
HXLINE( 306)																			int _hx_tmp108;
HXDLIN( 306)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																				_hx_tmp108 = ((((((blended26 >> 24) & 255) << 24) | ((blended26 & 255) << 16)) | (((blended26 >> 8) & 255) << 8)) | ((blended26 >> 16) & 255));
            																			}
            																			else {
HXLINE( 306)																				_hx_tmp108 = blended26;
            																			}
HXDLIN( 306)																			::iterMagic::Iimg_obj::set(undoImage39->image,location26,_hx_tmp108);
            																		}
            																	}
            																	else {
HXLINE( 306)																		::Dynamic this446 = undoImage39->image;
HXDLIN( 306)																		int index57;
HXDLIN( 306)																		if (undoImage39->useVirtualPos) {
HXLINE( 306)																			index57 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x48) - undoImage39->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index57 = ::Std_obj::_hx_int(( (Float)(((y48 * undoImage39->width) + x48)) ));
            																		}
HXDLIN( 306)																		int _hx_tmp109;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			_hx_tmp109 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			_hx_tmp109 = c44;
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this446,index57,_hx_tmp109);
            																	}
            																}
            																else {
HXLINE( 306)																	if (forceClear13) {
HXLINE( 306)																		::Dynamic this447 = undoImage39->image;
HXDLIN( 306)																		int x49 = (dx15 - rectLeft13);
HXDLIN( 306)																		int y49 = (dy15 - rectTop13);
HXDLIN( 306)																		int index58;
HXDLIN( 306)																		if (undoImage39->useVirtualPos) {
HXLINE( 306)																			index58 = ::Std_obj::_hx_int(((((( (Float)(y49) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x49) - undoImage39->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index58 = ::Std_obj::_hx_int(( (Float)(((y49 * undoImage39->width) + x49)) ));
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this447,index58,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 306)										bool found3 = false;
HXDLIN( 306)										Float s3 = ((Float)0.);
HXDLIN( 306)										Float t3 = ((Float)0.);
HXDLIN( 306)										Float sxx3 = ((Float)0.);
HXDLIN( 306)										Float txx3 = ((Float)0.);
HXDLIN( 306)										{
HXLINE( 306)											int _g_min26 = xIter313->start;
HXDLIN( 306)											int _g_max26 = xIter313->max;
HXDLIN( 306)											while((_g_min26 < _g_max26)){
HXLINE( 306)												_g_min26 = (_g_min26 + 1);
HXDLIN( 306)												int x50 = (_g_min26 - 1);
HXLINE(  60)												sxx3 = (sx3 * ( (Float)(x50) ));
HXLINE(  61)												txx3 = (tx3 * ( (Float)(x50) ));
HXLINE(  62)												found3 = false;
HXLINE( 306)												{
HXLINE( 306)													int _g_min27 = yIter313->start;
HXDLIN( 306)													int _g_max27 = yIter313->max;
HXDLIN( 306)													while((_g_min27 < _g_max27)){
HXLINE( 306)														_g_min27 = (_g_min27 + 1);
HXDLIN( 306)														int y50 = (_g_min27 - 1);
HXLINE(  64)														s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y50) )));
HXLINE(  65)														t3 = ((t03 + txx3) + (ty3 * ( (Float)(y50) )));
HXLINE( 306)														bool _hx_tmp110;
HXDLIN( 306)														if (!((s3 <= 0))) {
HXLINE( 306)															_hx_tmp110 = (t3 <= 0);
            														}
            														else {
HXLINE( 306)															_hx_tmp110 = true;
            														}
HXDLIN( 306)														if (_hx_tmp110) {
HXLINE( 306)															if (found3) {
HXLINE( 306)																goto _hx_goto_852;
            															}
            														}
            														else {
HXLINE( 306)															if (((s3 + t3) < A3)) {
HXLINE( 306)																{
HXLINE( 306)																	int c45 = colorB;
HXDLIN( 306)																	bool _hx_tmp111;
HXDLIN( 306)																	if ((((c45 >> 24) & 255) < 254)) {
HXLINE( 306)																		_hx_tmp111 = this425->transparent;
            																	}
            																	else {
HXLINE( 306)																		_hx_tmp111 = false;
            																	}
HXDLIN( 306)																	if (_hx_tmp111) {
HXLINE( 306)																		int location27;
HXDLIN( 306)																		if (this425->useVirtualPos) {
HXLINE( 306)																			location27 = ::Std_obj::_hx_int(((((( (Float)(y50) ) - this425->virtualY) * ( (Float)(this425->width) )) + x50) - this425->virtualX));
            																		}
            																		else {
HXLINE( 306)																			location27 = ::Std_obj::_hx_int(( (Float)(((y50 * this425->width) + x50)) ));
            																		}
HXDLIN( 306)																		int this448 = ::iterMagic::Iimg_obj::get(this425->image,location27);
HXDLIN( 306)																		int this449;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			this449 = ((((((this448 >> 24) & 255) << 24) | ((this448 & 255) << 16)) | (((this448 >> 8) & 255) << 8)) | ((this448 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			this449 = this448;
            																		}
HXDLIN( 306)																		Float a131;
HXDLIN( 306)																		int this450 = ((this449 >> 24) & 255);
HXDLIN( 306)																		if ((this450 == 0)) {
HXLINE( 306)																			a131 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a131 = (( (Float)(this450) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r128;
HXDLIN( 306)																		int this451 = ((this449 >> 16) & 255);
HXDLIN( 306)																		if ((this451 == 0)) {
HXLINE( 306)																			r128 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r128 = (( (Float)(this451) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g128;
HXDLIN( 306)																		int this452 = ((this449 >> 8) & 255);
HXDLIN( 306)																		if ((this452 == 0)) {
HXLINE( 306)																			g128 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g128 = (( (Float)(this452) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b133;
HXDLIN( 306)																		int this453 = (this449 & 255);
HXDLIN( 306)																		if ((this453 == 0)) {
HXLINE( 306)																			b133 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b133 = (( (Float)(this453) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a229;
HXDLIN( 306)																		int this454 = ((colorB >> 24) & 255);
HXDLIN( 306)																		if ((this454 == 0)) {
HXLINE( 306)																			a229 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			a229 = (( (Float)(this454) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float r228;
HXDLIN( 306)																		int this455 = ((colorB >> 16) & 255);
HXDLIN( 306)																		if ((this455 == 0)) {
HXLINE( 306)																			r228 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			r228 = (( (Float)(this455) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float g228;
HXDLIN( 306)																		int this456 = ((colorB >> 8) & 255);
HXDLIN( 306)																		if ((this456 == 0)) {
HXLINE( 306)																			g228 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			g228 = (( (Float)(this456) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float b231;
HXDLIN( 306)																		int this457 = (colorB & 255);
HXDLIN( 306)																		if ((this457 == 0)) {
HXLINE( 306)																			b231 = ((Float)0.);
            																		}
            																		else {
HXLINE( 306)																			b231 = (( (Float)(this457) ) / ( (Float)(255) ));
            																		}
HXDLIN( 306)																		Float a328 = (a131 * (( (Float)(1) ) - a229));
HXDLIN( 306)																		int r55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r128 * a328) + (r228 * a229))));
HXDLIN( 306)																		int g55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g128 * a328) + (g228 * a229))));
HXDLIN( 306)																		int b92 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b133 * a328) + (b231 * a229))));
HXDLIN( 306)																		int a75 = ::Std_obj::_hx_int((( (Float)(255) ) * (a328 + a229)));
HXDLIN( 306)																		int blended27 = ((((a75 << 24) | (r55 << 16)) | (g55 << 8)) | b92);
HXDLIN( 306)																		{
HXLINE( 306)																			int _hx_tmp112;
HXDLIN( 306)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																				_hx_tmp112 = ((((((blended27 >> 24) & 255) << 24) | ((blended27 & 255) << 16)) | (((blended27 >> 8) & 255) << 8)) | ((blended27 >> 16) & 255));
            																			}
            																			else {
HXLINE( 306)																				_hx_tmp112 = blended27;
            																			}
HXDLIN( 306)																			::iterMagic::Iimg_obj::set(this425->image,location27,_hx_tmp112);
            																		}
            																	}
            																	else {
HXLINE( 306)																		::Dynamic this458 = this425->image;
HXDLIN( 306)																		int index59;
HXDLIN( 306)																		if (this425->useVirtualPos) {
HXLINE( 306)																			index59 = ::Std_obj::_hx_int(((((( (Float)(y50) ) - this425->virtualY) * ( (Float)(this425->width) )) + x50) - this425->virtualX));
            																		}
            																		else {
HXLINE( 306)																			index59 = ::Std_obj::_hx_int(( (Float)(((y50 * this425->width) + x50)) ));
            																		}
HXDLIN( 306)																		int _hx_tmp113;
HXDLIN( 306)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 306)																			_hx_tmp113 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            																		}
            																		else {
HXLINE( 306)																			_hx_tmp113 = c45;
            																		}
HXDLIN( 306)																		::iterMagic::Iimg_obj::set(this458,index59,_hx_tmp113);
            																	}
            																}
HXLINE(  73)																found3 = true;
            															}
            															else {
HXLINE( 306)																if (found3) {
HXLINE( 306)																	goto _hx_goto_852;
            																}
            															}
            														}
            													}
            													_hx_goto_852:;
            												}
            											}
            										}
HXDLIN( 306)										if ((hasHit13 == true)) {
HXLINE( 306)											 ::pi_xy::algo::HitTri v47 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX,lowerY,bx8,by3,cx5,cy10,true);
HXDLIN( 306)											if (hasUndo13) {
HXLINE( 306)												v47->undoImage = undoImage39;
HXDLIN( 306)												v47->undoX = xIter313->start;
HXDLIN( 306)												v47->undoY = yIter313->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX3 = nextX3;
HXLINE(  47)							lastY3 = nextY3;
            						}
            					}
            				}
            			}
            		}
HXLINE( 312)		{
HXLINE( 312)			Float wid1 = (wid - (( (Float)(2) ) * thick));
HXDLIN( 312)			Float hi1 = (hi - (( (Float)(2) ) * hi));
HXDLIN( 312)			 ::Dynamic dx16 = dx;
HXDLIN( 312)			 ::Dynamic dy16 = dy;
HXDLIN( 312)			 ::Dynamic fat2 = fat;
HXDLIN( 312)			 ::Dynamic tall2 = tall;
HXLINE( 317)			if (::hx::IsNull( tall2 )) {
HXLINE( 317)				tall2 = ((Float)-1.);
            			}
HXDLIN( 317)			if (::hx::IsNull( fat2 )) {
HXLINE( 317)				fat2 = ((Float)-1.);
            			}
HXLINE( 316)			if (::hx::IsNull( dy16 )) {
HXLINE( 316)				dy16 = ((Float)-1.);
            			}
HXDLIN( 316)			if (::hx::IsNull( dx16 )) {
HXLINE( 316)				dx16 = ((Float)-1.);
            			}
HXLINE( 312)			if (::hx::IsLess( dx16,((Float)0.) )) {
HXLINE( 312)				Float smallest1;
HXDLIN( 312)				if ((hi1 < wid1)) {
HXLINE( 312)					smallest1 = hi1;
            				}
            				else {
HXLINE( 312)					smallest1 = wid1;
            				}
HXDLIN( 312)				Float goldenRatio1 = ((Float)1.61803398875);
HXLINE(  26)				dx16 = (smallest1 / (goldenRatio1 + 2));
            			}
HXLINE( 312)			if (::hx::IsLess( dy16,((Float)0.) )) {
HXLINE(  28)				dy16 = dx16;
            			}
HXLINE( 312)			if (::hx::IsLess( fat2,((Float)0.) )) {
HXLINE(  29)				fat2 = (wid1 - (( (Float)(2) ) * ( (Float)(dx16) )));
            			}
HXLINE( 312)			if (::hx::IsLess( tall2,((Float)0.) )) {
HXLINE(  30)				tall2 = (hi1 - (( (Float)(2) ) * ( (Float)(dy16) )));
            			}
HXLINE( 312)			Float rightRadius1 = ((wid1 - ( (Float)(fat2) )) - ( (Float)(dx16) ));
HXDLIN( 312)			Float bottomRadius1 = ((hi1 - ( (Float)(tall2) )) - ( (Float)(dy16) ));
HXDLIN( 312)			Float farX1 = ((thick + dx16) + fat2);
HXDLIN( 312)			Float lowerY1 = ((thick + dy16) + tall2);
HXDLIN( 312)			{
HXLINE( 312)				 ::pi_xy::ImageStruct this459 = temp;
HXDLIN( 312)				Float cx6 = (thick + dx16);
HXDLIN( 312)				Float cy11 = (thick + dy16);
HXDLIN( 312)				Float rx2 = ( (Float)(dx16) );
HXDLIN( 312)				Float ry2 = ( (Float)(dy16) );
HXDLIN( 312)				{
HXLINE( 312)					 ::Dynamic targetError4 = ((Float)1.05);
HXDLIN( 312)					if (::hx::IsNull( targetError4 )) {
HXLINE( 113)						targetError4 = ((Float)1.05);
            					}
HXLINE( 312)					Float rSmall4;
HXDLIN( 312)					if ((rx2 > ry2)) {
HXLINE( 312)						rSmall4 = ry2;
            					}
            					else {
HXLINE( 312)						rSmall4 = rx2;
            					}
HXDLIN( 312)					 ::Dynamic targetE4 = ( (Float)(targetError4) );
HXDLIN( 312)					if (::hx::IsNull( targetE4 )) {
HXLINE(  20)						targetE4 = ((Float)1.05);
            					}
HXLINE( 312)					int result4 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE4) ) / rSmall4)))));
HXDLIN( 312)					int noSides4;
HXDLIN( 312)					if ((result4 < 12)) {
HXLINE( 312)						noSides4 = 12;
            					}
            					else {
HXLINE( 312)						if ((result4 > 500)) {
HXLINE( 312)							noSides4 = 500;
            						}
            						else {
HXLINE( 312)							noSides4 = result4;
            						}
            					}
HXDLIN( 312)					int sides4 = (::Math_obj::ceil((( (Float)(noSides4) ) / ( (Float)(4) ))) * 4);
HXDLIN( 312)					Float theta4 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides4) ));
HXDLIN( 312)					Float omega4 = ::Math_obj::PI;
HXDLIN( 312)					int quarter4 = ::Std_obj::_hx_int((( (Float)(sides4) ) / ( (Float)(4) )));
HXDLIN( 312)					Float lastX4 = ((Float)0.);
HXDLIN( 312)					Float lastY4 = ((Float)0.);
HXDLIN( 312)					{
HXLINE(  26)						lastX4 = (cx6 + (rx2 * ::Math_obj::cos(((( (Float)(sides4) ) * theta4) + omega4))));
HXLINE(  27)						lastY4 = (cy11 + (ry2 * ::Math_obj::sin(((( (Float)(sides4) ) * theta4) + omega4))));
            					}
HXLINE( 312)					{
HXLINE( 312)						int _g304 = 0;
HXDLIN( 312)						int _g305 = (quarter4 + 1);
HXDLIN( 312)						while((_g304 < _g305)){
HXLINE( 312)							_g304 = (_g304 + 1);
HXDLIN( 312)							int i134 = (_g304 - 1);
HXDLIN( 312)							Float nextX4 = (cx6 + (rx2 * ::Math_obj::cos((((( (Float)(i134) ) * theta4) + ((Float)0.0001)) + omega4))));
HXDLIN( 312)							Float nextY4 = (cy11 + (ry2 * ::Math_obj::sin((((( (Float)(i134) ) * theta4) + ((Float)0.0001)) + omega4))));
HXDLIN( 312)							{
HXLINE( 312)								 ::pi_xy::ImageStruct this460 = this459;
HXDLIN( 312)								bool hasHit14 = false;
HXDLIN( 312)								bool hasUndo14 = false;
HXDLIN( 312)								{
HXLINE( 312)									Float bx9 = lastX4;
HXDLIN( 312)									Float by4 = lastY4;
HXDLIN( 312)									Float cx7 = nextX4;
HXDLIN( 312)									Float cy12 = nextY4;
HXDLIN( 312)									bool adjustWinding4 = (((((cx6 * by4) - (bx9 * cy11)) + ((bx9 * cy12) - (cx7 * by4))) + ((cx7 * cy11) - (cx6 * cy12))) > 0);
HXDLIN( 312)									if (!(adjustWinding4)) {
HXLINE( 312)										Float bx_4 = bx9;
HXDLIN( 312)										Float by_4 = by4;
HXLINE(  25)										bx9 = cx7;
HXLINE(  26)										by4 = cy12;
HXLINE(  27)										cx7 = bx_4;
HXLINE(  28)										cy12 = by_4;
            									}
HXLINE( 312)									{
HXLINE( 312)										Float s04 = ((cy11 * cx7) - (cx6 * cy12));
HXDLIN( 312)										Float sx4 = (cy12 - cy11);
HXDLIN( 312)										Float sy4 = (cx6 - cx7);
HXDLIN( 312)										Float t04 = ((cx6 * by4) - (cy11 * bx9));
HXDLIN( 312)										Float tx4 = (cy11 - by4);
HXDLIN( 312)										Float ty4 = (bx9 - cx6);
HXDLIN( 312)										Float A4 = ((((-(by4) * cx7) + (cy11 * (-(bx9) + cx7))) + (cx6 * (by4 - cy12))) + (bx9 * cy12));
HXDLIN( 312)										 ::pi_xy::iter::IntIterStart xIter314;
HXDLIN( 312)										if ((cx6 > bx9)) {
HXLINE( 312)											if ((cx6 > cx7)) {
HXLINE( 312)												int min53;
HXDLIN( 312)												if ((bx9 > cx7)) {
HXLINE( 312)													min53 = ::Math_obj::floor(cx7);
            												}
            												else {
HXLINE( 312)													min53 = ::Math_obj::floor(bx9);
            												}
HXDLIN( 312)												int ii_min109 = min53;
HXDLIN( 312)												int ii_max109 = ::Math_obj::ceil(cx6);
HXDLIN( 312)												xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min109,ii_max109);
            											}
            											else {
HXLINE( 312)												int ii_min110 = ::Math_obj::floor(bx9);
HXDLIN( 312)												int ii_max110 = ::Math_obj::ceil(cx7);
HXDLIN( 312)												xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min110,ii_max110);
            											}
            										}
            										else {
HXLINE( 312)											if ((bx9 > cx7)) {
HXLINE( 312)												int min54;
HXDLIN( 312)												if ((cx6 > cx7)) {
HXLINE( 312)													min54 = ::Math_obj::floor(cx7);
            												}
            												else {
HXLINE( 312)													min54 = ::Math_obj::ceil(cx6);
            												}
HXDLIN( 312)												int ii_min111 = min54;
HXDLIN( 312)												int ii_max111 = ::Math_obj::ceil(bx9);
HXDLIN( 312)												xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min111,ii_max111);
            											}
            											else {
HXLINE( 312)												int ii_min112 = ::Math_obj::floor(cx6);
HXDLIN( 312)												int ii_max112 = ::Math_obj::ceil(cx7);
HXDLIN( 312)												xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min112,ii_max112);
            											}
            										}
HXDLIN( 312)										 ::pi_xy::iter::IntIterStart yIter314;
HXDLIN( 312)										if ((cy11 > by4)) {
HXLINE( 312)											if ((cy11 > cy12)) {
HXLINE( 312)												int min55;
HXDLIN( 312)												if ((by4 > cy12)) {
HXLINE( 312)													min55 = ::Math_obj::floor(cy12);
            												}
            												else {
HXLINE( 312)													min55 = ::Math_obj::floor(by4);
            												}
HXDLIN( 312)												int ii_min113 = min55;
HXDLIN( 312)												int ii_max113 = ::Math_obj::ceil(cy11);
HXDLIN( 312)												yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min113,ii_max113);
            											}
            											else {
HXLINE( 312)												int ii_min114 = ::Math_obj::floor(by4);
HXDLIN( 312)												int ii_max114 = ::Math_obj::ceil(cy12);
HXDLIN( 312)												yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min114,ii_max114);
            											}
            										}
            										else {
HXLINE( 312)											if ((by4 > cy12)) {
HXLINE( 312)												int min56;
HXDLIN( 312)												if ((cy11 > cy12)) {
HXLINE( 312)													min56 = ::Math_obj::floor(cy12);
            												}
            												else {
HXLINE( 312)													min56 = ::Math_obj::ceil(cy11);
            												}
HXDLIN( 312)												int ii_min115 = min56;
HXDLIN( 312)												int ii_max115 = ::Math_obj::ceil(by4);
HXDLIN( 312)												yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min115,ii_max115);
            											}
            											else {
HXLINE( 312)												int ii_min116 = ::Math_obj::floor(cy11);
HXDLIN( 312)												int ii_max116 = ::Math_obj::ceil(cy12);
HXDLIN( 312)												yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min116,ii_max116);
            											}
            										}
HXDLIN( 312)										 ::pi_xy::ImageStruct undoImage42 = null();
HXDLIN( 312)										if (hasUndo14) {
HXLINE( 312)											int width15 = ((xIter314->max - xIter314->start) + 1);
HXDLIN( 312)											int height15 = ((yIter314->max - yIter314->start) + 1);
HXDLIN( 312)											 ::Dynamic imageType15 = null();
HXDLIN( 312)											 ::pi_xy::ImageStruct this461 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 312)											if (::hx::IsNull( imageType15 )) {
HXLINE(  54)												imageType15 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 312)											::Dynamic undoImage43;
HXDLIN( 312)											switch((int)(( (int)(imageType15) ))){
            												case (int)0: {
HXLINE( 312)													 ::iterMagic::BytesImg byt15 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::BytesImg b93 = byt15;
HXDLIN( 312)													{
HXLINE( 312)														b93->width = width15;
HXDLIN( 312)														b93->height = height15;
HXDLIN( 312)														b93->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 312)														b93->data = ::haxe::io::Bytes_obj::alloc((b93->length * 4));
HXDLIN( 312)														{
HXLINE( 312)															int len30 = b93->length;
HXDLIN( 312)															int w15 = 0;
HXDLIN( 312)															{
HXLINE( 312)																int _g306 = 0;
HXDLIN( 312)																int _g307 = b93->height;
HXDLIN( 312)																while((_g306 < _g307)){
HXLINE( 312)																	_g306 = (_g306 + 1);
HXDLIN( 312)																	int y51 = (_g306 - 1);
HXDLIN( 312)																	{
HXLINE( 312)																		int _g308 = 0;
HXDLIN( 312)																		int _g309 = b93->width;
HXDLIN( 312)																		while((_g308 < _g309)){
HXLINE( 312)																			_g308 = (_g308 + 1);
HXDLIN( 312)																			int x51 = (_g308 - 1);
HXDLIN( 312)																			{
HXLINE( 312)																				w15 = (w15 + 1);
HXDLIN( 312)																				b93->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w15 = (w15 + 1);
HXDLIN( 312)																				b93->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w15 = (w15 + 1);
HXDLIN( 312)																				b93->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w15 = (w15 + 1);
HXDLIN( 312)																				b93->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage43 = b93;
            												}
            												break;
            												case (int)1: {
HXLINE( 312)													 ::iterMagic::ArrIntImg arrI15 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::ArrIntImg a76 = arrI15;
HXDLIN( 312)													{
HXLINE( 312)														a76->width = width15;
HXDLIN( 312)														a76->height = height15;
HXDLIN( 312)														a76->data = ::Array_obj< int >::__new(0);
HXDLIN( 312)														a76->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 312)														{
HXLINE( 312)															int _g310 = 0;
HXDLIN( 312)															int _g311 = a76->length;
HXDLIN( 312)															while((_g310 < _g311)){
HXLINE( 312)																_g310 = (_g310 + 1);
HXDLIN( 312)																int i135 = (_g310 - 1);
HXDLIN( 312)																a76->data[i135] = 0;
            															}
            														}
            													}
HXDLIN( 312)													undoImage43 = a76;
            												}
            												break;
            												case (int)2: {
HXLINE( 312)													 ::iterMagic::U32ArrImg u32a15 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::U32ArrImg b94 = u32a15;
HXDLIN( 312)													{
HXLINE( 312)														b94->width = width15;
HXDLIN( 312)														b94->height = height15;
HXDLIN( 312)														b94->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 312)														int size15 = (b94->length * 4);
HXDLIN( 312)														b94->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size15),0,size15);
HXDLIN( 312)														{
HXLINE( 312)															int _g312 = 0;
HXDLIN( 312)															int _g313 = b94->length;
HXDLIN( 312)															while((_g312 < _g313)){
HXLINE( 312)																_g312 = (_g312 + 1);
HXDLIN( 312)																int i136 = (_g312 - 1);
HXDLIN( 312)																{
HXLINE( 312)																	 ::haxe::io::ArrayBufferViewImpl this462 = b94->data;
HXDLIN( 312)																	bool undoImage44;
HXDLIN( 312)																	if ((i136 >= 0)) {
HXLINE( 312)																		undoImage44 = (i136 < (this462->byteLength >> 2));
            																	}
            																	else {
HXLINE( 312)																		undoImage44 = false;
            																	}
HXDLIN( 312)																	if (undoImage44) {
HXLINE( 312)																		 ::haxe::io::Bytes _this15 = this462->bytes;
HXDLIN( 312)																		int pos15 = ((i136 << 2) + this462->byteOffset);
HXDLIN( 312)																		_this15->b[pos15] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this15->b[(pos15 + 1)] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this15->b[(pos15 + 2)] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this15->b[(pos15 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage43 = b94;
            												}
            												break;
            												case (int)3: {
HXLINE( 312)													 ::iterMagic::VecIntImg vec15 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::VecIntImg v48 = vec15;
HXDLIN( 312)													{
HXLINE( 312)														v48->width = width15;
HXDLIN( 312)														v48->height = height15;
HXDLIN( 312)														v48->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 312)														v48->data = ::Array_obj< int >::__new(v48->length);
HXDLIN( 312)														{
HXLINE( 312)															int _g314 = 0;
HXDLIN( 312)															int _g315 = v48->length;
HXDLIN( 312)															while((_g314 < _g315)){
HXLINE( 312)																_g314 = (_g314 + 1);
HXDLIN( 312)																int i137 = (_g314 - 1);
HXDLIN( 312)																v48->data->__unsafe_set(i137,0);
            															}
            														}
            													}
HXDLIN( 312)													undoImage43 = v48;
            												}
            												break;
            												case (int)4: {
HXLINE( 312)													 ::iterMagic::StackIntImg sInt15 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::StackIntImg b95 = sInt15;
HXDLIN( 312)													{
HXLINE( 312)														b95->width = width15;
HXDLIN( 312)														b95->height = height15;
HXDLIN( 312)														b95->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 312)														b95->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 312)														{
HXLINE( 312)															int len31 = b95->length;
HXDLIN( 312)															 ::haxe::ds::GenericStack_Int d15 = b95->data;
HXDLIN( 312)															if (::hx::IsNull( d15->head )) {
HXLINE( 312)																int _g316 = 0;
HXDLIN( 312)																int _g317 = len31;
HXDLIN( 312)																while((_g316 < _g317)){
HXLINE( 312)																	_g316 = (_g316 + 1);
HXDLIN( 312)																	int i138 = (_g316 - 1);
HXDLIN( 312)																	d15->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d15->head);
            																}
            															}
            															else {
HXLINE( 312)																int _g318 = 0;
HXDLIN( 312)																int _g319 = len31;
HXDLIN( 312)																while((_g318 < _g319)){
HXLINE( 312)																	_g318 = (_g318 + 1);
HXDLIN( 312)																	int i139 = (_g318 - 1);
HXDLIN( 312)																	{
HXLINE( 312)																		 ::haxe::ds::GenericCell_Int l15 = b95->data->head;
HXDLIN( 312)																		 ::haxe::ds::GenericCell_Int prev15 = null();
HXDLIN( 312)																		{
HXLINE( 312)																			int _g320 = 0;
HXDLIN( 312)																			int _g321 = i139;
HXDLIN( 312)																			while((_g320 < _g321)){
HXLINE( 312)																				_g320 = (_g320 + 1);
HXDLIN( 312)																				int i140 = (_g320 - 1);
HXLINE( 345)																				prev15 = l15;
HXLINE( 346)																				l15 = l15->next;
            																			}
            																		}
HXLINE( 312)																		if (::hx::IsNull( prev15 )) {
HXLINE( 312)																			b95->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l15->next);
HXDLIN( 312)																			l15 = null();
            																		}
            																		else {
HXLINE( 312)																			prev15->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l15->next);
HXDLIN( 312)																			l15 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage43 = b95;
            												}
            												break;
            											}
HXDLIN( 312)											this461->image = undoImage43;
HXDLIN( 312)											this461->width = width15;
HXDLIN( 312)											this461->height = height15;
HXDLIN( 312)											this461->imageType = ( (int)(imageType15) );
HXDLIN( 312)											undoImage42 = this461;
HXDLIN( 312)											{
HXLINE( 312)												int rectLeft14 = xIter314->start;
HXDLIN( 312)												int rectTop14 = yIter314->start;
HXDLIN( 312)												int rectRight14 = xIter314->max;
HXDLIN( 312)												bool forceClear14 = false;
HXDLIN( 312)												{
HXLINE( 312)													int _g322 = rectTop14;
HXDLIN( 312)													int _g323 = yIter314->max;
HXDLIN( 312)													while((_g322 < _g323)){
HXLINE( 312)														_g322 = (_g322 + 1);
HXDLIN( 312)														int dy17 = (_g322 - 1);
HXDLIN( 312)														{
HXLINE( 312)															int _g324 = rectLeft14;
HXDLIN( 312)															int _g325 = rectRight14;
HXDLIN( 312)															while((_g324 < _g325)){
HXLINE( 312)																_g324 = (_g324 + 1);
HXDLIN( 312)																int dx17 = (_g324 - 1);
HXDLIN( 312)																::Dynamic this463 = this460->image;
HXDLIN( 312)																int index60;
HXDLIN( 312)																if (this460->useVirtualPos) {
HXLINE( 312)																	index60 = ::Std_obj::_hx_int(((((( (Float)(dy17) ) - this460->virtualY) * ( (Float)(this460->width) )) + dx17) - this460->virtualX));
            																}
            																else {
HXLINE( 312)																	index60 = ::Std_obj::_hx_int(( (Float)(((dy17 * this460->width) + dx17)) ));
            																}
HXDLIN( 312)																int c46 = ::iterMagic::Iimg_obj::get(this463,index60);
HXDLIN( 312)																int col14;
HXDLIN( 312)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																	col14 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            																}
            																else {
HXLINE( 312)																	col14 = c46;
            																}
HXDLIN( 312)																bool _hx_tmp114;
HXDLIN( 312)																if (this460->useMask) {
HXLINE( 312)																	_hx_tmp114 = ::hx::IsNotNull( this460->mask );
            																}
            																else {
HXLINE( 312)																	_hx_tmp114 = false;
            																}
HXDLIN( 312)																if (_hx_tmp114) {
HXLINE( 312)																	 ::pi_xy::ImageStruct this464 = this460->mask;
HXDLIN( 312)																	::Dynamic this465 = this464->image;
HXDLIN( 312)																	int index61;
HXDLIN( 312)																	if (this464->useVirtualPos) {
HXLINE( 312)																		index61 = ::Std_obj::_hx_int(((((( (Float)(dy17) ) - this464->virtualY) * ( (Float)(this464->width) )) + dx17) - this464->virtualX));
            																	}
            																	else {
HXLINE( 312)																		index61 = ::Std_obj::_hx_int(( (Float)(((dy17 * this464->width) + dx17)) ));
            																	}
HXDLIN( 312)																	int c47 = ::iterMagic::Iimg_obj::get(this465,index61);
HXDLIN( 312)																	int v49;
HXDLIN( 312)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																		v49 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            																	}
            																	else {
HXLINE( 312)																		v49 = c47;
            																	}
HXDLIN( 312)																	int maskPixel14 = v49;
HXDLIN( 312)																	int this466 = col14;
HXDLIN( 312)																	if ((maskPixel14 == 0)) {
HXLINE( 312)																		col14 = this466;
            																	}
            																	else {
HXLINE( 312)																		Float m014;
HXDLIN( 312)																		int this467 = ((maskPixel14 >> 24) & 255);
HXDLIN( 312)																		if ((this467 == 0)) {
HXLINE( 312)																			m014 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m014 = (( (Float)(this467) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m114;
HXDLIN( 312)																		int this468 = ((maskPixel14 >> 16) & 255);
HXDLIN( 312)																		if ((this468 == 0)) {
HXLINE( 312)																			m114 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m114 = (( (Float)(this468) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m214;
HXDLIN( 312)																		int this469 = ((maskPixel14 >> 8) & 255);
HXDLIN( 312)																		if ((this469 == 0)) {
HXLINE( 312)																			m214 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m214 = (( (Float)(this469) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m314;
HXDLIN( 312)																		int this470 = (maskPixel14 & 255);
HXDLIN( 312)																		if ((this470 == 0)) {
HXLINE( 312)																			m314 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m314 = (( (Float)(this470) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		int ch014 = ::Std_obj::_hx_int(((((Float)1.) - m014) * ( (Float)(((this466 >> 24) & 255)) )));
HXDLIN( 312)																		int ch114 = ::Std_obj::_hx_int(((((Float)1.) - m114) * ( (Float)(((this466 >> 16) & 255)) )));
HXDLIN( 312)																		int ch214 = ::Std_obj::_hx_int(((((Float)1.) - m214) * ( (Float)(((this466 >> 8) & 255)) )));
HXDLIN( 312)																		int ch314 = ::Std_obj::_hx_int(((((Float)1.) - m314) * ( (Float)((this466 & 255)) )));
HXDLIN( 312)																		col14 = ((((::Math_obj::round((( (Float)(ch014) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch114) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch214) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch314) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 312)																if ((col14 != 0)) {
HXLINE( 312)																	int x52 = (dx17 - rectLeft14);
HXDLIN( 312)																	int y52 = (dy17 - rectTop14);
HXDLIN( 312)																	int c48 = col14;
HXDLIN( 312)																	bool _hx_tmp115;
HXDLIN( 312)																	if ((((c48 >> 24) & 255) < 254)) {
HXLINE( 312)																		_hx_tmp115 = undoImage42->transparent;
            																	}
            																	else {
HXLINE( 312)																		_hx_tmp115 = false;
            																	}
HXDLIN( 312)																	if (_hx_tmp115) {
HXLINE( 312)																		int location28;
HXDLIN( 312)																		if (undoImage42->useVirtualPos) {
HXLINE( 312)																			location28 = ::Std_obj::_hx_int(((((( (Float)(y52) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x52) - undoImage42->virtualX));
            																		}
            																		else {
HXLINE( 312)																			location28 = ::Std_obj::_hx_int(( (Float)(((y52 * undoImage42->width) + x52)) ));
            																		}
HXDLIN( 312)																		int this471 = ::iterMagic::Iimg_obj::get(undoImage42->image,location28);
HXDLIN( 312)																		int this472;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			this472 = ((((((this471 >> 24) & 255) << 24) | ((this471 & 255) << 16)) | (((this471 >> 8) & 255) << 8)) | ((this471 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			this472 = this471;
            																		}
HXDLIN( 312)																		Float a132;
HXDLIN( 312)																		int this473 = ((this472 >> 24) & 255);
HXDLIN( 312)																		if ((this473 == 0)) {
HXLINE( 312)																			a132 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a132 = (( (Float)(this473) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r129;
HXDLIN( 312)																		int this474 = ((this472 >> 16) & 255);
HXDLIN( 312)																		if ((this474 == 0)) {
HXLINE( 312)																			r129 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r129 = (( (Float)(this474) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g129;
HXDLIN( 312)																		int this475 = ((this472 >> 8) & 255);
HXDLIN( 312)																		if ((this475 == 0)) {
HXLINE( 312)																			g129 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g129 = (( (Float)(this475) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b134;
HXDLIN( 312)																		int this476 = (this472 & 255);
HXDLIN( 312)																		if ((this476 == 0)) {
HXLINE( 312)																			b134 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b134 = (( (Float)(this476) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a230;
HXDLIN( 312)																		int this477 = ((col14 >> 24) & 255);
HXDLIN( 312)																		if ((this477 == 0)) {
HXLINE( 312)																			a230 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a230 = (( (Float)(this477) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r229;
HXDLIN( 312)																		int this478 = ((col14 >> 16) & 255);
HXDLIN( 312)																		if ((this478 == 0)) {
HXLINE( 312)																			r229 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r229 = (( (Float)(this478) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g229;
HXDLIN( 312)																		int this479 = ((col14 >> 8) & 255);
HXDLIN( 312)																		if ((this479 == 0)) {
HXLINE( 312)																			g229 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g229 = (( (Float)(this479) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b232;
HXDLIN( 312)																		int this480 = (col14 & 255);
HXDLIN( 312)																		if ((this480 == 0)) {
HXLINE( 312)																			b232 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b232 = (( (Float)(this480) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a329 = (a132 * (( (Float)(1) ) - a230));
HXDLIN( 312)																		int r56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r129 * a329) + (r229 * a230))));
HXDLIN( 312)																		int g56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g129 * a329) + (g229 * a230))));
HXDLIN( 312)																		int b96 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b134 * a329) + (b232 * a230))));
HXDLIN( 312)																		int a77 = ::Std_obj::_hx_int((( (Float)(255) ) * (a329 + a230)));
HXDLIN( 312)																		int blended28 = ((((a77 << 24) | (r56 << 16)) | (g56 << 8)) | b96);
HXDLIN( 312)																		{
HXLINE( 312)																			int _hx_tmp116;
HXDLIN( 312)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																				_hx_tmp116 = ((((((blended28 >> 24) & 255) << 24) | ((blended28 & 255) << 16)) | (((blended28 >> 8) & 255) << 8)) | ((blended28 >> 16) & 255));
            																			}
            																			else {
HXLINE( 312)																				_hx_tmp116 = blended28;
            																			}
HXDLIN( 312)																			::iterMagic::Iimg_obj::set(undoImage42->image,location28,_hx_tmp116);
            																		}
            																	}
            																	else {
HXLINE( 312)																		::Dynamic this481 = undoImage42->image;
HXDLIN( 312)																		int index62;
HXDLIN( 312)																		if (undoImage42->useVirtualPos) {
HXLINE( 312)																			index62 = ::Std_obj::_hx_int(((((( (Float)(y52) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x52) - undoImage42->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index62 = ::Std_obj::_hx_int(( (Float)(((y52 * undoImage42->width) + x52)) ));
            																		}
HXDLIN( 312)																		int _hx_tmp117;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			_hx_tmp117 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			_hx_tmp117 = c48;
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this481,index62,_hx_tmp117);
            																	}
            																}
            																else {
HXLINE( 312)																	if (forceClear14) {
HXLINE( 312)																		::Dynamic this482 = undoImage42->image;
HXDLIN( 312)																		int x53 = (dx17 - rectLeft14);
HXDLIN( 312)																		int y53 = (dy17 - rectTop14);
HXDLIN( 312)																		int index63;
HXDLIN( 312)																		if (undoImage42->useVirtualPos) {
HXLINE( 312)																			index63 = ::Std_obj::_hx_int(((((( (Float)(y53) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x53) - undoImage42->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index63 = ::Std_obj::_hx_int(( (Float)(((y53 * undoImage42->width) + x53)) ));
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this482,index63,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 312)										bool found4 = false;
HXDLIN( 312)										Float s4 = ((Float)0.);
HXDLIN( 312)										Float t4 = ((Float)0.);
HXDLIN( 312)										Float sxx4 = ((Float)0.);
HXDLIN( 312)										Float txx4 = ((Float)0.);
HXDLIN( 312)										{
HXLINE( 312)											int _g_min28 = xIter314->start;
HXDLIN( 312)											int _g_max28 = xIter314->max;
HXDLIN( 312)											while((_g_min28 < _g_max28)){
HXLINE( 312)												_g_min28 = (_g_min28 + 1);
HXDLIN( 312)												int x54 = (_g_min28 - 1);
HXLINE(  60)												sxx4 = (sx4 * ( (Float)(x54) ));
HXLINE(  61)												txx4 = (tx4 * ( (Float)(x54) ));
HXLINE(  62)												found4 = false;
HXLINE( 312)												{
HXLINE( 312)													int _g_min29 = yIter314->start;
HXDLIN( 312)													int _g_max29 = yIter314->max;
HXDLIN( 312)													while((_g_min29 < _g_max29)){
HXLINE( 312)														_g_min29 = (_g_min29 + 1);
HXDLIN( 312)														int y54 = (_g_min29 - 1);
HXLINE(  64)														s4 = ((s04 + sxx4) + (sy4 * ( (Float)(y54) )));
HXLINE(  65)														t4 = ((t04 + txx4) + (ty4 * ( (Float)(y54) )));
HXLINE( 312)														bool _hx_tmp118;
HXDLIN( 312)														if (!((s4 <= 0))) {
HXLINE( 312)															_hx_tmp118 = (t4 <= 0);
            														}
            														else {
HXLINE( 312)															_hx_tmp118 = true;
            														}
HXDLIN( 312)														if (_hx_tmp118) {
HXLINE( 312)															if (found4) {
HXLINE( 312)																goto _hx_goto_865;
            															}
            														}
            														else {
HXLINE( 312)															if (((s4 + t4) < A4)) {
HXLINE( 312)																{
HXLINE( 312)																	int c49 = 0;
HXDLIN( 312)																	bool _hx_tmp119;
HXDLIN( 312)																	if ((((c49 >> 24) & 255) < 254)) {
HXLINE( 312)																		_hx_tmp119 = this460->transparent;
            																	}
            																	else {
HXLINE( 312)																		_hx_tmp119 = false;
            																	}
HXDLIN( 312)																	if (_hx_tmp119) {
HXLINE( 312)																		int location29;
HXDLIN( 312)																		if (this460->useVirtualPos) {
HXLINE( 312)																			location29 = ::Std_obj::_hx_int(((((( (Float)(y54) ) - this460->virtualY) * ( (Float)(this460->width) )) + x54) - this460->virtualX));
            																		}
            																		else {
HXLINE( 312)																			location29 = ::Std_obj::_hx_int(( (Float)(((y54 * this460->width) + x54)) ));
            																		}
HXDLIN( 312)																		int this483 = ::iterMagic::Iimg_obj::get(this460->image,location29);
HXDLIN( 312)																		int this484;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			this484 = ((((((this483 >> 24) & 255) << 24) | ((this483 & 255) << 16)) | (((this483 >> 8) & 255) << 8)) | ((this483 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			this484 = this483;
            																		}
HXDLIN( 312)																		Float a133;
HXDLIN( 312)																		int this485 = ((this484 >> 24) & 255);
HXDLIN( 312)																		if ((this485 == 0)) {
HXLINE( 312)																			a133 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a133 = (( (Float)(this485) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r130;
HXDLIN( 312)																		int this486 = ((this484 >> 16) & 255);
HXDLIN( 312)																		if ((this486 == 0)) {
HXLINE( 312)																			r130 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r130 = (( (Float)(this486) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g130;
HXDLIN( 312)																		int this487 = ((this484 >> 8) & 255);
HXDLIN( 312)																		if ((this487 == 0)) {
HXLINE( 312)																			g130 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g130 = (( (Float)(this487) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b135;
HXDLIN( 312)																		int this488 = (this484 & 255);
HXDLIN( 312)																		if ((this488 == 0)) {
HXLINE( 312)																			b135 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b135 = (( (Float)(this488) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a231;
HXDLIN( 312)																		int this489 = ((0 >> 24) & 255);
HXDLIN( 312)																		if ((this489 == 0)) {
HXLINE( 312)																			a231 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a231 = (( (Float)(this489) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r230;
HXDLIN( 312)																		int this490 = ((0 >> 16) & 255);
HXDLIN( 312)																		if ((this490 == 0)) {
HXLINE( 312)																			r230 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r230 = (( (Float)(this490) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g230;
HXDLIN( 312)																		int this491 = ((0 >> 8) & 255);
HXDLIN( 312)																		if ((this491 == 0)) {
HXLINE( 312)																			g230 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g230 = (( (Float)(this491) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b233;
HXDLIN( 312)																		int this492 = (0 & 255);
HXDLIN( 312)																		if ((this492 == 0)) {
HXLINE( 312)																			b233 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b233 = (( (Float)(this492) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a330 = (a133 * (( (Float)(1) ) - a231));
HXDLIN( 312)																		int r57 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r130 * a330) + (r230 * a231))));
HXDLIN( 312)																		int g57 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g130 * a330) + (g230 * a231))));
HXDLIN( 312)																		int b97 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b135 * a330) + (b233 * a231))));
HXDLIN( 312)																		int a78 = ::Std_obj::_hx_int((( (Float)(255) ) * (a330 + a231)));
HXDLIN( 312)																		int blended29 = ((((a78 << 24) | (r57 << 16)) | (g57 << 8)) | b97);
HXDLIN( 312)																		{
HXLINE( 312)																			int _hx_tmp120;
HXDLIN( 312)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																				_hx_tmp120 = ((((((blended29 >> 24) & 255) << 24) | ((blended29 & 255) << 16)) | (((blended29 >> 8) & 255) << 8)) | ((blended29 >> 16) & 255));
            																			}
            																			else {
HXLINE( 312)																				_hx_tmp120 = blended29;
            																			}
HXDLIN( 312)																			::iterMagic::Iimg_obj::set(this460->image,location29,_hx_tmp120);
            																		}
            																	}
            																	else {
HXLINE( 312)																		::Dynamic this493 = this460->image;
HXDLIN( 312)																		int index64;
HXDLIN( 312)																		if (this460->useVirtualPos) {
HXLINE( 312)																			index64 = ::Std_obj::_hx_int(((((( (Float)(y54) ) - this460->virtualY) * ( (Float)(this460->width) )) + x54) - this460->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index64 = ::Std_obj::_hx_int(( (Float)(((y54 * this460->width) + x54)) ));
            																		}
HXDLIN( 312)																		int _hx_tmp121;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			_hx_tmp121 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			_hx_tmp121 = c49;
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this493,index64,_hx_tmp121);
            																	}
            																}
HXLINE(  73)																found4 = true;
            															}
            															else {
HXLINE( 312)																if (found4) {
HXLINE( 312)																	goto _hx_goto_865;
            																}
            															}
            														}
            													}
            													_hx_goto_865:;
            												}
            											}
            										}
HXDLIN( 312)										if ((hasHit14 == true)) {
HXLINE( 312)											 ::pi_xy::algo::HitTri v50 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx6,cy11,bx9,by4,cx7,cy12,true);
HXDLIN( 312)											if (hasUndo14) {
HXLINE( 312)												v50->undoImage = undoImage42;
HXDLIN( 312)												v50->undoX = xIter314->start;
HXDLIN( 312)												v50->undoY = yIter314->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX4 = nextX4;
HXLINE(  47)							lastY4 = nextY4;
            						}
            					}
            				}
            			}
HXLINE( 312)			{
HXLINE( 312)				int r_x = ::Std_obj::_hx_int((thick + dx16));
HXDLIN( 312)				int r_y = ::Std_obj::_hx_int(thick);
HXDLIN( 312)				int r_w = ::Std_obj::_hx_int(( (Float)(fat2) ));
HXDLIN( 312)				int r_h = ::Std_obj::_hx_int(( (Float)(dy16) ));
HXDLIN( 312)				int xmax = ((r_x + r_w) + 1);
HXDLIN( 312)				int ymax = ((r_y + r_h) + 1);
HXDLIN( 312)				int ii_min117 = r_x;
HXDLIN( 312)				int ii_max117 = xmax;
HXDLIN( 312)				int xRange__start = ii_min117;
HXDLIN( 312)				int xRange__max = ii_max117;
HXDLIN( 312)				int ii_min118 = r_y;
HXDLIN( 312)				int ii_max118 = ymax;
HXDLIN( 312)				int yRange__start = ii_min118;
HXDLIN( 312)				int yRange__max = ii_max118;
HXDLIN( 312)				int range_x = xRange__start;
HXDLIN( 312)				int range_y = (yRange__start - 1);
HXDLIN( 312)				int range_xReset = range_x;
HXDLIN( 312)				int range_yReset = range_y;
HXDLIN( 312)				int range_xMax = (xRange__max - 2);
HXDLIN( 312)				int range_yMax = (yRange__max - 2);
HXDLIN( 312)				int _this_min = 0;
HXDLIN( 312)				int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 312)				while((_this_min < _this_max)){
HXLINE( 312)					_this_min = (_this_min + 1);
HXDLIN( 312)					int i141 = (_this_min - 1);
HXDLIN( 312)					if ((range_y > range_yMax)) {
HXLINE( 312)						range_y = range_yReset;
HXDLIN( 312)						range_x = (range_x + 1);
            					}
HXDLIN( 312)					range_y = (range_y + 1);
HXDLIN( 312)					int i142 = i141;
HXDLIN( 312)					{
HXLINE( 312)						int x55 = range_x;
HXDLIN( 312)						int y55 = range_y;
HXDLIN( 312)						int c50 = 0;
HXDLIN( 312)						bool _hx_tmp122;
HXDLIN( 312)						if ((((c50 >> 24) & 255) < 254)) {
HXLINE( 312)							_hx_tmp122 = temp->transparent;
            						}
            						else {
HXLINE( 312)							_hx_tmp122 = false;
            						}
HXDLIN( 312)						if (_hx_tmp122) {
HXLINE( 312)							int location30;
HXDLIN( 312)							if (temp->useVirtualPos) {
HXLINE( 312)								location30 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - temp->virtualY) * ( (Float)(temp->width) )) + x55) - temp->virtualX));
            							}
            							else {
HXLINE( 312)								location30 = ::Std_obj::_hx_int(( (Float)(((y55 * temp->width) + x55)) ));
            							}
HXDLIN( 312)							int this494 = ::iterMagic::Iimg_obj::get(temp->image,location30);
HXDLIN( 312)							int this495;
HXDLIN( 312)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)								this495 = ((((((this494 >> 24) & 255) << 24) | ((this494 & 255) << 16)) | (((this494 >> 8) & 255) << 8)) | ((this494 >> 16) & 255));
            							}
            							else {
HXLINE( 312)								this495 = this494;
            							}
HXDLIN( 312)							Float a134;
HXDLIN( 312)							int this496 = ((this495 >> 24) & 255);
HXDLIN( 312)							if ((this496 == 0)) {
HXLINE( 312)								a134 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								a134 = (( (Float)(this496) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float r131;
HXDLIN( 312)							int this497 = ((this495 >> 16) & 255);
HXDLIN( 312)							if ((this497 == 0)) {
HXLINE( 312)								r131 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								r131 = (( (Float)(this497) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float g131;
HXDLIN( 312)							int this498 = ((this495 >> 8) & 255);
HXDLIN( 312)							if ((this498 == 0)) {
HXLINE( 312)								g131 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								g131 = (( (Float)(this498) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float b136;
HXDLIN( 312)							int this499 = (this495 & 255);
HXDLIN( 312)							if ((this499 == 0)) {
HXLINE( 312)								b136 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								b136 = (( (Float)(this499) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float a232;
HXDLIN( 312)							int this500 = ((0 >> 24) & 255);
HXDLIN( 312)							if ((this500 == 0)) {
HXLINE( 312)								a232 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								a232 = (( (Float)(this500) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float r231;
HXDLIN( 312)							int this501 = ((0 >> 16) & 255);
HXDLIN( 312)							if ((this501 == 0)) {
HXLINE( 312)								r231 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								r231 = (( (Float)(this501) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float g231;
HXDLIN( 312)							int this502 = ((0 >> 8) & 255);
HXDLIN( 312)							if ((this502 == 0)) {
HXLINE( 312)								g231 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								g231 = (( (Float)(this502) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float b234;
HXDLIN( 312)							int this503 = (0 & 255);
HXDLIN( 312)							if ((this503 == 0)) {
HXLINE( 312)								b234 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								b234 = (( (Float)(this503) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float a331 = (a134 * (( (Float)(1) ) - a232));
HXDLIN( 312)							int r58 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r131 * a331) + (r231 * a232))));
HXDLIN( 312)							int g58 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g131 * a331) + (g231 * a232))));
HXDLIN( 312)							int b98 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b136 * a331) + (b234 * a232))));
HXDLIN( 312)							int a79 = ::Std_obj::_hx_int((( (Float)(255) ) * (a331 + a232)));
HXDLIN( 312)							int blended30 = ((((a79 << 24) | (r58 << 16)) | (g58 << 8)) | b98);
HXDLIN( 312)							{
HXLINE( 312)								int _hx_tmp123;
HXDLIN( 312)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)									_hx_tmp123 = ((((((blended30 >> 24) & 255) << 24) | ((blended30 & 255) << 16)) | (((blended30 >> 8) & 255) << 8)) | ((blended30 >> 16) & 255));
            								}
            								else {
HXLINE( 312)									_hx_tmp123 = blended30;
            								}
HXDLIN( 312)								::iterMagic::Iimg_obj::set(temp->image,location30,_hx_tmp123);
            							}
            						}
            						else {
HXLINE( 312)							::Dynamic this504 = temp->image;
HXDLIN( 312)							int index65;
HXDLIN( 312)							if (temp->useVirtualPos) {
HXLINE( 312)								index65 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - temp->virtualY) * ( (Float)(temp->width) )) + x55) - temp->virtualX));
            							}
            							else {
HXLINE( 312)								index65 = ::Std_obj::_hx_int(( (Float)(((y55 * temp->width) + x55)) ));
            							}
HXDLIN( 312)							int _hx_tmp124;
HXDLIN( 312)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)								_hx_tmp124 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            							}
            							else {
HXLINE( 312)								_hx_tmp124 = c50;
            							}
HXDLIN( 312)							::iterMagic::Iimg_obj::set(this504,index65,_hx_tmp124);
            						}
            					}
            				}
            			}
HXDLIN( 312)			{
HXLINE( 312)				 ::pi_xy::ImageStruct this505 = temp;
HXDLIN( 312)				Float cy13 = (thick + dy16);
HXDLIN( 312)				Float ry3 = ( (Float)(dy16) );
HXDLIN( 312)				{
HXLINE( 312)					 ::Dynamic targetError5 = ((Float)1.05);
HXDLIN( 312)					if (::hx::IsNull( targetError5 )) {
HXLINE( 113)						targetError5 = ((Float)1.05);
            					}
HXLINE( 312)					Float rSmall5;
HXDLIN( 312)					if ((rightRadius1 > ry3)) {
HXLINE( 312)						rSmall5 = ry3;
            					}
            					else {
HXLINE( 312)						rSmall5 = rightRadius1;
            					}
HXDLIN( 312)					 ::Dynamic targetE5 = ( (Float)(targetError5) );
HXDLIN( 312)					if (::hx::IsNull( targetE5 )) {
HXLINE(  20)						targetE5 = ((Float)1.05);
            					}
HXLINE( 312)					int result5 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE5) ) / rSmall5)))));
HXDLIN( 312)					int noSides5;
HXDLIN( 312)					if ((result5 < 12)) {
HXLINE( 312)						noSides5 = 12;
            					}
            					else {
HXLINE( 312)						if ((result5 > 500)) {
HXLINE( 312)							noSides5 = 500;
            						}
            						else {
HXLINE( 312)							noSides5 = result5;
            						}
            					}
HXDLIN( 312)					int sides5 = (::Math_obj::ceil((( (Float)(noSides5) ) / ( (Float)(4) ))) * 4);
HXDLIN( 312)					Float theta5 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides5) ));
HXDLIN( 312)					Float omega5 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN( 312)					int quarter5 = ::Std_obj::_hx_int((( (Float)(sides5) ) / ( (Float)(4) )));
HXDLIN( 312)					Float lastX5 = ((Float)0.);
HXDLIN( 312)					Float lastY5 = ((Float)0.);
HXDLIN( 312)					{
HXLINE(  26)						lastX5 = (farX1 + (rightRadius1 * ::Math_obj::cos(((( (Float)(sides5) ) * theta5) + omega5))));
HXLINE(  27)						lastY5 = (cy13 + (ry3 * ::Math_obj::sin(((( (Float)(sides5) ) * theta5) + omega5))));
            					}
HXLINE( 312)					{
HXLINE( 312)						int _g326 = 0;
HXDLIN( 312)						int _g327 = (quarter5 + 1);
HXDLIN( 312)						while((_g326 < _g327)){
HXLINE( 312)							_g326 = (_g326 + 1);
HXDLIN( 312)							int i143 = (_g326 - 1);
HXDLIN( 312)							Float nextX5 = (farX1 + (rightRadius1 * ::Math_obj::cos((((( (Float)(i143) ) * theta5) + ((Float)0.0001)) + omega5))));
HXDLIN( 312)							Float nextY5 = (cy13 + (ry3 * ::Math_obj::sin((((( (Float)(i143) ) * theta5) + ((Float)0.0001)) + omega5))));
HXDLIN( 312)							{
HXLINE( 312)								 ::pi_xy::ImageStruct this506 = this505;
HXDLIN( 312)								bool hasHit15 = false;
HXDLIN( 312)								bool hasUndo15 = false;
HXDLIN( 312)								{
HXLINE( 312)									Float bx10 = lastX5;
HXDLIN( 312)									Float by5 = lastY5;
HXDLIN( 312)									Float cx8 = nextX5;
HXDLIN( 312)									Float cy14 = nextY5;
HXDLIN( 312)									bool adjustWinding5 = (((((farX1 * by5) - (bx10 * cy13)) + ((bx10 * cy14) - (cx8 * by5))) + ((cx8 * cy13) - (farX1 * cy14))) > 0);
HXDLIN( 312)									if (!(adjustWinding5)) {
HXLINE( 312)										Float bx_5 = bx10;
HXDLIN( 312)										Float by_5 = by5;
HXLINE(  25)										bx10 = cx8;
HXLINE(  26)										by5 = cy14;
HXLINE(  27)										cx8 = bx_5;
HXLINE(  28)										cy14 = by_5;
            									}
HXLINE( 312)									{
HXLINE( 312)										Float s05 = ((cy13 * cx8) - (farX1 * cy14));
HXDLIN( 312)										Float sx5 = (cy14 - cy13);
HXDLIN( 312)										Float sy5 = (farX1 - cx8);
HXDLIN( 312)										Float t05 = ((farX1 * by5) - (cy13 * bx10));
HXDLIN( 312)										Float tx5 = (cy13 - by5);
HXDLIN( 312)										Float ty5 = (bx10 - farX1);
HXDLIN( 312)										Float A5 = ((((-(by5) * cx8) + (cy13 * (-(bx10) + cx8))) + (farX1 * (by5 - cy14))) + (bx10 * cy14));
HXDLIN( 312)										 ::pi_xy::iter::IntIterStart xIter315;
HXDLIN( 312)										if ((farX1 > bx10)) {
HXLINE( 312)											if ((farX1 > cx8)) {
HXLINE( 312)												int min57;
HXDLIN( 312)												if ((bx10 > cx8)) {
HXLINE( 312)													min57 = ::Math_obj::floor(cx8);
            												}
            												else {
HXLINE( 312)													min57 = ::Math_obj::floor(bx10);
            												}
HXDLIN( 312)												int ii_min119 = min57;
HXDLIN( 312)												int ii_max119 = ::Math_obj::ceil(farX1);
HXDLIN( 312)												xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min119,ii_max119);
            											}
            											else {
HXLINE( 312)												int ii_min120 = ::Math_obj::floor(bx10);
HXDLIN( 312)												int ii_max120 = ::Math_obj::ceil(cx8);
HXDLIN( 312)												xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min120,ii_max120);
            											}
            										}
            										else {
HXLINE( 312)											if ((bx10 > cx8)) {
HXLINE( 312)												int min58;
HXDLIN( 312)												if ((farX1 > cx8)) {
HXLINE( 312)													min58 = ::Math_obj::floor(cx8);
            												}
            												else {
HXLINE( 312)													min58 = ::Math_obj::ceil(farX1);
            												}
HXDLIN( 312)												int ii_min121 = min58;
HXDLIN( 312)												int ii_max121 = ::Math_obj::ceil(bx10);
HXDLIN( 312)												xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min121,ii_max121);
            											}
            											else {
HXLINE( 312)												int ii_min122 = ::Math_obj::floor(farX1);
HXDLIN( 312)												int ii_max122 = ::Math_obj::ceil(cx8);
HXDLIN( 312)												xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min122,ii_max122);
            											}
            										}
HXDLIN( 312)										 ::pi_xy::iter::IntIterStart yIter315;
HXDLIN( 312)										if ((cy13 > by5)) {
HXLINE( 312)											if ((cy13 > cy14)) {
HXLINE( 312)												int min59;
HXDLIN( 312)												if ((by5 > cy14)) {
HXLINE( 312)													min59 = ::Math_obj::floor(cy14);
            												}
            												else {
HXLINE( 312)													min59 = ::Math_obj::floor(by5);
            												}
HXDLIN( 312)												int ii_min123 = min59;
HXDLIN( 312)												int ii_max123 = ::Math_obj::ceil(cy13);
HXDLIN( 312)												yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min123,ii_max123);
            											}
            											else {
HXLINE( 312)												int ii_min124 = ::Math_obj::floor(by5);
HXDLIN( 312)												int ii_max124 = ::Math_obj::ceil(cy14);
HXDLIN( 312)												yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min124,ii_max124);
            											}
            										}
            										else {
HXLINE( 312)											if ((by5 > cy14)) {
HXLINE( 312)												int min60;
HXDLIN( 312)												if ((cy13 > cy14)) {
HXLINE( 312)													min60 = ::Math_obj::floor(cy14);
            												}
            												else {
HXLINE( 312)													min60 = ::Math_obj::ceil(cy13);
            												}
HXDLIN( 312)												int ii_min125 = min60;
HXDLIN( 312)												int ii_max125 = ::Math_obj::ceil(by5);
HXDLIN( 312)												yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min125,ii_max125);
            											}
            											else {
HXLINE( 312)												int ii_min126 = ::Math_obj::floor(cy13);
HXDLIN( 312)												int ii_max126 = ::Math_obj::ceil(cy14);
HXDLIN( 312)												yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min126,ii_max126);
            											}
            										}
HXDLIN( 312)										 ::pi_xy::ImageStruct undoImage45 = null();
HXDLIN( 312)										if (hasUndo15) {
HXLINE( 312)											int width16 = ((xIter315->max - xIter315->start) + 1);
HXDLIN( 312)											int height16 = ((yIter315->max - yIter315->start) + 1);
HXDLIN( 312)											 ::Dynamic imageType16 = null();
HXDLIN( 312)											 ::pi_xy::ImageStruct this507 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 312)											if (::hx::IsNull( imageType16 )) {
HXLINE(  54)												imageType16 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 312)											::Dynamic undoImage46;
HXDLIN( 312)											switch((int)(( (int)(imageType16) ))){
            												case (int)0: {
HXLINE( 312)													 ::iterMagic::BytesImg byt16 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::BytesImg b99 = byt16;
HXDLIN( 312)													{
HXLINE( 312)														b99->width = width16;
HXDLIN( 312)														b99->height = height16;
HXDLIN( 312)														b99->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 312)														b99->data = ::haxe::io::Bytes_obj::alloc((b99->length * 4));
HXDLIN( 312)														{
HXLINE( 312)															int len32 = b99->length;
HXDLIN( 312)															int w16 = 0;
HXDLIN( 312)															{
HXLINE( 312)																int _g328 = 0;
HXDLIN( 312)																int _g329 = b99->height;
HXDLIN( 312)																while((_g328 < _g329)){
HXLINE( 312)																	_g328 = (_g328 + 1);
HXDLIN( 312)																	int y56 = (_g328 - 1);
HXDLIN( 312)																	{
HXLINE( 312)																		int _g330 = 0;
HXDLIN( 312)																		int _g331 = b99->width;
HXDLIN( 312)																		while((_g330 < _g331)){
HXLINE( 312)																			_g330 = (_g330 + 1);
HXDLIN( 312)																			int x56 = (_g330 - 1);
HXDLIN( 312)																			{
HXLINE( 312)																				w16 = (w16 + 1);
HXDLIN( 312)																				b99->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w16 = (w16 + 1);
HXDLIN( 312)																				b99->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w16 = (w16 + 1);
HXDLIN( 312)																				b99->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w16 = (w16 + 1);
HXDLIN( 312)																				b99->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage46 = b99;
            												}
            												break;
            												case (int)1: {
HXLINE( 312)													 ::iterMagic::ArrIntImg arrI16 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::ArrIntImg a80 = arrI16;
HXDLIN( 312)													{
HXLINE( 312)														a80->width = width16;
HXDLIN( 312)														a80->height = height16;
HXDLIN( 312)														a80->data = ::Array_obj< int >::__new(0);
HXDLIN( 312)														a80->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 312)														{
HXLINE( 312)															int _g332 = 0;
HXDLIN( 312)															int _g333 = a80->length;
HXDLIN( 312)															while((_g332 < _g333)){
HXLINE( 312)																_g332 = (_g332 + 1);
HXDLIN( 312)																int i144 = (_g332 - 1);
HXDLIN( 312)																a80->data[i144] = 0;
            															}
            														}
            													}
HXDLIN( 312)													undoImage46 = a80;
            												}
            												break;
            												case (int)2: {
HXLINE( 312)													 ::iterMagic::U32ArrImg u32a16 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::U32ArrImg b100 = u32a16;
HXDLIN( 312)													{
HXLINE( 312)														b100->width = width16;
HXDLIN( 312)														b100->height = height16;
HXDLIN( 312)														b100->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 312)														int size16 = (b100->length * 4);
HXDLIN( 312)														b100->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size16),0,size16);
HXDLIN( 312)														{
HXLINE( 312)															int _g334 = 0;
HXDLIN( 312)															int _g335 = b100->length;
HXDLIN( 312)															while((_g334 < _g335)){
HXLINE( 312)																_g334 = (_g334 + 1);
HXDLIN( 312)																int i145 = (_g334 - 1);
HXDLIN( 312)																{
HXLINE( 312)																	 ::haxe::io::ArrayBufferViewImpl this508 = b100->data;
HXDLIN( 312)																	bool undoImage47;
HXDLIN( 312)																	if ((i145 >= 0)) {
HXLINE( 312)																		undoImage47 = (i145 < (this508->byteLength >> 2));
            																	}
            																	else {
HXLINE( 312)																		undoImage47 = false;
            																	}
HXDLIN( 312)																	if (undoImage47) {
HXLINE( 312)																		 ::haxe::io::Bytes _this16 = this508->bytes;
HXDLIN( 312)																		int pos16 = ((i145 << 2) + this508->byteOffset);
HXDLIN( 312)																		_this16->b[pos16] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this16->b[(pos16 + 1)] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this16->b[(pos16 + 2)] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this16->b[(pos16 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage46 = b100;
            												}
            												break;
            												case (int)3: {
HXLINE( 312)													 ::iterMagic::VecIntImg vec16 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::VecIntImg v51 = vec16;
HXDLIN( 312)													{
HXLINE( 312)														v51->width = width16;
HXDLIN( 312)														v51->height = height16;
HXDLIN( 312)														v51->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 312)														v51->data = ::Array_obj< int >::__new(v51->length);
HXDLIN( 312)														{
HXLINE( 312)															int _g336 = 0;
HXDLIN( 312)															int _g337 = v51->length;
HXDLIN( 312)															while((_g336 < _g337)){
HXLINE( 312)																_g336 = (_g336 + 1);
HXDLIN( 312)																int i146 = (_g336 - 1);
HXDLIN( 312)																v51->data->__unsafe_set(i146,0);
            															}
            														}
            													}
HXDLIN( 312)													undoImage46 = v51;
            												}
            												break;
            												case (int)4: {
HXLINE( 312)													 ::iterMagic::StackIntImg sInt16 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::StackIntImg b101 = sInt16;
HXDLIN( 312)													{
HXLINE( 312)														b101->width = width16;
HXDLIN( 312)														b101->height = height16;
HXDLIN( 312)														b101->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 312)														b101->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 312)														{
HXLINE( 312)															int len33 = b101->length;
HXDLIN( 312)															 ::haxe::ds::GenericStack_Int d16 = b101->data;
HXDLIN( 312)															if (::hx::IsNull( d16->head )) {
HXLINE( 312)																int _g338 = 0;
HXDLIN( 312)																int _g339 = len33;
HXDLIN( 312)																while((_g338 < _g339)){
HXLINE( 312)																	_g338 = (_g338 + 1);
HXDLIN( 312)																	int i147 = (_g338 - 1);
HXDLIN( 312)																	d16->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d16->head);
            																}
            															}
            															else {
HXLINE( 312)																int _g340 = 0;
HXDLIN( 312)																int _g341 = len33;
HXDLIN( 312)																while((_g340 < _g341)){
HXLINE( 312)																	_g340 = (_g340 + 1);
HXDLIN( 312)																	int i148 = (_g340 - 1);
HXDLIN( 312)																	{
HXLINE( 312)																		 ::haxe::ds::GenericCell_Int l16 = b101->data->head;
HXDLIN( 312)																		 ::haxe::ds::GenericCell_Int prev16 = null();
HXDLIN( 312)																		{
HXLINE( 312)																			int _g342 = 0;
HXDLIN( 312)																			int _g343 = i148;
HXDLIN( 312)																			while((_g342 < _g343)){
HXLINE( 312)																				_g342 = (_g342 + 1);
HXDLIN( 312)																				int i149 = (_g342 - 1);
HXLINE( 345)																				prev16 = l16;
HXLINE( 346)																				l16 = l16->next;
            																			}
            																		}
HXLINE( 312)																		if (::hx::IsNull( prev16 )) {
HXLINE( 312)																			b101->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l16->next);
HXDLIN( 312)																			l16 = null();
            																		}
            																		else {
HXLINE( 312)																			prev16->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l16->next);
HXDLIN( 312)																			l16 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage46 = b101;
            												}
            												break;
            											}
HXDLIN( 312)											this507->image = undoImage46;
HXDLIN( 312)											this507->width = width16;
HXDLIN( 312)											this507->height = height16;
HXDLIN( 312)											this507->imageType = ( (int)(imageType16) );
HXDLIN( 312)											undoImage45 = this507;
HXDLIN( 312)											{
HXLINE( 312)												int rectLeft15 = xIter315->start;
HXDLIN( 312)												int rectTop15 = yIter315->start;
HXDLIN( 312)												int rectRight15 = xIter315->max;
HXDLIN( 312)												bool forceClear15 = false;
HXDLIN( 312)												{
HXLINE( 312)													int _g344 = rectTop15;
HXDLIN( 312)													int _g345 = yIter315->max;
HXDLIN( 312)													while((_g344 < _g345)){
HXLINE( 312)														_g344 = (_g344 + 1);
HXDLIN( 312)														int dy18 = (_g344 - 1);
HXDLIN( 312)														{
HXLINE( 312)															int _g346 = rectLeft15;
HXDLIN( 312)															int _g347 = rectRight15;
HXDLIN( 312)															while((_g346 < _g347)){
HXLINE( 312)																_g346 = (_g346 + 1);
HXDLIN( 312)																int dx18 = (_g346 - 1);
HXDLIN( 312)																::Dynamic this509 = this506->image;
HXDLIN( 312)																int index66;
HXDLIN( 312)																if (this506->useVirtualPos) {
HXLINE( 312)																	index66 = ::Std_obj::_hx_int(((((( (Float)(dy18) ) - this506->virtualY) * ( (Float)(this506->width) )) + dx18) - this506->virtualX));
            																}
            																else {
HXLINE( 312)																	index66 = ::Std_obj::_hx_int(( (Float)(((dy18 * this506->width) + dx18)) ));
            																}
HXDLIN( 312)																int c51 = ::iterMagic::Iimg_obj::get(this509,index66);
HXDLIN( 312)																int col15;
HXDLIN( 312)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																	col15 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            																}
            																else {
HXLINE( 312)																	col15 = c51;
            																}
HXDLIN( 312)																bool _hx_tmp125;
HXDLIN( 312)																if (this506->useMask) {
HXLINE( 312)																	_hx_tmp125 = ::hx::IsNotNull( this506->mask );
            																}
            																else {
HXLINE( 312)																	_hx_tmp125 = false;
            																}
HXDLIN( 312)																if (_hx_tmp125) {
HXLINE( 312)																	 ::pi_xy::ImageStruct this510 = this506->mask;
HXDLIN( 312)																	::Dynamic this511 = this510->image;
HXDLIN( 312)																	int index67;
HXDLIN( 312)																	if (this510->useVirtualPos) {
HXLINE( 312)																		index67 = ::Std_obj::_hx_int(((((( (Float)(dy18) ) - this510->virtualY) * ( (Float)(this510->width) )) + dx18) - this510->virtualX));
            																	}
            																	else {
HXLINE( 312)																		index67 = ::Std_obj::_hx_int(( (Float)(((dy18 * this510->width) + dx18)) ));
            																	}
HXDLIN( 312)																	int c52 = ::iterMagic::Iimg_obj::get(this511,index67);
HXDLIN( 312)																	int v52;
HXDLIN( 312)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																		v52 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            																	}
            																	else {
HXLINE( 312)																		v52 = c52;
            																	}
HXDLIN( 312)																	int maskPixel15 = v52;
HXDLIN( 312)																	int this512 = col15;
HXDLIN( 312)																	if ((maskPixel15 == 0)) {
HXLINE( 312)																		col15 = this512;
            																	}
            																	else {
HXLINE( 312)																		Float m015;
HXDLIN( 312)																		int this513 = ((maskPixel15 >> 24) & 255);
HXDLIN( 312)																		if ((this513 == 0)) {
HXLINE( 312)																			m015 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m015 = (( (Float)(this513) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m115;
HXDLIN( 312)																		int this514 = ((maskPixel15 >> 16) & 255);
HXDLIN( 312)																		if ((this514 == 0)) {
HXLINE( 312)																			m115 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m115 = (( (Float)(this514) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m215;
HXDLIN( 312)																		int this515 = ((maskPixel15 >> 8) & 255);
HXDLIN( 312)																		if ((this515 == 0)) {
HXLINE( 312)																			m215 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m215 = (( (Float)(this515) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m315;
HXDLIN( 312)																		int this516 = (maskPixel15 & 255);
HXDLIN( 312)																		if ((this516 == 0)) {
HXLINE( 312)																			m315 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m315 = (( (Float)(this516) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		int ch015 = ::Std_obj::_hx_int(((((Float)1.) - m015) * ( (Float)(((this512 >> 24) & 255)) )));
HXDLIN( 312)																		int ch115 = ::Std_obj::_hx_int(((((Float)1.) - m115) * ( (Float)(((this512 >> 16) & 255)) )));
HXDLIN( 312)																		int ch215 = ::Std_obj::_hx_int(((((Float)1.) - m215) * ( (Float)(((this512 >> 8) & 255)) )));
HXDLIN( 312)																		int ch315 = ::Std_obj::_hx_int(((((Float)1.) - m315) * ( (Float)((this512 & 255)) )));
HXDLIN( 312)																		col15 = ((((::Math_obj::round((( (Float)(ch015) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch115) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch215) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch315) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 312)																if ((col15 != 0)) {
HXLINE( 312)																	int x57 = (dx18 - rectLeft15);
HXDLIN( 312)																	int y57 = (dy18 - rectTop15);
HXDLIN( 312)																	int c53 = col15;
HXDLIN( 312)																	bool _hx_tmp126;
HXDLIN( 312)																	if ((((c53 >> 24) & 255) < 254)) {
HXLINE( 312)																		_hx_tmp126 = undoImage45->transparent;
            																	}
            																	else {
HXLINE( 312)																		_hx_tmp126 = false;
            																	}
HXDLIN( 312)																	if (_hx_tmp126) {
HXLINE( 312)																		int location31;
HXDLIN( 312)																		if (undoImage45->useVirtualPos) {
HXLINE( 312)																			location31 = ::Std_obj::_hx_int(((((( (Float)(y57) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x57) - undoImage45->virtualX));
            																		}
            																		else {
HXLINE( 312)																			location31 = ::Std_obj::_hx_int(( (Float)(((y57 * undoImage45->width) + x57)) ));
            																		}
HXDLIN( 312)																		int this517 = ::iterMagic::Iimg_obj::get(undoImage45->image,location31);
HXDLIN( 312)																		int this518;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			this518 = ((((((this517 >> 24) & 255) << 24) | ((this517 & 255) << 16)) | (((this517 >> 8) & 255) << 8)) | ((this517 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			this518 = this517;
            																		}
HXDLIN( 312)																		Float a135;
HXDLIN( 312)																		int this519 = ((this518 >> 24) & 255);
HXDLIN( 312)																		if ((this519 == 0)) {
HXLINE( 312)																			a135 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a135 = (( (Float)(this519) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r132;
HXDLIN( 312)																		int this520 = ((this518 >> 16) & 255);
HXDLIN( 312)																		if ((this520 == 0)) {
HXLINE( 312)																			r132 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r132 = (( (Float)(this520) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g132;
HXDLIN( 312)																		int this521 = ((this518 >> 8) & 255);
HXDLIN( 312)																		if ((this521 == 0)) {
HXLINE( 312)																			g132 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g132 = (( (Float)(this521) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b137;
HXDLIN( 312)																		int this522 = (this518 & 255);
HXDLIN( 312)																		if ((this522 == 0)) {
HXLINE( 312)																			b137 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b137 = (( (Float)(this522) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a233;
HXDLIN( 312)																		int this523 = ((col15 >> 24) & 255);
HXDLIN( 312)																		if ((this523 == 0)) {
HXLINE( 312)																			a233 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a233 = (( (Float)(this523) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r232;
HXDLIN( 312)																		int this524 = ((col15 >> 16) & 255);
HXDLIN( 312)																		if ((this524 == 0)) {
HXLINE( 312)																			r232 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r232 = (( (Float)(this524) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g232;
HXDLIN( 312)																		int this525 = ((col15 >> 8) & 255);
HXDLIN( 312)																		if ((this525 == 0)) {
HXLINE( 312)																			g232 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g232 = (( (Float)(this525) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b235;
HXDLIN( 312)																		int this526 = (col15 & 255);
HXDLIN( 312)																		if ((this526 == 0)) {
HXLINE( 312)																			b235 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b235 = (( (Float)(this526) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a332 = (a135 * (( (Float)(1) ) - a233));
HXDLIN( 312)																		int r59 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r132 * a332) + (r232 * a233))));
HXDLIN( 312)																		int g59 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g132 * a332) + (g232 * a233))));
HXDLIN( 312)																		int b102 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b137 * a332) + (b235 * a233))));
HXDLIN( 312)																		int a81 = ::Std_obj::_hx_int((( (Float)(255) ) * (a332 + a233)));
HXDLIN( 312)																		int blended31 = ((((a81 << 24) | (r59 << 16)) | (g59 << 8)) | b102);
HXDLIN( 312)																		{
HXLINE( 312)																			int _hx_tmp127;
HXDLIN( 312)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																				_hx_tmp127 = ((((((blended31 >> 24) & 255) << 24) | ((blended31 & 255) << 16)) | (((blended31 >> 8) & 255) << 8)) | ((blended31 >> 16) & 255));
            																			}
            																			else {
HXLINE( 312)																				_hx_tmp127 = blended31;
            																			}
HXDLIN( 312)																			::iterMagic::Iimg_obj::set(undoImage45->image,location31,_hx_tmp127);
            																		}
            																	}
            																	else {
HXLINE( 312)																		::Dynamic this527 = undoImage45->image;
HXDLIN( 312)																		int index68;
HXDLIN( 312)																		if (undoImage45->useVirtualPos) {
HXLINE( 312)																			index68 = ::Std_obj::_hx_int(((((( (Float)(y57) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x57) - undoImage45->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index68 = ::Std_obj::_hx_int(( (Float)(((y57 * undoImage45->width) + x57)) ));
            																		}
HXDLIN( 312)																		int _hx_tmp128;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			_hx_tmp128 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			_hx_tmp128 = c53;
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this527,index68,_hx_tmp128);
            																	}
            																}
            																else {
HXLINE( 312)																	if (forceClear15) {
HXLINE( 312)																		::Dynamic this528 = undoImage45->image;
HXDLIN( 312)																		int x58 = (dx18 - rectLeft15);
HXDLIN( 312)																		int y58 = (dy18 - rectTop15);
HXDLIN( 312)																		int index69;
HXDLIN( 312)																		if (undoImage45->useVirtualPos) {
HXLINE( 312)																			index69 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x58) - undoImage45->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index69 = ::Std_obj::_hx_int(( (Float)(((y58 * undoImage45->width) + x58)) ));
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this528,index69,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 312)										bool found5 = false;
HXDLIN( 312)										Float s5 = ((Float)0.);
HXDLIN( 312)										Float t5 = ((Float)0.);
HXDLIN( 312)										Float sxx5 = ((Float)0.);
HXDLIN( 312)										Float txx5 = ((Float)0.);
HXDLIN( 312)										{
HXLINE( 312)											int _g_min30 = xIter315->start;
HXDLIN( 312)											int _g_max30 = xIter315->max;
HXDLIN( 312)											while((_g_min30 < _g_max30)){
HXLINE( 312)												_g_min30 = (_g_min30 + 1);
HXDLIN( 312)												int x59 = (_g_min30 - 1);
HXLINE(  60)												sxx5 = (sx5 * ( (Float)(x59) ));
HXLINE(  61)												txx5 = (tx5 * ( (Float)(x59) ));
HXLINE(  62)												found5 = false;
HXLINE( 312)												{
HXLINE( 312)													int _g_min31 = yIter315->start;
HXDLIN( 312)													int _g_max31 = yIter315->max;
HXDLIN( 312)													while((_g_min31 < _g_max31)){
HXLINE( 312)														_g_min31 = (_g_min31 + 1);
HXDLIN( 312)														int y59 = (_g_min31 - 1);
HXLINE(  64)														s5 = ((s05 + sxx5) + (sy5 * ( (Float)(y59) )));
HXLINE(  65)														t5 = ((t05 + txx5) + (ty5 * ( (Float)(y59) )));
HXLINE( 312)														bool _hx_tmp129;
HXDLIN( 312)														if (!((s5 <= 0))) {
HXLINE( 312)															_hx_tmp129 = (t5 <= 0);
            														}
            														else {
HXLINE( 312)															_hx_tmp129 = true;
            														}
HXDLIN( 312)														if (_hx_tmp129) {
HXLINE( 312)															if (found5) {
HXLINE( 312)																goto _hx_goto_879;
            															}
            														}
            														else {
HXLINE( 312)															if (((s5 + t5) < A5)) {
HXLINE( 312)																{
HXLINE( 312)																	int c54 = 0;
HXDLIN( 312)																	bool _hx_tmp130;
HXDLIN( 312)																	if ((((c54 >> 24) & 255) < 254)) {
HXLINE( 312)																		_hx_tmp130 = this506->transparent;
            																	}
            																	else {
HXLINE( 312)																		_hx_tmp130 = false;
            																	}
HXDLIN( 312)																	if (_hx_tmp130) {
HXLINE( 312)																		int location32;
HXDLIN( 312)																		if (this506->useVirtualPos) {
HXLINE( 312)																			location32 = ::Std_obj::_hx_int(((((( (Float)(y59) ) - this506->virtualY) * ( (Float)(this506->width) )) + x59) - this506->virtualX));
            																		}
            																		else {
HXLINE( 312)																			location32 = ::Std_obj::_hx_int(( (Float)(((y59 * this506->width) + x59)) ));
            																		}
HXDLIN( 312)																		int this529 = ::iterMagic::Iimg_obj::get(this506->image,location32);
HXDLIN( 312)																		int this530;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			this530 = ((((((this529 >> 24) & 255) << 24) | ((this529 & 255) << 16)) | (((this529 >> 8) & 255) << 8)) | ((this529 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			this530 = this529;
            																		}
HXDLIN( 312)																		Float a136;
HXDLIN( 312)																		int this531 = ((this530 >> 24) & 255);
HXDLIN( 312)																		if ((this531 == 0)) {
HXLINE( 312)																			a136 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a136 = (( (Float)(this531) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r133;
HXDLIN( 312)																		int this532 = ((this530 >> 16) & 255);
HXDLIN( 312)																		if ((this532 == 0)) {
HXLINE( 312)																			r133 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r133 = (( (Float)(this532) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g133;
HXDLIN( 312)																		int this533 = ((this530 >> 8) & 255);
HXDLIN( 312)																		if ((this533 == 0)) {
HXLINE( 312)																			g133 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g133 = (( (Float)(this533) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b138;
HXDLIN( 312)																		int this534 = (this530 & 255);
HXDLIN( 312)																		if ((this534 == 0)) {
HXLINE( 312)																			b138 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b138 = (( (Float)(this534) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a234;
HXDLIN( 312)																		int this535 = ((0 >> 24) & 255);
HXDLIN( 312)																		if ((this535 == 0)) {
HXLINE( 312)																			a234 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a234 = (( (Float)(this535) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r233;
HXDLIN( 312)																		int this536 = ((0 >> 16) & 255);
HXDLIN( 312)																		if ((this536 == 0)) {
HXLINE( 312)																			r233 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r233 = (( (Float)(this536) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g233;
HXDLIN( 312)																		int this537 = ((0 >> 8) & 255);
HXDLIN( 312)																		if ((this537 == 0)) {
HXLINE( 312)																			g233 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g233 = (( (Float)(this537) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b236;
HXDLIN( 312)																		int this538 = (0 & 255);
HXDLIN( 312)																		if ((this538 == 0)) {
HXLINE( 312)																			b236 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b236 = (( (Float)(this538) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a333 = (a136 * (( (Float)(1) ) - a234));
HXDLIN( 312)																		int r60 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r133 * a333) + (r233 * a234))));
HXDLIN( 312)																		int g60 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g133 * a333) + (g233 * a234))));
HXDLIN( 312)																		int b103 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b138 * a333) + (b236 * a234))));
HXDLIN( 312)																		int a82 = ::Std_obj::_hx_int((( (Float)(255) ) * (a333 + a234)));
HXDLIN( 312)																		int blended32 = ((((a82 << 24) | (r60 << 16)) | (g60 << 8)) | b103);
HXDLIN( 312)																		{
HXLINE( 312)																			int _hx_tmp131;
HXDLIN( 312)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																				_hx_tmp131 = ((((((blended32 >> 24) & 255) << 24) | ((blended32 & 255) << 16)) | (((blended32 >> 8) & 255) << 8)) | ((blended32 >> 16) & 255));
            																			}
            																			else {
HXLINE( 312)																				_hx_tmp131 = blended32;
            																			}
HXDLIN( 312)																			::iterMagic::Iimg_obj::set(this506->image,location32,_hx_tmp131);
            																		}
            																	}
            																	else {
HXLINE( 312)																		::Dynamic this539 = this506->image;
HXDLIN( 312)																		int index70;
HXDLIN( 312)																		if (this506->useVirtualPos) {
HXLINE( 312)																			index70 = ::Std_obj::_hx_int(((((( (Float)(y59) ) - this506->virtualY) * ( (Float)(this506->width) )) + x59) - this506->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index70 = ::Std_obj::_hx_int(( (Float)(((y59 * this506->width) + x59)) ));
            																		}
HXDLIN( 312)																		int _hx_tmp132;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			_hx_tmp132 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			_hx_tmp132 = c54;
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this539,index70,_hx_tmp132);
            																	}
            																}
HXLINE(  73)																found5 = true;
            															}
            															else {
HXLINE( 312)																if (found5) {
HXLINE( 312)																	goto _hx_goto_879;
            																}
            															}
            														}
            													}
            													_hx_goto_879:;
            												}
            											}
            										}
HXDLIN( 312)										if ((hasHit15 == true)) {
HXLINE( 312)											 ::pi_xy::algo::HitTri v53 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX1,cy13,bx10,by5,cx8,cy14,true);
HXDLIN( 312)											if (hasUndo15) {
HXLINE( 312)												v53->undoImage = undoImage45;
HXDLIN( 312)												v53->undoX = xIter315->start;
HXDLIN( 312)												v53->undoY = yIter315->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX5 = nextX5;
HXLINE(  47)							lastY5 = nextY5;
            						}
            					}
            				}
            			}
HXLINE( 312)			{
HXLINE( 312)				int r_x1 = ::Std_obj::_hx_int(thick);
HXDLIN( 312)				int r_y1 = ::Std_obj::_hx_int((thick + dy16));
HXDLIN( 312)				int r_w1 = ::Std_obj::_hx_int(wid1);
HXDLIN( 312)				int r_h1 = ::Std_obj::_hx_int(( (Float)(tall2) ));
HXDLIN( 312)				int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN( 312)				int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN( 312)				int ii_min127 = r_x1;
HXDLIN( 312)				int ii_max127 = xmax1;
HXDLIN( 312)				int xRange__start1 = ii_min127;
HXDLIN( 312)				int xRange__max1 = ii_max127;
HXDLIN( 312)				int ii_min128 = r_y1;
HXDLIN( 312)				int ii_max128 = ymax1;
HXDLIN( 312)				int yRange__start1 = ii_min128;
HXDLIN( 312)				int yRange__max1 = ii_max128;
HXDLIN( 312)				int range_x1 = xRange__start1;
HXDLIN( 312)				int range_y1 = (yRange__start1 - 1);
HXDLIN( 312)				int range_xReset1 = range_x1;
HXDLIN( 312)				int range_yReset1 = range_y1;
HXDLIN( 312)				int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 312)				int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 312)				int _this_min1 = 0;
HXDLIN( 312)				int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 312)				while((_this_min1 < _this_max1)){
HXLINE( 312)					_this_min1 = (_this_min1 + 1);
HXDLIN( 312)					int i150 = (_this_min1 - 1);
HXDLIN( 312)					if ((range_y1 > range_yMax1)) {
HXLINE( 312)						range_y1 = range_yReset1;
HXDLIN( 312)						range_x1 = (range_x1 + 1);
            					}
HXDLIN( 312)					range_y1 = (range_y1 + 1);
HXDLIN( 312)					int i151 = i150;
HXDLIN( 312)					{
HXLINE( 312)						int x60 = range_x1;
HXDLIN( 312)						int y60 = range_y1;
HXDLIN( 312)						int c55 = 0;
HXDLIN( 312)						bool _hx_tmp133;
HXDLIN( 312)						if ((((c55 >> 24) & 255) < 254)) {
HXLINE( 312)							_hx_tmp133 = temp->transparent;
            						}
            						else {
HXLINE( 312)							_hx_tmp133 = false;
            						}
HXDLIN( 312)						if (_hx_tmp133) {
HXLINE( 312)							int location33;
HXDLIN( 312)							if (temp->useVirtualPos) {
HXLINE( 312)								location33 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - temp->virtualY) * ( (Float)(temp->width) )) + x60) - temp->virtualX));
            							}
            							else {
HXLINE( 312)								location33 = ::Std_obj::_hx_int(( (Float)(((y60 * temp->width) + x60)) ));
            							}
HXDLIN( 312)							int this540 = ::iterMagic::Iimg_obj::get(temp->image,location33);
HXDLIN( 312)							int this541;
HXDLIN( 312)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)								this541 = ((((((this540 >> 24) & 255) << 24) | ((this540 & 255) << 16)) | (((this540 >> 8) & 255) << 8)) | ((this540 >> 16) & 255));
            							}
            							else {
HXLINE( 312)								this541 = this540;
            							}
HXDLIN( 312)							Float a137;
HXDLIN( 312)							int this542 = ((this541 >> 24) & 255);
HXDLIN( 312)							if ((this542 == 0)) {
HXLINE( 312)								a137 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								a137 = (( (Float)(this542) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float r134;
HXDLIN( 312)							int this543 = ((this541 >> 16) & 255);
HXDLIN( 312)							if ((this543 == 0)) {
HXLINE( 312)								r134 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								r134 = (( (Float)(this543) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float g134;
HXDLIN( 312)							int this544 = ((this541 >> 8) & 255);
HXDLIN( 312)							if ((this544 == 0)) {
HXLINE( 312)								g134 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								g134 = (( (Float)(this544) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float b139;
HXDLIN( 312)							int this545 = (this541 & 255);
HXDLIN( 312)							if ((this545 == 0)) {
HXLINE( 312)								b139 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								b139 = (( (Float)(this545) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float a235;
HXDLIN( 312)							int this546 = ((0 >> 24) & 255);
HXDLIN( 312)							if ((this546 == 0)) {
HXLINE( 312)								a235 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								a235 = (( (Float)(this546) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float r234;
HXDLIN( 312)							int this547 = ((0 >> 16) & 255);
HXDLIN( 312)							if ((this547 == 0)) {
HXLINE( 312)								r234 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								r234 = (( (Float)(this547) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float g234;
HXDLIN( 312)							int this548 = ((0 >> 8) & 255);
HXDLIN( 312)							if ((this548 == 0)) {
HXLINE( 312)								g234 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								g234 = (( (Float)(this548) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float b237;
HXDLIN( 312)							int this549 = (0 & 255);
HXDLIN( 312)							if ((this549 == 0)) {
HXLINE( 312)								b237 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								b237 = (( (Float)(this549) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float a334 = (a137 * (( (Float)(1) ) - a235));
HXDLIN( 312)							int r61 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r134 * a334) + (r234 * a235))));
HXDLIN( 312)							int g61 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g134 * a334) + (g234 * a235))));
HXDLIN( 312)							int b104 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b139 * a334) + (b237 * a235))));
HXDLIN( 312)							int a83 = ::Std_obj::_hx_int((( (Float)(255) ) * (a334 + a235)));
HXDLIN( 312)							int blended33 = ((((a83 << 24) | (r61 << 16)) | (g61 << 8)) | b104);
HXDLIN( 312)							{
HXLINE( 312)								int _hx_tmp134;
HXDLIN( 312)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)									_hx_tmp134 = ((((((blended33 >> 24) & 255) << 24) | ((blended33 & 255) << 16)) | (((blended33 >> 8) & 255) << 8)) | ((blended33 >> 16) & 255));
            								}
            								else {
HXLINE( 312)									_hx_tmp134 = blended33;
            								}
HXDLIN( 312)								::iterMagic::Iimg_obj::set(temp->image,location33,_hx_tmp134);
            							}
            						}
            						else {
HXLINE( 312)							::Dynamic this550 = temp->image;
HXDLIN( 312)							int index71;
HXDLIN( 312)							if (temp->useVirtualPos) {
HXLINE( 312)								index71 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - temp->virtualY) * ( (Float)(temp->width) )) + x60) - temp->virtualX));
            							}
            							else {
HXLINE( 312)								index71 = ::Std_obj::_hx_int(( (Float)(((y60 * temp->width) + x60)) ));
            							}
HXDLIN( 312)							int _hx_tmp135;
HXDLIN( 312)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)								_hx_tmp135 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            							}
            							else {
HXLINE( 312)								_hx_tmp135 = c55;
            							}
HXDLIN( 312)							::iterMagic::Iimg_obj::set(this550,index71,_hx_tmp135);
            						}
            					}
            				}
            			}
HXDLIN( 312)			{
HXLINE( 312)				 ::pi_xy::ImageStruct this551 = temp;
HXDLIN( 312)				Float cx9 = (thick + dx16);
HXDLIN( 312)				Float rx3 = ( (Float)(dx16) );
HXDLIN( 312)				{
HXLINE( 312)					 ::Dynamic targetError6 = ((Float)1.05);
HXDLIN( 312)					if (::hx::IsNull( targetError6 )) {
HXLINE( 113)						targetError6 = ((Float)1.05);
            					}
HXLINE( 312)					Float rSmall6;
HXDLIN( 312)					if ((rx3 > bottomRadius1)) {
HXLINE( 312)						rSmall6 = bottomRadius1;
            					}
            					else {
HXLINE( 312)						rSmall6 = rx3;
            					}
HXDLIN( 312)					 ::Dynamic targetE6 = ( (Float)(targetError6) );
HXDLIN( 312)					if (::hx::IsNull( targetE6 )) {
HXLINE(  20)						targetE6 = ((Float)1.05);
            					}
HXLINE( 312)					int result6 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE6) ) / rSmall6)))));
HXDLIN( 312)					int noSides6;
HXDLIN( 312)					if ((result6 < 12)) {
HXLINE( 312)						noSides6 = 12;
            					}
            					else {
HXLINE( 312)						if ((result6 > 500)) {
HXLINE( 312)							noSides6 = 500;
            						}
            						else {
HXLINE( 312)							noSides6 = result6;
            						}
            					}
HXDLIN( 312)					int sides6 = (::Math_obj::ceil((( (Float)(noSides6) ) / ( (Float)(4) ))) * 4);
HXDLIN( 312)					Float theta6 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides6) ));
HXDLIN( 312)					Float omega6 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 312)					int quarter6 = ::Std_obj::_hx_int((( (Float)(sides6) ) / ( (Float)(4) )));
HXDLIN( 312)					Float lastX6 = ((Float)0.);
HXDLIN( 312)					Float lastY6 = ((Float)0.);
HXDLIN( 312)					{
HXLINE(  26)						lastX6 = (cx9 + (rx3 * ::Math_obj::cos(((( (Float)(sides6) ) * theta6) + omega6))));
HXLINE(  27)						lastY6 = (lowerY1 + (bottomRadius1 * ::Math_obj::sin(((( (Float)(sides6) ) * theta6) + omega6))));
            					}
HXLINE( 312)					{
HXLINE( 312)						int _g348 = 0;
HXDLIN( 312)						int _g349 = (quarter6 + 1);
HXDLIN( 312)						while((_g348 < _g349)){
HXLINE( 312)							_g348 = (_g348 + 1);
HXDLIN( 312)							int i152 = (_g348 - 1);
HXDLIN( 312)							Float nextX6 = (cx9 + (rx3 * ::Math_obj::cos((((( (Float)(i152) ) * theta6) + ((Float)0.0001)) + omega6))));
HXDLIN( 312)							Float nextY6 = (lowerY1 + (bottomRadius1 * ::Math_obj::sin((((( (Float)(i152) ) * theta6) + ((Float)0.0001)) + omega6))));
HXDLIN( 312)							{
HXLINE( 312)								 ::pi_xy::ImageStruct this552 = this551;
HXDLIN( 312)								bool hasHit16 = false;
HXDLIN( 312)								bool hasUndo16 = false;
HXDLIN( 312)								{
HXLINE( 312)									Float bx11 = lastX6;
HXDLIN( 312)									Float by6 = lastY6;
HXDLIN( 312)									Float cx10 = nextX6;
HXDLIN( 312)									Float cy15 = nextY6;
HXDLIN( 312)									bool adjustWinding6 = (((((cx9 * by6) - (bx11 * lowerY1)) + ((bx11 * cy15) - (cx10 * by6))) + ((cx10 * lowerY1) - (cx9 * cy15))) > 0);
HXDLIN( 312)									if (!(adjustWinding6)) {
HXLINE( 312)										Float bx_6 = bx11;
HXDLIN( 312)										Float by_6 = by6;
HXLINE(  25)										bx11 = cx10;
HXLINE(  26)										by6 = cy15;
HXLINE(  27)										cx10 = bx_6;
HXLINE(  28)										cy15 = by_6;
            									}
HXLINE( 312)									{
HXLINE( 312)										Float s06 = ((lowerY1 * cx10) - (cx9 * cy15));
HXDLIN( 312)										Float sx6 = (cy15 - lowerY1);
HXDLIN( 312)										Float sy6 = (cx9 - cx10);
HXDLIN( 312)										Float t06 = ((cx9 * by6) - (lowerY1 * bx11));
HXDLIN( 312)										Float tx6 = (lowerY1 - by6);
HXDLIN( 312)										Float ty6 = (bx11 - cx9);
HXDLIN( 312)										Float A6 = ((((-(by6) * cx10) + (lowerY1 * (-(bx11) + cx10))) + (cx9 * (by6 - cy15))) + (bx11 * cy15));
HXDLIN( 312)										 ::pi_xy::iter::IntIterStart xIter316;
HXDLIN( 312)										if ((cx9 > bx11)) {
HXLINE( 312)											if ((cx9 > cx10)) {
HXLINE( 312)												int min61;
HXDLIN( 312)												if ((bx11 > cx10)) {
HXLINE( 312)													min61 = ::Math_obj::floor(cx10);
            												}
            												else {
HXLINE( 312)													min61 = ::Math_obj::floor(bx11);
            												}
HXDLIN( 312)												int ii_min129 = min61;
HXDLIN( 312)												int ii_max129 = ::Math_obj::ceil(cx9);
HXDLIN( 312)												xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min129,ii_max129);
            											}
            											else {
HXLINE( 312)												int ii_min130 = ::Math_obj::floor(bx11);
HXDLIN( 312)												int ii_max130 = ::Math_obj::ceil(cx10);
HXDLIN( 312)												xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min130,ii_max130);
            											}
            										}
            										else {
HXLINE( 312)											if ((bx11 > cx10)) {
HXLINE( 312)												int min62;
HXDLIN( 312)												if ((cx9 > cx10)) {
HXLINE( 312)													min62 = ::Math_obj::floor(cx10);
            												}
            												else {
HXLINE( 312)													min62 = ::Math_obj::ceil(cx9);
            												}
HXDLIN( 312)												int ii_min131 = min62;
HXDLIN( 312)												int ii_max131 = ::Math_obj::ceil(bx11);
HXDLIN( 312)												xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min131,ii_max131);
            											}
            											else {
HXLINE( 312)												int ii_min132 = ::Math_obj::floor(cx9);
HXDLIN( 312)												int ii_max132 = ::Math_obj::ceil(cx10);
HXDLIN( 312)												xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min132,ii_max132);
            											}
            										}
HXDLIN( 312)										 ::pi_xy::iter::IntIterStart yIter316;
HXDLIN( 312)										if ((lowerY1 > by6)) {
HXLINE( 312)											if ((lowerY1 > cy15)) {
HXLINE( 312)												int min63;
HXDLIN( 312)												if ((by6 > cy15)) {
HXLINE( 312)													min63 = ::Math_obj::floor(cy15);
            												}
            												else {
HXLINE( 312)													min63 = ::Math_obj::floor(by6);
            												}
HXDLIN( 312)												int ii_min133 = min63;
HXDLIN( 312)												int ii_max133 = ::Math_obj::ceil(lowerY1);
HXDLIN( 312)												yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min133,ii_max133);
            											}
            											else {
HXLINE( 312)												int ii_min134 = ::Math_obj::floor(by6);
HXDLIN( 312)												int ii_max134 = ::Math_obj::ceil(cy15);
HXDLIN( 312)												yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min134,ii_max134);
            											}
            										}
            										else {
HXLINE( 312)											if ((by6 > cy15)) {
HXLINE( 312)												int min64;
HXDLIN( 312)												if ((lowerY1 > cy15)) {
HXLINE( 312)													min64 = ::Math_obj::floor(cy15);
            												}
            												else {
HXLINE( 312)													min64 = ::Math_obj::ceil(lowerY1);
            												}
HXDLIN( 312)												int ii_min135 = min64;
HXDLIN( 312)												int ii_max135 = ::Math_obj::ceil(by6);
HXDLIN( 312)												yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min135,ii_max135);
            											}
            											else {
HXLINE( 312)												int ii_min136 = ::Math_obj::floor(lowerY1);
HXDLIN( 312)												int ii_max136 = ::Math_obj::ceil(cy15);
HXDLIN( 312)												yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min136,ii_max136);
            											}
            										}
HXDLIN( 312)										 ::pi_xy::ImageStruct undoImage48 = null();
HXDLIN( 312)										if (hasUndo16) {
HXLINE( 312)											int width17 = ((xIter316->max - xIter316->start) + 1);
HXDLIN( 312)											int height17 = ((yIter316->max - yIter316->start) + 1);
HXDLIN( 312)											 ::Dynamic imageType17 = null();
HXDLIN( 312)											 ::pi_xy::ImageStruct this553 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 312)											if (::hx::IsNull( imageType17 )) {
HXLINE(  54)												imageType17 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 312)											::Dynamic undoImage49;
HXDLIN( 312)											switch((int)(( (int)(imageType17) ))){
            												case (int)0: {
HXLINE( 312)													 ::iterMagic::BytesImg byt17 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::BytesImg b105 = byt17;
HXDLIN( 312)													{
HXLINE( 312)														b105->width = width17;
HXDLIN( 312)														b105->height = height17;
HXDLIN( 312)														b105->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 312)														b105->data = ::haxe::io::Bytes_obj::alloc((b105->length * 4));
HXDLIN( 312)														{
HXLINE( 312)															int len34 = b105->length;
HXDLIN( 312)															int w17 = 0;
HXDLIN( 312)															{
HXLINE( 312)																int _g350 = 0;
HXDLIN( 312)																int _g351 = b105->height;
HXDLIN( 312)																while((_g350 < _g351)){
HXLINE( 312)																	_g350 = (_g350 + 1);
HXDLIN( 312)																	int y61 = (_g350 - 1);
HXDLIN( 312)																	{
HXLINE( 312)																		int _g352 = 0;
HXDLIN( 312)																		int _g353 = b105->width;
HXDLIN( 312)																		while((_g352 < _g353)){
HXLINE( 312)																			_g352 = (_g352 + 1);
HXDLIN( 312)																			int x61 = (_g352 - 1);
HXDLIN( 312)																			{
HXLINE( 312)																				w17 = (w17 + 1);
HXDLIN( 312)																				b105->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w17 = (w17 + 1);
HXDLIN( 312)																				b105->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w17 = (w17 + 1);
HXDLIN( 312)																				b105->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w17 = (w17 + 1);
HXDLIN( 312)																				b105->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage49 = b105;
            												}
            												break;
            												case (int)1: {
HXLINE( 312)													 ::iterMagic::ArrIntImg arrI17 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::ArrIntImg a84 = arrI17;
HXDLIN( 312)													{
HXLINE( 312)														a84->width = width17;
HXDLIN( 312)														a84->height = height17;
HXDLIN( 312)														a84->data = ::Array_obj< int >::__new(0);
HXDLIN( 312)														a84->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 312)														{
HXLINE( 312)															int _g354 = 0;
HXDLIN( 312)															int _g355 = a84->length;
HXDLIN( 312)															while((_g354 < _g355)){
HXLINE( 312)																_g354 = (_g354 + 1);
HXDLIN( 312)																int i153 = (_g354 - 1);
HXDLIN( 312)																a84->data[i153] = 0;
            															}
            														}
            													}
HXDLIN( 312)													undoImage49 = a84;
            												}
            												break;
            												case (int)2: {
HXLINE( 312)													 ::iterMagic::U32ArrImg u32a17 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::U32ArrImg b106 = u32a17;
HXDLIN( 312)													{
HXLINE( 312)														b106->width = width17;
HXDLIN( 312)														b106->height = height17;
HXDLIN( 312)														b106->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 312)														int size17 = (b106->length * 4);
HXDLIN( 312)														b106->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size17),0,size17);
HXDLIN( 312)														{
HXLINE( 312)															int _g356 = 0;
HXDLIN( 312)															int _g357 = b106->length;
HXDLIN( 312)															while((_g356 < _g357)){
HXLINE( 312)																_g356 = (_g356 + 1);
HXDLIN( 312)																int i154 = (_g356 - 1);
HXDLIN( 312)																{
HXLINE( 312)																	 ::haxe::io::ArrayBufferViewImpl this554 = b106->data;
HXDLIN( 312)																	bool undoImage50;
HXDLIN( 312)																	if ((i154 >= 0)) {
HXLINE( 312)																		undoImage50 = (i154 < (this554->byteLength >> 2));
            																	}
            																	else {
HXLINE( 312)																		undoImage50 = false;
            																	}
HXDLIN( 312)																	if (undoImage50) {
HXLINE( 312)																		 ::haxe::io::Bytes _this17 = this554->bytes;
HXDLIN( 312)																		int pos17 = ((i154 << 2) + this554->byteOffset);
HXDLIN( 312)																		_this17->b[pos17] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this17->b[(pos17 + 1)] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this17->b[(pos17 + 2)] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this17->b[(pos17 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage49 = b106;
            												}
            												break;
            												case (int)3: {
HXLINE( 312)													 ::iterMagic::VecIntImg vec17 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::VecIntImg v54 = vec17;
HXDLIN( 312)													{
HXLINE( 312)														v54->width = width17;
HXDLIN( 312)														v54->height = height17;
HXDLIN( 312)														v54->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 312)														v54->data = ::Array_obj< int >::__new(v54->length);
HXDLIN( 312)														{
HXLINE( 312)															int _g358 = 0;
HXDLIN( 312)															int _g359 = v54->length;
HXDLIN( 312)															while((_g358 < _g359)){
HXLINE( 312)																_g358 = (_g358 + 1);
HXDLIN( 312)																int i155 = (_g358 - 1);
HXDLIN( 312)																v54->data->__unsafe_set(i155,0);
            															}
            														}
            													}
HXDLIN( 312)													undoImage49 = v54;
            												}
            												break;
            												case (int)4: {
HXLINE( 312)													 ::iterMagic::StackIntImg sInt17 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::StackIntImg b107 = sInt17;
HXDLIN( 312)													{
HXLINE( 312)														b107->width = width17;
HXDLIN( 312)														b107->height = height17;
HXDLIN( 312)														b107->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 312)														b107->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 312)														{
HXLINE( 312)															int len35 = b107->length;
HXDLIN( 312)															 ::haxe::ds::GenericStack_Int d17 = b107->data;
HXDLIN( 312)															if (::hx::IsNull( d17->head )) {
HXLINE( 312)																int _g360 = 0;
HXDLIN( 312)																int _g361 = len35;
HXDLIN( 312)																while((_g360 < _g361)){
HXLINE( 312)																	_g360 = (_g360 + 1);
HXDLIN( 312)																	int i156 = (_g360 - 1);
HXDLIN( 312)																	d17->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d17->head);
            																}
            															}
            															else {
HXLINE( 312)																int _g362 = 0;
HXDLIN( 312)																int _g363 = len35;
HXDLIN( 312)																while((_g362 < _g363)){
HXLINE( 312)																	_g362 = (_g362 + 1);
HXDLIN( 312)																	int i157 = (_g362 - 1);
HXDLIN( 312)																	{
HXLINE( 312)																		 ::haxe::ds::GenericCell_Int l17 = b107->data->head;
HXDLIN( 312)																		 ::haxe::ds::GenericCell_Int prev17 = null();
HXDLIN( 312)																		{
HXLINE( 312)																			int _g364 = 0;
HXDLIN( 312)																			int _g365 = i157;
HXDLIN( 312)																			while((_g364 < _g365)){
HXLINE( 312)																				_g364 = (_g364 + 1);
HXDLIN( 312)																				int i158 = (_g364 - 1);
HXLINE( 345)																				prev17 = l17;
HXLINE( 346)																				l17 = l17->next;
            																			}
            																		}
HXLINE( 312)																		if (::hx::IsNull( prev17 )) {
HXLINE( 312)																			b107->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l17->next);
HXDLIN( 312)																			l17 = null();
            																		}
            																		else {
HXLINE( 312)																			prev17->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l17->next);
HXDLIN( 312)																			l17 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage49 = b107;
            												}
            												break;
            											}
HXDLIN( 312)											this553->image = undoImage49;
HXDLIN( 312)											this553->width = width17;
HXDLIN( 312)											this553->height = height17;
HXDLIN( 312)											this553->imageType = ( (int)(imageType17) );
HXDLIN( 312)											undoImage48 = this553;
HXDLIN( 312)											{
HXLINE( 312)												int rectLeft16 = xIter316->start;
HXDLIN( 312)												int rectTop16 = yIter316->start;
HXDLIN( 312)												int rectRight16 = xIter316->max;
HXDLIN( 312)												bool forceClear16 = false;
HXDLIN( 312)												{
HXLINE( 312)													int _g366 = rectTop16;
HXDLIN( 312)													int _g367 = yIter316->max;
HXDLIN( 312)													while((_g366 < _g367)){
HXLINE( 312)														_g366 = (_g366 + 1);
HXDLIN( 312)														int dy19 = (_g366 - 1);
HXDLIN( 312)														{
HXLINE( 312)															int _g368 = rectLeft16;
HXDLIN( 312)															int _g369 = rectRight16;
HXDLIN( 312)															while((_g368 < _g369)){
HXLINE( 312)																_g368 = (_g368 + 1);
HXDLIN( 312)																int dx19 = (_g368 - 1);
HXDLIN( 312)																::Dynamic this555 = this552->image;
HXDLIN( 312)																int index72;
HXDLIN( 312)																if (this552->useVirtualPos) {
HXLINE( 312)																	index72 = ::Std_obj::_hx_int(((((( (Float)(dy19) ) - this552->virtualY) * ( (Float)(this552->width) )) + dx19) - this552->virtualX));
            																}
            																else {
HXLINE( 312)																	index72 = ::Std_obj::_hx_int(( (Float)(((dy19 * this552->width) + dx19)) ));
            																}
HXDLIN( 312)																int c56 = ::iterMagic::Iimg_obj::get(this555,index72);
HXDLIN( 312)																int col16;
HXDLIN( 312)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																	col16 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            																}
            																else {
HXLINE( 312)																	col16 = c56;
            																}
HXDLIN( 312)																bool _hx_tmp136;
HXDLIN( 312)																if (this552->useMask) {
HXLINE( 312)																	_hx_tmp136 = ::hx::IsNotNull( this552->mask );
            																}
            																else {
HXLINE( 312)																	_hx_tmp136 = false;
            																}
HXDLIN( 312)																if (_hx_tmp136) {
HXLINE( 312)																	 ::pi_xy::ImageStruct this556 = this552->mask;
HXDLIN( 312)																	::Dynamic this557 = this556->image;
HXDLIN( 312)																	int index73;
HXDLIN( 312)																	if (this556->useVirtualPos) {
HXLINE( 312)																		index73 = ::Std_obj::_hx_int(((((( (Float)(dy19) ) - this556->virtualY) * ( (Float)(this556->width) )) + dx19) - this556->virtualX));
            																	}
            																	else {
HXLINE( 312)																		index73 = ::Std_obj::_hx_int(( (Float)(((dy19 * this556->width) + dx19)) ));
            																	}
HXDLIN( 312)																	int c57 = ::iterMagic::Iimg_obj::get(this557,index73);
HXDLIN( 312)																	int v55;
HXDLIN( 312)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																		v55 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            																	}
            																	else {
HXLINE( 312)																		v55 = c57;
            																	}
HXDLIN( 312)																	int maskPixel16 = v55;
HXDLIN( 312)																	int this558 = col16;
HXDLIN( 312)																	if ((maskPixel16 == 0)) {
HXLINE( 312)																		col16 = this558;
            																	}
            																	else {
HXLINE( 312)																		Float m016;
HXDLIN( 312)																		int this559 = ((maskPixel16 >> 24) & 255);
HXDLIN( 312)																		if ((this559 == 0)) {
HXLINE( 312)																			m016 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m016 = (( (Float)(this559) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m116;
HXDLIN( 312)																		int this560 = ((maskPixel16 >> 16) & 255);
HXDLIN( 312)																		if ((this560 == 0)) {
HXLINE( 312)																			m116 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m116 = (( (Float)(this560) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m216;
HXDLIN( 312)																		int this561 = ((maskPixel16 >> 8) & 255);
HXDLIN( 312)																		if ((this561 == 0)) {
HXLINE( 312)																			m216 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m216 = (( (Float)(this561) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m316;
HXDLIN( 312)																		int this562 = (maskPixel16 & 255);
HXDLIN( 312)																		if ((this562 == 0)) {
HXLINE( 312)																			m316 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m316 = (( (Float)(this562) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		int ch016 = ::Std_obj::_hx_int(((((Float)1.) - m016) * ( (Float)(((this558 >> 24) & 255)) )));
HXDLIN( 312)																		int ch116 = ::Std_obj::_hx_int(((((Float)1.) - m116) * ( (Float)(((this558 >> 16) & 255)) )));
HXDLIN( 312)																		int ch216 = ::Std_obj::_hx_int(((((Float)1.) - m216) * ( (Float)(((this558 >> 8) & 255)) )));
HXDLIN( 312)																		int ch316 = ::Std_obj::_hx_int(((((Float)1.) - m316) * ( (Float)((this558 & 255)) )));
HXDLIN( 312)																		col16 = ((((::Math_obj::round((( (Float)(ch016) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch116) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch216) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch316) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 312)																if ((col16 != 0)) {
HXLINE( 312)																	int x62 = (dx19 - rectLeft16);
HXDLIN( 312)																	int y62 = (dy19 - rectTop16);
HXDLIN( 312)																	int c58 = col16;
HXDLIN( 312)																	bool _hx_tmp137;
HXDLIN( 312)																	if ((((c58 >> 24) & 255) < 254)) {
HXLINE( 312)																		_hx_tmp137 = undoImage48->transparent;
            																	}
            																	else {
HXLINE( 312)																		_hx_tmp137 = false;
            																	}
HXDLIN( 312)																	if (_hx_tmp137) {
HXLINE( 312)																		int location34;
HXDLIN( 312)																		if (undoImage48->useVirtualPos) {
HXLINE( 312)																			location34 = ::Std_obj::_hx_int(((((( (Float)(y62) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x62) - undoImage48->virtualX));
            																		}
            																		else {
HXLINE( 312)																			location34 = ::Std_obj::_hx_int(( (Float)(((y62 * undoImage48->width) + x62)) ));
            																		}
HXDLIN( 312)																		int this563 = ::iterMagic::Iimg_obj::get(undoImage48->image,location34);
HXDLIN( 312)																		int this564;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			this564 = ((((((this563 >> 24) & 255) << 24) | ((this563 & 255) << 16)) | (((this563 >> 8) & 255) << 8)) | ((this563 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			this564 = this563;
            																		}
HXDLIN( 312)																		Float a138;
HXDLIN( 312)																		int this565 = ((this564 >> 24) & 255);
HXDLIN( 312)																		if ((this565 == 0)) {
HXLINE( 312)																			a138 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a138 = (( (Float)(this565) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r135;
HXDLIN( 312)																		int this566 = ((this564 >> 16) & 255);
HXDLIN( 312)																		if ((this566 == 0)) {
HXLINE( 312)																			r135 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r135 = (( (Float)(this566) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g135;
HXDLIN( 312)																		int this567 = ((this564 >> 8) & 255);
HXDLIN( 312)																		if ((this567 == 0)) {
HXLINE( 312)																			g135 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g135 = (( (Float)(this567) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b140;
HXDLIN( 312)																		int this568 = (this564 & 255);
HXDLIN( 312)																		if ((this568 == 0)) {
HXLINE( 312)																			b140 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b140 = (( (Float)(this568) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a236;
HXDLIN( 312)																		int this569 = ((col16 >> 24) & 255);
HXDLIN( 312)																		if ((this569 == 0)) {
HXLINE( 312)																			a236 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a236 = (( (Float)(this569) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r235;
HXDLIN( 312)																		int this570 = ((col16 >> 16) & 255);
HXDLIN( 312)																		if ((this570 == 0)) {
HXLINE( 312)																			r235 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r235 = (( (Float)(this570) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g235;
HXDLIN( 312)																		int this571 = ((col16 >> 8) & 255);
HXDLIN( 312)																		if ((this571 == 0)) {
HXLINE( 312)																			g235 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g235 = (( (Float)(this571) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b238;
HXDLIN( 312)																		int this572 = (col16 & 255);
HXDLIN( 312)																		if ((this572 == 0)) {
HXLINE( 312)																			b238 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b238 = (( (Float)(this572) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a335 = (a138 * (( (Float)(1) ) - a236));
HXDLIN( 312)																		int r62 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r135 * a335) + (r235 * a236))));
HXDLIN( 312)																		int g62 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g135 * a335) + (g235 * a236))));
HXDLIN( 312)																		int b108 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b140 * a335) + (b238 * a236))));
HXDLIN( 312)																		int a85 = ::Std_obj::_hx_int((( (Float)(255) ) * (a335 + a236)));
HXDLIN( 312)																		int blended34 = ((((a85 << 24) | (r62 << 16)) | (g62 << 8)) | b108);
HXDLIN( 312)																		{
HXLINE( 312)																			int _hx_tmp138;
HXDLIN( 312)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																				_hx_tmp138 = ((((((blended34 >> 24) & 255) << 24) | ((blended34 & 255) << 16)) | (((blended34 >> 8) & 255) << 8)) | ((blended34 >> 16) & 255));
            																			}
            																			else {
HXLINE( 312)																				_hx_tmp138 = blended34;
            																			}
HXDLIN( 312)																			::iterMagic::Iimg_obj::set(undoImage48->image,location34,_hx_tmp138);
            																		}
            																	}
            																	else {
HXLINE( 312)																		::Dynamic this573 = undoImage48->image;
HXDLIN( 312)																		int index74;
HXDLIN( 312)																		if (undoImage48->useVirtualPos) {
HXLINE( 312)																			index74 = ::Std_obj::_hx_int(((((( (Float)(y62) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x62) - undoImage48->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index74 = ::Std_obj::_hx_int(( (Float)(((y62 * undoImage48->width) + x62)) ));
            																		}
HXDLIN( 312)																		int _hx_tmp139;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			_hx_tmp139 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			_hx_tmp139 = c58;
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this573,index74,_hx_tmp139);
            																	}
            																}
            																else {
HXLINE( 312)																	if (forceClear16) {
HXLINE( 312)																		::Dynamic this574 = undoImage48->image;
HXDLIN( 312)																		int x63 = (dx19 - rectLeft16);
HXDLIN( 312)																		int y63 = (dy19 - rectTop16);
HXDLIN( 312)																		int index75;
HXDLIN( 312)																		if (undoImage48->useVirtualPos) {
HXLINE( 312)																			index75 = ::Std_obj::_hx_int(((((( (Float)(y63) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x63) - undoImage48->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index75 = ::Std_obj::_hx_int(( (Float)(((y63 * undoImage48->width) + x63)) ));
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this574,index75,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 312)										bool found6 = false;
HXDLIN( 312)										Float s6 = ((Float)0.);
HXDLIN( 312)										Float t6 = ((Float)0.);
HXDLIN( 312)										Float sxx6 = ((Float)0.);
HXDLIN( 312)										Float txx6 = ((Float)0.);
HXDLIN( 312)										{
HXLINE( 312)											int _g_min32 = xIter316->start;
HXDLIN( 312)											int _g_max32 = xIter316->max;
HXDLIN( 312)											while((_g_min32 < _g_max32)){
HXLINE( 312)												_g_min32 = (_g_min32 + 1);
HXDLIN( 312)												int x64 = (_g_min32 - 1);
HXLINE(  60)												sxx6 = (sx6 * ( (Float)(x64) ));
HXLINE(  61)												txx6 = (tx6 * ( (Float)(x64) ));
HXLINE(  62)												found6 = false;
HXLINE( 312)												{
HXLINE( 312)													int _g_min33 = yIter316->start;
HXDLIN( 312)													int _g_max33 = yIter316->max;
HXDLIN( 312)													while((_g_min33 < _g_max33)){
HXLINE( 312)														_g_min33 = (_g_min33 + 1);
HXDLIN( 312)														int y64 = (_g_min33 - 1);
HXLINE(  64)														s6 = ((s06 + sxx6) + (sy6 * ( (Float)(y64) )));
HXLINE(  65)														t6 = ((t06 + txx6) + (ty6 * ( (Float)(y64) )));
HXLINE( 312)														bool _hx_tmp140;
HXDLIN( 312)														if (!((s6 <= 0))) {
HXLINE( 312)															_hx_tmp140 = (t6 <= 0);
            														}
            														else {
HXLINE( 312)															_hx_tmp140 = true;
            														}
HXDLIN( 312)														if (_hx_tmp140) {
HXLINE( 312)															if (found6) {
HXLINE( 312)																goto _hx_goto_893;
            															}
            														}
            														else {
HXLINE( 312)															if (((s6 + t6) < A6)) {
HXLINE( 312)																{
HXLINE( 312)																	int c59 = 0;
HXDLIN( 312)																	bool _hx_tmp141;
HXDLIN( 312)																	if ((((c59 >> 24) & 255) < 254)) {
HXLINE( 312)																		_hx_tmp141 = this552->transparent;
            																	}
            																	else {
HXLINE( 312)																		_hx_tmp141 = false;
            																	}
HXDLIN( 312)																	if (_hx_tmp141) {
HXLINE( 312)																		int location35;
HXDLIN( 312)																		if (this552->useVirtualPos) {
HXLINE( 312)																			location35 = ::Std_obj::_hx_int(((((( (Float)(y64) ) - this552->virtualY) * ( (Float)(this552->width) )) + x64) - this552->virtualX));
            																		}
            																		else {
HXLINE( 312)																			location35 = ::Std_obj::_hx_int(( (Float)(((y64 * this552->width) + x64)) ));
            																		}
HXDLIN( 312)																		int this575 = ::iterMagic::Iimg_obj::get(this552->image,location35);
HXDLIN( 312)																		int this576;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			this576 = ((((((this575 >> 24) & 255) << 24) | ((this575 & 255) << 16)) | (((this575 >> 8) & 255) << 8)) | ((this575 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			this576 = this575;
            																		}
HXDLIN( 312)																		Float a139;
HXDLIN( 312)																		int this577 = ((this576 >> 24) & 255);
HXDLIN( 312)																		if ((this577 == 0)) {
HXLINE( 312)																			a139 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a139 = (( (Float)(this577) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r136;
HXDLIN( 312)																		int this578 = ((this576 >> 16) & 255);
HXDLIN( 312)																		if ((this578 == 0)) {
HXLINE( 312)																			r136 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r136 = (( (Float)(this578) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g136;
HXDLIN( 312)																		int this579 = ((this576 >> 8) & 255);
HXDLIN( 312)																		if ((this579 == 0)) {
HXLINE( 312)																			g136 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g136 = (( (Float)(this579) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b141;
HXDLIN( 312)																		int this580 = (this576 & 255);
HXDLIN( 312)																		if ((this580 == 0)) {
HXLINE( 312)																			b141 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b141 = (( (Float)(this580) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a237;
HXDLIN( 312)																		int this581 = ((0 >> 24) & 255);
HXDLIN( 312)																		if ((this581 == 0)) {
HXLINE( 312)																			a237 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a237 = (( (Float)(this581) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r236;
HXDLIN( 312)																		int this582 = ((0 >> 16) & 255);
HXDLIN( 312)																		if ((this582 == 0)) {
HXLINE( 312)																			r236 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r236 = (( (Float)(this582) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g236;
HXDLIN( 312)																		int this583 = ((0 >> 8) & 255);
HXDLIN( 312)																		if ((this583 == 0)) {
HXLINE( 312)																			g236 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g236 = (( (Float)(this583) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b239;
HXDLIN( 312)																		int this584 = (0 & 255);
HXDLIN( 312)																		if ((this584 == 0)) {
HXLINE( 312)																			b239 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b239 = (( (Float)(this584) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a336 = (a139 * (( (Float)(1) ) - a237));
HXDLIN( 312)																		int r63 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r136 * a336) + (r236 * a237))));
HXDLIN( 312)																		int g63 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g136 * a336) + (g236 * a237))));
HXDLIN( 312)																		int b109 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b141 * a336) + (b239 * a237))));
HXDLIN( 312)																		int a86 = ::Std_obj::_hx_int((( (Float)(255) ) * (a336 + a237)));
HXDLIN( 312)																		int blended35 = ((((a86 << 24) | (r63 << 16)) | (g63 << 8)) | b109);
HXDLIN( 312)																		{
HXLINE( 312)																			int _hx_tmp142;
HXDLIN( 312)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																				_hx_tmp142 = ((((((blended35 >> 24) & 255) << 24) | ((blended35 & 255) << 16)) | (((blended35 >> 8) & 255) << 8)) | ((blended35 >> 16) & 255));
            																			}
            																			else {
HXLINE( 312)																				_hx_tmp142 = blended35;
            																			}
HXDLIN( 312)																			::iterMagic::Iimg_obj::set(this552->image,location35,_hx_tmp142);
            																		}
            																	}
            																	else {
HXLINE( 312)																		::Dynamic this585 = this552->image;
HXDLIN( 312)																		int index76;
HXDLIN( 312)																		if (this552->useVirtualPos) {
HXLINE( 312)																			index76 = ::Std_obj::_hx_int(((((( (Float)(y64) ) - this552->virtualY) * ( (Float)(this552->width) )) + x64) - this552->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index76 = ::Std_obj::_hx_int(( (Float)(((y64 * this552->width) + x64)) ));
            																		}
HXDLIN( 312)																		int _hx_tmp143;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			_hx_tmp143 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			_hx_tmp143 = c59;
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this585,index76,_hx_tmp143);
            																	}
            																}
HXLINE(  73)																found6 = true;
            															}
            															else {
HXLINE( 312)																if (found6) {
HXLINE( 312)																	goto _hx_goto_893;
            																}
            															}
            														}
            													}
            													_hx_goto_893:;
            												}
            											}
            										}
HXDLIN( 312)										if ((hasHit16 == true)) {
HXLINE( 312)											 ::pi_xy::algo::HitTri v56 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx9,lowerY1,bx11,by6,cx10,cy15,true);
HXDLIN( 312)											if (hasUndo16) {
HXLINE( 312)												v56->undoImage = undoImage48;
HXDLIN( 312)												v56->undoX = xIter316->start;
HXDLIN( 312)												v56->undoY = yIter316->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX6 = nextX6;
HXLINE(  47)							lastY6 = nextY6;
            						}
            					}
            				}
            			}
HXLINE( 312)			{
HXLINE( 312)				int r_x2 = ::Std_obj::_hx_int((thick + dx16));
HXDLIN( 312)				int r_y2 = ::Std_obj::_hx_int(lowerY1);
HXDLIN( 312)				int r_w2 = ::Std_obj::_hx_int(( (Float)(fat2) ));
HXDLIN( 312)				int r_h2 = ::Std_obj::_hx_int(bottomRadius1);
HXDLIN( 312)				int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN( 312)				int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN( 312)				int ii_min137 = r_x2;
HXDLIN( 312)				int ii_max137 = xmax2;
HXDLIN( 312)				int xRange__start2 = ii_min137;
HXDLIN( 312)				int xRange__max2 = ii_max137;
HXDLIN( 312)				int ii_min138 = r_y2;
HXDLIN( 312)				int ii_max138 = ymax2;
HXDLIN( 312)				int yRange__start2 = ii_min138;
HXDLIN( 312)				int yRange__max2 = ii_max138;
HXDLIN( 312)				int range_x2 = xRange__start2;
HXDLIN( 312)				int range_y2 = (yRange__start2 - 1);
HXDLIN( 312)				int range_xReset2 = range_x2;
HXDLIN( 312)				int range_yReset2 = range_y2;
HXDLIN( 312)				int range_xMax2 = (xRange__max2 - 2);
HXDLIN( 312)				int range_yMax2 = (yRange__max2 - 2);
HXDLIN( 312)				int _this_min2 = 0;
HXDLIN( 312)				int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN( 312)				while((_this_min2 < _this_max2)){
HXLINE( 312)					_this_min2 = (_this_min2 + 1);
HXDLIN( 312)					int i159 = (_this_min2 - 1);
HXDLIN( 312)					if ((range_y2 > range_yMax2)) {
HXLINE( 312)						range_y2 = range_yReset2;
HXDLIN( 312)						range_x2 = (range_x2 + 1);
            					}
HXDLIN( 312)					range_y2 = (range_y2 + 1);
HXDLIN( 312)					int i160 = i159;
HXDLIN( 312)					{
HXLINE( 312)						int x65 = range_x2;
HXDLIN( 312)						int y65 = range_y2;
HXDLIN( 312)						int c60 = 0;
HXDLIN( 312)						bool _hx_tmp144;
HXDLIN( 312)						if ((((c60 >> 24) & 255) < 254)) {
HXLINE( 312)							_hx_tmp144 = temp->transparent;
            						}
            						else {
HXLINE( 312)							_hx_tmp144 = false;
            						}
HXDLIN( 312)						if (_hx_tmp144) {
HXLINE( 312)							int location36;
HXDLIN( 312)							if (temp->useVirtualPos) {
HXLINE( 312)								location36 = ::Std_obj::_hx_int(((((( (Float)(y65) ) - temp->virtualY) * ( (Float)(temp->width) )) + x65) - temp->virtualX));
            							}
            							else {
HXLINE( 312)								location36 = ::Std_obj::_hx_int(( (Float)(((y65 * temp->width) + x65)) ));
            							}
HXDLIN( 312)							int this586 = ::iterMagic::Iimg_obj::get(temp->image,location36);
HXDLIN( 312)							int this587;
HXDLIN( 312)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)								this587 = ((((((this586 >> 24) & 255) << 24) | ((this586 & 255) << 16)) | (((this586 >> 8) & 255) << 8)) | ((this586 >> 16) & 255));
            							}
            							else {
HXLINE( 312)								this587 = this586;
            							}
HXDLIN( 312)							Float a140;
HXDLIN( 312)							int this588 = ((this587 >> 24) & 255);
HXDLIN( 312)							if ((this588 == 0)) {
HXLINE( 312)								a140 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								a140 = (( (Float)(this588) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float r137;
HXDLIN( 312)							int this589 = ((this587 >> 16) & 255);
HXDLIN( 312)							if ((this589 == 0)) {
HXLINE( 312)								r137 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								r137 = (( (Float)(this589) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float g137;
HXDLIN( 312)							int this590 = ((this587 >> 8) & 255);
HXDLIN( 312)							if ((this590 == 0)) {
HXLINE( 312)								g137 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								g137 = (( (Float)(this590) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float b142;
HXDLIN( 312)							int this591 = (this587 & 255);
HXDLIN( 312)							if ((this591 == 0)) {
HXLINE( 312)								b142 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								b142 = (( (Float)(this591) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float a238;
HXDLIN( 312)							int this592 = ((0 >> 24) & 255);
HXDLIN( 312)							if ((this592 == 0)) {
HXLINE( 312)								a238 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								a238 = (( (Float)(this592) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float r237;
HXDLIN( 312)							int this593 = ((0 >> 16) & 255);
HXDLIN( 312)							if ((this593 == 0)) {
HXLINE( 312)								r237 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								r237 = (( (Float)(this593) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float g237;
HXDLIN( 312)							int this594 = ((0 >> 8) & 255);
HXDLIN( 312)							if ((this594 == 0)) {
HXLINE( 312)								g237 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								g237 = (( (Float)(this594) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float b240;
HXDLIN( 312)							int this595 = (0 & 255);
HXDLIN( 312)							if ((this595 == 0)) {
HXLINE( 312)								b240 = ((Float)0.);
            							}
            							else {
HXLINE( 312)								b240 = (( (Float)(this595) ) / ( (Float)(255) ));
            							}
HXDLIN( 312)							Float a337 = (a140 * (( (Float)(1) ) - a238));
HXDLIN( 312)							int r64 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r137 * a337) + (r237 * a238))));
HXDLIN( 312)							int g64 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g137 * a337) + (g237 * a238))));
HXDLIN( 312)							int b143 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b142 * a337) + (b240 * a238))));
HXDLIN( 312)							int a87 = ::Std_obj::_hx_int((( (Float)(255) ) * (a337 + a238)));
HXDLIN( 312)							int blended36 = ((((a87 << 24) | (r64 << 16)) | (g64 << 8)) | b143);
HXDLIN( 312)							{
HXLINE( 312)								int _hx_tmp145;
HXDLIN( 312)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)									_hx_tmp145 = ((((((blended36 >> 24) & 255) << 24) | ((blended36 & 255) << 16)) | (((blended36 >> 8) & 255) << 8)) | ((blended36 >> 16) & 255));
            								}
            								else {
HXLINE( 312)									_hx_tmp145 = blended36;
            								}
HXDLIN( 312)								::iterMagic::Iimg_obj::set(temp->image,location36,_hx_tmp145);
            							}
            						}
            						else {
HXLINE( 312)							::Dynamic this596 = temp->image;
HXDLIN( 312)							int index77;
HXDLIN( 312)							if (temp->useVirtualPos) {
HXLINE( 312)								index77 = ::Std_obj::_hx_int(((((( (Float)(y65) ) - temp->virtualY) * ( (Float)(temp->width) )) + x65) - temp->virtualX));
            							}
            							else {
HXLINE( 312)								index77 = ::Std_obj::_hx_int(( (Float)(((y65 * temp->width) + x65)) ));
            							}
HXDLIN( 312)							int _hx_tmp146;
HXDLIN( 312)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)								_hx_tmp146 = ((((((c60 >> 24) & 255) << 24) | ((c60 & 255) << 16)) | (((c60 >> 8) & 255) << 8)) | ((c60 >> 16) & 255));
            							}
            							else {
HXLINE( 312)								_hx_tmp146 = c60;
            							}
HXDLIN( 312)							::iterMagic::Iimg_obj::set(this596,index77,_hx_tmp146);
            						}
            					}
            				}
            			}
HXDLIN( 312)			{
HXLINE( 312)				 ::pi_xy::ImageStruct this597 = temp;
HXDLIN( 312)				{
HXLINE( 312)					 ::Dynamic targetError7 = ((Float)1.05);
HXDLIN( 312)					if (::hx::IsNull( targetError7 )) {
HXLINE( 113)						targetError7 = ((Float)1.05);
            					}
HXLINE( 312)					Float rSmall7;
HXDLIN( 312)					if ((rightRadius1 > bottomRadius1)) {
HXLINE( 312)						rSmall7 = bottomRadius1;
            					}
            					else {
HXLINE( 312)						rSmall7 = rightRadius1;
            					}
HXDLIN( 312)					 ::Dynamic targetE7 = ( (Float)(targetError7) );
HXDLIN( 312)					if (::hx::IsNull( targetE7 )) {
HXLINE(  20)						targetE7 = ((Float)1.05);
            					}
HXLINE( 312)					int result7 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE7) ) / rSmall7)))));
HXDLIN( 312)					int noSides7;
HXDLIN( 312)					if ((result7 < 12)) {
HXLINE( 312)						noSides7 = 12;
            					}
            					else {
HXLINE( 312)						if ((result7 > 500)) {
HXLINE( 312)							noSides7 = 500;
            						}
            						else {
HXLINE( 312)							noSides7 = result7;
            						}
            					}
HXDLIN( 312)					int sides7 = (::Math_obj::ceil((( (Float)(noSides7) ) / ( (Float)(4) ))) * 4);
HXDLIN( 312)					Float theta7 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides7) ));
HXDLIN( 312)					Float omega7 = ( (Float)(0) );
HXDLIN( 312)					int quarter7 = ::Std_obj::_hx_int((( (Float)(sides7) ) / ( (Float)(4) )));
HXDLIN( 312)					Float lastX7 = ((Float)0.);
HXDLIN( 312)					Float lastY7 = ((Float)0.);
HXDLIN( 312)					{
HXLINE(  26)						lastX7 = (farX1 + (rightRadius1 * ::Math_obj::cos(((( (Float)(sides7) ) * theta7) + omega7))));
HXLINE(  27)						lastY7 = (lowerY1 + (bottomRadius1 * ::Math_obj::sin(((( (Float)(sides7) ) * theta7) + omega7))));
            					}
HXLINE( 312)					{
HXLINE( 312)						int _g370 = 0;
HXDLIN( 312)						int _g371 = (quarter7 + 1);
HXDLIN( 312)						while((_g370 < _g371)){
HXLINE( 312)							_g370 = (_g370 + 1);
HXDLIN( 312)							int i161 = (_g370 - 1);
HXDLIN( 312)							Float nextX7 = (farX1 + (rightRadius1 * ::Math_obj::cos((((( (Float)(i161) ) * theta7) + ((Float)0.0001)) + omega7))));
HXDLIN( 312)							Float nextY7 = (lowerY1 + (bottomRadius1 * ::Math_obj::sin((((( (Float)(i161) ) * theta7) + ((Float)0.0001)) + omega7))));
HXDLIN( 312)							{
HXLINE( 312)								 ::pi_xy::ImageStruct this598 = this597;
HXDLIN( 312)								bool hasHit17 = false;
HXDLIN( 312)								bool hasUndo17 = false;
HXDLIN( 312)								{
HXLINE( 312)									Float bx12 = lastX7;
HXDLIN( 312)									Float by7 = lastY7;
HXDLIN( 312)									Float cx11 = nextX7;
HXDLIN( 312)									Float cy16 = nextY7;
HXDLIN( 312)									bool adjustWinding7 = (((((farX1 * by7) - (bx12 * lowerY1)) + ((bx12 * cy16) - (cx11 * by7))) + ((cx11 * lowerY1) - (farX1 * cy16))) > 0);
HXDLIN( 312)									if (!(adjustWinding7)) {
HXLINE( 312)										Float bx_7 = bx12;
HXDLIN( 312)										Float by_7 = by7;
HXLINE(  25)										bx12 = cx11;
HXLINE(  26)										by7 = cy16;
HXLINE(  27)										cx11 = bx_7;
HXLINE(  28)										cy16 = by_7;
            									}
HXLINE( 312)									{
HXLINE( 312)										Float s07 = ((lowerY1 * cx11) - (farX1 * cy16));
HXDLIN( 312)										Float sx7 = (cy16 - lowerY1);
HXDLIN( 312)										Float sy7 = (farX1 - cx11);
HXDLIN( 312)										Float t07 = ((farX1 * by7) - (lowerY1 * bx12));
HXDLIN( 312)										Float tx7 = (lowerY1 - by7);
HXDLIN( 312)										Float ty7 = (bx12 - farX1);
HXDLIN( 312)										Float A7 = ((((-(by7) * cx11) + (lowerY1 * (-(bx12) + cx11))) + (farX1 * (by7 - cy16))) + (bx12 * cy16));
HXDLIN( 312)										 ::pi_xy::iter::IntIterStart xIter317;
HXDLIN( 312)										if ((farX1 > bx12)) {
HXLINE( 312)											if ((farX1 > cx11)) {
HXLINE( 312)												int min65;
HXDLIN( 312)												if ((bx12 > cx11)) {
HXLINE( 312)													min65 = ::Math_obj::floor(cx11);
            												}
            												else {
HXLINE( 312)													min65 = ::Math_obj::floor(bx12);
            												}
HXDLIN( 312)												int ii_min139 = min65;
HXDLIN( 312)												int ii_max139 = ::Math_obj::ceil(farX1);
HXDLIN( 312)												xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min139,ii_max139);
            											}
            											else {
HXLINE( 312)												int ii_min140 = ::Math_obj::floor(bx12);
HXDLIN( 312)												int ii_max140 = ::Math_obj::ceil(cx11);
HXDLIN( 312)												xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min140,ii_max140);
            											}
            										}
            										else {
HXLINE( 312)											if ((bx12 > cx11)) {
HXLINE( 312)												int min66;
HXDLIN( 312)												if ((farX1 > cx11)) {
HXLINE( 312)													min66 = ::Math_obj::floor(cx11);
            												}
            												else {
HXLINE( 312)													min66 = ::Math_obj::ceil(farX1);
            												}
HXDLIN( 312)												int ii_min141 = min66;
HXDLIN( 312)												int ii_max141 = ::Math_obj::ceil(bx12);
HXDLIN( 312)												xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min141,ii_max141);
            											}
            											else {
HXLINE( 312)												int ii_min142 = ::Math_obj::floor(farX1);
HXDLIN( 312)												int ii_max142 = ::Math_obj::ceil(cx11);
HXDLIN( 312)												xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min142,ii_max142);
            											}
            										}
HXDLIN( 312)										 ::pi_xy::iter::IntIterStart yIter317;
HXDLIN( 312)										if ((lowerY1 > by7)) {
HXLINE( 312)											if ((lowerY1 > cy16)) {
HXLINE( 312)												int min67;
HXDLIN( 312)												if ((by7 > cy16)) {
HXLINE( 312)													min67 = ::Math_obj::floor(cy16);
            												}
            												else {
HXLINE( 312)													min67 = ::Math_obj::floor(by7);
            												}
HXDLIN( 312)												int ii_min143 = min67;
HXDLIN( 312)												int ii_max143 = ::Math_obj::ceil(lowerY1);
HXDLIN( 312)												yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min143,ii_max143);
            											}
            											else {
HXLINE( 312)												int ii_min144 = ::Math_obj::floor(by7);
HXDLIN( 312)												int ii_max144 = ::Math_obj::ceil(cy16);
HXDLIN( 312)												yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min144,ii_max144);
            											}
            										}
            										else {
HXLINE( 312)											if ((by7 > cy16)) {
HXLINE( 312)												int min68;
HXDLIN( 312)												if ((lowerY1 > cy16)) {
HXLINE( 312)													min68 = ::Math_obj::floor(cy16);
            												}
            												else {
HXLINE( 312)													min68 = ::Math_obj::ceil(lowerY1);
            												}
HXDLIN( 312)												int ii_min145 = min68;
HXDLIN( 312)												int ii_max145 = ::Math_obj::ceil(by7);
HXDLIN( 312)												yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min145,ii_max145);
            											}
            											else {
HXLINE( 312)												int ii_min146 = ::Math_obj::floor(lowerY1);
HXDLIN( 312)												int ii_max146 = ::Math_obj::ceil(cy16);
HXDLIN( 312)												yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min146,ii_max146);
            											}
            										}
HXDLIN( 312)										 ::pi_xy::ImageStruct undoImage51 = null();
HXDLIN( 312)										if (hasUndo17) {
HXLINE( 312)											int width18 = ((xIter317->max - xIter317->start) + 1);
HXDLIN( 312)											int height18 = ((yIter317->max - yIter317->start) + 1);
HXDLIN( 312)											 ::Dynamic imageType18 = null();
HXDLIN( 312)											 ::pi_xy::ImageStruct this599 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 312)											if (::hx::IsNull( imageType18 )) {
HXLINE(  54)												imageType18 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 312)											::Dynamic undoImage52;
HXDLIN( 312)											switch((int)(( (int)(imageType18) ))){
            												case (int)0: {
HXLINE( 312)													 ::iterMagic::BytesImg byt18 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::BytesImg b144 = byt18;
HXDLIN( 312)													{
HXLINE( 312)														b144->width = width18;
HXDLIN( 312)														b144->height = height18;
HXDLIN( 312)														b144->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN( 312)														b144->data = ::haxe::io::Bytes_obj::alloc((b144->length * 4));
HXDLIN( 312)														{
HXLINE( 312)															int len36 = b144->length;
HXDLIN( 312)															int w18 = 0;
HXDLIN( 312)															{
HXLINE( 312)																int _g372 = 0;
HXDLIN( 312)																int _g373 = b144->height;
HXDLIN( 312)																while((_g372 < _g373)){
HXLINE( 312)																	_g372 = (_g372 + 1);
HXDLIN( 312)																	int y66 = (_g372 - 1);
HXDLIN( 312)																	{
HXLINE( 312)																		int _g374 = 0;
HXDLIN( 312)																		int _g375 = b144->width;
HXDLIN( 312)																		while((_g374 < _g375)){
HXLINE( 312)																			_g374 = (_g374 + 1);
HXDLIN( 312)																			int x66 = (_g374 - 1);
HXDLIN( 312)																			{
HXLINE( 312)																				w18 = (w18 + 1);
HXDLIN( 312)																				b144->data->b[(w18 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w18 = (w18 + 1);
HXDLIN( 312)																				b144->data->b[(w18 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w18 = (w18 + 1);
HXDLIN( 312)																				b144->data->b[(w18 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 312)																			{
HXLINE( 312)																				w18 = (w18 + 1);
HXDLIN( 312)																				b144->data->b[(w18 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage52 = b144;
            												}
            												break;
            												case (int)1: {
HXLINE( 312)													 ::iterMagic::ArrIntImg arrI18 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::ArrIntImg a88 = arrI18;
HXDLIN( 312)													{
HXLINE( 312)														a88->width = width18;
HXDLIN( 312)														a88->height = height18;
HXDLIN( 312)														a88->data = ::Array_obj< int >::__new(0);
HXDLIN( 312)														a88->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN( 312)														{
HXLINE( 312)															int _g376 = 0;
HXDLIN( 312)															int _g377 = a88->length;
HXDLIN( 312)															while((_g376 < _g377)){
HXLINE( 312)																_g376 = (_g376 + 1);
HXDLIN( 312)																int i162 = (_g376 - 1);
HXDLIN( 312)																a88->data[i162] = 0;
            															}
            														}
            													}
HXDLIN( 312)													undoImage52 = a88;
            												}
            												break;
            												case (int)2: {
HXLINE( 312)													 ::iterMagic::U32ArrImg u32a18 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::U32ArrImg b145 = u32a18;
HXDLIN( 312)													{
HXLINE( 312)														b145->width = width18;
HXDLIN( 312)														b145->height = height18;
HXDLIN( 312)														b145->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN( 312)														int size18 = (b145->length * 4);
HXDLIN( 312)														b145->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size18),0,size18);
HXDLIN( 312)														{
HXLINE( 312)															int _g378 = 0;
HXDLIN( 312)															int _g379 = b145->length;
HXDLIN( 312)															while((_g378 < _g379)){
HXLINE( 312)																_g378 = (_g378 + 1);
HXDLIN( 312)																int i163 = (_g378 - 1);
HXDLIN( 312)																{
HXLINE( 312)																	 ::haxe::io::ArrayBufferViewImpl this600 = b145->data;
HXDLIN( 312)																	bool undoImage53;
HXDLIN( 312)																	if ((i163 >= 0)) {
HXLINE( 312)																		undoImage53 = (i163 < (this600->byteLength >> 2));
            																	}
            																	else {
HXLINE( 312)																		undoImage53 = false;
            																	}
HXDLIN( 312)																	if (undoImage53) {
HXLINE( 312)																		 ::haxe::io::Bytes _this18 = this600->bytes;
HXDLIN( 312)																		int pos18 = ((i163 << 2) + this600->byteOffset);
HXDLIN( 312)																		_this18->b[pos18] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this18->b[(pos18 + 1)] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this18->b[(pos18 + 2)] = ( (unsigned char)(0) );
HXDLIN( 312)																		_this18->b[(pos18 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage52 = b145;
            												}
            												break;
            												case (int)3: {
HXLINE( 312)													 ::iterMagic::VecIntImg vec18 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::VecIntImg v57 = vec18;
HXDLIN( 312)													{
HXLINE( 312)														v57->width = width18;
HXDLIN( 312)														v57->height = height18;
HXDLIN( 312)														v57->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN( 312)														v57->data = ::Array_obj< int >::__new(v57->length);
HXDLIN( 312)														{
HXLINE( 312)															int _g380 = 0;
HXDLIN( 312)															int _g381 = v57->length;
HXDLIN( 312)															while((_g380 < _g381)){
HXLINE( 312)																_g380 = (_g380 + 1);
HXDLIN( 312)																int i164 = (_g380 - 1);
HXDLIN( 312)																v57->data->__unsafe_set(i164,0);
            															}
            														}
            													}
HXDLIN( 312)													undoImage52 = v57;
            												}
            												break;
            												case (int)4: {
HXLINE( 312)													 ::iterMagic::StackIntImg sInt18 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 312)													 ::iterMagic::StackIntImg b146 = sInt18;
HXDLIN( 312)													{
HXLINE( 312)														b146->width = width18;
HXDLIN( 312)														b146->height = height18;
HXDLIN( 312)														b146->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN( 312)														b146->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 312)														{
HXLINE( 312)															int len37 = b146->length;
HXDLIN( 312)															 ::haxe::ds::GenericStack_Int d18 = b146->data;
HXDLIN( 312)															if (::hx::IsNull( d18->head )) {
HXLINE( 312)																int _g382 = 0;
HXDLIN( 312)																int _g383 = len37;
HXDLIN( 312)																while((_g382 < _g383)){
HXLINE( 312)																	_g382 = (_g382 + 1);
HXDLIN( 312)																	int i165 = (_g382 - 1);
HXDLIN( 312)																	d18->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d18->head);
            																}
            															}
            															else {
HXLINE( 312)																int _g384 = 0;
HXDLIN( 312)																int _g385 = len37;
HXDLIN( 312)																while((_g384 < _g385)){
HXLINE( 312)																	_g384 = (_g384 + 1);
HXDLIN( 312)																	int i166 = (_g384 - 1);
HXDLIN( 312)																	{
HXLINE( 312)																		 ::haxe::ds::GenericCell_Int l18 = b146->data->head;
HXDLIN( 312)																		 ::haxe::ds::GenericCell_Int prev18 = null();
HXDLIN( 312)																		{
HXLINE( 312)																			int _g386 = 0;
HXDLIN( 312)																			int _g387 = i166;
HXDLIN( 312)																			while((_g386 < _g387)){
HXLINE( 312)																				_g386 = (_g386 + 1);
HXDLIN( 312)																				int i167 = (_g386 - 1);
HXLINE( 345)																				prev18 = l18;
HXLINE( 346)																				l18 = l18->next;
            																			}
            																		}
HXLINE( 312)																		if (::hx::IsNull( prev18 )) {
HXLINE( 312)																			b146->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l18->next);
HXDLIN( 312)																			l18 = null();
            																		}
            																		else {
HXLINE( 312)																			prev18->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l18->next);
HXDLIN( 312)																			l18 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 312)													undoImage52 = b146;
            												}
            												break;
            											}
HXDLIN( 312)											this599->image = undoImage52;
HXDLIN( 312)											this599->width = width18;
HXDLIN( 312)											this599->height = height18;
HXDLIN( 312)											this599->imageType = ( (int)(imageType18) );
HXDLIN( 312)											undoImage51 = this599;
HXDLIN( 312)											{
HXLINE( 312)												int rectLeft17 = xIter317->start;
HXDLIN( 312)												int rectTop17 = yIter317->start;
HXDLIN( 312)												int rectRight17 = xIter317->max;
HXDLIN( 312)												bool forceClear17 = false;
HXDLIN( 312)												{
HXLINE( 312)													int _g388 = rectTop17;
HXDLIN( 312)													int _g389 = yIter317->max;
HXDLIN( 312)													while((_g388 < _g389)){
HXLINE( 312)														_g388 = (_g388 + 1);
HXDLIN( 312)														int dy20 = (_g388 - 1);
HXDLIN( 312)														{
HXLINE( 312)															int _g390 = rectLeft17;
HXDLIN( 312)															int _g391 = rectRight17;
HXDLIN( 312)															while((_g390 < _g391)){
HXLINE( 312)																_g390 = (_g390 + 1);
HXDLIN( 312)																int dx20 = (_g390 - 1);
HXDLIN( 312)																::Dynamic this601 = this598->image;
HXDLIN( 312)																int index78;
HXDLIN( 312)																if (this598->useVirtualPos) {
HXLINE( 312)																	index78 = ::Std_obj::_hx_int(((((( (Float)(dy20) ) - this598->virtualY) * ( (Float)(this598->width) )) + dx20) - this598->virtualX));
            																}
            																else {
HXLINE( 312)																	index78 = ::Std_obj::_hx_int(( (Float)(((dy20 * this598->width) + dx20)) ));
            																}
HXDLIN( 312)																int c61 = ::iterMagic::Iimg_obj::get(this601,index78);
HXDLIN( 312)																int col17;
HXDLIN( 312)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																	col17 = ((((((c61 >> 24) & 255) << 24) | ((c61 & 255) << 16)) | (((c61 >> 8) & 255) << 8)) | ((c61 >> 16) & 255));
            																}
            																else {
HXLINE( 312)																	col17 = c61;
            																}
HXDLIN( 312)																bool _hx_tmp147;
HXDLIN( 312)																if (this598->useMask) {
HXLINE( 312)																	_hx_tmp147 = ::hx::IsNotNull( this598->mask );
            																}
            																else {
HXLINE( 312)																	_hx_tmp147 = false;
            																}
HXDLIN( 312)																if (_hx_tmp147) {
HXLINE( 312)																	 ::pi_xy::ImageStruct this602 = this598->mask;
HXDLIN( 312)																	::Dynamic this603 = this602->image;
HXDLIN( 312)																	int index79;
HXDLIN( 312)																	if (this602->useVirtualPos) {
HXLINE( 312)																		index79 = ::Std_obj::_hx_int(((((( (Float)(dy20) ) - this602->virtualY) * ( (Float)(this602->width) )) + dx20) - this602->virtualX));
            																	}
            																	else {
HXLINE( 312)																		index79 = ::Std_obj::_hx_int(( (Float)(((dy20 * this602->width) + dx20)) ));
            																	}
HXDLIN( 312)																	int c62 = ::iterMagic::Iimg_obj::get(this603,index79);
HXDLIN( 312)																	int v58;
HXDLIN( 312)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																		v58 = ((((((c62 >> 24) & 255) << 24) | ((c62 & 255) << 16)) | (((c62 >> 8) & 255) << 8)) | ((c62 >> 16) & 255));
            																	}
            																	else {
HXLINE( 312)																		v58 = c62;
            																	}
HXDLIN( 312)																	int maskPixel17 = v58;
HXDLIN( 312)																	int this604 = col17;
HXDLIN( 312)																	if ((maskPixel17 == 0)) {
HXLINE( 312)																		col17 = this604;
            																	}
            																	else {
HXLINE( 312)																		Float m017;
HXDLIN( 312)																		int this605 = ((maskPixel17 >> 24) & 255);
HXDLIN( 312)																		if ((this605 == 0)) {
HXLINE( 312)																			m017 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m017 = (( (Float)(this605) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m117;
HXDLIN( 312)																		int this606 = ((maskPixel17 >> 16) & 255);
HXDLIN( 312)																		if ((this606 == 0)) {
HXLINE( 312)																			m117 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m117 = (( (Float)(this606) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m217;
HXDLIN( 312)																		int this607 = ((maskPixel17 >> 8) & 255);
HXDLIN( 312)																		if ((this607 == 0)) {
HXLINE( 312)																			m217 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m217 = (( (Float)(this607) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float m317;
HXDLIN( 312)																		int this608 = (maskPixel17 & 255);
HXDLIN( 312)																		if ((this608 == 0)) {
HXLINE( 312)																			m317 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			m317 = (( (Float)(this608) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		int ch017 = ::Std_obj::_hx_int(((((Float)1.) - m017) * ( (Float)(((this604 >> 24) & 255)) )));
HXDLIN( 312)																		int ch117 = ::Std_obj::_hx_int(((((Float)1.) - m117) * ( (Float)(((this604 >> 16) & 255)) )));
HXDLIN( 312)																		int ch217 = ::Std_obj::_hx_int(((((Float)1.) - m217) * ( (Float)(((this604 >> 8) & 255)) )));
HXDLIN( 312)																		int ch317 = ::Std_obj::_hx_int(((((Float)1.) - m317) * ( (Float)((this604 & 255)) )));
HXDLIN( 312)																		col17 = ((((::Math_obj::round((( (Float)(ch017) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch117) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch217) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch317) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 312)																if ((col17 != 0)) {
HXLINE( 312)																	int x67 = (dx20 - rectLeft17);
HXDLIN( 312)																	int y67 = (dy20 - rectTop17);
HXDLIN( 312)																	int c63 = col17;
HXDLIN( 312)																	bool _hx_tmp148;
HXDLIN( 312)																	if ((((c63 >> 24) & 255) < 254)) {
HXLINE( 312)																		_hx_tmp148 = undoImage51->transparent;
            																	}
            																	else {
HXLINE( 312)																		_hx_tmp148 = false;
            																	}
HXDLIN( 312)																	if (_hx_tmp148) {
HXLINE( 312)																		int location37;
HXDLIN( 312)																		if (undoImage51->useVirtualPos) {
HXLINE( 312)																			location37 = ::Std_obj::_hx_int(((((( (Float)(y67) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x67) - undoImage51->virtualX));
            																		}
            																		else {
HXLINE( 312)																			location37 = ::Std_obj::_hx_int(( (Float)(((y67 * undoImage51->width) + x67)) ));
            																		}
HXDLIN( 312)																		int this609 = ::iterMagic::Iimg_obj::get(undoImage51->image,location37);
HXDLIN( 312)																		int this610;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			this610 = ((((((this609 >> 24) & 255) << 24) | ((this609 & 255) << 16)) | (((this609 >> 8) & 255) << 8)) | ((this609 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			this610 = this609;
            																		}
HXDLIN( 312)																		Float a141;
HXDLIN( 312)																		int this611 = ((this610 >> 24) & 255);
HXDLIN( 312)																		if ((this611 == 0)) {
HXLINE( 312)																			a141 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a141 = (( (Float)(this611) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r138;
HXDLIN( 312)																		int this612 = ((this610 >> 16) & 255);
HXDLIN( 312)																		if ((this612 == 0)) {
HXLINE( 312)																			r138 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r138 = (( (Float)(this612) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g138;
HXDLIN( 312)																		int this613 = ((this610 >> 8) & 255);
HXDLIN( 312)																		if ((this613 == 0)) {
HXLINE( 312)																			g138 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g138 = (( (Float)(this613) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b147;
HXDLIN( 312)																		int this614 = (this610 & 255);
HXDLIN( 312)																		if ((this614 == 0)) {
HXLINE( 312)																			b147 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b147 = (( (Float)(this614) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a239;
HXDLIN( 312)																		int this615 = ((col17 >> 24) & 255);
HXDLIN( 312)																		if ((this615 == 0)) {
HXLINE( 312)																			a239 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a239 = (( (Float)(this615) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r238;
HXDLIN( 312)																		int this616 = ((col17 >> 16) & 255);
HXDLIN( 312)																		if ((this616 == 0)) {
HXLINE( 312)																			r238 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r238 = (( (Float)(this616) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g238;
HXDLIN( 312)																		int this617 = ((col17 >> 8) & 255);
HXDLIN( 312)																		if ((this617 == 0)) {
HXLINE( 312)																			g238 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g238 = (( (Float)(this617) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b241;
HXDLIN( 312)																		int this618 = (col17 & 255);
HXDLIN( 312)																		if ((this618 == 0)) {
HXLINE( 312)																			b241 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b241 = (( (Float)(this618) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a338 = (a141 * (( (Float)(1) ) - a239));
HXDLIN( 312)																		int r65 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r138 * a338) + (r238 * a239))));
HXDLIN( 312)																		int g65 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g138 * a338) + (g238 * a239))));
HXDLIN( 312)																		int b148 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b147 * a338) + (b241 * a239))));
HXDLIN( 312)																		int a89 = ::Std_obj::_hx_int((( (Float)(255) ) * (a338 + a239)));
HXDLIN( 312)																		int blended37 = ((((a89 << 24) | (r65 << 16)) | (g65 << 8)) | b148);
HXDLIN( 312)																		{
HXLINE( 312)																			int _hx_tmp149;
HXDLIN( 312)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																				_hx_tmp149 = ((((((blended37 >> 24) & 255) << 24) | ((blended37 & 255) << 16)) | (((blended37 >> 8) & 255) << 8)) | ((blended37 >> 16) & 255));
            																			}
            																			else {
HXLINE( 312)																				_hx_tmp149 = blended37;
            																			}
HXDLIN( 312)																			::iterMagic::Iimg_obj::set(undoImage51->image,location37,_hx_tmp149);
            																		}
            																	}
            																	else {
HXLINE( 312)																		::Dynamic this619 = undoImage51->image;
HXDLIN( 312)																		int index80;
HXDLIN( 312)																		if (undoImage51->useVirtualPos) {
HXLINE( 312)																			index80 = ::Std_obj::_hx_int(((((( (Float)(y67) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x67) - undoImage51->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index80 = ::Std_obj::_hx_int(( (Float)(((y67 * undoImage51->width) + x67)) ));
            																		}
HXDLIN( 312)																		int _hx_tmp150;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			_hx_tmp150 = ((((((c63 >> 24) & 255) << 24) | ((c63 & 255) << 16)) | (((c63 >> 8) & 255) << 8)) | ((c63 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			_hx_tmp150 = c63;
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this619,index80,_hx_tmp150);
            																	}
            																}
            																else {
HXLINE( 312)																	if (forceClear17) {
HXLINE( 312)																		::Dynamic this620 = undoImage51->image;
HXDLIN( 312)																		int x68 = (dx20 - rectLeft17);
HXDLIN( 312)																		int y68 = (dy20 - rectTop17);
HXDLIN( 312)																		int index81;
HXDLIN( 312)																		if (undoImage51->useVirtualPos) {
HXLINE( 312)																			index81 = ::Std_obj::_hx_int(((((( (Float)(y68) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x68) - undoImage51->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index81 = ::Std_obj::_hx_int(( (Float)(((y68 * undoImage51->width) + x68)) ));
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this620,index81,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 312)										bool found7 = false;
HXDLIN( 312)										Float s7 = ((Float)0.);
HXDLIN( 312)										Float t7 = ((Float)0.);
HXDLIN( 312)										Float sxx7 = ((Float)0.);
HXDLIN( 312)										Float txx7 = ((Float)0.);
HXDLIN( 312)										{
HXLINE( 312)											int _g_min34 = xIter317->start;
HXDLIN( 312)											int _g_max34 = xIter317->max;
HXDLIN( 312)											while((_g_min34 < _g_max34)){
HXLINE( 312)												_g_min34 = (_g_min34 + 1);
HXDLIN( 312)												int x69 = (_g_min34 - 1);
HXLINE(  60)												sxx7 = (sx7 * ( (Float)(x69) ));
HXLINE(  61)												txx7 = (tx7 * ( (Float)(x69) ));
HXLINE(  62)												found7 = false;
HXLINE( 312)												{
HXLINE( 312)													int _g_min35 = yIter317->start;
HXDLIN( 312)													int _g_max35 = yIter317->max;
HXDLIN( 312)													while((_g_min35 < _g_max35)){
HXLINE( 312)														_g_min35 = (_g_min35 + 1);
HXDLIN( 312)														int y69 = (_g_min35 - 1);
HXLINE(  64)														s7 = ((s07 + sxx7) + (sy7 * ( (Float)(y69) )));
HXLINE(  65)														t7 = ((t07 + txx7) + (ty7 * ( (Float)(y69) )));
HXLINE( 312)														bool _hx_tmp151;
HXDLIN( 312)														if (!((s7 <= 0))) {
HXLINE( 312)															_hx_tmp151 = (t7 <= 0);
            														}
            														else {
HXLINE( 312)															_hx_tmp151 = true;
            														}
HXDLIN( 312)														if (_hx_tmp151) {
HXLINE( 312)															if (found7) {
HXLINE( 312)																goto _hx_goto_907;
            															}
            														}
            														else {
HXLINE( 312)															if (((s7 + t7) < A7)) {
HXLINE( 312)																{
HXLINE( 312)																	int c64 = 0;
HXDLIN( 312)																	bool _hx_tmp152;
HXDLIN( 312)																	if ((((c64 >> 24) & 255) < 254)) {
HXLINE( 312)																		_hx_tmp152 = this598->transparent;
            																	}
            																	else {
HXLINE( 312)																		_hx_tmp152 = false;
            																	}
HXDLIN( 312)																	if (_hx_tmp152) {
HXLINE( 312)																		int location38;
HXDLIN( 312)																		if (this598->useVirtualPos) {
HXLINE( 312)																			location38 = ::Std_obj::_hx_int(((((( (Float)(y69) ) - this598->virtualY) * ( (Float)(this598->width) )) + x69) - this598->virtualX));
            																		}
            																		else {
HXLINE( 312)																			location38 = ::Std_obj::_hx_int(( (Float)(((y69 * this598->width) + x69)) ));
            																		}
HXDLIN( 312)																		int this621 = ::iterMagic::Iimg_obj::get(this598->image,location38);
HXDLIN( 312)																		int this622;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			this622 = ((((((this621 >> 24) & 255) << 24) | ((this621 & 255) << 16)) | (((this621 >> 8) & 255) << 8)) | ((this621 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			this622 = this621;
            																		}
HXDLIN( 312)																		Float a142;
HXDLIN( 312)																		int this623 = ((this622 >> 24) & 255);
HXDLIN( 312)																		if ((this623 == 0)) {
HXLINE( 312)																			a142 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a142 = (( (Float)(this623) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r139;
HXDLIN( 312)																		int this624 = ((this622 >> 16) & 255);
HXDLIN( 312)																		if ((this624 == 0)) {
HXLINE( 312)																			r139 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r139 = (( (Float)(this624) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g139;
HXDLIN( 312)																		int this625 = ((this622 >> 8) & 255);
HXDLIN( 312)																		if ((this625 == 0)) {
HXLINE( 312)																			g139 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g139 = (( (Float)(this625) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b149;
HXDLIN( 312)																		int this626 = (this622 & 255);
HXDLIN( 312)																		if ((this626 == 0)) {
HXLINE( 312)																			b149 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b149 = (( (Float)(this626) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a240;
HXDLIN( 312)																		int this627 = ((0 >> 24) & 255);
HXDLIN( 312)																		if ((this627 == 0)) {
HXLINE( 312)																			a240 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			a240 = (( (Float)(this627) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float r239;
HXDLIN( 312)																		int this628 = ((0 >> 16) & 255);
HXDLIN( 312)																		if ((this628 == 0)) {
HXLINE( 312)																			r239 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			r239 = (( (Float)(this628) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float g239;
HXDLIN( 312)																		int this629 = ((0 >> 8) & 255);
HXDLIN( 312)																		if ((this629 == 0)) {
HXLINE( 312)																			g239 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			g239 = (( (Float)(this629) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float b242;
HXDLIN( 312)																		int this630 = (0 & 255);
HXDLIN( 312)																		if ((this630 == 0)) {
HXLINE( 312)																			b242 = ((Float)0.);
            																		}
            																		else {
HXLINE( 312)																			b242 = (( (Float)(this630) ) / ( (Float)(255) ));
            																		}
HXDLIN( 312)																		Float a339 = (a142 * (( (Float)(1) ) - a240));
HXDLIN( 312)																		int r66 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r139 * a339) + (r239 * a240))));
HXDLIN( 312)																		int g66 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g139 * a339) + (g239 * a240))));
HXDLIN( 312)																		int b150 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b149 * a339) + (b242 * a240))));
HXDLIN( 312)																		int a90 = ::Std_obj::_hx_int((( (Float)(255) ) * (a339 + a240)));
HXDLIN( 312)																		int blended38 = ((((a90 << 24) | (r66 << 16)) | (g66 << 8)) | b150);
HXDLIN( 312)																		{
HXLINE( 312)																			int _hx_tmp153;
HXDLIN( 312)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																				_hx_tmp153 = ((((((blended38 >> 24) & 255) << 24) | ((blended38 & 255) << 16)) | (((blended38 >> 8) & 255) << 8)) | ((blended38 >> 16) & 255));
            																			}
            																			else {
HXLINE( 312)																				_hx_tmp153 = blended38;
            																			}
HXDLIN( 312)																			::iterMagic::Iimg_obj::set(this598->image,location38,_hx_tmp153);
            																		}
            																	}
            																	else {
HXLINE( 312)																		::Dynamic this631 = this598->image;
HXDLIN( 312)																		int index82;
HXDLIN( 312)																		if (this598->useVirtualPos) {
HXLINE( 312)																			index82 = ::Std_obj::_hx_int(((((( (Float)(y69) ) - this598->virtualY) * ( (Float)(this598->width) )) + x69) - this598->virtualX));
            																		}
            																		else {
HXLINE( 312)																			index82 = ::Std_obj::_hx_int(( (Float)(((y69 * this598->width) + x69)) ));
            																		}
HXDLIN( 312)																		int _hx_tmp154;
HXDLIN( 312)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 312)																			_hx_tmp154 = ((((((c64 >> 24) & 255) << 24) | ((c64 & 255) << 16)) | (((c64 >> 8) & 255) << 8)) | ((c64 >> 16) & 255));
            																		}
            																		else {
HXLINE( 312)																			_hx_tmp154 = c64;
            																		}
HXDLIN( 312)																		::iterMagic::Iimg_obj::set(this631,index82,_hx_tmp154);
            																	}
            																}
HXLINE(  73)																found7 = true;
            															}
            															else {
HXLINE( 312)																if (found7) {
HXLINE( 312)																	goto _hx_goto_907;
            																}
            															}
            														}
            													}
            													_hx_goto_907:;
            												}
            											}
            										}
HXDLIN( 312)										if ((hasHit17 == true)) {
HXLINE( 312)											 ::pi_xy::algo::HitTri v59 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX1,lowerY1,bx12,by7,cx11,cy16,true);
HXDLIN( 312)											if (hasUndo17) {
HXLINE( 312)												v59->undoImage = undoImage51;
HXDLIN( 312)												v59->undoX = xIter317->start;
HXDLIN( 312)												v59->undoY = yIter317->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  46)							lastX7 = nextX7;
HXLINE(  47)							lastY7 = nextY7;
            						}
            					}
            				}
            			}
            		}
HXLINE( 318)		{
HXLINE( 318)			int x70 = ::Std_obj::_hx_int(x);
HXDLIN( 318)			int y70 = ::Std_obj::_hx_int(y);
HXDLIN( 318)			bool forceClear18 = false;
HXDLIN( 318)			{
HXLINE( 318)				int _g392 = 0;
HXDLIN( 318)				int _g393 = temp->height;
HXDLIN( 318)				while((_g392 < _g393)){
HXLINE( 318)					_g392 = (_g392 + 1);
HXDLIN( 318)					int dy21 = (_g392 - 1);
HXDLIN( 318)					{
HXLINE( 318)						int _g394 = 0;
HXDLIN( 318)						int _g395 = temp->width;
HXDLIN( 318)						while((_g394 < _g395)){
HXLINE( 318)							_g394 = (_g394 + 1);
HXDLIN( 318)							int dx21 = (_g394 - 1);
HXDLIN( 318)							::Dynamic this632 = temp->image;
HXDLIN( 318)							int index83;
HXDLIN( 318)							if (temp->useVirtualPos) {
HXLINE( 318)								index83 = ::Std_obj::_hx_int(((((( (Float)(dy21) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx21) - temp->virtualX));
            							}
            							else {
HXLINE( 318)								index83 = ::Std_obj::_hx_int(( (Float)(((dy21 * temp->width) + dx21)) ));
            							}
HXDLIN( 318)							int c65 = ::iterMagic::Iimg_obj::get(this632,index83);
HXDLIN( 318)							int col18;
HXDLIN( 318)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 318)								col18 = ((((((c65 >> 24) & 255) << 24) | ((c65 & 255) << 16)) | (((c65 >> 8) & 255) << 8)) | ((c65 >> 16) & 255));
            							}
            							else {
HXLINE( 318)								col18 = c65;
            							}
HXDLIN( 318)							bool _hx_tmp155;
HXDLIN( 318)							if (temp->useMask) {
HXLINE( 318)								_hx_tmp155 = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE( 318)								_hx_tmp155 = false;
            							}
HXDLIN( 318)							if (_hx_tmp155) {
HXLINE( 318)								 ::pi_xy::ImageStruct this633 = temp->mask;
HXDLIN( 318)								::Dynamic this634 = this633->image;
HXDLIN( 318)								int index84;
HXDLIN( 318)								if (this633->useVirtualPos) {
HXLINE( 318)									index84 = ::Std_obj::_hx_int(((((( (Float)(dy21) ) - this633->virtualY) * ( (Float)(this633->width) )) + dx21) - this633->virtualX));
            								}
            								else {
HXLINE( 318)									index84 = ::Std_obj::_hx_int(( (Float)(((dy21 * this633->width) + dx21)) ));
            								}
HXDLIN( 318)								int c66 = ::iterMagic::Iimg_obj::get(this634,index84);
HXDLIN( 318)								int v60;
HXDLIN( 318)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 318)									v60 = ((((((c66 >> 24) & 255) << 24) | ((c66 & 255) << 16)) | (((c66 >> 8) & 255) << 8)) | ((c66 >> 16) & 255));
            								}
            								else {
HXLINE( 318)									v60 = c66;
            								}
HXDLIN( 318)								int maskPixel18 = v60;
HXDLIN( 318)								int this635 = col18;
HXDLIN( 318)								if ((maskPixel18 == 0)) {
HXLINE( 318)									col18 = this635;
            								}
            								else {
HXLINE( 318)									Float m018;
HXDLIN( 318)									int this636 = ((maskPixel18 >> 24) & 255);
HXDLIN( 318)									if ((this636 == 0)) {
HXLINE( 318)										m018 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										m018 = (( (Float)(this636) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float m118;
HXDLIN( 318)									int this637 = ((maskPixel18 >> 16) & 255);
HXDLIN( 318)									if ((this637 == 0)) {
HXLINE( 318)										m118 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										m118 = (( (Float)(this637) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float m218;
HXDLIN( 318)									int this638 = ((maskPixel18 >> 8) & 255);
HXDLIN( 318)									if ((this638 == 0)) {
HXLINE( 318)										m218 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										m218 = (( (Float)(this638) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float m318;
HXDLIN( 318)									int this639 = (maskPixel18 & 255);
HXDLIN( 318)									if ((this639 == 0)) {
HXLINE( 318)										m318 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										m318 = (( (Float)(this639) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									int ch018 = ::Std_obj::_hx_int(((((Float)1.) - m018) * ( (Float)(((this635 >> 24) & 255)) )));
HXDLIN( 318)									int ch118 = ::Std_obj::_hx_int(((((Float)1.) - m118) * ( (Float)(((this635 >> 16) & 255)) )));
HXDLIN( 318)									int ch218 = ::Std_obj::_hx_int(((((Float)1.) - m218) * ( (Float)(((this635 >> 8) & 255)) )));
HXDLIN( 318)									int ch318 = ::Std_obj::_hx_int(((((Float)1.) - m318) * ( (Float)((this635 & 255)) )));
HXDLIN( 318)									col18 = ((((::Math_obj::round((( (Float)(ch018) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch118) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch218) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch318) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN( 318)							if ((col18 != 0)) {
HXLINE( 318)								int x71 = (x70 + dx21);
HXDLIN( 318)								int y71 = (y70 + dy21);
HXDLIN( 318)								int c67 = col18;
HXDLIN( 318)								bool _hx_tmp156;
HXDLIN( 318)								if ((((c67 >> 24) & 255) < 254)) {
HXLINE( 318)									_hx_tmp156 = this1->transparent;
            								}
            								else {
HXLINE( 318)									_hx_tmp156 = false;
            								}
HXDLIN( 318)								if (_hx_tmp156) {
HXLINE( 318)									int location39;
HXDLIN( 318)									if (this1->useVirtualPos) {
HXLINE( 318)										location39 = ::Std_obj::_hx_int(((((( (Float)(y71) ) - this1->virtualY) * ( (Float)(this1->width) )) + x71) - this1->virtualX));
            									}
            									else {
HXLINE( 318)										location39 = ::Std_obj::_hx_int(( (Float)(((y71 * this1->width) + x71)) ));
            									}
HXDLIN( 318)									int this640 = ::iterMagic::Iimg_obj::get(this1->image,location39);
HXDLIN( 318)									int this641;
HXDLIN( 318)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 318)										this641 = ((((((this640 >> 24) & 255) << 24) | ((this640 & 255) << 16)) | (((this640 >> 8) & 255) << 8)) | ((this640 >> 16) & 255));
            									}
            									else {
HXLINE( 318)										this641 = this640;
            									}
HXDLIN( 318)									Float a143;
HXDLIN( 318)									int this642 = ((this641 >> 24) & 255);
HXDLIN( 318)									if ((this642 == 0)) {
HXLINE( 318)										a143 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										a143 = (( (Float)(this642) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float r140;
HXDLIN( 318)									int this643 = ((this641 >> 16) & 255);
HXDLIN( 318)									if ((this643 == 0)) {
HXLINE( 318)										r140 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										r140 = (( (Float)(this643) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float g140;
HXDLIN( 318)									int this644 = ((this641 >> 8) & 255);
HXDLIN( 318)									if ((this644 == 0)) {
HXLINE( 318)										g140 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										g140 = (( (Float)(this644) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float b151;
HXDLIN( 318)									int this645 = (this641 & 255);
HXDLIN( 318)									if ((this645 == 0)) {
HXLINE( 318)										b151 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										b151 = (( (Float)(this645) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float a241;
HXDLIN( 318)									int this646 = ((col18 >> 24) & 255);
HXDLIN( 318)									if ((this646 == 0)) {
HXLINE( 318)										a241 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										a241 = (( (Float)(this646) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float r240;
HXDLIN( 318)									int this647 = ((col18 >> 16) & 255);
HXDLIN( 318)									if ((this647 == 0)) {
HXLINE( 318)										r240 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										r240 = (( (Float)(this647) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float g240;
HXDLIN( 318)									int this648 = ((col18 >> 8) & 255);
HXDLIN( 318)									if ((this648 == 0)) {
HXLINE( 318)										g240 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										g240 = (( (Float)(this648) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float b243;
HXDLIN( 318)									int this649 = (col18 & 255);
HXDLIN( 318)									if ((this649 == 0)) {
HXLINE( 318)										b243 = ((Float)0.);
            									}
            									else {
HXLINE( 318)										b243 = (( (Float)(this649) ) / ( (Float)(255) ));
            									}
HXDLIN( 318)									Float a340 = (a143 * (( (Float)(1) ) - a241));
HXDLIN( 318)									int r67 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r140 * a340) + (r240 * a241))));
HXDLIN( 318)									int g67 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g140 * a340) + (g240 * a241))));
HXDLIN( 318)									int b152 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b151 * a340) + (b243 * a241))));
HXDLIN( 318)									int a91 = ::Std_obj::_hx_int((( (Float)(255) ) * (a340 + a241)));
HXDLIN( 318)									int blended39 = ((((a91 << 24) | (r67 << 16)) | (g67 << 8)) | b152);
HXDLIN( 318)									{
HXLINE( 318)										int _hx_tmp157;
HXDLIN( 318)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 318)											_hx_tmp157 = ((((((blended39 >> 24) & 255) << 24) | ((blended39 & 255) << 16)) | (((blended39 >> 8) & 255) << 8)) | ((blended39 >> 16) & 255));
            										}
            										else {
HXLINE( 318)											_hx_tmp157 = blended39;
            										}
HXDLIN( 318)										::iterMagic::Iimg_obj::set(this1->image,location39,_hx_tmp157);
            									}
            								}
            								else {
HXLINE( 318)									::Dynamic this650 = this1->image;
HXDLIN( 318)									int index85;
HXDLIN( 318)									if (this1->useVirtualPos) {
HXLINE( 318)										index85 = ::Std_obj::_hx_int(((((( (Float)(y71) ) - this1->virtualY) * ( (Float)(this1->width) )) + x71) - this1->virtualX));
            									}
            									else {
HXLINE( 318)										index85 = ::Std_obj::_hx_int(( (Float)(((y71 * this1->width) + x71)) ));
            									}
HXDLIN( 318)									int _hx_tmp158;
HXDLIN( 318)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 318)										_hx_tmp158 = ((((((c67 >> 24) & 255) << 24) | ((c67 & 255) << 16)) | (((c67 >> 8) & 255) << 8)) | ((c67 >> 16) & 255));
            									}
            									else {
HXLINE( 318)										_hx_tmp158 = c67;
            									}
HXDLIN( 318)									::iterMagic::Iimg_obj::set(this650,index85,_hx_tmp158);
            								}
            							}
            							else {
HXLINE( 318)								if (forceClear18) {
HXLINE( 318)									::Dynamic this651 = this1->image;
HXDLIN( 318)									int x72 = (x70 + dx21);
HXDLIN( 318)									int y72 = (y70 + dy21);
HXDLIN( 318)									int index86;
HXDLIN( 318)									if (this1->useVirtualPos) {
HXLINE( 318)										index86 = ::Std_obj::_hx_int(((((( (Float)(y72) ) - this1->virtualY) * ( (Float)(this1->width) )) + x72) - this1->virtualX));
            									}
            									else {
HXLINE( 318)										index86 = ::Std_obj::_hx_int(( (Float)(((y72 * this1->width) + x72)) ));
            									}
HXDLIN( 318)									::iterMagic::Iimg_obj::set(this651,index86,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 319)		temp = null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(GradientShape_Impl__obj,lineRoundRectangle,(void))


GradientShape_Impl__obj::GradientShape_Impl__obj()
{
}

bool GradientShape_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pie") ) { outValue = pie_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"quad") ) { outValue = quad_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"line") ) { outValue = line_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"triangle") ) { outValue = triangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sweepTri") ) { outValue = sweepTri_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"rectangle") ) { outValue = rectangle_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"thickArrow") ) { outValue = thickArrow_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"radialPolyon") ) { outValue = radialPolyon_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"thickFixArrow") ) { outValue = thickFixArrow_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"thickArrowBoth") ) { outValue = thickArrowBoth_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"RoundRectangle") ) { outValue = RoundRectangle_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"radialRectangle") ) { outValue = radialRectangle_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"radialEllipseTri") ) { outValue = radialEllipseTri_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"thickFixArrowBoth") ) { outValue = thickFixArrowBoth_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"lineRoundRectangle") ) { outValue = lineRoundRectangle_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *GradientShape_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *GradientShape_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class GradientShape_Impl__obj::__mClass;

static ::String GradientShape_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("triangle",c8,be,c5,8d),
	HX_("rectangle",2f,d4,7c,19),
	HX_("quad",c7,38,0a,4b),
	HX_("line",f4,17,b3,47),
	HX_("radialPolyon",aa,2e,92,22),
	HX_("radialEllipseTri",ac,ee,5f,59),
	HX_("sweepTri",9f,86,ef,d9),
	HX_("pie",4c,58,55,00),
	HX_("radialRectangle",50,a1,6f,01),
	HX_("thickArrow",2c,3a,3b,df),
	HX_("thickArrowBoth",cd,74,f6,57),
	HX_("thickFixArrow",31,c3,93,19),
	HX_("thickFixArrowBoth",52,64,c8,64),
	HX_("RoundRectangle",21,d6,70,de),
	HX_("lineRoundRectangle",15,71,92,b4),
	::String(null())
};

void GradientShape_Impl__obj::__register()
{
	GradientShape_Impl__obj _hx_dummy;
	GradientShape_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._GradientShape.GradientShape_Impl_",a6,16,aa,02);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GradientShape_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(GradientShape_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< GradientShape_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GradientShape_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GradientShape_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _GradientShape
