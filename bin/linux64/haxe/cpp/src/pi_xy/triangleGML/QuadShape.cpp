// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_QuadShape
#include <pi_xy/triangleGML/QuadShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_BasicShape
#include <pi_xy/triangleGML/triGML/BasicShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_GroupShape
#include <pi_xy/triangleGML/triGML/GroupShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_ShapeInterface
#include <pi_xy/triangleGML/triGML/ShapeInterface.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_hitTest_IhitObj
#include <pi_xy/triangleGML/triGML/hitTest/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_shape_contour_QuadShape_
#include <pi_xy/triangleGML/triGML/shape/contour/QuadShape_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_27ea2ca91e1c5395_6_new,"pi_xy.triangleGML.QuadShape","new",0x360f3d75,"pi_xy.triangleGML.QuadShape.new","pi_xy/triangleGML/QuadShape.hx",6,0x3ca7a01d)
HX_LOCAL_STACK_FRAME(_hx_pos_27ea2ca91e1c5395_9_setParameter,"pi_xy.triangleGML.QuadShape","setParameter",0xa30abdf2,"pi_xy.triangleGML.QuadShape.setParameter","pi_xy/triangleGML/QuadShape.hx",9,0x3ca7a01d)
HX_LOCAL_STACK_FRAME(_hx_pos_27ea2ca91e1c5395_16_render,"pi_xy.triangleGML.QuadShape","render",0xf0719961,"pi_xy.triangleGML.QuadShape.render","pi_xy/triangleGML/QuadShape.hx",16,0x3ca7a01d)
HX_LOCAL_STACK_FRAME(_hx_pos_27ea2ca91e1c5395_28_clear,"pi_xy.triangleGML.QuadShape","clear",0xf59c0de2,"pi_xy.triangleGML.QuadShape.clear","pi_xy/triangleGML/QuadShape.hx",28,0x3ca7a01d)
namespace pi_xy{
namespace triangleGML{

void QuadShape_obj::__construct( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic aX, ::Dynamic aY, ::Dynamic bX, ::Dynamic bY, ::Dynamic cX, ::Dynamic cY, ::Dynamic dX, ::Dynamic dY){
            	HX_STACKFRAME(&_hx_pos_27ea2ca91e1c5395_6_new)
HXDLIN(   6)		super::__construct(opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY);
            	}

Dynamic QuadShape_obj::__CreateEmpty() { return new QuadShape_obj; }

void *QuadShape_obj::_hx_vtable = 0;

Dynamic QuadShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< QuadShape_obj > _hx_result = new QuadShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10]);
	return _hx_result;
}

bool QuadShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3b57bb90) {
		if (inClassId<=(int)0x1a0bd5c0) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x1a0bd5c0;
		} else {
			return inClassId==(int)0x3b57bb90;
		}
	} else {
		return inClassId==(int)0x76e348e3 || inClassId==(int)0x7ff8cec5;
	}
}

void QuadShape_obj::setParameter(::String name,::String value){
            	HX_STACKFRAME(&_hx_pos_27ea2ca91e1c5395_9_setParameter)
HXDLIN(   9)		if ((name == HX_("luxury",0d,9d,17,dc))) {
HXLINE(  11)			bool _hx_tmp;
HXDLIN(  11)			if ((::StringTools_obj::trim(value).toLowerCase() == HX_("true",4e,a7,03,4d))) {
HXLINE(  11)				_hx_tmp = true;
            			}
            			else {
HXLINE(  11)				_hx_tmp = false;
            			}
HXDLIN(  11)			this->luxury = _hx_tmp;
            		}
            		else {
HXLINE(  13)			this->super::setParameter(name,value);
            		}
            	}


 ::Dynamic QuadShape_obj::render( ::Dynamic _tmp_pixelImage){
            	HX_GC_STACKFRAME(&_hx_pos_27ea2ca91e1c5395_16_render)
HXLINE(  17)		 ::pi_xy::ImageStruct pixelImage = ( ( ::pi_xy::ImageStruct)(_tmp_pixelImage) );
HXDLIN(  17)		 ::pi_xy::algo::HitQuad _hx_tmp;
HXDLIN(  17)		if ((this->edgeSoft == ((Float)0.))) {
HXLINE(  18)			 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN(  18)			Float ax = (this->aX + this->offX);
HXDLIN(  18)			Float ay = (this->aY + this->offY);
HXDLIN(  18)			Float bx = (this->bX + this->offX);
HXDLIN(  18)			Float by = (this->bY + this->offY);
HXDLIN(  18)			Float cx = (this->cX + this->offX);
HXDLIN(  18)			Float cy = (this->cY + this->offY);
HXDLIN(  18)			Float dx = (this->dX + this->offX);
HXDLIN(  18)			Float dy = (this->dY + this->offY);
HXDLIN(  18)			int color = this->strokeColor;
HXDLIN(  18)			Float bx1 = bx;
HXDLIN(  18)			Float by1 = by;
HXDLIN(  18)			Float cx1 = dx;
HXDLIN(  18)			Float cy1 = dy;
HXDLIN(  18)			bool hasUndo = false;
HXDLIN(  18)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  18)			if (!(adjustWinding)) {
HXLINE(  18)				Float bx_ = bx1;
HXDLIN(  18)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE(  18)			Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  18)			Float sx = (cy1 - ay);
HXDLIN(  18)			Float sy = (ax - cx1);
HXDLIN(  18)			Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  18)			Float tx = (ay - by1);
HXDLIN(  18)			Float ty = (bx1 - ax);
HXDLIN(  18)			Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  18)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  18)			if ((ax > bx1)) {
HXLINE(  18)				if ((ax > cx1)) {
HXLINE(  18)					int min;
HXDLIN(  18)					if ((bx1 > cx1)) {
HXLINE(  18)						min = ::Math_obj::floor(cx1);
            					}
            					else {
HXLINE(  18)						min = ::Math_obj::floor(bx1);
            					}
HXDLIN(  18)					int ii_min = min;
HXDLIN(  18)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  18)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE(  18)					int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  18)					int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  18)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE(  18)				if ((bx1 > cx1)) {
HXLINE(  18)					int min1;
HXDLIN(  18)					if ((ax > cx1)) {
HXLINE(  18)						min1 = ::Math_obj::floor(cx1);
            					}
            					else {
HXLINE(  18)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN(  18)					int ii_min2 = min1;
HXDLIN(  18)					int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  18)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE(  18)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  18)					int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  18)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN(  18)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  18)			if ((ay > by1)) {
HXLINE(  18)				if ((ay > cy1)) {
HXLINE(  18)					int min2;
HXDLIN(  18)					if ((by1 > cy1)) {
HXLINE(  18)						min2 = ::Math_obj::floor(cy1);
            					}
            					else {
HXLINE(  18)						min2 = ::Math_obj::floor(by1);
            					}
HXDLIN(  18)					int ii_min4 = min2;
HXDLIN(  18)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  18)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE(  18)					int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  18)					int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  18)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE(  18)				if ((by1 > cy1)) {
HXLINE(  18)					int min3;
HXDLIN(  18)					if ((ay > cy1)) {
HXLINE(  18)						min3 = ::Math_obj::floor(cy1);
            					}
            					else {
HXLINE(  18)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN(  18)					int ii_min6 = min3;
HXDLIN(  18)					int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  18)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE(  18)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  18)					int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  18)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN(  18)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  18)			if (hasUndo) {
HXLINE(  18)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  18)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  18)				 ::Dynamic imageType = null();
HXDLIN(  18)				 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  18)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  18)				::Dynamic undoImage1;
HXDLIN(  18)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE(  18)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::BytesImg b = byt;
HXDLIN(  18)						{
HXLINE(  18)							b->width = width;
HXDLIN(  18)							b->height = height;
HXDLIN(  18)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  18)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  18)							{
HXLINE(  18)								int len = b->length;
HXDLIN(  18)								int w = 0;
HXDLIN(  18)								{
HXLINE(  18)									int _g = 0;
HXDLIN(  18)									int _g1 = b->height;
HXDLIN(  18)									while((_g < _g1)){
HXLINE(  18)										_g = (_g + 1);
HXDLIN(  18)										int y = (_g - 1);
HXDLIN(  18)										{
HXLINE(  18)											int _g2 = 0;
HXDLIN(  18)											int _g3 = b->width;
HXDLIN(  18)											while((_g2 < _g3)){
HXLINE(  18)												_g2 = (_g2 + 1);
HXDLIN(  18)												int x = (_g2 - 1);
HXDLIN(  18)												{
HXLINE(  18)													w = (w + 1);
HXDLIN(  18)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  18)												{
HXLINE(  18)													w = (w + 1);
HXDLIN(  18)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  18)												{
HXLINE(  18)													w = (w + 1);
HXDLIN(  18)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  18)												{
HXLINE(  18)													w = (w + 1);
HXDLIN(  18)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  18)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE(  18)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  18)						{
HXLINE(  18)							a->width = width;
HXDLIN(  18)							a->height = height;
HXDLIN(  18)							a->data = ::Array_obj< int >::__new(0);
HXDLIN(  18)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  18)							{
HXLINE(  18)								int _g4 = 0;
HXDLIN(  18)								int _g5 = a->length;
HXDLIN(  18)								while((_g4 < _g5)){
HXLINE(  18)									_g4 = (_g4 + 1);
HXDLIN(  18)									int i = (_g4 - 1);
HXDLIN(  18)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN(  18)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE(  18)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  18)						{
HXLINE(  18)							b1->width = width;
HXDLIN(  18)							b1->height = height;
HXDLIN(  18)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  18)							int size = (b1->length * 4);
HXDLIN(  18)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  18)							{
HXLINE(  18)								int _g6 = 0;
HXDLIN(  18)								int _g7 = b1->length;
HXDLIN(  18)								while((_g6 < _g7)){
HXLINE(  18)									_g6 = (_g6 + 1);
HXDLIN(  18)									int i1 = (_g6 - 1);
HXDLIN(  18)									{
HXLINE(  18)										 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  18)										bool undoImage2;
HXDLIN(  18)										if ((i1 >= 0)) {
HXLINE(  18)											undoImage2 = (i1 < (this3->byteLength >> 2));
            										}
            										else {
HXLINE(  18)											undoImage2 = false;
            										}
HXDLIN(  18)										if (undoImage2) {
HXLINE(  18)											 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  18)											int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  18)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  18)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  18)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  18)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  18)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE(  18)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::VecIntImg v = vec;
HXDLIN(  18)						{
HXLINE(  18)							v->width = width;
HXDLIN(  18)							v->height = height;
HXDLIN(  18)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  18)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  18)							{
HXLINE(  18)								int _g8 = 0;
HXDLIN(  18)								int _g9 = v->length;
HXDLIN(  18)								while((_g8 < _g9)){
HXLINE(  18)									_g8 = (_g8 + 1);
HXDLIN(  18)									int i2 = (_g8 - 1);
HXDLIN(  18)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN(  18)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE(  18)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  18)						{
HXLINE(  18)							b2->width = width;
HXDLIN(  18)							b2->height = height;
HXDLIN(  18)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  18)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  18)							{
HXLINE(  18)								int len1 = b2->length;
HXDLIN(  18)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  18)								if (::hx::IsNull( d->head )) {
HXLINE(  18)									int _g10 = 0;
HXDLIN(  18)									int _g11 = len1;
HXDLIN(  18)									while((_g10 < _g11)){
HXLINE(  18)										_g10 = (_g10 + 1);
HXDLIN(  18)										int i3 = (_g10 - 1);
HXDLIN(  18)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE(  18)									int _g12 = 0;
HXDLIN(  18)									int _g13 = len1;
HXDLIN(  18)									while((_g12 < _g13)){
HXLINE(  18)										_g12 = (_g12 + 1);
HXDLIN(  18)										int i4 = (_g12 - 1);
HXDLIN(  18)										{
HXLINE(  18)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  18)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  18)											{
HXLINE(  18)												int _g14 = 0;
HXDLIN(  18)												int _g15 = i4;
HXDLIN(  18)												while((_g14 < _g15)){
HXLINE(  18)													_g14 = (_g14 + 1);
HXDLIN(  18)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE(  18)											if (::hx::IsNull( prev )) {
HXLINE(  18)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  18)												l = null();
            											}
            											else {
HXLINE(  18)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  18)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  18)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN(  18)				this2->image = undoImage1;
HXDLIN(  18)				this2->width = width;
HXDLIN(  18)				this2->height = height;
HXDLIN(  18)				this2->imageType = ( (int)(imageType) );
HXDLIN(  18)				undoImage = this2;
HXDLIN(  18)				{
HXLINE(  18)					int rectLeft = xIter3->start;
HXDLIN(  18)					int rectTop = yIter3->start;
HXDLIN(  18)					int rectRight = xIter3->max;
HXDLIN(  18)					bool forceClear = false;
HXDLIN(  18)					{
HXLINE(  18)						int _g16 = rectTop;
HXDLIN(  18)						int _g17 = yIter3->max;
HXDLIN(  18)						while((_g16 < _g17)){
HXLINE(  18)							_g16 = (_g16 + 1);
HXDLIN(  18)							int dy1 = (_g16 - 1);
HXDLIN(  18)							{
HXLINE(  18)								int _g18 = rectLeft;
HXDLIN(  18)								int _g19 = rectRight;
HXDLIN(  18)								while((_g18 < _g19)){
HXLINE(  18)									_g18 = (_g18 + 1);
HXDLIN(  18)									int dx1 = (_g18 - 1);
HXDLIN(  18)									::Dynamic this4 = this1->image;
HXDLIN(  18)									int index;
HXDLIN(  18)									if (this1->useVirtualPos) {
HXLINE(  18)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            									}
            									else {
HXLINE(  18)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            									}
HXDLIN(  18)									int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  18)									int col;
HXDLIN(  18)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  18)										col = c;
            									}
HXDLIN(  18)									bool _hx_tmp1;
HXDLIN(  18)									if (this1->useMask) {
HXLINE(  18)										_hx_tmp1 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  18)										_hx_tmp1 = false;
            									}
HXDLIN(  18)									if (_hx_tmp1) {
HXLINE(  18)										 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  18)										::Dynamic this6 = this5->image;
HXDLIN(  18)										int index1;
HXDLIN(  18)										if (this5->useVirtualPos) {
HXLINE(  18)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            										}
            										else {
HXLINE(  18)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            										}
HXDLIN(  18)										int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  18)										int v1;
HXDLIN(  18)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE(  18)											v1 = c1;
            										}
HXDLIN(  18)										int maskPixel = v1;
HXDLIN(  18)										int this7 = col;
HXDLIN(  18)										if ((maskPixel == 0)) {
HXLINE(  18)											col = this7;
            										}
            										else {
HXLINE(  18)											Float m0;
HXDLIN(  18)											int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  18)											if ((this8 == 0)) {
HXLINE(  18)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float m1;
HXDLIN(  18)											int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  18)											if ((this9 == 0)) {
HXLINE(  18)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float m2;
HXDLIN(  18)											int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  18)											if ((this10 == 0)) {
HXLINE(  18)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float m3;
HXDLIN(  18)											int this11 = (maskPixel & 255);
HXDLIN(  18)											if ((this11 == 0)) {
HXLINE(  18)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  18)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  18)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  18)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  18)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  18)									if ((col != 0)) {
HXLINE(  18)										int x1 = (dx1 - rectLeft);
HXDLIN(  18)										int y1 = (dy1 - rectTop);
HXDLIN(  18)										int c2 = col;
HXDLIN(  18)										bool _hx_tmp2;
HXDLIN(  18)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  18)											_hx_tmp2 = undoImage->transparent;
            										}
            										else {
HXLINE(  18)											_hx_tmp2 = false;
            										}
HXDLIN(  18)										if (_hx_tmp2) {
HXLINE(  18)											int location;
HXDLIN(  18)											if (undoImage->useVirtualPos) {
HXLINE(  18)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE(  18)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN(  18)											int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  18)											int this13;
HXDLIN(  18)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)												this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            											}
            											else {
HXLINE(  18)												this13 = this12;
            											}
HXDLIN(  18)											Float a1;
HXDLIN(  18)											int this14 = ((this13 >> 24) & 255);
HXDLIN(  18)											if ((this14 == 0)) {
HXLINE(  18)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float r1;
HXDLIN(  18)											int this15 = ((this13 >> 16) & 255);
HXDLIN(  18)											if ((this15 == 0)) {
HXLINE(  18)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float g1;
HXDLIN(  18)											int this16 = ((this13 >> 8) & 255);
HXDLIN(  18)											if ((this16 == 0)) {
HXLINE(  18)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float b11;
HXDLIN(  18)											int this17 = (this13 & 255);
HXDLIN(  18)											if ((this17 == 0)) {
HXLINE(  18)												b11 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float a2;
HXDLIN(  18)											int this18 = ((col >> 24) & 255);
HXDLIN(  18)											if ((this18 == 0)) {
HXLINE(  18)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float r2;
HXDLIN(  18)											int this19 = ((col >> 16) & 255);
HXDLIN(  18)											if ((this19 == 0)) {
HXLINE(  18)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float g2;
HXDLIN(  18)											int this20 = ((col >> 8) & 255);
HXDLIN(  18)											if ((this20 == 0)) {
HXLINE(  18)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float b21;
HXDLIN(  18)											int this21 = (col & 255);
HXDLIN(  18)											if ((this21 == 0)) {
HXLINE(  18)												b21 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  18)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  18)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  18)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  18)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  18)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  18)											{
HXLINE(  18)												int _hx_tmp3;
HXDLIN(  18)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)													_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  18)													_hx_tmp3 = blended;
            												}
HXDLIN(  18)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp3);
            											}
            										}
            										else {
HXLINE(  18)											::Dynamic this22 = undoImage->image;
HXDLIN(  18)											int index2;
HXDLIN(  18)											if (undoImage->useVirtualPos) {
HXLINE(  18)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE(  18)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN(  18)											int _hx_tmp4;
HXDLIN(  18)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)												_hx_tmp4 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE(  18)												_hx_tmp4 = c2;
            											}
HXDLIN(  18)											::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp4);
            										}
            									}
            									else {
HXLINE(  18)										if (forceClear) {
HXLINE(  18)											::Dynamic this23 = undoImage->image;
HXDLIN(  18)											int x2 = (dx1 - rectLeft);
HXDLIN(  18)											int y2 = (dy1 - rectTop);
HXDLIN(  18)											int index3;
HXDLIN(  18)											if (undoImage->useVirtualPos) {
HXLINE(  18)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE(  18)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN(  18)											::iterMagic::Iimg_obj::set(this23,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  18)			bool found = false;
HXDLIN(  18)			Float s = ((Float)0.);
HXDLIN(  18)			Float t = ((Float)0.);
HXDLIN(  18)			Float sxx = ((Float)0.);
HXDLIN(  18)			Float txx = ((Float)0.);
HXDLIN(  18)			{
HXLINE(  18)				int _g_min = xIter3->start;
HXDLIN(  18)				int _g_max = xIter3->max;
HXDLIN(  18)				while((_g_min < _g_max)){
HXLINE(  18)					_g_min = (_g_min + 1);
HXDLIN(  18)					int x3 = (_g_min - 1);
HXLINE(  60)					sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)					txx = (tx * ( (Float)(x3) ));
HXLINE(  62)					found = false;
HXLINE(  18)					{
HXLINE(  18)						int _g_min1 = yIter3->start;
HXDLIN(  18)						int _g_max1 = yIter3->max;
HXDLIN(  18)						while((_g_min1 < _g_max1)){
HXLINE(  18)							_g_min1 = (_g_min1 + 1);
HXDLIN(  18)							int y3 = (_g_min1 - 1);
HXLINE(  64)							s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)							t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  18)							bool _hx_tmp5;
HXDLIN(  18)							if (!((s <= 0))) {
HXLINE(  18)								_hx_tmp5 = (t <= 0);
            							}
            							else {
HXLINE(  18)								_hx_tmp5 = true;
            							}
HXDLIN(  18)							if (_hx_tmp5) {
HXLINE(  18)								if (found) {
HXLINE(  18)									goto _hx_goto_13;
            								}
            							}
            							else {
HXLINE(  18)								if (((s + t) < A)) {
HXLINE(  18)									{
HXLINE(  18)										int c3 = color;
HXDLIN(  18)										bool _hx_tmp6;
HXDLIN(  18)										if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  18)											_hx_tmp6 = this1->transparent;
            										}
            										else {
HXLINE(  18)											_hx_tmp6 = false;
            										}
HXDLIN(  18)										if (_hx_tmp6) {
HXLINE(  18)											int location1;
HXDLIN(  18)											if (this1->useVirtualPos) {
HXLINE(  18)												location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            											}
            											else {
HXLINE(  18)												location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            											}
HXDLIN(  18)											int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  18)											int this25;
HXDLIN(  18)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)												this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            											}
            											else {
HXLINE(  18)												this25 = this24;
            											}
HXDLIN(  18)											Float a11;
HXDLIN(  18)											int this26 = ((this25 >> 24) & 255);
HXDLIN(  18)											if ((this26 == 0)) {
HXLINE(  18)												a11 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float r11;
HXDLIN(  18)											int this27 = ((this25 >> 16) & 255);
HXDLIN(  18)											if ((this27 == 0)) {
HXLINE(  18)												r11 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float g11;
HXDLIN(  18)											int this28 = ((this25 >> 8) & 255);
HXDLIN(  18)											if ((this28 == 0)) {
HXLINE(  18)												g11 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float b12;
HXDLIN(  18)											int this29 = (this25 & 255);
HXDLIN(  18)											if ((this29 == 0)) {
HXLINE(  18)												b12 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float a21;
HXDLIN(  18)											int this30 = ((color >> 24) & 255);
HXDLIN(  18)											if ((this30 == 0)) {
HXLINE(  18)												a21 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float r21;
HXDLIN(  18)											int this31 = ((color >> 16) & 255);
HXDLIN(  18)											if ((this31 == 0)) {
HXLINE(  18)												r21 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float g21;
HXDLIN(  18)											int this32 = ((color >> 8) & 255);
HXDLIN(  18)											if ((this32 == 0)) {
HXLINE(  18)												g21 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float b22;
HXDLIN(  18)											int this33 = (color & 255);
HXDLIN(  18)											if ((this33 == 0)) {
HXLINE(  18)												b22 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  18)											int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  18)											int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  18)											int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  18)											int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  18)											int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  18)											{
HXLINE(  18)												int _hx_tmp7;
HXDLIN(  18)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)													_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXLINE(  18)													_hx_tmp7 = blended1;
            												}
HXDLIN(  18)												::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            											}
            										}
            										else {
HXLINE(  18)											::Dynamic this34 = this1->image;
HXDLIN(  18)											int index4;
HXDLIN(  18)											if (this1->useVirtualPos) {
HXLINE(  18)												index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            											}
            											else {
HXLINE(  18)												index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            											}
HXDLIN(  18)											int _hx_tmp8;
HXDLIN(  18)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)												_hx_tmp8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            											}
            											else {
HXLINE(  18)												_hx_tmp8 = c3;
            											}
HXDLIN(  18)											::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp8);
            										}
            									}
HXLINE(  73)									found = true;
            								}
            								else {
HXLINE(  18)									if (found) {
HXLINE(  18)										goto _hx_goto_13;
            									}
            								}
            							}
            						}
            						_hx_goto_13:;
            					}
            				}
            			}
HXDLIN(  18)			 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  18)			 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  18)			int v_undoY;
HXDLIN(  18)			int v_undoX;
HXDLIN(  18)			Float v_ty;
HXDLIN(  18)			Float v_tx;
HXDLIN(  18)			Float v_t0;
HXDLIN(  18)			Float v_sy;
HXDLIN(  18)			Float v_sx;
HXDLIN(  18)			Float v_s0;
HXDLIN(  18)			Float v_A;
HXDLIN(  18)			Float ax1 = ax;
HXDLIN(  18)			Float ay1 = ay;
HXDLIN(  18)			 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  18)			Float bx2 = bx1;
HXDLIN(  18)			Float by2 = by1;
HXDLIN(  18)			Float cx2 = cx1;
HXDLIN(  18)			Float cy2 = cy1;
HXDLIN(  18)			bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  18)			if (!(adjustWinding1)) {
HXLINE(  18)				Float bx_1 = bx2;
HXDLIN(  18)				Float by_1 = by2;
HXLINE(  24)				bx2 = cx2;
HXLINE(  25)				by2 = cy2;
HXLINE(  26)				cx2 = bx_1;
HXLINE(  27)				cy2 = by_1;
            			}
HXLINE(  18)			Float v_ax = ax1;
HXDLIN(  18)			Float v_ay = ay1;
HXDLIN(  18)			Float v_bx = bx2;
HXDLIN(  18)			Float v_by = by2;
HXDLIN(  18)			Float v_cx = cx2;
HXDLIN(  18)			Float v_cy = cy2;
HXDLIN(  18)			bool v_preCalculated = true;
HXDLIN(  18)			{
HXLINE(  18)				v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  18)				v_sx = (v_cy - v_ay);
HXDLIN(  18)				v_sy = (v_ax - v_cx);
HXDLIN(  18)				v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  18)				v_tx = (v_ay - v_by);
HXDLIN(  18)				v_ty = (v_bx - v_ax);
HXDLIN(  18)				v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  18)				Float a6 = v_ax;
HXDLIN(  18)				Float b5 = v_bx;
HXDLIN(  18)				Float c4 = v_cx;
HXDLIN(  18)				if ((a6 > b5)) {
HXLINE(  18)					if ((a6 > c4)) {
HXLINE(  18)						int min4;
HXDLIN(  18)						if ((b5 > c4)) {
HXLINE(  18)							min4 = ::Math_obj::floor(c4);
            						}
            						else {
HXLINE(  18)							min4 = ::Math_obj::floor(b5);
            						}
HXDLIN(  18)						int ii_min8 = min4;
HXDLIN(  18)						int ii_max8 = ::Math_obj::ceil(a6);
HXDLIN(  18)						v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE(  18)						int ii_min9 = ::Math_obj::floor(b5);
HXDLIN(  18)						int ii_max9 = ::Math_obj::ceil(c4);
HXDLIN(  18)						v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE(  18)					if ((b5 > c4)) {
HXLINE(  18)						int min5;
HXDLIN(  18)						if ((a6 > c4)) {
HXLINE(  18)							min5 = ::Math_obj::floor(c4);
            						}
            						else {
HXLINE(  18)							min5 = ::Math_obj::ceil(a6);
            						}
HXDLIN(  18)						int ii_min10 = min5;
HXDLIN(  18)						int ii_max10 = ::Math_obj::ceil(b5);
HXDLIN(  18)						v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE(  18)						int ii_min11 = ::Math_obj::floor(a6);
HXDLIN(  18)						int ii_max11 = ::Math_obj::ceil(c4);
HXDLIN(  18)						v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN(  18)				Float a7 = v_ay;
HXDLIN(  18)				Float b6 = v_by;
HXDLIN(  18)				Float c5 = v_cy;
HXDLIN(  18)				if ((a7 > b6)) {
HXLINE(  18)					if ((a7 > c5)) {
HXLINE(  18)						int min6;
HXDLIN(  18)						if ((b6 > c5)) {
HXLINE(  18)							min6 = ::Math_obj::floor(c5);
            						}
            						else {
HXLINE(  18)							min6 = ::Math_obj::floor(b6);
            						}
HXDLIN(  18)						int ii_min12 = min6;
HXDLIN(  18)						int ii_max12 = ::Math_obj::ceil(a7);
HXDLIN(  18)						v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE(  18)						int ii_min13 = ::Math_obj::floor(b6);
HXDLIN(  18)						int ii_max13 = ::Math_obj::ceil(c5);
HXDLIN(  18)						v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE(  18)					if ((b6 > c5)) {
HXLINE(  18)						int min7;
HXDLIN(  18)						if ((a7 > c5)) {
HXLINE(  18)							min7 = ::Math_obj::floor(c5);
            						}
            						else {
HXLINE(  18)							min7 = ::Math_obj::ceil(a7);
            						}
HXDLIN(  18)						int ii_min14 = min7;
HXDLIN(  18)						int ii_max14 = ::Math_obj::ceil(b6);
HXDLIN(  18)						v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE(  18)						int ii_min15 = ::Math_obj::floor(a7);
HXDLIN(  18)						int ii_max15 = ::Math_obj::ceil(c5);
HXDLIN(  18)						v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
            			}
HXDLIN(  18)			if (hasUndo) {
HXLINE(  18)				v_undoImage = undoImage;
HXDLIN(  18)				v_undoX = xIter3->start;
HXDLIN(  18)				v_undoY = yIter3->start;
            			}
HXDLIN(  18)			Float bx3 = cx;
HXDLIN(  18)			Float by3 = cy;
HXDLIN(  18)			Float cx3 = dx;
HXDLIN(  18)			Float cy3 = dy;
HXDLIN(  18)			bool hasUndo1 = false;
HXDLIN(  18)			bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN(  18)			if (!(adjustWinding2)) {
HXLINE(  18)				Float bx_2 = bx3;
HXDLIN(  18)				Float by_2 = by3;
HXLINE(  25)				bx3 = cx3;
HXLINE(  26)				by3 = cy3;
HXLINE(  27)				cx3 = bx_2;
HXLINE(  28)				cy3 = by_2;
            			}
HXLINE(  18)			Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN(  18)			Float sx1 = (cy3 - by);
HXDLIN(  18)			Float sy1 = (bx - cx3);
HXDLIN(  18)			Float t01 = ((bx * by3) - (by * bx3));
HXDLIN(  18)			Float tx1 = (by - by3);
HXDLIN(  18)			Float ty1 = (bx3 - bx);
HXDLIN(  18)			Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN(  18)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  18)			if ((bx > bx3)) {
HXLINE(  18)				if ((bx > cx3)) {
HXLINE(  18)					int min8;
HXDLIN(  18)					if ((bx3 > cx3)) {
HXLINE(  18)						min8 = ::Math_obj::floor(cx3);
            					}
            					else {
HXLINE(  18)						min8 = ::Math_obj::floor(bx3);
            					}
HXDLIN(  18)					int ii_min16 = min8;
HXDLIN(  18)					int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN(  18)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            				}
            				else {
HXLINE(  18)					int ii_min17 = ::Math_obj::floor(bx3);
HXDLIN(  18)					int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN(  18)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            				}
            			}
            			else {
HXLINE(  18)				if ((bx3 > cx3)) {
HXLINE(  18)					int min9;
HXDLIN(  18)					if ((bx > cx3)) {
HXLINE(  18)						min9 = ::Math_obj::floor(cx3);
            					}
            					else {
HXLINE(  18)						min9 = ::Math_obj::ceil(bx);
            					}
HXDLIN(  18)					int ii_min18 = min9;
HXDLIN(  18)					int ii_max18 = ::Math_obj::ceil(bx3);
HXDLIN(  18)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            				}
            				else {
HXLINE(  18)					int ii_min19 = ::Math_obj::floor(bx);
HXDLIN(  18)					int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN(  18)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            				}
            			}
HXDLIN(  18)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  18)			if ((by > by3)) {
HXLINE(  18)				if ((by > cy3)) {
HXLINE(  18)					int min10;
HXDLIN(  18)					if ((by3 > cy3)) {
HXLINE(  18)						min10 = ::Math_obj::floor(cy3);
            					}
            					else {
HXLINE(  18)						min10 = ::Math_obj::floor(by3);
            					}
HXDLIN(  18)					int ii_min20 = min10;
HXDLIN(  18)					int ii_max20 = ::Math_obj::ceil(by);
HXDLIN(  18)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            				}
            				else {
HXLINE(  18)					int ii_min21 = ::Math_obj::floor(by3);
HXDLIN(  18)					int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN(  18)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            				}
            			}
            			else {
HXLINE(  18)				if ((by3 > cy3)) {
HXLINE(  18)					int min11;
HXDLIN(  18)					if ((by > cy3)) {
HXLINE(  18)						min11 = ::Math_obj::floor(cy3);
            					}
            					else {
HXLINE(  18)						min11 = ::Math_obj::ceil(by);
            					}
HXDLIN(  18)					int ii_min22 = min11;
HXDLIN(  18)					int ii_max22 = ::Math_obj::ceil(by3);
HXDLIN(  18)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            				}
            				else {
HXLINE(  18)					int ii_min23 = ::Math_obj::floor(by);
HXDLIN(  18)					int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN(  18)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            				}
            			}
HXDLIN(  18)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  18)			if (hasUndo1) {
HXLINE(  18)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  18)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  18)				 ::Dynamic imageType1 = null();
HXDLIN(  18)				 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  18)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  18)				::Dynamic undoImage4;
HXDLIN(  18)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE(  18)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::BytesImg b7 = byt1;
HXDLIN(  18)						{
HXLINE(  18)							b7->width = width1;
HXDLIN(  18)							b7->height = height1;
HXDLIN(  18)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  18)							b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN(  18)							{
HXLINE(  18)								int len2 = b7->length;
HXDLIN(  18)								int w1 = 0;
HXDLIN(  18)								{
HXLINE(  18)									int _g20 = 0;
HXDLIN(  18)									int _g21 = b7->height;
HXDLIN(  18)									while((_g20 < _g21)){
HXLINE(  18)										_g20 = (_g20 + 1);
HXDLIN(  18)										int y4 = (_g20 - 1);
HXDLIN(  18)										{
HXLINE(  18)											int _g22 = 0;
HXDLIN(  18)											int _g23 = b7->width;
HXDLIN(  18)											while((_g22 < _g23)){
HXLINE(  18)												_g22 = (_g22 + 1);
HXDLIN(  18)												int x4 = (_g22 - 1);
HXDLIN(  18)												{
HXLINE(  18)													w1 = (w1 + 1);
HXDLIN(  18)													b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  18)												{
HXLINE(  18)													w1 = (w1 + 1);
HXDLIN(  18)													b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  18)												{
HXLINE(  18)													w1 = (w1 + 1);
HXDLIN(  18)													b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  18)												{
HXLINE(  18)													w1 = (w1 + 1);
HXDLIN(  18)													b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  18)						undoImage4 = b7;
            					}
            					break;
            					case (int)1: {
HXLINE(  18)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::ArrIntImg a8 = arrI1;
HXDLIN(  18)						{
HXLINE(  18)							a8->width = width1;
HXDLIN(  18)							a8->height = height1;
HXDLIN(  18)							a8->data = ::Array_obj< int >::__new(0);
HXDLIN(  18)							a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  18)							{
HXLINE(  18)								int _g24 = 0;
HXDLIN(  18)								int _g25 = a8->length;
HXDLIN(  18)								while((_g24 < _g25)){
HXLINE(  18)									_g24 = (_g24 + 1);
HXDLIN(  18)									int i6 = (_g24 - 1);
HXDLIN(  18)									a8->data[i6] = 0;
            								}
            							}
            						}
HXDLIN(  18)						undoImage4 = a8;
            					}
            					break;
            					case (int)2: {
HXLINE(  18)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::U32ArrImg b8 = u32a1;
HXDLIN(  18)						{
HXLINE(  18)							b8->width = width1;
HXDLIN(  18)							b8->height = height1;
HXDLIN(  18)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  18)							int size1 = (b8->length * 4);
HXDLIN(  18)							b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  18)							{
HXLINE(  18)								int _g26 = 0;
HXDLIN(  18)								int _g27 = b8->length;
HXDLIN(  18)								while((_g26 < _g27)){
HXLINE(  18)									_g26 = (_g26 + 1);
HXDLIN(  18)									int i7 = (_g26 - 1);
HXDLIN(  18)									{
HXLINE(  18)										 ::haxe::io::ArrayBufferViewImpl this36 = b8->data;
HXDLIN(  18)										bool undoImage5;
HXDLIN(  18)										if ((i7 >= 0)) {
HXLINE(  18)											undoImage5 = (i7 < (this36->byteLength >> 2));
            										}
            										else {
HXLINE(  18)											undoImage5 = false;
            										}
HXDLIN(  18)										if (undoImage5) {
HXLINE(  18)											 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN(  18)											int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN(  18)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  18)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  18)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  18)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  18)						undoImage4 = b8;
            					}
            					break;
            					case (int)3: {
HXLINE(  18)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  18)						{
HXLINE(  18)							v2->width = width1;
HXDLIN(  18)							v2->height = height1;
HXDLIN(  18)							v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  18)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  18)							{
HXLINE(  18)								int _g28 = 0;
HXDLIN(  18)								int _g29 = v2->length;
HXDLIN(  18)								while((_g28 < _g29)){
HXLINE(  18)									_g28 = (_g28 + 1);
HXDLIN(  18)									int i8 = (_g28 - 1);
HXDLIN(  18)									v2->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN(  18)						undoImage4 = v2;
            					}
            					break;
            					case (int)4: {
HXLINE(  18)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  18)						 ::iterMagic::StackIntImg b9 = sInt1;
HXDLIN(  18)						{
HXLINE(  18)							b9->width = width1;
HXDLIN(  18)							b9->height = height1;
HXDLIN(  18)							b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  18)							b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  18)							{
HXLINE(  18)								int len3 = b9->length;
HXDLIN(  18)								 ::haxe::ds::GenericStack_Int d1 = b9->data;
HXDLIN(  18)								if (::hx::IsNull( d1->head )) {
HXLINE(  18)									int _g30 = 0;
HXDLIN(  18)									int _g31 = len3;
HXDLIN(  18)									while((_g30 < _g31)){
HXLINE(  18)										_g30 = (_g30 + 1);
HXDLIN(  18)										int i9 = (_g30 - 1);
HXDLIN(  18)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE(  18)									int _g32 = 0;
HXDLIN(  18)									int _g33 = len3;
HXDLIN(  18)									while((_g32 < _g33)){
HXLINE(  18)										_g32 = (_g32 + 1);
HXDLIN(  18)										int i10 = (_g32 - 1);
HXDLIN(  18)										{
HXLINE(  18)											 ::haxe::ds::GenericCell_Int l1 = b9->data->head;
HXDLIN(  18)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  18)											{
HXLINE(  18)												int _g34 = 0;
HXDLIN(  18)												int _g35 = i10;
HXDLIN(  18)												while((_g34 < _g35)){
HXLINE(  18)													_g34 = (_g34 + 1);
HXDLIN(  18)													int i11 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  18)											if (::hx::IsNull( prev1 )) {
HXLINE(  18)												b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  18)												l1 = null();
            											}
            											else {
HXLINE(  18)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  18)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  18)						undoImage4 = b9;
            					}
            					break;
            				}
HXDLIN(  18)				this35->image = undoImage4;
HXDLIN(  18)				this35->width = width1;
HXDLIN(  18)				this35->height = height1;
HXDLIN(  18)				this35->imageType = ( (int)(imageType1) );
HXDLIN(  18)				undoImage3 = this35;
HXDLIN(  18)				{
HXLINE(  18)					int rectLeft1 = xIter31->start;
HXDLIN(  18)					int rectTop1 = yIter31->start;
HXDLIN(  18)					int rectRight1 = xIter31->max;
HXDLIN(  18)					bool forceClear1 = false;
HXDLIN(  18)					{
HXLINE(  18)						int _g36 = rectTop1;
HXDLIN(  18)						int _g37 = yIter31->max;
HXDLIN(  18)						while((_g36 < _g37)){
HXLINE(  18)							_g36 = (_g36 + 1);
HXDLIN(  18)							int dy2 = (_g36 - 1);
HXDLIN(  18)							{
HXLINE(  18)								int _g38 = rectLeft1;
HXDLIN(  18)								int _g39 = rectRight1;
HXDLIN(  18)								while((_g38 < _g39)){
HXLINE(  18)									_g38 = (_g38 + 1);
HXDLIN(  18)									int dx2 = (_g38 - 1);
HXDLIN(  18)									::Dynamic this37 = this1->image;
HXDLIN(  18)									int index5;
HXDLIN(  18)									if (this1->useVirtualPos) {
HXLINE(  18)										index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            									}
            									else {
HXLINE(  18)										index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            									}
HXDLIN(  18)									int c6 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN(  18)									int col1;
HXDLIN(  18)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)										col1 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE(  18)										col1 = c6;
            									}
HXDLIN(  18)									bool _hx_tmp9;
HXDLIN(  18)									if (this1->useMask) {
HXLINE(  18)										_hx_tmp9 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  18)										_hx_tmp9 = false;
            									}
HXDLIN(  18)									if (_hx_tmp9) {
HXLINE(  18)										 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN(  18)										::Dynamic this39 = this38->image;
HXDLIN(  18)										int index6;
HXDLIN(  18)										if (this38->useVirtualPos) {
HXLINE(  18)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            										}
            										else {
HXLINE(  18)											index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            										}
HXDLIN(  18)										int c7 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN(  18)										int v3;
HXDLIN(  18)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)											v3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE(  18)											v3 = c7;
            										}
HXDLIN(  18)										int maskPixel1 = v3;
HXDLIN(  18)										int this40 = col1;
HXDLIN(  18)										if ((maskPixel1 == 0)) {
HXLINE(  18)											col1 = this40;
            										}
            										else {
HXLINE(  18)											Float m01;
HXDLIN(  18)											int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN(  18)											if ((this41 == 0)) {
HXLINE(  18)												m01 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float m11;
HXDLIN(  18)											int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN(  18)											if ((this42 == 0)) {
HXLINE(  18)												m11 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float m21;
HXDLIN(  18)											int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN(  18)											if ((this43 == 0)) {
HXLINE(  18)												m21 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float m31;
HXDLIN(  18)											int this44 = (maskPixel1 & 255);
HXDLIN(  18)											if ((this44 == 0)) {
HXLINE(  18)												m31 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN(  18)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN(  18)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN(  18)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN(  18)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  18)									if ((col1 != 0)) {
HXLINE(  18)										int x5 = (dx2 - rectLeft1);
HXDLIN(  18)										int y5 = (dy2 - rectTop1);
HXDLIN(  18)										int c8 = col1;
HXDLIN(  18)										bool _hx_tmp10;
HXDLIN(  18)										if ((((c8 >> 24) & 255) < 254)) {
HXLINE(  18)											_hx_tmp10 = undoImage3->transparent;
            										}
            										else {
HXLINE(  18)											_hx_tmp10 = false;
            										}
HXDLIN(  18)										if (_hx_tmp10) {
HXLINE(  18)											int location2;
HXDLIN(  18)											if (undoImage3->useVirtualPos) {
HXLINE(  18)												location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  18)												location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN(  18)											int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  18)											int this46;
HXDLIN(  18)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)												this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            											}
            											else {
HXLINE(  18)												this46 = this45;
            											}
HXDLIN(  18)											Float a12;
HXDLIN(  18)											int this47 = ((this46 >> 24) & 255);
HXDLIN(  18)											if ((this47 == 0)) {
HXLINE(  18)												a12 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float r12;
HXDLIN(  18)											int this48 = ((this46 >> 16) & 255);
HXDLIN(  18)											if ((this48 == 0)) {
HXLINE(  18)												r12 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float g12;
HXDLIN(  18)											int this49 = ((this46 >> 8) & 255);
HXDLIN(  18)											if ((this49 == 0)) {
HXLINE(  18)												g12 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float b13;
HXDLIN(  18)											int this50 = (this46 & 255);
HXDLIN(  18)											if ((this50 == 0)) {
HXLINE(  18)												b13 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float a22;
HXDLIN(  18)											int this51 = ((col1 >> 24) & 255);
HXDLIN(  18)											if ((this51 == 0)) {
HXLINE(  18)												a22 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float r22;
HXDLIN(  18)											int this52 = ((col1 >> 16) & 255);
HXDLIN(  18)											if ((this52 == 0)) {
HXLINE(  18)												r22 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float g22;
HXDLIN(  18)											int this53 = ((col1 >> 8) & 255);
HXDLIN(  18)											if ((this53 == 0)) {
HXLINE(  18)												g22 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float b23;
HXDLIN(  18)											int this54 = (col1 & 255);
HXDLIN(  18)											if ((this54 == 0)) {
HXLINE(  18)												b23 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  18)											int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  18)											int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  18)											int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  18)											int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  18)											int blended2 = ((((a9 << 24) | (r4 << 16)) | (g4 << 8)) | b10);
HXDLIN(  18)											{
HXLINE(  18)												int _hx_tmp11;
HXDLIN(  18)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)													_hx_tmp11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE(  18)													_hx_tmp11 = blended2;
            												}
HXDLIN(  18)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp11);
            											}
            										}
            										else {
HXLINE(  18)											::Dynamic this55 = undoImage3->image;
HXDLIN(  18)											int index7;
HXDLIN(  18)											if (undoImage3->useVirtualPos) {
HXLINE(  18)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  18)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN(  18)											int _hx_tmp12;
HXDLIN(  18)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)												_hx_tmp12 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXLINE(  18)												_hx_tmp12 = c8;
            											}
HXDLIN(  18)											::iterMagic::Iimg_obj::set(this55,index7,_hx_tmp12);
            										}
            									}
            									else {
HXLINE(  18)										if (forceClear1) {
HXLINE(  18)											::Dynamic this56 = undoImage3->image;
HXDLIN(  18)											int x6 = (dx2 - rectLeft1);
HXDLIN(  18)											int y6 = (dy2 - rectTop1);
HXDLIN(  18)											int index8;
HXDLIN(  18)											if (undoImage3->useVirtualPos) {
HXLINE(  18)												index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  18)												index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            											}
HXDLIN(  18)											::iterMagic::Iimg_obj::set(this56,index8,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  18)			bool found1 = false;
HXDLIN(  18)			Float s1 = ((Float)0.);
HXDLIN(  18)			Float t1 = ((Float)0.);
HXDLIN(  18)			Float sxx1 = ((Float)0.);
HXDLIN(  18)			Float txx1 = ((Float)0.);
HXDLIN(  18)			{
HXLINE(  18)				int _g_min2 = xIter31->start;
HXDLIN(  18)				int _g_max2 = xIter31->max;
HXDLIN(  18)				while((_g_min2 < _g_max2)){
HXLINE(  18)					_g_min2 = (_g_min2 + 1);
HXDLIN(  18)					int x7 = (_g_min2 - 1);
HXLINE(  60)					sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)					txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)					found1 = false;
HXLINE(  18)					{
HXLINE(  18)						int _g_min3 = yIter31->start;
HXDLIN(  18)						int _g_max3 = yIter31->max;
HXDLIN(  18)						while((_g_min3 < _g_max3)){
HXLINE(  18)							_g_min3 = (_g_min3 + 1);
HXDLIN(  18)							int y7 = (_g_min3 - 1);
HXLINE(  64)							s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)							t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  18)							bool _hx_tmp13;
HXDLIN(  18)							if (!((s1 <= 0))) {
HXLINE(  18)								_hx_tmp13 = (t1 <= 0);
            							}
            							else {
HXLINE(  18)								_hx_tmp13 = true;
            							}
HXDLIN(  18)							if (_hx_tmp13) {
HXLINE(  18)								if (found1) {
HXLINE(  18)									goto _hx_goto_25;
            								}
            							}
            							else {
HXLINE(  18)								if (((s1 + t1) < A1)) {
HXLINE(  18)									{
HXLINE(  18)										int c9 = color;
HXDLIN(  18)										bool _hx_tmp14;
HXDLIN(  18)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE(  18)											_hx_tmp14 = this1->transparent;
            										}
            										else {
HXLINE(  18)											_hx_tmp14 = false;
            										}
HXDLIN(  18)										if (_hx_tmp14) {
HXLINE(  18)											int location3;
HXDLIN(  18)											if (this1->useVirtualPos) {
HXLINE(  18)												location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            											}
            											else {
HXLINE(  18)												location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            											}
HXDLIN(  18)											int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  18)											int this58;
HXDLIN(  18)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)												this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            											}
            											else {
HXLINE(  18)												this58 = this57;
            											}
HXDLIN(  18)											Float a13;
HXDLIN(  18)											int this59 = ((this58 >> 24) & 255);
HXDLIN(  18)											if ((this59 == 0)) {
HXLINE(  18)												a13 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												a13 = (( (Float)(this59) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float r13;
HXDLIN(  18)											int this60 = ((this58 >> 16) & 255);
HXDLIN(  18)											if ((this60 == 0)) {
HXLINE(  18)												r13 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float g13;
HXDLIN(  18)											int this61 = ((this58 >> 8) & 255);
HXDLIN(  18)											if ((this61 == 0)) {
HXLINE(  18)												g13 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float b14;
HXDLIN(  18)											int this62 = (this58 & 255);
HXDLIN(  18)											if ((this62 == 0)) {
HXLINE(  18)												b14 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float a23;
HXDLIN(  18)											int this63 = ((color >> 24) & 255);
HXDLIN(  18)											if ((this63 == 0)) {
HXLINE(  18)												a23 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float r23;
HXDLIN(  18)											int this64 = ((color >> 16) & 255);
HXDLIN(  18)											if ((this64 == 0)) {
HXLINE(  18)												r23 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float g23;
HXDLIN(  18)											int this65 = ((color >> 8) & 255);
HXDLIN(  18)											if ((this65 == 0)) {
HXLINE(  18)												g23 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float b24;
HXDLIN(  18)											int this66 = (color & 255);
HXDLIN(  18)											if ((this66 == 0)) {
HXLINE(  18)												b24 = ((Float)0.);
            											}
            											else {
HXLINE(  18)												b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN(  18)											Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  18)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  18)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  18)											int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  18)											int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  18)											int blended3 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b15);
HXDLIN(  18)											{
HXLINE(  18)												int _hx_tmp15;
HXDLIN(  18)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)													_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE(  18)													_hx_tmp15 = blended3;
            												}
HXDLIN(  18)												::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp15);
            											}
            										}
            										else {
HXLINE(  18)											::Dynamic this67 = this1->image;
HXDLIN(  18)											int index9;
HXDLIN(  18)											if (this1->useVirtualPos) {
HXLINE(  18)												index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            											}
            											else {
HXLINE(  18)												index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            											}
HXDLIN(  18)											int _hx_tmp16;
HXDLIN(  18)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  18)												_hx_tmp16 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE(  18)												_hx_tmp16 = c9;
            											}
HXDLIN(  18)											::iterMagic::Iimg_obj::set(this67,index9,_hx_tmp16);
            										}
            									}
HXLINE(  73)									found1 = true;
            								}
            								else {
HXLINE(  18)									if (found1) {
HXLINE(  18)										goto _hx_goto_25;
            									}
            								}
            							}
            						}
            						_hx_goto_25:;
            					}
            				}
            			}
HXDLIN(  18)			 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  18)			 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  18)			int v_undoY1;
HXDLIN(  18)			int v_undoX1;
HXDLIN(  18)			Float v_ty1;
HXDLIN(  18)			Float v_tx1;
HXDLIN(  18)			Float v_t01;
HXDLIN(  18)			Float v_sy1;
HXDLIN(  18)			Float v_sx1;
HXDLIN(  18)			Float v_s01;
HXDLIN(  18)			Float v_A1;
HXDLIN(  18)			Float ax2 = bx;
HXDLIN(  18)			Float ay2 = by;
HXDLIN(  18)			 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  18)			Float bx4 = bx3;
HXDLIN(  18)			Float by4 = by3;
HXDLIN(  18)			Float cx4 = cx3;
HXDLIN(  18)			Float cy4 = cy3;
HXDLIN(  18)			bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN(  18)			if (!(adjustWinding3)) {
HXLINE(  18)				Float bx_3 = bx4;
HXDLIN(  18)				Float by_3 = by4;
HXLINE(  24)				bx4 = cx4;
HXLINE(  25)				by4 = cy4;
HXLINE(  26)				cx4 = bx_3;
HXLINE(  27)				cy4 = by_3;
            			}
HXLINE(  18)			Float v_ax1 = ax2;
HXDLIN(  18)			Float v_ay1 = ay2;
HXDLIN(  18)			Float v_bx1 = bx4;
HXDLIN(  18)			Float v_by1 = by4;
HXDLIN(  18)			Float v_cx1 = cx4;
HXDLIN(  18)			Float v_cy1 = cy4;
HXDLIN(  18)			bool v_preCalculated1 = true;
HXDLIN(  18)			{
HXLINE(  18)				v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  18)				v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  18)				v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  18)				v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  18)				v_tx1 = (v_ay1 - v_by1);
HXDLIN(  18)				v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  18)				v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  18)				Float a14 = v_ax1;
HXDLIN(  18)				Float b16 = v_bx1;
HXDLIN(  18)				Float c10 = v_cx1;
HXDLIN(  18)				if ((a14 > b16)) {
HXLINE(  18)					if ((a14 > c10)) {
HXLINE(  18)						int min12;
HXDLIN(  18)						if ((b16 > c10)) {
HXLINE(  18)							min12 = ::Math_obj::floor(c10);
            						}
            						else {
HXLINE(  18)							min12 = ::Math_obj::floor(b16);
            						}
HXDLIN(  18)						int ii_min24 = min12;
HXDLIN(  18)						int ii_max24 = ::Math_obj::ceil(a14);
HXDLIN(  18)						v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            					}
            					else {
HXLINE(  18)						int ii_min25 = ::Math_obj::floor(b16);
HXDLIN(  18)						int ii_max25 = ::Math_obj::ceil(c10);
HXDLIN(  18)						v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            					}
            				}
            				else {
HXLINE(  18)					if ((b16 > c10)) {
HXLINE(  18)						int min13;
HXDLIN(  18)						if ((a14 > c10)) {
HXLINE(  18)							min13 = ::Math_obj::floor(c10);
            						}
            						else {
HXLINE(  18)							min13 = ::Math_obj::ceil(a14);
            						}
HXDLIN(  18)						int ii_min26 = min13;
HXDLIN(  18)						int ii_max26 = ::Math_obj::ceil(b16);
HXDLIN(  18)						v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            					}
            					else {
HXLINE(  18)						int ii_min27 = ::Math_obj::floor(a14);
HXDLIN(  18)						int ii_max27 = ::Math_obj::ceil(c10);
HXDLIN(  18)						v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            					}
            				}
HXDLIN(  18)				Float a15 = v_ay1;
HXDLIN(  18)				Float b17 = v_by1;
HXDLIN(  18)				Float c11 = v_cy1;
HXDLIN(  18)				if ((a15 > b17)) {
HXLINE(  18)					if ((a15 > c11)) {
HXLINE(  18)						int min14;
HXDLIN(  18)						if ((b17 > c11)) {
HXLINE(  18)							min14 = ::Math_obj::floor(c11);
            						}
            						else {
HXLINE(  18)							min14 = ::Math_obj::floor(b17);
            						}
HXDLIN(  18)						int ii_min28 = min14;
HXDLIN(  18)						int ii_max28 = ::Math_obj::ceil(a15);
HXDLIN(  18)						v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            					}
            					else {
HXLINE(  18)						int ii_min29 = ::Math_obj::floor(b17);
HXDLIN(  18)						int ii_max29 = ::Math_obj::ceil(c11);
HXDLIN(  18)						v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            					}
            				}
            				else {
HXLINE(  18)					if ((b17 > c11)) {
HXLINE(  18)						int min15;
HXDLIN(  18)						if ((a15 > c11)) {
HXLINE(  18)							min15 = ::Math_obj::floor(c11);
            						}
            						else {
HXLINE(  18)							min15 = ::Math_obj::ceil(a15);
            						}
HXDLIN(  18)						int ii_min30 = min15;
HXDLIN(  18)						int ii_max30 = ::Math_obj::ceil(b17);
HXDLIN(  18)						v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            					}
            					else {
HXLINE(  18)						int ii_min31 = ::Math_obj::floor(a15);
HXDLIN(  18)						int ii_max31 = ::Math_obj::ceil(c11);
HXDLIN(  18)						v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            					}
            				}
            			}
HXDLIN(  18)			if (hasUndo1) {
HXLINE(  18)				v_undoImage1 = undoImage3;
HXDLIN(  18)				v_undoX1 = xIter31->start;
HXDLIN(  18)				v_undoY1 = yIter31->start;
            			}
HXDLIN(  18)			 ::pi_xy::algo::HitQuad v4 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE(  17)			_hx_tmp = v4;
            		}
            		else {
HXLINE(  20)			if (this->luxury) {
HXLINE(  21)				 ::pi_xy::ImageStruct this68 = pixelImage;
HXDLIN(  21)				Float ax3 = (this->aX + this->offX);
HXDLIN(  21)				Float ay3 = (this->aY + this->offY);
HXDLIN(  21)				Float bx5 = (this->bX + this->offX);
HXDLIN(  21)				Float by5 = (this->bY + this->offY);
HXDLIN(  21)				Float cx5 = (this->cX + this->offX);
HXDLIN(  21)				Float cy5 = (this->cY + this->offY);
HXDLIN(  21)				Float dx3 = (this->dX + this->offX);
HXDLIN(  21)				Float dy3 = (this->dY + this->offY);
HXDLIN(  21)				int color1 = this->strokeColor;
HXDLIN(  21)				Float soft = this->edgeSoft;
HXDLIN(  21)				bool hasHit = false;
HXDLIN(  21)				{
HXLINE(  21)					bool hasUndo2 = true;
HXDLIN(  21)					int aA = ((color1 >> 24) & 255);
HXDLIN(  21)					int rA = ((color1 >> 16) & 255);
HXDLIN(  21)					int gA = ((color1 >> 8) & 255);
HXDLIN(  21)					int bA = (color1 & 255);
HXDLIN(  21)					Float bcx = (bx5 - cx5);
HXDLIN(  21)					Float bcy = (by5 - cy5);
HXDLIN(  21)					Float acx = (ax3 - cx5);
HXDLIN(  21)					Float acy = (ay3 - cy5);
HXDLIN(  21)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  21)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  21)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  21)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  21)					 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  21)					if ((ax3 > bx5)) {
HXLINE(  21)						if ((ax3 > cx5)) {
HXLINE(  21)							int min16;
HXDLIN(  21)							if ((bx5 > cx5)) {
HXLINE(  21)								min16 = ::Math_obj::floor(cx5);
            							}
            							else {
HXLINE(  21)								min16 = ::Math_obj::floor(bx5);
            							}
HXDLIN(  21)							int ii_min32 = min16;
HXDLIN(  21)							int ii_max32 = ::Math_obj::ceil(ax3);
HXDLIN(  21)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            						}
            						else {
HXLINE(  21)							int ii_min33 = ::Math_obj::floor(bx5);
HXDLIN(  21)							int ii_max33 = ::Math_obj::ceil(cx5);
HXDLIN(  21)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            						}
            					}
            					else {
HXLINE(  21)						if ((bx5 > cx5)) {
HXLINE(  21)							int min17;
HXDLIN(  21)							if ((ax3 > cx5)) {
HXLINE(  21)								min17 = ::Math_obj::floor(cx5);
            							}
            							else {
HXLINE(  21)								min17 = ::Math_obj::ceil(ax3);
            							}
HXDLIN(  21)							int ii_min34 = min17;
HXDLIN(  21)							int ii_max34 = ::Math_obj::ceil(bx5);
HXDLIN(  21)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            						}
            						else {
HXLINE(  21)							int ii_min35 = ::Math_obj::floor(ax3);
HXDLIN(  21)							int ii_max35 = ::Math_obj::ceil(cx5);
HXDLIN(  21)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            						}
            					}
HXDLIN(  21)					 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  21)					if ((ay3 > by5)) {
HXLINE(  21)						if ((ay3 > cy5)) {
HXLINE(  21)							int min18;
HXDLIN(  21)							if ((by5 > cy5)) {
HXLINE(  21)								min18 = ::Math_obj::floor(cy5);
            							}
            							else {
HXLINE(  21)								min18 = ::Math_obj::floor(by5);
            							}
HXDLIN(  21)							int ii_min36 = min18;
HXDLIN(  21)							int ii_max36 = ::Math_obj::ceil(ay3);
HXDLIN(  21)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            						}
            						else {
HXLINE(  21)							int ii_min37 = ::Math_obj::floor(by5);
HXDLIN(  21)							int ii_max37 = ::Math_obj::ceil(cy5);
HXDLIN(  21)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            						}
            					}
            					else {
HXLINE(  21)						if ((by5 > cy5)) {
HXLINE(  21)							int min19;
HXDLIN(  21)							if ((ay3 > cy5)) {
HXLINE(  21)								min19 = ::Math_obj::floor(cy5);
            							}
            							else {
HXLINE(  21)								min19 = ::Math_obj::ceil(ay3);
            							}
HXDLIN(  21)							int ii_min38 = min19;
HXDLIN(  21)							int ii_max38 = ::Math_obj::ceil(by5);
HXDLIN(  21)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            						}
            						else {
HXLINE(  21)							int ii_min39 = ::Math_obj::floor(ay3);
HXDLIN(  21)							int ii_max39 = ::Math_obj::ceil(cy5);
HXDLIN(  21)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            						}
            					}
HXDLIN(  21)					 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  21)					if (hasUndo2) {
HXLINE(  21)						int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  21)						int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  21)						 ::Dynamic imageType2 = null();
HXDLIN(  21)						 ::pi_xy::ImageStruct this69 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  21)						if (::hx::IsNull( imageType2 )) {
HXLINE(  54)							imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  21)						::Dynamic undoImage7;
HXDLIN(  21)						switch((int)(( (int)(imageType2) ))){
            							case (int)0: {
HXLINE(  21)								 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::BytesImg b18 = byt2;
HXDLIN(  21)								{
HXLINE(  21)									b18->width = width2;
HXDLIN(  21)									b18->height = height2;
HXDLIN(  21)									b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  21)									b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN(  21)									{
HXLINE(  21)										int len4 = b18->length;
HXDLIN(  21)										int w2 = 0;
HXDLIN(  21)										{
HXLINE(  21)											int _g40 = 0;
HXDLIN(  21)											int _g41 = b18->height;
HXDLIN(  21)											while((_g40 < _g41)){
HXLINE(  21)												_g40 = (_g40 + 1);
HXDLIN(  21)												int y8 = (_g40 - 1);
HXDLIN(  21)												{
HXLINE(  21)													int _g42 = 0;
HXDLIN(  21)													int _g43 = b18->width;
HXDLIN(  21)													while((_g42 < _g43)){
HXLINE(  21)														_g42 = (_g42 + 1);
HXDLIN(  21)														int x8 = (_g42 - 1);
HXDLIN(  21)														{
HXLINE(  21)															w2 = (w2 + 1);
HXDLIN(  21)															b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w2 = (w2 + 1);
HXDLIN(  21)															b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w2 = (w2 + 1);
HXDLIN(  21)															b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w2 = (w2 + 1);
HXDLIN(  21)															b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage7 = b18;
            							}
            							break;
            							case (int)1: {
HXLINE(  21)								 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::ArrIntImg a16 = arrI2;
HXDLIN(  21)								{
HXLINE(  21)									a16->width = width2;
HXDLIN(  21)									a16->height = height2;
HXDLIN(  21)									a16->data = ::Array_obj< int >::__new(0);
HXDLIN(  21)									a16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  21)									{
HXLINE(  21)										int _g44 = 0;
HXDLIN(  21)										int _g45 = a16->length;
HXDLIN(  21)										while((_g44 < _g45)){
HXLINE(  21)											_g44 = (_g44 + 1);
HXDLIN(  21)											int i12 = (_g44 - 1);
HXDLIN(  21)											a16->data[i12] = 0;
            										}
            									}
            								}
HXDLIN(  21)								undoImage7 = a16;
            							}
            							break;
            							case (int)2: {
HXLINE(  21)								 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::U32ArrImg b19 = u32a2;
HXDLIN(  21)								{
HXLINE(  21)									b19->width = width2;
HXDLIN(  21)									b19->height = height2;
HXDLIN(  21)									b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  21)									int size2 = (b19->length * 4);
HXDLIN(  21)									b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  21)									{
HXLINE(  21)										int _g46 = 0;
HXDLIN(  21)										int _g47 = b19->length;
HXDLIN(  21)										while((_g46 < _g47)){
HXLINE(  21)											_g46 = (_g46 + 1);
HXDLIN(  21)											int i13 = (_g46 - 1);
HXDLIN(  21)											{
HXLINE(  21)												 ::haxe::io::ArrayBufferViewImpl this70 = b19->data;
HXDLIN(  21)												bool undoImage8;
HXDLIN(  21)												if ((i13 >= 0)) {
HXLINE(  21)													undoImage8 = (i13 < (this70->byteLength >> 2));
            												}
            												else {
HXLINE(  21)													undoImage8 = false;
            												}
HXDLIN(  21)												if (undoImage8) {
HXLINE(  21)													 ::haxe::io::Bytes _this2 = this70->bytes;
HXDLIN(  21)													int pos2 = ((i13 << 2) + this70->byteOffset);
HXDLIN(  21)													_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  21)													_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  21)													_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  21)													_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage7 = b19;
            							}
            							break;
            							case (int)3: {
HXLINE(  21)								 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN(  21)								{
HXLINE(  21)									v5->width = width2;
HXDLIN(  21)									v5->height = height2;
HXDLIN(  21)									v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  21)									v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN(  21)									{
HXLINE(  21)										int _g48 = 0;
HXDLIN(  21)										int _g49 = v5->length;
HXDLIN(  21)										while((_g48 < _g49)){
HXLINE(  21)											_g48 = (_g48 + 1);
HXDLIN(  21)											int i14 = (_g48 - 1);
HXDLIN(  21)											v5->data->__unsafe_set(i14,0);
            										}
            									}
            								}
HXDLIN(  21)								undoImage7 = v5;
            							}
            							break;
            							case (int)4: {
HXLINE(  21)								 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::StackIntImg b20 = sInt2;
HXDLIN(  21)								{
HXLINE(  21)									b20->width = width2;
HXDLIN(  21)									b20->height = height2;
HXDLIN(  21)									b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  21)									b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  21)									{
HXLINE(  21)										int len5 = b20->length;
HXDLIN(  21)										 ::haxe::ds::GenericStack_Int d2 = b20->data;
HXDLIN(  21)										if (::hx::IsNull( d2->head )) {
HXLINE(  21)											int _g50 = 0;
HXDLIN(  21)											int _g51 = len5;
HXDLIN(  21)											while((_g50 < _g51)){
HXLINE(  21)												_g50 = (_g50 + 1);
HXDLIN(  21)												int i15 = (_g50 - 1);
HXDLIN(  21)												d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            											}
            										}
            										else {
HXLINE(  21)											int _g52 = 0;
HXDLIN(  21)											int _g53 = len5;
HXDLIN(  21)											while((_g52 < _g53)){
HXLINE(  21)												_g52 = (_g52 + 1);
HXDLIN(  21)												int i16 = (_g52 - 1);
HXDLIN(  21)												{
HXLINE(  21)													 ::haxe::ds::GenericCell_Int l2 = b20->data->head;
HXDLIN(  21)													 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  21)													{
HXLINE(  21)														int _g54 = 0;
HXDLIN(  21)														int _g55 = i16;
HXDLIN(  21)														while((_g54 < _g55)){
HXLINE(  21)															_g54 = (_g54 + 1);
HXDLIN(  21)															int i17 = (_g54 - 1);
HXLINE( 345)															prev2 = l2;
HXLINE( 346)															l2 = l2->next;
            														}
            													}
HXLINE(  21)													if (::hx::IsNull( prev2 )) {
HXLINE(  21)														b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  21)														l2 = null();
            													}
            													else {
HXLINE(  21)														prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  21)														l2 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage7 = b20;
            							}
            							break;
            						}
HXDLIN(  21)						this69->image = undoImage7;
HXDLIN(  21)						this69->width = width2;
HXDLIN(  21)						this69->height = height2;
HXDLIN(  21)						this69->imageType = ( (int)(imageType2) );
HXDLIN(  21)						undoImage6 = this69;
HXDLIN(  21)						{
HXLINE(  21)							int rectLeft2 = xIter32->start;
HXDLIN(  21)							int rectTop2 = yIter32->start;
HXDLIN(  21)							int rectRight2 = xIter32->max;
HXDLIN(  21)							bool forceClear2 = false;
HXDLIN(  21)							{
HXLINE(  21)								int _g56 = rectTop2;
HXDLIN(  21)								int _g57 = yIter32->max;
HXDLIN(  21)								while((_g56 < _g57)){
HXLINE(  21)									_g56 = (_g56 + 1);
HXDLIN(  21)									int dy4 = (_g56 - 1);
HXDLIN(  21)									{
HXLINE(  21)										int _g58 = rectLeft2;
HXDLIN(  21)										int _g59 = rectRight2;
HXDLIN(  21)										while((_g58 < _g59)){
HXLINE(  21)											_g58 = (_g58 + 1);
HXDLIN(  21)											int dx4 = (_g58 - 1);
HXDLIN(  21)											::Dynamic this71 = this68->image;
HXDLIN(  21)											int index10;
HXDLIN(  21)											if (this68->useVirtualPos) {
HXLINE(  21)												index10 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this68->virtualY) * ( (Float)(this68->width) )) + dx4) - this68->virtualX));
            											}
            											else {
HXLINE(  21)												index10 = ::Std_obj::_hx_int(( (Float)(((dy4 * this68->width) + dx4)) ));
            											}
HXDLIN(  21)											int c12 = ::iterMagic::Iimg_obj::get(this71,index10);
HXDLIN(  21)											int col2;
HXDLIN(  21)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)												col2 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            											}
            											else {
HXLINE(  21)												col2 = c12;
            											}
HXDLIN(  21)											bool _hx_tmp17;
HXDLIN(  21)											if (this68->useMask) {
HXLINE(  21)												_hx_tmp17 = ::hx::IsNotNull( this68->mask );
            											}
            											else {
HXLINE(  21)												_hx_tmp17 = false;
            											}
HXDLIN(  21)											if (_hx_tmp17) {
HXLINE(  21)												 ::pi_xy::ImageStruct this72 = this68->mask;
HXDLIN(  21)												::Dynamic this73 = this72->image;
HXDLIN(  21)												int index11;
HXDLIN(  21)												if (this72->useVirtualPos) {
HXLINE(  21)													index11 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this72->virtualY) * ( (Float)(this72->width) )) + dx4) - this72->virtualX));
            												}
            												else {
HXLINE(  21)													index11 = ::Std_obj::_hx_int(( (Float)(((dy4 * this72->width) + dx4)) ));
            												}
HXDLIN(  21)												int c13 = ::iterMagic::Iimg_obj::get(this73,index11);
HXDLIN(  21)												int v6;
HXDLIN(  21)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)													v6 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            												}
            												else {
HXLINE(  21)													v6 = c13;
            												}
HXDLIN(  21)												int maskPixel2 = v6;
HXDLIN(  21)												int this74 = col2;
HXDLIN(  21)												if ((maskPixel2 == 0)) {
HXLINE(  21)													col2 = this74;
            												}
            												else {
HXLINE(  21)													Float m02;
HXDLIN(  21)													int this75 = ((maskPixel2 >> 24) & 255);
HXDLIN(  21)													if ((this75 == 0)) {
HXLINE(  21)														m02 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m02 = (( (Float)(this75) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m12;
HXDLIN(  21)													int this76 = ((maskPixel2 >> 16) & 255);
HXDLIN(  21)													if ((this76 == 0)) {
HXLINE(  21)														m12 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m12 = (( (Float)(this76) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m22;
HXDLIN(  21)													int this77 = ((maskPixel2 >> 8) & 255);
HXDLIN(  21)													if ((this77 == 0)) {
HXLINE(  21)														m22 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m22 = (( (Float)(this77) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m32;
HXDLIN(  21)													int this78 = (maskPixel2 & 255);
HXDLIN(  21)													if ((this78 == 0)) {
HXLINE(  21)														m32 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m32 = (( (Float)(this78) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this74 >> 24) & 255)) )));
HXDLIN(  21)													int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this74 >> 16) & 255)) )));
HXDLIN(  21)													int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this74 >> 8) & 255)) )));
HXDLIN(  21)													int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this74 & 255)) )));
HXDLIN(  21)													col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  21)											if ((col2 != 0)) {
HXLINE(  21)												int x9 = (dx4 - rectLeft2);
HXDLIN(  21)												int y9 = (dy4 - rectTop2);
HXDLIN(  21)												int c14 = col2;
HXDLIN(  21)												bool _hx_tmp18;
HXDLIN(  21)												if ((((c14 >> 24) & 255) < 254)) {
HXLINE(  21)													_hx_tmp18 = undoImage6->transparent;
            												}
            												else {
HXLINE(  21)													_hx_tmp18 = false;
            												}
HXDLIN(  21)												if (_hx_tmp18) {
HXLINE(  21)													int location4;
HXDLIN(  21)													if (undoImage6->useVirtualPos) {
HXLINE(  21)														location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            													}
            													else {
HXLINE(  21)														location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            													}
HXDLIN(  21)													int this79 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN(  21)													int this80;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														this80 = ((((((this79 >> 24) & 255) << 24) | ((this79 & 255) << 16)) | (((this79 >> 8) & 255) << 8)) | ((this79 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														this80 = this79;
            													}
HXDLIN(  21)													Float a17;
HXDLIN(  21)													int this81 = ((this80 >> 24) & 255);
HXDLIN(  21)													if ((this81 == 0)) {
HXLINE(  21)														a17 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a17 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r14;
HXDLIN(  21)													int this82 = ((this80 >> 16) & 255);
HXDLIN(  21)													if ((this82 == 0)) {
HXLINE(  21)														r14 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r14 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g14;
HXDLIN(  21)													int this83 = ((this80 >> 8) & 255);
HXDLIN(  21)													if ((this83 == 0)) {
HXLINE(  21)														g14 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g14 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b110;
HXDLIN(  21)													int this84 = (this80 & 255);
HXDLIN(  21)													if ((this84 == 0)) {
HXLINE(  21)														b110 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b110 = (( (Float)(this84) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a24;
HXDLIN(  21)													int this85 = ((col2 >> 24) & 255);
HXDLIN(  21)													if ((this85 == 0)) {
HXLINE(  21)														a24 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a24 = (( (Float)(this85) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r24;
HXDLIN(  21)													int this86 = ((col2 >> 16) & 255);
HXDLIN(  21)													if ((this86 == 0)) {
HXLINE(  21)														r24 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r24 = (( (Float)(this86) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g24;
HXDLIN(  21)													int this87 = ((col2 >> 8) & 255);
HXDLIN(  21)													if ((this87 == 0)) {
HXLINE(  21)														g24 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g24 = (( (Float)(this87) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b25;
HXDLIN(  21)													int this88 = (col2 & 255);
HXDLIN(  21)													if ((this88 == 0)) {
HXLINE(  21)														b25 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b25 = (( (Float)(this88) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a34 = (a17 * (( (Float)(1) ) - a24));
HXDLIN(  21)													int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  21)													int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  21)													int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN(  21)													int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  21)													int blended4 = ((((a18 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN(  21)													{
HXLINE(  21)														int _hx_tmp19;
HXDLIN(  21)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)															_hx_tmp19 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXLINE(  21)															_hx_tmp19 = blended4;
            														}
HXDLIN(  21)														::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp19);
            													}
            												}
            												else {
HXLINE(  21)													::Dynamic this89 = undoImage6->image;
HXDLIN(  21)													int index12;
HXDLIN(  21)													if (undoImage6->useVirtualPos) {
HXLINE(  21)														index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            													}
            													else {
HXLINE(  21)														index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            													}
HXDLIN(  21)													int _hx_tmp20;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														_hx_tmp20 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														_hx_tmp20 = c14;
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this89,index12,_hx_tmp20);
            												}
            											}
            											else {
HXLINE(  21)												if (forceClear2) {
HXLINE(  21)													::Dynamic this90 = undoImage6->image;
HXDLIN(  21)													int x10 = (dx4 - rectLeft2);
HXDLIN(  21)													int y10 = (dy4 - rectTop2);
HXDLIN(  21)													int index13;
HXDLIN(  21)													if (undoImage6->useVirtualPos) {
HXLINE(  21)														index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            													}
            													else {
HXLINE(  21)														index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this90,index13,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  21)					bool found2 = false;
HXDLIN(  21)					Float min20 = ( (Float)(0) );
HXDLIN(  21)					Float max = ( (Float)(0) );
HXDLIN(  21)					int a19 = 0;
HXDLIN(  21)					int r7 = 0;
HXDLIN(  21)					int g7 = 0;
HXDLIN(  21)					int b27 = 0;
HXDLIN(  21)					{
HXLINE(  21)						int _g_min4 = xIter32->start;
HXDLIN(  21)						int _g_max4 = xIter32->max;
HXDLIN(  21)						while((_g_min4 < _g_max4)){
HXLINE(  21)							_g_min4 = (_g_min4 + 1);
HXDLIN(  21)							int px = (_g_min4 - 1);
HXDLIN(  21)							Float pcx = (( (Float)(px) ) - cx5);
HXLINE( 812)							found2 = false;
HXLINE(  21)							{
HXLINE(  21)								int _g_min5 = yIter32->start;
HXDLIN(  21)								int _g_max5 = yIter32->max;
HXDLIN(  21)								while((_g_min5 < _g_max5)){
HXLINE(  21)									_g_min5 = (_g_min5 + 1);
HXDLIN(  21)									int py = (_g_min5 - 1);
HXDLIN(  21)									Float pcy = (( (Float)(py) ) - cy5);
HXDLIN(  21)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  21)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  21)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  21)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  21)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  21)									bool _hx_tmp21;
HXDLIN(  21)									bool _hx_tmp22;
HXDLIN(  21)									if ((ratioA >= 0)) {
HXLINE(  21)										_hx_tmp22 = (ratioB >= 0);
            									}
            									else {
HXLINE(  21)										_hx_tmp22 = false;
            									}
HXDLIN(  21)									if (_hx_tmp22) {
HXLINE(  21)										_hx_tmp21 = (ratioC >= 0);
            									}
            									else {
HXLINE(  21)										_hx_tmp21 = false;
            									}
HXDLIN(  21)									if (_hx_tmp21) {
HXLINE(  21)										int i18 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  21)										if ((i18 > 255)) {
HXLINE(  24)											i18 = 255;
            										}
HXLINE(  21)										if ((i18 < 0)) {
HXLINE(  25)											i18 = 0;
            										}
HXLINE( 821)										r7 = i18;
HXLINE(  21)										int i19 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  21)										if ((i19 > 255)) {
HXLINE(  24)											i19 = 255;
            										}
HXLINE(  21)										if ((i19 < 0)) {
HXLINE(  25)											i19 = 0;
            										}
HXLINE( 822)										g7 = i19;
HXLINE(  21)										int i20 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  21)										if ((i20 > 255)) {
HXLINE(  24)											i20 = 255;
            										}
HXLINE(  21)										if ((i20 < 0)) {
HXLINE(  25)											i20 = 0;
            										}
HXLINE( 823)										b27 = i20;
HXLINE(  21)										{
HXLINE(  21)											if ((ratioB < ratioC)) {
HXLINE(  21)												min20 = ratioB;
            											}
            											else {
HXLINE(  21)												min20 = ratioC;
            											}
HXDLIN(  21)											if ((ratioA > ratioB)) {
HXLINE(  21)												max = ratioA;
            											}
            											else {
HXLINE(  21)												max = ratioB;
            											}
HXDLIN(  21)											if (!((max > ratioC))) {
HXLINE(  21)												max = ratioC;
            											}
HXLINE( 842)											max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  21)											if (!((min20 < max))) {
HXLINE(  21)												min20 = ((max + min20) / ( (Float)(2) ));
            											}
HXDLIN(  21)											int i21 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min20));
HXDLIN(  21)											if ((i21 > 255)) {
HXLINE(  24)												i21 = 255;
            											}
HXLINE(  21)											if ((i21 < 0)) {
HXLINE(  25)												i21 = 0;
            											}
HXLINE( 845)											a19 = i21;
HXLINE(  21)											{
HXLINE(  21)												int location5;
HXDLIN(  21)												if (this68->useVirtualPos) {
HXLINE(  21)													location5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this68->virtualY) * ( (Float)(this68->width) )) + px) - this68->virtualX));
            												}
            												else {
HXLINE(  21)													location5 = ::Std_obj::_hx_int(( (Float)(((py * this68->width) + px)) ));
            												}
HXDLIN(  21)												bool _hx_tmp23;
HXDLIN(  21)												if (this68->transparent) {
HXLINE(  21)													_hx_tmp23 = (a19 < 254);
            												}
            												else {
HXLINE(  21)													_hx_tmp23 = false;
            												}
HXDLIN(  21)												if (_hx_tmp23) {
HXLINE(  21)													int this91 = ::iterMagic::Iimg_obj::get(this68->image,location5);
HXDLIN(  21)													int old;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														old = ((((((this91 >> 24) & 255) << 24) | ((this91 & 255) << 16)) | (((this91 >> 8) & 255) << 8)) | ((this91 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														old = this91;
            													}
HXDLIN(  21)													int rhs = ((((a19 << 24) | (r7 << 16)) | (g7 << 8)) | b27);
HXDLIN(  21)													Float a110;
HXDLIN(  21)													int this92 = ((old >> 24) & 255);
HXDLIN(  21)													if ((this92 == 0)) {
HXLINE(  21)														a110 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a110 = (( (Float)(this92) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r15;
HXDLIN(  21)													int this93 = ((old >> 16) & 255);
HXDLIN(  21)													if ((this93 == 0)) {
HXLINE(  21)														r15 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r15 = (( (Float)(this93) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g15;
HXDLIN(  21)													int this94 = ((old >> 8) & 255);
HXDLIN(  21)													if ((this94 == 0)) {
HXLINE(  21)														g15 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g15 = (( (Float)(this94) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b111;
HXDLIN(  21)													int this95 = (old & 255);
HXDLIN(  21)													if ((this95 == 0)) {
HXLINE(  21)														b111 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b111 = (( (Float)(this95) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a25;
HXDLIN(  21)													int this96 = ((rhs >> 24) & 255);
HXDLIN(  21)													if ((this96 == 0)) {
HXLINE(  21)														a25 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a25 = (( (Float)(this96) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r25;
HXDLIN(  21)													int this97 = ((rhs >> 16) & 255);
HXDLIN(  21)													if ((this97 == 0)) {
HXLINE(  21)														r25 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r25 = (( (Float)(this97) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g25;
HXDLIN(  21)													int this98 = ((rhs >> 8) & 255);
HXDLIN(  21)													if ((this98 == 0)) {
HXLINE(  21)														g25 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g25 = (( (Float)(this98) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b28;
HXDLIN(  21)													int this99 = (rhs & 255);
HXDLIN(  21)													if ((this99 == 0)) {
HXLINE(  21)														b28 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b28 = (( (Float)(this99) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN(  21)													int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  21)													int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  21)													int b29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b28 * a25))));
HXDLIN(  21)													int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  21)													int blended5 = ((((a20 << 24) | (r8 << 16)) | (g8 << 8)) | b29);
HXDLIN(  21)													{
HXLINE(  21)														int _hx_tmp24;
HXDLIN(  21)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)															_hx_tmp24 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            														}
            														else {
HXLINE(  21)															_hx_tmp24 = blended5;
            														}
HXDLIN(  21)														::iterMagic::Iimg_obj::set(this68->image,location5,_hx_tmp24);
            													}
            												}
            												else {
HXLINE(  21)													int value;
HXDLIN(  21)													if (this68->isLittle) {
HXLINE(  21)														value = ((((a19 << 24) | (b27 << 16)) | (g7 << 8)) | r7);
            													}
            													else {
HXLINE(  21)														value = ((((a19 << 24) | (r7 << 16)) | (g7 << 8)) | b27);
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this68->image,location5,value);
            												}
            											}
            										}
HXLINE( 850)										found2 = true;
            									}
            									else {
HXLINE(  21)										if (found2) {
HXLINE(  21)											goto _hx_goto_37;
            										}
            									}
            								}
            								_hx_goto_37:;
            							}
            						}
            					}
HXDLIN(  21)					if ((hasHit == false)) {
HXLINE(  21)						 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax3,ay3,bx5,by5,cx5,cy5,true);
HXDLIN(  21)						if (hasUndo2) {
HXLINE(  21)							v7->undoImage = undoImage6;
HXDLIN(  21)							v7->undoX = xIter32->start;
HXDLIN(  21)							v7->undoY = yIter32->start;
            						}
            					}
            				}
HXDLIN(  21)				{
HXLINE(  21)					bool hasUndo3 = true;
HXDLIN(  21)					int aA1 = ((color1 >> 24) & 255);
HXDLIN(  21)					int rA1 = ((color1 >> 16) & 255);
HXDLIN(  21)					int gA1 = ((color1 >> 8) & 255);
HXDLIN(  21)					int bA1 = (color1 & 255);
HXDLIN(  21)					Float bcx1 = (cx5 - ax3);
HXDLIN(  21)					Float bcy1 = (cy5 - ay3);
HXDLIN(  21)					Float acx1 = (dx3 - ax3);
HXDLIN(  21)					Float acy1 = (dy3 - ay3);
HXDLIN(  21)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  21)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  21)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  21)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  21)					 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  21)					if ((dx3 > cx5)) {
HXLINE(  21)						if ((dx3 > ax3)) {
HXLINE(  21)							int min21;
HXDLIN(  21)							if ((cx5 > ax3)) {
HXLINE(  21)								min21 = ::Math_obj::floor(ax3);
            							}
            							else {
HXLINE(  21)								min21 = ::Math_obj::floor(cx5);
            							}
HXDLIN(  21)							int ii_min40 = min21;
HXDLIN(  21)							int ii_max40 = ::Math_obj::ceil(dx3);
HXDLIN(  21)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            						}
            						else {
HXLINE(  21)							int ii_min41 = ::Math_obj::floor(cx5);
HXDLIN(  21)							int ii_max41 = ::Math_obj::ceil(ax3);
HXDLIN(  21)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            						}
            					}
            					else {
HXLINE(  21)						if ((cx5 > ax3)) {
HXLINE(  21)							int min22;
HXDLIN(  21)							if ((dx3 > ax3)) {
HXLINE(  21)								min22 = ::Math_obj::floor(ax3);
            							}
            							else {
HXLINE(  21)								min22 = ::Math_obj::ceil(dx3);
            							}
HXDLIN(  21)							int ii_min42 = min22;
HXDLIN(  21)							int ii_max42 = ::Math_obj::ceil(cx5);
HXDLIN(  21)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            						}
            						else {
HXLINE(  21)							int ii_min43 = ::Math_obj::floor(dx3);
HXDLIN(  21)							int ii_max43 = ::Math_obj::ceil(ax3);
HXDLIN(  21)							xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            						}
            					}
HXDLIN(  21)					 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  21)					if ((dy3 > cy5)) {
HXLINE(  21)						if ((dy3 > ay3)) {
HXLINE(  21)							int min23;
HXDLIN(  21)							if ((cy5 > ay3)) {
HXLINE(  21)								min23 = ::Math_obj::floor(ay3);
            							}
            							else {
HXLINE(  21)								min23 = ::Math_obj::floor(cy5);
            							}
HXDLIN(  21)							int ii_min44 = min23;
HXDLIN(  21)							int ii_max44 = ::Math_obj::ceil(dy3);
HXDLIN(  21)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            						}
            						else {
HXLINE(  21)							int ii_min45 = ::Math_obj::floor(cy5);
HXDLIN(  21)							int ii_max45 = ::Math_obj::ceil(ay3);
HXDLIN(  21)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            						}
            					}
            					else {
HXLINE(  21)						if ((cy5 > ay3)) {
HXLINE(  21)							int min24;
HXDLIN(  21)							if ((dy3 > ay3)) {
HXLINE(  21)								min24 = ::Math_obj::floor(ay3);
            							}
            							else {
HXLINE(  21)								min24 = ::Math_obj::ceil(dy3);
            							}
HXDLIN(  21)							int ii_min46 = min24;
HXDLIN(  21)							int ii_max46 = ::Math_obj::ceil(cy5);
HXDLIN(  21)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            						}
            						else {
HXLINE(  21)							int ii_min47 = ::Math_obj::floor(dy3);
HXDLIN(  21)							int ii_max47 = ::Math_obj::ceil(ay3);
HXDLIN(  21)							yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            						}
            					}
HXDLIN(  21)					 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  21)					if (hasUndo3) {
HXLINE(  21)						int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  21)						int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  21)						 ::Dynamic imageType3 = null();
HXDLIN(  21)						 ::pi_xy::ImageStruct this100 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  21)						if (::hx::IsNull( imageType3 )) {
HXLINE(  54)							imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  21)						::Dynamic undoImage10;
HXDLIN(  21)						switch((int)(( (int)(imageType3) ))){
            							case (int)0: {
HXLINE(  21)								 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::BytesImg b30 = byt3;
HXDLIN(  21)								{
HXLINE(  21)									b30->width = width3;
HXDLIN(  21)									b30->height = height3;
HXDLIN(  21)									b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  21)									b30->data = ::haxe::io::Bytes_obj::alloc((b30->length * 4));
HXDLIN(  21)									{
HXLINE(  21)										int len6 = b30->length;
HXDLIN(  21)										int w3 = 0;
HXDLIN(  21)										{
HXLINE(  21)											int _g60 = 0;
HXDLIN(  21)											int _g61 = b30->height;
HXDLIN(  21)											while((_g60 < _g61)){
HXLINE(  21)												_g60 = (_g60 + 1);
HXDLIN(  21)												int y11 = (_g60 - 1);
HXDLIN(  21)												{
HXLINE(  21)													int _g62 = 0;
HXDLIN(  21)													int _g63 = b30->width;
HXDLIN(  21)													while((_g62 < _g63)){
HXLINE(  21)														_g62 = (_g62 + 1);
HXDLIN(  21)														int x11 = (_g62 - 1);
HXDLIN(  21)														{
HXLINE(  21)															w3 = (w3 + 1);
HXDLIN(  21)															b30->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w3 = (w3 + 1);
HXDLIN(  21)															b30->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w3 = (w3 + 1);
HXDLIN(  21)															b30->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w3 = (w3 + 1);
HXDLIN(  21)															b30->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage10 = b30;
            							}
            							break;
            							case (int)1: {
HXLINE(  21)								 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::ArrIntImg a26 = arrI3;
HXDLIN(  21)								{
HXLINE(  21)									a26->width = width3;
HXDLIN(  21)									a26->height = height3;
HXDLIN(  21)									a26->data = ::Array_obj< int >::__new(0);
HXDLIN(  21)									a26->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  21)									{
HXLINE(  21)										int _g64 = 0;
HXDLIN(  21)										int _g65 = a26->length;
HXDLIN(  21)										while((_g64 < _g65)){
HXLINE(  21)											_g64 = (_g64 + 1);
HXDLIN(  21)											int i22 = (_g64 - 1);
HXDLIN(  21)											a26->data[i22] = 0;
            										}
            									}
            								}
HXDLIN(  21)								undoImage10 = a26;
            							}
            							break;
            							case (int)2: {
HXLINE(  21)								 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::U32ArrImg b31 = u32a3;
HXDLIN(  21)								{
HXLINE(  21)									b31->width = width3;
HXDLIN(  21)									b31->height = height3;
HXDLIN(  21)									b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  21)									int size3 = (b31->length * 4);
HXDLIN(  21)									b31->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  21)									{
HXLINE(  21)										int _g66 = 0;
HXDLIN(  21)										int _g67 = b31->length;
HXDLIN(  21)										while((_g66 < _g67)){
HXLINE(  21)											_g66 = (_g66 + 1);
HXDLIN(  21)											int i23 = (_g66 - 1);
HXDLIN(  21)											{
HXLINE(  21)												 ::haxe::io::ArrayBufferViewImpl this101 = b31->data;
HXDLIN(  21)												bool undoImage11;
HXDLIN(  21)												if ((i23 >= 0)) {
HXLINE(  21)													undoImage11 = (i23 < (this101->byteLength >> 2));
            												}
            												else {
HXLINE(  21)													undoImage11 = false;
            												}
HXDLIN(  21)												if (undoImage11) {
HXLINE(  21)													 ::haxe::io::Bytes _this3 = this101->bytes;
HXDLIN(  21)													int pos3 = ((i23 << 2) + this101->byteOffset);
HXDLIN(  21)													_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  21)													_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  21)													_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  21)													_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage10 = b31;
            							}
            							break;
            							case (int)3: {
HXLINE(  21)								 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::VecIntImg v8 = vec3;
HXDLIN(  21)								{
HXLINE(  21)									v8->width = width3;
HXDLIN(  21)									v8->height = height3;
HXDLIN(  21)									v8->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  21)									v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN(  21)									{
HXLINE(  21)										int _g68 = 0;
HXDLIN(  21)										int _g69 = v8->length;
HXDLIN(  21)										while((_g68 < _g69)){
HXLINE(  21)											_g68 = (_g68 + 1);
HXDLIN(  21)											int i24 = (_g68 - 1);
HXDLIN(  21)											v8->data->__unsafe_set(i24,0);
            										}
            									}
            								}
HXDLIN(  21)								undoImage10 = v8;
            							}
            							break;
            							case (int)4: {
HXLINE(  21)								 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::StackIntImg b32 = sInt3;
HXDLIN(  21)								{
HXLINE(  21)									b32->width = width3;
HXDLIN(  21)									b32->height = height3;
HXDLIN(  21)									b32->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  21)									b32->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  21)									{
HXLINE(  21)										int len7 = b32->length;
HXDLIN(  21)										 ::haxe::ds::GenericStack_Int d3 = b32->data;
HXDLIN(  21)										if (::hx::IsNull( d3->head )) {
HXLINE(  21)											int _g70 = 0;
HXDLIN(  21)											int _g71 = len7;
HXDLIN(  21)											while((_g70 < _g71)){
HXLINE(  21)												_g70 = (_g70 + 1);
HXDLIN(  21)												int i25 = (_g70 - 1);
HXDLIN(  21)												d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            											}
            										}
            										else {
HXLINE(  21)											int _g72 = 0;
HXDLIN(  21)											int _g73 = len7;
HXDLIN(  21)											while((_g72 < _g73)){
HXLINE(  21)												_g72 = (_g72 + 1);
HXDLIN(  21)												int i26 = (_g72 - 1);
HXDLIN(  21)												{
HXLINE(  21)													 ::haxe::ds::GenericCell_Int l3 = b32->data->head;
HXDLIN(  21)													 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  21)													{
HXLINE(  21)														int _g74 = 0;
HXDLIN(  21)														int _g75 = i26;
HXDLIN(  21)														while((_g74 < _g75)){
HXLINE(  21)															_g74 = (_g74 + 1);
HXDLIN(  21)															int i27 = (_g74 - 1);
HXLINE( 345)															prev3 = l3;
HXLINE( 346)															l3 = l3->next;
            														}
            													}
HXLINE(  21)													if (::hx::IsNull( prev3 )) {
HXLINE(  21)														b32->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  21)														l3 = null();
            													}
            													else {
HXLINE(  21)														prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  21)														l3 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage10 = b32;
            							}
            							break;
            						}
HXDLIN(  21)						this100->image = undoImage10;
HXDLIN(  21)						this100->width = width3;
HXDLIN(  21)						this100->height = height3;
HXDLIN(  21)						this100->imageType = ( (int)(imageType3) );
HXDLIN(  21)						undoImage9 = this100;
HXDLIN(  21)						{
HXLINE(  21)							int rectLeft3 = xIter33->start;
HXDLIN(  21)							int rectTop3 = yIter33->start;
HXDLIN(  21)							int rectRight3 = xIter33->max;
HXDLIN(  21)							bool forceClear3 = false;
HXDLIN(  21)							{
HXLINE(  21)								int _g76 = rectTop3;
HXDLIN(  21)								int _g77 = yIter33->max;
HXDLIN(  21)								while((_g76 < _g77)){
HXLINE(  21)									_g76 = (_g76 + 1);
HXDLIN(  21)									int dy5 = (_g76 - 1);
HXDLIN(  21)									{
HXLINE(  21)										int _g78 = rectLeft3;
HXDLIN(  21)										int _g79 = rectRight3;
HXDLIN(  21)										while((_g78 < _g79)){
HXLINE(  21)											_g78 = (_g78 + 1);
HXDLIN(  21)											int dx5 = (_g78 - 1);
HXDLIN(  21)											::Dynamic this102 = this68->image;
HXDLIN(  21)											int index14;
HXDLIN(  21)											if (this68->useVirtualPos) {
HXLINE(  21)												index14 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this68->virtualY) * ( (Float)(this68->width) )) + dx5) - this68->virtualX));
            											}
            											else {
HXLINE(  21)												index14 = ::Std_obj::_hx_int(( (Float)(((dy5 * this68->width) + dx5)) ));
            											}
HXDLIN(  21)											int c15 = ::iterMagic::Iimg_obj::get(this102,index14);
HXDLIN(  21)											int col3;
HXDLIN(  21)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)												col3 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            											}
            											else {
HXLINE(  21)												col3 = c15;
            											}
HXDLIN(  21)											bool _hx_tmp25;
HXDLIN(  21)											if (this68->useMask) {
HXLINE(  21)												_hx_tmp25 = ::hx::IsNotNull( this68->mask );
            											}
            											else {
HXLINE(  21)												_hx_tmp25 = false;
            											}
HXDLIN(  21)											if (_hx_tmp25) {
HXLINE(  21)												 ::pi_xy::ImageStruct this103 = this68->mask;
HXDLIN(  21)												::Dynamic this104 = this103->image;
HXDLIN(  21)												int index15;
HXDLIN(  21)												if (this103->useVirtualPos) {
HXLINE(  21)													index15 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this103->virtualY) * ( (Float)(this103->width) )) + dx5) - this103->virtualX));
            												}
            												else {
HXLINE(  21)													index15 = ::Std_obj::_hx_int(( (Float)(((dy5 * this103->width) + dx5)) ));
            												}
HXDLIN(  21)												int c16 = ::iterMagic::Iimg_obj::get(this104,index15);
HXDLIN(  21)												int v9;
HXDLIN(  21)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)													v9 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            												}
            												else {
HXLINE(  21)													v9 = c16;
            												}
HXDLIN(  21)												int maskPixel3 = v9;
HXDLIN(  21)												int this105 = col3;
HXDLIN(  21)												if ((maskPixel3 == 0)) {
HXLINE(  21)													col3 = this105;
            												}
            												else {
HXLINE(  21)													Float m03;
HXDLIN(  21)													int this106 = ((maskPixel3 >> 24) & 255);
HXDLIN(  21)													if ((this106 == 0)) {
HXLINE(  21)														m03 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m03 = (( (Float)(this106) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m13;
HXDLIN(  21)													int this107 = ((maskPixel3 >> 16) & 255);
HXDLIN(  21)													if ((this107 == 0)) {
HXLINE(  21)														m13 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m13 = (( (Float)(this107) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m23;
HXDLIN(  21)													int this108 = ((maskPixel3 >> 8) & 255);
HXDLIN(  21)													if ((this108 == 0)) {
HXLINE(  21)														m23 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m23 = (( (Float)(this108) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m33;
HXDLIN(  21)													int this109 = (maskPixel3 & 255);
HXDLIN(  21)													if ((this109 == 0)) {
HXLINE(  21)														m33 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m33 = (( (Float)(this109) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this105 >> 24) & 255)) )));
HXDLIN(  21)													int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this105 >> 16) & 255)) )));
HXDLIN(  21)													int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this105 >> 8) & 255)) )));
HXDLIN(  21)													int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this105 & 255)) )));
HXDLIN(  21)													col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  21)											if ((col3 != 0)) {
HXLINE(  21)												int x12 = (dx5 - rectLeft3);
HXDLIN(  21)												int y12 = (dy5 - rectTop3);
HXDLIN(  21)												int c17 = col3;
HXDLIN(  21)												bool _hx_tmp26;
HXDLIN(  21)												if ((((c17 >> 24) & 255) < 254)) {
HXLINE(  21)													_hx_tmp26 = undoImage9->transparent;
            												}
            												else {
HXLINE(  21)													_hx_tmp26 = false;
            												}
HXDLIN(  21)												if (_hx_tmp26) {
HXLINE(  21)													int location6;
HXDLIN(  21)													if (undoImage9->useVirtualPos) {
HXLINE(  21)														location6 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x12) - undoImage9->virtualX));
            													}
            													else {
HXLINE(  21)														location6 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage9->width) + x12)) ));
            													}
HXDLIN(  21)													int this110 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN(  21)													int this111;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														this111 = ((((((this110 >> 24) & 255) << 24) | ((this110 & 255) << 16)) | (((this110 >> 8) & 255) << 8)) | ((this110 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														this111 = this110;
            													}
HXDLIN(  21)													Float a111;
HXDLIN(  21)													int this112 = ((this111 >> 24) & 255);
HXDLIN(  21)													if ((this112 == 0)) {
HXLINE(  21)														a111 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a111 = (( (Float)(this112) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r16;
HXDLIN(  21)													int this113 = ((this111 >> 16) & 255);
HXDLIN(  21)													if ((this113 == 0)) {
HXLINE(  21)														r16 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r16 = (( (Float)(this113) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g16;
HXDLIN(  21)													int this114 = ((this111 >> 8) & 255);
HXDLIN(  21)													if ((this114 == 0)) {
HXLINE(  21)														g16 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g16 = (( (Float)(this114) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b112;
HXDLIN(  21)													int this115 = (this111 & 255);
HXDLIN(  21)													if ((this115 == 0)) {
HXLINE(  21)														b112 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b112 = (( (Float)(this115) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a27;
HXDLIN(  21)													int this116 = ((col3 >> 24) & 255);
HXDLIN(  21)													if ((this116 == 0)) {
HXLINE(  21)														a27 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a27 = (( (Float)(this116) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r26;
HXDLIN(  21)													int this117 = ((col3 >> 16) & 255);
HXDLIN(  21)													if ((this117 == 0)) {
HXLINE(  21)														r26 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r26 = (( (Float)(this117) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g26;
HXDLIN(  21)													int this118 = ((col3 >> 8) & 255);
HXDLIN(  21)													if ((this118 == 0)) {
HXLINE(  21)														g26 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g26 = (( (Float)(this118) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b210;
HXDLIN(  21)													int this119 = (col3 & 255);
HXDLIN(  21)													if ((this119 == 0)) {
HXLINE(  21)														b210 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b210 = (( (Float)(this119) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a36 = (a111 * (( (Float)(1) ) - a27));
HXDLIN(  21)													int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a27))));
HXDLIN(  21)													int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a27))));
HXDLIN(  21)													int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a27))));
HXDLIN(  21)													int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a27)));
HXDLIN(  21)													int blended6 = ((((a28 << 24) | (r9 << 16)) | (g9 << 8)) | b33);
HXDLIN(  21)													{
HXLINE(  21)														int _hx_tmp27;
HXDLIN(  21)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)															_hx_tmp27 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            														}
            														else {
HXLINE(  21)															_hx_tmp27 = blended6;
            														}
HXDLIN(  21)														::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp27);
            													}
            												}
            												else {
HXLINE(  21)													::Dynamic this120 = undoImage9->image;
HXDLIN(  21)													int index16;
HXDLIN(  21)													if (undoImage9->useVirtualPos) {
HXLINE(  21)														index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x12) - undoImage9->virtualX));
            													}
            													else {
HXLINE(  21)														index16 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage9->width) + x12)) ));
            													}
HXDLIN(  21)													int _hx_tmp28;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														_hx_tmp28 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														_hx_tmp28 = c17;
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this120,index16,_hx_tmp28);
            												}
            											}
            											else {
HXLINE(  21)												if (forceClear3) {
HXLINE(  21)													::Dynamic this121 = undoImage9->image;
HXDLIN(  21)													int x13 = (dx5 - rectLeft3);
HXDLIN(  21)													int y13 = (dy5 - rectTop3);
HXDLIN(  21)													int index17;
HXDLIN(  21)													if (undoImage9->useVirtualPos) {
HXLINE(  21)														index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            													}
            													else {
HXLINE(  21)														index17 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this121,index17,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  21)					bool found3 = false;
HXDLIN(  21)					Float min25 = ( (Float)(0) );
HXDLIN(  21)					Float max1 = ( (Float)(0) );
HXDLIN(  21)					int a29 = 0;
HXDLIN(  21)					int r10 = 0;
HXDLIN(  21)					int g10 = 0;
HXDLIN(  21)					int b34 = 0;
HXDLIN(  21)					{
HXLINE(  21)						int _g_min6 = xIter33->start;
HXDLIN(  21)						int _g_max6 = xIter33->max;
HXDLIN(  21)						while((_g_min6 < _g_max6)){
HXLINE(  21)							_g_min6 = (_g_min6 + 1);
HXDLIN(  21)							int px1 = (_g_min6 - 1);
HXDLIN(  21)							Float pcx1 = (( (Float)(px1) ) - ax3);
HXLINE( 812)							found3 = false;
HXLINE(  21)							{
HXLINE(  21)								int _g_min7 = yIter33->start;
HXDLIN(  21)								int _g_max7 = yIter33->max;
HXDLIN(  21)								while((_g_min7 < _g_max7)){
HXLINE(  21)									_g_min7 = (_g_min7 + 1);
HXDLIN(  21)									int py1 = (_g_min7 - 1);
HXDLIN(  21)									Float pcy1 = (( (Float)(py1) ) - ay3);
HXDLIN(  21)									Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  21)									Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  21)									Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  21)									Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  21)									Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  21)									bool _hx_tmp29;
HXDLIN(  21)									bool _hx_tmp30;
HXDLIN(  21)									if ((ratioA1 >= 0)) {
HXLINE(  21)										_hx_tmp30 = (ratioB1 >= 0);
            									}
            									else {
HXLINE(  21)										_hx_tmp30 = false;
            									}
HXDLIN(  21)									if (_hx_tmp30) {
HXLINE(  21)										_hx_tmp29 = (ratioC1 >= 0);
            									}
            									else {
HXLINE(  21)										_hx_tmp29 = false;
            									}
HXDLIN(  21)									if (_hx_tmp29) {
HXLINE(  21)										int i28 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  21)										if ((i28 > 255)) {
HXLINE(  24)											i28 = 255;
            										}
HXLINE(  21)										if ((i28 < 0)) {
HXLINE(  25)											i28 = 0;
            										}
HXLINE( 821)										r10 = i28;
HXLINE(  21)										int i29 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  21)										if ((i29 > 255)) {
HXLINE(  24)											i29 = 255;
            										}
HXLINE(  21)										if ((i29 < 0)) {
HXLINE(  25)											i29 = 0;
            										}
HXLINE( 822)										g10 = i29;
HXLINE(  21)										int i30 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  21)										if ((i30 > 255)) {
HXLINE(  24)											i30 = 255;
            										}
HXLINE(  21)										if ((i30 < 0)) {
HXLINE(  25)											i30 = 0;
            										}
HXLINE( 823)										b34 = i30;
HXLINE(  21)										{
HXLINE(  21)											if ((ratioA1 < ratioC1)) {
HXLINE(  21)												min25 = ratioA1;
            											}
            											else {
HXLINE(  21)												min25 = ratioC1;
            											}
HXDLIN(  21)											if ((ratioA1 > ratioB1)) {
HXLINE(  21)												max1 = ratioA1;
            											}
            											else {
HXLINE(  21)												max1 = ratioB1;
            											}
HXDLIN(  21)											if (!((max1 > ratioC1))) {
HXLINE(  21)												max1 = ratioC1;
            											}
HXLINE( 829)											max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  21)											if (!((min25 < max1))) {
HXLINE(  21)												min25 = ((max1 + min25) / ( (Float)(2) ));
            											}
HXDLIN(  21)											int i31 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min25));
HXDLIN(  21)											if ((i31 > 255)) {
HXLINE(  24)												i31 = 255;
            											}
HXLINE(  21)											if ((i31 < 0)) {
HXLINE(  25)												i31 = 0;
            											}
HXLINE( 832)											a29 = i31;
HXLINE(  21)											{
HXLINE(  21)												int location7;
HXDLIN(  21)												if (this68->useVirtualPos) {
HXLINE(  21)													location7 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this68->virtualY) * ( (Float)(this68->width) )) + px1) - this68->virtualX));
            												}
            												else {
HXLINE(  21)													location7 = ::Std_obj::_hx_int(( (Float)(((py1 * this68->width) + px1)) ));
            												}
HXDLIN(  21)												bool _hx_tmp31;
HXDLIN(  21)												if (this68->transparent) {
HXLINE(  21)													_hx_tmp31 = (a29 < 254);
            												}
            												else {
HXLINE(  21)													_hx_tmp31 = false;
            												}
HXDLIN(  21)												if (_hx_tmp31) {
HXLINE(  21)													int this122 = ::iterMagic::Iimg_obj::get(this68->image,location7);
HXDLIN(  21)													int old1;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														old1 = ((((((this122 >> 24) & 255) << 24) | ((this122 & 255) << 16)) | (((this122 >> 8) & 255) << 8)) | ((this122 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														old1 = this122;
            													}
HXDLIN(  21)													int rhs1 = ((((a29 << 24) | (r10 << 16)) | (g10 << 8)) | b34);
HXDLIN(  21)													Float a112;
HXDLIN(  21)													int this123 = ((old1 >> 24) & 255);
HXDLIN(  21)													if ((this123 == 0)) {
HXLINE(  21)														a112 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a112 = (( (Float)(this123) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r17;
HXDLIN(  21)													int this124 = ((old1 >> 16) & 255);
HXDLIN(  21)													if ((this124 == 0)) {
HXLINE(  21)														r17 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r17 = (( (Float)(this124) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g17;
HXDLIN(  21)													int this125 = ((old1 >> 8) & 255);
HXDLIN(  21)													if ((this125 == 0)) {
HXLINE(  21)														g17 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g17 = (( (Float)(this125) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b113;
HXDLIN(  21)													int this126 = (old1 & 255);
HXDLIN(  21)													if ((this126 == 0)) {
HXLINE(  21)														b113 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b113 = (( (Float)(this126) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a210;
HXDLIN(  21)													int this127 = ((rhs1 >> 24) & 255);
HXDLIN(  21)													if ((this127 == 0)) {
HXLINE(  21)														a210 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a210 = (( (Float)(this127) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r27;
HXDLIN(  21)													int this128 = ((rhs1 >> 16) & 255);
HXDLIN(  21)													if ((this128 == 0)) {
HXLINE(  21)														r27 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r27 = (( (Float)(this128) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g27;
HXDLIN(  21)													int this129 = ((rhs1 >> 8) & 255);
HXDLIN(  21)													if ((this129 == 0)) {
HXLINE(  21)														g27 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g27 = (( (Float)(this129) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b211;
HXDLIN(  21)													int this130 = (rhs1 & 255);
HXDLIN(  21)													if ((this130 == 0)) {
HXLINE(  21)														b211 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b211 = (( (Float)(this130) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a37 = (a112 * (( (Float)(1) ) - a210));
HXDLIN(  21)													int r18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a210))));
HXDLIN(  21)													int g18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a210))));
HXDLIN(  21)													int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a210))));
HXDLIN(  21)													int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a210)));
HXDLIN(  21)													int blended7 = ((((a30 << 24) | (r18 << 16)) | (g18 << 8)) | b35);
HXDLIN(  21)													{
HXLINE(  21)														int _hx_tmp32;
HXDLIN(  21)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)															_hx_tmp32 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            														}
            														else {
HXLINE(  21)															_hx_tmp32 = blended7;
            														}
HXDLIN(  21)														::iterMagic::Iimg_obj::set(this68->image,location7,_hx_tmp32);
            													}
            												}
            												else {
HXLINE(  21)													int value1;
HXDLIN(  21)													if (this68->isLittle) {
HXLINE(  21)														value1 = ((((a29 << 24) | (b34 << 16)) | (g10 << 8)) | r10);
            													}
            													else {
HXLINE(  21)														value1 = ((((a29 << 24) | (r10 << 16)) | (g10 << 8)) | b34);
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this68->image,location7,value1);
            												}
            											}
            										}
HXLINE( 850)										found3 = true;
            									}
            									else {
HXLINE(  21)										if (found3) {
HXLINE(  21)											goto _hx_goto_49;
            										}
            									}
            								}
            								_hx_goto_49:;
            							}
            						}
            					}
HXDLIN(  21)					if ((hasHit == false)) {
HXLINE(  21)						 ::pi_xy::algo::HitTri v10 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,dx3,dy3,cx5,cy5,ax3,ay3,true);
HXDLIN(  21)						if (hasUndo3) {
HXLINE(  21)							v10->undoImage = undoImage9;
HXDLIN(  21)							v10->undoX = xIter33->start;
HXDLIN(  21)							v10->undoY = yIter33->start;
            						}
            					}
            				}
HXDLIN(  21)				{
HXLINE(  21)					bool hasUndo4 = true;
HXDLIN(  21)					int aA2 = ((color1 >> 24) & 255);
HXDLIN(  21)					int rA2 = ((color1 >> 16) & 255);
HXDLIN(  21)					int gA2 = ((color1 >> 8) & 255);
HXDLIN(  21)					int bA2 = (color1 & 255);
HXDLIN(  21)					Float bcx2 = (bx5 - dx3);
HXDLIN(  21)					Float bcy2 = (by5 - dy3);
HXDLIN(  21)					Float acx2 = (ax3 - dx3);
HXDLIN(  21)					Float acy2 = (ay3 - dy3);
HXDLIN(  21)					Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  21)					Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  21)					Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  21)					Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  21)					 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN(  21)					if ((ax3 > bx5)) {
HXLINE(  21)						if ((ax3 > dx3)) {
HXLINE(  21)							int min26;
HXDLIN(  21)							if ((bx5 > dx3)) {
HXLINE(  21)								min26 = ::Math_obj::floor(dx3);
            							}
            							else {
HXLINE(  21)								min26 = ::Math_obj::floor(bx5);
            							}
HXDLIN(  21)							int ii_min48 = min26;
HXDLIN(  21)							int ii_max48 = ::Math_obj::ceil(ax3);
HXDLIN(  21)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            						}
            						else {
HXLINE(  21)							int ii_min49 = ::Math_obj::floor(bx5);
HXDLIN(  21)							int ii_max49 = ::Math_obj::ceil(dx3);
HXDLIN(  21)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            						}
            					}
            					else {
HXLINE(  21)						if ((bx5 > dx3)) {
HXLINE(  21)							int min27;
HXDLIN(  21)							if ((ax3 > dx3)) {
HXLINE(  21)								min27 = ::Math_obj::floor(dx3);
            							}
            							else {
HXLINE(  21)								min27 = ::Math_obj::ceil(ax3);
            							}
HXDLIN(  21)							int ii_min50 = min27;
HXDLIN(  21)							int ii_max50 = ::Math_obj::ceil(bx5);
HXDLIN(  21)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            						}
            						else {
HXLINE(  21)							int ii_min51 = ::Math_obj::floor(ax3);
HXDLIN(  21)							int ii_max51 = ::Math_obj::ceil(dx3);
HXDLIN(  21)							xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            						}
            					}
HXDLIN(  21)					 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN(  21)					if ((ay3 > by5)) {
HXLINE(  21)						if ((ay3 > dy3)) {
HXLINE(  21)							int min28;
HXDLIN(  21)							if ((by5 > dy3)) {
HXLINE(  21)								min28 = ::Math_obj::floor(dy3);
            							}
            							else {
HXLINE(  21)								min28 = ::Math_obj::floor(by5);
            							}
HXDLIN(  21)							int ii_min52 = min28;
HXDLIN(  21)							int ii_max52 = ::Math_obj::ceil(ay3);
HXDLIN(  21)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            						}
            						else {
HXLINE(  21)							int ii_min53 = ::Math_obj::floor(by5);
HXDLIN(  21)							int ii_max53 = ::Math_obj::ceil(dy3);
HXDLIN(  21)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            						}
            					}
            					else {
HXLINE(  21)						if ((by5 > dy3)) {
HXLINE(  21)							int min29;
HXDLIN(  21)							if ((ay3 > dy3)) {
HXLINE(  21)								min29 = ::Math_obj::floor(dy3);
            							}
            							else {
HXLINE(  21)								min29 = ::Math_obj::ceil(ay3);
            							}
HXDLIN(  21)							int ii_min54 = min29;
HXDLIN(  21)							int ii_max54 = ::Math_obj::ceil(by5);
HXDLIN(  21)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            						}
            						else {
HXLINE(  21)							int ii_min55 = ::Math_obj::floor(ay3);
HXDLIN(  21)							int ii_max55 = ::Math_obj::ceil(dy3);
HXDLIN(  21)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            						}
            					}
HXDLIN(  21)					 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN(  21)					if (hasUndo4) {
HXLINE(  21)						int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN(  21)						int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN(  21)						 ::Dynamic imageType4 = null();
HXDLIN(  21)						 ::pi_xy::ImageStruct this131 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  21)						if (::hx::IsNull( imageType4 )) {
HXLINE(  54)							imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  21)						::Dynamic undoImage13;
HXDLIN(  21)						switch((int)(( (int)(imageType4) ))){
            							case (int)0: {
HXLINE(  21)								 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::BytesImg b36 = byt4;
HXDLIN(  21)								{
HXLINE(  21)									b36->width = width4;
HXDLIN(  21)									b36->height = height4;
HXDLIN(  21)									b36->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  21)									b36->data = ::haxe::io::Bytes_obj::alloc((b36->length * 4));
HXDLIN(  21)									{
HXLINE(  21)										int len8 = b36->length;
HXDLIN(  21)										int w4 = 0;
HXDLIN(  21)										{
HXLINE(  21)											int _g80 = 0;
HXDLIN(  21)											int _g81 = b36->height;
HXDLIN(  21)											while((_g80 < _g81)){
HXLINE(  21)												_g80 = (_g80 + 1);
HXDLIN(  21)												int y14 = (_g80 - 1);
HXDLIN(  21)												{
HXLINE(  21)													int _g82 = 0;
HXDLIN(  21)													int _g83 = b36->width;
HXDLIN(  21)													while((_g82 < _g83)){
HXLINE(  21)														_g82 = (_g82 + 1);
HXDLIN(  21)														int x14 = (_g82 - 1);
HXDLIN(  21)														{
HXLINE(  21)															w4 = (w4 + 1);
HXDLIN(  21)															b36->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w4 = (w4 + 1);
HXDLIN(  21)															b36->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w4 = (w4 + 1);
HXDLIN(  21)															b36->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w4 = (w4 + 1);
HXDLIN(  21)															b36->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage13 = b36;
            							}
            							break;
            							case (int)1: {
HXLINE(  21)								 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::ArrIntImg a38 = arrI4;
HXDLIN(  21)								{
HXLINE(  21)									a38->width = width4;
HXDLIN(  21)									a38->height = height4;
HXDLIN(  21)									a38->data = ::Array_obj< int >::__new(0);
HXDLIN(  21)									a38->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  21)									{
HXLINE(  21)										int _g84 = 0;
HXDLIN(  21)										int _g85 = a38->length;
HXDLIN(  21)										while((_g84 < _g85)){
HXLINE(  21)											_g84 = (_g84 + 1);
HXDLIN(  21)											int i32 = (_g84 - 1);
HXDLIN(  21)											a38->data[i32] = 0;
            										}
            									}
            								}
HXDLIN(  21)								undoImage13 = a38;
            							}
            							break;
            							case (int)2: {
HXLINE(  21)								 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::U32ArrImg b37 = u32a4;
HXDLIN(  21)								{
HXLINE(  21)									b37->width = width4;
HXDLIN(  21)									b37->height = height4;
HXDLIN(  21)									b37->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  21)									int size4 = (b37->length * 4);
HXDLIN(  21)									b37->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN(  21)									{
HXLINE(  21)										int _g86 = 0;
HXDLIN(  21)										int _g87 = b37->length;
HXDLIN(  21)										while((_g86 < _g87)){
HXLINE(  21)											_g86 = (_g86 + 1);
HXDLIN(  21)											int i33 = (_g86 - 1);
HXDLIN(  21)											{
HXLINE(  21)												 ::haxe::io::ArrayBufferViewImpl this132 = b37->data;
HXDLIN(  21)												bool undoImage14;
HXDLIN(  21)												if ((i33 >= 0)) {
HXLINE(  21)													undoImage14 = (i33 < (this132->byteLength >> 2));
            												}
            												else {
HXLINE(  21)													undoImage14 = false;
            												}
HXDLIN(  21)												if (undoImage14) {
HXLINE(  21)													 ::haxe::io::Bytes _this4 = this132->bytes;
HXDLIN(  21)													int pos4 = ((i33 << 2) + this132->byteOffset);
HXDLIN(  21)													_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN(  21)													_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN(  21)													_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN(  21)													_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage13 = b37;
            							}
            							break;
            							case (int)3: {
HXLINE(  21)								 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::VecIntImg v11 = vec4;
HXDLIN(  21)								{
HXLINE(  21)									v11->width = width4;
HXDLIN(  21)									v11->height = height4;
HXDLIN(  21)									v11->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  21)									v11->data = ::Array_obj< int >::__new(v11->length);
HXDLIN(  21)									{
HXLINE(  21)										int _g88 = 0;
HXDLIN(  21)										int _g89 = v11->length;
HXDLIN(  21)										while((_g88 < _g89)){
HXLINE(  21)											_g88 = (_g88 + 1);
HXDLIN(  21)											int i34 = (_g88 - 1);
HXDLIN(  21)											v11->data->__unsafe_set(i34,0);
            										}
            									}
            								}
HXDLIN(  21)								undoImage13 = v11;
            							}
            							break;
            							case (int)4: {
HXLINE(  21)								 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::StackIntImg b38 = sInt4;
HXDLIN(  21)								{
HXLINE(  21)									b38->width = width4;
HXDLIN(  21)									b38->height = height4;
HXDLIN(  21)									b38->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  21)									b38->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  21)									{
HXLINE(  21)										int len9 = b38->length;
HXDLIN(  21)										 ::haxe::ds::GenericStack_Int d4 = b38->data;
HXDLIN(  21)										if (::hx::IsNull( d4->head )) {
HXLINE(  21)											int _g90 = 0;
HXDLIN(  21)											int _g91 = len9;
HXDLIN(  21)											while((_g90 < _g91)){
HXLINE(  21)												_g90 = (_g90 + 1);
HXDLIN(  21)												int i35 = (_g90 - 1);
HXDLIN(  21)												d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            											}
            										}
            										else {
HXLINE(  21)											int _g92 = 0;
HXDLIN(  21)											int _g93 = len9;
HXDLIN(  21)											while((_g92 < _g93)){
HXLINE(  21)												_g92 = (_g92 + 1);
HXDLIN(  21)												int i36 = (_g92 - 1);
HXDLIN(  21)												{
HXLINE(  21)													 ::haxe::ds::GenericCell_Int l4 = b38->data->head;
HXDLIN(  21)													 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN(  21)													{
HXLINE(  21)														int _g94 = 0;
HXDLIN(  21)														int _g95 = i36;
HXDLIN(  21)														while((_g94 < _g95)){
HXLINE(  21)															_g94 = (_g94 + 1);
HXDLIN(  21)															int i37 = (_g94 - 1);
HXLINE( 345)															prev4 = l4;
HXLINE( 346)															l4 = l4->next;
            														}
            													}
HXLINE(  21)													if (::hx::IsNull( prev4 )) {
HXLINE(  21)														b38->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  21)														l4 = null();
            													}
            													else {
HXLINE(  21)														prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  21)														l4 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage13 = b38;
            							}
            							break;
            						}
HXDLIN(  21)						this131->image = undoImage13;
HXDLIN(  21)						this131->width = width4;
HXDLIN(  21)						this131->height = height4;
HXDLIN(  21)						this131->imageType = ( (int)(imageType4) );
HXDLIN(  21)						undoImage12 = this131;
HXDLIN(  21)						{
HXLINE(  21)							int rectLeft4 = xIter34->start;
HXDLIN(  21)							int rectTop4 = yIter34->start;
HXDLIN(  21)							int rectRight4 = xIter34->max;
HXDLIN(  21)							bool forceClear4 = false;
HXDLIN(  21)							{
HXLINE(  21)								int _g96 = rectTop4;
HXDLIN(  21)								int _g97 = yIter34->max;
HXDLIN(  21)								while((_g96 < _g97)){
HXLINE(  21)									_g96 = (_g96 + 1);
HXDLIN(  21)									int dy6 = (_g96 - 1);
HXDLIN(  21)									{
HXLINE(  21)										int _g98 = rectLeft4;
HXDLIN(  21)										int _g99 = rectRight4;
HXDLIN(  21)										while((_g98 < _g99)){
HXLINE(  21)											_g98 = (_g98 + 1);
HXDLIN(  21)											int dx6 = (_g98 - 1);
HXDLIN(  21)											::Dynamic this133 = this68->image;
HXDLIN(  21)											int index18;
HXDLIN(  21)											if (this68->useVirtualPos) {
HXLINE(  21)												index18 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this68->virtualY) * ( (Float)(this68->width) )) + dx6) - this68->virtualX));
            											}
            											else {
HXLINE(  21)												index18 = ::Std_obj::_hx_int(( (Float)(((dy6 * this68->width) + dx6)) ));
            											}
HXDLIN(  21)											int c18 = ::iterMagic::Iimg_obj::get(this133,index18);
HXDLIN(  21)											int col4;
HXDLIN(  21)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)												col4 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            											}
            											else {
HXLINE(  21)												col4 = c18;
            											}
HXDLIN(  21)											bool _hx_tmp33;
HXDLIN(  21)											if (this68->useMask) {
HXLINE(  21)												_hx_tmp33 = ::hx::IsNotNull( this68->mask );
            											}
            											else {
HXLINE(  21)												_hx_tmp33 = false;
            											}
HXDLIN(  21)											if (_hx_tmp33) {
HXLINE(  21)												 ::pi_xy::ImageStruct this134 = this68->mask;
HXDLIN(  21)												::Dynamic this135 = this134->image;
HXDLIN(  21)												int index19;
HXDLIN(  21)												if (this134->useVirtualPos) {
HXLINE(  21)													index19 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this134->virtualY) * ( (Float)(this134->width) )) + dx6) - this134->virtualX));
            												}
            												else {
HXLINE(  21)													index19 = ::Std_obj::_hx_int(( (Float)(((dy6 * this134->width) + dx6)) ));
            												}
HXDLIN(  21)												int c19 = ::iterMagic::Iimg_obj::get(this135,index19);
HXDLIN(  21)												int v12;
HXDLIN(  21)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)													v12 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            												}
            												else {
HXLINE(  21)													v12 = c19;
            												}
HXDLIN(  21)												int maskPixel4 = v12;
HXDLIN(  21)												int this136 = col4;
HXDLIN(  21)												if ((maskPixel4 == 0)) {
HXLINE(  21)													col4 = this136;
            												}
            												else {
HXLINE(  21)													Float m04;
HXDLIN(  21)													int this137 = ((maskPixel4 >> 24) & 255);
HXDLIN(  21)													if ((this137 == 0)) {
HXLINE(  21)														m04 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m04 = (( (Float)(this137) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m14;
HXDLIN(  21)													int this138 = ((maskPixel4 >> 16) & 255);
HXDLIN(  21)													if ((this138 == 0)) {
HXLINE(  21)														m14 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m14 = (( (Float)(this138) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m24;
HXDLIN(  21)													int this139 = ((maskPixel4 >> 8) & 255);
HXDLIN(  21)													if ((this139 == 0)) {
HXLINE(  21)														m24 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m24 = (( (Float)(this139) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m34;
HXDLIN(  21)													int this140 = (maskPixel4 & 255);
HXDLIN(  21)													if ((this140 == 0)) {
HXLINE(  21)														m34 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m34 = (( (Float)(this140) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this136 >> 24) & 255)) )));
HXDLIN(  21)													int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this136 >> 16) & 255)) )));
HXDLIN(  21)													int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this136 >> 8) & 255)) )));
HXDLIN(  21)													int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this136 & 255)) )));
HXDLIN(  21)													col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  21)											if ((col4 != 0)) {
HXLINE(  21)												int x15 = (dx6 - rectLeft4);
HXDLIN(  21)												int y15 = (dy6 - rectTop4);
HXDLIN(  21)												int c20 = col4;
HXDLIN(  21)												bool _hx_tmp34;
HXDLIN(  21)												if ((((c20 >> 24) & 255) < 254)) {
HXLINE(  21)													_hx_tmp34 = undoImage12->transparent;
            												}
            												else {
HXLINE(  21)													_hx_tmp34 = false;
            												}
HXDLIN(  21)												if (_hx_tmp34) {
HXLINE(  21)													int location8;
HXDLIN(  21)													if (undoImage12->useVirtualPos) {
HXLINE(  21)														location8 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x15) - undoImage12->virtualX));
            													}
            													else {
HXLINE(  21)														location8 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage12->width) + x15)) ));
            													}
HXDLIN(  21)													int this141 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN(  21)													int this142;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														this142 = ((((((this141 >> 24) & 255) << 24) | ((this141 & 255) << 16)) | (((this141 >> 8) & 255) << 8)) | ((this141 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														this142 = this141;
            													}
HXDLIN(  21)													Float a113;
HXDLIN(  21)													int this143 = ((this142 >> 24) & 255);
HXDLIN(  21)													if ((this143 == 0)) {
HXLINE(  21)														a113 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a113 = (( (Float)(this143) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r19;
HXDLIN(  21)													int this144 = ((this142 >> 16) & 255);
HXDLIN(  21)													if ((this144 == 0)) {
HXLINE(  21)														r19 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r19 = (( (Float)(this144) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g19;
HXDLIN(  21)													int this145 = ((this142 >> 8) & 255);
HXDLIN(  21)													if ((this145 == 0)) {
HXLINE(  21)														g19 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g19 = (( (Float)(this145) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b114;
HXDLIN(  21)													int this146 = (this142 & 255);
HXDLIN(  21)													if ((this146 == 0)) {
HXLINE(  21)														b114 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b114 = (( (Float)(this146) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a211;
HXDLIN(  21)													int this147 = ((col4 >> 24) & 255);
HXDLIN(  21)													if ((this147 == 0)) {
HXLINE(  21)														a211 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a211 = (( (Float)(this147) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r28;
HXDLIN(  21)													int this148 = ((col4 >> 16) & 255);
HXDLIN(  21)													if ((this148 == 0)) {
HXLINE(  21)														r28 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r28 = (( (Float)(this148) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g28;
HXDLIN(  21)													int this149 = ((col4 >> 8) & 255);
HXDLIN(  21)													if ((this149 == 0)) {
HXLINE(  21)														g28 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g28 = (( (Float)(this149) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b212;
HXDLIN(  21)													int this150 = (col4 & 255);
HXDLIN(  21)													if ((this150 == 0)) {
HXLINE(  21)														b212 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b212 = (( (Float)(this150) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a39 = (a113 * (( (Float)(1) ) - a211));
HXDLIN(  21)													int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r28 * a211))));
HXDLIN(  21)													int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g28 * a211))));
HXDLIN(  21)													int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a39) + (b212 * a211))));
HXDLIN(  21)													int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a211)));
HXDLIN(  21)													int blended8 = ((((a40 << 24) | (r20 << 16)) | (g20 << 8)) | b39);
HXDLIN(  21)													{
HXLINE(  21)														int _hx_tmp35;
HXDLIN(  21)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)															_hx_tmp35 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            														}
            														else {
HXLINE(  21)															_hx_tmp35 = blended8;
            														}
HXDLIN(  21)														::iterMagic::Iimg_obj::set(undoImage12->image,location8,_hx_tmp35);
            													}
            												}
            												else {
HXLINE(  21)													::Dynamic this151 = undoImage12->image;
HXDLIN(  21)													int index20;
HXDLIN(  21)													if (undoImage12->useVirtualPos) {
HXLINE(  21)														index20 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x15) - undoImage12->virtualX));
            													}
            													else {
HXLINE(  21)														index20 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage12->width) + x15)) ));
            													}
HXDLIN(  21)													int _hx_tmp36;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														_hx_tmp36 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														_hx_tmp36 = c20;
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this151,index20,_hx_tmp36);
            												}
            											}
            											else {
HXLINE(  21)												if (forceClear4) {
HXLINE(  21)													::Dynamic this152 = undoImage12->image;
HXDLIN(  21)													int x16 = (dx6 - rectLeft4);
HXDLIN(  21)													int y16 = (dy6 - rectTop4);
HXDLIN(  21)													int index21;
HXDLIN(  21)													if (undoImage12->useVirtualPos) {
HXLINE(  21)														index21 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x16) - undoImage12->virtualX));
            													}
            													else {
HXLINE(  21)														index21 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage12->width) + x16)) ));
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this152,index21,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  21)					bool found4 = false;
HXDLIN(  21)					Float min30 = ( (Float)(0) );
HXDLIN(  21)					Float max2 = ( (Float)(0) );
HXDLIN(  21)					int a41 = 0;
HXDLIN(  21)					int r29 = 0;
HXDLIN(  21)					int g29 = 0;
HXDLIN(  21)					int b40 = 0;
HXDLIN(  21)					{
HXLINE(  21)						int _g_min8 = xIter34->start;
HXDLIN(  21)						int _g_max8 = xIter34->max;
HXDLIN(  21)						while((_g_min8 < _g_max8)){
HXLINE(  21)							_g_min8 = (_g_min8 + 1);
HXDLIN(  21)							int px2 = (_g_min8 - 1);
HXDLIN(  21)							Float pcx2 = (( (Float)(px2) ) - dx3);
HXLINE( 812)							found4 = false;
HXLINE(  21)							{
HXLINE(  21)								int _g_min9 = yIter34->start;
HXDLIN(  21)								int _g_max9 = yIter34->max;
HXDLIN(  21)								while((_g_min9 < _g_max9)){
HXLINE(  21)									_g_min9 = (_g_min9 + 1);
HXDLIN(  21)									int py2 = (_g_min9 - 1);
HXDLIN(  21)									Float pcy2 = (( (Float)(py2) ) - dy3);
HXDLIN(  21)									Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN(  21)									Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN(  21)									Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN(  21)									Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN(  21)									Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN(  21)									bool _hx_tmp37;
HXDLIN(  21)									bool _hx_tmp38;
HXDLIN(  21)									if ((ratioA2 >= 0)) {
HXLINE(  21)										_hx_tmp38 = (ratioB2 >= 0);
            									}
            									else {
HXLINE(  21)										_hx_tmp38 = false;
            									}
HXDLIN(  21)									if (_hx_tmp38) {
HXLINE(  21)										_hx_tmp37 = (ratioC2 >= 0);
            									}
            									else {
HXLINE(  21)										_hx_tmp37 = false;
            									}
HXDLIN(  21)									if (_hx_tmp37) {
HXLINE(  21)										int i38 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN(  21)										if ((i38 > 255)) {
HXLINE(  24)											i38 = 255;
            										}
HXLINE(  21)										if ((i38 < 0)) {
HXLINE(  25)											i38 = 0;
            										}
HXLINE( 821)										r29 = i38;
HXLINE(  21)										int i39 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN(  21)										if ((i39 > 255)) {
HXLINE(  24)											i39 = 255;
            										}
HXLINE(  21)										if ((i39 < 0)) {
HXLINE(  25)											i39 = 0;
            										}
HXLINE( 822)										g29 = i39;
HXLINE(  21)										int i40 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN(  21)										if ((i40 > 255)) {
HXLINE(  24)											i40 = 255;
            										}
HXLINE(  21)										if ((i40 < 0)) {
HXLINE(  25)											i40 = 0;
            										}
HXLINE( 823)										b40 = i40;
HXLINE(  21)										{
HXLINE(  21)											if ((ratioA2 < ratioC2)) {
HXLINE(  21)												min30 = ratioA2;
            											}
            											else {
HXLINE(  21)												min30 = ratioC2;
            											}
HXDLIN(  21)											if ((ratioA2 > ratioB2)) {
HXLINE(  21)												max2 = ratioA2;
            											}
            											else {
HXLINE(  21)												max2 = ratioB2;
            											}
HXDLIN(  21)											if (!((max2 > ratioC2))) {
HXLINE(  21)												max2 = ratioC2;
            											}
HXLINE( 829)											max2 = ((( (Float)(1) ) - max2) / ( (Float)(2) ));
HXLINE(  21)											if (!((min30 < max2))) {
HXLINE(  21)												min30 = ((max2 + min30) / ( (Float)(2) ));
            											}
HXDLIN(  21)											int i41 = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min30));
HXDLIN(  21)											if ((i41 > 255)) {
HXLINE(  24)												i41 = 255;
            											}
HXLINE(  21)											if ((i41 < 0)) {
HXLINE(  25)												i41 = 0;
            											}
HXLINE( 832)											a41 = i41;
HXLINE(  21)											{
HXLINE(  21)												int location9;
HXDLIN(  21)												if (this68->useVirtualPos) {
HXLINE(  21)													location9 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this68->virtualY) * ( (Float)(this68->width) )) + px2) - this68->virtualX));
            												}
            												else {
HXLINE(  21)													location9 = ::Std_obj::_hx_int(( (Float)(((py2 * this68->width) + px2)) ));
            												}
HXDLIN(  21)												bool _hx_tmp39;
HXDLIN(  21)												if (this68->transparent) {
HXLINE(  21)													_hx_tmp39 = (a41 < 254);
            												}
            												else {
HXLINE(  21)													_hx_tmp39 = false;
            												}
HXDLIN(  21)												if (_hx_tmp39) {
HXLINE(  21)													int this153 = ::iterMagic::Iimg_obj::get(this68->image,location9);
HXDLIN(  21)													int old2;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														old2 = ((((((this153 >> 24) & 255) << 24) | ((this153 & 255) << 16)) | (((this153 >> 8) & 255) << 8)) | ((this153 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														old2 = this153;
            													}
HXDLIN(  21)													int rhs2 = ((((a41 << 24) | (r29 << 16)) | (g29 << 8)) | b40);
HXDLIN(  21)													Float a114;
HXDLIN(  21)													int this154 = ((old2 >> 24) & 255);
HXDLIN(  21)													if ((this154 == 0)) {
HXLINE(  21)														a114 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a114 = (( (Float)(this154) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r110;
HXDLIN(  21)													int this155 = ((old2 >> 16) & 255);
HXDLIN(  21)													if ((this155 == 0)) {
HXLINE(  21)														r110 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r110 = (( (Float)(this155) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g110;
HXDLIN(  21)													int this156 = ((old2 >> 8) & 255);
HXDLIN(  21)													if ((this156 == 0)) {
HXLINE(  21)														g110 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g110 = (( (Float)(this156) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b115;
HXDLIN(  21)													int this157 = (old2 & 255);
HXDLIN(  21)													if ((this157 == 0)) {
HXLINE(  21)														b115 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b115 = (( (Float)(this157) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a212;
HXDLIN(  21)													int this158 = ((rhs2 >> 24) & 255);
HXDLIN(  21)													if ((this158 == 0)) {
HXLINE(  21)														a212 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a212 = (( (Float)(this158) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r210;
HXDLIN(  21)													int this159 = ((rhs2 >> 16) & 255);
HXDLIN(  21)													if ((this159 == 0)) {
HXLINE(  21)														r210 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r210 = (( (Float)(this159) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g210;
HXDLIN(  21)													int this160 = ((rhs2 >> 8) & 255);
HXDLIN(  21)													if ((this160 == 0)) {
HXLINE(  21)														g210 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g210 = (( (Float)(this160) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b213;
HXDLIN(  21)													int this161 = (rhs2 & 255);
HXDLIN(  21)													if ((this161 == 0)) {
HXLINE(  21)														b213 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b213 = (( (Float)(this161) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a310 = (a114 * (( (Float)(1) ) - a212));
HXDLIN(  21)													int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a212))));
HXDLIN(  21)													int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a212))));
HXDLIN(  21)													int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a310) + (b213 * a212))));
HXDLIN(  21)													int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a212)));
HXDLIN(  21)													int blended9 = ((((a42 << 24) | (r30 << 16)) | (g30 << 8)) | b41);
HXDLIN(  21)													{
HXLINE(  21)														int _hx_tmp40;
HXDLIN(  21)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)															_hx_tmp40 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            														}
            														else {
HXLINE(  21)															_hx_tmp40 = blended9;
            														}
HXDLIN(  21)														::iterMagic::Iimg_obj::set(this68->image,location9,_hx_tmp40);
            													}
            												}
            												else {
HXLINE(  21)													int value2;
HXDLIN(  21)													if (this68->isLittle) {
HXLINE(  21)														value2 = ((((a41 << 24) | (b40 << 16)) | (g29 << 8)) | r29);
            													}
            													else {
HXLINE(  21)														value2 = ((((a41 << 24) | (r29 << 16)) | (g29 << 8)) | b40);
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this68->image,location9,value2);
            												}
            											}
            										}
HXLINE( 850)										found4 = true;
            									}
            									else {
HXLINE(  21)										if (found4) {
HXLINE(  21)											goto _hx_goto_61;
            										}
            									}
            								}
            								_hx_goto_61:;
            							}
            						}
            					}
HXDLIN(  21)					if ((hasHit == false)) {
HXLINE(  21)						 ::pi_xy::algo::HitTri v13 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax3,ay3,bx5,by5,dx3,dy3,true);
HXDLIN(  21)						if (hasUndo4) {
HXLINE(  21)							v13->undoImage = undoImage12;
HXDLIN(  21)							v13->undoX = xIter34->start;
HXDLIN(  21)							v13->undoY = yIter34->start;
            						}
            					}
            				}
HXDLIN(  21)				{
HXLINE(  21)					bool hasUndo5 = true;
HXDLIN(  21)					int aA3 = ((color1 >> 24) & 255);
HXDLIN(  21)					int rA3 = ((color1 >> 16) & 255);
HXDLIN(  21)					int gA3 = ((color1 >> 8) & 255);
HXDLIN(  21)					int bA3 = (color1 & 255);
HXDLIN(  21)					Float bcx3 = (cx5 - dx3);
HXDLIN(  21)					Float bcy3 = (cy5 - dy3);
HXDLIN(  21)					Float acx3 = (bx5 - dx3);
HXDLIN(  21)					Float acy3 = (by5 - dy3);
HXDLIN(  21)					Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  21)					Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  21)					Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  21)					Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  21)					 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN(  21)					if ((bx5 > cx5)) {
HXLINE(  21)						if ((bx5 > dx3)) {
HXLINE(  21)							int min31;
HXDLIN(  21)							if ((cx5 > dx3)) {
HXLINE(  21)								min31 = ::Math_obj::floor(dx3);
            							}
            							else {
HXLINE(  21)								min31 = ::Math_obj::floor(cx5);
            							}
HXDLIN(  21)							int ii_min56 = min31;
HXDLIN(  21)							int ii_max56 = ::Math_obj::ceil(bx5);
HXDLIN(  21)							xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            						}
            						else {
HXLINE(  21)							int ii_min57 = ::Math_obj::floor(cx5);
HXDLIN(  21)							int ii_max57 = ::Math_obj::ceil(dx3);
HXDLIN(  21)							xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            						}
            					}
            					else {
HXLINE(  21)						if ((cx5 > dx3)) {
HXLINE(  21)							int min32;
HXDLIN(  21)							if ((bx5 > dx3)) {
HXLINE(  21)								min32 = ::Math_obj::floor(dx3);
            							}
            							else {
HXLINE(  21)								min32 = ::Math_obj::ceil(bx5);
            							}
HXDLIN(  21)							int ii_min58 = min32;
HXDLIN(  21)							int ii_max58 = ::Math_obj::ceil(cx5);
HXDLIN(  21)							xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            						}
            						else {
HXLINE(  21)							int ii_min59 = ::Math_obj::floor(bx5);
HXDLIN(  21)							int ii_max59 = ::Math_obj::ceil(dx3);
HXDLIN(  21)							xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            						}
            					}
HXDLIN(  21)					 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN(  21)					if ((by5 > cy5)) {
HXLINE(  21)						if ((by5 > dy3)) {
HXLINE(  21)							int min33;
HXDLIN(  21)							if ((cy5 > dy3)) {
HXLINE(  21)								min33 = ::Math_obj::floor(dy3);
            							}
            							else {
HXLINE(  21)								min33 = ::Math_obj::floor(cy5);
            							}
HXDLIN(  21)							int ii_min60 = min33;
HXDLIN(  21)							int ii_max60 = ::Math_obj::ceil(by5);
HXDLIN(  21)							yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            						}
            						else {
HXLINE(  21)							int ii_min61 = ::Math_obj::floor(cy5);
HXDLIN(  21)							int ii_max61 = ::Math_obj::ceil(dy3);
HXDLIN(  21)							yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            						}
            					}
            					else {
HXLINE(  21)						if ((cy5 > dy3)) {
HXLINE(  21)							int min34;
HXDLIN(  21)							if ((by5 > dy3)) {
HXLINE(  21)								min34 = ::Math_obj::floor(dy3);
            							}
            							else {
HXLINE(  21)								min34 = ::Math_obj::ceil(by5);
            							}
HXDLIN(  21)							int ii_min62 = min34;
HXDLIN(  21)							int ii_max62 = ::Math_obj::ceil(cy5);
HXDLIN(  21)							yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            						}
            						else {
HXLINE(  21)							int ii_min63 = ::Math_obj::floor(by5);
HXDLIN(  21)							int ii_max63 = ::Math_obj::ceil(dy3);
HXDLIN(  21)							yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            						}
            					}
HXDLIN(  21)					 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN(  21)					if (hasUndo5) {
HXLINE(  21)						int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN(  21)						int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN(  21)						 ::Dynamic imageType5 = null();
HXDLIN(  21)						 ::pi_xy::ImageStruct this162 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  21)						if (::hx::IsNull( imageType5 )) {
HXLINE(  54)							imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  21)						::Dynamic undoImage16;
HXDLIN(  21)						switch((int)(( (int)(imageType5) ))){
            							case (int)0: {
HXLINE(  21)								 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::BytesImg b42 = byt5;
HXDLIN(  21)								{
HXLINE(  21)									b42->width = width5;
HXDLIN(  21)									b42->height = height5;
HXDLIN(  21)									b42->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  21)									b42->data = ::haxe::io::Bytes_obj::alloc((b42->length * 4));
HXDLIN(  21)									{
HXLINE(  21)										int len10 = b42->length;
HXDLIN(  21)										int w5 = 0;
HXDLIN(  21)										{
HXLINE(  21)											int _g100 = 0;
HXDLIN(  21)											int _g101 = b42->height;
HXDLIN(  21)											while((_g100 < _g101)){
HXLINE(  21)												_g100 = (_g100 + 1);
HXDLIN(  21)												int y17 = (_g100 - 1);
HXDLIN(  21)												{
HXLINE(  21)													int _g102 = 0;
HXDLIN(  21)													int _g103 = b42->width;
HXDLIN(  21)													while((_g102 < _g103)){
HXLINE(  21)														_g102 = (_g102 + 1);
HXDLIN(  21)														int x17 = (_g102 - 1);
HXDLIN(  21)														{
HXLINE(  21)															w5 = (w5 + 1);
HXDLIN(  21)															b42->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w5 = (w5 + 1);
HXDLIN(  21)															b42->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w5 = (w5 + 1);
HXDLIN(  21)															b42->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  21)														{
HXLINE(  21)															w5 = (w5 + 1);
HXDLIN(  21)															b42->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage16 = b42;
            							}
            							break;
            							case (int)1: {
HXLINE(  21)								 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::ArrIntImg a43 = arrI5;
HXDLIN(  21)								{
HXLINE(  21)									a43->width = width5;
HXDLIN(  21)									a43->height = height5;
HXDLIN(  21)									a43->data = ::Array_obj< int >::__new(0);
HXDLIN(  21)									a43->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  21)									{
HXLINE(  21)										int _g104 = 0;
HXDLIN(  21)										int _g105 = a43->length;
HXDLIN(  21)										while((_g104 < _g105)){
HXLINE(  21)											_g104 = (_g104 + 1);
HXDLIN(  21)											int i42 = (_g104 - 1);
HXDLIN(  21)											a43->data[i42] = 0;
            										}
            									}
            								}
HXDLIN(  21)								undoImage16 = a43;
            							}
            							break;
            							case (int)2: {
HXLINE(  21)								 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::U32ArrImg b43 = u32a5;
HXDLIN(  21)								{
HXLINE(  21)									b43->width = width5;
HXDLIN(  21)									b43->height = height5;
HXDLIN(  21)									b43->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  21)									int size5 = (b43->length * 4);
HXDLIN(  21)									b43->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN(  21)									{
HXLINE(  21)										int _g106 = 0;
HXDLIN(  21)										int _g107 = b43->length;
HXDLIN(  21)										while((_g106 < _g107)){
HXLINE(  21)											_g106 = (_g106 + 1);
HXDLIN(  21)											int i43 = (_g106 - 1);
HXDLIN(  21)											{
HXLINE(  21)												 ::haxe::io::ArrayBufferViewImpl this163 = b43->data;
HXDLIN(  21)												bool undoImage17;
HXDLIN(  21)												if ((i43 >= 0)) {
HXLINE(  21)													undoImage17 = (i43 < (this163->byteLength >> 2));
            												}
            												else {
HXLINE(  21)													undoImage17 = false;
            												}
HXDLIN(  21)												if (undoImage17) {
HXLINE(  21)													 ::haxe::io::Bytes _this5 = this163->bytes;
HXDLIN(  21)													int pos5 = ((i43 << 2) + this163->byteOffset);
HXDLIN(  21)													_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN(  21)													_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN(  21)													_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN(  21)													_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage16 = b43;
            							}
            							break;
            							case (int)3: {
HXLINE(  21)								 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::VecIntImg v14 = vec5;
HXDLIN(  21)								{
HXLINE(  21)									v14->width = width5;
HXDLIN(  21)									v14->height = height5;
HXDLIN(  21)									v14->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  21)									v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN(  21)									{
HXLINE(  21)										int _g108 = 0;
HXDLIN(  21)										int _g109 = v14->length;
HXDLIN(  21)										while((_g108 < _g109)){
HXLINE(  21)											_g108 = (_g108 + 1);
HXDLIN(  21)											int i44 = (_g108 - 1);
HXDLIN(  21)											v14->data->__unsafe_set(i44,0);
            										}
            									}
            								}
HXDLIN(  21)								undoImage16 = v14;
            							}
            							break;
            							case (int)4: {
HXLINE(  21)								 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)								 ::iterMagic::StackIntImg b44 = sInt5;
HXDLIN(  21)								{
HXLINE(  21)									b44->width = width5;
HXDLIN(  21)									b44->height = height5;
HXDLIN(  21)									b44->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  21)									b44->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  21)									{
HXLINE(  21)										int len11 = b44->length;
HXDLIN(  21)										 ::haxe::ds::GenericStack_Int d5 = b44->data;
HXDLIN(  21)										if (::hx::IsNull( d5->head )) {
HXLINE(  21)											int _g110 = 0;
HXDLIN(  21)											int _g111 = len11;
HXDLIN(  21)											while((_g110 < _g111)){
HXLINE(  21)												_g110 = (_g110 + 1);
HXDLIN(  21)												int i45 = (_g110 - 1);
HXDLIN(  21)												d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            											}
            										}
            										else {
HXLINE(  21)											int _g112 = 0;
HXDLIN(  21)											int _g113 = len11;
HXDLIN(  21)											while((_g112 < _g113)){
HXLINE(  21)												_g112 = (_g112 + 1);
HXDLIN(  21)												int i46 = (_g112 - 1);
HXDLIN(  21)												{
HXLINE(  21)													 ::haxe::ds::GenericCell_Int l5 = b44->data->head;
HXDLIN(  21)													 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN(  21)													{
HXLINE(  21)														int _g114 = 0;
HXDLIN(  21)														int _g115 = i46;
HXDLIN(  21)														while((_g114 < _g115)){
HXLINE(  21)															_g114 = (_g114 + 1);
HXDLIN(  21)															int i47 = (_g114 - 1);
HXLINE( 345)															prev5 = l5;
HXLINE( 346)															l5 = l5->next;
            														}
            													}
HXLINE(  21)													if (::hx::IsNull( prev5 )) {
HXLINE(  21)														b44->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  21)														l5 = null();
            													}
            													else {
HXLINE(  21)														prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  21)														l5 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  21)								undoImage16 = b44;
            							}
            							break;
            						}
HXDLIN(  21)						this162->image = undoImage16;
HXDLIN(  21)						this162->width = width5;
HXDLIN(  21)						this162->height = height5;
HXDLIN(  21)						this162->imageType = ( (int)(imageType5) );
HXDLIN(  21)						undoImage15 = this162;
HXDLIN(  21)						{
HXLINE(  21)							int rectLeft5 = xIter35->start;
HXDLIN(  21)							int rectTop5 = yIter35->start;
HXDLIN(  21)							int rectRight5 = xIter35->max;
HXDLIN(  21)							bool forceClear5 = false;
HXDLIN(  21)							{
HXLINE(  21)								int _g116 = rectTop5;
HXDLIN(  21)								int _g117 = yIter35->max;
HXDLIN(  21)								while((_g116 < _g117)){
HXLINE(  21)									_g116 = (_g116 + 1);
HXDLIN(  21)									int dy7 = (_g116 - 1);
HXDLIN(  21)									{
HXLINE(  21)										int _g118 = rectLeft5;
HXDLIN(  21)										int _g119 = rectRight5;
HXDLIN(  21)										while((_g118 < _g119)){
HXLINE(  21)											_g118 = (_g118 + 1);
HXDLIN(  21)											int dx7 = (_g118 - 1);
HXDLIN(  21)											::Dynamic this164 = this68->image;
HXDLIN(  21)											int index22;
HXDLIN(  21)											if (this68->useVirtualPos) {
HXLINE(  21)												index22 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this68->virtualY) * ( (Float)(this68->width) )) + dx7) - this68->virtualX));
            											}
            											else {
HXLINE(  21)												index22 = ::Std_obj::_hx_int(( (Float)(((dy7 * this68->width) + dx7)) ));
            											}
HXDLIN(  21)											int c21 = ::iterMagic::Iimg_obj::get(this164,index22);
HXDLIN(  21)											int col5;
HXDLIN(  21)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)												col5 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            											}
            											else {
HXLINE(  21)												col5 = c21;
            											}
HXDLIN(  21)											bool _hx_tmp41;
HXDLIN(  21)											if (this68->useMask) {
HXLINE(  21)												_hx_tmp41 = ::hx::IsNotNull( this68->mask );
            											}
            											else {
HXLINE(  21)												_hx_tmp41 = false;
            											}
HXDLIN(  21)											if (_hx_tmp41) {
HXLINE(  21)												 ::pi_xy::ImageStruct this165 = this68->mask;
HXDLIN(  21)												::Dynamic this166 = this165->image;
HXDLIN(  21)												int index23;
HXDLIN(  21)												if (this165->useVirtualPos) {
HXLINE(  21)													index23 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this165->virtualY) * ( (Float)(this165->width) )) + dx7) - this165->virtualX));
            												}
            												else {
HXLINE(  21)													index23 = ::Std_obj::_hx_int(( (Float)(((dy7 * this165->width) + dx7)) ));
            												}
HXDLIN(  21)												int c22 = ::iterMagic::Iimg_obj::get(this166,index23);
HXDLIN(  21)												int v15;
HXDLIN(  21)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)													v15 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            												}
            												else {
HXLINE(  21)													v15 = c22;
            												}
HXDLIN(  21)												int maskPixel5 = v15;
HXDLIN(  21)												int this167 = col5;
HXDLIN(  21)												if ((maskPixel5 == 0)) {
HXLINE(  21)													col5 = this167;
            												}
            												else {
HXLINE(  21)													Float m05;
HXDLIN(  21)													int this168 = ((maskPixel5 >> 24) & 255);
HXDLIN(  21)													if ((this168 == 0)) {
HXLINE(  21)														m05 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m05 = (( (Float)(this168) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m15;
HXDLIN(  21)													int this169 = ((maskPixel5 >> 16) & 255);
HXDLIN(  21)													if ((this169 == 0)) {
HXLINE(  21)														m15 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m15 = (( (Float)(this169) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m25;
HXDLIN(  21)													int this170 = ((maskPixel5 >> 8) & 255);
HXDLIN(  21)													if ((this170 == 0)) {
HXLINE(  21)														m25 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m25 = (( (Float)(this170) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float m35;
HXDLIN(  21)													int this171 = (maskPixel5 & 255);
HXDLIN(  21)													if ((this171 == 0)) {
HXLINE(  21)														m35 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														m35 = (( (Float)(this171) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this167 >> 24) & 255)) )));
HXDLIN(  21)													int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this167 >> 16) & 255)) )));
HXDLIN(  21)													int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this167 >> 8) & 255)) )));
HXDLIN(  21)													int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this167 & 255)) )));
HXDLIN(  21)													col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  21)											if ((col5 != 0)) {
HXLINE(  21)												int x18 = (dx7 - rectLeft5);
HXDLIN(  21)												int y18 = (dy7 - rectTop5);
HXDLIN(  21)												int c23 = col5;
HXDLIN(  21)												bool _hx_tmp42;
HXDLIN(  21)												if ((((c23 >> 24) & 255) < 254)) {
HXLINE(  21)													_hx_tmp42 = undoImage15->transparent;
            												}
            												else {
HXLINE(  21)													_hx_tmp42 = false;
            												}
HXDLIN(  21)												if (_hx_tmp42) {
HXLINE(  21)													int location10;
HXDLIN(  21)													if (undoImage15->useVirtualPos) {
HXLINE(  21)														location10 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x18) - undoImage15->virtualX));
            													}
            													else {
HXLINE(  21)														location10 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage15->width) + x18)) ));
            													}
HXDLIN(  21)													int this172 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN(  21)													int this173;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														this173 = ((((((this172 >> 24) & 255) << 24) | ((this172 & 255) << 16)) | (((this172 >> 8) & 255) << 8)) | ((this172 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														this173 = this172;
            													}
HXDLIN(  21)													Float a115;
HXDLIN(  21)													int this174 = ((this173 >> 24) & 255);
HXDLIN(  21)													if ((this174 == 0)) {
HXLINE(  21)														a115 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a115 = (( (Float)(this174) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r111;
HXDLIN(  21)													int this175 = ((this173 >> 16) & 255);
HXDLIN(  21)													if ((this175 == 0)) {
HXLINE(  21)														r111 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r111 = (( (Float)(this175) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g111;
HXDLIN(  21)													int this176 = ((this173 >> 8) & 255);
HXDLIN(  21)													if ((this176 == 0)) {
HXLINE(  21)														g111 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g111 = (( (Float)(this176) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b116;
HXDLIN(  21)													int this177 = (this173 & 255);
HXDLIN(  21)													if ((this177 == 0)) {
HXLINE(  21)														b116 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b116 = (( (Float)(this177) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a213;
HXDLIN(  21)													int this178 = ((col5 >> 24) & 255);
HXDLIN(  21)													if ((this178 == 0)) {
HXLINE(  21)														a213 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a213 = (( (Float)(this178) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r211;
HXDLIN(  21)													int this179 = ((col5 >> 16) & 255);
HXDLIN(  21)													if ((this179 == 0)) {
HXLINE(  21)														r211 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r211 = (( (Float)(this179) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g211;
HXDLIN(  21)													int this180 = ((col5 >> 8) & 255);
HXDLIN(  21)													if ((this180 == 0)) {
HXLINE(  21)														g211 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g211 = (( (Float)(this180) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b214;
HXDLIN(  21)													int this181 = (col5 & 255);
HXDLIN(  21)													if ((this181 == 0)) {
HXLINE(  21)														b214 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b214 = (( (Float)(this181) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a311 = (a115 * (( (Float)(1) ) - a213));
HXDLIN(  21)													int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a213))));
HXDLIN(  21)													int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a213))));
HXDLIN(  21)													int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a311) + (b214 * a213))));
HXDLIN(  21)													int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a213)));
HXDLIN(  21)													int blended10 = ((((a44 << 24) | (r31 << 16)) | (g31 << 8)) | b45);
HXDLIN(  21)													{
HXLINE(  21)														int _hx_tmp43;
HXDLIN(  21)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)															_hx_tmp43 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            														}
            														else {
HXLINE(  21)															_hx_tmp43 = blended10;
            														}
HXDLIN(  21)														::iterMagic::Iimg_obj::set(undoImage15->image,location10,_hx_tmp43);
            													}
            												}
            												else {
HXLINE(  21)													::Dynamic this182 = undoImage15->image;
HXDLIN(  21)													int index24;
HXDLIN(  21)													if (undoImage15->useVirtualPos) {
HXLINE(  21)														index24 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x18) - undoImage15->virtualX));
            													}
            													else {
HXLINE(  21)														index24 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage15->width) + x18)) ));
            													}
HXDLIN(  21)													int _hx_tmp44;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														_hx_tmp44 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														_hx_tmp44 = c23;
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this182,index24,_hx_tmp44);
            												}
            											}
            											else {
HXLINE(  21)												if (forceClear5) {
HXLINE(  21)													::Dynamic this183 = undoImage15->image;
HXDLIN(  21)													int x19 = (dx7 - rectLeft5);
HXDLIN(  21)													int y19 = (dy7 - rectTop5);
HXDLIN(  21)													int index25;
HXDLIN(  21)													if (undoImage15->useVirtualPos) {
HXLINE(  21)														index25 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x19) - undoImage15->virtualX));
            													}
            													else {
HXLINE(  21)														index25 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage15->width) + x19)) ));
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this183,index25,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  21)					bool found5 = false;
HXDLIN(  21)					Float min35 = ( (Float)(0) );
HXDLIN(  21)					Float max3 = ( (Float)(0) );
HXDLIN(  21)					int a45 = 0;
HXDLIN(  21)					int r32 = 0;
HXDLIN(  21)					int g32 = 0;
HXDLIN(  21)					int b46 = 0;
HXDLIN(  21)					{
HXLINE(  21)						int _g_min10 = xIter35->start;
HXDLIN(  21)						int _g_max10 = xIter35->max;
HXDLIN(  21)						while((_g_min10 < _g_max10)){
HXLINE(  21)							_g_min10 = (_g_min10 + 1);
HXDLIN(  21)							int px3 = (_g_min10 - 1);
HXDLIN(  21)							Float pcx3 = (( (Float)(px3) ) - dx3);
HXLINE( 812)							found5 = false;
HXLINE(  21)							{
HXLINE(  21)								int _g_min11 = yIter35->start;
HXDLIN(  21)								int _g_max11 = yIter35->max;
HXDLIN(  21)								while((_g_min11 < _g_max11)){
HXLINE(  21)									_g_min11 = (_g_min11 + 1);
HXDLIN(  21)									int py3 = (_g_min11 - 1);
HXDLIN(  21)									Float pcy3 = (( (Float)(py3) ) - dy3);
HXDLIN(  21)									Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN(  21)									Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN(  21)									Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN(  21)									Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN(  21)									Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN(  21)									bool _hx_tmp45;
HXDLIN(  21)									bool _hx_tmp46;
HXDLIN(  21)									if ((ratioA3 >= 0)) {
HXLINE(  21)										_hx_tmp46 = (ratioB3 >= 0);
            									}
            									else {
HXLINE(  21)										_hx_tmp46 = false;
            									}
HXDLIN(  21)									if (_hx_tmp46) {
HXLINE(  21)										_hx_tmp45 = (ratioC3 >= 0);
            									}
            									else {
HXLINE(  21)										_hx_tmp45 = false;
            									}
HXDLIN(  21)									if (_hx_tmp45) {
HXLINE(  21)										int i48 = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN(  21)										if ((i48 > 255)) {
HXLINE(  24)											i48 = 255;
            										}
HXLINE(  21)										if ((i48 < 0)) {
HXLINE(  25)											i48 = 0;
            										}
HXLINE( 821)										r32 = i48;
HXLINE(  21)										int i49 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN(  21)										if ((i49 > 255)) {
HXLINE(  24)											i49 = 255;
            										}
HXLINE(  21)										if ((i49 < 0)) {
HXLINE(  25)											i49 = 0;
            										}
HXLINE( 822)										g32 = i49;
HXLINE(  21)										int i50 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN(  21)										if ((i50 > 255)) {
HXLINE(  24)											i50 = 255;
            										}
HXLINE(  21)										if ((i50 < 0)) {
HXLINE(  25)											i50 = 0;
            										}
HXLINE( 823)										b46 = i50;
HXLINE(  21)										{
HXLINE(  21)											if ((ratioB3 < ratioC3)) {
HXLINE(  21)												min35 = ratioB3;
            											}
            											else {
HXLINE(  21)												min35 = ratioC3;
            											}
HXDLIN(  21)											if ((ratioA3 > ratioB3)) {
HXLINE(  21)												max3 = ratioA3;
            											}
            											else {
HXLINE(  21)												max3 = ratioB3;
            											}
HXDLIN(  21)											if (!((max3 > ratioC3))) {
HXLINE(  21)												max3 = ratioC3;
            											}
HXLINE( 842)											max3 = ((( (Float)(1) ) - max3) / ( (Float)(2) ));
HXLINE(  21)											if (!((min35 < max3))) {
HXLINE(  21)												min35 = ((max3 + min35) / ( (Float)(2) ));
            											}
HXDLIN(  21)											int i51 = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft) * min35));
HXDLIN(  21)											if ((i51 > 255)) {
HXLINE(  24)												i51 = 255;
            											}
HXLINE(  21)											if ((i51 < 0)) {
HXLINE(  25)												i51 = 0;
            											}
HXLINE( 845)											a45 = i51;
HXLINE(  21)											{
HXLINE(  21)												int location11;
HXDLIN(  21)												if (this68->useVirtualPos) {
HXLINE(  21)													location11 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this68->virtualY) * ( (Float)(this68->width) )) + px3) - this68->virtualX));
            												}
            												else {
HXLINE(  21)													location11 = ::Std_obj::_hx_int(( (Float)(((py3 * this68->width) + px3)) ));
            												}
HXDLIN(  21)												bool _hx_tmp47;
HXDLIN(  21)												if (this68->transparent) {
HXLINE(  21)													_hx_tmp47 = (a45 < 254);
            												}
            												else {
HXLINE(  21)													_hx_tmp47 = false;
            												}
HXDLIN(  21)												if (_hx_tmp47) {
HXLINE(  21)													int this184 = ::iterMagic::Iimg_obj::get(this68->image,location11);
HXDLIN(  21)													int old3;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														old3 = ((((((this184 >> 24) & 255) << 24) | ((this184 & 255) << 16)) | (((this184 >> 8) & 255) << 8)) | ((this184 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														old3 = this184;
            													}
HXDLIN(  21)													int rhs3 = ((((a45 << 24) | (r32 << 16)) | (g32 << 8)) | b46);
HXDLIN(  21)													Float a116;
HXDLIN(  21)													int this185 = ((old3 >> 24) & 255);
HXDLIN(  21)													if ((this185 == 0)) {
HXLINE(  21)														a116 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a116 = (( (Float)(this185) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r112;
HXDLIN(  21)													int this186 = ((old3 >> 16) & 255);
HXDLIN(  21)													if ((this186 == 0)) {
HXLINE(  21)														r112 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r112 = (( (Float)(this186) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g112;
HXDLIN(  21)													int this187 = ((old3 >> 8) & 255);
HXDLIN(  21)													if ((this187 == 0)) {
HXLINE(  21)														g112 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g112 = (( (Float)(this187) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b117;
HXDLIN(  21)													int this188 = (old3 & 255);
HXDLIN(  21)													if ((this188 == 0)) {
HXLINE(  21)														b117 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b117 = (( (Float)(this188) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a214;
HXDLIN(  21)													int this189 = ((rhs3 >> 24) & 255);
HXDLIN(  21)													if ((this189 == 0)) {
HXLINE(  21)														a214 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														a214 = (( (Float)(this189) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float r212;
HXDLIN(  21)													int this190 = ((rhs3 >> 16) & 255);
HXDLIN(  21)													if ((this190 == 0)) {
HXLINE(  21)														r212 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														r212 = (( (Float)(this190) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float g212;
HXDLIN(  21)													int this191 = ((rhs3 >> 8) & 255);
HXDLIN(  21)													if ((this191 == 0)) {
HXLINE(  21)														g212 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														g212 = (( (Float)(this191) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float b215;
HXDLIN(  21)													int this192 = (rhs3 & 255);
HXDLIN(  21)													if ((this192 == 0)) {
HXLINE(  21)														b215 = ((Float)0.);
            													}
            													else {
HXLINE(  21)														b215 = (( (Float)(this192) ) / ( (Float)(255) ));
            													}
HXDLIN(  21)													Float a312 = (a116 * (( (Float)(1) ) - a214));
HXDLIN(  21)													int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a214))));
HXDLIN(  21)													int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a214))));
HXDLIN(  21)													int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a312) + (b215 * a214))));
HXDLIN(  21)													int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a214)));
HXDLIN(  21)													int blended11 = ((((a46 << 24) | (r33 << 16)) | (g33 << 8)) | b47);
HXDLIN(  21)													{
HXLINE(  21)														int _hx_tmp48;
HXDLIN(  21)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)															_hx_tmp48 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            														}
            														else {
HXLINE(  21)															_hx_tmp48 = blended11;
            														}
HXDLIN(  21)														::iterMagic::Iimg_obj::set(this68->image,location11,_hx_tmp48);
            													}
            												}
            												else {
HXLINE(  21)													int value3;
HXDLIN(  21)													if (this68->isLittle) {
HXLINE(  21)														value3 = ((((a45 << 24) | (b46 << 16)) | (g32 << 8)) | r32);
            													}
            													else {
HXLINE(  21)														value3 = ((((a45 << 24) | (r32 << 16)) | (g32 << 8)) | b46);
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(this68->image,location11,value3);
            												}
            											}
            										}
HXLINE( 850)										found5 = true;
            									}
            									else {
HXLINE(  21)										if (found5) {
HXLINE(  21)											goto _hx_goto_73;
            										}
            									}
            								}
            								_hx_goto_73:;
            							}
            						}
            					}
HXDLIN(  21)					if ((hasHit == false)) {
HXLINE(  21)						 ::pi_xy::algo::HitTri v16 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx5,by5,cx5,cy5,dx3,dy3,true);
HXDLIN(  21)						if (hasUndo5) {
HXLINE(  21)							v16->undoImage = undoImage15;
HXDLIN(  21)							v16->undoX = xIter35->start;
HXDLIN(  21)							v16->undoY = yIter35->start;
            						}
            					}
            				}
HXDLIN(  21)				if ((hasHit == true)) {
HXLINE(  21)					 ::pi_xy::algo::HitQuad v17 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax3,ay3,bx5,by5,cx5,cy5,dx3,dy3,true);
HXLINE(  17)					_hx_tmp = v17;
            				}
            				else {
HXLINE(  17)					_hx_tmp = null();
            				}
            			}
            			else {
HXLINE(  23)				 ::pi_xy::ImageStruct this193 = pixelImage;
HXDLIN(  23)				Float ax4 = (this->aX + this->offX);
HXDLIN(  23)				Float ay4 = (this->aY + this->offY);
HXDLIN(  23)				Float bx6 = (this->bX + this->offX);
HXDLIN(  23)				Float by6 = (this->bY + this->offY);
HXDLIN(  23)				Float cx6 = (this->cX + this->offX);
HXDLIN(  23)				Float cy6 = (this->cY + this->offY);
HXDLIN(  23)				Float dx8 = (this->dX + this->offX);
HXDLIN(  23)				Float dy8 = (this->dY + this->offY);
HXDLIN(  23)				int color2 = this->strokeColor;
HXDLIN(  23)				Float soft1 = this->edgeSoft;
HXDLIN(  23)				bool hasHit1 = false;
HXDLIN(  23)				{
HXLINE(  23)					bool hasUndo6 = true;
HXDLIN(  23)					int aA4 = ((color2 >> 24) & 255);
HXDLIN(  23)					int rA4 = ((color2 >> 16) & 255);
HXDLIN(  23)					int gA4 = ((color2 >> 8) & 255);
HXDLIN(  23)					int bA4 = (color2 & 255);
HXDLIN(  23)					Float bcx4 = (bx6 - dx8);
HXDLIN(  23)					Float bcy4 = (by6 - dy8);
HXDLIN(  23)					Float acx4 = (ax4 - dx8);
HXDLIN(  23)					Float acy4 = (ay4 - dy8);
HXDLIN(  23)					Float dot114 = ((bcx4 * bcx4) + (bcy4 * bcy4));
HXDLIN(  23)					Float dot124 = ((bcx4 * acx4) + (bcy4 * acy4));
HXDLIN(  23)					Float dot224 = ((acx4 * acx4) + (acy4 * acy4));
HXDLIN(  23)					Float denom14 = (( (Float)(1) ) / ((dot114 * dot224) - (dot124 * dot124)));
HXDLIN(  23)					 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN(  23)					if ((ax4 > bx6)) {
HXLINE(  23)						if ((ax4 > dx8)) {
HXLINE(  23)							int min36;
HXDLIN(  23)							if ((bx6 > dx8)) {
HXLINE(  23)								min36 = ::Math_obj::floor(dx8);
            							}
            							else {
HXLINE(  23)								min36 = ::Math_obj::floor(bx6);
            							}
HXDLIN(  23)							int ii_min64 = min36;
HXDLIN(  23)							int ii_max64 = ::Math_obj::ceil(ax4);
HXDLIN(  23)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            						}
            						else {
HXLINE(  23)							int ii_min65 = ::Math_obj::floor(bx6);
HXDLIN(  23)							int ii_max65 = ::Math_obj::ceil(dx8);
HXDLIN(  23)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            						}
            					}
            					else {
HXLINE(  23)						if ((bx6 > dx8)) {
HXLINE(  23)							int min37;
HXDLIN(  23)							if ((ax4 > dx8)) {
HXLINE(  23)								min37 = ::Math_obj::floor(dx8);
            							}
            							else {
HXLINE(  23)								min37 = ::Math_obj::ceil(ax4);
            							}
HXDLIN(  23)							int ii_min66 = min37;
HXDLIN(  23)							int ii_max66 = ::Math_obj::ceil(bx6);
HXDLIN(  23)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            						}
            						else {
HXLINE(  23)							int ii_min67 = ::Math_obj::floor(ax4);
HXDLIN(  23)							int ii_max67 = ::Math_obj::ceil(dx8);
HXDLIN(  23)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            						}
            					}
HXDLIN(  23)					 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN(  23)					if ((ay4 > by6)) {
HXLINE(  23)						if ((ay4 > dy8)) {
HXLINE(  23)							int min38;
HXDLIN(  23)							if ((by6 > dy8)) {
HXLINE(  23)								min38 = ::Math_obj::floor(dy8);
            							}
            							else {
HXLINE(  23)								min38 = ::Math_obj::floor(by6);
            							}
HXDLIN(  23)							int ii_min68 = min38;
HXDLIN(  23)							int ii_max68 = ::Math_obj::ceil(ay4);
HXDLIN(  23)							yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            						}
            						else {
HXLINE(  23)							int ii_min69 = ::Math_obj::floor(by6);
HXDLIN(  23)							int ii_max69 = ::Math_obj::ceil(dy8);
HXDLIN(  23)							yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            						}
            					}
            					else {
HXLINE(  23)						if ((by6 > dy8)) {
HXLINE(  23)							int min39;
HXDLIN(  23)							if ((ay4 > dy8)) {
HXLINE(  23)								min39 = ::Math_obj::floor(dy8);
            							}
            							else {
HXLINE(  23)								min39 = ::Math_obj::ceil(ay4);
            							}
HXDLIN(  23)							int ii_min70 = min39;
HXDLIN(  23)							int ii_max70 = ::Math_obj::ceil(by6);
HXDLIN(  23)							yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            						}
            						else {
HXLINE(  23)							int ii_min71 = ::Math_obj::floor(ay4);
HXDLIN(  23)							int ii_max71 = ::Math_obj::ceil(dy8);
HXDLIN(  23)							yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            						}
            					}
HXDLIN(  23)					 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN(  23)					if (hasUndo6) {
HXLINE(  23)						int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN(  23)						int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN(  23)						 ::Dynamic imageType6 = null();
HXDLIN(  23)						 ::pi_xy::ImageStruct this194 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)						if (::hx::IsNull( imageType6 )) {
HXLINE(  54)							imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  23)						::Dynamic undoImage19;
HXDLIN(  23)						switch((int)(( (int)(imageType6) ))){
            							case (int)0: {
HXLINE(  23)								 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::BytesImg b48 = byt6;
HXDLIN(  23)								{
HXLINE(  23)									b48->width = width6;
HXDLIN(  23)									b48->height = height6;
HXDLIN(  23)									b48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)									b48->data = ::haxe::io::Bytes_obj::alloc((b48->length * 4));
HXDLIN(  23)									{
HXLINE(  23)										int len12 = b48->length;
HXDLIN(  23)										int w6 = 0;
HXDLIN(  23)										{
HXLINE(  23)											int _g120 = 0;
HXDLIN(  23)											int _g121 = b48->height;
HXDLIN(  23)											while((_g120 < _g121)){
HXLINE(  23)												_g120 = (_g120 + 1);
HXDLIN(  23)												int y20 = (_g120 - 1);
HXDLIN(  23)												{
HXLINE(  23)													int _g122 = 0;
HXDLIN(  23)													int _g123 = b48->width;
HXDLIN(  23)													while((_g122 < _g123)){
HXLINE(  23)														_g122 = (_g122 + 1);
HXDLIN(  23)														int x20 = (_g122 - 1);
HXDLIN(  23)														{
HXLINE(  23)															w6 = (w6 + 1);
HXDLIN(  23)															b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXLINE(  23)															w6 = (w6 + 1);
HXDLIN(  23)															b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXLINE(  23)															w6 = (w6 + 1);
HXDLIN(  23)															b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXLINE(  23)															w6 = (w6 + 1);
HXDLIN(  23)															b48->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								undoImage19 = b48;
            							}
            							break;
            							case (int)1: {
HXLINE(  23)								 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::ArrIntImg a47 = arrI6;
HXDLIN(  23)								{
HXLINE(  23)									a47->width = width6;
HXDLIN(  23)									a47->height = height6;
HXDLIN(  23)									a47->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)									a47->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)									{
HXLINE(  23)										int _g124 = 0;
HXDLIN(  23)										int _g125 = a47->length;
HXDLIN(  23)										while((_g124 < _g125)){
HXLINE(  23)											_g124 = (_g124 + 1);
HXDLIN(  23)											int i52 = (_g124 - 1);
HXDLIN(  23)											a47->data[i52] = 0;
            										}
            									}
            								}
HXDLIN(  23)								undoImage19 = a47;
            							}
            							break;
            							case (int)2: {
HXLINE(  23)								 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::U32ArrImg b49 = u32a6;
HXDLIN(  23)								{
HXLINE(  23)									b49->width = width6;
HXDLIN(  23)									b49->height = height6;
HXDLIN(  23)									b49->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)									int size6 = (b49->length * 4);
HXDLIN(  23)									b49->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN(  23)									{
HXLINE(  23)										int _g126 = 0;
HXDLIN(  23)										int _g127 = b49->length;
HXDLIN(  23)										while((_g126 < _g127)){
HXLINE(  23)											_g126 = (_g126 + 1);
HXDLIN(  23)											int i53 = (_g126 - 1);
HXDLIN(  23)											{
HXLINE(  23)												 ::haxe::io::ArrayBufferViewImpl this195 = b49->data;
HXDLIN(  23)												bool undoImage20;
HXDLIN(  23)												if ((i53 >= 0)) {
HXLINE(  23)													undoImage20 = (i53 < (this195->byteLength >> 2));
            												}
            												else {
HXLINE(  23)													undoImage20 = false;
            												}
HXDLIN(  23)												if (undoImage20) {
HXLINE(  23)													 ::haxe::io::Bytes _this6 = this195->bytes;
HXDLIN(  23)													int pos6 = ((i53 << 2) + this195->byteOffset);
HXDLIN(  23)													_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN(  23)													_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)													_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)													_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								undoImage19 = b49;
            							}
            							break;
            							case (int)3: {
HXLINE(  23)								 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::VecIntImg v18 = vec6;
HXDLIN(  23)								{
HXLINE(  23)									v18->width = width6;
HXDLIN(  23)									v18->height = height6;
HXDLIN(  23)									v18->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)									v18->data = ::Array_obj< int >::__new(v18->length);
HXDLIN(  23)									{
HXLINE(  23)										int _g128 = 0;
HXDLIN(  23)										int _g129 = v18->length;
HXDLIN(  23)										while((_g128 < _g129)){
HXLINE(  23)											_g128 = (_g128 + 1);
HXDLIN(  23)											int i54 = (_g128 - 1);
HXDLIN(  23)											v18->data->__unsafe_set(i54,0);
            										}
            									}
            								}
HXDLIN(  23)								undoImage19 = v18;
            							}
            							break;
            							case (int)4: {
HXLINE(  23)								 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::StackIntImg b50 = sInt6;
HXDLIN(  23)								{
HXLINE(  23)									b50->width = width6;
HXDLIN(  23)									b50->height = height6;
HXDLIN(  23)									b50->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)									b50->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)									{
HXLINE(  23)										int len13 = b50->length;
HXDLIN(  23)										 ::haxe::ds::GenericStack_Int d6 = b50->data;
HXDLIN(  23)										if (::hx::IsNull( d6->head )) {
HXLINE(  23)											int _g130 = 0;
HXDLIN(  23)											int _g131 = len13;
HXDLIN(  23)											while((_g130 < _g131)){
HXLINE(  23)												_g130 = (_g130 + 1);
HXDLIN(  23)												int i55 = (_g130 - 1);
HXDLIN(  23)												d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            											}
            										}
            										else {
HXLINE(  23)											int _g132 = 0;
HXDLIN(  23)											int _g133 = len13;
HXDLIN(  23)											while((_g132 < _g133)){
HXLINE(  23)												_g132 = (_g132 + 1);
HXDLIN(  23)												int i56 = (_g132 - 1);
HXDLIN(  23)												{
HXLINE(  23)													 ::haxe::ds::GenericCell_Int l6 = b50->data->head;
HXDLIN(  23)													 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN(  23)													{
HXLINE(  23)														int _g134 = 0;
HXDLIN(  23)														int _g135 = i56;
HXDLIN(  23)														while((_g134 < _g135)){
HXLINE(  23)															_g134 = (_g134 + 1);
HXDLIN(  23)															int i57 = (_g134 - 1);
HXLINE( 345)															prev6 = l6;
HXLINE( 346)															l6 = l6->next;
            														}
            													}
HXLINE(  23)													if (::hx::IsNull( prev6 )) {
HXLINE(  23)														b50->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  23)														l6 = null();
            													}
            													else {
HXLINE(  23)														prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  23)														l6 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								undoImage19 = b50;
            							}
            							break;
            						}
HXDLIN(  23)						this194->image = undoImage19;
HXDLIN(  23)						this194->width = width6;
HXDLIN(  23)						this194->height = height6;
HXDLIN(  23)						this194->imageType = ( (int)(imageType6) );
HXDLIN(  23)						undoImage18 = this194;
HXDLIN(  23)						{
HXLINE(  23)							int rectLeft6 = xIter36->start;
HXDLIN(  23)							int rectTop6 = yIter36->start;
HXDLIN(  23)							int rectRight6 = xIter36->max;
HXDLIN(  23)							bool forceClear6 = false;
HXDLIN(  23)							{
HXLINE(  23)								int _g136 = rectTop6;
HXDLIN(  23)								int _g137 = yIter36->max;
HXDLIN(  23)								while((_g136 < _g137)){
HXLINE(  23)									_g136 = (_g136 + 1);
HXDLIN(  23)									int dy9 = (_g136 - 1);
HXDLIN(  23)									{
HXLINE(  23)										int _g138 = rectLeft6;
HXDLIN(  23)										int _g139 = rectRight6;
HXDLIN(  23)										while((_g138 < _g139)){
HXLINE(  23)											_g138 = (_g138 + 1);
HXDLIN(  23)											int dx9 = (_g138 - 1);
HXDLIN(  23)											::Dynamic this196 = this193->image;
HXDLIN(  23)											int index26;
HXDLIN(  23)											if (this193->useVirtualPos) {
HXLINE(  23)												index26 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this193->virtualY) * ( (Float)(this193->width) )) + dx9) - this193->virtualX));
            											}
            											else {
HXLINE(  23)												index26 = ::Std_obj::_hx_int(( (Float)(((dy9 * this193->width) + dx9)) ));
            											}
HXDLIN(  23)											int c24 = ::iterMagic::Iimg_obj::get(this196,index26);
HXDLIN(  23)											int col6;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)												col6 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            											}
            											else {
HXLINE(  23)												col6 = c24;
            											}
HXDLIN(  23)											bool _hx_tmp49;
HXDLIN(  23)											if (this193->useMask) {
HXLINE(  23)												_hx_tmp49 = ::hx::IsNotNull( this193->mask );
            											}
            											else {
HXLINE(  23)												_hx_tmp49 = false;
            											}
HXDLIN(  23)											if (_hx_tmp49) {
HXLINE(  23)												 ::pi_xy::ImageStruct this197 = this193->mask;
HXDLIN(  23)												::Dynamic this198 = this197->image;
HXDLIN(  23)												int index27;
HXDLIN(  23)												if (this197->useVirtualPos) {
HXLINE(  23)													index27 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this197->virtualY) * ( (Float)(this197->width) )) + dx9) - this197->virtualX));
            												}
            												else {
HXLINE(  23)													index27 = ::Std_obj::_hx_int(( (Float)(((dy9 * this197->width) + dx9)) ));
            												}
HXDLIN(  23)												int c25 = ::iterMagic::Iimg_obj::get(this198,index27);
HXDLIN(  23)												int v19;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)													v19 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            												}
            												else {
HXLINE(  23)													v19 = c25;
            												}
HXDLIN(  23)												int maskPixel6 = v19;
HXDLIN(  23)												int this199 = col6;
HXDLIN(  23)												if ((maskPixel6 == 0)) {
HXLINE(  23)													col6 = this199;
            												}
            												else {
HXLINE(  23)													Float m06;
HXDLIN(  23)													int this200 = ((maskPixel6 >> 24) & 255);
HXDLIN(  23)													if ((this200 == 0)) {
HXLINE(  23)														m06 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														m06 = (( (Float)(this200) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float m16;
HXDLIN(  23)													int this201 = ((maskPixel6 >> 16) & 255);
HXDLIN(  23)													if ((this201 == 0)) {
HXLINE(  23)														m16 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														m16 = (( (Float)(this201) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float m26;
HXDLIN(  23)													int this202 = ((maskPixel6 >> 8) & 255);
HXDLIN(  23)													if ((this202 == 0)) {
HXLINE(  23)														m26 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														m26 = (( (Float)(this202) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float m36;
HXDLIN(  23)													int this203 = (maskPixel6 & 255);
HXDLIN(  23)													if ((this203 == 0)) {
HXLINE(  23)														m36 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														m36 = (( (Float)(this203) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this199 >> 24) & 255)) )));
HXDLIN(  23)													int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this199 >> 16) & 255)) )));
HXDLIN(  23)													int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this199 >> 8) & 255)) )));
HXDLIN(  23)													int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this199 & 255)) )));
HXDLIN(  23)													col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  23)											if ((col6 != 0)) {
HXLINE(  23)												int x21 = (dx9 - rectLeft6);
HXDLIN(  23)												int y21 = (dy9 - rectTop6);
HXDLIN(  23)												int c26 = col6;
HXDLIN(  23)												bool _hx_tmp50;
HXDLIN(  23)												if ((((c26 >> 24) & 255) < 254)) {
HXLINE(  23)													_hx_tmp50 = undoImage18->transparent;
            												}
            												else {
HXLINE(  23)													_hx_tmp50 = false;
            												}
HXDLIN(  23)												if (_hx_tmp50) {
HXLINE(  23)													int location12;
HXDLIN(  23)													if (undoImage18->useVirtualPos) {
HXLINE(  23)														location12 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x21) - undoImage18->virtualX));
            													}
            													else {
HXLINE(  23)														location12 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage18->width) + x21)) ));
            													}
HXDLIN(  23)													int this204 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN(  23)													int this205;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)														this205 = ((((((this204 >> 24) & 255) << 24) | ((this204 & 255) << 16)) | (((this204 >> 8) & 255) << 8)) | ((this204 >> 16) & 255));
            													}
            													else {
HXLINE(  23)														this205 = this204;
            													}
HXDLIN(  23)													Float a117;
HXDLIN(  23)													int this206 = ((this205 >> 24) & 255);
HXDLIN(  23)													if ((this206 == 0)) {
HXLINE(  23)														a117 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														a117 = (( (Float)(this206) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float r113;
HXDLIN(  23)													int this207 = ((this205 >> 16) & 255);
HXDLIN(  23)													if ((this207 == 0)) {
HXLINE(  23)														r113 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														r113 = (( (Float)(this207) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float g113;
HXDLIN(  23)													int this208 = ((this205 >> 8) & 255);
HXDLIN(  23)													if ((this208 == 0)) {
HXLINE(  23)														g113 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														g113 = (( (Float)(this208) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float b118;
HXDLIN(  23)													int this209 = (this205 & 255);
HXDLIN(  23)													if ((this209 == 0)) {
HXLINE(  23)														b118 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														b118 = (( (Float)(this209) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float a215;
HXDLIN(  23)													int this210 = ((col6 >> 24) & 255);
HXDLIN(  23)													if ((this210 == 0)) {
HXLINE(  23)														a215 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														a215 = (( (Float)(this210) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float r213;
HXDLIN(  23)													int this211 = ((col6 >> 16) & 255);
HXDLIN(  23)													if ((this211 == 0)) {
HXLINE(  23)														r213 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														r213 = (( (Float)(this211) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float g213;
HXDLIN(  23)													int this212 = ((col6 >> 8) & 255);
HXDLIN(  23)													if ((this212 == 0)) {
HXLINE(  23)														g213 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														g213 = (( (Float)(this212) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float b216;
HXDLIN(  23)													int this213 = (col6 & 255);
HXDLIN(  23)													if ((this213 == 0)) {
HXLINE(  23)														b216 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														b216 = (( (Float)(this213) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float a313 = (a117 * (( (Float)(1) ) - a215));
HXDLIN(  23)													int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a215))));
HXDLIN(  23)													int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a215))));
HXDLIN(  23)													int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a313) + (b216 * a215))));
HXDLIN(  23)													int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a215)));
HXDLIN(  23)													int blended12 = ((((a48 << 24) | (r34 << 16)) | (g34 << 8)) | b51);
HXDLIN(  23)													{
HXLINE(  23)														int _hx_tmp51;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)															_hx_tmp51 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            														}
            														else {
HXLINE(  23)															_hx_tmp51 = blended12;
            														}
HXDLIN(  23)														::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp51);
            													}
            												}
            												else {
HXLINE(  23)													::Dynamic this214 = undoImage18->image;
HXDLIN(  23)													int index28;
HXDLIN(  23)													if (undoImage18->useVirtualPos) {
HXLINE(  23)														index28 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x21) - undoImage18->virtualX));
            													}
            													else {
HXLINE(  23)														index28 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage18->width) + x21)) ));
            													}
HXDLIN(  23)													int _hx_tmp52;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)														_hx_tmp52 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            													}
            													else {
HXLINE(  23)														_hx_tmp52 = c26;
            													}
HXDLIN(  23)													::iterMagic::Iimg_obj::set(this214,index28,_hx_tmp52);
            												}
            											}
            											else {
HXLINE(  23)												if (forceClear6) {
HXLINE(  23)													::Dynamic this215 = undoImage18->image;
HXDLIN(  23)													int x22 = (dx9 - rectLeft6);
HXDLIN(  23)													int y22 = (dy9 - rectTop6);
HXDLIN(  23)													int index29;
HXDLIN(  23)													if (undoImage18->useVirtualPos) {
HXLINE(  23)														index29 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x22) - undoImage18->virtualX));
            													}
            													else {
HXLINE(  23)														index29 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage18->width) + x22)) ));
            													}
HXDLIN(  23)													::iterMagic::Iimg_obj::set(this215,index29,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  23)					bool found6 = false;
HXDLIN(  23)					Float min40 = ( (Float)(0) );
HXDLIN(  23)					Float max4 = ( (Float)(0) );
HXDLIN(  23)					int a49 = 0;
HXDLIN(  23)					int r35 = 0;
HXDLIN(  23)					int g35 = 0;
HXDLIN(  23)					int b52 = 0;
HXDLIN(  23)					{
HXLINE(  23)						int _g_min12 = xIter36->start;
HXDLIN(  23)						int _g_max12 = xIter36->max;
HXDLIN(  23)						while((_g_min12 < _g_max12)){
HXLINE(  23)							_g_min12 = (_g_min12 + 1);
HXDLIN(  23)							int px4 = (_g_min12 - 1);
HXDLIN(  23)							Float pcx4 = (( (Float)(px4) ) - dx8);
HXLINE( 695)							found6 = false;
HXLINE(  23)							{
HXLINE(  23)								int _g_min13 = yIter36->start;
HXDLIN(  23)								int _g_max13 = yIter36->max;
HXDLIN(  23)								while((_g_min13 < _g_max13)){
HXLINE(  23)									_g_min13 = (_g_min13 + 1);
HXDLIN(  23)									int py4 = (_g_min13 - 1);
HXDLIN(  23)									Float pcy4 = (( (Float)(py4) ) - dy8);
HXDLIN(  23)									Float dot314 = ((pcx4 * bcx4) + (pcy4 * bcy4));
HXDLIN(  23)									Float dot324 = ((pcx4 * acx4) + (pcy4 * acy4));
HXDLIN(  23)									Float ratioA4 = (((dot224 * dot314) - (dot124 * dot324)) * denom14);
HXDLIN(  23)									Float ratioB4 = (((dot114 * dot324) - (dot124 * dot314)) * denom14);
HXDLIN(  23)									Float ratioC4 = ((((Float)1.0) - ratioB4) - ratioA4);
HXDLIN(  23)									bool _hx_tmp53;
HXDLIN(  23)									bool _hx_tmp54;
HXDLIN(  23)									if ((ratioA4 >= 0)) {
HXLINE(  23)										_hx_tmp54 = (ratioB4 >= 0);
            									}
            									else {
HXLINE(  23)										_hx_tmp54 = false;
            									}
HXDLIN(  23)									if (_hx_tmp54) {
HXLINE(  23)										_hx_tmp53 = (ratioC4 >= 0);
            									}
            									else {
HXLINE(  23)										_hx_tmp53 = false;
            									}
HXDLIN(  23)									if (_hx_tmp53) {
HXLINE(  23)										if ((ratioA4 < ratioC4)) {
HXLINE(  23)											min40 = ratioA4;
            										}
            										else {
HXLINE(  23)											min40 = ratioC4;
            										}
HXDLIN(  23)										if ((ratioA4 > ratioB4)) {
HXLINE(  23)											max4 = ratioA4;
            										}
            										else {
HXLINE(  23)											max4 = ratioB4;
            										}
HXDLIN(  23)										if (!((max4 > ratioC4))) {
HXLINE(  23)											max4 = ratioC4;
            										}
HXLINE( 728)										max4 = ((( (Float)(1) ) - max4) / ( (Float)(2) ));
HXLINE(  23)										if (!((min40 < max4))) {
HXLINE(  23)											min40 = ((max4 + min40) / ( (Float)(2) ));
            										}
HXDLIN(  23)										int i58 = ::Std_obj::_hx_int(((( (Float)(aA4) ) * soft1) * min40));
HXDLIN(  23)										if ((i58 > 255)) {
HXLINE(  24)											i58 = 255;
            										}
HXLINE(  23)										if ((i58 < 0)) {
HXLINE(  25)											i58 = 0;
            										}
HXLINE(  23)										a49 = i58;
HXDLIN(  23)										int i59 = ::Std_obj::_hx_int(( (Float)(rA4) ));
HXDLIN(  23)										if ((i59 > 255)) {
HXLINE(  24)											i59 = 255;
            										}
HXLINE(  23)										if ((i59 < 0)) {
HXLINE(  25)											i59 = 0;
            										}
HXLINE( 747)										r35 = i59;
HXLINE(  23)										int i60 = ::Std_obj::_hx_int(( (Float)(gA4) ));
HXDLIN(  23)										if ((i60 > 255)) {
HXLINE(  24)											i60 = 255;
            										}
HXLINE(  23)										if ((i60 < 0)) {
HXLINE(  25)											i60 = 0;
            										}
HXLINE( 748)										g35 = i60;
HXLINE(  23)										int i61 = ::Std_obj::_hx_int(( (Float)(bA4) ));
HXDLIN(  23)										if ((i61 > 255)) {
HXLINE(  24)											i61 = 255;
            										}
HXLINE(  23)										if ((i61 < 0)) {
HXLINE(  25)											i61 = 0;
            										}
HXLINE( 749)										b52 = i61;
HXLINE(  23)										{
HXLINE(  23)											int location13;
HXDLIN(  23)											if (this193->useVirtualPos) {
HXLINE(  23)												location13 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - this193->virtualY) * ( (Float)(this193->width) )) + px4) - this193->virtualX));
            											}
            											else {
HXLINE(  23)												location13 = ::Std_obj::_hx_int(( (Float)(((py4 * this193->width) + px4)) ));
            											}
HXDLIN(  23)											bool _hx_tmp55;
HXDLIN(  23)											if (this193->transparent) {
HXLINE(  23)												_hx_tmp55 = (a49 < 254);
            											}
            											else {
HXLINE(  23)												_hx_tmp55 = false;
            											}
HXDLIN(  23)											if (_hx_tmp55) {
HXLINE(  23)												int this216 = ::iterMagic::Iimg_obj::get(this193->image,location13);
HXDLIN(  23)												int old4;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)													old4 = ((((((this216 >> 24) & 255) << 24) | ((this216 & 255) << 16)) | (((this216 >> 8) & 255) << 8)) | ((this216 >> 16) & 255));
            												}
            												else {
HXLINE(  23)													old4 = this216;
            												}
HXDLIN(  23)												int rhs4 = ((((a49 << 24) | (r35 << 16)) | (g35 << 8)) | b52);
HXDLIN(  23)												Float a118;
HXDLIN(  23)												int this217 = ((old4 >> 24) & 255);
HXDLIN(  23)												if ((this217 == 0)) {
HXLINE(  23)													a118 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													a118 = (( (Float)(this217) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float r114;
HXDLIN(  23)												int this218 = ((old4 >> 16) & 255);
HXDLIN(  23)												if ((this218 == 0)) {
HXLINE(  23)													r114 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													r114 = (( (Float)(this218) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float g114;
HXDLIN(  23)												int this219 = ((old4 >> 8) & 255);
HXDLIN(  23)												if ((this219 == 0)) {
HXLINE(  23)													g114 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													g114 = (( (Float)(this219) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float b119;
HXDLIN(  23)												int this220 = (old4 & 255);
HXDLIN(  23)												if ((this220 == 0)) {
HXLINE(  23)													b119 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													b119 = (( (Float)(this220) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float a216;
HXDLIN(  23)												int this221 = ((rhs4 >> 24) & 255);
HXDLIN(  23)												if ((this221 == 0)) {
HXLINE(  23)													a216 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													a216 = (( (Float)(this221) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float r214;
HXDLIN(  23)												int this222 = ((rhs4 >> 16) & 255);
HXDLIN(  23)												if ((this222 == 0)) {
HXLINE(  23)													r214 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													r214 = (( (Float)(this222) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float g214;
HXDLIN(  23)												int this223 = ((rhs4 >> 8) & 255);
HXDLIN(  23)												if ((this223 == 0)) {
HXLINE(  23)													g214 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													g214 = (( (Float)(this223) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float b217;
HXDLIN(  23)												int this224 = (rhs4 & 255);
HXDLIN(  23)												if ((this224 == 0)) {
HXLINE(  23)													b217 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													b217 = (( (Float)(this224) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float a314 = (a118 * (( (Float)(1) ) - a216));
HXDLIN(  23)												int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a216))));
HXDLIN(  23)												int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a216))));
HXDLIN(  23)												int b53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a314) + (b217 * a216))));
HXDLIN(  23)												int a50 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a216)));
HXDLIN(  23)												int blended13 = ((((a50 << 24) | (r36 << 16)) | (g36 << 8)) | b53);
HXDLIN(  23)												{
HXLINE(  23)													int _hx_tmp56;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)														_hx_tmp56 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            													}
            													else {
HXLINE(  23)														_hx_tmp56 = blended13;
            													}
HXDLIN(  23)													::iterMagic::Iimg_obj::set(this193->image,location13,_hx_tmp56);
            												}
            											}
            											else {
HXLINE(  23)												int value4;
HXDLIN(  23)												if (this193->isLittle) {
HXLINE(  23)													value4 = ((((a49 << 24) | (b52 << 16)) | (g35 << 8)) | r35);
            												}
            												else {
HXLINE(  23)													value4 = ((((a49 << 24) | (r35 << 16)) | (g35 << 8)) | b52);
            												}
HXDLIN(  23)												::iterMagic::Iimg_obj::set(this193->image,location13,value4);
            											}
            										}
HXLINE( 751)										found6 = true;
            									}
            									else {
HXLINE(  23)										if (found6) {
HXLINE(  23)											goto _hx_goto_85;
            										}
            									}
            								}
            								_hx_goto_85:;
            							}
            						}
            					}
HXDLIN(  23)					if ((hasHit1 == false)) {
HXLINE(  23)						 ::pi_xy::algo::HitTri v20 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax4,ay4,bx6,by6,dx8,dy8,true);
HXDLIN(  23)						if (hasUndo6) {
HXLINE(  23)							v20->undoImage = undoImage18;
HXDLIN(  23)							v20->undoX = xIter36->start;
HXDLIN(  23)							v20->undoY = yIter36->start;
            						}
            					}
            				}
HXDLIN(  23)				{
HXLINE(  23)					bool hasUndo7 = true;
HXDLIN(  23)					int aA5 = ((color2 >> 24) & 255);
HXDLIN(  23)					int rA5 = ((color2 >> 16) & 255);
HXDLIN(  23)					int gA5 = ((color2 >> 8) & 255);
HXDLIN(  23)					int bA5 = (color2 & 255);
HXDLIN(  23)					Float bcx5 = (cx6 - dx8);
HXDLIN(  23)					Float bcy5 = (cy6 - dy8);
HXDLIN(  23)					Float acx5 = (bx6 - dx8);
HXDLIN(  23)					Float acy5 = (by6 - dy8);
HXDLIN(  23)					Float dot115 = ((bcx5 * bcx5) + (bcy5 * bcy5));
HXDLIN(  23)					Float dot125 = ((bcx5 * acx5) + (bcy5 * acy5));
HXDLIN(  23)					Float dot225 = ((acx5 * acx5) + (acy5 * acy5));
HXDLIN(  23)					Float denom15 = (( (Float)(1) ) / ((dot115 * dot225) - (dot125 * dot125)));
HXDLIN(  23)					 ::pi_xy::iter::IntIterStart xIter37;
HXDLIN(  23)					if ((bx6 > cx6)) {
HXLINE(  23)						if ((bx6 > dx8)) {
HXLINE(  23)							int min41;
HXDLIN(  23)							if ((cx6 > dx8)) {
HXLINE(  23)								min41 = ::Math_obj::floor(dx8);
            							}
            							else {
HXLINE(  23)								min41 = ::Math_obj::floor(cx6);
            							}
HXDLIN(  23)							int ii_min72 = min41;
HXDLIN(  23)							int ii_max72 = ::Math_obj::ceil(bx6);
HXDLIN(  23)							xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            						}
            						else {
HXLINE(  23)							int ii_min73 = ::Math_obj::floor(cx6);
HXDLIN(  23)							int ii_max73 = ::Math_obj::ceil(dx8);
HXDLIN(  23)							xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            						}
            					}
            					else {
HXLINE(  23)						if ((cx6 > dx8)) {
HXLINE(  23)							int min42;
HXDLIN(  23)							if ((bx6 > dx8)) {
HXLINE(  23)								min42 = ::Math_obj::floor(dx8);
            							}
            							else {
HXLINE(  23)								min42 = ::Math_obj::ceil(bx6);
            							}
HXDLIN(  23)							int ii_min74 = min42;
HXDLIN(  23)							int ii_max74 = ::Math_obj::ceil(cx6);
HXDLIN(  23)							xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min74,ii_max74);
            						}
            						else {
HXLINE(  23)							int ii_min75 = ::Math_obj::floor(bx6);
HXDLIN(  23)							int ii_max75 = ::Math_obj::ceil(dx8);
HXDLIN(  23)							xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min75,ii_max75);
            						}
            					}
HXDLIN(  23)					 ::pi_xy::iter::IntIterStart yIter37;
HXDLIN(  23)					if ((by6 > cy6)) {
HXLINE(  23)						if ((by6 > dy8)) {
HXLINE(  23)							int min43;
HXDLIN(  23)							if ((cy6 > dy8)) {
HXLINE(  23)								min43 = ::Math_obj::floor(dy8);
            							}
            							else {
HXLINE(  23)								min43 = ::Math_obj::floor(cy6);
            							}
HXDLIN(  23)							int ii_min76 = min43;
HXDLIN(  23)							int ii_max76 = ::Math_obj::ceil(by6);
HXDLIN(  23)							yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min76,ii_max76);
            						}
            						else {
HXLINE(  23)							int ii_min77 = ::Math_obj::floor(cy6);
HXDLIN(  23)							int ii_max77 = ::Math_obj::ceil(dy8);
HXDLIN(  23)							yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min77,ii_max77);
            						}
            					}
            					else {
HXLINE(  23)						if ((cy6 > dy8)) {
HXLINE(  23)							int min44;
HXDLIN(  23)							if ((by6 > dy8)) {
HXLINE(  23)								min44 = ::Math_obj::floor(dy8);
            							}
            							else {
HXLINE(  23)								min44 = ::Math_obj::ceil(by6);
            							}
HXDLIN(  23)							int ii_min78 = min44;
HXDLIN(  23)							int ii_max78 = ::Math_obj::ceil(cy6);
HXDLIN(  23)							yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min78,ii_max78);
            						}
            						else {
HXLINE(  23)							int ii_min79 = ::Math_obj::floor(by6);
HXDLIN(  23)							int ii_max79 = ::Math_obj::ceil(dy8);
HXDLIN(  23)							yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min79,ii_max79);
            						}
            					}
HXDLIN(  23)					 ::pi_xy::ImageStruct undoImage21 = null();
HXDLIN(  23)					if (hasUndo7) {
HXLINE(  23)						int width7 = ((xIter37->max - xIter37->start) + 1);
HXDLIN(  23)						int height7 = ((yIter37->max - yIter37->start) + 1);
HXDLIN(  23)						 ::Dynamic imageType7 = null();
HXDLIN(  23)						 ::pi_xy::ImageStruct this225 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)						if (::hx::IsNull( imageType7 )) {
HXLINE(  54)							imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  23)						::Dynamic undoImage22;
HXDLIN(  23)						switch((int)(( (int)(imageType7) ))){
            							case (int)0: {
HXLINE(  23)								 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::BytesImg b54 = byt7;
HXDLIN(  23)								{
HXLINE(  23)									b54->width = width7;
HXDLIN(  23)									b54->height = height7;
HXDLIN(  23)									b54->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)									b54->data = ::haxe::io::Bytes_obj::alloc((b54->length * 4));
HXDLIN(  23)									{
HXLINE(  23)										int len14 = b54->length;
HXDLIN(  23)										int w7 = 0;
HXDLIN(  23)										{
HXLINE(  23)											int _g140 = 0;
HXDLIN(  23)											int _g141 = b54->height;
HXDLIN(  23)											while((_g140 < _g141)){
HXLINE(  23)												_g140 = (_g140 + 1);
HXDLIN(  23)												int y23 = (_g140 - 1);
HXDLIN(  23)												{
HXLINE(  23)													int _g142 = 0;
HXDLIN(  23)													int _g143 = b54->width;
HXDLIN(  23)													while((_g142 < _g143)){
HXLINE(  23)														_g142 = (_g142 + 1);
HXDLIN(  23)														int x23 = (_g142 - 1);
HXDLIN(  23)														{
HXLINE(  23)															w7 = (w7 + 1);
HXDLIN(  23)															b54->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXLINE(  23)															w7 = (w7 + 1);
HXDLIN(  23)															b54->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXLINE(  23)															w7 = (w7 + 1);
HXDLIN(  23)															b54->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXLINE(  23)															w7 = (w7 + 1);
HXDLIN(  23)															b54->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								undoImage22 = b54;
            							}
            							break;
            							case (int)1: {
HXLINE(  23)								 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::ArrIntImg a51 = arrI7;
HXDLIN(  23)								{
HXLINE(  23)									a51->width = width7;
HXDLIN(  23)									a51->height = height7;
HXDLIN(  23)									a51->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)									a51->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)									{
HXLINE(  23)										int _g144 = 0;
HXDLIN(  23)										int _g145 = a51->length;
HXDLIN(  23)										while((_g144 < _g145)){
HXLINE(  23)											_g144 = (_g144 + 1);
HXDLIN(  23)											int i62 = (_g144 - 1);
HXDLIN(  23)											a51->data[i62] = 0;
            										}
            									}
            								}
HXDLIN(  23)								undoImage22 = a51;
            							}
            							break;
            							case (int)2: {
HXLINE(  23)								 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::U32ArrImg b55 = u32a7;
HXDLIN(  23)								{
HXLINE(  23)									b55->width = width7;
HXDLIN(  23)									b55->height = height7;
HXDLIN(  23)									b55->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)									int size7 = (b55->length * 4);
HXDLIN(  23)									b55->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN(  23)									{
HXLINE(  23)										int _g146 = 0;
HXDLIN(  23)										int _g147 = b55->length;
HXDLIN(  23)										while((_g146 < _g147)){
HXLINE(  23)											_g146 = (_g146 + 1);
HXDLIN(  23)											int i63 = (_g146 - 1);
HXDLIN(  23)											{
HXLINE(  23)												 ::haxe::io::ArrayBufferViewImpl this226 = b55->data;
HXDLIN(  23)												bool undoImage23;
HXDLIN(  23)												if ((i63 >= 0)) {
HXLINE(  23)													undoImage23 = (i63 < (this226->byteLength >> 2));
            												}
            												else {
HXLINE(  23)													undoImage23 = false;
            												}
HXDLIN(  23)												if (undoImage23) {
HXLINE(  23)													 ::haxe::io::Bytes _this7 = this226->bytes;
HXDLIN(  23)													int pos7 = ((i63 << 2) + this226->byteOffset);
HXDLIN(  23)													_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN(  23)													_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)													_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)													_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								undoImage22 = b55;
            							}
            							break;
            							case (int)3: {
HXLINE(  23)								 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::VecIntImg v21 = vec7;
HXDLIN(  23)								{
HXLINE(  23)									v21->width = width7;
HXDLIN(  23)									v21->height = height7;
HXDLIN(  23)									v21->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)									v21->data = ::Array_obj< int >::__new(v21->length);
HXDLIN(  23)									{
HXLINE(  23)										int _g148 = 0;
HXDLIN(  23)										int _g149 = v21->length;
HXDLIN(  23)										while((_g148 < _g149)){
HXLINE(  23)											_g148 = (_g148 + 1);
HXDLIN(  23)											int i64 = (_g148 - 1);
HXDLIN(  23)											v21->data->__unsafe_set(i64,0);
            										}
            									}
            								}
HXDLIN(  23)								undoImage22 = v21;
            							}
            							break;
            							case (int)4: {
HXLINE(  23)								 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::StackIntImg b56 = sInt7;
HXDLIN(  23)								{
HXLINE(  23)									b56->width = width7;
HXDLIN(  23)									b56->height = height7;
HXDLIN(  23)									b56->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)									b56->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)									{
HXLINE(  23)										int len15 = b56->length;
HXDLIN(  23)										 ::haxe::ds::GenericStack_Int d7 = b56->data;
HXDLIN(  23)										if (::hx::IsNull( d7->head )) {
HXLINE(  23)											int _g150 = 0;
HXDLIN(  23)											int _g151 = len15;
HXDLIN(  23)											while((_g150 < _g151)){
HXLINE(  23)												_g150 = (_g150 + 1);
HXDLIN(  23)												int i65 = (_g150 - 1);
HXDLIN(  23)												d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            											}
            										}
            										else {
HXLINE(  23)											int _g152 = 0;
HXDLIN(  23)											int _g153 = len15;
HXDLIN(  23)											while((_g152 < _g153)){
HXLINE(  23)												_g152 = (_g152 + 1);
HXDLIN(  23)												int i66 = (_g152 - 1);
HXDLIN(  23)												{
HXLINE(  23)													 ::haxe::ds::GenericCell_Int l7 = b56->data->head;
HXDLIN(  23)													 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN(  23)													{
HXLINE(  23)														int _g154 = 0;
HXDLIN(  23)														int _g155 = i66;
HXDLIN(  23)														while((_g154 < _g155)){
HXLINE(  23)															_g154 = (_g154 + 1);
HXDLIN(  23)															int i67 = (_g154 - 1);
HXLINE( 345)															prev7 = l7;
HXLINE( 346)															l7 = l7->next;
            														}
            													}
HXLINE(  23)													if (::hx::IsNull( prev7 )) {
HXLINE(  23)														b56->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  23)														l7 = null();
            													}
            													else {
HXLINE(  23)														prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  23)														l7 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								undoImage22 = b56;
            							}
            							break;
            						}
HXDLIN(  23)						this225->image = undoImage22;
HXDLIN(  23)						this225->width = width7;
HXDLIN(  23)						this225->height = height7;
HXDLIN(  23)						this225->imageType = ( (int)(imageType7) );
HXDLIN(  23)						undoImage21 = this225;
HXDLIN(  23)						{
HXLINE(  23)							int rectLeft7 = xIter37->start;
HXDLIN(  23)							int rectTop7 = yIter37->start;
HXDLIN(  23)							int rectRight7 = xIter37->max;
HXDLIN(  23)							bool forceClear7 = false;
HXDLIN(  23)							{
HXLINE(  23)								int _g156 = rectTop7;
HXDLIN(  23)								int _g157 = yIter37->max;
HXDLIN(  23)								while((_g156 < _g157)){
HXLINE(  23)									_g156 = (_g156 + 1);
HXDLIN(  23)									int dy10 = (_g156 - 1);
HXDLIN(  23)									{
HXLINE(  23)										int _g158 = rectLeft7;
HXDLIN(  23)										int _g159 = rectRight7;
HXDLIN(  23)										while((_g158 < _g159)){
HXLINE(  23)											_g158 = (_g158 + 1);
HXDLIN(  23)											int dx10 = (_g158 - 1);
HXDLIN(  23)											::Dynamic this227 = this193->image;
HXDLIN(  23)											int index30;
HXDLIN(  23)											if (this193->useVirtualPos) {
HXLINE(  23)												index30 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - this193->virtualY) * ( (Float)(this193->width) )) + dx10) - this193->virtualX));
            											}
            											else {
HXLINE(  23)												index30 = ::Std_obj::_hx_int(( (Float)(((dy10 * this193->width) + dx10)) ));
            											}
HXDLIN(  23)											int c27 = ::iterMagic::Iimg_obj::get(this227,index30);
HXDLIN(  23)											int col7;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)												col7 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            											}
            											else {
HXLINE(  23)												col7 = c27;
            											}
HXDLIN(  23)											bool _hx_tmp57;
HXDLIN(  23)											if (this193->useMask) {
HXLINE(  23)												_hx_tmp57 = ::hx::IsNotNull( this193->mask );
            											}
            											else {
HXLINE(  23)												_hx_tmp57 = false;
            											}
HXDLIN(  23)											if (_hx_tmp57) {
HXLINE(  23)												 ::pi_xy::ImageStruct this228 = this193->mask;
HXDLIN(  23)												::Dynamic this229 = this228->image;
HXDLIN(  23)												int index31;
HXDLIN(  23)												if (this228->useVirtualPos) {
HXLINE(  23)													index31 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - this228->virtualY) * ( (Float)(this228->width) )) + dx10) - this228->virtualX));
            												}
            												else {
HXLINE(  23)													index31 = ::Std_obj::_hx_int(( (Float)(((dy10 * this228->width) + dx10)) ));
            												}
HXDLIN(  23)												int c28 = ::iterMagic::Iimg_obj::get(this229,index31);
HXDLIN(  23)												int v22;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)													v22 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            												}
            												else {
HXLINE(  23)													v22 = c28;
            												}
HXDLIN(  23)												int maskPixel7 = v22;
HXDLIN(  23)												int this230 = col7;
HXDLIN(  23)												if ((maskPixel7 == 0)) {
HXLINE(  23)													col7 = this230;
            												}
            												else {
HXLINE(  23)													Float m07;
HXDLIN(  23)													int this231 = ((maskPixel7 >> 24) & 255);
HXDLIN(  23)													if ((this231 == 0)) {
HXLINE(  23)														m07 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														m07 = (( (Float)(this231) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float m17;
HXDLIN(  23)													int this232 = ((maskPixel7 >> 16) & 255);
HXDLIN(  23)													if ((this232 == 0)) {
HXLINE(  23)														m17 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														m17 = (( (Float)(this232) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float m27;
HXDLIN(  23)													int this233 = ((maskPixel7 >> 8) & 255);
HXDLIN(  23)													if ((this233 == 0)) {
HXLINE(  23)														m27 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														m27 = (( (Float)(this233) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float m37;
HXDLIN(  23)													int this234 = (maskPixel7 & 255);
HXDLIN(  23)													if ((this234 == 0)) {
HXLINE(  23)														m37 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														m37 = (( (Float)(this234) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this230 >> 24) & 255)) )));
HXDLIN(  23)													int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this230 >> 16) & 255)) )));
HXDLIN(  23)													int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this230 >> 8) & 255)) )));
HXDLIN(  23)													int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this230 & 255)) )));
HXDLIN(  23)													col7 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  23)											if ((col7 != 0)) {
HXLINE(  23)												int x24 = (dx10 - rectLeft7);
HXDLIN(  23)												int y24 = (dy10 - rectTop7);
HXDLIN(  23)												int c29 = col7;
HXDLIN(  23)												bool _hx_tmp58;
HXDLIN(  23)												if ((((c29 >> 24) & 255) < 254)) {
HXLINE(  23)													_hx_tmp58 = undoImage21->transparent;
            												}
            												else {
HXLINE(  23)													_hx_tmp58 = false;
            												}
HXDLIN(  23)												if (_hx_tmp58) {
HXLINE(  23)													int location14;
HXDLIN(  23)													if (undoImage21->useVirtualPos) {
HXLINE(  23)														location14 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x24) - undoImage21->virtualX));
            													}
            													else {
HXLINE(  23)														location14 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage21->width) + x24)) ));
            													}
HXDLIN(  23)													int this235 = ::iterMagic::Iimg_obj::get(undoImage21->image,location14);
HXDLIN(  23)													int this236;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)														this236 = ((((((this235 >> 24) & 255) << 24) | ((this235 & 255) << 16)) | (((this235 >> 8) & 255) << 8)) | ((this235 >> 16) & 255));
            													}
            													else {
HXLINE(  23)														this236 = this235;
            													}
HXDLIN(  23)													Float a119;
HXDLIN(  23)													int this237 = ((this236 >> 24) & 255);
HXDLIN(  23)													if ((this237 == 0)) {
HXLINE(  23)														a119 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														a119 = (( (Float)(this237) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float r115;
HXDLIN(  23)													int this238 = ((this236 >> 16) & 255);
HXDLIN(  23)													if ((this238 == 0)) {
HXLINE(  23)														r115 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														r115 = (( (Float)(this238) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float g115;
HXDLIN(  23)													int this239 = ((this236 >> 8) & 255);
HXDLIN(  23)													if ((this239 == 0)) {
HXLINE(  23)														g115 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														g115 = (( (Float)(this239) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float b120;
HXDLIN(  23)													int this240 = (this236 & 255);
HXDLIN(  23)													if ((this240 == 0)) {
HXLINE(  23)														b120 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														b120 = (( (Float)(this240) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float a217;
HXDLIN(  23)													int this241 = ((col7 >> 24) & 255);
HXDLIN(  23)													if ((this241 == 0)) {
HXLINE(  23)														a217 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														a217 = (( (Float)(this241) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float r215;
HXDLIN(  23)													int this242 = ((col7 >> 16) & 255);
HXDLIN(  23)													if ((this242 == 0)) {
HXLINE(  23)														r215 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														r215 = (( (Float)(this242) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float g215;
HXDLIN(  23)													int this243 = ((col7 >> 8) & 255);
HXDLIN(  23)													if ((this243 == 0)) {
HXLINE(  23)														g215 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														g215 = (( (Float)(this243) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float b218;
HXDLIN(  23)													int this244 = (col7 & 255);
HXDLIN(  23)													if ((this244 == 0)) {
HXLINE(  23)														b218 = ((Float)0.);
            													}
            													else {
HXLINE(  23)														b218 = (( (Float)(this244) ) / ( (Float)(255) ));
            													}
HXDLIN(  23)													Float a315 = (a119 * (( (Float)(1) ) - a217));
HXDLIN(  23)													int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a217))));
HXDLIN(  23)													int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a217))));
HXDLIN(  23)													int b57 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a315) + (b218 * a217))));
HXDLIN(  23)													int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a217)));
HXDLIN(  23)													int blended14 = ((((a52 << 24) | (r37 << 16)) | (g37 << 8)) | b57);
HXDLIN(  23)													{
HXLINE(  23)														int _hx_tmp59;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)															_hx_tmp59 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            														}
            														else {
HXLINE(  23)															_hx_tmp59 = blended14;
            														}
HXDLIN(  23)														::iterMagic::Iimg_obj::set(undoImage21->image,location14,_hx_tmp59);
            													}
            												}
            												else {
HXLINE(  23)													::Dynamic this245 = undoImage21->image;
HXDLIN(  23)													int index32;
HXDLIN(  23)													if (undoImage21->useVirtualPos) {
HXLINE(  23)														index32 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x24) - undoImage21->virtualX));
            													}
            													else {
HXLINE(  23)														index32 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage21->width) + x24)) ));
            													}
HXDLIN(  23)													int _hx_tmp60;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)														_hx_tmp60 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            													}
            													else {
HXLINE(  23)														_hx_tmp60 = c29;
            													}
HXDLIN(  23)													::iterMagic::Iimg_obj::set(this245,index32,_hx_tmp60);
            												}
            											}
            											else {
HXLINE(  23)												if (forceClear7) {
HXLINE(  23)													::Dynamic this246 = undoImage21->image;
HXDLIN(  23)													int x25 = (dx10 - rectLeft7);
HXDLIN(  23)													int y25 = (dy10 - rectTop7);
HXDLIN(  23)													int index33;
HXDLIN(  23)													if (undoImage21->useVirtualPos) {
HXLINE(  23)														index33 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x25) - undoImage21->virtualX));
            													}
            													else {
HXLINE(  23)														index33 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage21->width) + x25)) ));
            													}
HXDLIN(  23)													::iterMagic::Iimg_obj::set(this246,index33,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  23)					bool found7 = false;
HXDLIN(  23)					Float min45 = ( (Float)(0) );
HXDLIN(  23)					Float max5 = ( (Float)(0) );
HXDLIN(  23)					int a53 = 0;
HXDLIN(  23)					int r38 = 0;
HXDLIN(  23)					int g38 = 0;
HXDLIN(  23)					int b58 = 0;
HXDLIN(  23)					{
HXLINE(  23)						int _g_min14 = xIter37->start;
HXDLIN(  23)						int _g_max14 = xIter37->max;
HXDLIN(  23)						while((_g_min14 < _g_max14)){
HXLINE(  23)							_g_min14 = (_g_min14 + 1);
HXDLIN(  23)							int px5 = (_g_min14 - 1);
HXDLIN(  23)							Float pcx5 = (( (Float)(px5) ) - dx8);
HXLINE( 695)							found7 = false;
HXLINE(  23)							{
HXLINE(  23)								int _g_min15 = yIter37->start;
HXDLIN(  23)								int _g_max15 = yIter37->max;
HXDLIN(  23)								while((_g_min15 < _g_max15)){
HXLINE(  23)									_g_min15 = (_g_min15 + 1);
HXDLIN(  23)									int py5 = (_g_min15 - 1);
HXDLIN(  23)									Float pcy5 = (( (Float)(py5) ) - dy8);
HXDLIN(  23)									Float dot315 = ((pcx5 * bcx5) + (pcy5 * bcy5));
HXDLIN(  23)									Float dot325 = ((pcx5 * acx5) + (pcy5 * acy5));
HXDLIN(  23)									Float ratioA5 = (((dot225 * dot315) - (dot125 * dot325)) * denom15);
HXDLIN(  23)									Float ratioB5 = (((dot115 * dot325) - (dot125 * dot315)) * denom15);
HXDLIN(  23)									Float ratioC5 = ((((Float)1.0) - ratioB5) - ratioA5);
HXDLIN(  23)									bool _hx_tmp61;
HXDLIN(  23)									bool _hx_tmp62;
HXDLIN(  23)									if ((ratioA5 >= 0)) {
HXLINE(  23)										_hx_tmp62 = (ratioB5 >= 0);
            									}
            									else {
HXLINE(  23)										_hx_tmp62 = false;
            									}
HXDLIN(  23)									if (_hx_tmp62) {
HXLINE(  23)										_hx_tmp61 = (ratioC5 >= 0);
            									}
            									else {
HXLINE(  23)										_hx_tmp61 = false;
            									}
HXDLIN(  23)									if (_hx_tmp61) {
HXLINE(  23)										if ((ratioB5 < ratioC5)) {
HXLINE(  23)											min45 = ratioB5;
            										}
            										else {
HXLINE(  23)											min45 = ratioC5;
            										}
HXDLIN(  23)										if ((ratioA5 > ratioB5)) {
HXLINE(  23)											max5 = ratioA5;
            										}
            										else {
HXLINE(  23)											max5 = ratioB5;
            										}
HXDLIN(  23)										if (!((max5 > ratioC5))) {
HXLINE(  23)											max5 = ratioC5;
            										}
HXLINE( 735)										max5 = ((( (Float)(1) ) - max5) / ( (Float)(2) ));
HXLINE(  23)										if (!((min45 < max5))) {
HXLINE(  23)											min45 = ((max5 + min45) / ( (Float)(2) ));
            										}
HXDLIN(  23)										int i68 = ::Std_obj::_hx_int(((( (Float)(aA5) ) * soft1) * min45));
HXDLIN(  23)										if ((i68 > 255)) {
HXLINE(  24)											i68 = 255;
            										}
HXLINE(  23)										if ((i68 < 0)) {
HXLINE(  25)											i68 = 0;
            										}
HXLINE(  23)										a53 = i68;
HXDLIN(  23)										int i69 = ::Std_obj::_hx_int(( (Float)(rA5) ));
HXDLIN(  23)										if ((i69 > 255)) {
HXLINE(  24)											i69 = 255;
            										}
HXLINE(  23)										if ((i69 < 0)) {
HXLINE(  25)											i69 = 0;
            										}
HXLINE( 747)										r38 = i69;
HXLINE(  23)										int i70 = ::Std_obj::_hx_int(( (Float)(gA5) ));
HXDLIN(  23)										if ((i70 > 255)) {
HXLINE(  24)											i70 = 255;
            										}
HXLINE(  23)										if ((i70 < 0)) {
HXLINE(  25)											i70 = 0;
            										}
HXLINE( 748)										g38 = i70;
HXLINE(  23)										int i71 = ::Std_obj::_hx_int(( (Float)(bA5) ));
HXDLIN(  23)										if ((i71 > 255)) {
HXLINE(  24)											i71 = 255;
            										}
HXLINE(  23)										if ((i71 < 0)) {
HXLINE(  25)											i71 = 0;
            										}
HXLINE( 749)										b58 = i71;
HXLINE(  23)										{
HXLINE(  23)											int location15;
HXDLIN(  23)											if (this193->useVirtualPos) {
HXLINE(  23)												location15 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - this193->virtualY) * ( (Float)(this193->width) )) + px5) - this193->virtualX));
            											}
            											else {
HXLINE(  23)												location15 = ::Std_obj::_hx_int(( (Float)(((py5 * this193->width) + px5)) ));
            											}
HXDLIN(  23)											bool _hx_tmp63;
HXDLIN(  23)											if (this193->transparent) {
HXLINE(  23)												_hx_tmp63 = (a53 < 254);
            											}
            											else {
HXLINE(  23)												_hx_tmp63 = false;
            											}
HXDLIN(  23)											if (_hx_tmp63) {
HXLINE(  23)												int this247 = ::iterMagic::Iimg_obj::get(this193->image,location15);
HXDLIN(  23)												int old5;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)													old5 = ((((((this247 >> 24) & 255) << 24) | ((this247 & 255) << 16)) | (((this247 >> 8) & 255) << 8)) | ((this247 >> 16) & 255));
            												}
            												else {
HXLINE(  23)													old5 = this247;
            												}
HXDLIN(  23)												int rhs5 = ((((a53 << 24) | (r38 << 16)) | (g38 << 8)) | b58);
HXDLIN(  23)												Float a120;
HXDLIN(  23)												int this248 = ((old5 >> 24) & 255);
HXDLIN(  23)												if ((this248 == 0)) {
HXLINE(  23)													a120 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													a120 = (( (Float)(this248) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float r116;
HXDLIN(  23)												int this249 = ((old5 >> 16) & 255);
HXDLIN(  23)												if ((this249 == 0)) {
HXLINE(  23)													r116 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													r116 = (( (Float)(this249) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float g116;
HXDLIN(  23)												int this250 = ((old5 >> 8) & 255);
HXDLIN(  23)												if ((this250 == 0)) {
HXLINE(  23)													g116 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													g116 = (( (Float)(this250) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float b121;
HXDLIN(  23)												int this251 = (old5 & 255);
HXDLIN(  23)												if ((this251 == 0)) {
HXLINE(  23)													b121 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													b121 = (( (Float)(this251) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float a218;
HXDLIN(  23)												int this252 = ((rhs5 >> 24) & 255);
HXDLIN(  23)												if ((this252 == 0)) {
HXLINE(  23)													a218 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													a218 = (( (Float)(this252) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float r216;
HXDLIN(  23)												int this253 = ((rhs5 >> 16) & 255);
HXDLIN(  23)												if ((this253 == 0)) {
HXLINE(  23)													r216 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													r216 = (( (Float)(this253) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float g216;
HXDLIN(  23)												int this254 = ((rhs5 >> 8) & 255);
HXDLIN(  23)												if ((this254 == 0)) {
HXLINE(  23)													g216 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													g216 = (( (Float)(this254) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float b219;
HXDLIN(  23)												int this255 = (rhs5 & 255);
HXDLIN(  23)												if ((this255 == 0)) {
HXLINE(  23)													b219 = ((Float)0.);
            												}
            												else {
HXLINE(  23)													b219 = (( (Float)(this255) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float a316 = (a120 * (( (Float)(1) ) - a218));
HXDLIN(  23)												int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a218))));
HXDLIN(  23)												int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a218))));
HXDLIN(  23)												int b59 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a316) + (b219 * a218))));
HXDLIN(  23)												int a54 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a218)));
HXDLIN(  23)												int blended15 = ((((a54 << 24) | (r39 << 16)) | (g39 << 8)) | b59);
HXDLIN(  23)												{
HXLINE(  23)													int _hx_tmp64;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  23)														_hx_tmp64 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            													}
            													else {
HXLINE(  23)														_hx_tmp64 = blended15;
            													}
HXDLIN(  23)													::iterMagic::Iimg_obj::set(this193->image,location15,_hx_tmp64);
            												}
            											}
            											else {
HXLINE(  23)												int value5;
HXDLIN(  23)												if (this193->isLittle) {
HXLINE(  23)													value5 = ((((a53 << 24) | (b58 << 16)) | (g38 << 8)) | r38);
            												}
            												else {
HXLINE(  23)													value5 = ((((a53 << 24) | (r38 << 16)) | (g38 << 8)) | b58);
            												}
HXDLIN(  23)												::iterMagic::Iimg_obj::set(this193->image,location15,value5);
            											}
            										}
HXLINE( 751)										found7 = true;
            									}
            									else {
HXLINE(  23)										if (found7) {
HXLINE(  23)											goto _hx_goto_97;
            										}
            									}
            								}
            								_hx_goto_97:;
            							}
            						}
            					}
HXDLIN(  23)					if ((hasHit1 == false)) {
HXLINE(  23)						 ::pi_xy::algo::HitTri v23 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx6,by6,cx6,cy6,dx8,dy8,true);
HXDLIN(  23)						if (hasUndo7) {
HXLINE(  23)							v23->undoImage = undoImage21;
HXDLIN(  23)							v23->undoX = xIter37->start;
HXDLIN(  23)							v23->undoY = yIter37->start;
            						}
            					}
            				}
HXDLIN(  23)				if ((hasHit1 == true)) {
HXLINE(  23)					 ::pi_xy::algo::HitQuad v24 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax4,ay4,bx6,by6,cx6,cy6,dx8,dy8,true);
HXLINE(  17)					_hx_tmp = v24;
            				}
            				else {
HXLINE(  17)					_hx_tmp = null();
            				}
            			}
            		}
HXDLIN(  17)		this->hitObj = _hx_tmp;
HXLINE(  26)		return pixelImage;
            	}


 ::Dynamic QuadShape_obj::clear( ::Dynamic _tmp_pixelImage,int color){
            	HX_GC_STACKFRAME(&_hx_pos_27ea2ca91e1c5395_28_clear)
HXLINE(  29)		 ::pi_xy::ImageStruct pixelImage = ( ( ::pi_xy::ImageStruct)(_tmp_pixelImage) );
HXDLIN(  29)		{
HXLINE(  29)			 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN(  29)			Float ax = (this->aX + this->offX);
HXDLIN(  29)			Float ay = (this->aY + this->offY);
HXDLIN(  29)			Float bx = (this->bX + this->offX);
HXDLIN(  29)			Float by = (this->bY + this->offY);
HXDLIN(  29)			Float cx = (this->cX + this->offX);
HXDLIN(  29)			Float cy = (this->cY + this->offY);
HXDLIN(  29)			Float dx = (this->dX + this->offX);
HXDLIN(  29)			Float dy = (this->dY + this->offY);
HXDLIN(  29)			{
HXLINE(  29)				{
HXLINE(  29)					Float bx1 = bx;
HXDLIN(  29)					Float by1 = by;
HXDLIN(  29)					Float cx1 = dx;
HXDLIN(  29)					Float cy1 = dy;
HXDLIN(  29)					bool hasUndo = false;
HXDLIN(  29)					bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  29)					if (!(adjustWinding)) {
HXLINE(  29)						Float bx_ = bx1;
HXDLIN(  29)						Float by_ = by1;
HXLINE(  25)						bx1 = cx1;
HXLINE(  26)						by1 = cy1;
HXLINE(  27)						cx1 = bx_;
HXLINE(  28)						cy1 = by_;
            					}
HXLINE(  29)					{
HXLINE(  29)						Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  29)						Float sx = (cy1 - ay);
HXDLIN(  29)						Float sy = (ax - cx1);
HXDLIN(  29)						Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  29)						Float tx = (ay - by1);
HXDLIN(  29)						Float ty = (bx1 - ax);
HXDLIN(  29)						Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  29)						 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  29)						if ((ax > bx1)) {
HXLINE(  29)							if ((ax > cx1)) {
HXLINE(  29)								int min;
HXDLIN(  29)								if ((bx1 > cx1)) {
HXLINE(  29)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  29)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN(  29)								int ii_min = min;
HXDLIN(  29)								int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  29)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            							}
            							else {
HXLINE(  29)								int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  29)								int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  29)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            							}
            						}
            						else {
HXLINE(  29)							if ((bx1 > cx1)) {
HXLINE(  29)								int min1;
HXDLIN(  29)								if ((ax > cx1)) {
HXLINE(  29)									min1 = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  29)									min1 = ::Math_obj::ceil(ax);
            								}
HXDLIN(  29)								int ii_min2 = min1;
HXDLIN(  29)								int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  29)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            							}
            							else {
HXLINE(  29)								int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  29)								int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  29)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            							}
            						}
HXDLIN(  29)						 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  29)						if ((ay > by1)) {
HXLINE(  29)							if ((ay > cy1)) {
HXLINE(  29)								int min2;
HXDLIN(  29)								if ((by1 > cy1)) {
HXLINE(  29)									min2 = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  29)									min2 = ::Math_obj::floor(by1);
            								}
HXDLIN(  29)								int ii_min4 = min2;
HXDLIN(  29)								int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  29)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            							}
            							else {
HXLINE(  29)								int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  29)								int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  29)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            							}
            						}
            						else {
HXLINE(  29)							if ((by1 > cy1)) {
HXLINE(  29)								int min3;
HXDLIN(  29)								if ((ay > cy1)) {
HXLINE(  29)									min3 = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  29)									min3 = ::Math_obj::ceil(ay);
            								}
HXDLIN(  29)								int ii_min6 = min3;
HXDLIN(  29)								int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  29)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            							}
            							else {
HXLINE(  29)								int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  29)								int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  29)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            							}
            						}
HXDLIN(  29)						 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  29)						if (hasUndo) {
HXLINE(  29)							int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  29)							int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  29)							 ::Dynamic imageType = null();
HXDLIN(  29)							 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  29)							if (::hx::IsNull( imageType )) {
HXLINE(  54)								imageType = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  29)							::Dynamic undoImage1;
HXDLIN(  29)							switch((int)(( (int)(imageType) ))){
            								case (int)0: {
HXLINE(  29)									 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::BytesImg b = byt;
HXDLIN(  29)									{
HXLINE(  29)										b->width = width;
HXDLIN(  29)										b->height = height;
HXDLIN(  29)										b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)										b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  29)										{
HXLINE(  29)											int len = b->length;
HXDLIN(  29)											int w = 0;
HXDLIN(  29)											{
HXLINE(  29)												int _g = 0;
HXDLIN(  29)												int _g1 = b->height;
HXDLIN(  29)												while((_g < _g1)){
HXLINE(  29)													_g = (_g + 1);
HXDLIN(  29)													int y = (_g - 1);
HXDLIN(  29)													{
HXLINE(  29)														int _g2 = 0;
HXDLIN(  29)														int _g3 = b->width;
HXDLIN(  29)														while((_g2 < _g3)){
HXLINE(  29)															_g2 = (_g2 + 1);
HXDLIN(  29)															int x = (_g2 - 1);
HXDLIN(  29)															{
HXLINE(  29)																w = (w + 1);
HXDLIN(  29)																b->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  29)															{
HXLINE(  29)																w = (w + 1);
HXDLIN(  29)																b->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  29)															{
HXLINE(  29)																w = (w + 1);
HXDLIN(  29)																b->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  29)															{
HXLINE(  29)																w = (w + 1);
HXDLIN(  29)																b->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  29)									undoImage1 = b;
            								}
            								break;
            								case (int)1: {
HXLINE(  29)									 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  29)									{
HXLINE(  29)										a->width = width;
HXDLIN(  29)										a->height = height;
HXDLIN(  29)										a->data = ::Array_obj< int >::__new(0);
HXDLIN(  29)										a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)										{
HXLINE(  29)											int _g4 = 0;
HXDLIN(  29)											int _g5 = a->length;
HXDLIN(  29)											while((_g4 < _g5)){
HXLINE(  29)												_g4 = (_g4 + 1);
HXDLIN(  29)												int i = (_g4 - 1);
HXDLIN(  29)												a->data[i] = 0;
            											}
            										}
            									}
HXDLIN(  29)									undoImage1 = a;
            								}
            								break;
            								case (int)2: {
HXLINE(  29)									 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  29)									{
HXLINE(  29)										b1->width = width;
HXDLIN(  29)										b1->height = height;
HXDLIN(  29)										b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)										int size = (b1->length * 4);
HXDLIN(  29)										b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  29)										{
HXLINE(  29)											int _g6 = 0;
HXDLIN(  29)											int _g7 = b1->length;
HXDLIN(  29)											while((_g6 < _g7)){
HXLINE(  29)												_g6 = (_g6 + 1);
HXDLIN(  29)												int i1 = (_g6 - 1);
HXDLIN(  29)												{
HXLINE(  29)													 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  29)													bool undoImage2;
HXDLIN(  29)													if ((i1 >= 0)) {
HXLINE(  29)														undoImage2 = (i1 < (this3->byteLength >> 2));
            													}
            													else {
HXLINE(  29)														undoImage2 = false;
            													}
HXDLIN(  29)													if (undoImage2) {
HXLINE(  29)														 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  29)														int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  29)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  29)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  29)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  29)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  29)									undoImage1 = b1;
            								}
            								break;
            								case (int)3: {
HXLINE(  29)									 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::VecIntImg v = vec;
HXDLIN(  29)									{
HXLINE(  29)										v->width = width;
HXDLIN(  29)										v->height = height;
HXDLIN(  29)										v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)										v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  29)										{
HXLINE(  29)											int _g8 = 0;
HXDLIN(  29)											int _g9 = v->length;
HXDLIN(  29)											while((_g8 < _g9)){
HXLINE(  29)												_g8 = (_g8 + 1);
HXDLIN(  29)												int i2 = (_g8 - 1);
HXDLIN(  29)												v->data->__unsafe_set(i2,0);
            											}
            										}
            									}
HXDLIN(  29)									undoImage1 = v;
            								}
            								break;
            								case (int)4: {
HXLINE(  29)									 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  29)									{
HXLINE(  29)										b2->width = width;
HXDLIN(  29)										b2->height = height;
HXDLIN(  29)										b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  29)										b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  29)										{
HXLINE(  29)											int len1 = b2->length;
HXDLIN(  29)											 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  29)											if (::hx::IsNull( d->head )) {
HXLINE(  29)												int _g10 = 0;
HXDLIN(  29)												int _g11 = len1;
HXDLIN(  29)												while((_g10 < _g11)){
HXLINE(  29)													_g10 = (_g10 + 1);
HXDLIN(  29)													int i3 = (_g10 - 1);
HXDLIN(  29)													d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            												}
            											}
            											else {
HXLINE(  29)												int _g12 = 0;
HXDLIN(  29)												int _g13 = len1;
HXDLIN(  29)												while((_g12 < _g13)){
HXLINE(  29)													_g12 = (_g12 + 1);
HXDLIN(  29)													int i4 = (_g12 - 1);
HXDLIN(  29)													{
HXLINE(  29)														 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  29)														 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  29)														{
HXLINE(  29)															int _g14 = 0;
HXDLIN(  29)															int _g15 = i4;
HXDLIN(  29)															while((_g14 < _g15)){
HXLINE(  29)																_g14 = (_g14 + 1);
HXDLIN(  29)																int i5 = (_g14 - 1);
HXLINE( 345)																prev = l;
HXLINE( 346)																l = l->next;
            															}
            														}
HXLINE(  29)														if (::hx::IsNull( prev )) {
HXLINE(  29)															b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  29)															l = null();
            														}
            														else {
HXLINE(  29)															prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  29)															l = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  29)									undoImage1 = b2;
            								}
            								break;
            							}
HXDLIN(  29)							this2->image = undoImage1;
HXDLIN(  29)							this2->width = width;
HXDLIN(  29)							this2->height = height;
HXDLIN(  29)							this2->imageType = ( (int)(imageType) );
HXDLIN(  29)							undoImage = this2;
HXDLIN(  29)							{
HXLINE(  29)								int rectLeft = xIter3->start;
HXDLIN(  29)								int rectTop = yIter3->start;
HXDLIN(  29)								int rectRight = xIter3->max;
HXDLIN(  29)								bool forceClear = false;
HXDLIN(  29)								{
HXLINE(  29)									int _g16 = rectTop;
HXDLIN(  29)									int _g17 = yIter3->max;
HXDLIN(  29)									while((_g16 < _g17)){
HXLINE(  29)										_g16 = (_g16 + 1);
HXDLIN(  29)										int dy1 = (_g16 - 1);
HXDLIN(  29)										{
HXLINE(  29)											int _g18 = rectLeft;
HXDLIN(  29)											int _g19 = rectRight;
HXDLIN(  29)											while((_g18 < _g19)){
HXLINE(  29)												_g18 = (_g18 + 1);
HXDLIN(  29)												int dx1 = (_g18 - 1);
HXDLIN(  29)												::Dynamic this4 = this1->image;
HXDLIN(  29)												int index;
HXDLIN(  29)												if (this1->useVirtualPos) {
HXLINE(  29)													index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            												}
            												else {
HXLINE(  29)													index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            												}
HXDLIN(  29)												int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  29)												int col;
HXDLIN(  29)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  29)													col = c;
            												}
HXDLIN(  29)												bool _hx_tmp;
HXDLIN(  29)												if (this1->useMask) {
HXLINE(  29)													_hx_tmp = ::hx::IsNotNull( this1->mask );
            												}
            												else {
HXLINE(  29)													_hx_tmp = false;
            												}
HXDLIN(  29)												if (_hx_tmp) {
HXLINE(  29)													 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  29)													::Dynamic this6 = this5->image;
HXDLIN(  29)													int index1;
HXDLIN(  29)													if (this5->useVirtualPos) {
HXLINE(  29)														index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            													}
            													else {
HXLINE(  29)														index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            													}
HXDLIN(  29)													int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  29)													int v1;
HXDLIN(  29)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)														v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            													}
            													else {
HXLINE(  29)														v1 = c1;
            													}
HXDLIN(  29)													int maskPixel = v1;
HXDLIN(  29)													int this7 = col;
HXDLIN(  29)													if ((maskPixel == 0)) {
HXLINE(  29)														col = this7;
            													}
            													else {
HXLINE(  29)														Float m0;
HXDLIN(  29)														int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  29)														if ((this8 == 0)) {
HXLINE(  29)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float m1;
HXDLIN(  29)														int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  29)														if ((this9 == 0)) {
HXLINE(  29)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float m2;
HXDLIN(  29)														int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  29)														if ((this10 == 0)) {
HXLINE(  29)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float m3;
HXDLIN(  29)														int this11 = (maskPixel & 255);
HXDLIN(  29)														if ((this11 == 0)) {
HXLINE(  29)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  29)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  29)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  29)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  29)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  29)												if ((col != 0)) {
HXLINE(  29)													int x1 = (dx1 - rectLeft);
HXDLIN(  29)													int y1 = (dy1 - rectTop);
HXDLIN(  29)													int c2 = col;
HXDLIN(  29)													bool _hx_tmp1;
HXDLIN(  29)													if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  29)														_hx_tmp1 = undoImage->transparent;
            													}
            													else {
HXLINE(  29)														_hx_tmp1 = false;
            													}
HXDLIN(  29)													if (_hx_tmp1) {
HXLINE(  29)														int location;
HXDLIN(  29)														if (undoImage->useVirtualPos) {
HXLINE(  29)															location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            														}
            														else {
HXLINE(  29)															location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            														}
HXDLIN(  29)														int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  29)														int this13;
HXDLIN(  29)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)															this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            														}
            														else {
HXLINE(  29)															this13 = this12;
            														}
HXDLIN(  29)														Float a1;
HXDLIN(  29)														int this14 = ((this13 >> 24) & 255);
HXDLIN(  29)														if ((this14 == 0)) {
HXLINE(  29)															a1 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float r1;
HXDLIN(  29)														int this15 = ((this13 >> 16) & 255);
HXDLIN(  29)														if ((this15 == 0)) {
HXLINE(  29)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float g1;
HXDLIN(  29)														int this16 = ((this13 >> 8) & 255);
HXDLIN(  29)														if ((this16 == 0)) {
HXLINE(  29)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float b11;
HXDLIN(  29)														int this17 = (this13 & 255);
HXDLIN(  29)														if ((this17 == 0)) {
HXLINE(  29)															b11 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float a2;
HXDLIN(  29)														int this18 = ((col >> 24) & 255);
HXDLIN(  29)														if ((this18 == 0)) {
HXLINE(  29)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float r2;
HXDLIN(  29)														int this19 = ((col >> 16) & 255);
HXDLIN(  29)														if ((this19 == 0)) {
HXLINE(  29)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float g2;
HXDLIN(  29)														int this20 = ((col >> 8) & 255);
HXDLIN(  29)														if ((this20 == 0)) {
HXLINE(  29)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float b21;
HXDLIN(  29)														int this21 = (col & 255);
HXDLIN(  29)														if ((this21 == 0)) {
HXLINE(  29)															b21 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  29)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  29)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  29)														int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  29)														int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  29)														int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  29)														{
HXLINE(  29)															int _hx_tmp2;
HXDLIN(  29)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)																_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  29)																_hx_tmp2 = blended;
            															}
HXDLIN(  29)															::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            														}
            													}
            													else {
HXLINE(  29)														::Dynamic this22 = undoImage->image;
HXDLIN(  29)														int index2;
HXDLIN(  29)														if (undoImage->useVirtualPos) {
HXLINE(  29)															index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            														}
            														else {
HXLINE(  29)															index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            														}
HXDLIN(  29)														int _hx_tmp3;
HXDLIN(  29)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)															_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            														}
            														else {
HXLINE(  29)															_hx_tmp3 = c2;
            														}
HXDLIN(  29)														::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            													}
            												}
            												else {
HXLINE(  29)													if (forceClear) {
HXLINE(  29)														::Dynamic this23 = undoImage->image;
HXDLIN(  29)														int x2 = (dx1 - rectLeft);
HXDLIN(  29)														int y2 = (dy1 - rectTop);
HXDLIN(  29)														int index3;
HXDLIN(  29)														if (undoImage->useVirtualPos) {
HXLINE(  29)															index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            														}
            														else {
HXLINE(  29)															index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            														}
HXDLIN(  29)														::iterMagic::Iimg_obj::set(this23,index3,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  29)						bool found = false;
HXDLIN(  29)						Float s = ((Float)0.);
HXDLIN(  29)						Float t = ((Float)0.);
HXDLIN(  29)						Float sxx = ((Float)0.);
HXDLIN(  29)						Float txx = ((Float)0.);
HXDLIN(  29)						{
HXLINE(  29)							int _g_min = xIter3->start;
HXDLIN(  29)							int _g_max = xIter3->max;
HXDLIN(  29)							while((_g_min < _g_max)){
HXLINE(  29)								_g_min = (_g_min + 1);
HXDLIN(  29)								int x3 = (_g_min - 1);
HXLINE(  60)								sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)								txx = (tx * ( (Float)(x3) ));
HXLINE(  62)								found = false;
HXLINE(  29)								{
HXLINE(  29)									int _g_min1 = yIter3->start;
HXDLIN(  29)									int _g_max1 = yIter3->max;
HXDLIN(  29)									while((_g_min1 < _g_max1)){
HXLINE(  29)										_g_min1 = (_g_min1 + 1);
HXDLIN(  29)										int y3 = (_g_min1 - 1);
HXLINE(  64)										s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)										t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  29)										bool _hx_tmp4;
HXDLIN(  29)										if (!((s <= 0))) {
HXLINE(  29)											_hx_tmp4 = (t <= 0);
            										}
            										else {
HXLINE(  29)											_hx_tmp4 = true;
            										}
HXDLIN(  29)										if (_hx_tmp4) {
HXLINE(  29)											if (found) {
HXLINE(  29)												goto _hx_goto_110;
            											}
            										}
            										else {
HXLINE(  29)											if (((s + t) < A)) {
HXLINE(  29)												{
HXLINE(  29)													int c3 = color;
HXDLIN(  29)													bool _hx_tmp5;
HXDLIN(  29)													if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  29)														_hx_tmp5 = this1->transparent;
            													}
            													else {
HXLINE(  29)														_hx_tmp5 = false;
            													}
HXDLIN(  29)													if (_hx_tmp5) {
HXLINE(  29)														int location1;
HXDLIN(  29)														if (this1->useVirtualPos) {
HXLINE(  29)															location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            														}
            														else {
HXLINE(  29)															location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            														}
HXDLIN(  29)														int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  29)														int this25;
HXDLIN(  29)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)															this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            														}
            														else {
HXLINE(  29)															this25 = this24;
            														}
HXDLIN(  29)														Float a11;
HXDLIN(  29)														int this26 = ((this25 >> 24) & 255);
HXDLIN(  29)														if ((this26 == 0)) {
HXLINE(  29)															a11 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float r11;
HXDLIN(  29)														int this27 = ((this25 >> 16) & 255);
HXDLIN(  29)														if ((this27 == 0)) {
HXLINE(  29)															r11 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float g11;
HXDLIN(  29)														int this28 = ((this25 >> 8) & 255);
HXDLIN(  29)														if ((this28 == 0)) {
HXLINE(  29)															g11 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float b12;
HXDLIN(  29)														int this29 = (this25 & 255);
HXDLIN(  29)														if ((this29 == 0)) {
HXLINE(  29)															b12 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float a21;
HXDLIN(  29)														int this30 = ((color >> 24) & 255);
HXDLIN(  29)														if ((this30 == 0)) {
HXLINE(  29)															a21 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float r21;
HXDLIN(  29)														int this31 = ((color >> 16) & 255);
HXDLIN(  29)														if ((this31 == 0)) {
HXLINE(  29)															r21 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float g21;
HXDLIN(  29)														int this32 = ((color >> 8) & 255);
HXDLIN(  29)														if ((this32 == 0)) {
HXLINE(  29)															g21 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float b22;
HXDLIN(  29)														int this33 = (color & 255);
HXDLIN(  29)														if ((this33 == 0)) {
HXLINE(  29)															b22 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  29)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  29)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  29)														int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  29)														int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  29)														int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  29)														{
HXLINE(  29)															int _hx_tmp6;
HXDLIN(  29)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)																_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            															}
            															else {
HXLINE(  29)																_hx_tmp6 = blended1;
            															}
HXDLIN(  29)															::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            														}
            													}
            													else {
HXLINE(  29)														::Dynamic this34 = this1->image;
HXDLIN(  29)														int index4;
HXDLIN(  29)														if (this1->useVirtualPos) {
HXLINE(  29)															index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            														}
            														else {
HXLINE(  29)															index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            														}
HXDLIN(  29)														int _hx_tmp7;
HXDLIN(  29)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)															_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXLINE(  29)															_hx_tmp7 = c3;
            														}
HXDLIN(  29)														::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            													}
            												}
HXLINE(  73)												found = true;
            											}
            											else {
HXLINE(  29)												if (found) {
HXLINE(  29)													goto _hx_goto_110;
            												}
            											}
            										}
            									}
            									_hx_goto_110:;
            								}
            							}
            						}
            					}
            				}
HXDLIN(  29)				{
HXLINE(  29)					Float bx2 = cx;
HXDLIN(  29)					Float by2 = cy;
HXDLIN(  29)					Float cx2 = dx;
HXDLIN(  29)					Float cy2 = dy;
HXDLIN(  29)					bool hasUndo1 = false;
HXDLIN(  29)					bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  29)					if (!(adjustWinding1)) {
HXLINE(  29)						Float bx_1 = bx2;
HXDLIN(  29)						Float by_1 = by2;
HXLINE(  25)						bx2 = cx2;
HXLINE(  26)						by2 = cy2;
HXLINE(  27)						cx2 = bx_1;
HXLINE(  28)						cy2 = by_1;
            					}
HXLINE(  29)					{
HXLINE(  29)						Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  29)						Float sx1 = (cy2 - by);
HXDLIN(  29)						Float sy1 = (bx - cx2);
HXDLIN(  29)						Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  29)						Float tx1 = (by - by2);
HXDLIN(  29)						Float ty1 = (bx2 - bx);
HXDLIN(  29)						Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  29)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  29)						if ((bx > bx2)) {
HXLINE(  29)							if ((bx > cx2)) {
HXLINE(  29)								int min4;
HXDLIN(  29)								if ((bx2 > cx2)) {
HXLINE(  29)									min4 = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE(  29)									min4 = ::Math_obj::floor(bx2);
            								}
HXDLIN(  29)								int ii_min8 = min4;
HXDLIN(  29)								int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN(  29)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            							else {
HXLINE(  29)								int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN(  29)								int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  29)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            						}
            						else {
HXLINE(  29)							if ((bx2 > cx2)) {
HXLINE(  29)								int min5;
HXDLIN(  29)								if ((bx > cx2)) {
HXLINE(  29)									min5 = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE(  29)									min5 = ::Math_obj::ceil(bx);
            								}
HXDLIN(  29)								int ii_min10 = min5;
HXDLIN(  29)								int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN(  29)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            							else {
HXLINE(  29)								int ii_min11 = ::Math_obj::floor(bx);
HXDLIN(  29)								int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  29)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            						}
HXDLIN(  29)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  29)						if ((by > by2)) {
HXLINE(  29)							if ((by > cy2)) {
HXLINE(  29)								int min6;
HXDLIN(  29)								if ((by2 > cy2)) {
HXLINE(  29)									min6 = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE(  29)									min6 = ::Math_obj::floor(by2);
            								}
HXDLIN(  29)								int ii_min12 = min6;
HXDLIN(  29)								int ii_max12 = ::Math_obj::ceil(by);
HXDLIN(  29)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            							else {
HXLINE(  29)								int ii_min13 = ::Math_obj::floor(by2);
HXDLIN(  29)								int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  29)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            						}
            						else {
HXLINE(  29)							if ((by2 > cy2)) {
HXLINE(  29)								int min7;
HXDLIN(  29)								if ((by > cy2)) {
HXLINE(  29)									min7 = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE(  29)									min7 = ::Math_obj::ceil(by);
            								}
HXDLIN(  29)								int ii_min14 = min7;
HXDLIN(  29)								int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN(  29)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            							else {
HXLINE(  29)								int ii_min15 = ::Math_obj::floor(by);
HXDLIN(  29)								int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  29)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            						}
HXDLIN(  29)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  29)						if (hasUndo1) {
HXLINE(  29)							int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  29)							int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  29)							 ::Dynamic imageType1 = null();
HXDLIN(  29)							 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  29)							if (::hx::IsNull( imageType1 )) {
HXLINE(  54)								imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  29)							::Dynamic undoImage4;
HXDLIN(  29)							switch((int)(( (int)(imageType1) ))){
            								case (int)0: {
HXLINE(  29)									 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  29)									{
HXLINE(  29)										b5->width = width1;
HXDLIN(  29)										b5->height = height1;
HXDLIN(  29)										b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  29)										b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  29)										{
HXLINE(  29)											int len2 = b5->length;
HXDLIN(  29)											int w1 = 0;
HXDLIN(  29)											{
HXLINE(  29)												int _g20 = 0;
HXDLIN(  29)												int _g21 = b5->height;
HXDLIN(  29)												while((_g20 < _g21)){
HXLINE(  29)													_g20 = (_g20 + 1);
HXDLIN(  29)													int y4 = (_g20 - 1);
HXDLIN(  29)													{
HXLINE(  29)														int _g22 = 0;
HXDLIN(  29)														int _g23 = b5->width;
HXDLIN(  29)														while((_g22 < _g23)){
HXLINE(  29)															_g22 = (_g22 + 1);
HXDLIN(  29)															int x4 = (_g22 - 1);
HXDLIN(  29)															{
HXLINE(  29)																w1 = (w1 + 1);
HXDLIN(  29)																b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  29)															{
HXLINE(  29)																w1 = (w1 + 1);
HXDLIN(  29)																b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  29)															{
HXLINE(  29)																w1 = (w1 + 1);
HXDLIN(  29)																b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  29)															{
HXLINE(  29)																w1 = (w1 + 1);
HXDLIN(  29)																b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  29)									undoImage4 = b5;
            								}
            								break;
            								case (int)1: {
HXLINE(  29)									 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  29)									{
HXLINE(  29)										a6->width = width1;
HXDLIN(  29)										a6->height = height1;
HXDLIN(  29)										a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  29)										a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  29)										{
HXLINE(  29)											int _g24 = 0;
HXDLIN(  29)											int _g25 = a6->length;
HXDLIN(  29)											while((_g24 < _g25)){
HXLINE(  29)												_g24 = (_g24 + 1);
HXDLIN(  29)												int i6 = (_g24 - 1);
HXDLIN(  29)												a6->data[i6] = 0;
            											}
            										}
            									}
HXDLIN(  29)									undoImage4 = a6;
            								}
            								break;
            								case (int)2: {
HXLINE(  29)									 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  29)									{
HXLINE(  29)										b6->width = width1;
HXDLIN(  29)										b6->height = height1;
HXDLIN(  29)										b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  29)										int size1 = (b6->length * 4);
HXDLIN(  29)										b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  29)										{
HXLINE(  29)											int _g26 = 0;
HXDLIN(  29)											int _g27 = b6->length;
HXDLIN(  29)											while((_g26 < _g27)){
HXLINE(  29)												_g26 = (_g26 + 1);
HXDLIN(  29)												int i7 = (_g26 - 1);
HXDLIN(  29)												{
HXLINE(  29)													 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN(  29)													bool undoImage5;
HXDLIN(  29)													if ((i7 >= 0)) {
HXLINE(  29)														undoImage5 = (i7 < (this36->byteLength >> 2));
            													}
            													else {
HXLINE(  29)														undoImage5 = false;
            													}
HXDLIN(  29)													if (undoImage5) {
HXLINE(  29)														 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN(  29)														int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN(  29)														_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  29)														_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  29)														_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  29)														_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  29)									undoImage4 = b6;
            								}
            								break;
            								case (int)3: {
HXLINE(  29)									 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  29)									{
HXLINE(  29)										v2->width = width1;
HXDLIN(  29)										v2->height = height1;
HXDLIN(  29)										v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  29)										v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  29)										{
HXLINE(  29)											int _g28 = 0;
HXDLIN(  29)											int _g29 = v2->length;
HXDLIN(  29)											while((_g28 < _g29)){
HXLINE(  29)												_g28 = (_g28 + 1);
HXDLIN(  29)												int i8 = (_g28 - 1);
HXDLIN(  29)												v2->data->__unsafe_set(i8,0);
            											}
            										}
            									}
HXDLIN(  29)									undoImage4 = v2;
            								}
            								break;
            								case (int)4: {
HXLINE(  29)									 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  29)									 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  29)									{
HXLINE(  29)										b7->width = width1;
HXDLIN(  29)										b7->height = height1;
HXDLIN(  29)										b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  29)										b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  29)										{
HXLINE(  29)											int len3 = b7->length;
HXDLIN(  29)											 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  29)											if (::hx::IsNull( d1->head )) {
HXLINE(  29)												int _g30 = 0;
HXDLIN(  29)												int _g31 = len3;
HXDLIN(  29)												while((_g30 < _g31)){
HXLINE(  29)													_g30 = (_g30 + 1);
HXDLIN(  29)													int i9 = (_g30 - 1);
HXDLIN(  29)													d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            												}
            											}
            											else {
HXLINE(  29)												int _g32 = 0;
HXDLIN(  29)												int _g33 = len3;
HXDLIN(  29)												while((_g32 < _g33)){
HXLINE(  29)													_g32 = (_g32 + 1);
HXDLIN(  29)													int i10 = (_g32 - 1);
HXDLIN(  29)													{
HXLINE(  29)														 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  29)														 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  29)														{
HXLINE(  29)															int _g34 = 0;
HXDLIN(  29)															int _g35 = i10;
HXDLIN(  29)															while((_g34 < _g35)){
HXLINE(  29)																_g34 = (_g34 + 1);
HXDLIN(  29)																int i11 = (_g34 - 1);
HXLINE( 345)																prev1 = l1;
HXLINE( 346)																l1 = l1->next;
            															}
            														}
HXLINE(  29)														if (::hx::IsNull( prev1 )) {
HXLINE(  29)															b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  29)															l1 = null();
            														}
            														else {
HXLINE(  29)															prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  29)															l1 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  29)									undoImage4 = b7;
            								}
            								break;
            							}
HXDLIN(  29)							this35->image = undoImage4;
HXDLIN(  29)							this35->width = width1;
HXDLIN(  29)							this35->height = height1;
HXDLIN(  29)							this35->imageType = ( (int)(imageType1) );
HXDLIN(  29)							undoImage3 = this35;
HXDLIN(  29)							{
HXLINE(  29)								int rectLeft1 = xIter31->start;
HXDLIN(  29)								int rectTop1 = yIter31->start;
HXDLIN(  29)								int rectRight1 = xIter31->max;
HXDLIN(  29)								bool forceClear1 = false;
HXDLIN(  29)								{
HXLINE(  29)									int _g36 = rectTop1;
HXDLIN(  29)									int _g37 = yIter31->max;
HXDLIN(  29)									while((_g36 < _g37)){
HXLINE(  29)										_g36 = (_g36 + 1);
HXDLIN(  29)										int dy2 = (_g36 - 1);
HXDLIN(  29)										{
HXLINE(  29)											int _g38 = rectLeft1;
HXDLIN(  29)											int _g39 = rectRight1;
HXDLIN(  29)											while((_g38 < _g39)){
HXLINE(  29)												_g38 = (_g38 + 1);
HXDLIN(  29)												int dx2 = (_g38 - 1);
HXDLIN(  29)												::Dynamic this37 = this1->image;
HXDLIN(  29)												int index5;
HXDLIN(  29)												if (this1->useVirtualPos) {
HXLINE(  29)													index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            												}
            												else {
HXLINE(  29)													index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            												}
HXDLIN(  29)												int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN(  29)												int col1;
HXDLIN(  29)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)													col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE(  29)													col1 = c4;
            												}
HXDLIN(  29)												bool _hx_tmp8;
HXDLIN(  29)												if (this1->useMask) {
HXLINE(  29)													_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            												}
            												else {
HXLINE(  29)													_hx_tmp8 = false;
            												}
HXDLIN(  29)												if (_hx_tmp8) {
HXLINE(  29)													 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN(  29)													::Dynamic this39 = this38->image;
HXDLIN(  29)													int index6;
HXDLIN(  29)													if (this38->useVirtualPos) {
HXLINE(  29)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            													}
            													else {
HXLINE(  29)														index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            													}
HXDLIN(  29)													int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN(  29)													int v3;
HXDLIN(  29)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)														v3 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXLINE(  29)														v3 = c5;
            													}
HXDLIN(  29)													int maskPixel1 = v3;
HXDLIN(  29)													int this40 = col1;
HXDLIN(  29)													if ((maskPixel1 == 0)) {
HXLINE(  29)														col1 = this40;
            													}
            													else {
HXLINE(  29)														Float m01;
HXDLIN(  29)														int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN(  29)														if ((this41 == 0)) {
HXLINE(  29)															m01 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float m11;
HXDLIN(  29)														int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN(  29)														if ((this42 == 0)) {
HXLINE(  29)															m11 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float m21;
HXDLIN(  29)														int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN(  29)														if ((this43 == 0)) {
HXLINE(  29)															m21 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float m31;
HXDLIN(  29)														int this44 = (maskPixel1 & 255);
HXDLIN(  29)														if ((this44 == 0)) {
HXLINE(  29)															m31 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN(  29)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN(  29)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN(  29)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN(  29)														col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  29)												if ((col1 != 0)) {
HXLINE(  29)													int x5 = (dx2 - rectLeft1);
HXDLIN(  29)													int y5 = (dy2 - rectTop1);
HXDLIN(  29)													int c6 = col1;
HXDLIN(  29)													bool _hx_tmp9;
HXDLIN(  29)													if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  29)														_hx_tmp9 = undoImage3->transparent;
            													}
            													else {
HXLINE(  29)														_hx_tmp9 = false;
            													}
HXDLIN(  29)													if (_hx_tmp9) {
HXLINE(  29)														int location2;
HXDLIN(  29)														if (undoImage3->useVirtualPos) {
HXLINE(  29)															location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  29)															location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            														}
HXDLIN(  29)														int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  29)														int this46;
HXDLIN(  29)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)															this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            														}
            														else {
HXLINE(  29)															this46 = this45;
            														}
HXDLIN(  29)														Float a12;
HXDLIN(  29)														int this47 = ((this46 >> 24) & 255);
HXDLIN(  29)														if ((this47 == 0)) {
HXLINE(  29)															a12 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float r12;
HXDLIN(  29)														int this48 = ((this46 >> 16) & 255);
HXDLIN(  29)														if ((this48 == 0)) {
HXLINE(  29)															r12 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float g12;
HXDLIN(  29)														int this49 = ((this46 >> 8) & 255);
HXDLIN(  29)														if ((this49 == 0)) {
HXLINE(  29)															g12 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float b13;
HXDLIN(  29)														int this50 = (this46 & 255);
HXDLIN(  29)														if ((this50 == 0)) {
HXLINE(  29)															b13 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float a22;
HXDLIN(  29)														int this51 = ((col1 >> 24) & 255);
HXDLIN(  29)														if ((this51 == 0)) {
HXLINE(  29)															a22 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float r22;
HXDLIN(  29)														int this52 = ((col1 >> 16) & 255);
HXDLIN(  29)														if ((this52 == 0)) {
HXLINE(  29)															r22 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float g22;
HXDLIN(  29)														int this53 = ((col1 >> 8) & 255);
HXDLIN(  29)														if ((this53 == 0)) {
HXLINE(  29)															g22 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float b23;
HXDLIN(  29)														int this54 = (col1 & 255);
HXDLIN(  29)														if ((this54 == 0)) {
HXLINE(  29)															b23 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  29)														int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  29)														int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  29)														int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  29)														int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  29)														int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  29)														{
HXLINE(  29)															int _hx_tmp10;
HXDLIN(  29)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)																_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            															}
            															else {
HXLINE(  29)																_hx_tmp10 = blended2;
            															}
HXDLIN(  29)															::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            														}
            													}
            													else {
HXLINE(  29)														::Dynamic this55 = undoImage3->image;
HXDLIN(  29)														int index7;
HXDLIN(  29)														if (undoImage3->useVirtualPos) {
HXLINE(  29)															index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  29)															index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            														}
HXDLIN(  29)														int _hx_tmp11;
HXDLIN(  29)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)															_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXLINE(  29)															_hx_tmp11 = c6;
            														}
HXDLIN(  29)														::iterMagic::Iimg_obj::set(this55,index7,_hx_tmp11);
            													}
            												}
            												else {
HXLINE(  29)													if (forceClear1) {
HXLINE(  29)														::Dynamic this56 = undoImage3->image;
HXDLIN(  29)														int x6 = (dx2 - rectLeft1);
HXDLIN(  29)														int y6 = (dy2 - rectTop1);
HXDLIN(  29)														int index8;
HXDLIN(  29)														if (undoImage3->useVirtualPos) {
HXLINE(  29)															index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  29)															index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            														}
HXDLIN(  29)														::iterMagic::Iimg_obj::set(this56,index8,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  29)						bool found1 = false;
HXDLIN(  29)						Float s1 = ((Float)0.);
HXDLIN(  29)						Float t1 = ((Float)0.);
HXDLIN(  29)						Float sxx1 = ((Float)0.);
HXDLIN(  29)						Float txx1 = ((Float)0.);
HXDLIN(  29)						{
HXLINE(  29)							int _g_min2 = xIter31->start;
HXDLIN(  29)							int _g_max2 = xIter31->max;
HXDLIN(  29)							while((_g_min2 < _g_max2)){
HXLINE(  29)								_g_min2 = (_g_min2 + 1);
HXDLIN(  29)								int x7 = (_g_min2 - 1);
HXLINE(  60)								sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)								txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)								found1 = false;
HXLINE(  29)								{
HXLINE(  29)									int _g_min3 = yIter31->start;
HXDLIN(  29)									int _g_max3 = yIter31->max;
HXDLIN(  29)									while((_g_min3 < _g_max3)){
HXLINE(  29)										_g_min3 = (_g_min3 + 1);
HXDLIN(  29)										int y7 = (_g_min3 - 1);
HXLINE(  64)										s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)										t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  29)										bool _hx_tmp12;
HXDLIN(  29)										if (!((s1 <= 0))) {
HXLINE(  29)											_hx_tmp12 = (t1 <= 0);
            										}
            										else {
HXLINE(  29)											_hx_tmp12 = true;
            										}
HXDLIN(  29)										if (_hx_tmp12) {
HXLINE(  29)											if (found1) {
HXLINE(  29)												goto _hx_goto_122;
            											}
            										}
            										else {
HXLINE(  29)											if (((s1 + t1) < A1)) {
HXLINE(  29)												{
HXLINE(  29)													int c7 = color;
HXDLIN(  29)													bool _hx_tmp13;
HXDLIN(  29)													if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  29)														_hx_tmp13 = this1->transparent;
            													}
            													else {
HXLINE(  29)														_hx_tmp13 = false;
            													}
HXDLIN(  29)													if (_hx_tmp13) {
HXLINE(  29)														int location3;
HXDLIN(  29)														if (this1->useVirtualPos) {
HXLINE(  29)															location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            														}
            														else {
HXLINE(  29)															location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            														}
HXDLIN(  29)														int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  29)														int this58;
HXDLIN(  29)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)															this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            														}
            														else {
HXLINE(  29)															this58 = this57;
            														}
HXDLIN(  29)														Float a13;
HXDLIN(  29)														int this59 = ((this58 >> 24) & 255);
HXDLIN(  29)														if ((this59 == 0)) {
HXLINE(  29)															a13 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															a13 = (( (Float)(this59) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float r13;
HXDLIN(  29)														int this60 = ((this58 >> 16) & 255);
HXDLIN(  29)														if ((this60 == 0)) {
HXLINE(  29)															r13 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float g13;
HXDLIN(  29)														int this61 = ((this58 >> 8) & 255);
HXDLIN(  29)														if ((this61 == 0)) {
HXLINE(  29)															g13 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float b14;
HXDLIN(  29)														int this62 = (this58 & 255);
HXDLIN(  29)														if ((this62 == 0)) {
HXLINE(  29)															b14 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float a23;
HXDLIN(  29)														int this63 = ((color >> 24) & 255);
HXDLIN(  29)														if ((this63 == 0)) {
HXLINE(  29)															a23 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float r23;
HXDLIN(  29)														int this64 = ((color >> 16) & 255);
HXDLIN(  29)														if ((this64 == 0)) {
HXLINE(  29)															r23 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float g23;
HXDLIN(  29)														int this65 = ((color >> 8) & 255);
HXDLIN(  29)														if ((this65 == 0)) {
HXLINE(  29)															g23 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float b24;
HXDLIN(  29)														int this66 = (color & 255);
HXDLIN(  29)														if ((this66 == 0)) {
HXLINE(  29)															b24 = ((Float)0.);
            														}
            														else {
HXLINE(  29)															b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            														}
HXDLIN(  29)														Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  29)														int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  29)														int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  29)														int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  29)														int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  29)														int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  29)														{
HXLINE(  29)															int _hx_tmp14;
HXDLIN(  29)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)																_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            															}
            															else {
HXLINE(  29)																_hx_tmp14 = blended3;
            															}
HXDLIN(  29)															::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            														}
            													}
            													else {
HXLINE(  29)														::Dynamic this67 = this1->image;
HXDLIN(  29)														int index9;
HXDLIN(  29)														if (this1->useVirtualPos) {
HXLINE(  29)															index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            														}
            														else {
HXLINE(  29)															index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            														}
HXDLIN(  29)														int _hx_tmp15;
HXDLIN(  29)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  29)															_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            														}
            														else {
HXLINE(  29)															_hx_tmp15 = c7;
            														}
HXDLIN(  29)														::iterMagic::Iimg_obj::set(this67,index9,_hx_tmp15);
            													}
            												}
HXLINE(  73)												found1 = true;
            											}
            											else {
HXLINE(  29)												if (found1) {
HXLINE(  29)													goto _hx_goto_122;
            												}
            											}
            										}
            									}
            									_hx_goto_122:;
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  30)		return pixelImage;
            	}



::hx::ObjectPtr< QuadShape_obj > QuadShape_obj::__new( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic aX, ::Dynamic aY, ::Dynamic bX, ::Dynamic bY, ::Dynamic cX, ::Dynamic cY, ::Dynamic dX, ::Dynamic dY) {
	::hx::ObjectPtr< QuadShape_obj > __this = new QuadShape_obj();
	__this->__construct(opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY);
	return __this;
}

::hx::ObjectPtr< QuadShape_obj > QuadShape_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic aX, ::Dynamic aY, ::Dynamic bX, ::Dynamic bY, ::Dynamic cX, ::Dynamic cY, ::Dynamic dX, ::Dynamic dY) {
	QuadShape_obj *__this = (QuadShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(QuadShape_obj), true, "pi_xy.triangleGML.QuadShape"));
	*(void **)__this = QuadShape_obj::_hx_vtable;
	__this->__construct(opacity,visibility,strokeColor,aX,aY,bX,bY,cX,cY,dX,dY);
	return __this;
}

QuadShape_obj::QuadShape_obj()
{
}

::hx::Val QuadShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"clear") ) { return ::hx::Val( clear_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"luxury") ) { return ::hx::Val( luxury ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val QuadShape_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"luxury") ) { luxury=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void QuadShape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("luxury",0d,9d,17,dc));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo QuadShape_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(QuadShape_obj,luxury),HX_("luxury",0d,9d,17,dc)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *QuadShape_obj_sStaticStorageInfo = 0;
#endif

static ::String QuadShape_obj_sMemberFields[] = {
	HX_("luxury",0d,9d,17,dc),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	HX_("clear",8d,71,5b,48),
	::String(null()) };

::hx::Class QuadShape_obj::__mClass;

void QuadShape_obj::__register()
{
	QuadShape_obj _hx_dummy;
	QuadShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.triangleGML.QuadShape",03,5f,04,fa);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(QuadShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< QuadShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = QuadShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = QuadShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace triangleGML
