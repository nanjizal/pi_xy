// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_nme_app_IAppEventHandler
#include <nme/app/IAppEventHandler.h>
#endif
#ifndef INCLUDED_nme_app_IPollClient
#include <nme/app/IPollClient.h>
#endif
#ifndef INCLUDED_nme_display_DisplayObject
#include <nme/display/DisplayObject.h>
#endif
#ifndef INCLUDED_nme_display_DisplayObjectContainer
#include <nme/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_nme_display_IBitmapDrawable
#include <nme/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_nme_display_InteractiveObject
#include <nme/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_nme_display_Sprite
#include <nme/display/Sprite.h>
#endif
#ifndef INCLUDED_nme_display_Stage
#include <nme/display/Stage.h>
#endif
#ifndef INCLUDED_nme_events_EventDispatcher
#include <nme/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_nme_events_IEventDispatcher
#include <nme/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_nme_geom_Rectangle
#include <nme/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a1c505347e3063ba_14_new,"nme.display.Sprite","new",0xf612366b,"nme.display.Sprite.new","nme/display/Sprite.hx",14,0xc7282623)
HX_LOCAL_STACK_FRAME(_hx_pos_a1c505347e3063ba_17_nmeGetType,"nme.display.Sprite","nmeGetType",0xdb32491f,"nme.display.Sprite.nmeGetType","nme/display/Sprite.hx",17,0xc7282623)
HX_LOCAL_STACK_FRAME(_hx_pos_a1c505347e3063ba_25_startDrag,"nme.display.Sprite","startDrag",0x2a5ea5c1,"nme.display.Sprite.startDrag","nme/display/Sprite.hx",25,0xc7282623)
HX_LOCAL_STACK_FRAME(_hx_pos_a1c505347e3063ba_31_stopDrag,"nme.display.Sprite","stopDrag",0xdb67432b,"nme.display.Sprite.stopDrag","nme/display/Sprite.hx",31,0xc7282623)
namespace nme{
namespace display{

void Sprite_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_a1c505347e3063ba_14_new)
HXDLIN(  14)		 ::hx::Object * _hx_tmp = ::nme::display::DisplayObjectContainer_obj::nme_create_display_object_container();
HXDLIN(  14)		super::__construct(( ( ::Dynamic)(_hx_tmp) ),this->nmeGetType());
            	}

Dynamic Sprite_obj::__CreateEmpty() { return new Sprite_obj; }

void *Sprite_obj::_hx_vtable = 0;

Dynamic Sprite_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Sprite_obj > _hx_result = new Sprite_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Sprite_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x169017a6) {
		if (inClassId<=(int)0x0ff07575) {
			if (inClassId<=(int)0x048b25c1) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x048b25c1;
			} else {
				return inClassId==(int)0x0ff07575;
			}
		} else {
			return inClassId==(int)0x169017a6;
		}
	} else {
		return inClassId==(int)0x5a2ce121 || inClassId==(int)0x5e732244;
	}
}

::String Sprite_obj::nmeGetType(){
            	HX_STACKFRAME(&_hx_pos_a1c505347e3063ba_17_nmeGetType)
HXLINE(  18)		::String type = ::Type_obj::getClassName(::Type_obj::getClass(::hx::ObjectPtr<OBJ_>(this)));
HXLINE(  19)		int pos = type.lastIndexOf(HX_(".",2e,00,00,00),null());
HXLINE(  20)		if ((pos >= 0)) {
HXLINE(  20)			return type.substr((pos + 1),null());
            		}
            		else {
HXLINE(  20)			return type;
            		}
HXDLIN(  20)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sprite_obj,nmeGetType,return )

void Sprite_obj::startDrag(::hx::Null< bool >  __o_lockCenter, ::nme::geom::Rectangle bounds){
            		bool lockCenter = __o_lockCenter.Default(false);
            	HX_STACKFRAME(&_hx_pos_a1c505347e3063ba_25_startDrag)
HXDLIN(  25)		if (::hx::IsNotNull( this->get_stage() )) {
HXLINE(  26)			this->get_stage()->nmeStartDrag(::hx::ObjectPtr<OBJ_>(this),lockCenter,bounds);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sprite_obj,startDrag,(void))

void Sprite_obj::stopDrag(){
            	HX_STACKFRAME(&_hx_pos_a1c505347e3063ba_31_stopDrag)
HXDLIN(  31)		if (::hx::IsNotNull( this->get_stage() )) {
HXLINE(  32)			this->get_stage()->nmeStopDrag(::hx::ObjectPtr<OBJ_>(this));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sprite_obj,stopDrag,(void))


::hx::ObjectPtr< Sprite_obj > Sprite_obj::__new() {
	::hx::ObjectPtr< Sprite_obj > __this = new Sprite_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Sprite_obj > Sprite_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Sprite_obj *__this = (Sprite_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Sprite_obj), true, "nme.display.Sprite"));
	*(void **)__this = Sprite_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Sprite_obj::Sprite_obj()
{
}

::hx::Val Sprite_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"stopDrag") ) { return ::hx::Val( stopDrag_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"startDrag") ) { return ::hx::Val( startDrag_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"buttonMode") ) { return ::hx::Val( buttonMode ); }
		if (HX_FIELD_EQ(inName,"nmeGetType") ) { return ::hx::Val( nmeGetType_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"useHandCursor") ) { return ::hx::Val( useHandCursor ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Sprite_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"buttonMode") ) { buttonMode=inValue.Cast< bool >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"useHandCursor") ) { useHandCursor=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Sprite_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("buttonMode",75,42,57,b2));
	outFields->push(HX_("useHandCursor",cc,da,ae,89));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Sprite_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(Sprite_obj,buttonMode),HX_("buttonMode",75,42,57,b2)},
	{::hx::fsBool,(int)offsetof(Sprite_obj,useHandCursor),HX_("useHandCursor",cc,da,ae,89)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Sprite_obj_sStaticStorageInfo = 0;
#endif

static ::String Sprite_obj_sMemberFields[] = {
	HX_("buttonMode",75,42,57,b2),
	HX_("useHandCursor",cc,da,ae,89),
	HX_("nmeGetType",ca,07,8d,ee),
	HX_("startDrag",76,a5,63,fb),
	HX_("stopDrag",16,71,2a,95),
	::String(null()) };

::hx::Class Sprite_obj::__mClass;

void Sprite_obj::__register()
{
	Sprite_obj _hx_dummy;
	Sprite_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("nme.display.Sprite",f9,24,ae,1c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Sprite_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Sprite_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Sprite_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Sprite_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nme
} // end namespace display
