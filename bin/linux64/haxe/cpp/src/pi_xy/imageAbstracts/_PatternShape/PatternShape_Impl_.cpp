// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__PatternShape_PatternShape_Impl_
#include <pi_xy/imageAbstracts/_PatternShape/PatternShape_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_33c2d5872a3431bf_7__new,"pi_xy.imageAbstracts._PatternShape.PatternShape_Impl_","_new",0x3b6dfd0f,"pi_xy.imageAbstracts._PatternShape.PatternShape_Impl_._new","pi_xy/imageAbstracts/PatternShape.hx",7,0xe81d7d3c)
HX_LOCAL_STACK_FRAME(_hx_pos_33c2d5872a3431bf_17_rectangle,"pi_xy.imageAbstracts._PatternShape.PatternShape_Impl_","rectangle",0xc4e155c1,"pi_xy.imageAbstracts._PatternShape.PatternShape_Impl_.rectangle","pi_xy/imageAbstracts/PatternShape.hx",17,0xe81d7d3c)
HX_LOCAL_STACK_FRAME(_hx_pos_33c2d5872a3431bf_27_rectangleDown,"pi_xy.imageAbstracts._PatternShape.PatternShape_Impl_","rectangleDown",0xa64ceec3,"pi_xy.imageAbstracts._PatternShape.PatternShape_Impl_.rectangleDown","pi_xy/imageAbstracts/PatternShape.hx",27,0xe81d7d3c)
namespace pi_xy{
namespace imageAbstracts{
namespace _PatternShape{

void PatternShape_Impl__obj::__construct() { }

Dynamic PatternShape_Impl__obj::__CreateEmpty() { return new PatternShape_Impl__obj; }

void *PatternShape_Impl__obj::_hx_vtable = 0;

Dynamic PatternShape_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PatternShape_Impl__obj > _hx_result = new PatternShape_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool PatternShape_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7cdf138c;
}

 ::pi_xy::ImageStruct PatternShape_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_33c2d5872a3431bf_7__new)
HXLINE(   9)		 ::Dynamic imageType = null();
HXDLIN(   9)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(   9)		if (::hx::IsNull( imageType )) {
HXLINE(   9)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(   9)		::Dynamic this2;
HXDLIN(   9)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(   9)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::BytesImg b = byt;
HXDLIN(   9)				{
HXLINE(   9)					b->width = w;
HXDLIN(   9)					b->height = h;
HXDLIN(   9)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(   9)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(   9)					{
HXLINE(   9)						int len = b->length;
HXDLIN(   9)						int w1 = 0;
HXDLIN(   9)						{
HXLINE(   9)							int _g = 0;
HXDLIN(   9)							int _g1 = b->height;
HXDLIN(   9)							while((_g < _g1)){
HXLINE(   9)								_g = (_g + 1);
HXDLIN(   9)								int y = (_g - 1);
HXDLIN(   9)								{
HXLINE(   9)									int _g2 = 0;
HXDLIN(   9)									int _g3 = b->width;
HXDLIN(   9)									while((_g2 < _g3)){
HXLINE(   9)										_g2 = (_g2 + 1);
HXDLIN(   9)										int x = (_g2 - 1);
HXDLIN(   9)										{
HXLINE(   9)											w1 = (w1 + 1);
HXDLIN(   9)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   9)										{
HXLINE(   9)											w1 = (w1 + 1);
HXDLIN(   9)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   9)										{
HXLINE(   9)											w1 = (w1 + 1);
HXDLIN(   9)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   9)										{
HXLINE(   9)											w1 = (w1 + 1);
HXDLIN(   9)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(   9)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE(   9)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(   9)				{
HXLINE(   9)					a->width = w;
HXDLIN(   9)					a->height = h;
HXDLIN(   9)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(   9)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(   9)					{
HXLINE(   9)						int _g4 = 0;
HXDLIN(   9)						int _g5 = a->length;
HXDLIN(   9)						while((_g4 < _g5)){
HXLINE(   9)							_g4 = (_g4 + 1);
HXDLIN(   9)							int i = (_g4 - 1);
HXDLIN(   9)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(   9)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE(   9)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(   9)				{
HXLINE(   9)					b1->width = w;
HXDLIN(   9)					b1->height = h;
HXDLIN(   9)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(   9)					int size = (b1->length * 4);
HXDLIN(   9)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(   9)					{
HXLINE(   9)						int _g6 = 0;
HXDLIN(   9)						int _g7 = b1->length;
HXDLIN(   9)						while((_g6 < _g7)){
HXLINE(   9)							_g6 = (_g6 + 1);
HXDLIN(   9)							int i1 = (_g6 - 1);
HXDLIN(   9)							{
HXLINE(   9)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(   9)								bool this4;
HXDLIN(   9)								if ((i1 >= 0)) {
HXLINE(   9)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(   9)									this4 = false;
            								}
HXDLIN(   9)								if (this4) {
HXLINE(   9)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(   9)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(   9)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(   9)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(   9)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(   9)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(   9)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(   9)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(   9)				{
HXLINE(   9)					v->width = w;
HXDLIN(   9)					v->height = h;
HXDLIN(   9)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(   9)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(   9)					{
HXLINE(   9)						int _g8 = 0;
HXDLIN(   9)						int _g9 = v->length;
HXDLIN(   9)						while((_g8 < _g9)){
HXLINE(   9)							_g8 = (_g8 + 1);
HXDLIN(   9)							int i2 = (_g8 - 1);
HXDLIN(   9)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(   9)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE(   9)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(   9)				{
HXLINE(   9)					b2->width = w;
HXDLIN(   9)					b2->height = h;
HXDLIN(   9)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(   9)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(   9)					{
HXLINE(   9)						int len1 = b2->length;
HXDLIN(   9)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(   9)						if (::hx::IsNull( d->head )) {
HXLINE(   9)							int _g10 = 0;
HXDLIN(   9)							int _g11 = len1;
HXDLIN(   9)							while((_g10 < _g11)){
HXLINE(   9)								_g10 = (_g10 + 1);
HXDLIN(   9)								int i3 = (_g10 - 1);
HXDLIN(   9)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(   9)							int _g12 = 0;
HXDLIN(   9)							int _g13 = len1;
HXDLIN(   9)							while((_g12 < _g13)){
HXLINE(   9)								_g12 = (_g12 + 1);
HXDLIN(   9)								int i4 = (_g12 - 1);
HXDLIN(   9)								{
HXLINE(   9)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(   9)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(   9)									{
HXLINE(   9)										int _g14 = 0;
HXDLIN(   9)										int _g15 = i4;
HXDLIN(   9)										while((_g14 < _g15)){
HXLINE(   9)											_g14 = (_g14 + 1);
HXDLIN(   9)											int i5 = (_g14 - 1);
HXDLIN(   9)											prev = l;
HXDLIN(   9)											l = l->next;
            										}
            									}
HXDLIN(   9)									if (::hx::IsNull( prev )) {
HXLINE(   9)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(   9)										l = null();
            									}
            									else {
HXLINE(   9)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(   9)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(   9)				this2 = b2;
            			}
            			break;
            		}
HXDLIN(   9)		this1->image = this2;
HXDLIN(   9)		this1->width = w;
HXDLIN(   9)		this1->height = h;
HXDLIN(   9)		this1->imageType = ( (int)(imageType) );
HXLINE(   7)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(PatternShape_Impl__obj,_new,return )

void PatternShape_Impl__obj::rectangle( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,int foreColor,int backColor,::Array< bool > patternFill){
            	HX_STACKFRAME(&_hx_pos_33c2d5872a3431bf_17_rectangle)
HXDLIN(  17)		int p = ::Std_obj::_hx_int(x);
HXDLIN(  17)		int xx = p;
HXDLIN(  17)		int q = ::Std_obj::_hx_int(y);
HXDLIN(  17)		int maxX = ::Std_obj::_hx_int((x + w));
HXDLIN(  17)		int maxY = ::Std_obj::_hx_int((y + h));
HXDLIN(  17)		int count = 0;
HXDLIN(  17)		bool useFore = true;
HXDLIN(  17)		do {
HXDLIN(  17)			if ((count < patternFill->length)) {
HXDLIN(  17)				useFore = patternFill->__get(count);
HXDLIN(  17)				count = (count + 1);
            			}
            			else {
HXDLIN(  17)				count = 0;
HXDLIN(  17)				useFore = patternFill->__get(count);
HXDLIN(  17)				count = (count + 1);
            			}
HXDLIN(  17)			int color;
HXDLIN(  17)			if (useFore) {
HXDLIN(  17)				color = foreColor;
            			}
            			else {
HXDLIN(  17)				color = backColor;
            			}
HXDLIN(  17)			{
HXDLIN(  17)				p = (p + 1);
HXDLIN(  17)				int x1 = (p - 1);
HXDLIN(  17)				int c = color;
HXDLIN(  17)				bool _hx_tmp;
HXDLIN(  17)				if ((((c >> 24) & 255) < 254)) {
HXDLIN(  17)					_hx_tmp = this1->transparent;
            				}
            				else {
HXDLIN(  17)					_hx_tmp = false;
            				}
HXDLIN(  17)				if (_hx_tmp) {
HXDLIN(  17)					int location;
HXDLIN(  17)					if (this1->useVirtualPos) {
HXDLIN(  17)						location = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            					}
            					else {
HXDLIN(  17)						location = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x1)) ));
            					}
HXDLIN(  17)					int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN(  17)					int this3;
HXDLIN(  17)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  17)						this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            					}
            					else {
HXDLIN(  17)						this3 = this2;
            					}
HXDLIN(  17)					Float a1;
HXDLIN(  17)					int this4 = ((this3 >> 24) & 255);
HXDLIN(  17)					if ((this4 == 0)) {
HXDLIN(  17)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN(  17)						a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            					}
HXDLIN(  17)					Float r1;
HXDLIN(  17)					int this5 = ((this3 >> 16) & 255);
HXDLIN(  17)					if ((this5 == 0)) {
HXDLIN(  17)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN(  17)						r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            					}
HXDLIN(  17)					Float g1;
HXDLIN(  17)					int this6 = ((this3 >> 8) & 255);
HXDLIN(  17)					if ((this6 == 0)) {
HXDLIN(  17)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN(  17)						g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  17)					Float b1;
HXDLIN(  17)					int this7 = (this3 & 255);
HXDLIN(  17)					if ((this7 == 0)) {
HXDLIN(  17)						b1 = ((Float)0.);
            					}
            					else {
HXDLIN(  17)						b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  17)					Float a2;
HXDLIN(  17)					int this8 = ((color >> 24) & 255);
HXDLIN(  17)					if ((this8 == 0)) {
HXDLIN(  17)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN(  17)						a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  17)					Float r2;
HXDLIN(  17)					int this9 = ((color >> 16) & 255);
HXDLIN(  17)					if ((this9 == 0)) {
HXDLIN(  17)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN(  17)						r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  17)					Float g2;
HXDLIN(  17)					int this10 = ((color >> 8) & 255);
HXDLIN(  17)					if ((this10 == 0)) {
HXDLIN(  17)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN(  17)						g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  17)					Float b2;
HXDLIN(  17)					int this11 = (color & 255);
HXDLIN(  17)					if ((this11 == 0)) {
HXDLIN(  17)						b2 = ((Float)0.);
            					}
            					else {
HXDLIN(  17)						b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  17)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  17)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  17)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  17)					int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  17)					int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  17)					int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  17)					{
HXDLIN(  17)						int _hx_tmp1;
HXDLIN(  17)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  17)							_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN(  17)							_hx_tmp1 = blended;
            						}
HXDLIN(  17)						::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            					}
            				}
            				else {
HXDLIN(  17)					::Dynamic this12 = this1->image;
HXDLIN(  17)					int index;
HXDLIN(  17)					if (this1->useVirtualPos) {
HXDLIN(  17)						index = ::Std_obj::_hx_int(((((( (Float)(q) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            					}
            					else {
HXDLIN(  17)						index = ::Std_obj::_hx_int(( (Float)(((q * this1->width) + x1)) ));
            					}
HXDLIN(  17)					int _hx_tmp2;
HXDLIN(  17)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  17)						_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXDLIN(  17)						_hx_tmp2 = c;
            					}
HXDLIN(  17)					::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            				}
            			}
HXDLIN(  17)			if ((p > maxX)) {
HXDLIN(  17)				p = xx;
HXDLIN(  17)				q = (q + 1);
            			}
            		} while((q <= maxY));
;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(PatternShape_Impl__obj,rectangle,(void))

void PatternShape_Impl__obj::rectangleDown( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,int foreColor,int backColor,::Array< bool > patternFill){
            	HX_STACKFRAME(&_hx_pos_33c2d5872a3431bf_27_rectangleDown)
HXDLIN(  27)		int p = ::Std_obj::_hx_int(x);
HXDLIN(  27)		int q = ::Std_obj::_hx_int(y);
HXDLIN(  27)		int yy = q;
HXDLIN(  27)		int maxX = ::Std_obj::_hx_int((x + w));
HXDLIN(  27)		int maxY = ::Std_obj::_hx_int((y + h));
HXDLIN(  27)		int count = 0;
HXDLIN(  27)		bool useFore = true;
HXDLIN(  27)		do {
HXDLIN(  27)			if ((count < patternFill->length)) {
HXDLIN(  27)				useFore = patternFill->__get(count);
HXDLIN(  27)				count = (count + 1);
            			}
            			else {
HXDLIN(  27)				count = 0;
HXDLIN(  27)				useFore = patternFill->__get(count);
HXDLIN(  27)				count = (count + 1);
            			}
HXDLIN(  27)			int color;
HXDLIN(  27)			if (useFore) {
HXDLIN(  27)				color = foreColor;
            			}
            			else {
HXDLIN(  27)				color = backColor;
            			}
HXDLIN(  27)			{
HXDLIN(  27)				q = (q + 1);
HXDLIN(  27)				int y1 = (q - 1);
HXDLIN(  27)				int c = color;
HXDLIN(  27)				bool _hx_tmp;
HXDLIN(  27)				if ((((c >> 24) & 255) < 254)) {
HXDLIN(  27)					_hx_tmp = this1->transparent;
            				}
            				else {
HXDLIN(  27)					_hx_tmp = false;
            				}
HXDLIN(  27)				if (_hx_tmp) {
HXDLIN(  27)					int location;
HXDLIN(  27)					if (this1->useVirtualPos) {
HXDLIN(  27)						location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + p) - this1->virtualX));
            					}
            					else {
HXDLIN(  27)						location = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + p)) ));
            					}
HXDLIN(  27)					int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN(  27)					int this3;
HXDLIN(  27)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  27)						this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            					}
            					else {
HXDLIN(  27)						this3 = this2;
            					}
HXDLIN(  27)					Float a1;
HXDLIN(  27)					int this4 = ((this3 >> 24) & 255);
HXDLIN(  27)					if ((this4 == 0)) {
HXDLIN(  27)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN(  27)						a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            					}
HXDLIN(  27)					Float r1;
HXDLIN(  27)					int this5 = ((this3 >> 16) & 255);
HXDLIN(  27)					if ((this5 == 0)) {
HXDLIN(  27)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN(  27)						r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            					}
HXDLIN(  27)					Float g1;
HXDLIN(  27)					int this6 = ((this3 >> 8) & 255);
HXDLIN(  27)					if ((this6 == 0)) {
HXDLIN(  27)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN(  27)						g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  27)					Float b1;
HXDLIN(  27)					int this7 = (this3 & 255);
HXDLIN(  27)					if ((this7 == 0)) {
HXDLIN(  27)						b1 = ((Float)0.);
            					}
            					else {
HXDLIN(  27)						b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  27)					Float a2;
HXDLIN(  27)					int this8 = ((color >> 24) & 255);
HXDLIN(  27)					if ((this8 == 0)) {
HXDLIN(  27)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN(  27)						a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  27)					Float r2;
HXDLIN(  27)					int this9 = ((color >> 16) & 255);
HXDLIN(  27)					if ((this9 == 0)) {
HXDLIN(  27)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN(  27)						r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  27)					Float g2;
HXDLIN(  27)					int this10 = ((color >> 8) & 255);
HXDLIN(  27)					if ((this10 == 0)) {
HXDLIN(  27)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN(  27)						g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  27)					Float b2;
HXDLIN(  27)					int this11 = (color & 255);
HXDLIN(  27)					if ((this11 == 0)) {
HXDLIN(  27)						b2 = ((Float)0.);
            					}
            					else {
HXDLIN(  27)						b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  27)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  27)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  27)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  27)					int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  27)					int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  27)					int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  27)					{
HXDLIN(  27)						int _hx_tmp1;
HXDLIN(  27)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  27)							_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN(  27)							_hx_tmp1 = blended;
            						}
HXDLIN(  27)						::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            					}
            				}
            				else {
HXDLIN(  27)					::Dynamic this12 = this1->image;
HXDLIN(  27)					int index;
HXDLIN(  27)					if (this1->useVirtualPos) {
HXDLIN(  27)						index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + p) - this1->virtualX));
            					}
            					else {
HXDLIN(  27)						index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + p)) ));
            					}
HXDLIN(  27)					int _hx_tmp2;
HXDLIN(  27)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  27)						_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXDLIN(  27)						_hx_tmp2 = c;
            					}
HXDLIN(  27)					::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            				}
            			}
HXDLIN(  27)			if ((q > maxY)) {
HXDLIN(  27)				q = yy;
HXDLIN(  27)				q = (q + 1);
            			}
            		} while((p <= maxX));
;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(PatternShape_Impl__obj,rectangleDown,(void))


PatternShape_Impl__obj::PatternShape_Impl__obj()
{
}

bool PatternShape_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"rectangle") ) { outValue = rectangle_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"rectangleDown") ) { outValue = rectangleDown_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *PatternShape_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *PatternShape_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class PatternShape_Impl__obj::__mClass;

static ::String PatternShape_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("rectangle",2f,d4,7c,19),
	HX_("rectangleDown",31,3c,93,b7),
	::String(null())
};

void PatternShape_Impl__obj::__register()
{
	PatternShape_Impl__obj _hx_dummy;
	PatternShape_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._PatternShape.PatternShape_Impl_",80,97,0a,0d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PatternShape_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PatternShape_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< PatternShape_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PatternShape_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PatternShape_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _PatternShape
