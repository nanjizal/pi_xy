// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_RawImageData
#include <iterMagic/RawImageData.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__RawImage_RawImage_Impl_
#include <pi_xy/imageAbstracts/_RawImage/RawImage_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_12__new,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","_new",0x3fa70dcf,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_._new","pi_xy/imageAbstracts/RawImage.hx",12,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_19_clone,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","clone",0xbed47b2f,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.clone","pi_xy/imageAbstracts/RawImage.hx",19,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_33_set,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","set",0x82110af4,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.set","pi_xy/imageAbstracts/RawImage.hx",33,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_37_get,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","get",0x8207efe8,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.get","pi_xy/imageAbstracts/RawImage.hx",37,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_43_fromTo,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","fromTo",0xe2900d73,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.fromTo","pi_xy/imageAbstracts/RawImage.hx",43,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_52_toFrom,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","toFrom",0xa6458073,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.toFrom","pi_xy/imageAbstracts/RawImage.hx",52,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_61_traceGrid,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","traceGrid",0xee6570bd,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.traceGrid","pi_xy/imageAbstracts/RawImage.hx",61,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_68_imgToString,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","imgToString",0x4cc4e521,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.imgToString","pi_xy/imageAbstracts/RawImage.hx",68,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_73_get_rawImageData,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","get_rawImageData",0xea7eca14,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.get_rawImageData","pi_xy/imageAbstracts/RawImage.hx",73,0x0955155a)
HX_LOCAL_STACK_FRAME(_hx_pos_448a5103eb94c3b0_77_set_rawImageData,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_","set_rawImageData",0x40c0b788,"pi_xy.imageAbstracts._RawImage.RawImage_Impl_.set_rawImageData","pi_xy/imageAbstracts/RawImage.hx",77,0x0955155a)
namespace pi_xy{
namespace imageAbstracts{
namespace _RawImage{

void RawImage_Impl__obj::__construct() { }

Dynamic RawImage_Impl__obj::__CreateEmpty() { return new RawImage_Impl__obj; }

void *RawImage_Impl__obj::_hx_vtable = 0;

Dynamic RawImage_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< RawImage_Impl__obj > _hx_result = new RawImage_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool RawImage_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x32b09f08;
}

 ::pi_xy::ImageStruct RawImage_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_448a5103eb94c3b0_12__new)
HXLINE(  14)		 ::Dynamic imageType = null();
HXDLIN(  14)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  14)		if (::hx::IsNull( imageType )) {
HXLINE(  14)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  14)		::Dynamic this2;
HXDLIN(  14)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  14)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  14)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  14)				{
HXLINE(  14)					b->width = w;
HXDLIN(  14)					b->height = h;
HXDLIN(  14)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  14)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  14)					{
HXLINE(  14)						int len = b->length;
HXDLIN(  14)						int w1 = 0;
HXDLIN(  14)						{
HXLINE(  14)							int _g = 0;
HXDLIN(  14)							int _g1 = b->height;
HXDLIN(  14)							while((_g < _g1)){
HXLINE(  14)								_g = (_g + 1);
HXDLIN(  14)								int y = (_g - 1);
HXDLIN(  14)								{
HXLINE(  14)									int _g2 = 0;
HXDLIN(  14)									int _g3 = b->width;
HXDLIN(  14)									while((_g2 < _g3)){
HXLINE(  14)										_g2 = (_g2 + 1);
HXDLIN(  14)										int x = (_g2 - 1);
HXDLIN(  14)										{
HXLINE(  14)											w1 = (w1 + 1);
HXDLIN(  14)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  14)										{
HXLINE(  14)											w1 = (w1 + 1);
HXDLIN(  14)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  14)										{
HXLINE(  14)											w1 = (w1 + 1);
HXDLIN(  14)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  14)										{
HXLINE(  14)											w1 = (w1 + 1);
HXDLIN(  14)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  14)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  14)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  14)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  14)				{
HXLINE(  14)					a->width = w;
HXDLIN(  14)					a->height = h;
HXDLIN(  14)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  14)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  14)					{
HXLINE(  14)						int _g4 = 0;
HXDLIN(  14)						int _g5 = a->length;
HXDLIN(  14)						while((_g4 < _g5)){
HXLINE(  14)							_g4 = (_g4 + 1);
HXDLIN(  14)							int i = (_g4 - 1);
HXDLIN(  14)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  14)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  14)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  14)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  14)				{
HXLINE(  14)					b1->width = w;
HXDLIN(  14)					b1->height = h;
HXDLIN(  14)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  14)					int size = (b1->length * 4);
HXDLIN(  14)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  14)					{
HXLINE(  14)						int _g6 = 0;
HXDLIN(  14)						int _g7 = b1->length;
HXDLIN(  14)						while((_g6 < _g7)){
HXLINE(  14)							_g6 = (_g6 + 1);
HXDLIN(  14)							int i1 = (_g6 - 1);
HXDLIN(  14)							{
HXLINE(  14)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  14)								bool this4;
HXDLIN(  14)								if ((i1 >= 0)) {
HXLINE(  14)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  14)									this4 = false;
            								}
HXDLIN(  14)								if (this4) {
HXLINE(  14)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  14)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  14)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  14)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  14)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  14)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  14)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  14)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  14)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  14)				{
HXLINE(  14)					v->width = w;
HXDLIN(  14)					v->height = h;
HXDLIN(  14)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  14)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  14)					{
HXLINE(  14)						int _g8 = 0;
HXDLIN(  14)						int _g9 = v->length;
HXDLIN(  14)						while((_g8 < _g9)){
HXLINE(  14)							_g8 = (_g8 + 1);
HXDLIN(  14)							int i2 = (_g8 - 1);
HXDLIN(  14)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  14)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  14)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  14)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  14)				{
HXLINE(  14)					b2->width = w;
HXDLIN(  14)					b2->height = h;
HXDLIN(  14)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  14)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  14)					{
HXLINE(  14)						int len1 = b2->length;
HXDLIN(  14)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  14)						if (::hx::IsNull( d->head )) {
HXLINE(  14)							int _g10 = 0;
HXDLIN(  14)							int _g11 = len1;
HXDLIN(  14)							while((_g10 < _g11)){
HXLINE(  14)								_g10 = (_g10 + 1);
HXDLIN(  14)								int i3 = (_g10 - 1);
HXDLIN(  14)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  14)							int _g12 = 0;
HXDLIN(  14)							int _g13 = len1;
HXDLIN(  14)							while((_g12 < _g13)){
HXLINE(  14)								_g12 = (_g12 + 1);
HXDLIN(  14)								int i4 = (_g12 - 1);
HXDLIN(  14)								{
HXLINE(  14)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  14)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  14)									{
HXLINE(  14)										int _g14 = 0;
HXDLIN(  14)										int _g15 = i4;
HXDLIN(  14)										while((_g14 < _g15)){
HXLINE(  14)											_g14 = (_g14 + 1);
HXDLIN(  14)											int i5 = (_g14 - 1);
HXDLIN(  14)											prev = l;
HXDLIN(  14)											l = l->next;
            										}
            									}
HXDLIN(  14)									if (::hx::IsNull( prev )) {
HXLINE(  14)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  14)										l = null();
            									}
            									else {
HXLINE(  14)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  14)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  14)				this2 = b2;
            			}
            			break;
            		}
HXDLIN(  14)		this1->image = this2;
HXDLIN(  14)		this1->width = w;
HXDLIN(  14)		this1->height = h;
HXDLIN(  14)		this1->imageType = ( (int)(imageType) );
HXLINE(  12)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RawImage_Impl__obj,_new,return )

 ::pi_xy::ImageStruct RawImage_Impl__obj::clone( ::pi_xy::ImageStruct this1){
            	HX_GC_STACKFRAME(&_hx_pos_448a5103eb94c3b0_19_clone)
HXLINE(  20)		 ::pi_xy::ImageStruct here = this1;
HXLINE(  21)		int width = this1->width;
HXDLIN(  21)		int height = this1->height;
HXDLIN(  21)		 ::Dynamic imageType = here->imageType;
HXDLIN(  21)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  21)		if (::hx::IsNull( imageType )) {
HXLINE(  21)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  21)		::Dynamic _hx_tmp;
HXDLIN(  21)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  21)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  21)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  21)				{
HXLINE(  21)					b->width = width;
HXDLIN(  21)					b->height = height;
HXDLIN(  21)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  21)					{
HXLINE(  21)						int len = b->length;
HXDLIN(  21)						int w = 0;
HXDLIN(  21)						{
HXLINE(  21)							int _g = 0;
HXDLIN(  21)							int _g1 = b->height;
HXDLIN(  21)							while((_g < _g1)){
HXLINE(  21)								_g = (_g + 1);
HXDLIN(  21)								int y = (_g - 1);
HXDLIN(  21)								{
HXLINE(  21)									int _g2 = 0;
HXDLIN(  21)									int _g3 = b->width;
HXDLIN(  21)									while((_g2 < _g3)){
HXLINE(  21)										_g2 = (_g2 + 1);
HXDLIN(  21)										int x = (_g2 - 1);
HXDLIN(  21)										{
HXLINE(  21)											w = (w + 1);
HXDLIN(  21)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  21)										{
HXLINE(  21)											w = (w + 1);
HXDLIN(  21)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  21)										{
HXLINE(  21)											w = (w + 1);
HXDLIN(  21)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  21)										{
HXLINE(  21)											w = (w + 1);
HXDLIN(  21)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  21)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  21)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  21)				{
HXLINE(  21)					a->width = width;
HXDLIN(  21)					a->height = height;
HXDLIN(  21)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  21)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)					{
HXLINE(  21)						int _g4 = 0;
HXDLIN(  21)						int _g5 = a->length;
HXDLIN(  21)						while((_g4 < _g5)){
HXLINE(  21)							_g4 = (_g4 + 1);
HXDLIN(  21)							int i = (_g4 - 1);
HXDLIN(  21)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  21)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  21)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  21)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  21)				{
HXLINE(  21)					b1->width = width;
HXDLIN(  21)					b1->height = height;
HXDLIN(  21)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)					int size = (b1->length * 4);
HXDLIN(  21)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  21)					{
HXLINE(  21)						int _g6 = 0;
HXDLIN(  21)						int _g7 = b1->length;
HXDLIN(  21)						while((_g6 < _g7)){
HXLINE(  21)							_g6 = (_g6 + 1);
HXDLIN(  21)							int i1 = (_g6 - 1);
HXDLIN(  21)							{
HXLINE(  21)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  21)								bool _hx_tmp1;
HXDLIN(  21)								if ((i1 >= 0)) {
HXLINE(  21)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  21)									_hx_tmp1 = false;
            								}
HXDLIN(  21)								if (_hx_tmp1) {
HXLINE(  21)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  21)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  21)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  21)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  21)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  21)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  21)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  21)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  21)				{
HXLINE(  21)					v->width = width;
HXDLIN(  21)					v->height = height;
HXDLIN(  21)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  21)					{
HXLINE(  21)						int _g8 = 0;
HXDLIN(  21)						int _g9 = v->length;
HXDLIN(  21)						while((_g8 < _g9)){
HXLINE(  21)							_g8 = (_g8 + 1);
HXDLIN(  21)							int i2 = (_g8 - 1);
HXDLIN(  21)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  21)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  21)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  21)				{
HXLINE(  21)					b2->width = width;
HXDLIN(  21)					b2->height = height;
HXDLIN(  21)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  21)					{
HXLINE(  21)						int len1 = b2->length;
HXDLIN(  21)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  21)						if (::hx::IsNull( d->head )) {
HXLINE(  21)							int _g10 = 0;
HXDLIN(  21)							int _g11 = len1;
HXDLIN(  21)							while((_g10 < _g11)){
HXLINE(  21)								_g10 = (_g10 + 1);
HXDLIN(  21)								int i3 = (_g10 - 1);
HXDLIN(  21)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  21)							int _g12 = 0;
HXDLIN(  21)							int _g13 = len1;
HXDLIN(  21)							while((_g12 < _g13)){
HXLINE(  21)								_g12 = (_g12 + 1);
HXDLIN(  21)								int i4 = (_g12 - 1);
HXDLIN(  21)								{
HXLINE(  21)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  21)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  21)									{
HXLINE(  21)										int _g14 = 0;
HXDLIN(  21)										int _g15 = i4;
HXDLIN(  21)										while((_g14 < _g15)){
HXLINE(  21)											_g14 = (_g14 + 1);
HXDLIN(  21)											int i5 = (_g14 - 1);
HXDLIN(  21)											prev = l;
HXDLIN(  21)											l = l->next;
            										}
            									}
HXDLIN(  21)									if (::hx::IsNull( prev )) {
HXLINE(  21)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  21)										l = null();
            									}
            									else {
HXLINE(  21)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  21)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  21)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  21)		this2->image = _hx_tmp;
HXDLIN(  21)		this2->width = width;
HXDLIN(  21)		this2->height = height;
HXDLIN(  21)		this2->imageType = ( (int)(imageType) );
HXDLIN(  21)		 ::pi_xy::ImageStruct cloned = this2;
HXLINE(  22)		{
HXLINE(  22)			int _g16 = 0;
HXDLIN(  22)			int _g17 = ( (int)(this1->image->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic)) );
HXDLIN(  22)			while((_g16 < _g17)){
HXLINE(  22)				_g16 = (_g16 + 1);
HXDLIN(  22)				int i6 = (_g16 - 1);
HXDLIN(  22)				{
HXLINE(  22)					::Dynamic this4 = cloned->image;
HXDLIN(  22)					::iterMagic::Iimg_obj::set(this4,i6,::iterMagic::Iimg_obj::get(this1->image,i6));
            				}
            			}
            		}
HXDLIN(  22)		return cloned;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(RawImage_Impl__obj,clone,return )

int RawImage_Impl__obj::set( ::pi_xy::ImageStruct this1,int index,int value){
            	HX_STACKFRAME(&_hx_pos_448a5103eb94c3b0_33_set)
HXDLIN(  33)		return ::iterMagic::Iimg_obj::set(this1->image,index,value);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(RawImage_Impl__obj,set,return )

int RawImage_Impl__obj::get( ::pi_xy::ImageStruct this1,int index){
            	HX_STACKFRAME(&_hx_pos_448a5103eb94c3b0_37_get)
HXDLIN(  37)		return ::iterMagic::Iimg_obj::get(this1->image,index);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RawImage_Impl__obj,get,return )

 ::pi_xy::ImageStruct RawImage_Impl__obj::fromTo( ::pi_xy::ImageStruct a, ::pi_xy::ImageStruct b){
            	HX_STACKFRAME(&_hx_pos_448a5103eb94c3b0_43_fromTo)
HXLINE(  44)		{
HXLINE(  44)			int _g = 0;
HXDLIN(  44)			int _g1 = ( (int)(b->image->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic)) );
HXDLIN(  44)			while((_g < _g1)){
HXLINE(  44)				_g = (_g + 1);
HXDLIN(  44)				int i = (_g - 1);
HXDLIN(  44)				{
HXLINE(  44)					::Dynamic this1 = b->image;
HXDLIN(  44)					::iterMagic::Iimg_obj::set(this1,i,::iterMagic::Iimg_obj::get(a->image,i));
            				}
            			}
            		}
HXLINE(  45)		return b;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RawImage_Impl__obj,fromTo,return )

 ::pi_xy::ImageStruct RawImage_Impl__obj::toFrom( ::pi_xy::ImageStruct a, ::pi_xy::ImageStruct b){
            	HX_STACKFRAME(&_hx_pos_448a5103eb94c3b0_52_toFrom)
HXLINE(  53)		{
HXLINE(  53)			int _g = 0;
HXDLIN(  53)			int _g1 = ( (int)(b->image->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic)) );
HXDLIN(  53)			while((_g < _g1)){
HXLINE(  53)				_g = (_g + 1);
HXDLIN(  53)				int i = (_g - 1);
HXDLIN(  53)				{
HXLINE(  53)					::Dynamic this1 = a->image;
HXDLIN(  53)					::iterMagic::Iimg_obj::set(this1,i,::iterMagic::Iimg_obj::get(b->image,i));
            				}
            			}
            		}
HXLINE(  54)		return a;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RawImage_Impl__obj,toFrom,return )

void RawImage_Impl__obj::traceGrid( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_448a5103eb94c3b0_61_traceGrid)
HXDLIN(  61)		::Dynamic this2 = this1->image;
HXDLIN(  61)		int count = 0;
HXDLIN(  61)		::String str = HX_("[ ",65,4f,00,00);
HXDLIN(  61)		{
HXDLIN(  61)			int _g = 0;
HXDLIN(  61)			int _g1 = ( (int)(this2->__Field(HX_("height",e7,07,4c,02),::hx::paccDynamic)) );
HXDLIN(  61)			while((_g < _g1)){
HXDLIN(  61)				_g = (_g + 1);
HXDLIN(  61)				int y = (_g - 1);
HXDLIN(  61)				{
HXDLIN(  61)					int _g2 = 0;
HXDLIN(  61)					int _g3 = ( (int)(this2->__Field(HX_("width",06,b6,62,ca),::hx::paccDynamic)) );
HXDLIN(  61)					while((_g2 < _g3)){
HXDLIN(  61)						_g2 = (_g2 + 1);
HXDLIN(  61)						int x = (_g2 - 1);
HXDLIN(  61)						count = (count + 1);
HXDLIN(  61)						str = (str + (::iterMagic::Iimg_obj::get(this2,(count - 1)) + HX_(", ",74,26,00,00)));
            					}
            				}
HXDLIN(  61)				str = str.substr(0,(str.length - 2));
HXDLIN(  61)				::haxe::Log_obj::trace((str + HX_(" ]",3d,1c,00,00)),::hx::SourceInfo(HX_("iterMagic/Img.hx",d5,af,99,88),650,HX_("iterMagic._Img.ImgMulti_Impl_",07,ef,b8,30),HX_("traceGrid",eb,b7,8e,bb)));
HXDLIN(  61)				str = HX_("[ ",65,4f,00,00);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(RawImage_Impl__obj,traceGrid,(void))

::String RawImage_Impl__obj::imgToString( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_448a5103eb94c3b0_68_imgToString)
HXDLIN(  68)		::Dynamic this2 = this1->image;
HXDLIN(  68)		::String str = HX_("[",5b,00,00,00);
HXDLIN(  68)		{
HXDLIN(  68)			int _g = 0;
HXDLIN(  68)			int _g1 = ( (int)(this2->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic)) );
HXDLIN(  68)			while((_g < _g1)){
HXDLIN(  68)				_g = (_g + 1);
HXDLIN(  68)				int i = (_g - 1);
HXDLIN(  68)				str = (str + (::Std_obj::string(::iterMagic::Iimg_obj::get(this2,i)) + HX_(",",2c,00,00,00)));
            			}
            		}
HXDLIN(  68)		return (str.substr(0,(str.length - 1)) + HX_("]",5d,00,00,00));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(RawImage_Impl__obj,imgToString,return )

 ::iterMagic::RawImageData RawImage_Impl__obj::get_rawImageData( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_448a5103eb94c3b0_73_get_rawImageData)
HXDLIN(  73)		return ::iterMagic::Iimg_obj::getRaw(this1->image);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(RawImage_Impl__obj,get_rawImageData,return )

 ::iterMagic::RawImageData RawImage_Impl__obj::set_rawImageData( ::pi_xy::ImageStruct this1, ::iterMagic::RawImageData d){
            	HX_STACKFRAME(&_hx_pos_448a5103eb94c3b0_77_set_rawImageData)
HXDLIN(  77)		return ::iterMagic::Iimg_obj::setRaw(this1->image,d);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RawImage_Impl__obj,set_rawImageData,return )


RawImage_Impl__obj::RawImage_Impl__obj()
{
}

bool RawImage_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"set") ) { outValue = set_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get") ) { outValue = get_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clone") ) { outValue = clone_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"fromTo") ) { outValue = fromTo_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toFrom") ) { outValue = toFrom_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"traceGrid") ) { outValue = traceGrid_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"imgToString") ) { outValue = imgToString_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_rawImageData") ) { outValue = get_rawImageData_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"set_rawImageData") ) { outValue = set_rawImageData_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *RawImage_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *RawImage_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class RawImage_Impl__obj::__mClass;

static ::String RawImage_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("clone",5d,13,63,48),
	HX_("set",a2,9b,57,00),
	HX_("get",96,80,4e,00),
	HX_("fromTo",85,9d,c6,b5),
	HX_("toFrom",85,10,7c,79),
	HX_("traceGrid",eb,b7,8e,bb),
	HX_("imgToString",cf,d3,30,ac),
	HX_("get_rawImageData",a6,e4,2c,49),
	HX_("set_rawImageData",1a,d2,6e,9f),
	::String(null())
};

void RawImage_Impl__obj::__register()
{
	RawImage_Impl__obj _hx_dummy;
	RawImage_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._RawImage.RawImage_Impl_",c0,3e,eb,ac);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &RawImage_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(RawImage_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< RawImage_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RawImage_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RawImage_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _RawImage
