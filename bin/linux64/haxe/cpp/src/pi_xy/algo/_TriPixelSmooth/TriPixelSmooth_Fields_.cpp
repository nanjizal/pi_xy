// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo__TriPixelSmooth_TriPixelSmooth_Fields_
#include <pi_xy/algo/_TriPixelSmooth/TriPixelSmooth_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_132148ab73c7d3b6_54_quadPentagonBarycentric,"pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_","quadPentagonBarycentric",0xeb441093,"pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_.quadPentagonBarycentric","pi_xy/algo/TriPixelSmooth.hx",54,0x991fb761)
HX_LOCAL_STACK_FRAME(_hx_pos_132148ab73c7d3b6_68_triPentagonBarycentricBottom,"pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_","triPentagonBarycentricBottom",0x2f277cc2,"pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_.triPentagonBarycentricBottom","pi_xy/algo/TriPixelSmooth.hx",68,0x991fb761)
HX_LOCAL_STACK_FRAME(_hx_pos_132148ab73c7d3b6_96_triPentagonBarycentricTop,"pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_","triPentagonBarycentricTop",0x3327d45e,"pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_.triPentagonBarycentricTop","pi_xy/algo/TriPixelSmooth.hx",96,0x991fb761)
HX_LOCAL_STACK_FRAME(_hx_pos_132148ab73c7d3b6_128_triPentagonBarycentic,"pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_","triPentagonBarycentic",0xbaf8e88f,"pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_.triPentagonBarycentic","pi_xy/algo/TriPixelSmooth.hx",128,0x991fb761)
namespace pi_xy{
namespace algo{
namespace _TriPixelSmooth{

void TriPixelSmooth_Fields__obj::__construct() { }

Dynamic TriPixelSmooth_Fields__obj::__CreateEmpty() { return new TriPixelSmooth_Fields__obj; }

void *TriPixelSmooth_Fields__obj::_hx_vtable = 0;

Dynamic TriPixelSmooth_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TriPixelSmooth_Fields__obj > _hx_result = new TriPixelSmooth_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool TriPixelSmooth_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0944e486;
}

 ::pi_xy::algo::HitQuad TriPixelSmooth_Fields__obj::quadPentagonBarycentric( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,int color,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_132148ab73c7d3b6_54_quadPentagonBarycentric)
HXLINE(  57)		Float bx1 = bx;
HXDLIN(  57)		Float by1 = by;
HXDLIN(  57)		Float cx1 = dx;
HXDLIN(  57)		Float cy1 = dy;
HXDLIN(  57)		int color1 = color;
HXDLIN(  57)		bool hasUndo = true;
HXDLIN(  57)		bool softAB = true;
HXDLIN(  57)		bool softBC = false;
HXDLIN(  57)		bool softCA = true;
HXDLIN(  57)		bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  57)		if (!(adjustWinding)) {
HXLINE(  57)			Float bx_ = bx1;
HXDLIN(  57)			Float by_ = by1;
HXLINE(  78)			bx1 = cx1;
HXLINE(  79)			by1 = cy1;
HXLINE(  80)			cx1 = bx_;
HXLINE(  81)			cy1 = by_;
HXLINE(  83)			color1 = -1309128;
            		}
HXLINE(  57)		int a = ((color1 >> 24) & 255);
HXDLIN(  57)		int r = ((color1 >> 16) & 255);
HXDLIN(  57)		int g = ((color1 >> 8) & 255);
HXDLIN(  57)		int b = (color1 & 255);
HXDLIN(  57)		Float bcx = (bx1 - cx1);
HXDLIN(  57)		Float bcy = (by1 - cy1);
HXDLIN(  57)		Float acx = (ax - cx1);
HXDLIN(  57)		Float acy = (ay - cy1);
HXDLIN(  57)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  57)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  57)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  57)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  57)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  57)		if ((ax > bx1)) {
HXLINE(  57)			if ((ax > cx1)) {
HXLINE(  57)				int min;
HXDLIN(  57)				if ((bx1 > cx1)) {
HXLINE(  57)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXLINE(  57)					min = ::Math_obj::floor(bx1);
            				}
HXDLIN(  57)				int ii_min = min;
HXDLIN(  57)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  57)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE(  57)				int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  57)				int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  57)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE(  57)			if ((bx1 > cx1)) {
HXLINE(  57)				int min1;
HXDLIN(  57)				if ((ax > cx1)) {
HXLINE(  57)					min1 = ::Math_obj::floor(cx1);
            				}
            				else {
HXLINE(  57)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN(  57)				int ii_min2 = min1;
HXDLIN(  57)				int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  57)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE(  57)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  57)				int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  57)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN(  57)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  57)		if ((ay > by1)) {
HXLINE(  57)			if ((ay > cy1)) {
HXLINE(  57)				int min2;
HXDLIN(  57)				if ((by1 > cy1)) {
HXLINE(  57)					min2 = ::Math_obj::floor(cy1);
            				}
            				else {
HXLINE(  57)					min2 = ::Math_obj::floor(by1);
            				}
HXDLIN(  57)				int ii_min4 = min2;
HXDLIN(  57)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  57)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE(  57)				int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  57)				int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  57)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE(  57)			if ((by1 > cy1)) {
HXLINE(  57)				int min3;
HXDLIN(  57)				if ((ay > cy1)) {
HXLINE(  57)					min3 = ::Math_obj::floor(cy1);
            				}
            				else {
HXLINE(  57)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN(  57)				int ii_min6 = min3;
HXDLIN(  57)				int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  57)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE(  57)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  57)				int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  57)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN(  57)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  57)		if (hasUndo) {
HXLINE(  57)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  57)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  57)			 ::Dynamic imageType = null();
HXDLIN(  57)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  57)			if (::hx::IsNull( imageType )) {
HXDLIN(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  57)			::Dynamic undoImage1;
HXDLIN(  57)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE(  57)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  57)					 ::iterMagic::BytesImg b1 = byt;
HXDLIN(  57)					{
HXLINE(  57)						b1->width = width;
HXDLIN(  57)						b1->height = height;
HXDLIN(  57)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  57)						b1->data = ::haxe::io::Bytes_obj::alloc((b1->length * 4));
HXDLIN(  57)						{
HXLINE(  57)							int len = b1->length;
HXDLIN(  57)							int w = 0;
HXDLIN(  57)							{
HXLINE(  57)								int _g = 0;
HXDLIN(  57)								int _g1 = b1->height;
HXDLIN(  57)								while((_g < _g1)){
HXLINE(  57)									_g = (_g + 1);
HXDLIN(  57)									int y = (_g - 1);
HXDLIN(  57)									{
HXLINE(  57)										int _g2 = 0;
HXDLIN(  57)										int _g3 = b1->width;
HXDLIN(  57)										while((_g2 < _g3)){
HXLINE(  57)											_g2 = (_g2 + 1);
HXDLIN(  57)											int x = (_g2 - 1);
HXDLIN(  57)											{
HXLINE(  57)												w = (w + 1);
HXDLIN(  57)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  57)											{
HXLINE(  57)												w = (w + 1);
HXDLIN(  57)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  57)											{
HXLINE(  57)												w = (w + 1);
HXDLIN(  57)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  57)											{
HXLINE(  57)												w = (w + 1);
HXDLIN(  57)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  57)					undoImage1 = b1;
            				}
            				break;
            				case (int)1: {
HXLINE(  57)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  57)					 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN(  57)					{
HXLINE(  57)						a1->width = width;
HXDLIN(  57)						a1->height = height;
HXDLIN(  57)						a1->data = ::Array_obj< int >::__new(0);
HXDLIN(  57)						a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  57)						{
HXLINE(  57)							int _g4 = 0;
HXDLIN(  57)							int _g5 = a1->length;
HXDLIN(  57)							while((_g4 < _g5)){
HXLINE(  57)								_g4 = (_g4 + 1);
HXDLIN(  57)								int i = (_g4 - 1);
HXDLIN(  57)								a1->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  57)					undoImage1 = a1;
            				}
            				break;
            				case (int)2: {
HXLINE(  57)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  57)					 ::iterMagic::U32ArrImg b2 = u32a;
HXDLIN(  57)					{
HXLINE(  57)						b2->width = width;
HXDLIN(  57)						b2->height = height;
HXDLIN(  57)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  57)						int size = (b2->length * 4);
HXDLIN(  57)						b2->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  57)						{
HXLINE(  57)							int _g6 = 0;
HXDLIN(  57)							int _g7 = b2->length;
HXDLIN(  57)							while((_g6 < _g7)){
HXLINE(  57)								_g6 = (_g6 + 1);
HXDLIN(  57)								int i1 = (_g6 - 1);
HXDLIN(  57)								{
HXLINE(  57)									 ::haxe::io::ArrayBufferViewImpl this2 = b2->data;
HXDLIN(  57)									bool undoImage2;
HXDLIN(  57)									if ((i1 >= 0)) {
HXLINE(  57)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  57)										undoImage2 = false;
            									}
HXDLIN(  57)									if (undoImage2) {
HXLINE(  57)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  57)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  57)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  57)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  57)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  57)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  57)					undoImage1 = b2;
            				}
            				break;
            				case (int)3: {
HXLINE(  57)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  57)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  57)					{
HXLINE(  57)						v->width = width;
HXDLIN(  57)						v->height = height;
HXDLIN(  57)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  57)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  57)						{
HXLINE(  57)							int _g8 = 0;
HXDLIN(  57)							int _g9 = v->length;
HXDLIN(  57)							while((_g8 < _g9)){
HXLINE(  57)								_g8 = (_g8 + 1);
HXDLIN(  57)								int i2 = (_g8 - 1);
HXDLIN(  57)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  57)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE(  57)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  57)					 ::iterMagic::StackIntImg b3 = sInt;
HXDLIN(  57)					{
HXLINE(  57)						b3->width = width;
HXDLIN(  57)						b3->height = height;
HXDLIN(  57)						b3->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  57)						b3->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  57)						{
HXLINE(  57)							int len1 = b3->length;
HXDLIN(  57)							 ::haxe::ds::GenericStack_Int d = b3->data;
HXDLIN(  57)							if (::hx::IsNull( d->head )) {
HXLINE(  57)								int _g10 = 0;
HXDLIN(  57)								int _g11 = len1;
HXDLIN(  57)								while((_g10 < _g11)){
HXLINE(  57)									_g10 = (_g10 + 1);
HXDLIN(  57)									int i3 = (_g10 - 1);
HXDLIN(  57)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE(  57)								int _g12 = 0;
HXDLIN(  57)								int _g13 = len1;
HXDLIN(  57)								while((_g12 < _g13)){
HXLINE(  57)									_g12 = (_g12 + 1);
HXDLIN(  57)									int i4 = (_g12 - 1);
HXDLIN(  57)									{
HXLINE(  57)										 ::haxe::ds::GenericCell_Int l = b3->data->head;
HXDLIN(  57)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  57)										{
HXLINE(  57)											int _g14 = 0;
HXDLIN(  57)											int _g15 = i4;
HXDLIN(  57)											while((_g14 < _g15)){
HXLINE(  57)												_g14 = (_g14 + 1);
HXDLIN(  57)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  57)										if (::hx::IsNull( prev )) {
HXLINE(  57)											b3->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  57)											l = null();
            										}
            										else {
HXLINE(  57)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  57)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  57)					undoImage1 = b3;
            				}
            				break;
            			}
HXDLIN(  57)			this1->image = undoImage1;
HXDLIN(  57)			this1->width = width;
HXDLIN(  57)			this1->height = height;
HXDLIN(  57)			this1->imageType = ( (int)(imageType) );
HXDLIN(  57)			undoImage = this1;
HXDLIN(  57)			{
HXLINE(  57)				int rectLeft = xIter3->start;
HXDLIN(  57)				int rectTop = yIter3->start;
HXDLIN(  57)				int rectRight = xIter3->max;
HXDLIN(  57)				bool forceClear = false;
HXDLIN(  57)				{
HXLINE(  57)					int _g16 = rectTop;
HXDLIN(  57)					int _g17 = yIter3->max;
HXDLIN(  57)					while((_g16 < _g17)){
HXLINE(  57)						_g16 = (_g16 + 1);
HXDLIN(  57)						int dy1 = (_g16 - 1);
HXDLIN(  57)						{
HXLINE(  57)							int _g18 = rectLeft;
HXDLIN(  57)							int _g19 = rectRight;
HXDLIN(  57)							while((_g18 < _g19)){
HXLINE(  57)								_g18 = (_g18 + 1);
HXDLIN(  57)								int dx1 = (_g18 - 1);
HXDLIN(  57)								::Dynamic this3 = pixelImage->image;
HXDLIN(  57)								int index;
HXDLIN(  57)								if (pixelImage->useVirtualPos) {
HXLINE(  57)									index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  57)									index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            								}
HXDLIN(  57)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  57)								int col;
HXDLIN(  57)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  57)									col = c;
            								}
HXDLIN(  57)								bool _hx_tmp;
HXDLIN(  57)								if (pixelImage->useMask) {
HXLINE(  57)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE(  57)									_hx_tmp = false;
            								}
HXDLIN(  57)								if (_hx_tmp) {
HXLINE(  57)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN(  57)									::Dynamic this5 = this4->image;
HXDLIN(  57)									int index1;
HXDLIN(  57)									if (this4->useVirtualPos) {
HXLINE(  57)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            									}
            									else {
HXLINE(  57)										index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            									}
HXDLIN(  57)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  57)									int v1;
HXDLIN(  57)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE(  57)										v1 = c1;
            									}
HXDLIN(  57)									int maskPixel = v1;
HXDLIN(  57)									int this6 = col;
HXDLIN(  57)									if ((maskPixel == 0)) {
HXLINE(  57)										col = this6;
            									}
            									else {
HXLINE(  57)										Float m0;
HXDLIN(  57)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  57)										if ((this7 == 0)) {
HXLINE(  57)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float m1;
HXDLIN(  57)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  57)										if ((this8 == 0)) {
HXLINE(  57)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float m2;
HXDLIN(  57)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  57)										if ((this9 == 0)) {
HXLINE(  57)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float m3;
HXDLIN(  57)										int this10 = (maskPixel & 255);
HXDLIN(  57)										if ((this10 == 0)) {
HXLINE(  57)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  57)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  57)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  57)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  57)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  57)								if ((col != 0)) {
HXLINE(  57)									int x1 = (dx1 - rectLeft);
HXDLIN(  57)									int y1 = (dy1 - rectTop);
HXDLIN(  57)									int c2 = col;
HXDLIN(  57)									bool _hx_tmp1;
HXDLIN(  57)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  57)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE(  57)										_hx_tmp1 = false;
            									}
HXDLIN(  57)									if (_hx_tmp1) {
HXLINE(  57)										int location;
HXDLIN(  57)										if (undoImage->useVirtualPos) {
HXLINE(  57)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE(  57)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  57)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  57)										int this12;
HXDLIN(  57)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE(  57)											this12 = this11;
            										}
HXDLIN(  57)										Float a11;
HXDLIN(  57)										int this13 = ((this12 >> 24) & 255);
HXDLIN(  57)										if ((this13 == 0)) {
HXLINE(  57)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											a11 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float r1;
HXDLIN(  57)										int this14 = ((this12 >> 16) & 255);
HXDLIN(  57)										if ((this14 == 0)) {
HXLINE(  57)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float g1;
HXDLIN(  57)										int this15 = ((this12 >> 8) & 255);
HXDLIN(  57)										if ((this15 == 0)) {
HXLINE(  57)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float b11;
HXDLIN(  57)										int this16 = (this12 & 255);
HXDLIN(  57)										if ((this16 == 0)) {
HXLINE(  57)											b11 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float a2;
HXDLIN(  57)										int this17 = ((col >> 24) & 255);
HXDLIN(  57)										if ((this17 == 0)) {
HXLINE(  57)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float r2;
HXDLIN(  57)										int this18 = ((col >> 16) & 255);
HXDLIN(  57)										if ((this18 == 0)) {
HXLINE(  57)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float g2;
HXDLIN(  57)										int this19 = ((col >> 8) & 255);
HXDLIN(  57)										if ((this19 == 0)) {
HXLINE(  57)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float b21;
HXDLIN(  57)										int this20 = (col & 255);
HXDLIN(  57)										if ((this20 == 0)) {
HXLINE(  57)											b21 = ((Float)0.);
            										}
            										else {
HXLINE(  57)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  57)										Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  57)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  57)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  57)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  57)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  57)										int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  57)										{
HXLINE(  57)											int _hx_tmp2;
HXDLIN(  57)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  57)												_hx_tmp2 = blended;
            											}
HXDLIN(  57)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE(  57)										::Dynamic this21 = undoImage->image;
HXDLIN(  57)										int index2;
HXDLIN(  57)										if (undoImage->useVirtualPos) {
HXLINE(  57)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE(  57)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  57)										int _hx_tmp3;
HXDLIN(  57)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE(  57)											_hx_tmp3 = c2;
            										}
HXDLIN(  57)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE(  57)									if (forceClear) {
HXLINE(  57)										::Dynamic this22 = undoImage->image;
HXDLIN(  57)										int x2 = (dx1 - rectLeft);
HXDLIN(  57)										int y2 = (dy1 - rectTop);
HXDLIN(  57)										int index3;
HXDLIN(  57)										if (undoImage->useVirtualPos) {
HXLINE(  57)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE(  57)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(  57)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  57)		Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  57)		Float sx = (cy1 - ay);
HXDLIN(  57)		Float sy = (ax - cx1);
HXDLIN(  57)		Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  57)		Float tx = (ay - by1);
HXDLIN(  57)		Float ty = (bx1 - ax);
HXDLIN(  57)		Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  57)		Float s = ((Float)0.);
HXDLIN(  57)		Float t = ((Float)0.);
HXDLIN(  57)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(5) ));
HXDLIN(  57)		Float omega = (theta / ( (Float)(3) ));
HXDLIN(  57)		Float delta = ((Float)0.7071);
HXDLIN(  57)		Float x0 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  57)		Float y0 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  57)		omega = (omega + theta);
HXDLIN(  57)		Float x11 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  57)		Float y11 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  57)		omega = (omega + theta);
HXDLIN(  57)		Float x21 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  57)		Float y21 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  57)		omega = (omega + theta);
HXDLIN(  57)		Float x3 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  57)		Float y3 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  57)		omega = (omega + theta);
HXDLIN(  57)		Float x4 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  57)		Float y4 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  57)		Float sxx = ((Float)0.);
HXDLIN(  57)		Float txx = ((Float)0.);
HXDLIN(  57)		Float sxx0 = ((Float)0.);
HXDLIN(  57)		Float sxx1 = ((Float)0.);
HXDLIN(  57)		Float sxx2 = ((Float)0.);
HXDLIN(  57)		Float sxx3 = ((Float)0.);
HXDLIN(  57)		Float sxx4 = ((Float)0.);
HXDLIN(  57)		Float txx0 = ((Float)0.);
HXDLIN(  57)		Float txx1 = ((Float)0.);
HXDLIN(  57)		Float txx2 = ((Float)0.);
HXDLIN(  57)		Float txx3 = ((Float)0.);
HXDLIN(  57)		Float txx4 = ((Float)0.);
HXDLIN(  57)		Float aSum = ((Float)0.);
HXDLIN(  57)		{
HXLINE(  57)			int _g_min = xIter3->start;
HXDLIN(  57)			int _g_max = xIter3->max;
HXDLIN(  57)			while((_g_min < _g_max)){
HXLINE(  57)				_g_min = (_g_min + 1);
HXDLIN(  57)				int px = (_g_min - 1);
HXDLIN(  57)				Float pcx = (( (Float)(px) ) - cx1);
HXLINE( 223)				sxx = (sx * ( (Float)(px) ));
HXLINE( 224)				txx = (tx * ( (Float)(px) ));
HXLINE( 226)				sxx0 = (sx * (px + x0));
HXLINE( 227)				sxx1 = (sx * (px + x11));
HXLINE( 228)				sxx2 = (sx * (px + x21));
HXLINE( 229)				sxx3 = (sx * (px + x3));
HXLINE( 230)				sxx4 = (sx * (px + x4));
HXLINE( 231)				txx0 = (tx * (px + x0));
HXLINE( 232)				txx1 = (tx * (px + x11));
HXLINE( 233)				txx2 = (tx * (px + x21));
HXLINE( 234)				txx3 = (tx * (px + x3));
HXLINE( 235)				txx4 = (tx * (px + x4));
HXLINE(  57)				{
HXLINE(  57)					int _g_min1 = yIter3->start;
HXDLIN(  57)					int _g_max1 = yIter3->max;
HXDLIN(  57)					while((_g_min1 < _g_max1)){
HXLINE(  57)						_g_min1 = (_g_min1 + 1);
HXDLIN(  57)						int py = (_g_min1 - 1);
HXDLIN(  57)						Float pcy = (( (Float)(py) ) - cy1);
HXDLIN(  57)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  57)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  57)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  57)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  57)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  57)						Float min4;
HXDLIN(  57)						if ((ratioA < ratioB)) {
HXLINE(  57)							min4 = ratioA;
            						}
            						else {
HXLINE(  57)							min4 = ratioB;
            						}
HXDLIN(  57)						if (!((min4 < ratioC))) {
HXLINE(  57)							min4 = ratioC;
            						}
HXDLIN(  57)						bool pentagonSampling;
HXDLIN(  57)						if (softAB) {
HXLINE(  57)							if (softBC) {
HXLINE(  57)								if (softCA) {
HXLINE(  57)									pentagonSampling = true;
            								}
            								else {
HXLINE(  57)									if ((min4 != ratioB)) {
HXLINE(  57)										pentagonSampling = (min4 == ratioC);
            									}
            									else {
HXLINE(  57)										pentagonSampling = true;
            									}
            								}
            							}
            							else {
HXLINE(  57)								if (softCA) {
HXLINE(  57)									if ((min4 != ratioA)) {
HXLINE(  57)										pentagonSampling = (min4 == ratioC);
            									}
            									else {
HXLINE(  57)										pentagonSampling = true;
            									}
            								}
            								else {
HXLINE(  57)									pentagonSampling = (min4 == ratioC);
            								}
            							}
            						}
            						else {
HXLINE(  57)							if (softBC) {
HXLINE(  57)								if (softCA) {
HXLINE(  57)									if ((min4 != ratioA)) {
HXLINE(  57)										pentagonSampling = (min4 == ratioB);
            									}
            									else {
HXLINE(  57)										pentagonSampling = true;
            									}
            								}
            								else {
HXLINE(  57)									pentagonSampling = (min4 == ratioB);
            								}
            							}
            							else {
HXLINE(  57)								if (softCA) {
HXLINE(  57)									pentagonSampling = (min4 == ratioA);
            								}
            								else {
HXLINE(  57)									pentagonSampling = false;
            								}
            							}
            						}
HXDLIN(  57)						if (pentagonSampling) {
HXLINE( 276)							aSum = ((Float)0.);
HXLINE( 277)							s = ((s0 + sxx0) + (sy * (py + y0)));
HXLINE( 278)							t = ((t0 + txx0) + (ty * (py + y0)));
HXLINE(  57)							bool _hx_tmp4;
HXDLIN(  57)							if (!((s <= 0))) {
HXLINE(  57)								_hx_tmp4 = (t <= 0);
            							}
            							else {
HXLINE(  57)								_hx_tmp4 = true;
            							}
HXDLIN(  57)							if (!(_hx_tmp4)) {
HXLINE(  57)								if (((s + t) < A)) {
HXLINE(  57)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 280)							s = ((s0 + sxx1) + (sy * (py + y11)));
HXLINE( 281)							t = ((t0 + txx1) + (ty * (py + y11)));
HXLINE(  57)							bool _hx_tmp5;
HXDLIN(  57)							if (!((s <= 0))) {
HXLINE(  57)								_hx_tmp5 = (t <= 0);
            							}
            							else {
HXLINE(  57)								_hx_tmp5 = true;
            							}
HXDLIN(  57)							if (!(_hx_tmp5)) {
HXLINE(  57)								if (((s + t) < A)) {
HXLINE(  57)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 283)							s = ((s0 + sxx2) + (sy * (py + y21)));
HXLINE( 284)							t = ((t0 + txx2) + (ty * (py + y21)));
HXLINE(  57)							bool _hx_tmp6;
HXDLIN(  57)							if (!((s <= 0))) {
HXLINE(  57)								_hx_tmp6 = (t <= 0);
            							}
            							else {
HXLINE(  57)								_hx_tmp6 = true;
            							}
HXDLIN(  57)							if (!(_hx_tmp6)) {
HXLINE(  57)								if (((s + t) < A)) {
HXLINE(  57)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 286)							s = ((s0 + sxx3) + (sy * (py + y3)));
HXLINE( 287)							t = ((t0 + txx3) + (ty * (py + y3)));
HXLINE(  57)							bool _hx_tmp7;
HXDLIN(  57)							if (!((s <= 0))) {
HXLINE(  57)								_hx_tmp7 = (t <= 0);
            							}
            							else {
HXLINE(  57)								_hx_tmp7 = true;
            							}
HXDLIN(  57)							if (!(_hx_tmp7)) {
HXLINE(  57)								if (((s + t) < A)) {
HXLINE(  57)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 289)							s = ((s0 + sxx4) + (sy * (py + y4)));
HXLINE( 290)							t = ((t0 + txx4) + (ty * (py + y4)));
HXLINE(  57)							bool _hx_tmp8;
HXDLIN(  57)							if (!((s <= 0))) {
HXLINE(  57)								_hx_tmp8 = (t <= 0);
            							}
            							else {
HXLINE(  57)								_hx_tmp8 = true;
            							}
HXDLIN(  57)							if (!(_hx_tmp8)) {
HXLINE(  57)								if (((s + t) < A)) {
HXLINE(  57)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXDLIN(  57)							if ((aSum != ((Float)0.))) {
HXLINE(  57)								int a5;
HXDLIN(  57)								if ((aSum > ((Float)0.9))) {
HXLINE(  57)									a5 = a;
            								}
            								else {
HXLINE(  57)									int i6 = ::Std_obj::_hx_int((( (Float)(a) ) * aSum));
HXDLIN(  57)									if ((i6 > 255)) {
HXLINE(  24)										i6 = 255;
            									}
HXLINE(  57)									if ((i6 < 0)) {
HXLINE(  25)										i6 = 0;
            									}
HXLINE(  57)									a5 = i6;
            								}
HXDLIN(  57)								int location1;
HXDLIN(  57)								if (pixelImage->useVirtualPos) {
HXLINE(  57)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  57)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN(  57)								bool _hx_tmp9;
HXDLIN(  57)								if (pixelImage->transparent) {
HXLINE(  57)									_hx_tmp9 = (a5 < 254);
            								}
            								else {
HXLINE(  57)									_hx_tmp9 = false;
            								}
HXDLIN(  57)								if (_hx_tmp9) {
HXLINE(  57)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN(  57)									int old;
HXDLIN(  57)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE(  57)										old = this23;
            									}
HXDLIN(  57)									int rhs = ((((a5 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  57)									Float a12;
HXDLIN(  57)									int this24 = ((old >> 24) & 255);
HXDLIN(  57)									if ((this24 == 0)) {
HXLINE(  57)										a12 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										a12 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float r11;
HXDLIN(  57)									int this25 = ((old >> 16) & 255);
HXDLIN(  57)									if ((this25 == 0)) {
HXLINE(  57)										r11 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float g11;
HXDLIN(  57)									int this26 = ((old >> 8) & 255);
HXDLIN(  57)									if ((this26 == 0)) {
HXLINE(  57)										g11 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float b12;
HXDLIN(  57)									int this27 = (old & 255);
HXDLIN(  57)									if ((this27 == 0)) {
HXLINE(  57)										b12 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float a21;
HXDLIN(  57)									int this28 = ((rhs >> 24) & 255);
HXDLIN(  57)									if ((this28 == 0)) {
HXLINE(  57)										a21 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float r21;
HXDLIN(  57)									int this29 = ((rhs >> 16) & 255);
HXDLIN(  57)									if ((this29 == 0)) {
HXLINE(  57)										r21 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float g21;
HXDLIN(  57)									int this30 = ((rhs >> 8) & 255);
HXDLIN(  57)									if ((this30 == 0)) {
HXLINE(  57)										g21 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float b22;
HXDLIN(  57)									int this31 = (rhs & 255);
HXDLIN(  57)									if ((this31 == 0)) {
HXLINE(  57)										b22 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN(  57)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  57)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  57)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  57)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  57)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  57)									{
HXLINE(  57)										int _hx_tmp10;
HXDLIN(  57)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)											_hx_tmp10 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE(  57)											_hx_tmp10 = blended1;
            										}
HXDLIN(  57)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp10);
            									}
            								}
            								else {
HXLINE(  57)									int value;
HXDLIN(  57)									if (pixelImage->isLittle) {
HXLINE(  57)										value = ((((a5 << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE(  57)										value = ((((a5 << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN(  57)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
            						}
            						else {
HXLINE(  57)							bool _hx_tmp11;
HXDLIN(  57)							bool _hx_tmp12;
HXDLIN(  57)							if ((ratioA >= 0)) {
HXLINE(  57)								_hx_tmp12 = (ratioB >= 0);
            							}
            							else {
HXLINE(  57)								_hx_tmp12 = false;
            							}
HXDLIN(  57)							if (_hx_tmp12) {
HXLINE(  57)								_hx_tmp11 = (ratioC >= 0);
            							}
            							else {
HXLINE(  57)								_hx_tmp11 = false;
            							}
HXDLIN(  57)							if (_hx_tmp11) {
HXLINE(  57)								int location2;
HXDLIN(  57)								if (pixelImage->useVirtualPos) {
HXLINE(  57)									location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  57)									location2 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN(  57)								bool _hx_tmp13;
HXDLIN(  57)								if (pixelImage->transparent) {
HXLINE(  57)									_hx_tmp13 = (a < 254);
            								}
            								else {
HXLINE(  57)									_hx_tmp13 = false;
            								}
HXDLIN(  57)								if (_hx_tmp13) {
HXLINE(  57)									int this32 = ::iterMagic::Iimg_obj::get(pixelImage->image,location2);
HXDLIN(  57)									int old1;
HXDLIN(  57)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)										old1 = ((((((this32 >> 24) & 255) << 24) | ((this32 & 255) << 16)) | (((this32 >> 8) & 255) << 8)) | ((this32 >> 16) & 255));
            									}
            									else {
HXLINE(  57)										old1 = this32;
            									}
HXDLIN(  57)									int rhs1 = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  57)									Float a13;
HXDLIN(  57)									int this33 = ((old1 >> 24) & 255);
HXDLIN(  57)									if ((this33 == 0)) {
HXLINE(  57)										a13 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										a13 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float r12;
HXDLIN(  57)									int this34 = ((old1 >> 16) & 255);
HXDLIN(  57)									if ((this34 == 0)) {
HXLINE(  57)										r12 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										r12 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float g12;
HXDLIN(  57)									int this35 = ((old1 >> 8) & 255);
HXDLIN(  57)									if ((this35 == 0)) {
HXLINE(  57)										g12 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										g12 = (( (Float)(this35) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float b13;
HXDLIN(  57)									int this36 = (old1 & 255);
HXDLIN(  57)									if ((this36 == 0)) {
HXLINE(  57)										b13 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										b13 = (( (Float)(this36) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float a22;
HXDLIN(  57)									int this37 = ((rhs1 >> 24) & 255);
HXDLIN(  57)									if ((this37 == 0)) {
HXLINE(  57)										a22 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										a22 = (( (Float)(this37) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float r22;
HXDLIN(  57)									int this38 = ((rhs1 >> 16) & 255);
HXDLIN(  57)									if ((this38 == 0)) {
HXLINE(  57)										r22 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										r22 = (( (Float)(this38) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float g22;
HXDLIN(  57)									int this39 = ((rhs1 >> 8) & 255);
HXDLIN(  57)									if ((this39 == 0)) {
HXLINE(  57)										g22 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										g22 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float b23;
HXDLIN(  57)									int this40 = (rhs1 & 255);
HXDLIN(  57)									if ((this40 == 0)) {
HXLINE(  57)										b23 = ((Float)0.);
            									}
            									else {
HXLINE(  57)										b23 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN(  57)									Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN(  57)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  57)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  57)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  57)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  57)									int blended2 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN(  57)									{
HXLINE(  57)										int _hx_tmp14;
HXDLIN(  57)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  57)											_hx_tmp14 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXLINE(  57)											_hx_tmp14 = blended2;
            										}
HXDLIN(  57)										::iterMagic::Iimg_obj::set(pixelImage->image,location2,_hx_tmp14);
            									}
            								}
            								else {
HXLINE(  57)									int value1;
HXDLIN(  57)									if (pixelImage->isLittle) {
HXLINE(  57)										value1 = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE(  57)										value1 = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN(  57)									::iterMagic::Iimg_obj::set(pixelImage->image,location2,value1);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  57)		 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  57)		 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  57)		int v_undoY;
HXDLIN(  57)		int v_undoX;
HXDLIN(  57)		Float v_ty;
HXDLIN(  57)		Float v_tx;
HXDLIN(  57)		Float v_t0;
HXDLIN(  57)		Float v_sy;
HXDLIN(  57)		Float v_sx;
HXDLIN(  57)		Float v_s0;
HXDLIN(  57)		Float v_A;
HXDLIN(  57)		Float ax1 = ax;
HXDLIN(  57)		Float ay1 = ay;
HXDLIN(  57)		 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  57)		Float bx2 = bx1;
HXDLIN(  57)		Float by2 = by1;
HXDLIN(  57)		Float cx2 = cx1;
HXDLIN(  57)		Float cy2 = cy1;
HXDLIN(  57)		bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  57)		if (!(adjustWinding1)) {
HXLINE(  57)			Float bx_1 = bx2;
HXDLIN(  57)			Float by_1 = by2;
HXLINE(  24)			bx2 = cx2;
HXLINE(  25)			by2 = cy2;
HXLINE(  26)			cx2 = bx_1;
HXLINE(  27)			cy2 = by_1;
            		}
HXLINE(  57)		Float v_ax = ax1;
HXDLIN(  57)		Float v_ay = ay1;
HXDLIN(  57)		Float v_bx = bx2;
HXDLIN(  57)		Float v_by = by2;
HXDLIN(  57)		Float v_cx = cx2;
HXDLIN(  57)		Float v_cy = cy2;
HXDLIN(  57)		bool v_preCalculated = true;
HXDLIN(  57)		{
HXLINE(  57)			v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  57)			v_sx = (v_cy - v_ay);
HXDLIN(  57)			v_sy = (v_ax - v_cx);
HXDLIN(  57)			v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  57)			v_tx = (v_ay - v_by);
HXDLIN(  57)			v_ty = (v_bx - v_ax);
HXDLIN(  57)			v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  57)			Float a8 = v_ax;
HXDLIN(  57)			Float b7 = v_bx;
HXDLIN(  57)			Float c3 = v_cx;
HXDLIN(  57)			if ((a8 > b7)) {
HXLINE(  57)				if ((a8 > c3)) {
HXLINE(  57)					int min5;
HXDLIN(  57)					if ((b7 > c3)) {
HXLINE(  57)						min5 = ::Math_obj::floor(c3);
            					}
            					else {
HXLINE(  57)						min5 = ::Math_obj::floor(b7);
            					}
HXDLIN(  57)					int ii_min8 = min5;
HXDLIN(  57)					int ii_max8 = ::Math_obj::ceil(a8);
HXDLIN(  57)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE(  57)					int ii_min9 = ::Math_obj::floor(b7);
HXDLIN(  57)					int ii_max9 = ::Math_obj::ceil(c3);
HXDLIN(  57)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE(  57)				if ((b7 > c3)) {
HXLINE(  57)					int min6;
HXDLIN(  57)					if ((a8 > c3)) {
HXLINE(  57)						min6 = ::Math_obj::floor(c3);
            					}
            					else {
HXLINE(  57)						min6 = ::Math_obj::ceil(a8);
            					}
HXDLIN(  57)					int ii_min10 = min6;
HXDLIN(  57)					int ii_max10 = ::Math_obj::ceil(b7);
HXDLIN(  57)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE(  57)					int ii_min11 = ::Math_obj::floor(a8);
HXDLIN(  57)					int ii_max11 = ::Math_obj::ceil(c3);
HXDLIN(  57)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN(  57)			Float a9 = v_ay;
HXDLIN(  57)			Float b8 = v_by;
HXDLIN(  57)			Float c4 = v_cy;
HXDLIN(  57)			if ((a9 > b8)) {
HXLINE(  57)				if ((a9 > c4)) {
HXLINE(  57)					int min7;
HXDLIN(  57)					if ((b8 > c4)) {
HXLINE(  57)						min7 = ::Math_obj::floor(c4);
            					}
            					else {
HXLINE(  57)						min7 = ::Math_obj::floor(b8);
            					}
HXDLIN(  57)					int ii_min12 = min7;
HXDLIN(  57)					int ii_max12 = ::Math_obj::ceil(a9);
HXDLIN(  57)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE(  57)					int ii_min13 = ::Math_obj::floor(b8);
HXDLIN(  57)					int ii_max13 = ::Math_obj::ceil(c4);
HXDLIN(  57)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE(  57)				if ((b8 > c4)) {
HXLINE(  57)					int min8;
HXDLIN(  57)					if ((a9 > c4)) {
HXLINE(  57)						min8 = ::Math_obj::floor(c4);
            					}
            					else {
HXLINE(  57)						min8 = ::Math_obj::ceil(a9);
            					}
HXDLIN(  57)					int ii_min14 = min8;
HXDLIN(  57)					int ii_max14 = ::Math_obj::ceil(b8);
HXDLIN(  57)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE(  57)					int ii_min15 = ::Math_obj::floor(a9);
HXDLIN(  57)					int ii_max15 = ::Math_obj::ceil(c4);
HXDLIN(  57)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
            		}
HXDLIN(  57)		if (hasUndo) {
HXLINE(  57)			v_undoImage = undoImage;
HXDLIN(  57)			v_undoX = xIter3->start;
HXDLIN(  57)			v_undoY = yIter3->start;
            		}
HXLINE(  58)		Float bx3 = cx;
HXDLIN(  58)		Float by3 = cy;
HXDLIN(  58)		Float cx3 = dx;
HXDLIN(  58)		Float cy3 = dy;
HXDLIN(  58)		int color2 = color;
HXDLIN(  58)		bool hasUndo1 = true;
HXDLIN(  58)		bool softAB1 = true;
HXDLIN(  58)		bool softBC1 = true;
HXDLIN(  58)		bool softCA1 = false;
HXDLIN(  58)		bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN(  58)		if (!(adjustWinding2)) {
HXLINE(  58)			Float bx_2 = bx3;
HXDLIN(  58)			Float by_2 = by3;
HXLINE( 106)			bx3 = cx3;
HXLINE( 107)			by3 = cy3;
HXLINE( 108)			cx3 = bx_2;
HXLINE( 109)			cy3 = by_2;
HXLINE( 111)			color2 = -2347260;
            		}
HXLINE(  58)		int a10 = ((color2 >> 24) & 255);
HXDLIN(  58)		int r6 = ((color2 >> 16) & 255);
HXDLIN(  58)		int g6 = ((color2 >> 8) & 255);
HXDLIN(  58)		int b9 = (color2 & 255);
HXDLIN(  58)		Float bcx1 = (bx3 - cx3);
HXDLIN(  58)		Float bcy1 = (by3 - cy3);
HXDLIN(  58)		Float acx1 = (bx - cx3);
HXDLIN(  58)		Float acy1 = (by - cy3);
HXDLIN(  58)		Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  58)		Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  58)		Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  58)		Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  58)		 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  58)		if ((bx > bx3)) {
HXLINE(  58)			if ((bx > cx3)) {
HXLINE(  58)				int min9;
HXDLIN(  58)				if ((bx3 > cx3)) {
HXLINE(  58)					min9 = ::Math_obj::floor(cx3);
            				}
            				else {
HXLINE(  58)					min9 = ::Math_obj::floor(bx3);
            				}
HXDLIN(  58)				int ii_min16 = min9;
HXDLIN(  58)				int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN(  58)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            			}
            			else {
HXLINE(  58)				int ii_min17 = ::Math_obj::floor(bx3);
HXDLIN(  58)				int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN(  58)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            			}
            		}
            		else {
HXLINE(  58)			if ((bx3 > cx3)) {
HXLINE(  58)				int min10;
HXDLIN(  58)				if ((bx > cx3)) {
HXLINE(  58)					min10 = ::Math_obj::floor(cx3);
            				}
            				else {
HXLINE(  58)					min10 = ::Math_obj::ceil(bx);
            				}
HXDLIN(  58)				int ii_min18 = min10;
HXDLIN(  58)				int ii_max18 = ::Math_obj::ceil(bx3);
HXDLIN(  58)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            			}
            			else {
HXLINE(  58)				int ii_min19 = ::Math_obj::floor(bx);
HXDLIN(  58)				int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN(  58)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            			}
            		}
HXDLIN(  58)		 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  58)		if ((by > by3)) {
HXLINE(  58)			if ((by > cy3)) {
HXLINE(  58)				int min11;
HXDLIN(  58)				if ((by3 > cy3)) {
HXLINE(  58)					min11 = ::Math_obj::floor(cy3);
            				}
            				else {
HXLINE(  58)					min11 = ::Math_obj::floor(by3);
            				}
HXDLIN(  58)				int ii_min20 = min11;
HXDLIN(  58)				int ii_max20 = ::Math_obj::ceil(by);
HXDLIN(  58)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            			}
            			else {
HXLINE(  58)				int ii_min21 = ::Math_obj::floor(by3);
HXDLIN(  58)				int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN(  58)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            			}
            		}
            		else {
HXLINE(  58)			if ((by3 > cy3)) {
HXLINE(  58)				int min12;
HXDLIN(  58)				if ((by > cy3)) {
HXLINE(  58)					min12 = ::Math_obj::floor(cy3);
            				}
            				else {
HXLINE(  58)					min12 = ::Math_obj::ceil(by);
            				}
HXDLIN(  58)				int ii_min22 = min12;
HXDLIN(  58)				int ii_max22 = ::Math_obj::ceil(by3);
HXDLIN(  58)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            			}
            			else {
HXLINE(  58)				int ii_min23 = ::Math_obj::floor(by);
HXDLIN(  58)				int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN(  58)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            			}
            		}
HXDLIN(  58)		 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  58)		if (hasUndo1) {
HXLINE(  58)			int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  58)			int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  58)			 ::Dynamic imageType1 = null();
HXDLIN(  58)			 ::pi_xy::ImageStruct this41 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  58)			if (::hx::IsNull( imageType1 )) {
HXDLIN(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  58)			::Dynamic undoImage4;
HXDLIN(  58)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXLINE(  58)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  58)					 ::iterMagic::BytesImg b10 = byt1;
HXDLIN(  58)					{
HXLINE(  58)						b10->width = width1;
HXDLIN(  58)						b10->height = height1;
HXDLIN(  58)						b10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)						b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN(  58)						{
HXLINE(  58)							int len2 = b10->length;
HXDLIN(  58)							int w1 = 0;
HXDLIN(  58)							{
HXLINE(  58)								int _g20 = 0;
HXDLIN(  58)								int _g21 = b10->height;
HXDLIN(  58)								while((_g20 < _g21)){
HXLINE(  58)									_g20 = (_g20 + 1);
HXDLIN(  58)									int y5 = (_g20 - 1);
HXDLIN(  58)									{
HXLINE(  58)										int _g22 = 0;
HXDLIN(  58)										int _g23 = b10->width;
HXDLIN(  58)										while((_g22 < _g23)){
HXLINE(  58)											_g22 = (_g22 + 1);
HXDLIN(  58)											int x5 = (_g22 - 1);
HXDLIN(  58)											{
HXLINE(  58)												w1 = (w1 + 1);
HXDLIN(  58)												b10->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  58)											{
HXLINE(  58)												w1 = (w1 + 1);
HXDLIN(  58)												b10->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  58)											{
HXLINE(  58)												w1 = (w1 + 1);
HXDLIN(  58)												b10->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  58)											{
HXLINE(  58)												w1 = (w1 + 1);
HXDLIN(  58)												b10->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  58)					undoImage4 = b10;
            				}
            				break;
            				case (int)1: {
HXLINE(  58)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)					 ::iterMagic::ArrIntImg a14 = arrI1;
HXDLIN(  58)					{
HXLINE(  58)						a14->width = width1;
HXDLIN(  58)						a14->height = height1;
HXDLIN(  58)						a14->data = ::Array_obj< int >::__new(0);
HXDLIN(  58)						a14->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)						{
HXLINE(  58)							int _g24 = 0;
HXDLIN(  58)							int _g25 = a14->length;
HXDLIN(  58)							while((_g24 < _g25)){
HXLINE(  58)								_g24 = (_g24 + 1);
HXDLIN(  58)								int i7 = (_g24 - 1);
HXDLIN(  58)								a14->data[i7] = 0;
            							}
            						}
            					}
HXDLIN(  58)					undoImage4 = a14;
            				}
            				break;
            				case (int)2: {
HXLINE(  58)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  58)					 ::iterMagic::U32ArrImg b14 = u32a1;
HXDLIN(  58)					{
HXLINE(  58)						b14->width = width1;
HXDLIN(  58)						b14->height = height1;
HXDLIN(  58)						b14->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)						int size1 = (b14->length * 4);
HXDLIN(  58)						b14->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  58)						{
HXLINE(  58)							int _g26 = 0;
HXDLIN(  58)							int _g27 = b14->length;
HXDLIN(  58)							while((_g26 < _g27)){
HXLINE(  58)								_g26 = (_g26 + 1);
HXDLIN(  58)								int i8 = (_g26 - 1);
HXDLIN(  58)								{
HXLINE(  58)									 ::haxe::io::ArrayBufferViewImpl this42 = b14->data;
HXDLIN(  58)									bool undoImage5;
HXDLIN(  58)									if ((i8 >= 0)) {
HXLINE(  58)										undoImage5 = (i8 < (this42->byteLength >> 2));
            									}
            									else {
HXLINE(  58)										undoImage5 = false;
            									}
HXDLIN(  58)									if (undoImage5) {
HXLINE(  58)										 ::haxe::io::Bytes _this1 = this42->bytes;
HXDLIN(  58)										int pos1 = ((i8 << 2) + this42->byteOffset);
HXDLIN(  58)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  58)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  58)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  58)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  58)					undoImage4 = b14;
            				}
            				break;
            				case (int)3: {
HXLINE(  58)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)					 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  58)					{
HXLINE(  58)						v2->width = width1;
HXDLIN(  58)						v2->height = height1;
HXDLIN(  58)						v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)						v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  58)						{
HXLINE(  58)							int _g28 = 0;
HXDLIN(  58)							int _g29 = v2->length;
HXDLIN(  58)							while((_g28 < _g29)){
HXLINE(  58)								_g28 = (_g28 + 1);
HXDLIN(  58)								int i9 = (_g28 - 1);
HXDLIN(  58)								v2->data->__unsafe_set(i9,0);
            							}
            						}
            					}
HXDLIN(  58)					undoImage4 = v2;
            				}
            				break;
            				case (int)4: {
HXLINE(  58)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)					 ::iterMagic::StackIntImg b15 = sInt1;
HXDLIN(  58)					{
HXLINE(  58)						b15->width = width1;
HXDLIN(  58)						b15->height = height1;
HXDLIN(  58)						b15->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)						b15->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  58)						{
HXLINE(  58)							int len3 = b15->length;
HXDLIN(  58)							 ::haxe::ds::GenericStack_Int d1 = b15->data;
HXDLIN(  58)							if (::hx::IsNull( d1->head )) {
HXLINE(  58)								int _g30 = 0;
HXDLIN(  58)								int _g31 = len3;
HXDLIN(  58)								while((_g30 < _g31)){
HXLINE(  58)									_g30 = (_g30 + 1);
HXDLIN(  58)									int i10 = (_g30 - 1);
HXDLIN(  58)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXLINE(  58)								int _g32 = 0;
HXDLIN(  58)								int _g33 = len3;
HXDLIN(  58)								while((_g32 < _g33)){
HXLINE(  58)									_g32 = (_g32 + 1);
HXDLIN(  58)									int i11 = (_g32 - 1);
HXDLIN(  58)									{
HXLINE(  58)										 ::haxe::ds::GenericCell_Int l1 = b15->data->head;
HXDLIN(  58)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  58)										{
HXLINE(  58)											int _g34 = 0;
HXDLIN(  58)											int _g35 = i11;
HXDLIN(  58)											while((_g34 < _g35)){
HXLINE(  58)												_g34 = (_g34 + 1);
HXDLIN(  58)												int i12 = (_g34 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE(  58)										if (::hx::IsNull( prev1 )) {
HXLINE(  58)											b15->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  58)											l1 = null();
            										}
            										else {
HXLINE(  58)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  58)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  58)					undoImage4 = b15;
            				}
            				break;
            			}
HXDLIN(  58)			this41->image = undoImage4;
HXDLIN(  58)			this41->width = width1;
HXDLIN(  58)			this41->height = height1;
HXDLIN(  58)			this41->imageType = ( (int)(imageType1) );
HXDLIN(  58)			undoImage3 = this41;
HXDLIN(  58)			{
HXLINE(  58)				int rectLeft1 = xIter31->start;
HXDLIN(  58)				int rectTop1 = yIter31->start;
HXDLIN(  58)				int rectRight1 = xIter31->max;
HXDLIN(  58)				bool forceClear1 = false;
HXDLIN(  58)				{
HXLINE(  58)					int _g36 = rectTop1;
HXDLIN(  58)					int _g37 = yIter31->max;
HXDLIN(  58)					while((_g36 < _g37)){
HXLINE(  58)						_g36 = (_g36 + 1);
HXDLIN(  58)						int dy2 = (_g36 - 1);
HXDLIN(  58)						{
HXLINE(  58)							int _g38 = rectLeft1;
HXDLIN(  58)							int _g39 = rectRight1;
HXDLIN(  58)							while((_g38 < _g39)){
HXLINE(  58)								_g38 = (_g38 + 1);
HXDLIN(  58)								int dx2 = (_g38 - 1);
HXDLIN(  58)								::Dynamic this43 = pixelImage->image;
HXDLIN(  58)								int index4;
HXDLIN(  58)								if (pixelImage->useVirtualPos) {
HXLINE(  58)									index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  58)									index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            								}
HXDLIN(  58)								int c5 = ::iterMagic::Iimg_obj::get(this43,index4);
HXDLIN(  58)								int col1;
HXDLIN(  58)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)									col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXLINE(  58)									col1 = c5;
            								}
HXDLIN(  58)								bool _hx_tmp15;
HXDLIN(  58)								if (pixelImage->useMask) {
HXLINE(  58)									_hx_tmp15 = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE(  58)									_hx_tmp15 = false;
            								}
HXDLIN(  58)								if (_hx_tmp15) {
HXLINE(  58)									 ::pi_xy::ImageStruct this44 = pixelImage->mask;
HXDLIN(  58)									::Dynamic this45 = this44->image;
HXDLIN(  58)									int index5;
HXDLIN(  58)									if (this44->useVirtualPos) {
HXLINE(  58)										index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this44->virtualY) * ( (Float)(this44->width) )) + dx2) - this44->virtualX));
            									}
            									else {
HXLINE(  58)										index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this44->width) + dx2)) ));
            									}
HXDLIN(  58)									int c6 = ::iterMagic::Iimg_obj::get(this45,index5);
HXDLIN(  58)									int v3;
HXDLIN(  58)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)										v3 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE(  58)										v3 = c6;
            									}
HXDLIN(  58)									int maskPixel1 = v3;
HXDLIN(  58)									int this46 = col1;
HXDLIN(  58)									if ((maskPixel1 == 0)) {
HXLINE(  58)										col1 = this46;
            									}
            									else {
HXLINE(  58)										Float m01;
HXDLIN(  58)										int this47 = ((maskPixel1 >> 24) & 255);
HXDLIN(  58)										if ((this47 == 0)) {
HXLINE(  58)											m01 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											m01 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float m11;
HXDLIN(  58)										int this48 = ((maskPixel1 >> 16) & 255);
HXDLIN(  58)										if ((this48 == 0)) {
HXLINE(  58)											m11 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											m11 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float m21;
HXDLIN(  58)										int this49 = ((maskPixel1 >> 8) & 255);
HXDLIN(  58)										if ((this49 == 0)) {
HXLINE(  58)											m21 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											m21 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float m31;
HXDLIN(  58)										int this50 = (maskPixel1 & 255);
HXDLIN(  58)										if ((this50 == 0)) {
HXLINE(  58)											m31 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											m31 = (( (Float)(this50) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this46 >> 24) & 255)) )));
HXDLIN(  58)										int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this46 >> 16) & 255)) )));
HXDLIN(  58)										int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this46 >> 8) & 255)) )));
HXDLIN(  58)										int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this46 & 255)) )));
HXDLIN(  58)										col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  58)								if ((col1 != 0)) {
HXLINE(  58)									int x6 = (dx2 - rectLeft1);
HXDLIN(  58)									int y6 = (dy2 - rectTop1);
HXDLIN(  58)									int c7 = col1;
HXDLIN(  58)									bool _hx_tmp16;
HXDLIN(  58)									if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  58)										_hx_tmp16 = undoImage3->transparent;
            									}
            									else {
HXLINE(  58)										_hx_tmp16 = false;
            									}
HXDLIN(  58)									if (_hx_tmp16) {
HXLINE(  58)										int location3;
HXDLIN(  58)										if (undoImage3->useVirtualPos) {
HXLINE(  58)											location3 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            										}
            										else {
HXLINE(  58)											location3 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            										}
HXDLIN(  58)										int this51 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN(  58)										int this52;
HXDLIN(  58)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)											this52 = ((((((this51 >> 24) & 255) << 24) | ((this51 & 255) << 16)) | (((this51 >> 8) & 255) << 8)) | ((this51 >> 16) & 255));
            										}
            										else {
HXLINE(  58)											this52 = this51;
            										}
HXDLIN(  58)										Float a15;
HXDLIN(  58)										int this53 = ((this52 >> 24) & 255);
HXDLIN(  58)										if ((this53 == 0)) {
HXLINE(  58)											a15 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											a15 = (( (Float)(this53) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float r13;
HXDLIN(  58)										int this54 = ((this52 >> 16) & 255);
HXDLIN(  58)										if ((this54 == 0)) {
HXLINE(  58)											r13 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											r13 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float g13;
HXDLIN(  58)										int this55 = ((this52 >> 8) & 255);
HXDLIN(  58)										if ((this55 == 0)) {
HXLINE(  58)											g13 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											g13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float b16;
HXDLIN(  58)										int this56 = (this52 & 255);
HXDLIN(  58)										if ((this56 == 0)) {
HXLINE(  58)											b16 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											b16 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float a23;
HXDLIN(  58)										int this57 = ((col1 >> 24) & 255);
HXDLIN(  58)										if ((this57 == 0)) {
HXLINE(  58)											a23 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											a23 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float r23;
HXDLIN(  58)										int this58 = ((col1 >> 16) & 255);
HXDLIN(  58)										if ((this58 == 0)) {
HXLINE(  58)											r23 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											r23 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float g23;
HXDLIN(  58)										int this59 = ((col1 >> 8) & 255);
HXDLIN(  58)										if ((this59 == 0)) {
HXLINE(  58)											g23 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											g23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float b24;
HXDLIN(  58)										int this60 = (col1 & 255);
HXDLIN(  58)										if ((this60 == 0)) {
HXLINE(  58)											b24 = ((Float)0.);
            										}
            										else {
HXLINE(  58)											b24 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN(  58)										Float a33 = (a15 * (( (Float)(1) ) - a23));
HXDLIN(  58)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  58)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  58)										int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a33) + (b24 * a23))));
HXDLIN(  58)										int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  58)										int blended3 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN(  58)										{
HXLINE(  58)											int _hx_tmp17;
HXDLIN(  58)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)												_hx_tmp17 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE(  58)												_hx_tmp17 = blended3;
            											}
HXDLIN(  58)											::iterMagic::Iimg_obj::set(undoImage3->image,location3,_hx_tmp17);
            										}
            									}
            									else {
HXLINE(  58)										::Dynamic this61 = undoImage3->image;
HXDLIN(  58)										int index6;
HXDLIN(  58)										if (undoImage3->useVirtualPos) {
HXLINE(  58)											index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            										}
            										else {
HXLINE(  58)											index6 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            										}
HXDLIN(  58)										int _hx_tmp18;
HXDLIN(  58)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)											_hx_tmp18 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE(  58)											_hx_tmp18 = c7;
            										}
HXDLIN(  58)										::iterMagic::Iimg_obj::set(this61,index6,_hx_tmp18);
            									}
            								}
            								else {
HXLINE(  58)									if (forceClear1) {
HXLINE(  58)										::Dynamic this62 = undoImage3->image;
HXDLIN(  58)										int x7 = (dx2 - rectLeft1);
HXDLIN(  58)										int y7 = (dy2 - rectTop1);
HXDLIN(  58)										int index7;
HXDLIN(  58)										if (undoImage3->useVirtualPos) {
HXLINE(  58)											index7 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            										}
            										else {
HXLINE(  58)											index7 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            										}
HXDLIN(  58)										::iterMagic::Iimg_obj::set(this62,index7,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  58)		Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN(  58)		Float sx1 = (cy3 - by);
HXDLIN(  58)		Float sy1 = (bx - cx3);
HXDLIN(  58)		Float t01 = ((bx * by3) - (by * bx3));
HXDLIN(  58)		Float tx1 = (by - by3);
HXDLIN(  58)		Float ty1 = (bx3 - bx);
HXDLIN(  58)		Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN(  58)		Float s1 = ((Float)0.);
HXDLIN(  58)		Float t1 = ((Float)0.);
HXDLIN(  58)		Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(5) ));
HXDLIN(  58)		Float omega1 = (theta1 / ( (Float)(3) ));
HXDLIN(  58)		Float delta1 = ((Float)0.7071);
HXDLIN(  58)		Float x01 = (delta1 * ::Math_obj::cos((theta1 + omega1)));
HXDLIN(  58)		Float y01 = (delta1 * ::Math_obj::sin((theta1 + omega1)));
HXDLIN(  58)		omega1 = (omega1 + theta1);
HXDLIN(  58)		Float x12 = (delta1 * ::Math_obj::cos((theta1 + omega1)));
HXDLIN(  58)		Float y12 = (delta1 * ::Math_obj::sin((theta1 + omega1)));
HXDLIN(  58)		omega1 = (omega1 + theta1);
HXDLIN(  58)		Float x22 = (delta1 * ::Math_obj::cos((theta1 + omega1)));
HXDLIN(  58)		Float y22 = (delta1 * ::Math_obj::sin((theta1 + omega1)));
HXDLIN(  58)		omega1 = (omega1 + theta1);
HXDLIN(  58)		Float x31 = (delta1 * ::Math_obj::cos((theta1 + omega1)));
HXDLIN(  58)		Float y31 = (delta1 * ::Math_obj::sin((theta1 + omega1)));
HXDLIN(  58)		omega1 = (omega1 + theta1);
HXDLIN(  58)		Float x41 = (delta1 * ::Math_obj::cos((theta1 + omega1)));
HXDLIN(  58)		Float y41 = (delta1 * ::Math_obj::sin((theta1 + omega1)));
HXDLIN(  58)		Float sxx5 = ((Float)0.);
HXDLIN(  58)		Float txx5 = ((Float)0.);
HXDLIN(  58)		Float sxx01 = ((Float)0.);
HXDLIN(  58)		Float sxx11 = ((Float)0.);
HXDLIN(  58)		Float sxx21 = ((Float)0.);
HXDLIN(  58)		Float sxx31 = ((Float)0.);
HXDLIN(  58)		Float sxx41 = ((Float)0.);
HXDLIN(  58)		Float txx01 = ((Float)0.);
HXDLIN(  58)		Float txx11 = ((Float)0.);
HXDLIN(  58)		Float txx21 = ((Float)0.);
HXDLIN(  58)		Float txx31 = ((Float)0.);
HXDLIN(  58)		Float txx41 = ((Float)0.);
HXDLIN(  58)		Float aSum1 = ((Float)0.);
HXDLIN(  58)		{
HXLINE(  58)			int _g_min2 = xIter31->start;
HXDLIN(  58)			int _g_max2 = xIter31->max;
HXDLIN(  58)			while((_g_min2 < _g_max2)){
HXLINE(  58)				_g_min2 = (_g_min2 + 1);
HXDLIN(  58)				int px1 = (_g_min2 - 1);
HXDLIN(  58)				Float pcx1 = (( (Float)(px1) ) - cx3);
HXLINE( 223)				sxx5 = (sx1 * ( (Float)(px1) ));
HXLINE( 224)				txx5 = (tx1 * ( (Float)(px1) ));
HXLINE( 226)				sxx01 = (sx1 * (px1 + x01));
HXLINE( 227)				sxx11 = (sx1 * (px1 + x12));
HXLINE( 228)				sxx21 = (sx1 * (px1 + x22));
HXLINE( 229)				sxx31 = (sx1 * (px1 + x31));
HXLINE( 230)				sxx41 = (sx1 * (px1 + x41));
HXLINE( 231)				txx01 = (tx1 * (px1 + x01));
HXLINE( 232)				txx11 = (tx1 * (px1 + x12));
HXLINE( 233)				txx21 = (tx1 * (px1 + x22));
HXLINE( 234)				txx31 = (tx1 * (px1 + x31));
HXLINE( 235)				txx41 = (tx1 * (px1 + x41));
HXLINE(  58)				{
HXLINE(  58)					int _g_min3 = yIter31->start;
HXDLIN(  58)					int _g_max3 = yIter31->max;
HXDLIN(  58)					while((_g_min3 < _g_max3)){
HXLINE(  58)						_g_min3 = (_g_min3 + 1);
HXDLIN(  58)						int py1 = (_g_min3 - 1);
HXDLIN(  58)						Float pcy1 = (( (Float)(py1) ) - cy3);
HXDLIN(  58)						Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  58)						Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  58)						Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  58)						Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  58)						Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  58)						Float min13;
HXDLIN(  58)						if ((ratioA1 < ratioB1)) {
HXLINE(  58)							min13 = ratioA1;
            						}
            						else {
HXLINE(  58)							min13 = ratioB1;
            						}
HXDLIN(  58)						if (!((min13 < ratioC1))) {
HXLINE(  58)							min13 = ratioC1;
            						}
HXDLIN(  58)						bool pentagonSampling1;
HXDLIN(  58)						if (softAB1) {
HXLINE(  58)							if (softBC1) {
HXLINE(  58)								if (softCA1) {
HXLINE(  58)									pentagonSampling1 = true;
            								}
            								else {
HXLINE(  58)									if ((min13 != ratioB1)) {
HXLINE(  58)										pentagonSampling1 = (min13 == ratioC1);
            									}
            									else {
HXLINE(  58)										pentagonSampling1 = true;
            									}
            								}
            							}
            							else {
HXLINE(  58)								if (softCA1) {
HXLINE(  58)									if ((min13 != ratioA1)) {
HXLINE(  58)										pentagonSampling1 = (min13 == ratioC1);
            									}
            									else {
HXLINE(  58)										pentagonSampling1 = true;
            									}
            								}
            								else {
HXLINE(  58)									pentagonSampling1 = (min13 == ratioC1);
            								}
            							}
            						}
            						else {
HXLINE(  58)							if (softBC1) {
HXLINE(  58)								if (softCA1) {
HXLINE(  58)									if ((min13 != ratioA1)) {
HXLINE(  58)										pentagonSampling1 = (min13 == ratioB1);
            									}
            									else {
HXLINE(  58)										pentagonSampling1 = true;
            									}
            								}
            								else {
HXLINE(  58)									pentagonSampling1 = (min13 == ratioB1);
            								}
            							}
            							else {
HXLINE(  58)								if (softCA1) {
HXLINE(  58)									pentagonSampling1 = (min13 == ratioA1);
            								}
            								else {
HXLINE(  58)									pentagonSampling1 = false;
            								}
            							}
            						}
HXDLIN(  58)						if (pentagonSampling1) {
HXLINE( 276)							aSum1 = ((Float)0.);
HXLINE( 277)							s1 = ((s01 + sxx01) + (sy1 * (py1 + y01)));
HXLINE( 278)							t1 = ((t01 + txx01) + (ty1 * (py1 + y01)));
HXLINE(  58)							bool _hx_tmp19;
HXDLIN(  58)							if (!((s1 <= 0))) {
HXLINE(  58)								_hx_tmp19 = (t1 <= 0);
            							}
            							else {
HXLINE(  58)								_hx_tmp19 = true;
            							}
HXDLIN(  58)							if (!(_hx_tmp19)) {
HXLINE(  58)								if (((s1 + t1) < A1)) {
HXLINE(  58)									aSum1 = (aSum1 + ((Float)0.2));
            								}
            							}
HXLINE( 280)							s1 = ((s01 + sxx11) + (sy1 * (py1 + y12)));
HXLINE( 281)							t1 = ((t01 + txx11) + (ty1 * (py1 + y12)));
HXLINE(  58)							bool _hx_tmp20;
HXDLIN(  58)							if (!((s1 <= 0))) {
HXLINE(  58)								_hx_tmp20 = (t1 <= 0);
            							}
            							else {
HXLINE(  58)								_hx_tmp20 = true;
            							}
HXDLIN(  58)							if (!(_hx_tmp20)) {
HXLINE(  58)								if (((s1 + t1) < A1)) {
HXLINE(  58)									aSum1 = (aSum1 + ((Float)0.2));
            								}
            							}
HXLINE( 283)							s1 = ((s01 + sxx21) + (sy1 * (py1 + y22)));
HXLINE( 284)							t1 = ((t01 + txx21) + (ty1 * (py1 + y22)));
HXLINE(  58)							bool _hx_tmp21;
HXDLIN(  58)							if (!((s1 <= 0))) {
HXLINE(  58)								_hx_tmp21 = (t1 <= 0);
            							}
            							else {
HXLINE(  58)								_hx_tmp21 = true;
            							}
HXDLIN(  58)							if (!(_hx_tmp21)) {
HXLINE(  58)								if (((s1 + t1) < A1)) {
HXLINE(  58)									aSum1 = (aSum1 + ((Float)0.2));
            								}
            							}
HXLINE( 286)							s1 = ((s01 + sxx31) + (sy1 * (py1 + y31)));
HXLINE( 287)							t1 = ((t01 + txx31) + (ty1 * (py1 + y31)));
HXLINE(  58)							bool _hx_tmp22;
HXDLIN(  58)							if (!((s1 <= 0))) {
HXLINE(  58)								_hx_tmp22 = (t1 <= 0);
            							}
            							else {
HXLINE(  58)								_hx_tmp22 = true;
            							}
HXDLIN(  58)							if (!(_hx_tmp22)) {
HXLINE(  58)								if (((s1 + t1) < A1)) {
HXLINE(  58)									aSum1 = (aSum1 + ((Float)0.2));
            								}
            							}
HXLINE( 289)							s1 = ((s01 + sxx41) + (sy1 * (py1 + y41)));
HXLINE( 290)							t1 = ((t01 + txx41) + (ty1 * (py1 + y41)));
HXLINE(  58)							bool _hx_tmp23;
HXDLIN(  58)							if (!((s1 <= 0))) {
HXLINE(  58)								_hx_tmp23 = (t1 <= 0);
            							}
            							else {
HXLINE(  58)								_hx_tmp23 = true;
            							}
HXDLIN(  58)							if (!(_hx_tmp23)) {
HXLINE(  58)								if (((s1 + t1) < A1)) {
HXLINE(  58)									aSum1 = (aSum1 + ((Float)0.2));
            								}
            							}
HXDLIN(  58)							if ((aSum1 != ((Float)0.))) {
HXLINE(  58)								int a17;
HXDLIN(  58)								if ((aSum1 > ((Float)0.9))) {
HXLINE(  58)									a17 = a10;
            								}
            								else {
HXLINE(  58)									int i13 = ::Std_obj::_hx_int((( (Float)(a10) ) * aSum1));
HXDLIN(  58)									if ((i13 > 255)) {
HXLINE(  24)										i13 = 255;
            									}
HXLINE(  58)									if ((i13 < 0)) {
HXLINE(  25)										i13 = 0;
            									}
HXLINE(  58)									a17 = i13;
            								}
HXDLIN(  58)								int location4;
HXDLIN(  58)								if (pixelImage->useVirtualPos) {
HXLINE(  58)									location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  58)									location4 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            								}
HXDLIN(  58)								bool _hx_tmp24;
HXDLIN(  58)								if (pixelImage->transparent) {
HXLINE(  58)									_hx_tmp24 = (a17 < 254);
            								}
            								else {
HXLINE(  58)									_hx_tmp24 = false;
            								}
HXDLIN(  58)								if (_hx_tmp24) {
HXLINE(  58)									int this63 = ::iterMagic::Iimg_obj::get(pixelImage->image,location4);
HXDLIN(  58)									int old2;
HXDLIN(  58)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)										old2 = ((((((this63 >> 24) & 255) << 24) | ((this63 & 255) << 16)) | (((this63 >> 8) & 255) << 8)) | ((this63 >> 16) & 255));
            									}
            									else {
HXLINE(  58)										old2 = this63;
            									}
HXDLIN(  58)									int rhs2 = ((((a17 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN(  58)									Float a18;
HXDLIN(  58)									int this64 = ((old2 >> 24) & 255);
HXDLIN(  58)									if ((this64 == 0)) {
HXLINE(  58)										a18 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										a18 = (( (Float)(this64) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float r14;
HXDLIN(  58)									int this65 = ((old2 >> 16) & 255);
HXDLIN(  58)									if ((this65 == 0)) {
HXLINE(  58)										r14 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										r14 = (( (Float)(this65) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float g14;
HXDLIN(  58)									int this66 = ((old2 >> 8) & 255);
HXDLIN(  58)									if ((this66 == 0)) {
HXLINE(  58)										g14 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										g14 = (( (Float)(this66) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float b18;
HXDLIN(  58)									int this67 = (old2 & 255);
HXDLIN(  58)									if ((this67 == 0)) {
HXLINE(  58)										b18 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										b18 = (( (Float)(this67) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float a24;
HXDLIN(  58)									int this68 = ((rhs2 >> 24) & 255);
HXDLIN(  58)									if ((this68 == 0)) {
HXLINE(  58)										a24 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										a24 = (( (Float)(this68) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float r24;
HXDLIN(  58)									int this69 = ((rhs2 >> 16) & 255);
HXDLIN(  58)									if ((this69 == 0)) {
HXLINE(  58)										r24 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										r24 = (( (Float)(this69) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float g24;
HXDLIN(  58)									int this70 = ((rhs2 >> 8) & 255);
HXDLIN(  58)									if ((this70 == 0)) {
HXLINE(  58)										g24 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										g24 = (( (Float)(this70) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float b25;
HXDLIN(  58)									int this71 = (rhs2 & 255);
HXDLIN(  58)									if ((this71 == 0)) {
HXLINE(  58)										b25 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										b25 = (( (Float)(this71) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float a34 = (a18 * (( (Float)(1) ) - a24));
HXDLIN(  58)									int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  58)									int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  58)									int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a34) + (b25 * a24))));
HXDLIN(  58)									int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  58)									int blended4 = ((((a19 << 24) | (r8 << 16)) | (g8 << 8)) | b19);
HXDLIN(  58)									{
HXLINE(  58)										int _hx_tmp25;
HXDLIN(  58)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)											_hx_tmp25 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXLINE(  58)											_hx_tmp25 = blended4;
            										}
HXDLIN(  58)										::iterMagic::Iimg_obj::set(pixelImage->image,location4,_hx_tmp25);
            									}
            								}
            								else {
HXLINE(  58)									int value2;
HXDLIN(  58)									if (pixelImage->isLittle) {
HXLINE(  58)										value2 = ((((a17 << 24) | (b9 << 16)) | (g6 << 8)) | r6);
            									}
            									else {
HXLINE(  58)										value2 = ((((a17 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
            									}
HXDLIN(  58)									::iterMagic::Iimg_obj::set(pixelImage->image,location4,value2);
            								}
            							}
            						}
            						else {
HXLINE(  58)							bool _hx_tmp26;
HXDLIN(  58)							bool _hx_tmp27;
HXDLIN(  58)							if ((ratioA1 >= 0)) {
HXLINE(  58)								_hx_tmp27 = (ratioB1 >= 0);
            							}
            							else {
HXLINE(  58)								_hx_tmp27 = false;
            							}
HXDLIN(  58)							if (_hx_tmp27) {
HXLINE(  58)								_hx_tmp26 = (ratioC1 >= 0);
            							}
            							else {
HXLINE(  58)								_hx_tmp26 = false;
            							}
HXDLIN(  58)							if (_hx_tmp26) {
HXLINE(  58)								int location5;
HXDLIN(  58)								if (pixelImage->useVirtualPos) {
HXLINE(  58)									location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  58)									location5 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            								}
HXDLIN(  58)								bool _hx_tmp28;
HXDLIN(  58)								if (pixelImage->transparent) {
HXLINE(  58)									_hx_tmp28 = (a10 < 254);
            								}
            								else {
HXLINE(  58)									_hx_tmp28 = false;
            								}
HXDLIN(  58)								if (_hx_tmp28) {
HXLINE(  58)									int this72 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN(  58)									int old3;
HXDLIN(  58)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)										old3 = ((((((this72 >> 24) & 255) << 24) | ((this72 & 255) << 16)) | (((this72 >> 8) & 255) << 8)) | ((this72 >> 16) & 255));
            									}
            									else {
HXLINE(  58)										old3 = this72;
            									}
HXDLIN(  58)									int rhs3 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN(  58)									Float a110;
HXDLIN(  58)									int this73 = ((old3 >> 24) & 255);
HXDLIN(  58)									if ((this73 == 0)) {
HXLINE(  58)										a110 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										a110 = (( (Float)(this73) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float r15;
HXDLIN(  58)									int this74 = ((old3 >> 16) & 255);
HXDLIN(  58)									if ((this74 == 0)) {
HXLINE(  58)										r15 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										r15 = (( (Float)(this74) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float g15;
HXDLIN(  58)									int this75 = ((old3 >> 8) & 255);
HXDLIN(  58)									if ((this75 == 0)) {
HXLINE(  58)										g15 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										g15 = (( (Float)(this75) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float b110;
HXDLIN(  58)									int this76 = (old3 & 255);
HXDLIN(  58)									if ((this76 == 0)) {
HXLINE(  58)										b110 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										b110 = (( (Float)(this76) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float a25;
HXDLIN(  58)									int this77 = ((rhs3 >> 24) & 255);
HXDLIN(  58)									if ((this77 == 0)) {
HXLINE(  58)										a25 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										a25 = (( (Float)(this77) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float r25;
HXDLIN(  58)									int this78 = ((rhs3 >> 16) & 255);
HXDLIN(  58)									if ((this78 == 0)) {
HXLINE(  58)										r25 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										r25 = (( (Float)(this78) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float g25;
HXDLIN(  58)									int this79 = ((rhs3 >> 8) & 255);
HXDLIN(  58)									if ((this79 == 0)) {
HXLINE(  58)										g25 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										g25 = (( (Float)(this79) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float b26;
HXDLIN(  58)									int this80 = (rhs3 & 255);
HXDLIN(  58)									if ((this80 == 0)) {
HXLINE(  58)										b26 = ((Float)0.);
            									}
            									else {
HXLINE(  58)										b26 = (( (Float)(this80) ) / ( (Float)(255) ));
            									}
HXDLIN(  58)									Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN(  58)									int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  58)									int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  58)									int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a35) + (b26 * a25))));
HXDLIN(  58)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  58)									int blended5 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b20);
HXDLIN(  58)									{
HXLINE(  58)										int _hx_tmp29;
HXDLIN(  58)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  58)											_hx_tmp29 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            										}
            										else {
HXLINE(  58)											_hx_tmp29 = blended5;
            										}
HXDLIN(  58)										::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp29);
            									}
            								}
            								else {
HXLINE(  58)									int value3;
HXDLIN(  58)									if (pixelImage->isLittle) {
HXLINE(  58)										value3 = ((((a10 << 24) | (b9 << 16)) | (g6 << 8)) | r6);
            									}
            									else {
HXLINE(  58)										value3 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
            									}
HXDLIN(  58)									::iterMagic::Iimg_obj::set(pixelImage->image,location5,value3);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  58)		 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  58)		 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  58)		int v_undoY1;
HXDLIN(  58)		int v_undoX1;
HXDLIN(  58)		Float v_ty1;
HXDLIN(  58)		Float v_tx1;
HXDLIN(  58)		Float v_t01;
HXDLIN(  58)		Float v_sy1;
HXDLIN(  58)		Float v_sx1;
HXDLIN(  58)		Float v_s01;
HXDLIN(  58)		Float v_A1;
HXDLIN(  58)		Float ax2 = bx;
HXDLIN(  58)		Float ay2 = by;
HXDLIN(  58)		 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  58)		Float bx4 = bx3;
HXDLIN(  58)		Float by4 = by3;
HXDLIN(  58)		Float cx4 = cx3;
HXDLIN(  58)		Float cy4 = cy3;
HXDLIN(  58)		bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN(  58)		if (!(adjustWinding3)) {
HXLINE(  58)			Float bx_3 = bx4;
HXDLIN(  58)			Float by_3 = by4;
HXLINE(  24)			bx4 = cx4;
HXLINE(  25)			by4 = cy4;
HXLINE(  26)			cx4 = bx_3;
HXLINE(  27)			cy4 = by_3;
            		}
HXLINE(  58)		Float v_ax1 = ax2;
HXDLIN(  58)		Float v_ay1 = ay2;
HXDLIN(  58)		Float v_bx1 = bx4;
HXDLIN(  58)		Float v_by1 = by4;
HXDLIN(  58)		Float v_cx1 = cx4;
HXDLIN(  58)		Float v_cy1 = cy4;
HXDLIN(  58)		bool v_preCalculated1 = true;
HXDLIN(  58)		{
HXLINE(  58)			v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  58)			v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  58)			v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  58)			v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  58)			v_tx1 = (v_ay1 - v_by1);
HXDLIN(  58)			v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  58)			v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  58)			Float a26 = v_ax1;
HXDLIN(  58)			Float b27 = v_bx1;
HXDLIN(  58)			Float c8 = v_cx1;
HXDLIN(  58)			if ((a26 > b27)) {
HXLINE(  58)				if ((a26 > c8)) {
HXLINE(  58)					int min14;
HXDLIN(  58)					if ((b27 > c8)) {
HXLINE(  58)						min14 = ::Math_obj::floor(c8);
            					}
            					else {
HXLINE(  58)						min14 = ::Math_obj::floor(b27);
            					}
HXDLIN(  58)					int ii_min24 = min14;
HXDLIN(  58)					int ii_max24 = ::Math_obj::ceil(a26);
HXDLIN(  58)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            				}
            				else {
HXLINE(  58)					int ii_min25 = ::Math_obj::floor(b27);
HXDLIN(  58)					int ii_max25 = ::Math_obj::ceil(c8);
HXDLIN(  58)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            				}
            			}
            			else {
HXLINE(  58)				if ((b27 > c8)) {
HXLINE(  58)					int min15;
HXDLIN(  58)					if ((a26 > c8)) {
HXLINE(  58)						min15 = ::Math_obj::floor(c8);
            					}
            					else {
HXLINE(  58)						min15 = ::Math_obj::ceil(a26);
            					}
HXDLIN(  58)					int ii_min26 = min15;
HXDLIN(  58)					int ii_max26 = ::Math_obj::ceil(b27);
HXDLIN(  58)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            				}
            				else {
HXLINE(  58)					int ii_min27 = ::Math_obj::floor(a26);
HXDLIN(  58)					int ii_max27 = ::Math_obj::ceil(c8);
HXDLIN(  58)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            				}
            			}
HXDLIN(  58)			Float a27 = v_ay1;
HXDLIN(  58)			Float b28 = v_by1;
HXDLIN(  58)			Float c9 = v_cy1;
HXDLIN(  58)			if ((a27 > b28)) {
HXLINE(  58)				if ((a27 > c9)) {
HXLINE(  58)					int min16;
HXDLIN(  58)					if ((b28 > c9)) {
HXLINE(  58)						min16 = ::Math_obj::floor(c9);
            					}
            					else {
HXLINE(  58)						min16 = ::Math_obj::floor(b28);
            					}
HXDLIN(  58)					int ii_min28 = min16;
HXDLIN(  58)					int ii_max28 = ::Math_obj::ceil(a27);
HXDLIN(  58)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            				}
            				else {
HXLINE(  58)					int ii_min29 = ::Math_obj::floor(b28);
HXDLIN(  58)					int ii_max29 = ::Math_obj::ceil(c9);
HXDLIN(  58)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            				}
            			}
            			else {
HXLINE(  58)				if ((b28 > c9)) {
HXLINE(  58)					int min17;
HXDLIN(  58)					if ((a27 > c9)) {
HXLINE(  58)						min17 = ::Math_obj::floor(c9);
            					}
            					else {
HXLINE(  58)						min17 = ::Math_obj::ceil(a27);
            					}
HXDLIN(  58)					int ii_min30 = min17;
HXDLIN(  58)					int ii_max30 = ::Math_obj::ceil(b28);
HXDLIN(  58)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            				}
            				else {
HXLINE(  58)					int ii_min31 = ::Math_obj::floor(a27);
HXDLIN(  58)					int ii_max31 = ::Math_obj::ceil(c9);
HXDLIN(  58)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            				}
            			}
            		}
HXDLIN(  58)		if (hasUndo1) {
HXLINE(  58)			v_undoImage1 = undoImage3;
HXDLIN(  58)			v_undoX1 = xIter31->start;
HXDLIN(  58)			v_undoY1 = yIter31->start;
            		}
HXLINE(  60)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(TriPixelSmooth_Fields__obj,quadPentagonBarycentric,return )

 ::pi_xy::algo::HitTri TriPixelSmooth_Fields__obj::triPentagonBarycentricBottom( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_132148ab73c7d3b6_68_triPentagonBarycentricBottom)
HXLINE(  71)		bool softAB = true;
HXLINE(  72)		bool softBC = false;
HXLINE(  73)		bool softCA = true;
HXLINE(  74)		bool adjustWinding = (((((ax * by) - (bx * ay)) + ((bx * cy) - (cx * by))) + ((cx * ay) - (ax * cy))) > 0);
HXLINE(  75)		if (!(adjustWinding)) {
HXLINE(  76)			Float bx_ = bx;
HXLINE(  77)			Float by_ = by;
HXLINE(  78)			bx = cx;
HXLINE(  79)			by = cy;
HXLINE(  80)			cx = bx_;
HXLINE(  81)			cy = by_;
HXLINE(  83)			color = -1309128;
HXLINE(  84)			bool softAB1 = true;
HXLINE(  85)			bool softBC1 = true;
HXLINE(  86)			bool softCA1 = false;
            		}
HXLINE(  88)		int a = ((color >> 24) & 255);
HXDLIN(  88)		int r = ((color >> 16) & 255);
HXDLIN(  88)		int g = ((color >> 8) & 255);
HXDLIN(  88)		int b = (color & 255);
HXDLIN(  88)		Float bcx = (bx - cx);
HXDLIN(  88)		Float bcy = (by - cy);
HXDLIN(  88)		Float acx = (ax - cx);
HXDLIN(  88)		Float acy = (ay - cy);
HXDLIN(  88)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  88)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  88)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  88)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  88)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  88)		if ((ax > bx)) {
HXLINE(  88)			if ((ax > cx)) {
HXLINE(  88)				int min;
HXDLIN(  88)				if ((bx > cx)) {
HXLINE(  88)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE(  88)					min = ::Math_obj::floor(bx);
            				}
HXDLIN(  88)				int ii_min = min;
HXDLIN(  88)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  88)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE(  88)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  88)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN(  88)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE(  88)			if ((bx > cx)) {
HXLINE(  88)				int min1;
HXDLIN(  88)				if ((ax > cx)) {
HXLINE(  88)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE(  88)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN(  88)				int ii_min2 = min1;
HXDLIN(  88)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  88)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE(  88)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  88)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN(  88)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN(  88)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  88)		if ((ay > by)) {
HXLINE(  88)			if ((ay > cy)) {
HXLINE(  88)				int min2;
HXDLIN(  88)				if ((by > cy)) {
HXLINE(  88)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE(  88)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN(  88)				int ii_min4 = min2;
HXDLIN(  88)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  88)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE(  88)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  88)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN(  88)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE(  88)			if ((by > cy)) {
HXLINE(  88)				int min3;
HXDLIN(  88)				if ((ay > cy)) {
HXLINE(  88)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE(  88)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN(  88)				int ii_min6 = min3;
HXDLIN(  88)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  88)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE(  88)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  88)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN(  88)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN(  88)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  88)		if (hasUndo) {
HXLINE(  88)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  88)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  88)			 ::Dynamic imageType = null();
HXDLIN(  88)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  88)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  88)			::Dynamic undoImage1;
HXDLIN(  88)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE(  88)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  88)					 ::iterMagic::BytesImg b1 = byt;
HXDLIN(  88)					{
HXLINE(  88)						b1->width = width;
HXDLIN(  88)						b1->height = height;
HXDLIN(  88)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  88)						b1->data = ::haxe::io::Bytes_obj::alloc((b1->length * 4));
HXDLIN(  88)						{
HXLINE(  88)							int len = b1->length;
HXDLIN(  88)							int w = 0;
HXDLIN(  88)							{
HXLINE(  88)								int _g = 0;
HXDLIN(  88)								int _g1 = b1->height;
HXDLIN(  88)								while((_g < _g1)){
HXLINE(  88)									_g = (_g + 1);
HXDLIN(  88)									int y = (_g - 1);
HXDLIN(  88)									{
HXLINE(  88)										int _g2 = 0;
HXDLIN(  88)										int _g3 = b1->width;
HXDLIN(  88)										while((_g2 < _g3)){
HXLINE(  88)											_g2 = (_g2 + 1);
HXDLIN(  88)											int x = (_g2 - 1);
HXDLIN(  88)											{
HXLINE(  88)												w = (w + 1);
HXDLIN(  88)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  88)											{
HXLINE(  88)												w = (w + 1);
HXDLIN(  88)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  88)											{
HXLINE(  88)												w = (w + 1);
HXDLIN(  88)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  88)											{
HXLINE(  88)												w = (w + 1);
HXDLIN(  88)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  88)					undoImage1 = b1;
            				}
            				break;
            				case (int)1: {
HXLINE(  88)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  88)					 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN(  88)					{
HXLINE(  88)						a1->width = width;
HXDLIN(  88)						a1->height = height;
HXDLIN(  88)						a1->data = ::Array_obj< int >::__new(0);
HXDLIN(  88)						a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  88)						{
HXLINE(  88)							int _g4 = 0;
HXDLIN(  88)							int _g5 = a1->length;
HXDLIN(  88)							while((_g4 < _g5)){
HXLINE(  88)								_g4 = (_g4 + 1);
HXDLIN(  88)								int i = (_g4 - 1);
HXDLIN(  88)								a1->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  88)					undoImage1 = a1;
            				}
            				break;
            				case (int)2: {
HXLINE(  88)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  88)					 ::iterMagic::U32ArrImg b2 = u32a;
HXDLIN(  88)					{
HXLINE(  88)						b2->width = width;
HXDLIN(  88)						b2->height = height;
HXDLIN(  88)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  88)						int size = (b2->length * 4);
HXDLIN(  88)						b2->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  88)						{
HXLINE(  88)							int _g6 = 0;
HXDLIN(  88)							int _g7 = b2->length;
HXDLIN(  88)							while((_g6 < _g7)){
HXLINE(  88)								_g6 = (_g6 + 1);
HXDLIN(  88)								int i1 = (_g6 - 1);
HXDLIN(  88)								{
HXLINE(  88)									 ::haxe::io::ArrayBufferViewImpl this2 = b2->data;
HXDLIN(  88)									bool undoImage2;
HXDLIN(  88)									if ((i1 >= 0)) {
HXLINE(  88)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  88)										undoImage2 = false;
            									}
HXDLIN(  88)									if (undoImage2) {
HXLINE(  88)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  88)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  88)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  88)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  88)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  88)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  88)					undoImage1 = b2;
            				}
            				break;
            				case (int)3: {
HXLINE(  88)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  88)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  88)					{
HXLINE(  88)						v->width = width;
HXDLIN(  88)						v->height = height;
HXDLIN(  88)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  88)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  88)						{
HXLINE(  88)							int _g8 = 0;
HXDLIN(  88)							int _g9 = v->length;
HXDLIN(  88)							while((_g8 < _g9)){
HXLINE(  88)								_g8 = (_g8 + 1);
HXDLIN(  88)								int i2 = (_g8 - 1);
HXDLIN(  88)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  88)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE(  88)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  88)					 ::iterMagic::StackIntImg b3 = sInt;
HXDLIN(  88)					{
HXLINE(  88)						b3->width = width;
HXDLIN(  88)						b3->height = height;
HXDLIN(  88)						b3->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  88)						b3->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  88)						{
HXLINE(  88)							int len1 = b3->length;
HXDLIN(  88)							 ::haxe::ds::GenericStack_Int d = b3->data;
HXDLIN(  88)							if (::hx::IsNull( d->head )) {
HXLINE(  88)								int _g10 = 0;
HXDLIN(  88)								int _g11 = len1;
HXDLIN(  88)								while((_g10 < _g11)){
HXLINE(  88)									_g10 = (_g10 + 1);
HXDLIN(  88)									int i3 = (_g10 - 1);
HXDLIN(  88)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE(  88)								int _g12 = 0;
HXDLIN(  88)								int _g13 = len1;
HXDLIN(  88)								while((_g12 < _g13)){
HXLINE(  88)									_g12 = (_g12 + 1);
HXDLIN(  88)									int i4 = (_g12 - 1);
HXDLIN(  88)									{
HXLINE(  88)										 ::haxe::ds::GenericCell_Int l = b3->data->head;
HXDLIN(  88)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  88)										{
HXLINE(  88)											int _g14 = 0;
HXDLIN(  88)											int _g15 = i4;
HXDLIN(  88)											while((_g14 < _g15)){
HXLINE(  88)												_g14 = (_g14 + 1);
HXDLIN(  88)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  88)										if (::hx::IsNull( prev )) {
HXLINE(  88)											b3->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  88)											l = null();
            										}
            										else {
HXLINE(  88)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  88)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  88)					undoImage1 = b3;
            				}
            				break;
            			}
HXDLIN(  88)			this1->image = undoImage1;
HXDLIN(  88)			this1->width = width;
HXDLIN(  88)			this1->height = height;
HXDLIN(  88)			this1->imageType = ( (int)(imageType) );
HXDLIN(  88)			undoImage = this1;
HXDLIN(  88)			{
HXLINE(  88)				int rectLeft = xIter3->start;
HXDLIN(  88)				int rectTop = yIter3->start;
HXDLIN(  88)				int rectRight = xIter3->max;
HXDLIN(  88)				bool forceClear = false;
HXDLIN(  88)				{
HXLINE(  88)					int _g16 = rectTop;
HXDLIN(  88)					int _g17 = yIter3->max;
HXDLIN(  88)					while((_g16 < _g17)){
HXLINE(  88)						_g16 = (_g16 + 1);
HXDLIN(  88)						int dy = (_g16 - 1);
HXDLIN(  88)						{
HXLINE(  88)							int _g18 = rectLeft;
HXDLIN(  88)							int _g19 = rectRight;
HXDLIN(  88)							while((_g18 < _g19)){
HXLINE(  88)								_g18 = (_g18 + 1);
HXDLIN(  88)								int dx = (_g18 - 1);
HXDLIN(  88)								::Dynamic this3 = pixelImage->image;
HXDLIN(  88)								int index;
HXDLIN(  88)								if (pixelImage->useVirtualPos) {
HXLINE(  88)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  88)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN(  88)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  88)								int col;
HXDLIN(  88)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  88)									col = c;
            								}
HXDLIN(  88)								bool _hx_tmp;
HXDLIN(  88)								if (pixelImage->useMask) {
HXLINE(  88)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE(  88)									_hx_tmp = false;
            								}
HXDLIN(  88)								if (_hx_tmp) {
HXLINE(  88)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN(  88)									::Dynamic this5 = this4->image;
HXDLIN(  88)									int index1;
HXDLIN(  88)									if (this4->useVirtualPos) {
HXLINE(  88)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE(  88)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN(  88)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  88)									int v1;
HXDLIN(  88)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE(  88)										v1 = c1;
            									}
HXDLIN(  88)									int maskPixel = v1;
HXDLIN(  88)									int this6 = col;
HXDLIN(  88)									if ((maskPixel == 0)) {
HXLINE(  88)										col = this6;
            									}
            									else {
HXLINE(  88)										Float m0;
HXDLIN(  88)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  88)										if ((this7 == 0)) {
HXLINE(  88)											m0 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float m1;
HXDLIN(  88)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  88)										if ((this8 == 0)) {
HXLINE(  88)											m1 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float m2;
HXDLIN(  88)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  88)										if ((this9 == 0)) {
HXLINE(  88)											m2 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float m3;
HXDLIN(  88)										int this10 = (maskPixel & 255);
HXDLIN(  88)										if ((this10 == 0)) {
HXLINE(  88)											m3 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  88)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  88)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  88)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  88)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  88)								if ((col != 0)) {
HXLINE(  88)									int x1 = (dx - rectLeft);
HXDLIN(  88)									int y1 = (dy - rectTop);
HXDLIN(  88)									int c2 = col;
HXDLIN(  88)									bool _hx_tmp1;
HXDLIN(  88)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  88)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE(  88)										_hx_tmp1 = false;
            									}
HXDLIN(  88)									if (_hx_tmp1) {
HXLINE(  88)										int location;
HXDLIN(  88)										if (undoImage->useVirtualPos) {
HXLINE(  88)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE(  88)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  88)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  88)										int this12;
HXDLIN(  88)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE(  88)											this12 = this11;
            										}
HXDLIN(  88)										Float a11;
HXDLIN(  88)										int this13 = ((this12 >> 24) & 255);
HXDLIN(  88)										if ((this13 == 0)) {
HXLINE(  88)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											a11 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float r1;
HXDLIN(  88)										int this14 = ((this12 >> 16) & 255);
HXDLIN(  88)										if ((this14 == 0)) {
HXLINE(  88)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float g1;
HXDLIN(  88)										int this15 = ((this12 >> 8) & 255);
HXDLIN(  88)										if ((this15 == 0)) {
HXLINE(  88)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float b11;
HXDLIN(  88)										int this16 = (this12 & 255);
HXDLIN(  88)										if ((this16 == 0)) {
HXLINE(  88)											b11 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float a2;
HXDLIN(  88)										int this17 = ((col >> 24) & 255);
HXDLIN(  88)										if ((this17 == 0)) {
HXLINE(  88)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float r2;
HXDLIN(  88)										int this18 = ((col >> 16) & 255);
HXDLIN(  88)										if ((this18 == 0)) {
HXLINE(  88)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float g2;
HXDLIN(  88)										int this19 = ((col >> 8) & 255);
HXDLIN(  88)										if ((this19 == 0)) {
HXLINE(  88)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float b21;
HXDLIN(  88)										int this20 = (col & 255);
HXDLIN(  88)										if ((this20 == 0)) {
HXLINE(  88)											b21 = ((Float)0.);
            										}
            										else {
HXLINE(  88)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  88)										Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  88)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  88)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  88)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  88)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  88)										int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  88)										{
HXLINE(  88)											int _hx_tmp2;
HXDLIN(  88)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  88)												_hx_tmp2 = blended;
            											}
HXDLIN(  88)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE(  88)										::Dynamic this21 = undoImage->image;
HXDLIN(  88)										int index2;
HXDLIN(  88)										if (undoImage->useVirtualPos) {
HXLINE(  88)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE(  88)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  88)										int _hx_tmp3;
HXDLIN(  88)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE(  88)											_hx_tmp3 = c2;
            										}
HXDLIN(  88)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE(  88)									if (forceClear) {
HXLINE(  88)										::Dynamic this22 = undoImage->image;
HXDLIN(  88)										int x2 = (dx - rectLeft);
HXDLIN(  88)										int y2 = (dy - rectTop);
HXDLIN(  88)										int index3;
HXDLIN(  88)										if (undoImage->useVirtualPos) {
HXLINE(  88)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE(  88)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(  88)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  88)		Float s0 = ((ay * cx) - (ax * cy));
HXDLIN(  88)		Float sx = (cy - ay);
HXDLIN(  88)		Float sy = (ax - cx);
HXDLIN(  88)		Float t0 = ((ax * by) - (ay * bx));
HXDLIN(  88)		Float tx = (ay - by);
HXDLIN(  88)		Float ty = (bx - ax);
HXDLIN(  88)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXDLIN(  88)		Float s = ((Float)0.);
HXDLIN(  88)		Float t = ((Float)0.);
HXDLIN(  88)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(5) ));
HXDLIN(  88)		Float omega = (theta / ( (Float)(3) ));
HXDLIN(  88)		Float delta = ((Float)0.7071);
HXDLIN(  88)		Float x0 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  88)		Float y0 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  88)		omega = (omega + theta);
HXDLIN(  88)		Float x11 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  88)		Float y11 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  88)		omega = (omega + theta);
HXDLIN(  88)		Float x21 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  88)		Float y21 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  88)		omega = (omega + theta);
HXDLIN(  88)		Float x3 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  88)		Float y3 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  88)		omega = (omega + theta);
HXDLIN(  88)		Float x4 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN(  88)		Float y4 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN(  88)		Float sxx = ((Float)0.);
HXDLIN(  88)		Float txx = ((Float)0.);
HXDLIN(  88)		Float sxx0 = ((Float)0.);
HXDLIN(  88)		Float sxx1 = ((Float)0.);
HXDLIN(  88)		Float sxx2 = ((Float)0.);
HXDLIN(  88)		Float sxx3 = ((Float)0.);
HXDLIN(  88)		Float sxx4 = ((Float)0.);
HXDLIN(  88)		Float txx0 = ((Float)0.);
HXDLIN(  88)		Float txx1 = ((Float)0.);
HXDLIN(  88)		Float txx2 = ((Float)0.);
HXDLIN(  88)		Float txx3 = ((Float)0.);
HXDLIN(  88)		Float txx4 = ((Float)0.);
HXDLIN(  88)		Float aSum = ((Float)0.);
HXDLIN(  88)		{
HXLINE(  88)			int _g_min = xIter3->start;
HXDLIN(  88)			int _g_max = xIter3->max;
HXDLIN(  88)			while((_g_min < _g_max)){
HXLINE(  88)				_g_min = (_g_min + 1);
HXDLIN(  88)				int px = (_g_min - 1);
HXDLIN(  88)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 223)				sxx = (sx * ( (Float)(px) ));
HXLINE( 224)				txx = (tx * ( (Float)(px) ));
HXLINE( 226)				sxx0 = (sx * (px + x0));
HXLINE( 227)				sxx1 = (sx * (px + x11));
HXLINE( 228)				sxx2 = (sx * (px + x21));
HXLINE( 229)				sxx3 = (sx * (px + x3));
HXLINE( 230)				sxx4 = (sx * (px + x4));
HXLINE( 231)				txx0 = (tx * (px + x0));
HXLINE( 232)				txx1 = (tx * (px + x11));
HXLINE( 233)				txx2 = (tx * (px + x21));
HXLINE( 234)				txx3 = (tx * (px + x3));
HXLINE( 235)				txx4 = (tx * (px + x4));
HXLINE(  88)				{
HXLINE(  88)					int _g_min1 = yIter3->start;
HXDLIN(  88)					int _g_max1 = yIter3->max;
HXDLIN(  88)					while((_g_min1 < _g_max1)){
HXLINE(  88)						_g_min1 = (_g_min1 + 1);
HXDLIN(  88)						int py = (_g_min1 - 1);
HXDLIN(  88)						Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  88)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  88)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  88)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  88)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  88)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  88)						Float min4;
HXDLIN(  88)						if ((ratioA < ratioB)) {
HXLINE(  88)							min4 = ratioA;
            						}
            						else {
HXLINE(  88)							min4 = ratioB;
            						}
HXDLIN(  88)						if (!((min4 < ratioC))) {
HXLINE(  88)							min4 = ratioC;
            						}
HXDLIN(  88)						bool pentagonSampling;
HXDLIN(  88)						if (softAB) {
HXLINE(  88)							if (softBC) {
HXLINE(  88)								if (softCA) {
HXLINE(  88)									pentagonSampling = true;
            								}
            								else {
HXLINE(  88)									if ((min4 != ratioB)) {
HXLINE(  88)										pentagonSampling = (min4 == ratioC);
            									}
            									else {
HXLINE(  88)										pentagonSampling = true;
            									}
            								}
            							}
            							else {
HXLINE(  88)								if (softCA) {
HXLINE(  88)									if ((min4 != ratioA)) {
HXLINE(  88)										pentagonSampling = (min4 == ratioC);
            									}
            									else {
HXLINE(  88)										pentagonSampling = true;
            									}
            								}
            								else {
HXLINE(  88)									pentagonSampling = (min4 == ratioC);
            								}
            							}
            						}
            						else {
HXLINE(  88)							if (softBC) {
HXLINE(  88)								if (softCA) {
HXLINE(  88)									if ((min4 != ratioA)) {
HXLINE(  88)										pentagonSampling = (min4 == ratioB);
            									}
            									else {
HXLINE(  88)										pentagonSampling = true;
            									}
            								}
            								else {
HXLINE(  88)									pentagonSampling = (min4 == ratioB);
            								}
            							}
            							else {
HXLINE(  88)								if (softCA) {
HXLINE(  88)									pentagonSampling = (min4 == ratioA);
            								}
            								else {
HXLINE(  88)									pentagonSampling = false;
            								}
            							}
            						}
HXDLIN(  88)						if (pentagonSampling) {
HXLINE( 276)							aSum = ((Float)0.);
HXLINE( 277)							s = ((s0 + sxx0) + (sy * (py + y0)));
HXLINE( 278)							t = ((t0 + txx0) + (ty * (py + y0)));
HXLINE(  88)							bool _hx_tmp4;
HXDLIN(  88)							if (!((s <= 0))) {
HXLINE(  88)								_hx_tmp4 = (t <= 0);
            							}
            							else {
HXLINE(  88)								_hx_tmp4 = true;
            							}
HXDLIN(  88)							if (!(_hx_tmp4)) {
HXLINE(  88)								if (((s + t) < A)) {
HXLINE(  88)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 280)							s = ((s0 + sxx1) + (sy * (py + y11)));
HXLINE( 281)							t = ((t0 + txx1) + (ty * (py + y11)));
HXLINE(  88)							bool _hx_tmp5;
HXDLIN(  88)							if (!((s <= 0))) {
HXLINE(  88)								_hx_tmp5 = (t <= 0);
            							}
            							else {
HXLINE(  88)								_hx_tmp5 = true;
            							}
HXDLIN(  88)							if (!(_hx_tmp5)) {
HXLINE(  88)								if (((s + t) < A)) {
HXLINE(  88)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 283)							s = ((s0 + sxx2) + (sy * (py + y21)));
HXLINE( 284)							t = ((t0 + txx2) + (ty * (py + y21)));
HXLINE(  88)							bool _hx_tmp6;
HXDLIN(  88)							if (!((s <= 0))) {
HXLINE(  88)								_hx_tmp6 = (t <= 0);
            							}
            							else {
HXLINE(  88)								_hx_tmp6 = true;
            							}
HXDLIN(  88)							if (!(_hx_tmp6)) {
HXLINE(  88)								if (((s + t) < A)) {
HXLINE(  88)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 286)							s = ((s0 + sxx3) + (sy * (py + y3)));
HXLINE( 287)							t = ((t0 + txx3) + (ty * (py + y3)));
HXLINE(  88)							bool _hx_tmp7;
HXDLIN(  88)							if (!((s <= 0))) {
HXLINE(  88)								_hx_tmp7 = (t <= 0);
            							}
            							else {
HXLINE(  88)								_hx_tmp7 = true;
            							}
HXDLIN(  88)							if (!(_hx_tmp7)) {
HXLINE(  88)								if (((s + t) < A)) {
HXLINE(  88)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 289)							s = ((s0 + sxx4) + (sy * (py + y4)));
HXLINE( 290)							t = ((t0 + txx4) + (ty * (py + y4)));
HXLINE(  88)							bool _hx_tmp8;
HXDLIN(  88)							if (!((s <= 0))) {
HXLINE(  88)								_hx_tmp8 = (t <= 0);
            							}
            							else {
HXLINE(  88)								_hx_tmp8 = true;
            							}
HXDLIN(  88)							if (!(_hx_tmp8)) {
HXLINE(  88)								if (((s + t) < A)) {
HXLINE(  88)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXDLIN(  88)							if ((aSum != ((Float)0.))) {
HXLINE(  88)								int a5;
HXDLIN(  88)								if ((aSum > ((Float)0.9))) {
HXLINE(  88)									a5 = a;
            								}
            								else {
HXLINE(  88)									int i6 = ::Std_obj::_hx_int((( (Float)(a) ) * aSum));
HXDLIN(  88)									if ((i6 > 255)) {
HXLINE(  24)										i6 = 255;
            									}
HXLINE(  88)									if ((i6 < 0)) {
HXLINE(  25)										i6 = 0;
            									}
HXLINE(  88)									a5 = i6;
            								}
HXDLIN(  88)								int location1;
HXDLIN(  88)								if (pixelImage->useVirtualPos) {
HXLINE(  88)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  88)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN(  88)								bool _hx_tmp9;
HXDLIN(  88)								if (pixelImage->transparent) {
HXLINE(  88)									_hx_tmp9 = (a5 < 254);
            								}
            								else {
HXLINE(  88)									_hx_tmp9 = false;
            								}
HXDLIN(  88)								if (_hx_tmp9) {
HXLINE(  88)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN(  88)									int old;
HXDLIN(  88)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE(  88)										old = this23;
            									}
HXDLIN(  88)									int rhs = ((((a5 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)									Float a12;
HXDLIN(  88)									int this24 = ((old >> 24) & 255);
HXDLIN(  88)									if ((this24 == 0)) {
HXLINE(  88)										a12 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										a12 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float r11;
HXDLIN(  88)									int this25 = ((old >> 16) & 255);
HXDLIN(  88)									if ((this25 == 0)) {
HXLINE(  88)										r11 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float g11;
HXDLIN(  88)									int this26 = ((old >> 8) & 255);
HXDLIN(  88)									if ((this26 == 0)) {
HXLINE(  88)										g11 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float b12;
HXDLIN(  88)									int this27 = (old & 255);
HXDLIN(  88)									if ((this27 == 0)) {
HXLINE(  88)										b12 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float a21;
HXDLIN(  88)									int this28 = ((rhs >> 24) & 255);
HXDLIN(  88)									if ((this28 == 0)) {
HXLINE(  88)										a21 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float r21;
HXDLIN(  88)									int this29 = ((rhs >> 16) & 255);
HXDLIN(  88)									if ((this29 == 0)) {
HXLINE(  88)										r21 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float g21;
HXDLIN(  88)									int this30 = ((rhs >> 8) & 255);
HXDLIN(  88)									if ((this30 == 0)) {
HXLINE(  88)										g21 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float b22;
HXDLIN(  88)									int this31 = (rhs & 255);
HXDLIN(  88)									if ((this31 == 0)) {
HXLINE(  88)										b22 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN(  88)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  88)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  88)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  88)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  88)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  88)									{
HXLINE(  88)										int _hx_tmp10;
HXDLIN(  88)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)											_hx_tmp10 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE(  88)											_hx_tmp10 = blended1;
            										}
HXDLIN(  88)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp10);
            									}
            								}
            								else {
HXLINE(  88)									int value;
HXDLIN(  88)									if (pixelImage->isLittle) {
HXLINE(  88)										value = ((((a5 << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE(  88)										value = ((((a5 << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN(  88)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
            						}
            						else {
HXLINE(  88)							bool _hx_tmp11;
HXDLIN(  88)							bool _hx_tmp12;
HXDLIN(  88)							if ((ratioA >= 0)) {
HXLINE(  88)								_hx_tmp12 = (ratioB >= 0);
            							}
            							else {
HXLINE(  88)								_hx_tmp12 = false;
            							}
HXDLIN(  88)							if (_hx_tmp12) {
HXLINE(  88)								_hx_tmp11 = (ratioC >= 0);
            							}
            							else {
HXLINE(  88)								_hx_tmp11 = false;
            							}
HXDLIN(  88)							if (_hx_tmp11) {
HXLINE(  88)								int location2;
HXDLIN(  88)								if (pixelImage->useVirtualPos) {
HXLINE(  88)									location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE(  88)									location2 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN(  88)								bool _hx_tmp13;
HXDLIN(  88)								if (pixelImage->transparent) {
HXLINE(  88)									_hx_tmp13 = (a < 254);
            								}
            								else {
HXLINE(  88)									_hx_tmp13 = false;
            								}
HXDLIN(  88)								if (_hx_tmp13) {
HXLINE(  88)									int this32 = ::iterMagic::Iimg_obj::get(pixelImage->image,location2);
HXDLIN(  88)									int old1;
HXDLIN(  88)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)										old1 = ((((((this32 >> 24) & 255) << 24) | ((this32 & 255) << 16)) | (((this32 >> 8) & 255) << 8)) | ((this32 >> 16) & 255));
            									}
            									else {
HXLINE(  88)										old1 = this32;
            									}
HXDLIN(  88)									int rhs1 = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  88)									Float a13;
HXDLIN(  88)									int this33 = ((old1 >> 24) & 255);
HXDLIN(  88)									if ((this33 == 0)) {
HXLINE(  88)										a13 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										a13 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float r12;
HXDLIN(  88)									int this34 = ((old1 >> 16) & 255);
HXDLIN(  88)									if ((this34 == 0)) {
HXLINE(  88)										r12 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										r12 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float g12;
HXDLIN(  88)									int this35 = ((old1 >> 8) & 255);
HXDLIN(  88)									if ((this35 == 0)) {
HXLINE(  88)										g12 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										g12 = (( (Float)(this35) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float b13;
HXDLIN(  88)									int this36 = (old1 & 255);
HXDLIN(  88)									if ((this36 == 0)) {
HXLINE(  88)										b13 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										b13 = (( (Float)(this36) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float a22;
HXDLIN(  88)									int this37 = ((rhs1 >> 24) & 255);
HXDLIN(  88)									if ((this37 == 0)) {
HXLINE(  88)										a22 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										a22 = (( (Float)(this37) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float r22;
HXDLIN(  88)									int this38 = ((rhs1 >> 16) & 255);
HXDLIN(  88)									if ((this38 == 0)) {
HXLINE(  88)										r22 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										r22 = (( (Float)(this38) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float g22;
HXDLIN(  88)									int this39 = ((rhs1 >> 8) & 255);
HXDLIN(  88)									if ((this39 == 0)) {
HXLINE(  88)										g22 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										g22 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float b23;
HXDLIN(  88)									int this40 = (rhs1 & 255);
HXDLIN(  88)									if ((this40 == 0)) {
HXLINE(  88)										b23 = ((Float)0.);
            									}
            									else {
HXLINE(  88)										b23 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN(  88)									Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN(  88)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  88)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  88)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  88)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  88)									int blended2 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN(  88)									{
HXLINE(  88)										int _hx_tmp14;
HXDLIN(  88)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  88)											_hx_tmp14 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXLINE(  88)											_hx_tmp14 = blended2;
            										}
HXDLIN(  88)										::iterMagic::Iimg_obj::set(pixelImage->image,location2,_hx_tmp14);
            									}
            								}
            								else {
HXLINE(  88)									int value1;
HXDLIN(  88)									if (pixelImage->isLittle) {
HXLINE(  88)										value1 = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE(  88)										value1 = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN(  88)									::iterMagic::Iimg_obj::set(pixelImage->image,location2,value1);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  88)		if ((hasHit == false)) {
HXLINE(  88)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN(  88)			if (hasUndo) {
HXLINE(  88)				v2->undoImage = undoImage;
HXDLIN(  88)				v2->undoX = xIter3->start;
HXDLIN(  88)				v2->undoY = yIter3->start;
            			}
HXDLIN(  88)			return v2;
            		}
            		else {
HXLINE(  88)			return null();
            		}
HXDLIN(  88)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixelSmooth_Fields__obj,triPentagonBarycentricBottom,return )

 ::pi_xy::algo::HitTri TriPixelSmooth_Fields__obj::triPentagonBarycentricTop( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_132148ab73c7d3b6_96_triPentagonBarycentricTop)
HXLINE(  99)		bool softAB = true;
HXLINE( 100)		bool softBC = true;
HXLINE( 101)		bool softCA = false;
HXLINE( 102)		bool adjustWinding = (((((ax * by) - (bx * ay)) + ((bx * cy) - (cx * by))) + ((cx * ay) - (ax * cy))) > 0);
HXLINE( 103)		if (!(adjustWinding)) {
HXLINE( 104)			Float bx_ = bx;
HXLINE( 105)			Float by_ = by;
HXLINE( 106)			bx = cx;
HXLINE( 107)			by = cy;
HXLINE( 108)			cx = bx_;
HXLINE( 109)			cy = by_;
HXLINE( 111)			color = -2347260;
HXLINE( 112)			bool softAB1 = true;
HXLINE( 113)			bool softBC1 = false;
HXLINE( 114)			bool softCA1 = true;
            		}
HXLINE( 116)		int a = ((color >> 24) & 255);
HXDLIN( 116)		int r = ((color >> 16) & 255);
HXDLIN( 116)		int g = ((color >> 8) & 255);
HXDLIN( 116)		int b = (color & 255);
HXDLIN( 116)		Float bcx = (bx - cx);
HXDLIN( 116)		Float bcy = (by - cy);
HXDLIN( 116)		Float acx = (ax - cx);
HXDLIN( 116)		Float acy = (ay - cy);
HXDLIN( 116)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 116)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 116)		Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 116)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 116)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 116)		if ((ax > bx)) {
HXLINE( 116)			if ((ax > cx)) {
HXLINE( 116)				int min;
HXDLIN( 116)				if ((bx > cx)) {
HXLINE( 116)					min = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 116)					min = ::Math_obj::floor(bx);
            				}
HXDLIN( 116)				int ii_min = min;
HXDLIN( 116)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 116)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 116)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 116)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 116)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 116)			if ((bx > cx)) {
HXLINE( 116)				int min1;
HXDLIN( 116)				if ((ax > cx)) {
HXLINE( 116)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 116)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 116)				int ii_min2 = min1;
HXDLIN( 116)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 116)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 116)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 116)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 116)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 116)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 116)		if ((ay > by)) {
HXLINE( 116)			if ((ay > cy)) {
HXLINE( 116)				int min2;
HXDLIN( 116)				if ((by > cy)) {
HXLINE( 116)					min2 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 116)					min2 = ::Math_obj::floor(by);
            				}
HXDLIN( 116)				int ii_min4 = min2;
HXDLIN( 116)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 116)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 116)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 116)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 116)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 116)			if ((by > cy)) {
HXLINE( 116)				int min3;
HXDLIN( 116)				if ((ay > cy)) {
HXLINE( 116)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 116)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 116)				int ii_min6 = min3;
HXDLIN( 116)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 116)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 116)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 116)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 116)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 116)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 116)		if (hasUndo) {
HXLINE( 116)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 116)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 116)			 ::Dynamic imageType = null();
HXDLIN( 116)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 116)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 116)			::Dynamic undoImage1;
HXDLIN( 116)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 116)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 116)					 ::iterMagic::BytesImg b1 = byt;
HXDLIN( 116)					{
HXLINE( 116)						b1->width = width;
HXDLIN( 116)						b1->height = height;
HXDLIN( 116)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)						b1->data = ::haxe::io::Bytes_obj::alloc((b1->length * 4));
HXDLIN( 116)						{
HXLINE( 116)							int len = b1->length;
HXDLIN( 116)							int w = 0;
HXDLIN( 116)							{
HXLINE( 116)								int _g = 0;
HXDLIN( 116)								int _g1 = b1->height;
HXDLIN( 116)								while((_g < _g1)){
HXLINE( 116)									_g = (_g + 1);
HXDLIN( 116)									int y = (_g - 1);
HXDLIN( 116)									{
HXLINE( 116)										int _g2 = 0;
HXDLIN( 116)										int _g3 = b1->width;
HXDLIN( 116)										while((_g2 < _g3)){
HXLINE( 116)											_g2 = (_g2 + 1);
HXDLIN( 116)											int x = (_g2 - 1);
HXDLIN( 116)											{
HXLINE( 116)												w = (w + 1);
HXDLIN( 116)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 116)											{
HXLINE( 116)												w = (w + 1);
HXDLIN( 116)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 116)											{
HXLINE( 116)												w = (w + 1);
HXDLIN( 116)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 116)											{
HXLINE( 116)												w = (w + 1);
HXDLIN( 116)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 116)					undoImage1 = b1;
            				}
            				break;
            				case (int)1: {
HXLINE( 116)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)					 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 116)					{
HXLINE( 116)						a1->width = width;
HXDLIN( 116)						a1->height = height;
HXDLIN( 116)						a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 116)						a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)						{
HXLINE( 116)							int _g4 = 0;
HXDLIN( 116)							int _g5 = a1->length;
HXDLIN( 116)							while((_g4 < _g5)){
HXLINE( 116)								_g4 = (_g4 + 1);
HXDLIN( 116)								int i = (_g4 - 1);
HXDLIN( 116)								a1->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 116)					undoImage1 = a1;
            				}
            				break;
            				case (int)2: {
HXLINE( 116)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 116)					 ::iterMagic::U32ArrImg b2 = u32a;
HXDLIN( 116)					{
HXLINE( 116)						b2->width = width;
HXDLIN( 116)						b2->height = height;
HXDLIN( 116)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)						int size = (b2->length * 4);
HXDLIN( 116)						b2->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 116)						{
HXLINE( 116)							int _g6 = 0;
HXDLIN( 116)							int _g7 = b2->length;
HXDLIN( 116)							while((_g6 < _g7)){
HXLINE( 116)								_g6 = (_g6 + 1);
HXDLIN( 116)								int i1 = (_g6 - 1);
HXDLIN( 116)								{
HXLINE( 116)									 ::haxe::io::ArrayBufferViewImpl this2 = b2->data;
HXDLIN( 116)									bool undoImage2;
HXDLIN( 116)									if ((i1 >= 0)) {
HXLINE( 116)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 116)										undoImage2 = false;
            									}
HXDLIN( 116)									if (undoImage2) {
HXLINE( 116)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 116)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 116)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 116)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 116)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 116)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 116)					undoImage1 = b2;
            				}
            				break;
            				case (int)3: {
HXLINE( 116)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 116)					{
HXLINE( 116)						v->width = width;
HXDLIN( 116)						v->height = height;
HXDLIN( 116)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 116)						{
HXLINE( 116)							int _g8 = 0;
HXDLIN( 116)							int _g9 = v->length;
HXDLIN( 116)							while((_g8 < _g9)){
HXLINE( 116)								_g8 = (_g8 + 1);
HXDLIN( 116)								int i2 = (_g8 - 1);
HXDLIN( 116)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 116)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 116)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 116)					 ::iterMagic::StackIntImg b3 = sInt;
HXDLIN( 116)					{
HXLINE( 116)						b3->width = width;
HXDLIN( 116)						b3->height = height;
HXDLIN( 116)						b3->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 116)						b3->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 116)						{
HXLINE( 116)							int len1 = b3->length;
HXDLIN( 116)							 ::haxe::ds::GenericStack_Int d = b3->data;
HXDLIN( 116)							if (::hx::IsNull( d->head )) {
HXLINE( 116)								int _g10 = 0;
HXDLIN( 116)								int _g11 = len1;
HXDLIN( 116)								while((_g10 < _g11)){
HXLINE( 116)									_g10 = (_g10 + 1);
HXDLIN( 116)									int i3 = (_g10 - 1);
HXDLIN( 116)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 116)								int _g12 = 0;
HXDLIN( 116)								int _g13 = len1;
HXDLIN( 116)								while((_g12 < _g13)){
HXLINE( 116)									_g12 = (_g12 + 1);
HXDLIN( 116)									int i4 = (_g12 - 1);
HXDLIN( 116)									{
HXLINE( 116)										 ::haxe::ds::GenericCell_Int l = b3->data->head;
HXDLIN( 116)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 116)										{
HXLINE( 116)											int _g14 = 0;
HXDLIN( 116)											int _g15 = i4;
HXDLIN( 116)											while((_g14 < _g15)){
HXLINE( 116)												_g14 = (_g14 + 1);
HXDLIN( 116)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 116)										if (::hx::IsNull( prev )) {
HXLINE( 116)											b3->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 116)											l = null();
            										}
            										else {
HXLINE( 116)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 116)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 116)					undoImage1 = b3;
            				}
            				break;
            			}
HXDLIN( 116)			this1->image = undoImage1;
HXDLIN( 116)			this1->width = width;
HXDLIN( 116)			this1->height = height;
HXDLIN( 116)			this1->imageType = ( (int)(imageType) );
HXDLIN( 116)			undoImage = this1;
HXDLIN( 116)			{
HXLINE( 116)				int rectLeft = xIter3->start;
HXDLIN( 116)				int rectTop = yIter3->start;
HXDLIN( 116)				int rectRight = xIter3->max;
HXDLIN( 116)				bool forceClear = false;
HXDLIN( 116)				{
HXLINE( 116)					int _g16 = rectTop;
HXDLIN( 116)					int _g17 = yIter3->max;
HXDLIN( 116)					while((_g16 < _g17)){
HXLINE( 116)						_g16 = (_g16 + 1);
HXDLIN( 116)						int dy = (_g16 - 1);
HXDLIN( 116)						{
HXLINE( 116)							int _g18 = rectLeft;
HXDLIN( 116)							int _g19 = rectRight;
HXDLIN( 116)							while((_g18 < _g19)){
HXLINE( 116)								_g18 = (_g18 + 1);
HXDLIN( 116)								int dx = (_g18 - 1);
HXDLIN( 116)								::Dynamic this3 = pixelImage->image;
HXDLIN( 116)								int index;
HXDLIN( 116)								if (pixelImage->useVirtualPos) {
HXLINE( 116)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 116)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 116)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 116)								int col;
HXDLIN( 116)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 116)									col = c;
            								}
HXDLIN( 116)								bool _hx_tmp;
HXDLIN( 116)								if (pixelImage->useMask) {
HXLINE( 116)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 116)									_hx_tmp = false;
            								}
HXDLIN( 116)								if (_hx_tmp) {
HXLINE( 116)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 116)									::Dynamic this5 = this4->image;
HXDLIN( 116)									int index1;
HXDLIN( 116)									if (this4->useVirtualPos) {
HXLINE( 116)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 116)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 116)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 116)									int v1;
HXDLIN( 116)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 116)										v1 = c1;
            									}
HXDLIN( 116)									int maskPixel = v1;
HXDLIN( 116)									int this6 = col;
HXDLIN( 116)									if ((maskPixel == 0)) {
HXLINE( 116)										col = this6;
            									}
            									else {
HXLINE( 116)										Float m0;
HXDLIN( 116)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 116)										if ((this7 == 0)) {
HXLINE( 116)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float m1;
HXDLIN( 116)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 116)										if ((this8 == 0)) {
HXLINE( 116)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float m2;
HXDLIN( 116)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 116)										if ((this9 == 0)) {
HXLINE( 116)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float m3;
HXDLIN( 116)										int this10 = (maskPixel & 255);
HXDLIN( 116)										if ((this10 == 0)) {
HXLINE( 116)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 116)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 116)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 116)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 116)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 116)								if ((col != 0)) {
HXLINE( 116)									int x1 = (dx - rectLeft);
HXDLIN( 116)									int y1 = (dy - rectTop);
HXDLIN( 116)									int c2 = col;
HXDLIN( 116)									bool _hx_tmp1;
HXDLIN( 116)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 116)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 116)										_hx_tmp1 = false;
            									}
HXDLIN( 116)									if (_hx_tmp1) {
HXLINE( 116)										int location;
HXDLIN( 116)										if (undoImage->useVirtualPos) {
HXLINE( 116)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 116)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 116)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 116)										int this12;
HXDLIN( 116)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 116)											this12 = this11;
            										}
HXDLIN( 116)										Float a11;
HXDLIN( 116)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 116)										if ((this13 == 0)) {
HXLINE( 116)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											a11 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float r1;
HXDLIN( 116)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 116)										if ((this14 == 0)) {
HXLINE( 116)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float g1;
HXDLIN( 116)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 116)										if ((this15 == 0)) {
HXLINE( 116)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float b11;
HXDLIN( 116)										int this16 = (this12 & 255);
HXDLIN( 116)										if ((this16 == 0)) {
HXLINE( 116)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float a2;
HXDLIN( 116)										int this17 = ((col >> 24) & 255);
HXDLIN( 116)										if ((this17 == 0)) {
HXLINE( 116)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float r2;
HXDLIN( 116)										int this18 = ((col >> 16) & 255);
HXDLIN( 116)										if ((this18 == 0)) {
HXLINE( 116)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float g2;
HXDLIN( 116)										int this19 = ((col >> 8) & 255);
HXDLIN( 116)										if ((this19 == 0)) {
HXLINE( 116)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float b21;
HXDLIN( 116)										int this20 = (col & 255);
HXDLIN( 116)										if ((this20 == 0)) {
HXLINE( 116)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 116)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 116)										Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 116)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 116)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 116)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 116)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 116)										int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 116)										{
HXLINE( 116)											int _hx_tmp2;
HXDLIN( 116)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 116)												_hx_tmp2 = blended;
            											}
HXDLIN( 116)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 116)										::Dynamic this21 = undoImage->image;
HXDLIN( 116)										int index2;
HXDLIN( 116)										if (undoImage->useVirtualPos) {
HXLINE( 116)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 116)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 116)										int _hx_tmp3;
HXDLIN( 116)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 116)											_hx_tmp3 = c2;
            										}
HXDLIN( 116)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 116)									if (forceClear) {
HXLINE( 116)										::Dynamic this22 = undoImage->image;
HXDLIN( 116)										int x2 = (dx - rectLeft);
HXDLIN( 116)										int y2 = (dy - rectTop);
HXDLIN( 116)										int index3;
HXDLIN( 116)										if (undoImage->useVirtualPos) {
HXLINE( 116)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 116)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 116)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 116)		Float s0 = ((ay * cx) - (ax * cy));
HXDLIN( 116)		Float sx = (cy - ay);
HXDLIN( 116)		Float sy = (ax - cx);
HXDLIN( 116)		Float t0 = ((ax * by) - (ay * bx));
HXDLIN( 116)		Float tx = (ay - by);
HXDLIN( 116)		Float ty = (bx - ax);
HXDLIN( 116)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXDLIN( 116)		Float s = ((Float)0.);
HXDLIN( 116)		Float t = ((Float)0.);
HXDLIN( 116)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(5) ));
HXDLIN( 116)		Float omega = (theta / ( (Float)(3) ));
HXDLIN( 116)		Float delta = ((Float)0.7071);
HXDLIN( 116)		Float x0 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN( 116)		Float y0 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN( 116)		omega = (omega + theta);
HXDLIN( 116)		Float x11 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN( 116)		Float y11 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN( 116)		omega = (omega + theta);
HXDLIN( 116)		Float x21 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN( 116)		Float y21 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN( 116)		omega = (omega + theta);
HXDLIN( 116)		Float x3 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN( 116)		Float y3 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN( 116)		omega = (omega + theta);
HXDLIN( 116)		Float x4 = (delta * ::Math_obj::cos((theta + omega)));
HXDLIN( 116)		Float y4 = (delta * ::Math_obj::sin((theta + omega)));
HXDLIN( 116)		Float sxx = ((Float)0.);
HXDLIN( 116)		Float txx = ((Float)0.);
HXDLIN( 116)		Float sxx0 = ((Float)0.);
HXDLIN( 116)		Float sxx1 = ((Float)0.);
HXDLIN( 116)		Float sxx2 = ((Float)0.);
HXDLIN( 116)		Float sxx3 = ((Float)0.);
HXDLIN( 116)		Float sxx4 = ((Float)0.);
HXDLIN( 116)		Float txx0 = ((Float)0.);
HXDLIN( 116)		Float txx1 = ((Float)0.);
HXDLIN( 116)		Float txx2 = ((Float)0.);
HXDLIN( 116)		Float txx3 = ((Float)0.);
HXDLIN( 116)		Float txx4 = ((Float)0.);
HXDLIN( 116)		Float aSum = ((Float)0.);
HXDLIN( 116)		{
HXLINE( 116)			int _g_min = xIter3->start;
HXDLIN( 116)			int _g_max = xIter3->max;
HXDLIN( 116)			while((_g_min < _g_max)){
HXLINE( 116)				_g_min = (_g_min + 1);
HXDLIN( 116)				int px = (_g_min - 1);
HXDLIN( 116)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 223)				sxx = (sx * ( (Float)(px) ));
HXLINE( 224)				txx = (tx * ( (Float)(px) ));
HXLINE( 226)				sxx0 = (sx * (px + x0));
HXLINE( 227)				sxx1 = (sx * (px + x11));
HXLINE( 228)				sxx2 = (sx * (px + x21));
HXLINE( 229)				sxx3 = (sx * (px + x3));
HXLINE( 230)				sxx4 = (sx * (px + x4));
HXLINE( 231)				txx0 = (tx * (px + x0));
HXLINE( 232)				txx1 = (tx * (px + x11));
HXLINE( 233)				txx2 = (tx * (px + x21));
HXLINE( 234)				txx3 = (tx * (px + x3));
HXLINE( 235)				txx4 = (tx * (px + x4));
HXLINE( 116)				{
HXLINE( 116)					int _g_min1 = yIter3->start;
HXDLIN( 116)					int _g_max1 = yIter3->max;
HXDLIN( 116)					while((_g_min1 < _g_max1)){
HXLINE( 116)						_g_min1 = (_g_min1 + 1);
HXDLIN( 116)						int py = (_g_min1 - 1);
HXDLIN( 116)						Float pcy = (( (Float)(py) ) - cy);
HXDLIN( 116)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 116)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 116)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 116)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 116)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 116)						Float min4;
HXDLIN( 116)						if ((ratioA < ratioB)) {
HXLINE( 116)							min4 = ratioA;
            						}
            						else {
HXLINE( 116)							min4 = ratioB;
            						}
HXDLIN( 116)						if (!((min4 < ratioC))) {
HXLINE( 116)							min4 = ratioC;
            						}
HXDLIN( 116)						bool pentagonSampling;
HXDLIN( 116)						if (softAB) {
HXLINE( 116)							if (softBC) {
HXLINE( 116)								if (softCA) {
HXLINE( 116)									pentagonSampling = true;
            								}
            								else {
HXLINE( 116)									if ((min4 != ratioB)) {
HXLINE( 116)										pentagonSampling = (min4 == ratioC);
            									}
            									else {
HXLINE( 116)										pentagonSampling = true;
            									}
            								}
            							}
            							else {
HXLINE( 116)								if (softCA) {
HXLINE( 116)									if ((min4 != ratioA)) {
HXLINE( 116)										pentagonSampling = (min4 == ratioC);
            									}
            									else {
HXLINE( 116)										pentagonSampling = true;
            									}
            								}
            								else {
HXLINE( 116)									pentagonSampling = (min4 == ratioC);
            								}
            							}
            						}
            						else {
HXLINE( 116)							if (softBC) {
HXLINE( 116)								if (softCA) {
HXLINE( 116)									if ((min4 != ratioA)) {
HXLINE( 116)										pentagonSampling = (min4 == ratioB);
            									}
            									else {
HXLINE( 116)										pentagonSampling = true;
            									}
            								}
            								else {
HXLINE( 116)									pentagonSampling = (min4 == ratioB);
            								}
            							}
            							else {
HXLINE( 116)								if (softCA) {
HXLINE( 116)									pentagonSampling = (min4 == ratioA);
            								}
            								else {
HXLINE( 116)									pentagonSampling = false;
            								}
            							}
            						}
HXDLIN( 116)						if (pentagonSampling) {
HXLINE( 276)							aSum = ((Float)0.);
HXLINE( 277)							s = ((s0 + sxx0) + (sy * (py + y0)));
HXLINE( 278)							t = ((t0 + txx0) + (ty * (py + y0)));
HXLINE( 116)							bool _hx_tmp4;
HXDLIN( 116)							if (!((s <= 0))) {
HXLINE( 116)								_hx_tmp4 = (t <= 0);
            							}
            							else {
HXLINE( 116)								_hx_tmp4 = true;
            							}
HXDLIN( 116)							if (!(_hx_tmp4)) {
HXLINE( 116)								if (((s + t) < A)) {
HXLINE( 116)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 280)							s = ((s0 + sxx1) + (sy * (py + y11)));
HXLINE( 281)							t = ((t0 + txx1) + (ty * (py + y11)));
HXLINE( 116)							bool _hx_tmp5;
HXDLIN( 116)							if (!((s <= 0))) {
HXLINE( 116)								_hx_tmp5 = (t <= 0);
            							}
            							else {
HXLINE( 116)								_hx_tmp5 = true;
            							}
HXDLIN( 116)							if (!(_hx_tmp5)) {
HXLINE( 116)								if (((s + t) < A)) {
HXLINE( 116)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 283)							s = ((s0 + sxx2) + (sy * (py + y21)));
HXLINE( 284)							t = ((t0 + txx2) + (ty * (py + y21)));
HXLINE( 116)							bool _hx_tmp6;
HXDLIN( 116)							if (!((s <= 0))) {
HXLINE( 116)								_hx_tmp6 = (t <= 0);
            							}
            							else {
HXLINE( 116)								_hx_tmp6 = true;
            							}
HXDLIN( 116)							if (!(_hx_tmp6)) {
HXLINE( 116)								if (((s + t) < A)) {
HXLINE( 116)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 286)							s = ((s0 + sxx3) + (sy * (py + y3)));
HXLINE( 287)							t = ((t0 + txx3) + (ty * (py + y3)));
HXLINE( 116)							bool _hx_tmp7;
HXDLIN( 116)							if (!((s <= 0))) {
HXLINE( 116)								_hx_tmp7 = (t <= 0);
            							}
            							else {
HXLINE( 116)								_hx_tmp7 = true;
            							}
HXDLIN( 116)							if (!(_hx_tmp7)) {
HXLINE( 116)								if (((s + t) < A)) {
HXLINE( 116)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 289)							s = ((s0 + sxx4) + (sy * (py + y4)));
HXLINE( 290)							t = ((t0 + txx4) + (ty * (py + y4)));
HXLINE( 116)							bool _hx_tmp8;
HXDLIN( 116)							if (!((s <= 0))) {
HXLINE( 116)								_hx_tmp8 = (t <= 0);
            							}
            							else {
HXLINE( 116)								_hx_tmp8 = true;
            							}
HXDLIN( 116)							if (!(_hx_tmp8)) {
HXLINE( 116)								if (((s + t) < A)) {
HXLINE( 116)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXDLIN( 116)							if ((aSum != ((Float)0.))) {
HXLINE( 116)								int a5;
HXDLIN( 116)								if ((aSum > ((Float)0.9))) {
HXLINE( 116)									a5 = a;
            								}
            								else {
HXLINE( 116)									int i6 = ::Std_obj::_hx_int((( (Float)(a) ) * aSum));
HXDLIN( 116)									if ((i6 > 255)) {
HXLINE(  24)										i6 = 255;
            									}
HXLINE( 116)									if ((i6 < 0)) {
HXLINE(  25)										i6 = 0;
            									}
HXLINE( 116)									a5 = i6;
            								}
HXDLIN( 116)								int location1;
HXDLIN( 116)								if (pixelImage->useVirtualPos) {
HXLINE( 116)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 116)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 116)								bool _hx_tmp9;
HXDLIN( 116)								if (pixelImage->transparent) {
HXLINE( 116)									_hx_tmp9 = (a5 < 254);
            								}
            								else {
HXLINE( 116)									_hx_tmp9 = false;
            								}
HXDLIN( 116)								if (_hx_tmp9) {
HXLINE( 116)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 116)									int old;
HXDLIN( 116)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE( 116)										old = this23;
            									}
HXDLIN( 116)									int rhs = ((((a5 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 116)									Float a12;
HXDLIN( 116)									int this24 = ((old >> 24) & 255);
HXDLIN( 116)									if ((this24 == 0)) {
HXLINE( 116)										a12 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										a12 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float r11;
HXDLIN( 116)									int this25 = ((old >> 16) & 255);
HXDLIN( 116)									if ((this25 == 0)) {
HXLINE( 116)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float g11;
HXDLIN( 116)									int this26 = ((old >> 8) & 255);
HXDLIN( 116)									if ((this26 == 0)) {
HXLINE( 116)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float b12;
HXDLIN( 116)									int this27 = (old & 255);
HXDLIN( 116)									if ((this27 == 0)) {
HXLINE( 116)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float a21;
HXDLIN( 116)									int this28 = ((rhs >> 24) & 255);
HXDLIN( 116)									if ((this28 == 0)) {
HXLINE( 116)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float r21;
HXDLIN( 116)									int this29 = ((rhs >> 16) & 255);
HXDLIN( 116)									if ((this29 == 0)) {
HXLINE( 116)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float g21;
HXDLIN( 116)									int this30 = ((rhs >> 8) & 255);
HXDLIN( 116)									if ((this30 == 0)) {
HXLINE( 116)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float b22;
HXDLIN( 116)									int this31 = (rhs & 255);
HXDLIN( 116)									if ((this31 == 0)) {
HXLINE( 116)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 116)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 116)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 116)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 116)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 116)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 116)									{
HXLINE( 116)										int _hx_tmp10;
HXDLIN( 116)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)											_hx_tmp10 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 116)											_hx_tmp10 = blended1;
            										}
HXDLIN( 116)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp10);
            									}
            								}
            								else {
HXLINE( 116)									int value;
HXDLIN( 116)									if (pixelImage->isLittle) {
HXLINE( 116)										value = ((((a5 << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE( 116)										value = ((((a5 << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN( 116)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
            						}
            						else {
HXLINE( 116)							bool _hx_tmp11;
HXDLIN( 116)							bool _hx_tmp12;
HXDLIN( 116)							if ((ratioA >= 0)) {
HXLINE( 116)								_hx_tmp12 = (ratioB >= 0);
            							}
            							else {
HXLINE( 116)								_hx_tmp12 = false;
            							}
HXDLIN( 116)							if (_hx_tmp12) {
HXLINE( 116)								_hx_tmp11 = (ratioC >= 0);
            							}
            							else {
HXLINE( 116)								_hx_tmp11 = false;
            							}
HXDLIN( 116)							if (_hx_tmp11) {
HXLINE( 116)								int location2;
HXDLIN( 116)								if (pixelImage->useVirtualPos) {
HXLINE( 116)									location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 116)									location2 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 116)								bool _hx_tmp13;
HXDLIN( 116)								if (pixelImage->transparent) {
HXLINE( 116)									_hx_tmp13 = (a < 254);
            								}
            								else {
HXLINE( 116)									_hx_tmp13 = false;
            								}
HXDLIN( 116)								if (_hx_tmp13) {
HXLINE( 116)									int this32 = ::iterMagic::Iimg_obj::get(pixelImage->image,location2);
HXDLIN( 116)									int old1;
HXDLIN( 116)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)										old1 = ((((((this32 >> 24) & 255) << 24) | ((this32 & 255) << 16)) | (((this32 >> 8) & 255) << 8)) | ((this32 >> 16) & 255));
            									}
            									else {
HXLINE( 116)										old1 = this32;
            									}
HXDLIN( 116)									int rhs1 = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 116)									Float a13;
HXDLIN( 116)									int this33 = ((old1 >> 24) & 255);
HXDLIN( 116)									if ((this33 == 0)) {
HXLINE( 116)										a13 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										a13 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float r12;
HXDLIN( 116)									int this34 = ((old1 >> 16) & 255);
HXDLIN( 116)									if ((this34 == 0)) {
HXLINE( 116)										r12 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										r12 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float g12;
HXDLIN( 116)									int this35 = ((old1 >> 8) & 255);
HXDLIN( 116)									if ((this35 == 0)) {
HXLINE( 116)										g12 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										g12 = (( (Float)(this35) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float b13;
HXDLIN( 116)									int this36 = (old1 & 255);
HXDLIN( 116)									if ((this36 == 0)) {
HXLINE( 116)										b13 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										b13 = (( (Float)(this36) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float a22;
HXDLIN( 116)									int this37 = ((rhs1 >> 24) & 255);
HXDLIN( 116)									if ((this37 == 0)) {
HXLINE( 116)										a22 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										a22 = (( (Float)(this37) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float r22;
HXDLIN( 116)									int this38 = ((rhs1 >> 16) & 255);
HXDLIN( 116)									if ((this38 == 0)) {
HXLINE( 116)										r22 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										r22 = (( (Float)(this38) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float g22;
HXDLIN( 116)									int this39 = ((rhs1 >> 8) & 255);
HXDLIN( 116)									if ((this39 == 0)) {
HXLINE( 116)										g22 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										g22 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float b23;
HXDLIN( 116)									int this40 = (rhs1 & 255);
HXDLIN( 116)									if ((this40 == 0)) {
HXLINE( 116)										b23 = ((Float)0.);
            									}
            									else {
HXLINE( 116)										b23 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN( 116)									Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 116)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 116)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 116)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 116)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 116)									int blended2 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 116)									{
HXLINE( 116)										int _hx_tmp14;
HXDLIN( 116)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 116)											_hx_tmp14 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXLINE( 116)											_hx_tmp14 = blended2;
            										}
HXDLIN( 116)										::iterMagic::Iimg_obj::set(pixelImage->image,location2,_hx_tmp14);
            									}
            								}
            								else {
HXLINE( 116)									int value1;
HXDLIN( 116)									if (pixelImage->isLittle) {
HXLINE( 116)										value1 = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE( 116)										value1 = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN( 116)									::iterMagic::Iimg_obj::set(pixelImage->image,location2,value1);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 116)		if ((hasHit == false)) {
HXLINE( 116)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 116)			if (hasUndo) {
HXLINE( 116)				v2->undoImage = undoImage;
HXDLIN( 116)				v2->undoX = xIter3->start;
HXDLIN( 116)				v2->undoY = yIter3->start;
            			}
HXDLIN( 116)			return v2;
            		}
            		else {
HXLINE( 116)			return null();
            		}
HXDLIN( 116)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TriPixelSmooth_Fields__obj,triPentagonBarycentricTop,return )

 ::pi_xy::algo::HitTri TriPixelSmooth_Fields__obj::triPentagonBarycentic( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCA,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCA = __o_softCA.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_132148ab73c7d3b6_128_triPentagonBarycentic)
HXLINE( 130)		int a = ((color >> 24) & 255);
HXLINE( 131)		int r = ((color >> 16) & 255);
HXLINE( 132)		int g = ((color >> 8) & 255);
HXLINE( 133)		int b = (color & 255);
HXLINE( 136)		Float bcx = (bx - cx);
HXLINE( 137)		Float bcy = (by - cy);
HXLINE( 138)		Float acx = (ax - cx);
HXLINE( 139)		Float acy = (ay - cy);
HXLINE( 141)		Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXLINE( 142)		Float dot12 = ((bcx * acx) + (bcy * acy));
HXLINE( 143)		Float dot22 = ((acx * acx) + (acy * acy));
HXLINE( 144)		Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXLINE( 146)		Float min = ( (Float)(0) );
HXLINE( 151)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 151)		if ((ax > bx)) {
HXLINE( 151)			if ((ax > cx)) {
HXLINE( 151)				int min1;
HXDLIN( 151)				if ((bx > cx)) {
HXLINE( 151)					min1 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 151)					min1 = ::Math_obj::floor(bx);
            				}
HXDLIN( 151)				int ii_min = min1;
HXDLIN( 151)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 151)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 151)				int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 151)				int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 151)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 151)			if ((bx > cx)) {
HXLINE( 151)				int min2;
HXDLIN( 151)				if ((ax > cx)) {
HXLINE( 151)					min2 = ::Math_obj::floor(cx);
            				}
            				else {
HXLINE( 151)					min2 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 151)				int ii_min2 = min2;
HXDLIN( 151)				int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 151)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 151)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 151)				int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 151)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXLINE( 152)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 152)		if ((ay > by)) {
HXLINE( 152)			if ((ay > cy)) {
HXLINE( 152)				int min3;
HXDLIN( 152)				if ((by > cy)) {
HXLINE( 152)					min3 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 152)					min3 = ::Math_obj::floor(by);
            				}
HXDLIN( 152)				int ii_min4 = min3;
HXDLIN( 152)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 152)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 152)				int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 152)				int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 152)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 152)			if ((by > cy)) {
HXLINE( 152)				int min4;
HXDLIN( 152)				if ((ay > cy)) {
HXLINE( 152)					min4 = ::Math_obj::floor(cy);
            				}
            				else {
HXLINE( 152)					min4 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 152)				int ii_min6 = min4;
HXDLIN( 152)				int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 152)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 152)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 152)				int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 152)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXLINE( 155)		 ::pi_xy::ImageStruct undoImage = null();
HXLINE( 156)		if (hasUndo) {
HXLINE( 157)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 157)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 157)			 ::Dynamic imageType = null();
HXDLIN( 157)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 157)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 157)			::Dynamic undoImage1;
HXDLIN( 157)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 157)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 157)					 ::iterMagic::BytesImg b1 = byt;
HXDLIN( 157)					{
HXLINE( 157)						b1->width = width;
HXDLIN( 157)						b1->height = height;
HXDLIN( 157)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 157)						b1->data = ::haxe::io::Bytes_obj::alloc((b1->length * 4));
HXDLIN( 157)						{
HXLINE( 157)							int len = b1->length;
HXDLIN( 157)							int w = 0;
HXDLIN( 157)							{
HXLINE( 157)								int _g = 0;
HXDLIN( 157)								int _g1 = b1->height;
HXDLIN( 157)								while((_g < _g1)){
HXLINE( 157)									_g = (_g + 1);
HXDLIN( 157)									int y = (_g - 1);
HXDLIN( 157)									{
HXLINE( 157)										int _g2 = 0;
HXDLIN( 157)										int _g3 = b1->width;
HXDLIN( 157)										while((_g2 < _g3)){
HXLINE( 157)											_g2 = (_g2 + 1);
HXDLIN( 157)											int x = (_g2 - 1);
HXDLIN( 157)											{
HXLINE( 157)												w = (w + 1);
HXDLIN( 157)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 157)											{
HXLINE( 157)												w = (w + 1);
HXDLIN( 157)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 157)											{
HXLINE( 157)												w = (w + 1);
HXDLIN( 157)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 157)											{
HXLINE( 157)												w = (w + 1);
HXDLIN( 157)												b1->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 157)					undoImage1 = b1;
            				}
            				break;
            				case (int)1: {
HXLINE( 157)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 157)					 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 157)					{
HXLINE( 157)						a1->width = width;
HXDLIN( 157)						a1->height = height;
HXDLIN( 157)						a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 157)						a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 157)						{
HXLINE( 157)							int _g4 = 0;
HXDLIN( 157)							int _g5 = a1->length;
HXDLIN( 157)							while((_g4 < _g5)){
HXLINE( 157)								_g4 = (_g4 + 1);
HXDLIN( 157)								int i = (_g4 - 1);
HXDLIN( 157)								a1->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 157)					undoImage1 = a1;
            				}
            				break;
            				case (int)2: {
HXLINE( 157)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 157)					 ::iterMagic::U32ArrImg b2 = u32a;
HXDLIN( 157)					{
HXLINE( 157)						b2->width = width;
HXDLIN( 157)						b2->height = height;
HXDLIN( 157)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 157)						int size = (b2->length * 4);
HXDLIN( 157)						b2->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 157)						{
HXLINE( 157)							int _g6 = 0;
HXDLIN( 157)							int _g7 = b2->length;
HXDLIN( 157)							while((_g6 < _g7)){
HXLINE( 157)								_g6 = (_g6 + 1);
HXDLIN( 157)								int i1 = (_g6 - 1);
HXDLIN( 157)								{
HXLINE( 157)									 ::haxe::io::ArrayBufferViewImpl this2 = b2->data;
HXDLIN( 157)									bool undoImage2;
HXDLIN( 157)									if ((i1 >= 0)) {
HXLINE( 157)										undoImage2 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE( 157)										undoImage2 = false;
            									}
HXDLIN( 157)									if (undoImage2) {
HXLINE( 157)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 157)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 157)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 157)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 157)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 157)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 157)					undoImage1 = b2;
            				}
            				break;
            				case (int)3: {
HXLINE( 157)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 157)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 157)					{
HXLINE( 157)						v->width = width;
HXDLIN( 157)						v->height = height;
HXDLIN( 157)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 157)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 157)						{
HXLINE( 157)							int _g8 = 0;
HXDLIN( 157)							int _g9 = v->length;
HXDLIN( 157)							while((_g8 < _g9)){
HXLINE( 157)								_g8 = (_g8 + 1);
HXDLIN( 157)								int i2 = (_g8 - 1);
HXDLIN( 157)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 157)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 157)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 157)					 ::iterMagic::StackIntImg b3 = sInt;
HXDLIN( 157)					{
HXLINE( 157)						b3->width = width;
HXDLIN( 157)						b3->height = height;
HXDLIN( 157)						b3->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 157)						b3->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 157)						{
HXLINE( 157)							int len1 = b3->length;
HXDLIN( 157)							 ::haxe::ds::GenericStack_Int d = b3->data;
HXDLIN( 157)							if (::hx::IsNull( d->head )) {
HXLINE( 157)								int _g10 = 0;
HXDLIN( 157)								int _g11 = len1;
HXDLIN( 157)								while((_g10 < _g11)){
HXLINE( 157)									_g10 = (_g10 + 1);
HXDLIN( 157)									int i3 = (_g10 - 1);
HXDLIN( 157)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 157)								int _g12 = 0;
HXDLIN( 157)								int _g13 = len1;
HXDLIN( 157)								while((_g12 < _g13)){
HXLINE( 157)									_g12 = (_g12 + 1);
HXDLIN( 157)									int i4 = (_g12 - 1);
HXDLIN( 157)									{
HXLINE( 157)										 ::haxe::ds::GenericCell_Int l = b3->data->head;
HXDLIN( 157)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 157)										{
HXLINE( 157)											int _g14 = 0;
HXDLIN( 157)											int _g15 = i4;
HXDLIN( 157)											while((_g14 < _g15)){
HXLINE( 157)												_g14 = (_g14 + 1);
HXDLIN( 157)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 157)										if (::hx::IsNull( prev )) {
HXLINE( 157)											b3->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 157)											l = null();
            										}
            										else {
HXLINE( 157)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 157)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 157)					undoImage1 = b3;
            				}
            				break;
            			}
HXDLIN( 157)			this1->image = undoImage1;
HXDLIN( 157)			this1->width = width;
HXDLIN( 157)			this1->height = height;
HXDLIN( 157)			this1->imageType = ( (int)(imageType) );
HXDLIN( 157)			undoImage = this1;
HXLINE( 158)			{
HXLINE( 158)				int rectLeft = xIter3->start;
HXDLIN( 158)				int rectTop = yIter3->start;
HXDLIN( 158)				int rectRight = xIter3->max;
HXDLIN( 158)				bool forceClear = false;
HXDLIN( 158)				{
HXLINE( 158)					int _g16 = rectTop;
HXDLIN( 158)					int _g17 = yIter3->max;
HXDLIN( 158)					while((_g16 < _g17)){
HXLINE( 158)						_g16 = (_g16 + 1);
HXDLIN( 158)						int dy = (_g16 - 1);
HXDLIN( 158)						{
HXLINE( 158)							int _g18 = rectLeft;
HXDLIN( 158)							int _g19 = rectRight;
HXDLIN( 158)							while((_g18 < _g19)){
HXLINE( 158)								_g18 = (_g18 + 1);
HXDLIN( 158)								int dx = (_g18 - 1);
HXDLIN( 158)								::Dynamic this3 = pixelImage->image;
HXDLIN( 158)								int index;
HXDLIN( 158)								if (pixelImage->useVirtualPos) {
HXLINE( 158)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 158)									index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            								}
HXDLIN( 158)								int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 158)								int col;
HXDLIN( 158)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 158)									col = c;
            								}
HXDLIN( 158)								bool _hx_tmp;
HXDLIN( 158)								if (pixelImage->useMask) {
HXLINE( 158)									_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            								}
            								else {
HXLINE( 158)									_hx_tmp = false;
            								}
HXDLIN( 158)								if (_hx_tmp) {
HXLINE( 158)									 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 158)									::Dynamic this5 = this4->image;
HXDLIN( 158)									int index1;
HXDLIN( 158)									if (this4->useVirtualPos) {
HXLINE( 158)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            									}
            									else {
HXLINE( 158)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            									}
HXDLIN( 158)									int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 158)									int v1;
HXDLIN( 158)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 158)										v1 = c1;
            									}
HXDLIN( 158)									int maskPixel = v1;
HXDLIN( 158)									int this6 = col;
HXDLIN( 158)									if ((maskPixel == 0)) {
HXLINE( 158)										col = this6;
            									}
            									else {
HXLINE( 158)										Float m0;
HXDLIN( 158)										int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 158)										if ((this7 == 0)) {
HXLINE( 158)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float m1;
HXDLIN( 158)										int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 158)										if ((this8 == 0)) {
HXLINE( 158)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float m2;
HXDLIN( 158)										int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 158)										if ((this9 == 0)) {
HXLINE( 158)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float m3;
HXDLIN( 158)										int this10 = (maskPixel & 255);
HXDLIN( 158)										if ((this10 == 0)) {
HXLINE( 158)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 158)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 158)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 158)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 158)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 158)								if ((col != 0)) {
HXLINE( 158)									int x1 = (dx - rectLeft);
HXDLIN( 158)									int y1 = (dy - rectTop);
HXDLIN( 158)									int c2 = col;
HXDLIN( 158)									bool _hx_tmp1;
HXDLIN( 158)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 158)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 158)										_hx_tmp1 = false;
            									}
HXDLIN( 158)									if (_hx_tmp1) {
HXLINE( 158)										int location;
HXDLIN( 158)										if (undoImage->useVirtualPos) {
HXLINE( 158)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 158)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 158)										int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 158)										int this12;
HXDLIN( 158)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)											this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            										}
            										else {
HXLINE( 158)											this12 = this11;
            										}
HXDLIN( 158)										Float a11;
HXDLIN( 158)										int this13 = ((this12 >> 24) & 255);
HXDLIN( 158)										if ((this13 == 0)) {
HXLINE( 158)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											a11 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float r1;
HXDLIN( 158)										int this14 = ((this12 >> 16) & 255);
HXDLIN( 158)										if ((this14 == 0)) {
HXLINE( 158)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float g1;
HXDLIN( 158)										int this15 = ((this12 >> 8) & 255);
HXDLIN( 158)										if ((this15 == 0)) {
HXLINE( 158)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float b11;
HXDLIN( 158)										int this16 = (this12 & 255);
HXDLIN( 158)										if ((this16 == 0)) {
HXLINE( 158)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float a2;
HXDLIN( 158)										int this17 = ((col >> 24) & 255);
HXDLIN( 158)										if ((this17 == 0)) {
HXLINE( 158)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float r2;
HXDLIN( 158)										int this18 = ((col >> 16) & 255);
HXDLIN( 158)										if ((this18 == 0)) {
HXLINE( 158)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float g2;
HXDLIN( 158)										int this19 = ((col >> 8) & 255);
HXDLIN( 158)										if ((this19 == 0)) {
HXLINE( 158)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float b21;
HXDLIN( 158)										int this20 = (col & 255);
HXDLIN( 158)										if ((this20 == 0)) {
HXLINE( 158)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 158)											b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 158)										Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 158)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 158)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 158)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 158)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 158)										int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 158)										{
HXLINE( 158)											int _hx_tmp2;
HXDLIN( 158)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 158)												_hx_tmp2 = blended;
            											}
HXDLIN( 158)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 158)										::Dynamic this21 = undoImage->image;
HXDLIN( 158)										int index2;
HXDLIN( 158)										if (undoImage->useVirtualPos) {
HXLINE( 158)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 158)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 158)										int _hx_tmp3;
HXDLIN( 158)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 158)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 158)											_hx_tmp3 = c2;
            										}
HXDLIN( 158)										::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 158)									if (forceClear) {
HXLINE( 158)										::Dynamic this22 = undoImage->image;
HXDLIN( 158)										int x2 = (dx - rectLeft);
HXDLIN( 158)										int y2 = (dy - rectTop);
HXDLIN( 158)										int index3;
HXDLIN( 158)										if (undoImage->useVirtualPos) {
HXLINE( 158)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 158)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 158)										::iterMagic::Iimg_obj::set(this22,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 162)		Float s0 = ((ay * cx) - (ax * cy));
HXLINE( 163)		Float sx = (cy - ay);
HXLINE( 164)		Float sy = (ax - cx);
HXLINE( 165)		Float t0 = ((ax * by) - (ay * bx));
HXLINE( 166)		Float tx = (ay - by);
HXLINE( 167)		Float ty = (bx - ax);
HXLINE( 168)		Float A = ((((-(by) * cx) + (ay * (-(bx) + cx))) + (ax * (by - cy))) + (bx * cy));
HXLINE( 170)		Float s = ((Float)0.);
HXLINE( 171)		Float t = ((Float)0.);
HXLINE( 172)		Float sxx = ((Float)0.);
HXLINE( 173)		Float txx = ((Float)0.);
HXLINE( 186)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(5) ));
HXLINE( 187)		Float omega = (theta / ( (Float)(3) ));
HXLINE( 188)		Float delta = ((Float)0.7071);
HXLINE( 189)		Float x0 = (delta * ::Math_obj::cos((theta + omega)));
HXLINE( 190)		Float y0 = (delta * ::Math_obj::sin((theta + omega)));
HXLINE( 191)		omega = (omega + theta);
HXLINE( 192)		Float x11 = (delta * ::Math_obj::cos((theta + omega)));
HXLINE( 193)		Float y11 = (delta * ::Math_obj::sin((theta + omega)));
HXLINE( 194)		omega = (omega + theta);
HXLINE( 195)		Float x21 = (delta * ::Math_obj::cos((theta + omega)));
HXLINE( 196)		Float y21 = (delta * ::Math_obj::sin((theta + omega)));
HXLINE( 197)		omega = (omega + theta);
HXLINE( 198)		Float x3 = (delta * ::Math_obj::cos((theta + omega)));
HXLINE( 199)		Float y3 = (delta * ::Math_obj::sin((theta + omega)));
HXLINE( 200)		omega = (omega + theta);
HXLINE( 201)		Float x4 = (delta * ::Math_obj::cos((theta + omega)));
HXLINE( 202)		Float y4 = (delta * ::Math_obj::sin((theta + omega)));
HXLINE( 204)		Float sxx1 = ((Float)0.);
HXLINE( 205)		Float txx1 = ((Float)0.);
HXLINE( 207)		Float sxx0 = ((Float)0.);
HXLINE( 208)		Float sxx11 = ((Float)0.);
HXLINE( 209)		Float sxx2 = ((Float)0.);
HXLINE( 210)		Float sxx3 = ((Float)0.);
HXLINE( 211)		Float sxx4 = ((Float)0.);
HXLINE( 212)		Float txx0 = ((Float)0.);
HXLINE( 213)		Float txx11 = ((Float)0.);
HXLINE( 214)		Float txx2 = ((Float)0.);
HXLINE( 215)		Float txx3 = ((Float)0.);
HXLINE( 216)		Float txx4 = ((Float)0.);
HXLINE( 217)		Float aSum = ((Float)0.);
HXLINE( 220)		{
HXLINE( 220)			int _g_min = xIter3->start;
HXDLIN( 220)			int _g_max = xIter3->max;
HXDLIN( 220)			while((_g_min < _g_max)){
HXLINE( 220)				_g_min = (_g_min + 1);
HXDLIN( 220)				int px = (_g_min - 1);
HXLINE( 221)				Float pcx = (( (Float)(px) ) - cx);
HXLINE( 223)				sxx1 = (sx * ( (Float)(px) ));
HXLINE( 224)				txx1 = (tx * ( (Float)(px) ));
HXLINE( 226)				sxx0 = (sx * (px + x0));
HXLINE( 227)				sxx11 = (sx * (px + x11));
HXLINE( 228)				sxx2 = (sx * (px + x21));
HXLINE( 229)				sxx3 = (sx * (px + x3));
HXLINE( 230)				sxx4 = (sx * (px + x4));
HXLINE( 231)				txx0 = (tx * (px + x0));
HXLINE( 232)				txx11 = (tx * (px + x11));
HXLINE( 233)				txx2 = (tx * (px + x21));
HXLINE( 234)				txx3 = (tx * (px + x3));
HXLINE( 235)				txx4 = (tx * (px + x4));
HXLINE( 238)				{
HXLINE( 238)					int _g_min1 = yIter3->start;
HXDLIN( 238)					int _g_max1 = yIter3->max;
HXDLIN( 238)					while((_g_min1 < _g_max1)){
HXLINE( 238)						_g_min1 = (_g_min1 + 1);
HXDLIN( 238)						int py = (_g_min1 - 1);
HXLINE( 240)						Float pcy = (( (Float)(py) ) - cy);
HXLINE( 241)						Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXLINE( 242)						Float dot32 = ((pcx * acx) + (pcy * acy));
HXLINE( 243)						Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXLINE( 244)						Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXLINE( 245)						Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXLINE( 248)						Float min5;
HXDLIN( 248)						if ((ratioA < ratioB)) {
HXLINE( 248)							min5 = ratioA;
            						}
            						else {
HXLINE( 248)							min5 = ratioB;
            						}
HXLINE( 249)						if (!((min5 < ratioC))) {
HXLINE( 249)							min5 = ratioC;
            						}
HXLINE( 256)						bool pentagonSampling;
HXDLIN( 256)						if (softAB) {
HXLINE( 256)							if (softBC) {
HXLINE( 256)								if (softCA) {
HXLINE( 256)									pentagonSampling = true;
            								}
            								else {
HXLINE( 270)									if ((min5 != ratioB)) {
HXLINE( 256)										pentagonSampling = (min5 == ratioC);
            									}
            									else {
HXLINE( 256)										pentagonSampling = true;
            									}
            								}
            							}
            							else {
HXLINE( 256)								if (softCA) {
HXLINE( 268)									if ((min5 != ratioA)) {
HXLINE( 256)										pentagonSampling = (min5 == ratioC);
            									}
            									else {
HXLINE( 256)										pentagonSampling = true;
            									}
            								}
            								else {
HXLINE( 256)									pentagonSampling = (min5 == ratioC);
            								}
            							}
            						}
            						else {
HXLINE( 256)							if (softBC) {
HXLINE( 256)								if (softCA) {
HXLINE( 264)									if ((min5 != ratioA)) {
HXLINE( 256)										pentagonSampling = (min5 == ratioB);
            									}
            									else {
HXLINE( 256)										pentagonSampling = true;
            									}
            								}
            								else {
HXLINE( 256)									pentagonSampling = (min5 == ratioB);
            								}
            							}
            							else {
HXLINE( 256)								if (softCA) {
HXLINE( 256)									pentagonSampling = (min5 == ratioA);
            								}
            								else {
HXLINE( 256)									pentagonSampling = false;
            								}
            							}
            						}
HXLINE( 275)						if (pentagonSampling) {
HXLINE( 276)							aSum = ((Float)0.);
HXLINE( 277)							s = ((s0 + sxx0) + (sy * (py + y0)));
HXLINE( 278)							t = ((t0 + txx0) + (ty * (py + y0)));
HXLINE( 279)							bool _hx_tmp4;
HXDLIN( 279)							if (!((s <= 0))) {
HXLINE( 279)								_hx_tmp4 = (t <= 0);
            							}
            							else {
HXLINE( 279)								_hx_tmp4 = true;
            							}
HXDLIN( 279)							if (!(_hx_tmp4)) {
HXLINE( 279)								if (((s + t) < A)) {
HXLINE( 279)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 280)							s = ((s0 + sxx11) + (sy * (py + y11)));
HXLINE( 281)							t = ((t0 + txx11) + (ty * (py + y11)));
HXLINE( 282)							bool _hx_tmp5;
HXDLIN( 282)							if (!((s <= 0))) {
HXLINE( 282)								_hx_tmp5 = (t <= 0);
            							}
            							else {
HXLINE( 282)								_hx_tmp5 = true;
            							}
HXDLIN( 282)							if (!(_hx_tmp5)) {
HXLINE( 282)								if (((s + t) < A)) {
HXLINE( 282)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 283)							s = ((s0 + sxx2) + (sy * (py + y21)));
HXLINE( 284)							t = ((t0 + txx2) + (ty * (py + y21)));
HXLINE( 285)							bool _hx_tmp6;
HXDLIN( 285)							if (!((s <= 0))) {
HXLINE( 285)								_hx_tmp6 = (t <= 0);
            							}
            							else {
HXLINE( 285)								_hx_tmp6 = true;
            							}
HXDLIN( 285)							if (!(_hx_tmp6)) {
HXLINE( 285)								if (((s + t) < A)) {
HXLINE( 285)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 286)							s = ((s0 + sxx3) + (sy * (py + y3)));
HXLINE( 287)							t = ((t0 + txx3) + (ty * (py + y3)));
HXLINE( 288)							bool _hx_tmp7;
HXDLIN( 288)							if (!((s <= 0))) {
HXLINE( 288)								_hx_tmp7 = (t <= 0);
            							}
            							else {
HXLINE( 288)								_hx_tmp7 = true;
            							}
HXDLIN( 288)							if (!(_hx_tmp7)) {
HXLINE( 288)								if (((s + t) < A)) {
HXLINE( 288)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 289)							s = ((s0 + sxx4) + (sy * (py + y4)));
HXLINE( 290)							t = ((t0 + txx4) + (ty * (py + y4)));
HXLINE( 291)							bool _hx_tmp8;
HXDLIN( 291)							if (!((s <= 0))) {
HXLINE( 291)								_hx_tmp8 = (t <= 0);
            							}
            							else {
HXLINE( 291)								_hx_tmp8 = true;
            							}
HXDLIN( 291)							if (!(_hx_tmp8)) {
HXLINE( 291)								if (((s + t) < A)) {
HXLINE( 291)									aSum = (aSum + ((Float)0.2));
            								}
            							}
HXLINE( 294)							if ((aSum != ((Float)0.))) {
HXLINE( 295)								int a5;
HXLINE( 296)								if ((aSum > ((Float)0.9))) {
HXLINE( 295)									a5 = a;
            								}
            								else {
HXLINE( 296)									int i6 = ::Std_obj::_hx_int((( (Float)(a) ) * aSum));
HXDLIN( 296)									if ((i6 > 255)) {
HXLINE(  24)										i6 = 255;
            									}
HXLINE( 296)									if ((i6 < 0)) {
HXLINE(  25)										i6 = 0;
            									}
HXLINE( 295)									a5 = i6;
            								}
HXDLIN( 295)								int location1;
HXLINE( 297)								if (pixelImage->useVirtualPos) {
HXLINE( 295)									location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 295)									location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 295)								bool _hx_tmp9;
HXDLIN( 295)								if (pixelImage->transparent) {
HXLINE( 295)									_hx_tmp9 = (a5 < 254);
            								}
            								else {
HXLINE( 295)									_hx_tmp9 = false;
            								}
HXDLIN( 295)								if (_hx_tmp9) {
HXLINE( 295)									int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 295)									int old;
HXDLIN( 295)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 295)										old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            									}
            									else {
HXLINE( 295)										old = this23;
            									}
HXDLIN( 295)									int rhs = ((((a5 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 295)									Float a12;
HXDLIN( 295)									int this24 = ((old >> 24) & 255);
HXDLIN( 295)									if ((this24 == 0)) {
HXLINE( 295)										a12 = ((Float)0.);
            									}
            									else {
HXLINE( 295)										a12 = (( (Float)(this24) ) / ( (Float)(255) ));
            									}
HXDLIN( 295)									Float r11;
HXDLIN( 295)									int this25 = ((old >> 16) & 255);
HXDLIN( 295)									if ((this25 == 0)) {
HXLINE( 295)										r11 = ((Float)0.);
            									}
            									else {
HXLINE( 295)										r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            									}
HXDLIN( 295)									Float g11;
HXDLIN( 295)									int this26 = ((old >> 8) & 255);
HXDLIN( 295)									if ((this26 == 0)) {
HXLINE( 295)										g11 = ((Float)0.);
            									}
            									else {
HXLINE( 295)										g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            									}
HXDLIN( 295)									Float b12;
HXDLIN( 295)									int this27 = (old & 255);
HXDLIN( 295)									if ((this27 == 0)) {
HXLINE( 295)										b12 = ((Float)0.);
            									}
            									else {
HXLINE( 295)										b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            									}
HXDLIN( 295)									Float a21;
HXDLIN( 295)									int this28 = ((rhs >> 24) & 255);
HXDLIN( 295)									if ((this28 == 0)) {
HXLINE( 295)										a21 = ((Float)0.);
            									}
            									else {
HXLINE( 295)										a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            									}
HXDLIN( 295)									Float r21;
HXDLIN( 295)									int this29 = ((rhs >> 16) & 255);
HXDLIN( 295)									if ((this29 == 0)) {
HXLINE( 295)										r21 = ((Float)0.);
            									}
            									else {
HXLINE( 295)										r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            									}
HXDLIN( 295)									Float g21;
HXDLIN( 295)									int this30 = ((rhs >> 8) & 255);
HXDLIN( 295)									if ((this30 == 0)) {
HXLINE( 295)										g21 = ((Float)0.);
            									}
            									else {
HXLINE( 295)										g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            									}
HXDLIN( 295)									Float b22;
HXDLIN( 295)									int this31 = (rhs & 255);
HXDLIN( 295)									if ((this31 == 0)) {
HXLINE( 295)										b22 = ((Float)0.);
            									}
            									else {
HXLINE( 295)										b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            									}
HXDLIN( 295)									Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 295)									int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 295)									int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 295)									int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 295)									int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 295)									int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 295)									{
HXLINE( 295)										int _hx_tmp10;
HXDLIN( 295)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 295)											_hx_tmp10 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            										}
            										else {
HXLINE( 295)											_hx_tmp10 = blended1;
            										}
HXDLIN( 295)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp10);
            									}
            								}
            								else {
HXLINE( 295)									int value;
HXDLIN( 295)									if (pixelImage->isLittle) {
HXLINE( 295)										value = ((((a5 << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE( 295)										value = ((((a5 << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN( 295)									::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            								}
            							}
            						}
            						else {
HXLINE( 309)							bool _hx_tmp11;
HXDLIN( 309)							bool _hx_tmp12;
HXDLIN( 309)							if ((ratioA >= 0)) {
HXLINE( 309)								_hx_tmp12 = (ratioB >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp12 = false;
            							}
HXDLIN( 309)							if (_hx_tmp12) {
HXLINE( 309)								_hx_tmp11 = (ratioC >= 0);
            							}
            							else {
HXLINE( 309)								_hx_tmp11 = false;
            							}
HXDLIN( 309)							if (_hx_tmp11) {
HXLINE( 310)								int location2;
HXDLIN( 310)								if (pixelImage->useVirtualPos) {
HXLINE( 310)									location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            								}
            								else {
HXLINE( 310)									location2 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            								}
HXDLIN( 310)								bool _hx_tmp13;
HXDLIN( 310)								if (pixelImage->transparent) {
HXLINE( 310)									_hx_tmp13 = (a < 254);
            								}
            								else {
HXLINE( 310)									_hx_tmp13 = false;
            								}
HXDLIN( 310)								if (_hx_tmp13) {
HXLINE( 310)									int this32 = ::iterMagic::Iimg_obj::get(pixelImage->image,location2);
HXDLIN( 310)									int old1;
HXDLIN( 310)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 310)										old1 = ((((((this32 >> 24) & 255) << 24) | ((this32 & 255) << 16)) | (((this32 >> 8) & 255) << 8)) | ((this32 >> 16) & 255));
            									}
            									else {
HXLINE( 310)										old1 = this32;
            									}
HXDLIN( 310)									int rhs1 = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 310)									Float a13;
HXDLIN( 310)									int this33 = ((old1 >> 24) & 255);
HXDLIN( 310)									if ((this33 == 0)) {
HXLINE( 310)										a13 = ((Float)0.);
            									}
            									else {
HXLINE( 310)										a13 = (( (Float)(this33) ) / ( (Float)(255) ));
            									}
HXDLIN( 310)									Float r12;
HXDLIN( 310)									int this34 = ((old1 >> 16) & 255);
HXDLIN( 310)									if ((this34 == 0)) {
HXLINE( 310)										r12 = ((Float)0.);
            									}
            									else {
HXLINE( 310)										r12 = (( (Float)(this34) ) / ( (Float)(255) ));
            									}
HXDLIN( 310)									Float g12;
HXDLIN( 310)									int this35 = ((old1 >> 8) & 255);
HXDLIN( 310)									if ((this35 == 0)) {
HXLINE( 310)										g12 = ((Float)0.);
            									}
            									else {
HXLINE( 310)										g12 = (( (Float)(this35) ) / ( (Float)(255) ));
            									}
HXDLIN( 310)									Float b13;
HXDLIN( 310)									int this36 = (old1 & 255);
HXDLIN( 310)									if ((this36 == 0)) {
HXLINE( 310)										b13 = ((Float)0.);
            									}
            									else {
HXLINE( 310)										b13 = (( (Float)(this36) ) / ( (Float)(255) ));
            									}
HXDLIN( 310)									Float a22;
HXDLIN( 310)									int this37 = ((rhs1 >> 24) & 255);
HXDLIN( 310)									if ((this37 == 0)) {
HXLINE( 310)										a22 = ((Float)0.);
            									}
            									else {
HXLINE( 310)										a22 = (( (Float)(this37) ) / ( (Float)(255) ));
            									}
HXDLIN( 310)									Float r22;
HXDLIN( 310)									int this38 = ((rhs1 >> 16) & 255);
HXDLIN( 310)									if ((this38 == 0)) {
HXLINE( 310)										r22 = ((Float)0.);
            									}
            									else {
HXLINE( 310)										r22 = (( (Float)(this38) ) / ( (Float)(255) ));
            									}
HXDLIN( 310)									Float g22;
HXDLIN( 310)									int this39 = ((rhs1 >> 8) & 255);
HXDLIN( 310)									if ((this39 == 0)) {
HXLINE( 310)										g22 = ((Float)0.);
            									}
            									else {
HXLINE( 310)										g22 = (( (Float)(this39) ) / ( (Float)(255) ));
            									}
HXDLIN( 310)									Float b23;
HXDLIN( 310)									int this40 = (rhs1 & 255);
HXDLIN( 310)									if ((this40 == 0)) {
HXLINE( 310)										b23 = ((Float)0.);
            									}
            									else {
HXLINE( 310)										b23 = (( (Float)(this40) ) / ( (Float)(255) ));
            									}
HXDLIN( 310)									Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 310)									int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 310)									int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 310)									int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 310)									int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 310)									int blended2 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 310)									{
HXLINE( 310)										int _hx_tmp14;
HXDLIN( 310)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 310)											_hx_tmp14 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            										}
            										else {
HXLINE( 310)											_hx_tmp14 = blended2;
            										}
HXDLIN( 310)										::iterMagic::Iimg_obj::set(pixelImage->image,location2,_hx_tmp14);
            									}
            								}
            								else {
HXLINE( 310)									int value1;
HXDLIN( 310)									if (pixelImage->isLittle) {
HXLINE( 310)										value1 = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            									}
            									else {
HXLINE( 310)										value1 = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            									}
HXDLIN( 310)									::iterMagic::Iimg_obj::set(pixelImage->image,location2,value1);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 316)		if ((hasHit == false)) {
HXLINE( 317)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXLINE( 318)			if (hasUndo) {
HXLINE( 319)				v2->undoImage = undoImage;
HXLINE( 320)				v2->undoX = xIter3->start;
HXLINE( 321)				v2->undoY = yIter3->start;
            			}
HXLINE( 323)			return v2;
            		}
            		else {
HXLINE( 325)			return null();
            		}
HXLINE( 316)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC13(TriPixelSmooth_Fields__obj,triPentagonBarycentic,return )


TriPixelSmooth_Fields__obj::TriPixelSmooth_Fields__obj()
{
}

bool TriPixelSmooth_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 21:
		if (HX_FIELD_EQ(inName,"triPentagonBarycentic") ) { outValue = triPentagonBarycentic_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"quadPentagonBarycentric") ) { outValue = quadPentagonBarycentric_dyn(); return true; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"triPentagonBarycentricTop") ) { outValue = triPentagonBarycentricTop_dyn(); return true; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"triPentagonBarycentricBottom") ) { outValue = triPentagonBarycentricBottom_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *TriPixelSmooth_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *TriPixelSmooth_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class TriPixelSmooth_Fields__obj::__mClass;

static ::String TriPixelSmooth_Fields__obj_sStaticFields[] = {
	HX_("quadPentagonBarycentric",b7,58,32,69),
	HX_("triPentagonBarycentricBottom",1e,32,4d,89),
	HX_("triPentagonBarycentricTop",82,6d,53,bf),
	HX_("triPentagonBarycentic",b3,1f,50,0b),
	::String(null())
};

void TriPixelSmooth_Fields__obj::__register()
{
	TriPixelSmooth_Fields__obj _hx_dummy;
	TriPixelSmooth_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.algo._TriPixelSmooth.TriPixelSmooth_Fields_",4a,64,fe,95);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TriPixelSmooth_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(TriPixelSmooth_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< TriPixelSmooth_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TriPixelSmooth_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TriPixelSmooth_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace algo
} // end namespace _TriPixelSmooth
