<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/home/nanjizal/haxe/versions/779b005/std/Any.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<toString get="inline" set="null" line="40" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<toString get="inline" set="null" line="40" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="/home/nanjizal/haxe/versions/779b005/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="280">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="287">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<map public="1" params="S" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="316">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="/home/nanjizal/haxe/versions/779b005/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/Date.hx" extern="1">
		<now public="1" set="method" line="97" static="1">
			<f a=""><c path="Date"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<new1 set="method" line="101" static="1"><f a="t">
	<d/>
	<c path="Date"/>
</f></new1>
		<fromTime public="1" set="method" line="105" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="111" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<mSeconds><x path="Float"/></mSeconds>
		<getTime public="1" set="method" line="29">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method" line="33">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method" line="37">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method" line="41">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method" line="45">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method" line="53">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method" line="57">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method" line="61">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method" line="65">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method" line="69">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method" line="73">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method" line="77">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method" line="81">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method" line="85">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method" line="89">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" set="method" line="93">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="25">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="EReg" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/EReg.hx" extern="1">
		<escape public="1" set="method" line="173" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape the string `s` for use as a part of regular expression.

		If `s` is null, the result is unspecified.</haxe_doc>
		</escape>
		<escapeRegExpRe expr="~/[\[\]{}()*+?.\\\^$|]/" line="177" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/[\[\]{}()*+?.\\\^$|]/</e></m></meta>
		</escapeRegExpRe>
		<_hx_regexp_new_options set="method" static="1">
			<f a="s:options">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_new_options"</e></m></meta>
		</_hx_regexp_new_options>
		<_hx_regexp_match set="method" static="1">
			<f a="handler:string:pos:len">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_match"</e></m></meta>
		</_hx_regexp_match>
		<_hx_regexp_matched set="method" static="1">
			<f a="handle:pos">
				<d/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_matched"</e></m></meta>
		</_hx_regexp_matched>
		<_hx_regexp_matched_pos set="method" static="1">
			<f a="handle:match">
				<d/>
				<x path="Int"/>
				<a>
					<pos><x path="Int"/></pos>
					<len><x path="Int"/></len>
				</a>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_matched_pos"</e></m></meta>
		</_hx_regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><x path="Bool"/></global>
		<match public="1" set="method" line="36">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="45">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="50">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the left of the last matched substring.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, only the
		substring to the left of the leftmost match is returned.

		The result does not include the matched part.</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="55">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.

		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="61">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="65">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<split public="1" set="method" line="74">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.

		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.

		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.

		If two matching substrings appear next to each other, the result
		contains the empty String `""` between them.

		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.

		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<replace public="1" set="method" line="98">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="149">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<toString set="method" line="180"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="28">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/regexp/Build.xml\"/>"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/home/nanjizal/haxe/versions/779b005/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/home/nanjizal/haxe/versions/779b005/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="IntIterator" params="" file="/home/nanjizal/haxe/versions/779b005/std/IntIterator.hx">
		<min><x path="Int"/></min>
		<max><x path="Int"/></max>
		<hasNext public="1" get="inline" set="null" line="53">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.

		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="45">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).

		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.

	It is usually not used explicitly, but through its special syntax:
	`min...max`

	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Lambda" params="" file="/home/nanjizal/haxe/versions/779b005/std/Lambda.hx" extern="1">
		<array public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="57" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="haxe.ds.List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a List form Iterable `it`.

		If `it` is a List, this function returns a copy of it.</haxe_doc>
		</list>
		<map public="1" params="A:B" get="inline" set="null" line="69" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="item">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="Array"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `it`.
		The order of elements is preserved.
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" get="inline" set="null" line="78" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a="index:item">
					<x path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="Array"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to map, but also passes the index of each element to `f`.
		The order of elements is preserved.
		If `f` is null, the result is unspecified.</haxe_doc>
		</mapi>
		<flatten public="1" params="A" get="inline" set="null" line="87" static="1">
			<f a="it">
				<t path="Iterable"><t path="Iterable"><c path="flatten.A"/></t></t>
				<c path="Array"><c path="flatten.A"/></c>
			</f>
			<haxe_doc>Concatenate a list of iterables.
		The order of elements is preserved.</haxe_doc>
		</flatten>
		<flatMap public="1" params="A:B" get="inline" set="null" line="96" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="flatMap.A"/></t>
				<f a="item">
					<c path="flatMap.A"/>
					<t path="Iterable"><c path="flatMap.B"/></t>
				</f>
				<c path="Array"><c path="flatMap.B"/></c>
			</f>
			<haxe_doc>A composition of map and flatten.
		The order of elements is preserved.
		If `f` is null, the result is unspecified.</haxe_doc>
		</flatMap>
		<has public="1" params="A" set="method" line="108" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.

		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.

		If no such element is found, the result is false.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="item">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.

		This function returns true as soon as an element is found for which a
		call to `f` returns true.

		If no such element is found, the result is false.

		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="144" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="item">
					<c path="foreach.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is true for all elements of `it`.

		This function returns false as soon as an element is found for which a
		call to `f` returns false.

		If no such element is found, the result is true.

		In particular, this function always returns true if `it` is empty.

		If `f` is null, the result is unspecified.</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="156" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="item">
					<c path="iter.A"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls `f` on all elements of `it`, in order.

		If `f` is null, the result is unspecified.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="167" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="item">
					<c path="filter.A"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Returns a Array containing those elements of `it` for which `f` returned
		true.
		If `it` is empty, the result is the empty Array even if `f` is null.
		Otherwise if `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="183" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a="item:result">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional fold on Iterable `it`, using function `f` with start argument
		`first`.

		If `it` has no elements, the result is `first`.

		Otherwise the first element of `it` is passed to `f` alongside `first`.
		The result of that call is then passed to `f` with the next element of
		`it`, and so on until `it` has no more elements.

		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</fold>
		<foldi public="1" params="A:B" set="method" line="194" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="foldi.A"/></t>
				<f a="item:result:index">
					<c path="foldi.A"/>
					<c path="foldi.B"/>
					<x path="Int"/>
					<c path="foldi.B"/>
				</f>
				<c path="foldi.B"/>
				<c path="foldi.B"/>
			</f>
			<haxe_doc>Similar to fold, but also passes the index of each element to `f`.

		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</foldi>
		<count public="1" params="A" set="method" line="209" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="item">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.

		This function traverses all elements.</haxe_doc>
		</count>
		<empty public="1" params="T" set="method" line="224" static="1">
			<f a="it">
				<t path="Iterable"><c path="empty.T"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if Iterable `it` does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="235" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.

		This function uses operator `==` to check for equality.

		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<find public="1" params="T" set="method" line="255" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="find.T"/></t>
				<f a="item">
					<c path="find.T"/>
					<x path="Bool"/>
				</f>
				<x path="Null"><c path="find.T"/></x>
			</f>
			<haxe_doc>Returns the first element of `it` for which `f` is true.

		This function returns as soon as an element is found for which a call to
		`f` returns true.

		If no such element is found, the result is null.

		If `f` is null, the result is unspecified.</haxe_doc>
		</find>
		<findIndex public="1" params="T" set="method" line="273" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="findIndex.T"/></t>
				<f a="item">
					<c path="findIndex.T"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element of `it` for which `f` is true.

		This function returns as soon as an element is found for which a call to
		`f` returns true.

		If no such element is found, the result is -1.

		If `f` is null, the result is unspecified.</haxe_doc>
		</findIndex>
		<concat public="1" params="T" set="method" line="289" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="Array"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a new Array containing all elements of Iterable `a` followed by
		all elements of Iterable `b`.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</concat>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with `using Lambda` and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.

	@see https://haxe.org/manual/std-Lambda.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="List" params="T" file="/home/nanjizal/haxe/versions/779b005/std/List.hx"><c path="haxe.ds.List"><c path="List.T"/></c></typedef>
	<typedef path="Map" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/home/nanjizal/haxe/versions/779b005/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, π. `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is `Math.NaN`.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, `null`, `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":include"><e>"hxMath.h"</e></m>
		</meta>
	</class>
	<class path="Reflect" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/Reflect.hx" extern="1">
		<hasField public="1" set="method" line="29" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="34" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<setField public="1" set="method" line="39" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="44" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="48" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="54" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="67" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="76" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="80" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="84" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="93" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="101" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="106" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="112" static="1">
			<f a="o">
				<x path="Null"><c path="copy.T"/></x>
				<x path="Null"><c path="copy.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is `null`.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="126" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":analyzer"><e>ignore</e></m>
		</meta>
	</class>
	<class path="Std" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/Std.hx" extern="1">
		<is public="1" get="inline" set="null" line="25" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"Std.is is deprecated. Use Std.isOfType instead."</e></m>
				<m n=":keep"/>
			</meta>
			<haxe_doc>DEPRECATED. Use `Std.isOfType(v, t)` instead.

		Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<isOfType public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<downcast public="1" params="T:S" set="method" line="33" static="1">
			<f a="value:c">
				<c path="downcast.T"/>
				<x path="Class"><c path="downcast.S"/></x>
				<c path="downcast.S"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Checks if object `value` is an instance of class or interface `c`.

		Compiles only if the type specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the type specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with core types such as `String`,
		`Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</downcast>
		<instance public="1" params="T:S" set="method" line="38" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"Std.instance() is deprecated. Use Std.downcast() instead."</e></m>
				<m n=":keep"/>
			</meta>
		</instance>
		<string public="1" set="method" line="42" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="46" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="50" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		`x` may optionally start with a + or - to denote a postive or negative value respectively.

		If the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following
		digits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary
		notations are not supported.

		Parsing continues until an invalid character is detected, in which case the result up to
		that point is returned. However, in decimal mode, the effect of `x` containing an e or E
		is unspecified, and it may be taken as scientific exponential notation.

		If `x` is `null`, the result is `null`.
		If `x` cannot be parsed as integer or is empty, the result is `null`.

		If `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal
		digit, the result is unspecified.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="54" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of `null`. Also, hexadecimal support is **not** specified.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.

		It may also end with `e` or `E` followed by optional minus or plus sign and a sequence of
		digits (defines exponent to base 10).</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="58" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerClassCode"><e><![CDATA["\t\tstatic inline String string(String &s) { return s; }"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Single" params="" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<from><icast><x path="Float"/></icast></from>
		<this><x path="Single"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc>Single-precision IEEE 32bit float (4-byte).</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/home/nanjizal/haxe/versions/779b005/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="/home/nanjizal/haxe/versions/779b005/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/StringBuf.hx" extern="1">
		<b><c path="Array"><c path="String"/></c></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<charBuf><c path="Array"><x path="cpp.Char"/></c></charBuf>
		<charBufAsString set="method" line="37"><f a=""><c path="String"/></f></charBufAsString>
		<flush set="method" line="43"><f a=""><x path="Void"/></f></flush>
		<get_length set="method" line="51"><f a=""><x path="Int"/></f></get_length>
		<add public="1" params="T" get="inline" set="null" line="61">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.

		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).

		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addSub public="1" set="method" line="70">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.

		If `s` or `pos` are null, the result is unspecified.

		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<addChar public="1" set="method" line="79">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.

		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<toString public="1" set="method" line="92">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.

		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" set="method" line="35">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/home/nanjizal/haxe/versions/779b005/std/StringTools.hx" extern="1">
		<urlEncode public="1" set="method" line="42" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="110" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="158" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="193" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Unescapes HTML special characters of the string `s`.

		This is the inverse operation to htmlEscape, i.e. the following always
		holds: `htmlUnescape(htmlEscape(s)) == s`

		The replacements follow:

		- `&amp;` becomes `&`
		- `&lt;` becomes `<`
		- `&gt;` becomes `>`
		- `&quot;` becomes `"`
		- `&#039;` becomes `'`]]></haxe_doc>
		</htmlUnescape>
		<contains public="1" get="inline" set="null" line="211" static="1">
			<f a="s:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if `s` contains `value` and  `false` otherwise.

		When `value` is `null`, the result is unspecified.</haxe_doc>
		</contains>
		<startsWith public="1" set="method" line="226" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="249" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="278" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="296" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="321" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="343" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="365" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<rpad public="1" set="method" line="390" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Appends `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</rpad>
		<replace public="1" set="method" line="412" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="434" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="476" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		End of file status can be checked by calling `StringTools.isEof()` with
		the returned value as argument.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</fastCodeAt>
		<unsafeCodeAt public="1" get="inline" set="null" line="515" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</unsafeCodeAt>
		<iterator public="1" get="inline" set="null" line="550" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.iterators.StringIterator"/>
			</f>
			<haxe_doc>Returns an iterator of the char codes.

		Note that char codes may differ across platforms because of different
		internal encoding of strings in different runtimes.
		For the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="561" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.iterators.StringKeyValueIterator"/>
			</f>
			<haxe_doc>Returns an iterator of the char indexes and codes.

		Note that char codes may differ across platforms because of different
		internal encoding of strings in different of runtimes.
		For the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.</haxe_doc>
		</keyValueIterator>
		<isEof public="1" get="inline" set="null" line="568" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>Tells if `c` represents the end-of-file (EOF) character.</haxe_doc>
		</isEof>
		<quoteUnixArg public="1" set="method" line="589" static="1">
			<f a="argument">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"StringTools.quoteUnixArg() is deprecated. Use haxe.SysTools.quoteUnixArg() instead."</e></m>
			</meta>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Unix.
		The input will be quoted, or escaped if necessary.</haxe_doc>
		</quoteUnixArg>
		<winMetaCharacters public="1" expr="cast haxe.SysTools.winMetaCharacters" line="598" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta>
				<m n=":value"><e>cast haxe.SysTools.winMetaCharacters</e></m>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead."</e></m>
			</meta>
			<haxe_doc>Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.</haxe_doc>
		</winMetaCharacters>
		<quoteWinArg public="1" set="method" line="615" static="1">
			<f a="argument:escapeMetaCharacters">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"StringTools.quoteWinArg() is deprecated. Use haxe.SysTools.quoteWinArg() instead."</e></m>
			</meta>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Windows.
		The input will be quoted, or escaped if necessary, such that the output
		will be parsed as a single argument using the rule specified in
		http://msdn.microsoft.com/en-us/library/ms880421

		Examples:
		```haxe
		quoteWinArg("abc") == "abc";
		quoteWinArg("ab c") == '"ab c"';
		```</haxe_doc>
		</quoteWinArg>
		<MIN_SURROGATE_CODE_POINT get="inline" set="null" expr="65536" line="630" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65536</e></m></meta>
		</MIN_SURROGATE_CODE_POINT>
		<utf16CodePointAt get="inline" set="null" line="632" static="1"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></utf16CodePointAt>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Sys" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/Sys.hx" extern="1">
		<print public="1" set="method" line="27" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Prints any value to the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="31" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<stdin public="1" set="method" line="36" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<meta><m n=":access"><e>sys.io.FileInput</e></m></meta>
			<haxe_doc>Returns the standard input of the process, from which user input can be read.
		Usually it will block until the user sends a full input line.
		See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="41" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<meta><m n=":access"><e>sys.io.FileOutput</e></m></meta>
			<haxe_doc>Returns the standard output of the process, to which program output can be written.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="46" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<meta><m n=":access"><e>sys.io.FileOutput</e></m></meta>
			<haxe_doc>Returns the standard error of the process, to which program errors can be written.</haxe_doc>
		</stderr>
		<getChar public="1" set="method" line="50" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a single input character from the standard input and returns it.
		Setting `echo` to `true` will also display the character on the output.</haxe_doc>
		</getChar>
		<args public="1" set="method" line="55" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns all the arguments that were passed in the command line.
		This does not include the interpreter or the name of the program file.

		(java)(eval) On Windows, non-ASCII Unicode arguments will not work correctly.

		(cs) Non-ASCII Unicode arguments will not work correctly.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable, or `null` if it
		doesn't exist.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="66" static="1">
			<f a="s:v">
				<c path="String"/>
				<x path="Null"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the value of the given environment variable.

		If `v` is `null`, the environment variable is removed.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</putEnv>
		<sleep public="1" set="method" line="70" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends execution for the given length of time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="74" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Changes the current time locale, which will affect `DateTools.format` date formating.
		Returns `true` if the locale was successfully changed.</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="78" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the current working directory (usually the one in which the program was started).</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="82" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="86" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<command public="1" set="method" line="90" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Runs the given command. The command output will be printed to the same output as the current process.
		The current process will block until the command terminates.
		The return value is the exit code of the command (usually `0` indicates no error).

		Command arguments can be passed in two ways:

		 1. Using `args` to pass command arguments. Each argument will be automatically quoted and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a full path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Use the `sys.io.Process` API for more complex tasks, such as background processes, or providing input to the command.</haxe_doc>
		</command>
		<exit public="1" set="method" line="108" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Exits the current process with the given exit code.

		(macro)(eval) Being invoked in a macro or eval context (e.g. with `-x` or `--run`) immediately terminates
		the compilation process, which also prevents the execution of any `--next` sections of compilation arguments.</haxe_doc>
		</exit>
		<time public="1" set="method" line="112" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="116" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds),
		but only accounts for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="120" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":deprecated"><e>"Use programPath instead"</e></m></meta>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<programPath public="1" set="method" line="124" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<environment public="1" set="method" line="128" static="1">
			<f a=""><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></f>
			<haxe_doc>Returns a map of the current environment variables and their values
		as of the invocation of the function.

		(python) On Windows, the variable names are always in upper case.

		(cpp)(hl)(neko) On Windows, the variable names match the last capitalization used when modifying
		the variable if the variable has been modified, otherwise they match their capitalization at
		the start of the process.

		On Windows on remaining targets, variable name capitalization matches however they were capitalized
		at the start of the process or at the moment of their creation.</haxe_doc>
		</environment>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" line="36" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="50" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="57" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="61" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="67" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="72" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="80" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="88" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="95" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="99" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="103" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="110" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="114" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="119" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="124" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<nativeEnumEq set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_enum_eq"</e></m></meta>
		</nativeEnumEq>
		<enumEq public="1" params="T" set="method" line="151" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="153" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<getEnumValueIndex set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_getEnumValueIndex"</e></m></meta>
		</getEnumValueIndex>
		<enumIndex public="1" set="method" line="166" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="170" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="UInt" params="" file="/home/nanjizal/haxe/versions/779b005/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/UInt.hx" private="1" module="UInt" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="XmlType" params="" file="/home/nanjizal/haxe/versions/779b005/std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/Xml.hx" private="1" module="Xml" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="Xml" params="" file="/home/nanjizal/haxe/versions/779b005/std/Xml.hx" extern="1">
		<Element public="1" set="null" expr="XmlType.Element" line="86" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Element</e></m></meta>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" expr="XmlType.PCData" line="91" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.PCData</e></m></meta>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" expr="XmlType.CData" line="96" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.CData</e></m></meta>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" expr="XmlType.Comment" line="101" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Comment</e></m></meta>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" expr="XmlType.DocType" line="106" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.DocType</e></m></meta>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" expr="XmlType.ProcessingInstruction" line="111" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.ProcessingInstruction</e></m></meta>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" expr="XmlType.Document" line="116" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Document</e></m></meta>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="121" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="182" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="191" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="200" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="209" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="218" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="227" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="236" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></attributeMap>
		<get_nodeName set="method" line="151"><f a=""><c path="String"/></f></get_nodeName>
		<set_nodeName set="method" line="158"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeName>
		<get_nodeValue set="method" line="165"><f a=""><c path="String"/></f></get_nodeValue>
		<set_nodeValue set="method" line="172"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeValue>
		<get public="1" set="method" line="244">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="255">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<remove public="1" set="method" line="266">
			<f a="att">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an attribute for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="277">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="287">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an `Iterator` on all the attribute names.</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="298">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="307">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="317">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="329">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node.</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="337">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="353">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="366">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="381">
			<f a="x:pos">
				<c path="Xml"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.
		A child node can only be inside one given parent node, which is indicated by the [parent] property.
		If the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="393">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<ensureElementType get="inline" set="null" line="403"><f a=""><x path="Void"/></f></ensureElementType>
		<new set="method" line="397"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Cross-platform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cpp.ArrayBase" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/ArrayBase.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getElementSize public="1" set="method"><f a=""><x path="Int"/></f></getElementSize>
		<getByteCount public="1" set="method"><f a=""><x path="Int"/></f></getByteCount>
		<getBase public="1" set="method"><f a=""><c path="cpp.RawPointer"><x path="cpp.Char"/></c></f></getBase>
	</class>
	<class path="cpp.AutoCast" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/AutoCast.hx" extern="1"/>
	<typedef path="cpp.CallableData" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Callable.hx" module="cpp.Callable">
		<c path="cpp.CallableData.T"/>
		<meta>
			<m n=":noPackageRestrict"/>
			<m n=":callable"/>
		</meta>
	</typedef>
	<abstract path="cpp.Callable" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Callable.hx">
		<from><icast field="fromFunction"><x path="cpp.Function">
	<c path="fromFunction.F"/>
	<c path="cpp.abi.Abi"/>
</x></icast></from>
		<this><t path="cpp.CallableData"><c path="cpp.Callable.T"/></t></this>
		<to><icast field="toFunction"><x path="cpp.Function">
	<c path="cpp.Callable.T"/>
	<c path="cpp.abi.Abi"/>
</x></icast></to>
		<haxe_doc><![CDATA[The generator intercepts this type and converts it to a cpp.Function<T> on cpp.]]></haxe_doc>
		<meta>
			<m n=":noPackageRestrict"/>
			<m n=":callable"/>
		</meta>
		<impl><class path="cpp._Callable.Callable_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Callable.hx" private="1" module="cpp.Callable" extern="1" final="1">
	<_new public="1" get="inline" set="null" line="37" static="1">
		<f a="inValue">
			<c path="cpp.Callable.T"/>
			<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<call public="1" get="accessor" set="null" static="1"><t path="cpp.CallableData"><c path="cpp.Callable.T"/></t></call>
	<get_call public="1" get="inline" set="null" line="43" static="1"><f a="this">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
</f></get_call>
	<fromFunction public="1" params="F" get="inline" set="null" line="48" static="1">
		<f a="func">
			<x path="cpp.Function">
				<c path="fromFunction.F"/>
				<c path="cpp.abi.Abi"/>
			</x>
			<x path="cpp.Callable"><c path="fromFunction.F"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromFunction>
	<toFunction public="1" get="inline" set="null" line="52" static="1">
		<f a="this">
			<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
			<x path="cpp.Function">
				<c path="cpp.Callable.T"/>
				<c path="cpp.abi.Abi"/>
			</x>
		</f>
		<meta><m n=":to"/></meta>
	</toFunction>
	<getProcAddress public="1" params="T:ABI" get="inline" set="null" line="55" static="1"><f a="inModule:inFunction">
	<c path="String"/>
	<c path="String"/>
	<x path="cpp.Function">
		<c path="getProcAddress.T"/>
		<c path="getProcAddress.ABI"/>
	</x>
</f></getProcAddress>
	<fromStaticFunction public="1" params="T" get="inline" set="null" line="58" static="1"><f a="inStaticFunction">
	<c path="fromStaticFunction.T"/>
	<x path="cpp.Callable"><c path="fromStaticFunction.T"/></x>
</f></fromStaticFunction>
	<lt public="1" get="inline" set="null" line="61" static="1"><f a="this:inOther">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
	<x path="Bool"/>
</f></lt>
	<leq public="1" get="inline" set="null" line="64" static="1"><f a="this:inOther">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
	<x path="Bool"/>
</f></leq>
	<gt public="1" get="inline" set="null" line="67" static="1"><f a="this:inOther">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
	<x path="Bool"/>
</f></gt>
	<geq public="1" get="inline" set="null" line="70" static="1"><f a="this:inOther">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
	<x path="Bool"/>
</f></geq>
</class></impl>
	</abstract>
	<class path="cpp._Callable.Callable_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Callable.hx" private="1" module="cpp.Callable" extern="1" final="1">
		<_new public="1" get="inline" set="null" line="37" static="1">
			<f a="inValue">
				<c path="cpp.Callable.T"/>
				<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<call public="1" get="accessor" set="null" static="1"><t path="cpp.CallableData"><c path="cpp.Callable.T"/></t></call>
		<get_call public="1" get="inline" set="null" line="43" static="1"><f a="this">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
</f></get_call>
		<fromFunction public="1" params="F" get="inline" set="null" line="48" static="1">
			<f a="func">
				<x path="cpp.Function">
					<c path="fromFunction.F"/>
					<c path="cpp.abi.Abi"/>
				</x>
				<x path="cpp.Callable"><c path="fromFunction.F"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromFunction>
		<toFunction public="1" get="inline" set="null" line="52" static="1">
			<f a="this">
				<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
				<x path="cpp.Function">
					<c path="cpp.Callable.T"/>
					<c path="cpp.abi.Abi"/>
				</x>
			</f>
			<meta><m n=":to"/></meta>
		</toFunction>
		<getProcAddress public="1" params="T:ABI" get="inline" set="null" line="55" static="1"><f a="inModule:inFunction">
	<c path="String"/>
	<c path="String"/>
	<x path="cpp.Function">
		<c path="getProcAddress.T"/>
		<c path="getProcAddress.ABI"/>
	</x>
</f></getProcAddress>
		<fromStaticFunction public="1" params="T" get="inline" set="null" line="58" static="1"><f a="inStaticFunction">
	<c path="fromStaticFunction.T"/>
	<x path="cpp.Callable"><c path="fromStaticFunction.T"/></x>
</f></fromStaticFunction>
		<lt public="1" get="inline" set="null" line="61" static="1"><f a="this:inOther">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
	<x path="Bool"/>
</f></lt>
		<leq public="1" get="inline" set="null" line="64" static="1"><f a="this:inOther">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
	<x path="Bool"/>
</f></leq>
		<gt public="1" get="inline" set="null" line="67" static="1"><f a="this:inOther">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
	<x path="Bool"/>
</f></gt>
		<geq public="1" get="inline" set="null" line="70" static="1"><f a="this:inOther">
	<t path="cpp.CallableData"><c path="cpp.Callable.T"/></t>
	<x path="cpp.Callable"><c path="cpp.Callable.T"/></x>
	<x path="Bool"/>
</f></geq>
	</class>
	<abstract path="cpp.Char" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Char.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cpp.Char"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="cpp.ConstCharStar" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/ConstCharStar.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></this>
		<to>
			<icast><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></icast>
			<icast field="toString"><c path="String"/></icast>
			<icast field="toPointer"><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></icast>
		</to>
		<impl><class path="cpp._ConstCharStar.ConstCharStar_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/ConstCharStar.hx" private="1" module="cpp.ConstCharStar" extern="1" final="1">
	<_new public="1" get="inline" set="null" line="26" static="1">
		<f a="s">
			<c path="String"/>
			<x path="cpp.ConstCharStar"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromString public="1" get="inline" set="null" line="31" static="1">
		<f a="s">
			<c path="String"/>
			<x path="cpp.ConstCharStar"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="34" static="1">
		<f a="this">
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			<c path="String"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":to"/>
		</meta>
	</toString>
	<toPointer public="1" get="inline" set="null" line="37" static="1">
		<f a="this">
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</toPointer>
</class></impl>
	</abstract>
	<class path="cpp._ConstCharStar.ConstCharStar_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/ConstCharStar.hx" private="1" module="cpp.ConstCharStar" extern="1" final="1">
		<_new public="1" get="inline" set="null" line="26" static="1">
			<f a="s">
				<c path="String"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromString public="1" get="inline" set="null" line="31" static="1">
			<f a="s">
				<c path="String"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="34" static="1">
			<f a="this">
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":to"/>
			</meta>
		</toString>
		<toPointer public="1" get="inline" set="null" line="37" static="1">
			<f a="this">
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</toPointer>
	</class>
	<class path="cpp.ConstPointer" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/ConstPointer.hx" extern="1">
		<fromRaw public="1" params="T" set="method" static="1"><f a="ptr">
	<c path="cpp.RawConstPointer"><c path="fromRaw.T"/></c>
	<c path="cpp.ConstPointer"><c path="fromRaw.T"/></c>
</f></fromRaw>
		<fromStar public="1" params="T" set="method" static="1">
			<f a="star">
				<t path="cpp.Star"><c path="fromStar.T"/></t>
				<c path="cpp.ConstPointer"><c path="fromStar.T"/></c>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromRaw"</e></m></meta>
		</fromStar>
		<fromPointer public="1" params="T" set="method" static="1"><f a="inNativePointer">
	<d/>
	<c path="cpp.ConstPointer"><c path="fromPointer.T"/></c>
</f></fromPointer>
		<ptr public="1"><t path="cpp.Star"><c path="cpp.ConstPointer.T"/></t></ptr>
		<value public="1" get="accessor" set="null"><c path="cpp.ConstPointer.T"/></value>
		<raw public="1" get="accessor" set="null"><c path="cpp.RawPointer"><c path="cpp.ConstPointer.T"/></c></raw>
		<constRaw public="1" get="accessor" set="null"><c path="cpp.RawConstPointer"><c path="cpp.ConstPointer.T"/></c></constRaw>
		<get_value public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t></f></get_value>
		<get_constRaw public="1" set="method"><f a=""><c path="cpp.RawConstPointer"><c path="cpp.ConstPointer.T"/></c></f></get_constRaw>
		<get_raw public="1" set="method"><f a=""><c path="cpp.RawPointer"><c path="cpp.ConstPointer.T"/></c></f></get_raw>
		<lt public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></lt>
		<leq public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></leq>
		<gt public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></gt>
		<geq public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></geq>
		<setRaw public="1" params="O" set="method"><f a="ptr">
	<c path="cpp.RawPointer"><c path="setRaw.O"/></c>
	<x path="Void"/>
</f></setRaw>
		<reinterpret public="1" params="Other" set="method"><f a=""><c path="cpp.Pointer"><c path="reinterpret.Other"/></c></f></reinterpret>
		<rawCast public="1" params="Other" set="method"><f a=""><c path="cpp.RawPointer"><c path="rawCast.Other"/></c></f></rawCast>
		<at public="1" set="method"><f a="inIndex">
	<x path="Int"/>
	<t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t>
</f></at>
		<inc public="1" set="method"><f a=""><c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c></f></inc>
		<dec public="1" set="method"><f a=""><c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c></f></dec>
		<incBy public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></incBy>
		<decBy public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></decBy>
		<add public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></add>
		<sub public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></sub>
		<postIncVal public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t></f></postIncVal>
		<meta>
			<m n=":coreType"/>
			<m n=":include"><e>"cpp/Pointer.h"</e></m>
			<m n=":native"><e>"cpp.Pointer"</e></m>
			<m n=":semantics"><e>variable</e></m>
		</meta>
	</class>
	<class path="cpp.EnumBase" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/EnumBase.hx" extern="1">
		<_hx_getIndex public="1" set="method"><f a=""><x path="Int"/></f></_hx_getIndex>
		<_hx_getTag public="1" set="method"><f a=""><c path="String"/></f></_hx_getTag>
		<_hx_getParamCount public="1" set="method"><f a=""><x path="Int"/></f></_hx_getParamCount>
		<_hx_getParamI public="1" set="method"><f a="inIndex">
	<x path="Int"/>
	<d/>
</f></_hx_getParamI>
		<_hx_getParameters public="1" set="method"><f a=""><c path="Array"><d/></c></f></_hx_getParameters>
		<getIndex public="1" get="inline" set="null" line="35"><f a=""><x path="Int"/></f></getIndex>
		<getTag public="1" get="inline" set="null" line="37"><f a=""><c path="String"/></f></getTag>
		<getParamCount public="1" get="inline" set="null" line="39"><f a=""><x path="Int"/></f></getParamCount>
		<getParamI public="1" get="inline" set="null" line="41"><f a="inIndex">
	<x path="Int"/>
	<d/>
</f></getParamI>
		<getParameters public="1" get="inline" set="null" line="43"><f a=""><c path="Array"><d/></c></f></getParameters>
		<meta><m n=":native"><e>"hx.EnumBase"</e></m></meta>
	</class>
	<class path="cpp.ErrorConstants" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/ErrorConstants.hx" extern="1">
		<invalidCast public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_CAST"</e></m></meta>
		</invalidCast>
		<indexOutOfBounds public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INDEX_OUT_OF_BOUNDS"</e></m></meta>
		</indexOutOfBounds>
		<invalidObject public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_OBJECT"</e></m></meta>
		</invalidObject>
		<invalidArgCount public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_ARG_COUNT"</e></m></meta>
		</invalidArgCount>
		<nullFunctionPointer public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_NULL_FUNCTION_POINTER"</e></m></meta>
		</nullFunctionPointer>
	</class>
	<typedef path="cpp.FunctionData" params="T:ABI" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Function.hx" module="cpp.Function">
		<c path="cpp.FunctionData.T"/>
		<meta><m n=":callable"/></meta>
	</typedef>
	<abstract path="cpp.Function" params="T:ABI" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Function.hx">
		<this><t path="cpp.FunctionData">
	<c path="cpp.Function.T"/>
	<c path="cpp.Function.ABI"/>
</t></this>
		<meta>
			<m n=":include"><e>"cpp/Pointer.h"</e></m>
			<m n=":callable"/>
		</meta>
		<impl><class path="cpp._Function.Function_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Function.hx" private="1" module="cpp.Function" extern="1" final="1">
	<_new public="1" get="inline" set="null" line="30" static="1">
		<f a="inValue">
			<c path="cpp.Function.T"/>
			<x path="cpp.Function">
				<c path="cpp.Function.T"/>
				<c path="cpp.Function.ABI"/>
			</x>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<call public="1" get="accessor" set="null" static="1"><t path="cpp.FunctionData">
	<c path="cpp.Function.T"/>
	<c path="cpp.Function.ABI"/>
</t></call>
	<get_call public="1" get="inline" set="null" line="37" static="1"><f a="this">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
</f></get_call>
	<nativeGetProcAddress public="1" params="T:ABI" set="method" static="1">
		<f a="inModule:inFunction">
			<c path="String"/>
			<c path="String"/>
			<c path="cpp.AutoCast"/>
		</f>
		<meta><m n=":native"><e>"::cpp::Function_obj::getProcAddress"</e></m></meta>
	</nativeGetProcAddress>
	<getProcAddress public="1" params="T:ABI" get="inline" set="null" line="42" static="1"><f a="inModule:inFunction">
	<c path="String"/>
	<c path="String"/>
	<x path="cpp.Function">
		<c path="getProcAddress.T"/>
		<c path="getProcAddress.ABI"/>
	</x>
</f></getProcAddress>
	<nativeFromStaticFunction public="1" params="T" set="method" static="1">
		<f a="inStaticFunction">
			<c path="nativeFromStaticFunction.T"/>
			<c path="cpp.AutoCast"/>
		</f>
		<meta><m n=":native"><e>"::cpp::Function_obj::fromStaticFunction"</e></m></meta>
	</nativeFromStaticFunction>
	<fromStaticFunction public="1" params="T" get="inline" set="null" line="49" static="1"><f a="inStaticFunction">
	<c path="fromStaticFunction.T"/>
	<x path="cpp.Callable"><c path="fromStaticFunction.T"/></x>
</f></fromStaticFunction>
	<lt public="1" set="method" static="1"><f a="this:inOther">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<x path="cpp.Function">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</x>
	<x path="Bool"/>
</f></lt>
	<leq public="1" set="method" static="1"><f a="this:inOther">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<x path="cpp.Function">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</x>
	<x path="Bool"/>
</f></leq>
	<gt public="1" set="method" static="1"><f a="this:inOther">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<x path="cpp.Function">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</x>
	<x path="Bool"/>
</f></gt>
	<geq public="1" set="method" static="1"><f a="this:inOther">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<x path="cpp.Function">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</x>
	<x path="Bool"/>
</f></geq>
</class></impl>
	</abstract>
	<class path="cpp._Function.Function_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Function.hx" private="1" module="cpp.Function" extern="1" final="1">
		<_new public="1" get="inline" set="null" line="30" static="1">
			<f a="inValue">
				<c path="cpp.Function.T"/>
				<x path="cpp.Function">
					<c path="cpp.Function.T"/>
					<c path="cpp.Function.ABI"/>
				</x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<call public="1" get="accessor" set="null" static="1"><t path="cpp.FunctionData">
	<c path="cpp.Function.T"/>
	<c path="cpp.Function.ABI"/>
</t></call>
		<get_call public="1" get="inline" set="null" line="37" static="1"><f a="this">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
</f></get_call>
		<nativeGetProcAddress public="1" params="T:ABI" set="method" static="1">
			<f a="inModule:inFunction">
				<c path="String"/>
				<c path="String"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Function_obj::getProcAddress"</e></m></meta>
		</nativeGetProcAddress>
		<getProcAddress public="1" params="T:ABI" get="inline" set="null" line="42" static="1"><f a="inModule:inFunction">
	<c path="String"/>
	<c path="String"/>
	<x path="cpp.Function">
		<c path="getProcAddress.T"/>
		<c path="getProcAddress.ABI"/>
	</x>
</f></getProcAddress>
		<nativeFromStaticFunction public="1" params="T" set="method" static="1">
			<f a="inStaticFunction">
				<c path="nativeFromStaticFunction.T"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Function_obj::fromStaticFunction"</e></m></meta>
		</nativeFromStaticFunction>
		<fromStaticFunction public="1" params="T" get="inline" set="null" line="49" static="1"><f a="inStaticFunction">
	<c path="fromStaticFunction.T"/>
	<x path="cpp.Callable"><c path="fromStaticFunction.T"/></x>
</f></fromStaticFunction>
		<lt public="1" set="method" static="1"><f a="this:inOther">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<x path="cpp.Function">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</x>
	<x path="Bool"/>
</f></lt>
		<leq public="1" set="method" static="1"><f a="this:inOther">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<x path="cpp.Function">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</x>
	<x path="Bool"/>
</f></leq>
		<gt public="1" set="method" static="1"><f a="this:inOther">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<x path="cpp.Function">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</x>
	<x path="Bool"/>
</f></gt>
		<geq public="1" set="method" static="1"><f a="this:inOther">
	<t path="cpp.FunctionData">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</t>
	<x path="cpp.Function">
		<c path="cpp.Function.T"/>
		<c path="cpp.Function.ABI"/>
	</x>
	<x path="Bool"/>
</f></geq>
	</class>
	<class path="cpp.Lib" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Lib.hx" extern="1">
		<load public="1" set="method" line="34" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<unloadAllLibraries public="1" set="method" line="46" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Unloaded all dynamic libraries in reverse order of loading.
		Returns the number of libraries unloaded.</haxe_doc>
		</unloadAllLibraries>
		<_loadPrime public="1" set="method" line="50" static="1">
			<f a="lib:prim:signature:?quietFail" v=":::false">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ quietFail : false }</e></m>
			</meta>
		</_loadPrime>
		<loadLazy public="1" set="method" line="65" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tries to load, and always returns a valid function, but the function may throw
		if called.</haxe_doc>
		</loadLazy>
		<do_rethrow set="method" static="1">
			<f a="inExp">
				<d/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noDebug"/>
				<m n=":native"><e>"HX_STACK_DO_RETHROW"</e></m>
			</meta>
		</do_rethrow>
		<rethrow public="1" set="method" line="85" static="1">
			<f a="inExp">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</rethrow>
		<stringReference public="1" set="method" line="89" static="1">
			<f a="inBytes">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</stringReference>
		<pushDllSearchPath public="1" set="method" line="96" static="1">
			<f a="inPath">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</pushDllSearchPath>
		<getDllExtension public="1" set="method" line="99" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</getDllExtension>
		<getBinDirectory public="1" set="method" line="102" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</getBinDirectory>
		<bytesReference public="1" get="inline" set="null" line="110" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns bytes referencing the content of a string.
		Use with extreme caution - changing constant strings will crash.
		Changing one string can cause others to change unexpectedly.
		Only really safe if you are using it read-only or if it comes from stringReference above</haxe_doc>
		</bytesReference>
		<print public="1" set="method" line="119" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Print the specified value on the default output.</haxe_doc>
		</print>
		<haxeToNeko public="1" set="method" line="127" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</haxeToNeko>
		<nekoToHaxe public="1" set="method" line="135" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</nekoToHaxe>
		<println public="1" set="method" line="142" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Print the specified value on the default output followed by a newline character.</haxe_doc>
		</println>
		<setFloatFormat public="1" set="method" line="146" static="1">
			<f a="inFormat">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFloatFormat>
		<haxe_doc>Platform-specific Cpp Library. Provides some platform-specific functions
	for the C++ target, such as conversion from Haxe types to native types
	and vice-versa.</haxe_doc>
	</class>
	<class path="cpp.NativeArray" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/NativeArray.hx" extern="1">
		<create public="1" params="T" get="inline" set="null" line="27" static="1"><f a="length">
	<x path="Int"/>
	<c path="Array"><c path="create.T"/></c>
</f></create>
		<blit public="1" params="T" get="inline" set="null" line="37" static="1">
			<f a="ioDestArray:inDestElement:inSourceArray:inSourceElement:inElementCount">
				<c path="Array"><c path="blit.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="blit.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</blit>
		<getBase public="1" get="inline" set="null" line="41" static="1">
			<f a="inArray">
				<c path="Array"><d/></c>
				<c path="cpp.ArrayBase"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getBase>
		<reserve public="1" params="T" set="method" static="1">
			<f a="inArray:inElements">
				<c path="Array"><c path="reserve.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</reserve>
		<capacity public="1" params="T" set="method" static="1">
			<f a="inArray">
				<c path="Array"><c path="capacity.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</capacity>
		<getElementSize public="1" params="T" set="method" static="1">
			<f a="inArray">
				<c path="Array"><c path="getElementSize.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</getElementSize>
		<address public="1" params="T" get="inline" set="null" line="54" static="1"><f a="inArray:inIndex">
	<c path="Array"><c path="address.T"/></c>
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="address.T"/></c>
</f></address>
		<setData public="1" params="T" set="method" static="1">
			<f a="inArray:inData:inElementCount">
				<c path="Array"><c path="setData.T"/></c>
				<c path="cpp.Pointer"><c path="setData.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</setData>
		<setUnmanagedData public="1" params="T" set="method" static="1">
			<f a="inArray:inData:inElementCount">
				<c path="Array"><c path="setUnmanagedData.T"/></c>
				<c path="cpp.ConstPointer"><c path="setUnmanagedData.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</setUnmanagedData>
		<zero public="1" params="T" set="method" static="1">
			<f a="ioDestArray:?inFirst:?inElements">
				<c path="Array"><c path="zero.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</zero>
		<removeAt public="1" params="T" set="method" static="1">
			<f a="ioDestArray:inIndex">
				<c path="Array"><c path="removeAt.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</removeAt>
		<memcmp public="1" params="T" set="method" static="1">
			<f a="inArrayA:inArrayB">
				<c path="Array"><c path="memcmp.T"/></c>
				<c path="Array"><c path="memcmp.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</memcmp>
		<resolveVirtualArray public="1" set="method" static="1">
			<f a="inArray">
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_reslove_virtual_array"</e></m></meta>
		</resolveVirtualArray>
		<unsafeGet public="1" params="T" get="inline" set="null" line="77" static="1">
			<f a="inDestArray:inIndex">
				<c path="Array"><c path="unsafeGet.T"/></c>
				<x path="Int"/>
				<c path="unsafeGet.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="ioDestArray:inIndex:inValue">
				<c path="Array"><c path="unsafeSet.T"/></c>
				<x path="Int"/>
				<c path="unsafeSet.T"/>
				<c path="unsafeSet.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</unsafeSet>
		<setSize public="1" params="T" get="inline" set="null" line="85" static="1">
			<f a="ioArray:inSize">
				<c path="Array"><c path="setSize.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="setSize.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setSize>
	</class>
	<class path="cpp.NativeFile" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/NativeFile.hx" extern="1">
		<file_open public="1" set="method" static="1">
			<f a="fname:r">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_open"</e></m></meta>
		</file_open>
		<file_close public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_close"</e></m></meta>
		</file_close>
		<file_write public="1" set="method" static="1">
			<f a="handle:s:p:n">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_write"</e></m></meta>
		</file_write>
		<file_write_char public="1" set="method" static="1">
			<f a="handle:c">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_write_char"</e></m></meta>
		</file_write_char>
		<file_read public="1" set="method" static="1">
			<f a="handle:s:p:n">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_read"</e></m></meta>
		</file_read>
		<file_read_char public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_read_char"</e></m></meta>
		</file_read_char>
		<file_seek public="1" set="method" static="1">
			<f a="handle:pos:kind">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_seek"</e></m></meta>
		</file_seek>
		<file_tell public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_tell"</e></m></meta>
		</file_tell>
		<file_eof public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_eof"</e></m></meta>
		</file_eof>
		<file_flush public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_flush"</e></m></meta>
		</file_flush>
		<file_contents_string public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_contents_string"</e></m></meta>
		</file_contents_string>
		<file_contents_bytes public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_contents_bytes"</e></m></meta>
		</file_contents_bytes>
		<file_stdin public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stdin"</e></m></meta>
		</file_stdin>
		<file_stdout public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stdout"</e></m></meta>
		</file_stdout>
		<file_stderr public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stderr"</e></m></meta>
		</file_stderr>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<class path="cpp.NativeSocket" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/NativeSocket.hx" extern="1">
		<socket_init public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"_hx_std_socket_init"</e></m></meta>
		</socket_init>
		<socket_new public="1" set="method" static="1">
			<f a="udp">
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_new"</e></m></meta>
		</socket_new>
		<socket_new_ip public="1" set="method" static="1">
			<f a="udp:ipv6">
				<x path="Bool"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_new"</e></m></meta>
		</socket_new_ip>
		<socket_close public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_close"</e></m></meta>
		</socket_close>
		<socket_bind public="1" set="method" static="1">
			<f a="o:host:port">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_bind"</e></m></meta>
		</socket_bind>
		<socket_bind_ipv6 public="1" set="method" static="1">
			<f a="o:host:port">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_bind_ipv6"</e></m></meta>
		</socket_bind_ipv6>
		<socket_send_char public="1" set="method" static="1">
			<f a="o:c">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_send_char"</e></m></meta>
		</socket_send_char>
		<socket_send public="1" set="method" static="1">
			<f a="o:buf:p:l">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_send"</e></m></meta>
		</socket_send>
		<socket_recv public="1" set="method" static="1">
			<f a="o:buf:p:l">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_recv"</e></m></meta>
		</socket_recv>
		<socket_recv_char public="1" set="method" static="1">
			<f a="o">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_recv_char"</e></m></meta>
		</socket_recv_char>
		<socket_write public="1" set="method" static="1">
			<f a="o:buf">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_write"</e></m></meta>
		</socket_write>
		<socket_read public="1" set="method" static="1">
			<f a="o">
				<d/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_read"</e></m></meta>
		</socket_read>
		<host_resolve_ipv6 public="1" set="method" static="1">
			<f a="host">
				<c path="String"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_host_resolve_ipv6"</e></m></meta>
		</host_resolve_ipv6>
		<host_resolve public="1" set="method" static="1">
			<f a="host">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_host_resolve"</e></m></meta>
		</host_resolve>
		<host_to_string public="1" set="method" static="1">
			<f a="ip">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_host_to_string"</e></m></meta>
		</host_to_string>
		<host_to_string_ipv6 public="1" set="method" static="1">
			<f a="ipv6">
				<t path="haxe.io.BytesData"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_host_to_string_ipv6"</e></m></meta>
		</host_to_string_ipv6>
		<host_reverse public="1" set="method" static="1">
			<f a="host">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_host_reverse"</e></m></meta>
		</host_reverse>
		<host_reverse_ipv6 public="1" set="method" static="1">
			<f a="ipv6">
				<t path="haxe.io.BytesData"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_host_reverse_ipv6"</e></m></meta>
		</host_reverse_ipv6>
		<host_local public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_host_local"</e></m></meta>
		</host_local>
		<host_local_ipv6 public="1" get="inline" set="null" line="87" static="1"><f a=""><c path="String"/></f></host_local_ipv6>
		<socket_connect public="1" set="method" static="1">
			<f a="o:host:port">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_connect"</e></m></meta>
		</socket_connect>
		<socket_connect_ipv6 public="1" set="method" static="1">
			<f a="o:host:port">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_connect_ipv6"</e></m></meta>
		</socket_connect_ipv6>
		<socket_listen public="1" set="method" static="1">
			<f a="o:n">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_listen"</e></m></meta>
		</socket_listen>
		<socket_select public="1" set="method" static="1">
			<f a="rs:ws:es:timeout">
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<d/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_select"</e></m></meta>
		</socket_select>
		<socket_fast_select public="1" set="method" static="1">
			<f a="rs:ws:es:timeout">
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_fast_select"</e></m></meta>
		</socket_fast_select>
		<socket_accept public="1" set="method" static="1">
			<f a="o">
				<d/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_accept"</e></m></meta>
		</socket_accept>
		<socket_peer public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_peer"</e></m></meta>
		</socket_peer>
		<socket_host public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_host"</e></m></meta>
		</socket_host>
		<socket_set_timeout public="1" set="method" static="1">
			<f a="o:t">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_set_timeout"</e></m></meta>
		</socket_set_timeout>
		<socket_shutdown public="1" set="method" static="1">
			<f a="o:r:w">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_shutdown"</e></m></meta>
		</socket_shutdown>
		<socket_set_blocking public="1" set="method" static="1">
			<f a="o:b">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_set_blocking"</e></m></meta>
		</socket_set_blocking>
		<socket_set_fast_send public="1" set="method" static="1">
			<f a="o:b">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_set_fast_send"</e></m></meta>
		</socket_set_fast_send>
		<socket_set_broadcast public="1" set="method" static="1">
			<f a="o:b">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_set_broadcast"</e></m></meta>
		</socket_set_broadcast>
		<socket_poll_alloc public="1" set="method" static="1">
			<f a="nsocks">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_poll_alloc"</e></m></meta>
		</socket_poll_alloc>
		<socket_poll_prepare public="1" set="method" static="1">
			<f a="pdata:rsocks:wsocks">
				<d/>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_poll_prepare"</e></m></meta>
		</socket_poll_prepare>
		<socket_poll_events public="1" set="method" static="1">
			<f a="pdata:timeout">
				<d/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_poll_events"</e></m></meta>
		</socket_poll_events>
		<socket_poll public="1" set="method" static="1">
			<f a="socks:pdata:timeout">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<d/>
				<x path="Float"/>
				<c path="Array"><c path="sys.net.Socket"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_poll"</e></m></meta>
		</socket_poll>
		<socket_send_to public="1" set="method" static="1">
			<f a="o:buf:p:l:inAddr">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_send_to"</e></m></meta>
		</socket_send_to>
		<socket_recv_from public="1" set="method" static="1">
			<f a="o:buf:p:l:outAddr">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_socket_recv_from"</e></m></meta>
		</socket_recv_from>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<class path="cpp.NativeSsl" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/NativeSsl.hx" extern="1">
		<ssl_debug_set public="1" set="method" static="1">
			<f a="int">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_debug_set"</e></m></meta>
		</ssl_debug_set>
		<ssl_new public="1" set="method" static="1">
			<f a="conf">
				<d/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_new"</e></m></meta>
		</ssl_new>
		<ssl_close public="1" set="method" static="1">
			<f a="ctx">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_close"</e></m></meta>
		</ssl_close>
		<ssl_handshake public="1" set="method" static="1">
			<f a="ctx">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_handshake"</e></m></meta>
		</ssl_handshake>
		<ssl_set_socket public="1" set="method" static="1">
			<f a="ctx:socket">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_set_socket"</e></m></meta>
		</ssl_set_socket>
		<ssl_set_hostname public="1" set="method" static="1">
			<f a="ctx:hostname">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_set_hostname"</e></m></meta>
		</ssl_set_hostname>
		<ssl_get_peer_certificate public="1" set="method" static="1">
			<f a="ctx">
				<d/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_get_peer_certificate"</e></m></meta>
		</ssl_get_peer_certificate>
		<ssl_get_verify_result public="1" set="method" static="1">
			<f a="ctx">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_get_verify_result"</e></m></meta>
		</ssl_get_verify_result>
		<ssl_send_char public="1" set="method" static="1">
			<f a="ctx:char">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_send_char"</e></m></meta>
		</ssl_send_char>
		<ssl_send public="1" set="method" static="1">
			<f a="ctx:buf:p:l">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_send"</e></m></meta>
		</ssl_send>
		<ssl_write public="1" set="method" static="1">
			<f a="ctx:data">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_write"</e></m></meta>
		</ssl_write>
		<ssl_recv_char public="1" set="method" static="1">
			<f a="ctx">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_recv_char"</e></m></meta>
		</ssl_recv_char>
		<ssl_recv public="1" set="method" static="1">
			<f a="ctx:buf:p:l">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_recv"</e></m></meta>
		</ssl_recv>
		<ssl_read public="1" set="method" static="1">
			<f a="ctx">
				<d/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_read"</e></m></meta>
		</ssl_read>
		<conf_new public="1" set="method" static="1">
			<f a="server">
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_conf_new"</e></m></meta>
		</conf_new>
		<conf_close public="1" set="method" static="1">
			<f a="conf">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_conf_close"</e></m></meta>
		</conf_close>
		<conf_set_ca public="1" set="method" static="1">
			<f a="conf:cert">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_conf_set_ca"</e></m></meta>
		</conf_set_ca>
		<conf_set_verify public="1" set="method" static="1">
			<f a="conf:mode">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_conf_set_verify"</e></m></meta>
		</conf_set_verify>
		<conf_set_cert public="1" set="method" static="1">
			<f a="conf:cert:pkey">
				<d/>
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_conf_set_cert"</e></m></meta>
		</conf_set_cert>
		<conf_set_servername_callback public="1" set="method" static="1">
			<f a="conf:cb">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_conf_set_servername_callback"</e></m></meta>
		</conf_set_servername_callback>
		<cert_load_defaults public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_ssl_cert_load_defaults"</e></m></meta>
		</cert_load_defaults>
		<cert_load_file public="1" set="method" static="1">
			<f a="file">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_load_file"</e></m></meta>
		</cert_load_file>
		<cert_load_path public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_load_path"</e></m></meta>
		</cert_load_path>
		<cert_get_subject public="1" set="method" static="1">
			<f a="cert:field">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_get_subject"</e></m></meta>
		</cert_get_subject>
		<cert_get_issuer public="1" set="method" static="1">
			<f a="cert:field">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_get_issuer"</e></m></meta>
		</cert_get_issuer>
		<cert_get_altnames public="1" set="method" static="1">
			<f a="cert">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_get_altnames"</e></m></meta>
		</cert_get_altnames>
		<cert_get_notbefore public="1" set="method" static="1">
			<f a="cert">
				<d/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_get_notbefore"</e></m></meta>
		</cert_get_notbefore>
		<cert_get_notafter public="1" set="method" static="1">
			<f a="cert">
				<d/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_get_notafter"</e></m></meta>
		</cert_get_notafter>
		<cert_get_next public="1" set="method" static="1">
			<f a="cert">
				<d/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_get_next"</e></m></meta>
		</cert_get_next>
		<cert_add_pem public="1" set="method" static="1">
			<f a="cert:data">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_add_pem"</e></m></meta>
		</cert_add_pem>
		<cert_add_der public="1" set="method" static="1">
			<f a="cert:data">
				<d/>
				<t path="haxe.io.BytesData"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_cert_add_der"</e></m></meta>
		</cert_add_der>
		<key_from_der public="1" set="method" static="1">
			<f a="data:pub">
				<t path="haxe.io.BytesData"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_key_from_der"</e></m></meta>
		</key_from_der>
		<key_from_pem public="1" set="method" static="1">
			<f a="data:pub:pass">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_key_from_pem"</e></m></meta>
		</key_from_pem>
		<dgst_make public="1" set="method" static="1">
			<f a="data:alg">
				<t path="haxe.io.BytesData"/>
				<c path="String"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_dgst_make"</e></m></meta>
		</dgst_make>
		<dgst_sign public="1" set="method" static="1">
			<f a="data:key:alg">
				<t path="haxe.io.BytesData"/>
				<d/>
				<c path="String"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_dgst_sign"</e></m></meta>
		</dgst_sign>
		<dgst_verify public="1" set="method" static="1">
			<f a="data:sign:key:alg">
				<t path="haxe.io.BytesData"/>
				<t path="haxe.io.BytesData"/>
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_ssl_dgst_verify"</e></m></meta>
		</dgst_verify>
		<init public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"_hx_ssl_init"</e></m></meta>
		</init>
		<meta><m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/ssl/Build.xml\"/>"]]></e></m></meta>
	</class>
	<class path="cpp.NativeString" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/NativeString.hx" extern="1">
		<raw public="1" get="inline" set="null" line="26" static="1">
			<f a="inString">
				<c path="String"/>
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</raw>
		<c_str public="1" get="inline" set="null" line="29" static="1">
			<f a="inString">
				<c path="String"/>
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</c_str>
		<fromPointer public="1" get="inline" set="null" line="32" static="1">
			<f a="inPtr">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromPointer>
		<fromGcPointer public="1" get="inline" set="null" line="35" static="1">
			<f a="inPtr:inLen">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromGcPointer>
		<parseFloat public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_float"</e></m></meta>
		</parseFloat>
		<parseSubstrFloat public="1" set="method" static="1">
			<f a="inString:start:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_float"</e></m></meta>
		</parseSubstrFloat>
		<parseInt public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_int"</e></m></meta>
		</parseInt>
		<parseSubstrInt public="1" set="method" static="1">
			<f a="inString:start:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_int"</e></m></meta>
		</parseSubstrInt>
		<compare public="1" set="method" static="1">
			<f a="inString0:inString1">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_string_compare"</e></m></meta>
		</compare>
		<utf8CharCodeAt public="1" set="method" static="1">
			<f a="inString:inIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_char_code_at"</e></m></meta>
		</utf8CharCodeAt>
		<utf8Length public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_length"</e></m></meta>
		</utf8Length>
		<utf8IsValid public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_is_valid"</e></m></meta>
		</utf8IsValid>
		<utf8Sub public="1" set="method" static="1">
			<f a="inString:charStart:inLen">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_sub"</e></m></meta>
		</utf8Sub>
		<fromPointerLen public="1" set="method" static="1">
			<f a="inPtr:len">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_string_create"</e></m></meta>
		</fromPointerLen>
		<utf8DecodeAdvance public="1" set="method" static="1">
			<f a="reference">
				<x path="cpp.Char"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_decode_advance"</e></m></meta>
		</utf8DecodeAdvance>
	</class>
	<class path="cpp.NativeSys" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/NativeSys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_print"</e></m></meta>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_println"</e></m></meta>
		</println>
		<get_env public="1" set="method" static="1">
			<f a="v">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_get_env"</e></m></meta>
		</get_env>
		<put_env public="1" set="method" static="1">
			<f a="e:v">
				<c path="String"/>
				<x path="Null"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_put_env"</e></m></meta>
		</put_env>
		<sys_sleep public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_sleep"</e></m></meta>
		</sys_sleep>
		<set_time_locale public="1" set="method" static="1">
			<f a="l">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_set_time_locale"</e></m></meta>
		</set_time_locale>
		<get_cwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_get_cwd"</e></m></meta>
		</get_cwd>
		<set_cwd public="1" set="method" static="1">
			<f a="d">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_set_cwd"</e></m></meta>
		</set_cwd>
		<sys_string public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_string"</e></m></meta>
		</sys_string>
		<sys_is64 public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_is64"</e></m></meta>
		</sys_is64>
		<sys_command public="1" set="method" static="1">
			<f a="cmd">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_command"</e></m></meta>
		</sys_command>
		<sys_exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_exit"</e></m></meta>
		</sys_exit>
		<sys_exists public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_exists"</e></m></meta>
		</sys_exists>
		<file_delete public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_delete"</e></m></meta>
		</file_delete>
		<sys_rename public="1" set="method" static="1">
			<f a="path:newname">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_rename"</e></m></meta>
		</sys_rename>
		<sys_stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_stat"</e></m></meta>
		</sys_stat>
		<sys_file_type public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_file_type"</e></m></meta>
		</sys_file_type>
		<sys_create_dir public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_create_dir"</e></m></meta>
		</sys_create_dir>
		<sys_remove_dir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_remove_dir"</e></m></meta>
		</sys_remove_dir>
		<sys_time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_time"</e></m></meta>
		</sys_time>
		<sys_cpu_time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_cpu_time"</e></m></meta>
		</sys_cpu_time>
		<sys_read_dir public="1" set="method" static="1">
			<f a="p">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_read_dir"</e></m></meta>
		</sys_read_dir>
		<file_full_path public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_full_path"</e></m></meta>
		</file_full_path>
		<sys_exe_path public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_exe_path"</e></m></meta>
		</sys_exe_path>
		<sys_env public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":native"><e>"_hx_std_sys_env"</e></m></meta>
		</sys_env>
		<sys_getch public="1" set="method" static="1">
			<f a="b">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_getch"</e></m></meta>
		</sys_getch>
		<sys_get_pid public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_get_pid"</e></m></meta>
		</sys_get_pid>
		<meta><m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m></meta>
	</class>
	<typedef path="cpp.Object" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Object.hx">
		<d/>
		<meta><m n=":noPackageRestrict"/></meta>
	</typedef>
	<class path="cpp.ObjectType" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/ObjectType.hx" extern="1">
		<vtUnknown public="1" get="inline" set="null" expr="-1" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</vtUnknown>
		<vtInt public="1" get="inline" set="null" expr="0xff" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xff</e></m></meta>
		</vtInt>
		<vtNull public="1" get="inline" set="null" expr="0" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vtNull>
		<vtFloat public="1" get="inline" set="null" expr="1" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</vtFloat>
		<vtBool public="1" get="inline" set="null" expr="2" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</vtBool>
		<vtString public="1" get="inline" set="null" expr="3" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</vtString>
		<vtObject public="1" get="inline" set="null" expr="4" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</vtObject>
		<vtArray public="1" get="inline" set="null" expr="5" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</vtArray>
		<vtFunction public="1" get="inline" set="null" expr="6" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</vtFunction>
		<vtEnum public="1" get="inline" set="null" expr="7" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</vtEnum>
		<vtClass public="1" get="inline" set="null" expr="8" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</vtClass>
		<vtInt64 public="1" get="inline" set="null" expr="9" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</vtInt64>
		<vtAbstractBase public="1" get="inline" set="null" expr="0x100" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100</e></m></meta>
		</vtAbstractBase>
	</class>
	<class path="cpp.Pointer" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Pointer.hx" extern="1">
		<extends path="cpp.ConstPointer"><c path="cpp.Pointer.T"/></extends>
		<fromRaw public="1" params="T" set="method" static="1"><f a="ptr">
	<c path="cpp.RawPointer"><c path="fromRaw.T"/></c>
	<c path="cpp.Pointer"><c path="fromRaw.T"/></c>
</f></fromRaw>
		<fromStar public="1" params="T" set="method" static="1">
			<f a="star">
				<t path="cpp.Star"><c path="fromStar.T"/></t>
				<c path="cpp.Pointer"><c path="fromStar.T"/></c>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromRaw"</e></m></meta>
		</fromStar>
		<nativeFromHandle public="1" params="T" set="method" static="1">
			<f a="inHandle:?inKind">
				<d/>
				<c path="String"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromHandle"</e></m></meta>
		</nativeFromHandle>
		<fromHandle public="1" params="T" get="inline" set="null" line="44" static="1"><f a="inHandle:?inKind">
	<d/>
	<c path="String"/>
	<c path="cpp.Pointer"><c path="fromHandle.T"/></c>
</f></fromHandle>
		<fromPointer public="1" params="T" set="method" static="1"><f a="inNativePointer">
	<d/>
	<c path="cpp.Pointer"><c path="fromPointer.T"/></c>
</f></fromPointer>
		<addressOf public="1" params="T" set="method" static="1"><f a="inVariable">
	<t path="cpp.Reference"><c path="addressOf.T"/></t>
	<c path="cpp.Pointer"><c path="addressOf.T"/></c>
</f></addressOf>
		<endOf public="1" params="T" set="method" static="1"><f a="inVariable">
	<c path="endOf.T"/>
	<c path="cpp.Pointer"><c path="cpp.Void"/></c>
</f></endOf>
		<nativeArrayElem public="1" params="T" set="method" static="1">
			<f a="array:inElem">
				<c path="Array"><c path="nativeArrayElem.T"/></c>
				<x path="Int"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::arrayElem"</e></m></meta>
		</nativeArrayElem>
		<arrayElem public="1" params="T" get="inline" set="null" line="56" static="1"><f a="array:inElem">
	<c path="Array"><c path="arrayElem.T"/></c>
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="arrayElem.T"/></c>
</f></arrayElem>
		<nativeOfArray public="1" params="T" set="method" static="1">
			<f a="array">
				<c path="Array"><c path="nativeOfArray.T"/></c>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::ofArray"</e></m></meta>
		</nativeOfArray>
		<ofArray public="1" params="T" get="inline" set="null" line="62" static="1"><f a="array">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="cpp.Pointer"><c path="ofArray.T"/></c>
</f></ofArray>
		<ref public="1" get="accessor" set="accessor"><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></ref>
		<get_ref public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></f></get_ref>
		<set_ref public="1" set="method"><f a="t">
	<c path="cpp.Pointer.T"/>
	<t path="cpp.Reference"><c path="cpp.Pointer.T"/></t>
</f></set_ref>
		<setAt public="1" set="method"><f a="inIndex:value">
	<x path="Int"/>
	<c path="cpp.Pointer.T"/>
	<x path="Void"/>
</f></setAt>
		<toUnmanagedArray public="1" get="inline" set="null" line="66"><f a="elementCount">
	<x path="Int"/>
	<c path="Array"><c path="cpp.Pointer.T"/></c>
</f></toUnmanagedArray>
		<toUnmanagedVector public="1" get="inline" set="null" line="73"><f a="elementCount">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><c path="cpp.Pointer.T"/></x>
</f></toUnmanagedVector>
		<inc public="1" set="method" override="1"><f a=""><c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c></f></inc>
		<dec public="1" set="method" override="1"><f a=""><c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c></f></dec>
		<incBy public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></incBy>
		<decBy public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></decBy>
		<add public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></add>
		<sub public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></sub>
		<postIncRef public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></f></postIncRef>
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<destroyArray public="1" set="method"><f a=""><x path="Void"/></f></destroyArray>
		<meta>
			<m n=":coreType"/>
			<m n=":semantics"><e>variable</e></m>
		</meta>
	</class>
	<class path="cpp.RawConstPointer" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/RawConstPointer.hx" extern="1">
		<addressOf public="1" params="T" set="method" static="1">
			<f a="t">
				<c path="addressOf.T"/>
				<c path="cpp.RawConstPointer"><c path="addressOf.T"/></c>
			</f>
			<meta><m n=":native"><e>"::hx::AddressOf"</e></m></meta>
		</addressOf>
		<meta><m n=":unreflective"/></meta>
	</class>
	<class path="cpp.RawPointer" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/RawPointer.hx" extern="1">
		<extends path="cpp.RawConstPointer"><c path="cpp.RawPointer.T"/></extends>
		<addressOf public="1" params="T" set="method" static="1">
			<f a="t">
				<c path="addressOf.T"/>
				<c path="cpp.RawPointer"><c path="addressOf.T"/></c>
			</f>
			<meta><m n=":native"><e>"::hx::AddressOf"</e></m></meta>
		</addressOf>
		<meta><m n=":unreflective"/></meta>
	</class>
	<typedef path="cpp.Reference" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Reference.hx">
		<c path="cpp.Reference.T"/>
		<haxe_doc>Allows haxe to type result correctly, and hxcpp can recognise this and
	prevent unwanted casting.</haxe_doc>
		<meta><m n=":semantics"><e>reference</e></m></meta>
	</typedef>
	<typedef path="cpp.Star" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Star.hx">
		<x path="Null"><c path="cpp.Star.T"/></x>
		<haxe_doc>Allows haxe to type result correctly, and hxcpp can recognise this use the
	correct type.</haxe_doc>
	</typedef>
	<abstract path="cpp.UInt8" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/UInt8.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cpp.UInt8"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="cpp.Void" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/Void.hx" extern="1"><meta><m n=":native"><e>"void"</e></m></meta></class>
	<class path="cpp.abi.Abi" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/abi/Abi.hx" extern="1"/>
	<enum path="format.png.Color" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/png/Data.hx" module="format.png.Data">
		<ColGrey a="alpha"><x path="Bool"/></ColGrey>
		<ColTrue a="alpha"><x path="Bool"/></ColTrue>
		<ColIndexed/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.png.Header" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/png/Data.hx" module="format.png.Data"><a>
	<width><x path="Int"/></width>
	<interlaced><x path="Bool"/></interlaced>
	<height><x path="Int"/></height>
	<color><e path="format.png.Color"/></color>
	<colbits><x path="Int"/></colbits>
</a></typedef>
	<enum path="format.png.Chunk" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/png/Data.hx" module="format.png.Data">
		<CEnd/>
		<CHeader a="h"><t path="format.png.Header"/></CHeader>
		<CData a="b"><c path="haxe.io.Bytes"/></CData>
		<CPalette a="b"><c path="haxe.io.Bytes"/></CPalette>
		<CUnknown a="id:data">
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
		</CUnknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.png.Data" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/png/Data.hx"><t path="List"><e path="format.png.Chunk"/></t></typedef>
	<class path="format.png.Reader" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/png/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<checkCRC public="1"><x path="Bool"/></checkCRC>
		<read public="1" set="method" line="41"><f a=""><t path="format.png.Data"/></f></read>
		<readHeader set="method" line="56"><f a="i">
	<c path="haxe.io.Input"/>
	<t path="format.png.Header"/>
</f></readHeader>
		<readChunk set="method" line="91"><f a=""><e path="format.png.Chunk"/></f></readChunk>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.png.Tools" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/png/Tools.hx">
		<getHeader public="1" set="method" line="35" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<t path="format.png.Header"/>
			</f>
			<haxe_doc>Returns the PNG header informations. Throws an exception if no header found.</haxe_doc>
		</getHeader>
		<getPalette public="1" set="method" line="47" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Return the PNG palette colors, or null if no palette chunk was found</haxe_doc>
		</getPalette>
		<filter get="inline" set="null" line="56" static="1">
			<f a="data:x:y:stride:prev:p:?numChannels" v="::::::4">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ numChannels : 4 }</e></m></meta>
		</filter>
		<reverseBytes public="1" set="method" line="69" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Converts from BGRA to ARGB and the other way by reversing bytes.</haxe_doc>
		</reverseBytes>
		<extractGrey public="1" set="method" line="106" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the greyscale PNG data and apply filters, extracting only the grey channel if alpha is present.</haxe_doc>
		</extractGrey>
		<extract32 public="1" set="method" line="205" static="1">
			<f a="d:?bytes:?flipY">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the PNG data and apply filters. By default this will output BGRA low-endian format. You can use the [reverseBytes] function to inverse the bytes to ARGB big-endian format.</haxe_doc>
		</extract32>
		<buildGrey public="1" set="method" line="653" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains one bytes (grey values) for each pixel.</haxe_doc>
		</buildGrey>
		<buildIndexed public="1" set="method" line="672" static="1">
			<f a="width:height:data:palette:?level" v="::::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains a one byte palette index for each pixel and a separate palette with 3 RGB bytes per color.</haxe_doc>
		</buildIndexed>
		<buildRGB public="1" set="method" line="691" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains three bytes (R,G and B values) for each pixel.</haxe_doc>
		</buildRGB>
		<build32ARGB public="1" set="method" line="714" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in ARGB format for each pixel.</haxe_doc>
		</build32ARGB>
		<build32BGRA public="1" set="method" line="738" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in BGRA format for each pixel.</haxe_doc>
		</build32BGRA>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.png.Writer" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/png/Writer.hx">
		<o><c path="haxe.io.Output"/></o>
		<write public="1" set="method" line="39"><f a="png">
	<t path="format.png.Data"/>
	<x path="Void"/>
</f></write>
		<writeChunk set="method" line="75"><f a="id:data">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></writeChunk>
		<new public="1" set="method" line="34"><f a="o">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.swf.Fixed" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><x path="Int"/></typedef>
	<typedef path="format.swf.Fixed8" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><x path="Int"/></typedef>
	<typedef path="format.swf.SWF" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<tags><c path="Array"><e path="format.swf.SWFTag"/></c></tags>
	<header><t path="format.swf.SWFHeader"/></header>
</a></typedef>
	<enum path="format.swf.SWFTag" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<TShowFrame/>
		<TShape a="id:data">
			<x path="Int"/>
			<e path="format.swf.ShapeData"/>
		</TShape>
		<TMorphShape a="id:data">
			<x path="Int"/>
			<e path="format.swf.MorphShapeData"/>
		</TMorphShape>
		<TFont a="id:data">
			<x path="Int"/>
			<e path="format.swf.FontData"/>
		</TFont>
		<TFontInfo a="id:data">
			<x path="Int"/>
			<e path="format.swf.FontInfoData"/>
		</TFontInfo>
		<TButton a="id:trackAsMenu:records">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="format.swf.ButtonRecord"/></c>
		</TButton>
		<TBackgroundColor a="color"><x path="Int"/></TBackgroundColor>
		<TDoActions a="data"><c path="haxe.io.Bytes"/></TDoActions>
		<TClip a="id:frames:tags">
			<x path="Int"/>
			<x path="Int"/>
			<c path="Array"><e path="format.swf.SWFTag"/></c>
		</TClip>
		<TPlaceObject2 a="po"><c path="format.swf.PlaceObject"/></TPlaceObject2>
		<TPlaceObject3 a="po"><c path="format.swf.PlaceObject"/></TPlaceObject3>
		<TRemoveObject2 a="depth"><x path="Int"/></TRemoveObject2>
		<TFrameLabel a="label:anchor">
			<c path="String"/>
			<x path="Bool"/>
		</TFrameLabel>
		<TExport a="el"><c path="Array"><a>
	<name><c path="String"/></name>
	<cid><x path="Int"/></cid>
</a></c></TExport>
		<TDoInitActions a="id:data">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
		</TDoInitActions>
		<TActionScript3 a="data:?context">
			<c path="haxe.io.Bytes"/>
			<t path="format.swf.AS3Context"/>
		</TActionScript3>
		<TSymbolClass a="symbols"><c path="Array"><t path="format.swf.SymData"/></c></TSymbolClass>
		<TExportAssets a="symbols"><c path="Array"><t path="format.swf.SymData"/></c></TExportAssets>
		<TSandBox a="useDirectBlit:useGpu:hasMeta:useAs3:useNetwork">
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</TSandBox>
		<TBitsLossless a="data"><t path="format.swf.Lossless"/></TBitsLossless>
		<TBitsLossless2 a="data"><t path="format.swf.Lossless"/></TBitsLossless2>
		<TBitsJPEG a="id:data">
			<x path="Int"/>
			<e path="format.swf.JPEGData"/>
		</TBitsJPEG>
		<TJPEGTables a="data"><c path="haxe.io.Bytes"/></TJPEGTables>
		<TBinaryData a="id:data">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
		</TBinaryData>
		<TSound a="data"><t path="format.swf.Sound"/></TSound>
		<TScenes a="scenes:labels">
			<c path="Array"><a>
	<offset><x path="Int"/></offset>
	<name><c path="String"/></name>
</a></c>
			<c path="Array"><a>
	<offset><x path="Int"/></offset>
	<name><c path="String"/></name>
</a></c>
		</TScenes>
		<TUnknown a="id:data">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
		</TUnknown>
	</enum>
	<typedef path="format.swf.SWFHeader" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<width><x path="Int"/></width>
	<version><x path="Int"/></version>
	<nframes><x path="Int"/></nframes>
	<height><x path="Int"/></height>
	<fps><t path="format.swf.Fixed8"/></fps>
	<compressed><x path="Bool"/></compressed>
</a></typedef>
	<typedef path="format.swf.AS3Context" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<label><c path="String"/></label>
	<id><x path="Int"/></id>
</a></typedef>
	<typedef path="format.swf.SymData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<className><c path="String"/></className>
	<cid><x path="Int"/></cid>
</a></typedef>
	<class path="format.swf.PlaceObject" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<depth public="1"><x path="Int"/></depth>
		<move public="1"><x path="Bool"/></move>
		<cid public="1"><x path="Null"><x path="Int"/></x></cid>
		<matrix public="1"><x path="Null"><t path="format.swf.Matrix"/></x></matrix>
		<color public="1"><x path="Null"><t path="format.swf.CXA"/></x></color>
		<ratio public="1"><x path="Null"><x path="Int"/></x></ratio>
		<instanceName public="1"><x path="Null"><c path="String"/></x></instanceName>
		<clipDepth public="1"><x path="Null"><x path="Int"/></x></clipDepth>
		<events public="1"><x path="Null"><c path="Array"><t path="format.swf.ClipEvent"/></c></x></events>
		<filters public="1"><x path="Null"><c path="Array"><e path="format.swf.Filter"/></c></x></filters>
		<blendMode public="1"><x path="Null"><e path="format.swf.BlendMode"/></x></blendMode>
		<bitmapCache public="1"><x path="Null"><x path="Int"/></x></bitmapCache>
		<hasImage public="1"><x path="Bool"/></hasImage>
		<className public="1"><x path="Null"><c path="String"/></x></className>
		<new public="1" set="method" line="104"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="format.swf.Rect" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<top><x path="Int"/></top>
	<right><x path="Int"/></right>
	<left><x path="Int"/></left>
	<bottom><x path="Int"/></bottom>
</a></typedef>
	<enum path="format.swf.ShapeData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<SHDShape1 a="bounds:shapes">
			<t path="format.swf.Rect"/>
			<t path="format.swf.ShapeWithStyleData"/>
		</SHDShape1>
		<SHDShape2 a="bounds:shapes">
			<t path="format.swf.Rect"/>
			<t path="format.swf.ShapeWithStyleData"/>
		</SHDShape2>
		<SHDShape3 a="bounds:shapes">
			<t path="format.swf.Rect"/>
			<t path="format.swf.ShapeWithStyleData"/>
		</SHDShape3>
		<SHDShape4 a="data"><t path="format.swf.Shape4Data"/></SHDShape4>
	</enum>
	<enum path="format.swf.MorphShapeData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<MSDShape1 a="data"><t path="format.swf.MorphShapeData1"/></MSDShape1>
		<MSDShape2 a="data"><t path="format.swf.MorphShapeData2"/></MSDShape2>
	</enum>
	<typedef path="format.swf.MorphShapeData1" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<startEdges><t path="format.swf.ShapeWithoutStyleData"/></startEdges>
	<startBounds><t path="format.swf.Rect"/></startBounds>
	<lineStyles><c path="Array"><t path="format.swf.Morph1LineStyle"/></c></lineStyles>
	<fillStyles><c path="Array"><e path="format.swf.MorphFillStyle"/></c></fillStyles>
	<endEdges><t path="format.swf.ShapeWithoutStyleData"/></endEdges>
	<endBounds><t path="format.swf.Rect"/></endBounds>
</a></typedef>
	<typedef path="format.swf.MorphShapeData2" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<useScalingStrokes><x path="Bool"/></useScalingStrokes>
	<useNonScalingStrokes><x path="Bool"/></useNonScalingStrokes>
	<startEdges><t path="format.swf.ShapeWithoutStyleData"/></startEdges>
	<startEdgeBounds><t path="format.swf.Rect"/></startEdgeBounds>
	<startBounds><t path="format.swf.Rect"/></startBounds>
	<lineStyles><c path="Array"><e path="format.swf.Morph2LineStyle"/></c></lineStyles>
	<fillStyles><c path="Array"><e path="format.swf.MorphFillStyle"/></c></fillStyles>
	<endEdges><t path="format.swf.ShapeWithoutStyleData"/></endEdges>
	<endEdgeBounds><t path="format.swf.Rect"/></endEdgeBounds>
	<endBounds><t path="format.swf.Rect"/></endBounds>
</a></typedef>
	<enum path="format.swf.MorphFillStyle" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<MFSSolid a="startColor:endColor">
			<t path="format.swf.RGBA"/>
			<t path="format.swf.RGBA"/>
		</MFSSolid>
		<MFSLinearGradient a="startMatrix:endMatrix:gradients">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Matrix"/>
			<c path="Array"><t path="format.swf.MorphGradient"/></c>
		</MFSLinearGradient>
		<MFSRadialGradient a="startMatrix:endMatrix:gradients">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Matrix"/>
			<c path="Array"><t path="format.swf.MorphGradient"/></c>
		</MFSRadialGradient>
		<MFSBitmap a="cid:startMatrix:endMatrix:repeat:smooth">
			<x path="Int"/>
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Matrix"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</MFSBitmap>
	</enum>
	<typedef path="format.swf.Morph1LineStyle" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<startWidth><x path="Int"/></startWidth>
	<startColor><t path="format.swf.RGBA"/></startColor>
	<endWidth><x path="Int"/></endWidth>
	<endColor><t path="format.swf.RGBA"/></endColor>
</a></typedef>
	<enum path="format.swf.Morph2LineStyle" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<M2LSNoFill a="startColor:endColor:data">
			<t path="format.swf.RGBA"/>
			<t path="format.swf.RGBA"/>
			<t path="format.swf.Morph2LineStyleData"/>
		</M2LSNoFill>
		<M2LSFill a="fill:data">
			<e path="format.swf.MorphFillStyle"/>
			<t path="format.swf.Morph2LineStyleData"/>
		</M2LSFill>
	</enum>
	<typedef path="format.swf.Morph2LineStyleData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<startWidth><x path="Int"/></startWidth>
	<startCapStyle><e path="format.swf.LineCapStyle"/></startCapStyle>
	<pixelHinting><x path="Bool"/></pixelHinting>
	<noVScale><x path="Bool"/></noVScale>
	<noHScale><x path="Bool"/></noHScale>
	<noClose><x path="Bool"/></noClose>
	<joinStyle><e path="format.swf.LineJoinStyle"/></joinStyle>
	<endWidth><x path="Int"/></endWidth>
	<endCapStyle><e path="format.swf.LineCapStyle"/></endCapStyle>
</a></typedef>
	<typedef path="format.swf.MorphGradient" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<startRatio><x path="Int"/></startRatio>
	<startColor><t path="format.swf.RGBA"/></startColor>
	<endRatio><x path="Int"/></endRatio>
	<endColor><t path="format.swf.RGBA"/></endColor>
</a></typedef>
	<typedef path="format.swf.Shape4Data" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<useWinding><x path="Bool"/></useWinding>
	<useScalingStroke><x path="Bool"/></useScalingStroke>
	<useNonScalingStroke><x path="Bool"/></useNonScalingStroke>
	<shapes><t path="format.swf.ShapeWithStyleData"/></shapes>
	<shapeBounds><t path="format.swf.Rect"/></shapeBounds>
	<edgeBounds><t path="format.swf.Rect"/></edgeBounds>
</a></typedef>
	<typedef path="format.swf.ShapeWithoutStyleData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a><shapeRecords><c path="Array"><e path="format.swf.ShapeRecord"/></c></shapeRecords></a></typedef>
	<typedef path="format.swf.ShapeWithStyleData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<shapeRecords><c path="Array"><e path="format.swf.ShapeRecord"/></c></shapeRecords>
	<lineStyles><c path="Array"><t path="format.swf.LineStyle"/></c></lineStyles>
	<fillStyles><c path="Array"><e path="format.swf.FillStyle"/></c></fillStyles>
</a></typedef>
	<enum path="format.swf.ShapeRecord" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<SHREnd/>
		<SHRChange a="data"><t path="format.swf.ShapeChangeRec"/></SHRChange>
		<SHREdge a="dx:dy">
			<x path="Int"/>
			<x path="Int"/>
		</SHREdge>
		<SHRCurvedEdge a="cdx:cdy:adx:ady">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</SHRCurvedEdge>
	</enum>
	<typedef path="format.swf.ShapeChangeRec" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<newStyles><x path="Null"><t path="format.swf.SCRNewStyles"/></x></newStyles>
	<moveTo><x path="Null"><t path="format.swf.SCRMoveTo"/></x></moveTo>
	<lineStyle><x path="Null"><t path="format.swf.SCRIndex"/></x></lineStyle>
	<fillStyle1><x path="Null"><t path="format.swf.SCRIndex"/></x></fillStyle1>
	<fillStyle0><x path="Null"><t path="format.swf.SCRIndex"/></x></fillStyle0>
</a></typedef>
	<typedef path="format.swf.SCRMoveTo" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<dy><x path="Int"/></dy>
	<dx><x path="Int"/></dx>
</a></typedef>
	<typedef path="format.swf.SCRIndex" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a><idx><x path="Int"/></idx></a></typedef>
	<typedef path="format.swf.SCRNewStyles" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<lineStyles><c path="Array"><t path="format.swf.LineStyle"/></c></lineStyles>
	<fillStyles><c path="Array"><e path="format.swf.FillStyle"/></c></fillStyles>
</a></typedef>
	<enum path="format.swf.FillStyle" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<FSSolid a="rgb"><t path="format.swf.RGB"/></FSSolid>
		<FSSolidAlpha a="rgb"><t path="format.swf.RGBA"/></FSSolidAlpha>
		<FSLinearGradient a="mat:grad">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Gradient"/>
		</FSLinearGradient>
		<FSRadialGradient a="mat:grad">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Gradient"/>
		</FSRadialGradient>
		<FSFocalGradient a="mat:grad">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.FocalGradient"/>
		</FSFocalGradient>
		<FSBitmap a="cid:mat:repeat:smooth">
			<x path="Int"/>
			<t path="format.swf.Matrix"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</FSBitmap>
	</enum>
	<typedef path="format.swf.LineStyle" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<width><x path="Int"/></width>
	<data><e path="format.swf.LineStyleData"/></data>
</a></typedef>
	<enum path="format.swf.LineStyleData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<LSRGB a="rgb"><t path="format.swf.RGB"/></LSRGB>
		<LSRGBA a="rgba"><t path="format.swf.RGBA"/></LSRGBA>
		<LS2 a="data"><t path="format.swf.LS2Data"/></LS2>
	</enum>
	<typedef path="format.swf.LS2Data" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<startCap><e path="format.swf.LineCapStyle"/></startCap>
	<pixelHinting><x path="Bool"/></pixelHinting>
	<noVScale><x path="Bool"/></noVScale>
	<noHScale><x path="Bool"/></noHScale>
	<noClose><x path="Bool"/></noClose>
	<join><e path="format.swf.LineJoinStyle"/></join>
	<fill><x path="Null"><e path="format.swf.LS2Fill"/></x></fill>
	<endCap><e path="format.swf.LineCapStyle"/></endCap>
</a></typedef>
	<enum path="format.swf.LineCapStyle" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<LCRound/>
		<LCNone/>
		<LCSquare/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="format.swf.LineJoinStyle" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<LJRound/>
		<LJBevel/>
		<LJMiter a="limitFactor"><t path="format.swf.Fixed8"/></LJMiter>
	</enum>
	<enum path="format.swf.LS2Fill" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<LS2FColor a="color"><t path="format.swf.RGBA"/></LS2FColor>
		<LS2FStyle a="style"><e path="format.swf.FillStyle"/></LS2FStyle>
	</enum>
	<enum path="format.swf.GradRecord" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<GRRGB a="pos:col">
			<x path="Int"/>
			<t path="format.swf.RGB"/>
		</GRRGB>
		<GRRGBA a="pos:col">
			<x path="Int"/>
			<t path="format.swf.RGBA"/>
		</GRRGBA>
	</enum>
	<typedef path="format.swf.Gradient" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<spread><e path="format.swf.SpreadMode"/></spread>
	<interpolate><e path="format.swf.InterpolationMode"/></interpolate>
	<data><c path="Array"><e path="format.swf.GradRecord"/></c></data>
</a></typedef>
	<typedef path="format.swf.FocalGradient" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<focalPoint><t path="format.swf.Fixed8"/></focalPoint>
	<data><t path="format.swf.Gradient"/></data>
</a></typedef>
	<class path="format.swf.ButtonRecord" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<stateHitTest public="1"><x path="Bool"/></stateHitTest>
		<stateDown public="1"><x path="Bool"/></stateDown>
		<stateOver public="1"><x path="Bool"/></stateOver>
		<stateUp public="1"><x path="Bool"/></stateUp>
		<cid public="1"><x path="Int"/></cid>
		<depth public="1"><x path="Int"/></depth>
		<matrix public="1"><t path="format.swf.Matrix"/></matrix>
		<color public="1"><t path="format.swf.CXA"/></color>
		<filters public="1"><x path="Null"><c path="Array"><e path="format.swf.Filter"/></c></x></filters>
		<blendMode public="1"><x path="Null"><e path="format.swf.BlendMode"/></x></blendMode>
		<new public="1" set="method" line="313"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="format.swf.SpreadMode" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<SMPad/>
		<SMReflect/>
		<SMRepeat/>
		<SMReserved/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="format.swf.InterpolationMode" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<IMNormalRGB/>
		<IMLinearRGB/>
		<IMReserved1/>
		<IMReserved2/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="format.swf.MatrixPart" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<nbits><x path="Int"/></nbits>
</a></typedef>
	<typedef path="format.swf.MatrixPartScale" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></typedef>
	<typedef path="format.swf.MatrixPartRotateSkew" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<rs1><x path="Float"/></rs1>
	<rs0><x path="Float"/></rs0>
</a></typedef>
	<typedef path="format.swf.MatrixPartTranslate" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
</a></typedef>
	<typedef path="format.swf.Matrix" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<translate><t path="format.swf.MatrixPartTranslate"/></translate>
	<scale><x path="Null"><t path="format.swf.MatrixPartScale"/></x></scale>
	<rotate><x path="Null"><t path="format.swf.MatrixPartRotateSkew"/></x></rotate>
</a></typedef>
	<typedef path="format.swf.RGBA" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<r><x path="Int"/></r>
	<g><x path="Int"/></g>
	<b><x path="Int"/></b>
	<a><x path="Int"/></a>
</a></typedef>
	<typedef path="format.swf.RGB" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<r><x path="Int"/></r>
	<g><x path="Int"/></g>
	<b><x path="Int"/></b>
</a></typedef>
	<typedef path="format.swf.CXA" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<nbits><x path="Int"/></nbits>
	<mult><x path="Null"><t path="format.swf.RGBA"/></x></mult>
	<add><x path="Null"><t path="format.swf.RGBA"/></x></add>
</a></typedef>
	<typedef path="format.swf.ClipEvent" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<eventsFlags><x path="Int"/></eventsFlags>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<enum path="format.swf.BlendMode" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<BNormal/>
		<BLayer/>
		<BMultiply/>
		<BScreen/>
		<BLighten/>
		<BDarken/>
		<BDifference/>
		<BAdd/>
		<BSubtract/>
		<BInvert/>
		<BAlpha/>
		<BErase/>
		<BOverlay/>
		<BHardLight/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="format.swf.Filter" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<FDropShadow a="data"><t path="format.swf.FilterData"/></FDropShadow>
		<FBlur a="data"><t path="format.swf.BlurFilterData"/></FBlur>
		<FGlow a="data"><t path="format.swf.FilterData"/></FGlow>
		<FBevel a="data"><t path="format.swf.FilterData"/></FBevel>
		<FGradientGlow a="data"><t path="format.swf.GradientFilterData"/></FGradientGlow>
		<FColorMatrix a="data"><c path="Array"><x path="Float"/></c></FColorMatrix>
		<FGradientBevel a="data"><t path="format.swf.GradientFilterData"/></FGradientBevel>
	</enum>
	<typedef path="format.swf.FilterFlags" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<passes><x path="Int"/></passes>
	<ontop><x path="Bool"/></ontop>
	<knockout><x path="Bool"/></knockout>
	<inner><x path="Bool"/></inner>
</a></typedef>
	<typedef path="format.swf.FilterData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<strength><t path="format.swf.Fixed8"/></strength>
	<flags><t path="format.swf.FilterFlags"/></flags>
	<distance><t path="format.swf.Fixed"/></distance>
	<color2><t path="format.swf.RGBA"/></color2>
	<color><t path="format.swf.RGBA"/></color>
	<blurY><t path="format.swf.Fixed"/></blurY>
	<blurX><t path="format.swf.Fixed"/></blurX>
	<angle><t path="format.swf.Fixed"/></angle>
</a></typedef>
	<typedef path="format.swf.BlurFilterData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<passes><x path="Int"/></passes>
	<blurY><t path="format.swf.Fixed"/></blurY>
	<blurX><t path="format.swf.Fixed"/></blurX>
</a></typedef>
	<typedef path="format.swf.GradientFilterData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<data><t path="format.swf.FilterData"/></data>
	<colors><c path="Array"><a>
	<position><x path="Int"/></position>
	<color><t path="format.swf.RGBA"/></color>
</a></c></colors>
</a></typedef>
	<typedef path="format.swf.Lossless" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<width><x path="Int"/></width>
	<height><x path="Int"/></height>
	<data><c path="haxe.io.Bytes"/></data>
	<color><e path="format.swf.ColorModel"/></color>
	<cid><x path="Int"/></cid>
</a></typedef>
	<enum path="format.swf.JPEGData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<JDJPEG1 a="data"><c path="haxe.io.Bytes"/></JDJPEG1>
		<JDJPEG2 a="data"><c path="haxe.io.Bytes"/></JDJPEG2>
		<JDJPEG3 a="data:mask">
			<c path="haxe.io.Bytes"/>
			<c path="haxe.io.Bytes"/>
		</JDJPEG3>
	</enum>
	<enum path="format.swf.ColorModel" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<CM8Bits a="ncolors"><x path="Int"/></CM8Bits>
		<CM15Bits/>
		<CM24Bits/>
		<CM32Bits/>
	</enum>
	<typedef path="format.swf.Sound" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<sid><x path="Int"/></sid>
	<samples><x path="Int"/></samples>
	<rate><e path="format.swf.SoundRate"/></rate>
	<isStereo><x path="Bool"/></isStereo>
	<is16bit><x path="Bool"/></is16bit>
	<format><e path="format.swf.SoundFormat"/></format>
	<data><e path="format.swf.SoundData"/></data>
</a></typedef>
	<enum path="format.swf.SoundData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<SDMp3 a="seek:data">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
		</SDMp3>
		<SDRaw a="data"><c path="haxe.io.Bytes"/></SDRaw>
		<SDOther a="data"><c path="haxe.io.Bytes"/></SDOther>
	</enum>
	<enum path="format.swf.SoundFormat" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<SFNativeEndianUncompressed/>
		<SFADPCM/>
		<SFMP3/>
		<SFLittleEndianUncompressed/>
		<SFNellymoser16k/>
		<SFNellymoser8k/>
		<SFNellymoser/>
		<SFSpeex/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="format.swf.SoundRate" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<SR5k/>
		<SR11k/>
		<SR22k/>
		<SR44k/>
		<haxe_doc>* Sound sampling rate.
 *
 * - 5k is not allowed for MP3
 * - Nellymoser and Speex ignore this option</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="format.swf.FontData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<FDFont1 a="data"><t path="format.swf.Font1Data"/></FDFont1>
		<FDFont2 a="hasWideChars:data">
			<x path="Bool"/>
			<t path="format.swf.Font2Data"/>
		</FDFont2>
		<FDFont3 a="data"><t path="format.swf.Font2Data"/></FDFont3>
	</enum>
	<enum path="format.swf.FontInfoData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<FIDFont1 a="shiftJIS:isANSI:hasWideCodes:data">
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<t path="format.swf.FIData"/>
		</FIDFont1>
		<FIDFont2 a="language:data">
			<e path="format.swf.LangCode"/>
			<t path="format.swf.FIData"/>
		</FIDFont2>
	</enum>
	<typedef path="format.swf.FIData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<name><c path="String"/></name>
	<isSmall><x path="Bool"/></isSmall>
	<isItalic><x path="Bool"/></isItalic>
	<isBold><x path="Bool"/></isBold>
	<codeTable><c path="Array"><x path="Int"/></c></codeTable>
</a></typedef>
	<enum path="format.swf.LangCode" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data">
		<LCNone/>
		<LCLatin/>
		<LCJapanese/>
		<LCKorean/>
		<LCSimplifiedChinese/>
		<LCTraditionalChinese/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="format.swf.Font1Data" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a><glyphs><c path="Array"><t path="format.swf.ShapeWithoutStyleData"/></c></glyphs></a></typedef>
	<typedef path="format.swf.Font2GlyphData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<shape><t path="format.swf.ShapeWithoutStyleData"/></shape>
	<charCode><x path="Int"/></charCode>
</a></typedef>
	<typedef path="format.swf.Font2Data" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<shiftJIS><x path="Bool"/></shiftJIS>
	<name><c path="String"/></name>
	<layout><x path="Null"><t path="format.swf.FontLayoutData"/></x></layout>
	<language><e path="format.swf.LangCode"/></language>
	<isSmall><x path="Bool"/></isSmall>
	<isItalic><x path="Bool"/></isItalic>
	<isBold><x path="Bool"/></isBold>
	<isANSI><x path="Bool"/></isANSI>
	<glyphs><c path="Array"><t path="format.swf.Font2GlyphData"/></c></glyphs>
</a></typedef>
	<typedef path="format.swf.FontKerningData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<charCode2><x path="Int"/></charCode2>
	<charCode1><x path="Int"/></charCode1>
	<adjust><x path="Int"/></adjust>
</a></typedef>
	<typedef path="format.swf.FontLayoutGlyphData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<bounds><t path="format.swf.Rect"/></bounds>
	<advance><x path="Int"/></advance>
</a></typedef>
	<typedef path="format.swf.FontLayoutData" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/swf/Data.hx" module="format.swf.Data"><a>
	<leading><x path="Int"/></leading>
	<kerning><c path="Array"><t path="format.swf.FontKerningData"/></c></kerning>
	<glyphs><c path="Array"><t path="format.swf.FontLayoutGlyphData"/></c></glyphs>
	<descent><x path="Int"/></descent>
	<ascent><x path="Int"/></ascent>
</a></typedef>
	<class path="format.tools.Deflate" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/tools/Deflate.hx">
		<run public="1" set="method" line="31" static="1">
			<f a="b:?level" v=":9">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
		</run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.Inflate" params="" file="/home/nanjizal/haxe/haxe_libraries/format/3.5.0/haxelib/format/tools/Inflate.hx">
		<run public="1" set="method" line="31" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.CallStack" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>haxe.CallStack</e></m>
	<m n=":allow"><e>haxe.Exception</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Constraints.hx" module="haxe.Constraints" extern="1" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Null"><c path="haxe.IMap.V"/></x>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.K"/></t></f></keys>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.V"/></t></f></iterator>
		<keyValueIterator public="1" set="method"><f a=""><t path="KeyValueIterator">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
</t></f></keyValueIterator>
		<copy public="1" set="method"><f a=""><c path="haxe.IMap">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
</c></f></copy>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
	</class>
	<class path="haxe.EnumTools" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:

			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="138" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="149" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="163" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="175" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.Exception" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/Exception.hx">
		<caught set="method" line="18" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<__exceptionMessage>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionMessage>
		<__nativeStack>
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<toString public="1" set="method" line="52">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<get_message set="method" line="66"><f a=""><c path="String"/></f></get_message>
		<new public="1" set="method" line="36">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Int32.hx" private="1" module="haxe.Int32" extern="1" final="1">
	<negate get="inline" set="null" line="32" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>-A</e></m></meta>
	</negate>
	<preIncrement get="inline" set="null" line="35" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>++A</e></m></meta>
	</preIncrement>
	<postIncrement get="inline" set="null" line="37" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A++</e></m></meta>
	</postIncrement>
	<preDecrement get="inline" set="null" line="44" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>--A</e></m></meta>
	</preDecrement>
	<postDecrement get="inline" set="null" line="46" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A--</e></m></meta>
	</postDecrement>
	<add get="inline" set="null" line="53" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</add>
	<addInt get="inline" set="null" line="56" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta>
			<m n=":op"><e>A + B</e></m>
			<m n=":commutative"/>
		</meta>
	</addInt>
	<sub get="inline" set="null" line="61" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</sub>
	<subInt get="inline" set="null" line="64" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</subInt>
	<intSub get="inline" set="null" line="67" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</intSub>
	<toFloat get="inline" set="null" line="249" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":to"/></meta>
	</toFloat>
	<ucompare public="1" set="method" line="254" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="Int"/>
		</f>
		<haxe_doc>Compare `a` and `b` in unsigned mode.</haxe_doc>
	</ucompare>
	<clamp get="inline" set="null" line="267" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
</class></impl>
	</abstract>
	<class path="haxe._Int32.Int32_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Int32.hx" private="1" module="haxe.Int32" extern="1" final="1">
		<negate get="inline" set="null" line="32" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>-A</e></m></meta>
		</negate>
		<preIncrement get="inline" set="null" line="35" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>++A</e></m></meta>
		</preIncrement>
		<postIncrement get="inline" set="null" line="37" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A++</e></m></meta>
		</postIncrement>
		<preDecrement get="inline" set="null" line="44" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>--A</e></m></meta>
		</preDecrement>
		<postDecrement get="inline" set="null" line="46" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A--</e></m></meta>
		</postDecrement>
		<add get="inline" set="null" line="53" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</add>
		<addInt get="inline" set="null" line="56" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta>
				<m n=":op"><e>A + B</e></m>
				<m n=":commutative"/>
			</meta>
		</addInt>
		<sub get="inline" set="null" line="61" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</sub>
		<subInt get="inline" set="null" line="64" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</subInt>
		<intSub get="inline" set="null" line="67" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</intSub>
		<toFloat get="inline" set="null" line="249" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":to"/></meta>
		</toFloat>
		<ucompare public="1" set="method" line="254" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compare `a` and `b` in unsigned mode.</haxe_doc>
		</ucompare>
		<clamp get="inline" set="null" line="267" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
	</class>
	<class path="haxe._Int64.___Int64" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64" extern="1">
		<make public="1" set="method" static="1">
			<f a="high:low">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_make"</e></m></meta>
		</make>
		<ofInt public="1" set="method" static="1">
			<f a="value">
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>" ::cpp::Int64Struct"</e></m></meta>
		</ofInt>
		<isInt64 public="1" set="method" static="1">
			<f a="d">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>" ::cpp::Int64Struct::is"</e></m></meta>
		</isInt64>
		<isNeg public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_is_neg"</e></m></meta>
		</isNeg>
		<isZero public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_is_zero"</e></m></meta>
		</isZero>
		<compare public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_compare"</e></m></meta>
		</compare>
		<ucompare public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_ucompare"</e></m></meta>
		</ucompare>
		<toString public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_to_string"</e></m></meta>
		</toString>
		<neg public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neg"</e></m></meta>
		</neg>
		<preIncrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_pre_increment"</e></m></meta>
		</preIncrement>
		<postIncrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_post_increment"</e></m></meta>
		</postIncrement>
		<preDecrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_pre_decrement"</e></m></meta>
		</preDecrement>
		<postDecrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_post_decrement"</e></m></meta>
		</postDecrement>
		<add public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_add"</e></m></meta>
		</add>
		<addInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_add"</e></m></meta>
		</addInt>
		<sub public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</sub>
		<subInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</subInt>
		<intSub public="1" set="method" static="1">
			<f a="a:b">
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</intSub>
		<mul public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_mul"</e></m></meta>
		</mul>
		<div public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_div"</e></m></meta>
		</div>
		<mod public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_mod"</e></m></meta>
		</mod>
		<eq public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_eq"</e></m></meta>
		</eq>
		<eqInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_eq"</e></m></meta>
		</eqInt>
		<neq public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neq"</e></m></meta>
		</neq>
		<neqInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neq"</e></m></meta>
		</neqInt>
		<complement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_complement"</e></m></meta>
		</complement>
		<bitAnd public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_and"</e></m></meta>
		</bitAnd>
		<bitOr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_or"</e></m></meta>
		</bitOr>
		<bitXor public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_xor"</e></m></meta>
		</bitXor>
		<shl public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_shl"</e></m></meta>
		</shl>
		<shr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_shr"</e></m></meta>
		</shr>
		<ushr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_ushr"</e></m></meta>
		</ushr>
		<high public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_high"</e></m></meta>
		</high>
		<low public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_low"</e></m></meta>
		</low>
		<meta>
			<m n=":notNull"/>
			<m n=":include"><e>"cpp/Int64.h"</e></m>
			<m n=":native"><e>"cpp::Int64Struct"</e></m>
		</meta>
	</class>
	<typedef path="haxe._Int64.__Int64" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64"><c path="haxe._Int64.___Int64"/></typedef>
	<abstract path="haxe.Int64" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<meta>
			<m n=":coreApi"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64" extern="1" final="1">
	<copy public="1" set="method" line="141" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<haxe_doc>Makes a copy of `this` Int64.</haxe_doc>
	</copy>
	<make public="1" set="method" line="143" static="1">
		<f a="high:low">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int64"/>
		</f>
		<haxe_doc>Construct an Int64 from two 32-bit words `high` and `low`.</haxe_doc>
	</make>
	<ofInt public="1" set="method" line="148" static="1">
		<f a="x">
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":from"/></meta>
		<haxe_doc>Returns an Int64 with the value of the Int `x`.
		`x` is sign-extended to fill 64 bits.</haxe_doc>
	</ofInt>
	<toInt public="1" set="method" line="152" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="Int"/>
		</f>
		<haxe_doc>Returns an Int with the value of the Int64 `x`.
		Throws an exception  if `x` cannot be represented in 32 bits.</haxe_doc>
	</toInt>
	<is public="1" get="inline" set="null" line="160" static="1">
		<f a="val">
			<d/>
			<x path="Bool"/>
		</f>
		<meta><m n=":deprecated"><e>"haxe.Int64.is() is deprecated. Use haxe.Int64.isInt64() instead"</e></m></meta>
	</is>
	<isInt64 public="1" set="method" line="165" static="1">
		<f a="val">
			<d/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns whether the value `val` is of type `haxe.Int64`</haxe_doc>
	</isInt64>
	<getHigh public="1" set="method" line="169" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":deprecated"><e>"Use high instead"</e></m></meta>
		<haxe_doc>Returns the high 32-bit word of `x`.</haxe_doc>
	</getHigh>
	<getLow public="1" set="method" line="173" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":deprecated"><e>"Use low instead"</e></m></meta>
		<haxe_doc>Returns the low 32-bit word of `x`.</haxe_doc>
	</getLow>
	<isNeg public="1" set="method" line="176" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns `true` if `x` is less than zero.</haxe_doc>
	</isNeg>
	<isZero public="1" set="method" line="179" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns `true` if `x` is exactly zero.</haxe_doc>
	</isZero>
	<compare public="1" set="method" line="182" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Int"/>
		</f>
		<haxe_doc><![CDATA[Compares `a` and `b` in signed mode.
		Returns a negative value if `a < b`, positive if `a > b`,
		or 0 if `a == b`.]]></haxe_doc>
	</compare>
	<ucompare public="1" set="method" line="185" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Int"/>
		</f>
		<haxe_doc><![CDATA[Compares `a` and `b` in unsigned mode.
		Returns a negative value if `a < b`, positive if `a > b`,
		or 0 if `a == b`.]]></haxe_doc>
	</ucompare>
	<toStr public="1" set="method" line="188" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a signed decimal `String` representation of `x`.</haxe_doc>
	</toStr>
	<toString set="method" line="191" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<c path="String"/>
</f></toString>
	<parseString public="1" set="method" line="193" static="1"><f a="sParam">
	<c path="String"/>
	<x path="haxe.Int64"/>
</f></parseString>
	<fromFloat public="1" set="method" line="197" static="1"><f a="f">
	<x path="Float"/>
	<x path="haxe.Int64"/>
</f></fromFloat>
	<divMod public="1" set="method" line="201" static="1">
		<f a="dividend:divisor">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<a>
				<quotient><x path="haxe.Int64"/></quotient>
				<modulus><x path="haxe.Int64"/></modulus>
			</a>
		</f>
		<haxe_doc>Performs signed integer divison of `dividend` by `divisor`.
		Returns `{ quotient : Int64, modulus : Int64 }`.</haxe_doc>
	</divMod>
	<neg public="1" set="method" line="214" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>-A</e></m></meta>
		<haxe_doc>Returns the negative of `x`.</haxe_doc>
	</neg>
	<preIncrement get="inline" set="null" line="216" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>++A</e></m></meta>
	</preIncrement>
	<postIncrement get="inline" set="null" line="225" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A++</e></m></meta>
	</postIncrement>
	<preDecrement get="inline" set="null" line="235" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":op"><e>--A</e></m>
		</meta>
	</preDecrement>
	<postDecrement get="inline" set="null" line="244" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A--</e></m></meta>
	</postDecrement>
	<add public="1" set="method" line="256" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>Returns the sum of `a` and `b`.</haxe_doc>
	</add>
	<addInt set="method" line="261" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta>
			<m n=":op"><e>A + B</e></m>
			<m n=":commutative"/>
		</meta>
	</addInt>
	<sub public="1" set="method" line="264" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>Returns `a` minus `b`.</haxe_doc>
	</sub>
	<subInt set="method" line="270" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</subInt>
	<intSub set="method" line="274" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</intSub>
	<mul public="1" set="method" line="278" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>Returns the product of `a` and `b`.</haxe_doc>
	</mul>
	<mulInt set="method" line="283" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta>
			<m n=":op"><e>A * B</e></m>
			<m n=":commutative"/>
		</meta>
	</mulInt>
	<div public="1" set="method" line="286" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
		<haxe_doc>Returns the quotient of `a` divided by `b`.</haxe_doc>
	</div>
	<divInt set="method" line="294" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
	</divInt>
	<intDiv set="method" line="298" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
	</intDiv>
	<mod public="1" set="method" line="301" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A % B</e></m></meta>
		<haxe_doc>Returns the modulus of `a` divided by `b`.</haxe_doc>
	</mod>
	<modInt set="method" line="309" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A % B</e></m></meta>
	</modInt>
	<intMod set="method" line="313" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A % B</e></m></meta>
	</intMod>
	<eq public="1" set="method" line="317" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
		<haxe_doc>Returns `true` if `a` is equal to `b`.</haxe_doc>
	</eq>
	<eqInt set="method" line="322" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":op"><e>A == B</e></m>
			<m n=":commutative"/>
		</meta>
	</eqInt>
	<neq public="1" set="method" line="326" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
		<haxe_doc>Returns `true` if `a` is not equal to `b`.</haxe_doc>
	</neq>
	<neqInt set="method" line="331" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":op"><e>A != B</e></m>
			<m n=":commutative"/>
		</meta>
	</neqInt>
	<lt set="method" line="335" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<ltInt set="method" line="339" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</ltInt>
	<intLt set="method" line="343" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</intLt>
	<lte set="method" line="347" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<lteInt set="method" line="351" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lteInt>
	<intLte set="method" line="355" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</intLte>
	<gt set="method" line="359" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gtInt set="method" line="363" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gtInt>
	<intGt set="method" line="367" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</intGt>
	<gte set="method" line="371" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<gteInt set="method" line="375" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gteInt>
	<intGte set="method" line="379" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</intGte>
	<complement set="method" line="383" static="1">
		<f a="a">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>~A</e></m></meta>
	</complement>
	<and public="1" set="method" line="387" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		<haxe_doc>Returns the bitwise AND of `a` and `b`.</haxe_doc>
	</and>
	<or public="1" set="method" line="391" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
		<haxe_doc>Returns the bitwise OR of `a` and `b`.</haxe_doc>
	</or>
	<xor public="1" set="method" line="395" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
		<haxe_doc>Returns the bitwise XOR of `a` and `b`.</haxe_doc>
	</xor>
	<shl public="1" set="method" line="399" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		<haxe_doc>Returns `a` left-shifted by `b` bits.</haxe_doc>
	</shl>
	<shr public="1" set="method" line="403" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		<haxe_doc>Returns `a` right-shifted by `b` bits in signed mode.
		`a` is sign-extended.</haxe_doc>
	</shr>
	<ushr public="1" set="method" line="407" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
		<haxe_doc>Returns `a` right-shifted by `b` bits in unsigned mode.
		`a` is padded with zeroes.</haxe_doc>
	</ushr>
	<high public="1" get="accessor" set="null" static="1"><x path="haxe.Int32"/></high>
	<get_high set="method" line="412" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
</f></get_high>
	<low public="1" get="accessor" set="null" static="1"><x path="haxe.Int32"/></low>
	<get_low set="method" line="417" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
</f></get_low>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":coreApi"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._Int64.Int64_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64" extern="1" final="1">
		<copy public="1" set="method" line="141" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Makes a copy of `this` Int64.</haxe_doc>
		</copy>
		<make public="1" set="method" line="143" static="1">
			<f a="high:low">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Construct an Int64 from two 32-bit words `high` and `low`.</haxe_doc>
		</make>
		<ofInt public="1" set="method" line="148" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":from"/></meta>
			<haxe_doc>Returns an Int64 with the value of the Int `x`.
		`x` is sign-extended to fill 64 bits.</haxe_doc>
		</ofInt>
		<toInt public="1" set="method" line="152" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns an Int with the value of the Int64 `x`.
		Throws an exception  if `x` cannot be represented in 32 bits.</haxe_doc>
		</toInt>
		<is public="1" get="inline" set="null" line="160" static="1">
			<f a="val">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"><e>"haxe.Int64.is() is deprecated. Use haxe.Int64.isInt64() instead"</e></m></meta>
		</is>
		<isInt64 public="1" set="method" line="165" static="1">
			<f a="val">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether the value `val` is of type `haxe.Int64`</haxe_doc>
		</isInt64>
		<getHigh public="1" set="method" line="169" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":deprecated"><e>"Use high instead"</e></m></meta>
			<haxe_doc>Returns the high 32-bit word of `x`.</haxe_doc>
		</getHigh>
		<getLow public="1" set="method" line="173" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":deprecated"><e>"Use low instead"</e></m></meta>
			<haxe_doc>Returns the low 32-bit word of `x`.</haxe_doc>
		</getLow>
		<isNeg public="1" set="method" line="176" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if `x` is less than zero.</haxe_doc>
		</isNeg>
		<isZero public="1" set="method" line="179" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if `x` is exactly zero.</haxe_doc>
		</isZero>
		<compare public="1" set="method" line="182" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Compares `a` and `b` in signed mode.
		Returns a negative value if `a < b`, positive if `a > b`,
		or 0 if `a == b`.]]></haxe_doc>
		</compare>
		<ucompare public="1" set="method" line="185" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Compares `a` and `b` in unsigned mode.
		Returns a negative value if `a < b`, positive if `a > b`,
		or 0 if `a == b`.]]></haxe_doc>
		</ucompare>
		<toStr public="1" set="method" line="188" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a signed decimal `String` representation of `x`.</haxe_doc>
		</toStr>
		<toString set="method" line="191" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<c path="String"/>
</f></toString>
		<parseString public="1" set="method" line="193" static="1"><f a="sParam">
	<c path="String"/>
	<x path="haxe.Int64"/>
</f></parseString>
		<fromFloat public="1" set="method" line="197" static="1"><f a="f">
	<x path="Float"/>
	<x path="haxe.Int64"/>
</f></fromFloat>
		<divMod public="1" set="method" line="201" static="1">
			<f a="dividend:divisor">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<a>
					<quotient><x path="haxe.Int64"/></quotient>
					<modulus><x path="haxe.Int64"/></modulus>
				</a>
			</f>
			<haxe_doc>Performs signed integer divison of `dividend` by `divisor`.
		Returns `{ quotient : Int64, modulus : Int64 }`.</haxe_doc>
		</divMod>
		<neg public="1" set="method" line="214" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>-A</e></m></meta>
			<haxe_doc>Returns the negative of `x`.</haxe_doc>
		</neg>
		<preIncrement get="inline" set="null" line="216" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>++A</e></m></meta>
		</preIncrement>
		<postIncrement get="inline" set="null" line="225" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A++</e></m></meta>
		</postIncrement>
		<preDecrement get="inline" set="null" line="235" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":op"><e>--A</e></m>
			</meta>
		</preDecrement>
		<postDecrement get="inline" set="null" line="244" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A--</e></m></meta>
		</postDecrement>
		<add public="1" set="method" line="256" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>Returns the sum of `a` and `b`.</haxe_doc>
		</add>
		<addInt set="method" line="261" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta>
				<m n=":op"><e>A + B</e></m>
				<m n=":commutative"/>
			</meta>
		</addInt>
		<sub public="1" set="method" line="264" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>Returns `a` minus `b`.</haxe_doc>
		</sub>
		<subInt set="method" line="270" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</subInt>
		<intSub set="method" line="274" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</intSub>
		<mul public="1" set="method" line="278" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>Returns the product of `a` and `b`.</haxe_doc>
		</mul>
		<mulInt set="method" line="283" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta>
				<m n=":op"><e>A * B</e></m>
				<m n=":commutative"/>
			</meta>
		</mulInt>
		<div public="1" set="method" line="286" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
			<haxe_doc>Returns the quotient of `a` divided by `b`.</haxe_doc>
		</div>
		<divInt set="method" line="294" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
		</divInt>
		<intDiv set="method" line="298" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
		</intDiv>
		<mod public="1" set="method" line="301" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A % B</e></m></meta>
			<haxe_doc>Returns the modulus of `a` divided by `b`.</haxe_doc>
		</mod>
		<modInt set="method" line="309" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A % B</e></m></meta>
		</modInt>
		<intMod set="method" line="313" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A % B</e></m></meta>
		</intMod>
		<eq public="1" set="method" line="317" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
			<haxe_doc>Returns `true` if `a` is equal to `b`.</haxe_doc>
		</eq>
		<eqInt set="method" line="322" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":op"><e>A == B</e></m>
				<m n=":commutative"/>
			</meta>
		</eqInt>
		<neq public="1" set="method" line="326" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
			<haxe_doc>Returns `true` if `a` is not equal to `b`.</haxe_doc>
		</neq>
		<neqInt set="method" line="331" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":op"><e>A != B</e></m>
				<m n=":commutative"/>
			</meta>
		</neqInt>
		<lt set="method" line="335" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<ltInt set="method" line="339" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</ltInt>
		<intLt set="method" line="343" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</intLt>
		<lte set="method" line="347" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<lteInt set="method" line="351" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lteInt>
		<intLte set="method" line="355" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</intLte>
		<gt set="method" line="359" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gtInt set="method" line="363" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gtInt>
		<intGt set="method" line="367" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</intGt>
		<gte set="method" line="371" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<gteInt set="method" line="375" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gteInt>
		<intGte set="method" line="379" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</intGte>
		<complement set="method" line="383" static="1">
			<f a="a">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>~A</e></m></meta>
		</complement>
		<and public="1" set="method" line="387" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
			<haxe_doc>Returns the bitwise AND of `a` and `b`.</haxe_doc>
		</and>
		<or public="1" set="method" line="391" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
			<haxe_doc>Returns the bitwise OR of `a` and `b`.</haxe_doc>
		</or>
		<xor public="1" set="method" line="395" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
			<haxe_doc>Returns the bitwise XOR of `a` and `b`.</haxe_doc>
		</xor>
		<shl public="1" set="method" line="399" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
			<haxe_doc>Returns `a` left-shifted by `b` bits.</haxe_doc>
		</shl>
		<shr public="1" set="method" line="403" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
			<haxe_doc>Returns `a` right-shifted by `b` bits in signed mode.
		`a` is sign-extended.</haxe_doc>
		</shr>
		<ushr public="1" set="method" line="407" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
			<haxe_doc>Returns `a` right-shifted by `b` bits in unsigned mode.
		`a` is padded with zeroes.</haxe_doc>
		</ushr>
		<high public="1" get="accessor" set="null" static="1"><x path="haxe.Int32"/></high>
		<get_high set="method" line="412" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
</f></get_high>
		<low public="1" get="accessor" set="null" static="1"><x path="haxe.Int32"/></low>
		<get_low set="method" line="417" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
</f></get_low>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/Log.hx" extern="1">
		<nativeTrace set="method" static="1">
			<f a="message:posInfo">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__trace"</e></m></meta>
		</nativeTrace>
		<trace public="1" set="dynamic" line="29" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<formatOutput public="1" set="method" line="39" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.NativeStackTrace" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/NativeStackTrace.hx" extern="1">
		<saveStack public="1" get="inline" set="null" line="12" static="1">
			<f a="exception">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" set="method" line="16" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noDebug"/>
			</meta>
		</callStack>
		<exceptionStack public="1" set="method" line="21" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noDebug"/>
			</meta>
		</exceptionStack>
		<toHaxe public="1" set="method" line="25" static="1">
			<f a="native:?skip" v=":0">
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ skip : 0 }</e></m></meta>
		</toHaxe>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="Array"><c path="haxe._Rest.NativeRest.T"/></c></typedef>
	<abstract path="haxe.Rest" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<haxe_doc><![CDATA[A special type that represents a "rest" function argument.

	The special `...` syntax can be used for convenience and improved readability:

	```haxe
	function f(...rest:Int) {
		$type(rest); // haxe.Rest<Int>
	}

	f(1, 2, 3);

	final array = [1, 2, 3];
	f(...array);
	```

	Should be used as a type for the last argument of a method, indicating that
	an arbitrary number of arguments of the given type can be passed to that method.

	Allows to use array access by index to get values of rest arguments.
	If the index exceeds the amount of rest arguments passed, the result is unspecified.]]></haxe_doc>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1">
	<toArray public="1" set="method" line="58" static="1">
		<f a="this">
			<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
			<c path="Array"><c path="haxe.Rest.T"/></c>
		</f>
		<meta><m n=":to"/></meta>
		<haxe_doc>Creates an array containing all the values of rest arguments.</haxe_doc>
	</toArray>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":coreApi"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._Rest.Rest_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1">
		<toArray public="1" set="method" line="58" static="1">
			<f a="this">
				<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
				<c path="Array"><c path="haxe.Rest.T"/></c>
			</f>
			<meta><m n=":to"/></meta>
			<haxe_doc>Creates an array containing all the values of rest arguments.</haxe_doc>
		</toArray>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ValueException" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Crc32" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/crypto/Crc32.hx" extern="1">
		<make public="1" set="method" line="59" static="1">
			<f a="data">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Calculates the CRC32 of the given data bytes</haxe_doc>
		</make>
		<crc><x path="Int"/></crc>
		<byte public="1" get="inline" set="null" line="35"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></byte>
		<update public="1" get="inline" set="null" line="42"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<get public="1" get="inline" set="null" line="52"><f a=""><x path="Int"/></f></get>
		<new public="1" get="inline" set="null" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Calculates the Crc32 of the given Bytes.</haxe_doc>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/ArraySort.hx" extern="1">
		<sort public="1" params="T" set="method" line="42" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="46" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="rotate.T"/>
		<c path="rotate.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="115" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="124" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="139" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="153" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare params="T" get="inline" set="null" line="159" static="1"><f a="a:cmp:i:j">
	<c path="Array"><c path="compare.T"/></c>
	<f a=":">
		<c path="compare.T"/>
		<c path="compare.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/BalancedTree.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.BalancedTree.K"/>
			<c path="haxe.ds.BalancedTree.V"/>
		</implements>
		<iteratorLoop params="K:V" set="method" line="172" static="1"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="iteratorLoop.K"/>
		<c path="iteratorLoop.V"/>
	</c>
	<c path="Array"><c path="iteratorLoop.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Null"><c path="haxe.ds.BalancedTree.V"/></x>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="85">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.

		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.

		Otherwise the binding of `key` is removed and true is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="101">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.

		This method returns true even if `key` is bound to null.

		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<iterator public="1" set="method" line="120">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="129">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<keys public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</keys>
		<copy public="1" set="method" line="144"><f a=""><c path="haxe.ds.BalancedTree">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></f></copy>
		<setLoop set="method" line="150"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="163"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<keysLoop set="method" line="180"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<merge set="method" line="188"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<minBinding set="method" line="197"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="201"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="205"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="225"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<toString public="1" set="method" line="229"><f a=""><c path="String"/></f></toString>
		<clear public="1" set="method" line="236">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all keys from `this` BalancedTree.</haxe_doc>
		</clear>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree" extern="1">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="264"><f a=""><x path="Int"/></f></get_height>
		<toString public="1" set="method" line="266"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/EnumValueMap.hx" extern="1">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="32" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="57"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="69"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<copy public="1" set="method" line="79" override="1"><f a=""><c path="haxe.ds.EnumValueMap">
	<c path="haxe.ds.EnumValueMap.K"/>
	<c path="haxe.ds.EnumValueMap.V"/>
</c></f></copy>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h>
			<d/>
			<meta><m n=":ifFeature"><e>"haxe.ds.IntMap.*"</e></m></meta>
		</h>
		<set public="1" set="method" line="60">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="64">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="68">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="72">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="76">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="81">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="86">
			<f a=""><t path="KeyValueIterator">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="90">
			<f a=""><c path="haxe.ds.IntMap"><c path="haxe.ds.IntMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method" line="97">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method" line="101">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":headerClassCode"><e><![CDATA["\n  inline void set(int key, ::null value) { __int_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(int key, bool value) { __int_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(int key, char value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, unsigned char value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, signed char value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, short value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, unsigned short value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, int value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, unsigned int value) { __int_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(int key, float value) { __int_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(int key, double value) { __int_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(int key, ::String value) { __int_hash_set_string(HX_MAP_THIS,key,value); }\n\n  template<typename V, typename H>\n  inline void set(int key, const ::cpp::Struct<V,H> &value) {__int_hash_set(HX_MAP_THIS,key,value); }\n  template<typename F>\n  inline void set(int key, const ::cpp::Function<F> &value) {__int_hash_set(HX_MAP_THIS,key,value); }\n  template<typename V>\n  inline void set(int key, const ::cpp::Pointer<V> &value) {__int_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n\n  template<typename VALUE>\n  inline void set(Dynamic &key, const VALUE &value) { set( (int)key, value ); }\n\n  inline bool get_bool(int key) { return __int_hash_get_bool(h,key); }\n  inline int get_int(int key) { return __int_hash_get_int(h,key); }\n  inline Float get_float(int key) { return __int_hash_get_float(h,key); }\n  inline String get_string(int key) { return __int_hash_get_string(h,key); }\n"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.List" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="68">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method" line="99">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		The element is removed from `this` List.</haxe_doc>
		</pop>
		<clear public="1" set="method" line="123">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.

		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<create public="1" params="T" get="inline" set="null" line="271" static="1"><f a="item:next">
	<c path="create.T"/>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
</f></create>
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="266"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<h>
			<d/>
			<meta><m n=":ifFeature"><e>"haxe.ds.ObjectMap.*"</e></m></meta>
		</h>
		<set public="1" set="method" line="60">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="64">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="68">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="72">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="76">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="81">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="86">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="90">
			<f a=""><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method" line="97">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method" line="101">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":headerClassCode"><e><![CDATA["\n  inline void set(Dynamic key, ::null value) { __object_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, bool value) { __object_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, char value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, unsigned char value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, signed char value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, short value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, unsigned short value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, int value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, unsigned int value) { __object_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, float value) { __object_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, double value) { __object_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(Dynamic key, ::String value) { __object_hash_set_string(HX_MAP_THIS,key,value); }\n\n\n  template<typename V, typename H>\n  inline void set(Dynamic key, const ::cpp::Struct<V,H> &value) {__object_hash_set(HX_MAP_THIS,key,value); }\n  template<typename V>\n  inline void set(Dynamic key, const ::cpp::Function<V> &value) {__object_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n  template<typename V>\n  inline void set(Dynamic key, const ::cpp::Pointer<V> &value) {__object_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n\n  inline bool get_bool(Dynamic key) { return __object_hash_get_bool(h,key); }\n  inline int get_int(Dynamic key) { return __object_hash_get_int(h,key); }\n  inline Float get_float(Dynamic key) { return __object_hash_get_float(h,key); }\n  inline String get_string(Dynamic key) { return __object_hash_get_string(h,key); }\n\n"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h>
			<d/>
			<meta><m n=":ifFeature"><e>"haxe.ds.StringMap.*"</e></m></meta>
		</h>
		<set public="1" set="method" line="60">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="64">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="68">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="72">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="76">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="81">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="86">
			<f a=""><t path="KeyValueIterator">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="90">
			<f a=""><c path="haxe.ds.StringMap"><c path="haxe.ds.StringMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method" line="97">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method" line="101">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":headerClassCode"><e><![CDATA["\n  inline void set(String key, ::null value) { __string_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(String key, bool value) { __string_hash_set(HX_MAP_THIS,key,value); }\n  inline void set(String key, char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, unsigned char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, signed char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, short value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, unsigned short value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, int value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, unsigned int value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\n  inline void set(String key, float value) { __string_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(String key, double value) { __string_hash_set_float(HX_MAP_THIS,key,value); }\n  inline void set(String key, ::String value) { __string_hash_set_string(HX_MAP_THIS,key,value); }\n\n  template<typename V, typename H>\n  inline void set(String key, const ::cpp::Struct<V,H> &value) {__string_hash_set(HX_MAP_THIS,key,value); }\n  template<typename V>\n  inline void set(String key, const ::cpp::Function<V> &value) {__string_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n  template<typename V>\n  inline void set(String key, const ::cpp::Pointer<V> &value) {__string_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\n\n  template<typename VALUE>\n  inline void set(Dynamic &key, const VALUE &value) { set( (String)key, value ); }\n\n  inline bool get_bool(String key) { return __string_hash_get_bool(h,key); }\n  inline int get_int(String key) { return __string_hash_get_int(h,key); }\n  inline Float get_float(String key) { return __string_hash_get_float(h,key); }\n  inline String get_string(String key) { return __string_hash_get_string(h,key); }\n"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.AsVar" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/extern/AsVar.hx">
		<from><icast><c path="haxe.extern.AsVar.T"/></icast></from>
		<this><c path="haxe.extern.AsVar.T"/></this>
		<to><icast><c path="haxe.extern.AsVar.T"/></icast></to>
		<haxe_doc>If this type is used as an argument type, the compiler ensures that
	argument expressions are bound to a local variable.</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":transitive"/>
			<m n=":semantics"><e>variable</e></m>
		</meta>
		<impl><class path="haxe.extern._AsVar.AsVar_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/extern/AsVar.hx" private="1" module="haxe.extern.AsVar" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.http._HttpBase.StringKeyValue" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/http/HttpBase.hx" private="1" module="haxe.http.HttpBase"><a>
	<value><c path="String"/></value>
	<name><c path="String"/></name>
</a></typedef>
	<class path="haxe.http.HttpBase" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/http/HttpBase.hx">
		<url public="1">
			<c path="String"/>
			<haxe_doc>The url of `this` request. It is used only by the `request()` method and
		can be changed in order to send the same request to different target
		Urls.</haxe_doc>
		</url>
		<responseData public="1" get="accessor" set="null"><x path="Null"><c path="String"/></x></responseData>
		<responseBytes public="1" set="null"><x path="Null"><c path="haxe.io.Bytes"/></x></responseBytes>
		<responseAsString><x path="Null"><c path="String"/></x></responseAsString>
		<postData><x path="Null"><c path="String"/></x></postData>
		<postBytes><x path="Null"><c path="haxe.io.Bytes"/></x></postBytes>
		<headers><c path="Array"><t path="haxe.http._HttpBase.StringKeyValue"/></c></headers>
		<params><c path="Array"><t path="haxe.http._HttpBase.StringKeyValue"/></c></params>
		<emptyOnData final="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></emptyOnData>
		<addHeader public="1" set="method" line="98"><f a="header:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></addHeader>
		<onData public="1" set="dynamic" line="196">
			<f a="data">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a successful request, with `data` containing
		the result String.

		The intended usage is to bind it to a custom function:
		`httpInstance.onData = function(data) { // handle result }`</haxe_doc>
		</onData>
		<onBytes public="1" set="dynamic" line="205">
			<f a="data">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a successful request, with `data` containing
		the result String.

		The intended usage is to bind it to a custom function:
		`httpInstance.onBytes = function(data) { // handle result }`</haxe_doc>
		</onBytes>
		<onError public="1" set="dynamic" line="214">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a request error, with `msg` containing the
		error description.

		The intended usage is to bind it to a custom function:
		`httpInstance.onError = function(msg) { // handle error }`</haxe_doc>
		</onError>
		<onStatus public="1" set="dynamic" line="223">
			<f a="status">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a Http status change, with `status` being the
		new status.

		The intended usage is to bind it to a custom function:
		`httpInstance.onStatus = function(status) { // handle status }`</haxe_doc>
		</onStatus>
		<hasOnData set="method" line="228">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Override this if extending `haxe.Http` with overriding `onData`</haxe_doc>
		</hasOnData>
		<success set="method" line="232"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></success>
		<get_responseData set="method" line="241"><f a=""><x path="Null"><c path="String"/></x></f></get_responseData>
		<new public="1" set="method" line="71">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Http instance with `url` as parameter.

		This does not do a request until `request()` is called.

		If `url` is null, the field url must be set to a value before making the
		call to `request()`, or the result is unspecified.

		(Php) Https (SSL) connections are allowed only if the OpenSSL extension
		is enabled.</haxe_doc>
		</new>
		<haxe_doc>This class can be used to handle Http requests consistently across
	platforms. There are two intended usages:

	- call `haxe.Http.requestUrl(url)` and receive the result as a `String`
	(only available on `sys` targets)
	- create a `new haxe.Http(url)`, register your callbacks for `onData`,
	`onError` and `onStatus`, then call `request()`.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="haxe.io.ArrayBufferViewImpl"/></typedef>
	<class path="haxe.io.ArrayBufferViewImpl" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView">
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<new public="1" set="method" line="32"><f a="bytes:pos:length">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.io.ArrayBufferView" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView" final="1">
	<fromBytes public="1" set="method" line="89" static="1">
		<f a="bytes:?pos:?length" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="haxe.io.ArrayBufferView"/>
		</f>
		<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
	</fromBytes>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView" final="1">
		<fromBytes public="1" set="method" line="89" static="1">
			<f a="bytes:?pos:?length" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="haxe.io.ArrayBufferView"/>
			</f>
			<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
		</fromBytes>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/Bytes.hx" extern="1">
		<alloc public="1" set="method" line="549" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance with the given `length`. The values of the
		bytes are not initialized and may not be zero.</haxe_doc>
		</alloc>
		<ofString public="1" set="method" line="580" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the `Bytes` representation of the given `String`, using the
		specified encoding (UTF-8 by default).</haxe_doc>
		</ofString>
		<ofData public="1" set="method" line="656" static="1">
			<f a="b">
				<t path="haxe.io.BytesData"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns the `Bytes` representation of the given `BytesData`.</haxe_doc>
		</ofData>
		<ofHex public="1" set="method" line="673" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Converts the given hexadecimal `String` to `Bytes`. `s` must be a string of
		even length consisting only of hexadecimal digits. For example:
		`"0FDA14058916052309"`.</haxe_doc>
		</ofHex>
		<fastGet public="1" get="inline" set="null" line="694" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Reads the `pos`-th byte of the given `b` bytes, in the most efficient way
		possible. Behavior when reading outside of the available data is
		unspecified.</haxe_doc>
		</fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="45">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the byte at index `pos`.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="64">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Stores the given byte `v` at the given position `pos`.</haxe_doc>
		</set>
		<blit public="1" set="method" line="90">
			<f a="pos:src:srcpos:len">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies `len` bytes from `src` into this instance.
		@param pos Zero-based location in `this` instance at which to start writing
			bytes.
		@param src Source `Bytes` instance from which to copy bytes.
		@param srcpos Zero-based location at `src` from which bytes will be copied.
		@param len Number of bytes to be copied.</haxe_doc>
		</blit>
		<fill public="1" set="method" line="132">
			<f a="pos:len:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets `len` consecutive bytes starting from index `pos` of `this` instance
		to `value`.</haxe_doc>
		</fill>
		<sub public="1" set="method" line="155">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance that contains a copy of `len` bytes of
		`this` instance, starting at index `pos`.</haxe_doc>
		</sub>
		<compare public="1" set="method" line="194">
			<f a="other">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns `0` if the bytes of `this` instance and the bytes of `other` are
		identical.

		Returns a negative value if the `length` of `this` instance is less than
		the `length` of `other`, or a positive value if the `length` of `this`
		instance is greater than the `length` of `other`.

		In case of equal `length`s, returns a negative value if the first different
		value in `other` is greater than the corresponding value in `this`
		instance; otherwise returns a positive value.</haxe_doc>
		</compare>
		<getDouble public="1" set="method" line="246">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the IEEE double-precision value at the given position `pos` (in
		little-endian encoding). Result is unspecified if `pos` is outside the
		bounds.</haxe_doc>
		</getDouble>
		<getFloat public="1" set="method" line="269">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the IEEE single-precision value at the given position `pos` (in
		little-endian encoding). Result is unspecified if `pos` is outside the
		bounds.</haxe_doc>
		</getFloat>
		<setDouble public="1" set="method" line="292">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Stores the given IEEE double-precision value `v` at the given position
		`pos` in little-endian encoding. Result is unspecified if writing outside
		of bounds.</haxe_doc>
		</setDouble>
		<setFloat public="1" set="method" line="319">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Stores the given IEEE single-precision value `v` at the given position
		`pos` in little-endian encoding. Result is unspecified if writing outside
		of bounds.</haxe_doc>
		</setFloat>
		<getUInt16 public="1" get="inline" set="null" line="340">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 16-bit unsigned integer at the given position `pos` (in
		little-endian encoding).</haxe_doc>
		</getUInt16>
		<setUInt16 public="1" get="inline" set="null" line="352">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given 16-bit unsigned integer `v` at the given position `pos`
		(in little-endian encoding).</haxe_doc>
		</setUInt16>
		<getInt32 public="1" get="inline" set="null" line="365">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 32-bit integer at the given position `pos` (in little-endian
		encoding).</haxe_doc>
		</getInt32>
		<getInt64 public="1" get="inline" set="null" line="383">
			<f a="pos">
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Returns the 64-bit integer at the given position `pos` (in little-endian
		encoding).</haxe_doc>
		</getInt64>
		<setInt32 public="1" get="inline" set="null" line="391">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given 32-bit integer `v` at the given position `pos` (in
		little-endian encoding).</haxe_doc>
		</setInt32>
		<setInt64 public="1" get="inline" set="null" line="406">
			<f a="pos:v">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given 64-bit integer `v` at the given position `pos` (in
		little-endian encoding).</haxe_doc>
		</setInt64>
		<getString public="1" set="method" line="415">
			<f a="pos:len:?encoding">
				<x path="Int"/>
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the `len`-bytes long string stored at the given position `pos`,
		interpreted with the given `encoding` (UTF-8 by default).</haxe_doc>
		</getString>
		<readString public="1" get="inline" set="null" line="495">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"readString is deprecated, use getString instead"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</readString>
		<toString public="1" set="method" line="502">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a `String` representation of the bytes interpreted as UTF-8.</haxe_doc>
		</toString>
		<toHex public="1" set="method" line="524">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a hexadecimal `String` representation of the bytes of `this`
		instance.</haxe_doc>
		</toHex>
		<getData public="1" get="inline" set="null" line="541">
			<f a=""><t path="haxe.io.BytesData"/></f>
			<haxe_doc>Returns the bytes of `this` instance as `BytesData`.</haxe_doc>
		</getData>
		<new set="method" line="34"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/BytesBuffer.hx" extern="1">
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="64"><f a=""><x path="Int"/></f></get_length>
		<addByte public="1" get="inline" set="null" line="76">
			<f a="byte">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</addByte>
		<add public="1" get="inline" set="null" line="94"><f a="src">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></add>
		<addString public="1" get="inline" set="null" line="118"><f a="v:?encoding">
	<c path="String"/>
	<e path="haxe.io.Encoding"/>
	<x path="Void"/>
</f></addString>
		<addInt32 public="1" set="method" line="133"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></addInt32>
		<addInt64 public="1" set="method" line="144"><f a="v">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></addInt64>
		<addFloat public="1" get="inline" set="null" line="149"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></addFloat>
		<addDouble public="1" get="inline" set="null" line="157"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></addDouble>
		<addBytes public="1" get="inline" set="null" line="165"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="202">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/BytesData.hx"><c path="Array"><x path="cpp.UInt8"/></c></typedef>
	<class path="haxe.io.Input" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/Input.hx" extern="1">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the input source.

		Behaviour while reading after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="94"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readAll public="1" set="method" line="106">
			<f a="?bufsize">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return all available data.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read. Its default value is target-specific.</haxe_doc>
		</readAll>
		<readFullBytes public="1" set="method" line="132">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="145">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readUntil public="1" set="method" line="163">
			<f a="end">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read a string until a character code specified by `end` is occurred.

		The final character is not included in the resulting string.</haxe_doc>
		</readUntil>
		<readLine public="1" set="method" line="176">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read a line of text separated by CR and/or LF bytes.

		The CR/LF characters are not included in the resulting string.</haxe_doc>
		</readLine>
		<readFloat public="1" set="method" line="199">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readFloat>
		<readDouble public="1" set="method" line="208">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 64-bit double-precision floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readDouble>
		<readInt8 public="1" set="method" line="217">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 8-bit signed integer.</haxe_doc>
		</readInt8>
		<readInt16 public="1" set="method" line="229">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt16>
		<readUInt16 public="1" set="method" line="243">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt16>
		<readInt24 public="1" set="method" line="254">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 24-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt24>
		<readUInt24 public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 24-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt24>
		<readInt32 public="1" set="method" line="281">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="304">
			<f a="len:?encoding">
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/BytesInput.hx" extern="1">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<get_position get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_position>
		<get_length get="inline" set="null" line="75"><f a=""><x path="Int"/></f></get_length>
		<set_position set="method" line="83"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="96" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<readBytes public="1" set="method" line="119" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="39"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/Output.hx" extern="1">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when writing numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<flush public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush any buffered data.</haxe_doc>
		</flush>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="94"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<write public="1" set="method" line="103">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeFullBytes public="1" set="method" line="120">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<writeFloat public="1" set="method" line="133">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeFloat>
		<writeDouble public="1" set="method" line="142">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 64-bit double-precision floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeDouble>
		<writeInt8 public="1" set="method" line="156">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 8-bit signed integer.</haxe_doc>
		</writeInt8>
		<writeInt16 public="1" set="method" line="167">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="178">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt16>
		<writeInt24 public="1" set="method" line="195">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 24-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt24>
		<writeUInt24 public="1" set="method" line="206">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 24-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt24>
		<writeInt32 public="1" set="method" line="225">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt32>
		<prepare public="1" set="method" line="246">
			<f a="nbytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least `nbytes` bytes.

		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="254">
			<f a="i:?bufsize">
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read all available data from `i` and write it.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read and written. Its default value is 4096.</haxe_doc>
		</writeInput>
		<writeString public="1" set="method" line="278">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/BytesOutput.hx" extern="1">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="47"><f a=""><x path="Int"/></f></get_length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="137">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns the `Bytes` of this output.

		This function should not be called more than once on a given
		`BytesOutput` instance.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.io.Encoding" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/Eof.hx" extern="1">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/FPHelper.hx" extern="1">
		<i32ToFloat public="1" set="method" line="133" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</i32ToFloat>
		<floatToI32 public="1" set="method" line="177" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</floatToI32>
		<i64ToDouble public="1" set="method" line="214" static="1">
			<f a="low:high">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</i64ToDouble>
		<doubleToI64 public="1" set="method" line="268" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns an Int64 representing the bytes representation of the double precision IEEE float value.
		WARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.
		We still ensure that this is safe to use in a multithread environment</haxe_doc>
		</doubleToI64>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
	</class>
	<class path="haxe.io.Path" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/Path.hx" extern="1">
		<withoutExtension public="1" set="method" line="123" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the file extension.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</withoutExtension>
		<withoutDirectory public="1" set="method" line="134" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the directory.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</withoutDirectory>
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is `null`, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</directory>
		<extension public="1" set="method" line="161" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the extension of `path`.

		If `path` has no extension, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</extension>
		<withExtension public="1" set="method" line="175" static="1">
			<f a="path:ext">
				<c path="String"/>
				<x path="Null"><c path="String"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `path` where the extension is `ext`.

		If `path` has no extension, `ext` is added as extension.

		If `path` or `ext` are `null`, the result is unspecified.</haxe_doc>
		</withExtension>
		<join public="1" set="method" line="189" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

		If `paths` is empty, the empty String `""` is returned. Otherwise the
		paths are joined with a slash between them.

		If `paths` is `null`, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="210" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).

		Also replaces backslashes `\` with slashes `/` and afterwards turns
		multiple slashes into a single one.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="271" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="299" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing slashes from `path`.

		If `path` does not end with a `/` or `\`, `path` is returned unchanged.

		Otherwise the substring of `path` excluding the trailing slashes or
		backslashes is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<isAbsolute public="1" set="method" line="314" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the path is an absolute path, and `false` otherwise.</haxe_doc>
		</isAbsolute>
		<unescape set="method" line="324" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></unescape>
		<escape set="method" line="329" static="1">
			<f a="path:?allowSlashes" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ allowSlashes : false }</e></m></meta>
		</escape>
		<dir public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is `null`.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
		is the empty String `""`.</haxe_doc>
		</file>
		<ext public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is `null`.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>`true` if the last directory separator is a backslash, `false` otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="114">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is `true`, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is `null`, their representation
		is the empty String `""`.</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Path` instance by parsing `path`.

		Path information can be retrieved by accessing the `dir`, `file` and `ext`
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.io.UInt32ArrayData" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/UInt32Array.hx" module="haxe.io.UInt32Array"><t path="haxe.io.ArrayBufferViewData"/></typedef>
	<abstract path="haxe.io.UInt32Array" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/UInt32Array.hx">
		<this><t path="haxe.io.UInt32ArrayData"/></this>
		<impl><class path="haxe.io._UInt32Array.UInt32Array_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/UInt32Array.hx" private="1" module="haxe.io.UInt32Array" final="1">
	<fromData public="1" set="method" line="69" static="1"><f a="d">
	<t path="haxe.io.UInt32ArrayData"/>
	<x path="haxe.io.UInt32Array"/>
</f></fromData>
	<fromBytes public="1" set="method" line="84" static="1">
		<f a="bytes:?bytePos:?length" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="haxe.io.UInt32Array"/>
		</f>
		<meta><m n=":value"><e>{ bytePos : 0 }</e></m></meta>
	</fromBytes>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.io._UInt32Array.UInt32Array_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/UInt32Array.hx" private="1" module="haxe.io.UInt32Array" final="1">
		<fromData public="1" set="method" line="69" static="1"><f a="d">
	<t path="haxe.io.UInt32ArrayData"/>
	<x path="haxe.io.UInt32Array"/>
</f></fromData>
		<fromBytes public="1" set="method" line="84" static="1">
			<f a="bytes:?bytePos:?length" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="haxe.io.UInt32Array"/>
			</f>
			<meta><m n=":value"><e>{ bytePos : 0 }</e></m></meta>
		</fromBytes>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.UInt8ArrayData" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/UInt8Array.hx" module="haxe.io.UInt8Array"><t path="haxe.io.ArrayBufferViewData"/></typedef>
	<abstract path="haxe.io.UInt8Array" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/UInt8Array.hx">
		<this><t path="haxe.io.UInt8ArrayData"/></this>
		<impl><class path="haxe.io._UInt8Array.UInt8Array_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/io/UInt8Array.hx" private="1" module="haxe.io.UInt8Array" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.MapKeyValueIterator" params="K:V" file="/home/nanjizal/haxe/versions/779b005/std/haxe/iterators/MapKeyValueIterator.hx" extern="1">
		<map><c path="haxe.IMap">
	<c path="haxe.iterators.MapKeyValueIterator.K"/>
	<c path="haxe.iterators.MapKeyValueIterator.V"/>
</c></map>
		<keys><t path="Iterator"><c path="haxe.iterators.MapKeyValueIterator.K"/></t></keys>
		<hasNext public="1" get="inline" set="null" line="43">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="50">
			<f a=""><a>
	<value><c path="haxe.iterators.MapKeyValueIterator.V"/></value>
	<key><c path="haxe.iterators.MapKeyValueIterator.K"/></key>
</a></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35"><f a="map">
	<c path="haxe.IMap">
		<c path="haxe.iterators.MapKeyValueIterator.K"/>
		<c path="haxe.iterators.MapKeyValueIterator.V"/>
	</c>
	<x path="Void"/>
</f></new>
		<haxe_doc>This Key/Value iterator can be used to iterate across maps.</haxe_doc>
		<meta><m n=":ifFeature">
	<e>"anon_read.keyValueIterator"</e>
	<e>"dynamic_read.keyValueIterator"</e>
</m></meta>
	</class>
	<class path="haxe.iterators.RestIterator" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/iterators/RestIterator.hx">
		<args final="1"><x path="haxe.Rest"><c path="haxe.iterators.RestIterator.T"/></x></args>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="16"><f a=""><c path="haxe.iterators.RestIterator.T"/></f></next>
		<new get="inline" set="null" line="8">
			<f a="args">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>haxe.Rest</e></m></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.macro.IncludePosition" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Compiler.hx" module="haxe.macro.Compiler">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.macro._Compiler.IncludePosition_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.macro.NullSafetyMode" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Compiler.hx" module="haxe.macro.Compiler">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.macro._Compiler.NullSafetyMode_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<typedef path="haxe.macro.Position" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Expr" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Metadata associatied with the variable, if available.</haxe_doc>
			</meta>
			<isStatic>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable is static.</haxe_doc>
			</isStatic>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@see https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has `name = "Module"`, `sub = "Type"`, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<defaultType>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional default type of the type parameter.</haxe_doc>
			</defaultType>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Ref" params="T" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<toString set="method"><f a=""><c path="String"/></f></toString>
			<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
		</a>
		<haxe_doc>Represents a reference to internal compiler structure. It exists to avoid
	expensive encoding if it is not required and to ensure that physical
	equality remains intact.

	A structure is only encoded when user requests it through `ref.get()`.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AnonType" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<status>
				<e path="haxe.macro.AnonStatus"/>
				<haxe_doc>The status/kind of the structure.</haxe_doc>
			</status>
			<fields>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The class fields of the structure.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents information for anonymous structure types.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the type parameter. It is guaranteed to be a `TInst` with a
		`KTypeParameter` kind.</haxe_doc>
			</t>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<defaultType>
				<x path="Null"><e path="haxe.macro.Type"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The default type for this type parameter.</haxe_doc>
			</defaultType>
		</a>
		<haxe_doc>Represents the declaration of type parameters.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassField" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the class field.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the class field.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the class field.</haxe_doc>
			</params>
			<overloads>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The overload fields of the class field.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the class field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the class field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldKind"/>
				<haxe_doc>The class field kind.</haxe_doc>
			</kind>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is public.</haxe_doc>
			</isPublic>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is final.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is extern.</haxe_doc>
			</isExtern>
			<isAbstract>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is abstract.</haxe_doc>
			</isAbstract>
			<expr set="method">
				<f a=""><x path="Null"><t path="haxe.macro.TypedExpr"/></x></f>
				<haxe_doc>Returns the typed expression of the class field.</haxe_doc>
			</expr>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a class field.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumField" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the enum constructor.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the enum constructor.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the enum constructor.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the enum constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the enum constructor.</haxe_doc>
			</meta>
			<index>
				<x path="Int"/>
				<haxe_doc>The index of the enum constructor, i.e. in which position it appears
		in the syntax.</haxe_doc>
			</index>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the enum constructor.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents an enum constructor.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.BaseType" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The information that all types (`ClassType`, `EnumType`, `DefType`,
	`AbstractType`) have in common.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassType" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<superClass>
				<x path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></x>
				<haxe_doc>The parent class and its type parameters, if available.</haxe_doc>
			</superClass>
			<statics>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The static fields of the class.</haxe_doc>
			</statics>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<overrides>
				<c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c>
				<haxe_doc>The list of fields that have override status.</haxe_doc>
			</overrides>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.ClassKind"/>
				<haxe_doc>The kind of the class.</haxe_doc>
			</kind>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>If true the type is an interface, otherwise it is a class.</haxe_doc>
			</isInterface>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>If true the class is final and cannot be extended.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<isAbstract>
				<x path="Bool"/>
				<haxe_doc>If true the class is abstract and cannot be instantiated directly.</haxe_doc>
			</isAbstract>
			<interfaces>
				<c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c>
				<haxe_doc>The implemented interfaces and their type parameters.</haxe_doc>
			</interfaces>
			<init>
				<x path="Null"><t path="haxe.macro.TypedExpr"/></x>
				<haxe_doc>The `__init__` expression of the class, if available.</haxe_doc>
			</init>
			<fields>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The member fields of the class.</haxe_doc>
			</fields>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructor>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></x>
				<haxe_doc>The constructor of the class, if available.</haxe_doc>
			</constructor>
		</a>
		<haxe_doc>Represents a class type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumType" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<names>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>An ordered list of enum constructor names.</haxe_doc>
			</names>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructs>
				<t path="Map">
					<c path="String"/>
					<t path="haxe.macro.EnumField"/>
				</t>
				<haxe_doc>The available enum constructors.</haxe_doc>
			</constructs>
		</a>
		<haxe_doc>Represents an enum type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.DefType" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The target type of the typedef.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a typedef.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<unops>
				<c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined unary operators of the abstract.</haxe_doc>
			</unops>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The underlying type of the abstract.</haxe_doc>
			</type>
			<to>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit to-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</to>
			<resolveWrite>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolveWrite>
			<resolve>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolve>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<impl>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></x>
				<haxe_doc>The implementation class of the abstract, if available.</haxe_doc>
			</impl>
			<from>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit from-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</from>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<binops>
				<c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined binary operators of the abstract.</haxe_doc>
			</binops>
			<array>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The defined array-access fields of the abstract.</haxe_doc>
			</array>
		</a>
		<haxe_doc>Represents an abstract type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array `[]` is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t set="null">
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the variable.</haxe_doc>
			</t>
			<name set="null">
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta set="null">
				<x path="Null"><t path="haxe.macro.MetaAccess"/></x>
				<haxe_doc>The metadata of the variable.</haxe_doc>
			</meta>
			<id set="null">
				<x path="Int"/>
				<haxe_doc>The unique ID of the variable.</haxe_doc>
			</id>
			<extra set="null">
				<x path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><x path="Null"><t path="haxe.macro.TypedExpr"/></x></expr>
</a></x>
				<haxe_doc>Special information which is internally used to keep track of closure.
		information</haxe_doc>
			</extra>
			<capture set="null">
				<x path="Bool"/>
				<haxe_doc>Whether or not the variable has been captured by a closure.</haxe_doc>
			</capture>
		</a>
		<haxe_doc>Represents a variable in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TFunc" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The return type of the function.</haxe_doc>
			</t>
			<expr>
				<t path="haxe.macro.TypedExpr"/>
				<haxe_doc>The expression of the function body.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><a>
	<value><x path="Null"><t path="haxe.macro.TypedExpr"/></x></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c>
				<haxe_doc>A list of function arguments identified by an argument variable `v` and
		an optional initialization `value`.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the expression.</haxe_doc>
			</t>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.TypedExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a typed AST node.</haxe_doc>
	</typedef>
	<abstract path="haxe.xml._Parser.S" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.xml._Parser.S_Impl_" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.xml.XmlParserException" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/xml/Parser.hx" module="haxe.xml.Parser" extern="1">
		<message public="1">
			<c path="String"/>
			<haxe_doc>the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>the line number at which the XML parsing error occurred</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the reported line at which the parsing error occurred</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the XML string at which the parsing error occurred</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="94"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="75"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.xml.Parser" params="" file="/home/nanjizal/haxe/versions/779b005/std/haxe/xml/Parser.hx" extern="1">
		<escapes expr="{
	var h = new haxe.ds.StringMap();
	h.set(&quot;lt&quot;, &quot;&lt;&quot;);
	h.set(&quot;gt&quot;, &quot;&gt;&quot;);
	h.set(&quot;amp&quot;, &quot;&amp;&quot;);
	h.set(&quot;quot&quot;, &quot;\&quot;&quot;);
	h.set(&quot;apos&quot;, &quot;&apos;&quot;);
	h;
}" line="100" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var h = new haxe.ds.StringMap();
	h.set("lt", "<");
	h.set("gt", ">");
	h.set("amp", "&");
	h.set("quot", "\"");
	h.set("apos", "'");
	h;
}]]></e></m></meta>
		</escapes>
		<parse public="1" set="method" line="115" static="1">
			<f a="str:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<meta><m n=":value"><e>{ strict : false }</e></m></meta>
			<haxe_doc>Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.

		@throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="121" static="1">
			<f a="str:strict:?p:?parent" v="::0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ p : 0 }</e></m></meta>
		</doParse>
		<isValidChar get="inline" set="null" line="415" static="1"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isValidChar>
	</class>
	<class path="haxe.zip.Compress" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/zip/Compress.hx" extern="1">
		<run public="1" set="method" line="45" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init set="method" static="1">
			<f a="level">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_deflate_init"</e></m></meta>
		</_deflate_init>
		<_deflate_bound set="method" static="1">
			<f a="handle:length">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_deflate_bound"</e></m></meta>
		</_deflate_bound>
		<_deflate_buffer set="method" static="1">
			<f a="handle:src:srcPos:dest:destPos">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<a>
					<write><x path="Int"/></write>
					<read><x path="Int"/></read>
					<done><x path="Bool"/></done>
				</a>
			</f>
			<meta><m n=":native"><e>"_hx_deflate_buffer"</e></m></meta>
		</_deflate_buffer>
		<_deflate_end set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_deflate_end"</e></m></meta>
		</_deflate_end>
		<_set_flush_mode set="method" static="1">
			<f a="handle:flushMode">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_zip_set_flush_mode"</e></m></meta>
		</_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/zlib/Build.xml\" />"]]></e></m>
		</meta>
	</class>
	<class path="haxe.zip.Uncompress" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/haxe/zip/Uncompress.hx" extern="1">
		<run public="1" set="method" line="45" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init set="method" static="1">
			<f a="windowBits">
				<d/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_inflate_init"</e></m></meta>
		</_inflate_init>
		<_inflate_buffer set="method" static="1">
			<f a="handle:src:srcPos:dest:destPos">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<a>
					<write><x path="Int"/></write>
					<read><x path="Int"/></read>
					<done><x path="Bool"/></done>
				</a>
			</f>
			<meta><m n=":native"><e>"_hx_inflate_buffer"</e></m></meta>
		</_inflate_buffer>
		<_inflate_end set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_inflate_end"</e></m></meta>
		</_inflate_end>
		<_set_flush_mode set="method" static="1">
			<f a="handle:flushMode">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_zip_set_flush_mode"</e></m></meta>
		</_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37">
			<f a="f">
				<e path="haxe.zip.FlushMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="?windowBits">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/zlib/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<class path="justPath._CurveMath.CurveMath_Fields_" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/CurveMath.hx" private="1" module="justPath.CurveMath" final="1">
		<distance public="1" get="inline" set="null" line="3" static="1"><f a="px:py:qx:qy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distance>
		<quadStep public="1" expr="0.03" line="8" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.03</e></m></meta>
		</quadStep>
		<quadCurve public="1" get="inline" set="null" line="11" static="1"><f a="p:ax:ay:bx:by:cx:cy">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><x path="Float"/></c>
</f></quadCurve>
		<cubicStep public="1" get="inline" set="null" expr="0.03" line="27" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.03</e></m></meta>
		</cubicStep>
		<cubicCurve public="1" get="inline" set="null" line="30" static="1"><f a="p:ax:ay:bx:by:cx:cy:dx:dy">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><x path="Float"/></c>
</f></cubicCurve>
		<calculateQuadStep public="1" get="inline" set="null" line="46" static="1"><f a="ax:ay:bx:by:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculateQuadStep>
		<calculateCubicStep public="1" get="inline" set="null" line="52" static="1"><f a="ax:ay:bx:by:cx:cy:dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculateCubicStep>
		<quadraticThru public="1" get="inline" set="null" line="58" static="1"><f a="t:s:c:e">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></quadraticThru>
		<quadratic public="1" get="inline" set="null" line="63" static="1"><f a="t:s:c:e">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></quadratic>
		<cubic public="1" get="inline" set="null" line="68" static="1"><f a="t:s:c1:c2:e">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></cubic>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="justPath.EllipseArcData" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/EllipseArc.hx" module="justPath.EllipseArc"><a>
	<ry><x path="Float"/></ry>
	<rx><x path="Float"/></rx>
	<phiSin><x path="Float"/></phiSin>
	<phiCos><x path="Float"/></phiCos>
	<phi><x path="Float"/></phi>
	<omega><x path="Float"/></omega>
	<delta><x path="Float"/></delta>
	<cy><x path="Float"/></cy>
	<cx><x path="Float"/></cx>
	<alpha><x path="Float"/></alpha>
</a></typedef>
	<class path="justPath.EllipseArc" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/EllipseArc.hx">
		<arc><t path="justPath.EllipseArcData"/></arc>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<alphaPoint public="1" set="method" line="26"><f a=""><x path="Void"/></f></alphaPoint>
		<omegaPoint public="1" set="method" line="29"><f a=""><x path="Void"/></f></omegaPoint>
		<lineRender public="1" set="method" line="33">
			<f a="moveTo:lineTo:dA:?renderFirst" v=":::true">
				<f a=":">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<f a=":">
					<x path="Float"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ renderFirst : true }</e></m></meta>
		</lineRender>
		<calculatePoint public="1" get="inline" set="null" line="51"><f a="theta">
	<x path="Float"/>
	<x path="Void"/>
</f></calculatePoint>
		<new public="1" set="method" line="23"><f a="arc_">
	<t path="justPath.EllipseArcData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":forward"/>
		</meta>
	</class>
	<abstract path="justPath.ConverterArc" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/EllipseArc.hx" module="justPath.EllipseArc">
		<from><icast><t path="justPath.EllipseArcData"/></icast></from>
		<this><t path="justPath.EllipseArcData"/></this>
		<to><icast><t path="justPath.EllipseArcData"/></icast></to>
		<impl><class path="justPath._EllipseArc.ConverterArc_Impl_" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/EllipseArc.hx" private="1" module="justPath.EllipseArc" final="1">
	<_new public="1" get="inline" set="null" line="67" static="1">
		<f a="sx:sy:xr:yr:phi:large:sweep:ex:ey">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="justPath.ConverterArc"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<zeroto2pi get="inline" set="null" line="139" static="1"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></zeroto2pi>
</class></impl>
	</abstract>
	<class path="justPath._EllipseArc.ConverterArc_Impl_" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/EllipseArc.hx" private="1" module="justPath.EllipseArc" final="1">
		<_new public="1" get="inline" set="null" line="67" static="1">
			<f a="sx:sy:xr:yr:phi:large:sweep:ex:ey">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="justPath.ConverterArc"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<zeroto2pi get="inline" set="null" line="139" static="1"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></zeroto2pi>
	</class>
	<class path="justPath.ILinePathContext" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/ILinePathContext.hx" interface="1">
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<lineSegmentTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
	</class>
	<class path="justPath.LinePathContextTrace" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/LinePathContextTrace.hx">
		<implements path="justPath.ILinePathContext"/>
		<moveTo public="1" set="method" line="7"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method" line="10"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<lineSegmentTo public="1" set="method" line="13"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="justPath.StoreF6" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/StoreF6.hx">
		<l expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</l>
		<s0 public="1"><x path="Null"><x path="Float"/></x></s0>
		<s1 public="1"><x path="Null"><x path="Float"/></x></s1>
		<s2 public="1"><x path="Null"><x path="Float"/></x></s2>
		<s3 public="1"><x path="Null"><x path="Float"/></x></s3>
		<s4 public="1"><x path="Null"><x path="Float"/></x></s4>
		<s5 public="1"><x path="Null"><x path="Float"/></x></s5>
		<s6 public="1"><c path="justPath.StoreF6"/></s6>
		<clear public="1" get="inline" set="null" line="13"><f a=""><x path="Void"/></f></clear>
		<length public="1" get="inline" set="null" line="23"><f a=""><x path="Int"/></f></length>
		<push public="1" get="inline" set="null" line="26"><f a="v">
	<x path="Null"><x path="Float"/></x>
	<x path="Void"/>
</f></push>
		<pop public="1" get="inline" set="null" line="46"><f a=""><x path="Null"><x path="Float"/></x></f></pop>
		<unshift public="1" get="inline" set="null" line="74"><f a="v">
	<x path="Null"><x path="Float"/></x>
	<x path="Void"/>
</f></unshift>
		<shift public="1" get="inline" set="null" line="84"><f a=""><x path="Null"><x path="Float"/></x></f></shift>
		<toString public="1" get="inline" set="null" line="98"><f a=""><c path="String"/></f></toString>
		<populatedToString public="1" get="inline" set="null" line="105"><f a=""><c path="String"/></f></populatedToString>
		<count expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</count>
		<hasNext public="1" get="inline" set="null" line="129"><f a=""><x path="Bool"/></f></hasNext>
		<resetIterator public="1" get="inline" set="null" line="132"><f a=""><x path="Void"/></f></resetIterator>
		<next public="1" get="inline" set="null" line="136"><f a=""><x path="Null"><x path="Float"/></x></f></next>
		<first public="1" get="inline" set="null" line="157"><f a=""><x path="Null"><x path="Float"/></x></f></first>
		<last public="1" get="inline" set="null" line="160"><f a=""><x path="Null"><x path="Float"/></x></f></last>
		<penultimate public="1" get="inline" set="null" line="180"><f a=""><x path="Null"><x path="Float"/></x></f></penultimate>
		<toArray public="1" get="inline" set="null" line="200"><f a=""><x path="Void"/></f></toArray>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="justPath.StoreF8" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/StoreF8.hx">
		<l expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</l>
		<s0 public="1"><x path="Null"><x path="Float"/></x></s0>
		<s1 public="1"><x path="Null"><x path="Float"/></x></s1>
		<s2 public="1"><x path="Null"><x path="Float"/></x></s2>
		<s3 public="1"><x path="Null"><x path="Float"/></x></s3>
		<s4 public="1"><x path="Null"><x path="Float"/></x></s4>
		<s5 public="1"><x path="Null"><x path="Float"/></x></s5>
		<s6 public="1"><x path="Null"><x path="Float"/></x></s6>
		<s7 public="1"><x path="Null"><x path="Float"/></x></s7>
		<clear public="1" get="inline" set="null" line="14"><f a=""><x path="Void"/></f></clear>
		<length public="1" get="inline" set="null" line="25"><f a=""><x path="Int"/></f></length>
		<push public="1" get="inline" set="null" line="28"><f a="v">
	<x path="Null"><x path="Float"/></x>
	<x path="Void"/>
</f></push>
		<pop public="1" get="inline" set="null" line="51"><f a=""><x path="Null"><x path="Float"/></x></f></pop>
		<unshift public="1" get="inline" set="null" line="85"><f a="v">
	<x path="Null"><x path="Float"/></x>
	<x path="Void"/>
</f></unshift>
		<shift public="1" get="inline" set="null" line="95"><f a=""><x path="Null"><x path="Float"/></x></f></shift>
		<toString public="1" get="inline" set="null" line="110"><f a=""><c path="String"/></f></toString>
		<populatedToString public="1" get="inline" set="null" line="113"><f a=""><c path="String"/></f></populatedToString>
		<count expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</count>
		<hasNext public="1" get="inline" set="null" line="138"><f a=""><x path="Bool"/></f></hasNext>
		<resetIterator public="1" get="inline" set="null" line="141"><f a=""><x path="Void"/></f></resetIterator>
		<next public="1" get="inline" set="null" line="144"><f a=""><x path="Null"><x path="Float"/></x></f></next>
		<first public="1" get="inline" set="null" line="169"><f a=""><x path="Null"><x path="Float"/></x></f></first>
		<last public="1" get="inline" set="null" line="172"><f a=""><x path="Null"><x path="Float"/></x></f></last>
		<penultimate public="1" get="inline" set="null" line="196"><f a=""><x path="Null"><x path="Float"/></x></f></penultimate>
		<toArray public="1" get="inline" set="null" line="220"><f a=""><x path="Void"/></f></toArray>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="justPath.SvgLinePath" params="" file="/home/nanjizal/haxe/haxe_libraries/justPath/0.0.2/github/73afb336149428fec5f356cbb799effdc937d201/justPath/SvgLinePath.hx">
		<str expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</str>
		<pos expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pos>
		<lastX expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</lastX>
		<lastY expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</lastY>
		<controlX expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</controlX>
		<controlY expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</controlY>
		<c expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</c>
		<l expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</l>
		<px expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</px>
		<py expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</py>
		<pathContext><c path="justPath.ILinePathContext"/></pathContext>
		<store><c path="justPath.StoreF6"/></store>
		<quickTriangle set="method" line="23"><f a="x0:y0:off">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quickTriangle>
		<parse public="1" set="method" line="30"><f a="str_">
	<c path="String"/>
	<c path="String"/>
</f></parse>
		<extractArgs get="inline" set="null" line="394">
			<f a="?process" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ process : true }</e></m></meta>
		</extractArgs>
		<nextChar get="inline" set="null" line="476"><f a=""><x path="Int"/></f></nextChar>
		<moveTo public="1" get="inline" set="null" line="480"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" get="inline" set="null" line="486"><f a="x_:y_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadThru public="1" get="inline" set="null" line="493"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadThru>
		<quadTo public="1" get="inline" set="null" line="499"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadTo>
		<curveTo public="1" get="inline" set="null" line="509"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<plotSegmentCoord public="1" get="inline" set="null" line="519">
			<f a="arr:?withMove" v=":true">
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ withMove : true }</e></m></meta>
		</plotSegmentCoord>
		<plotCoord public="1" get="inline" set="null" line="533">
			<f a="arr:?withMove" v=":true">
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ withMove : true }</e></m></meta>
		</plotCoord>
		<new public="1" set="method" line="20"><f a="pathContext_">
	<c path="justPath.ILinePathContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage._Endian.Endian_Fields_" params="" file="src/pixelimage/Endian.hx" private="1" module="pixelimage.Endian" final="1">
		<isLittleEndian final="1" public="1" set="null" expr="(function() -&gt;  @:implicitReturn return {
	var a8 = new haxe.io.UInt8Array(4);
	return true;
})()" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e><![CDATA[(function() ->  @:implicitReturn return {
	var a8 = new haxe.io.UInt8Array(4);
	return true;
})()]]></e></m></meta>
			<haxe_doc>little endian most desktops and laptops, seems that canvas context is ABGR so this is used to detect conversion</haxe_doc>
		</isLittleEndian>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.ImageStruct" params="" file="src/pixelimage/ImageStruct.hx">
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<image public="1"><x path="haxe.io.UInt32Array"/></image>
		<transparent public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transparent>
		<isLittle public="1"><x path="Bool"/></isLittle>
		<virtualX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</virtualX>
		<virtualY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</virtualY>
		<useVirtualPos public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</useVirtualPos>
		<mask public="1"><x path="pixelimage.Pixelimage"/></mask>
		<useMask public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</useMask>
		<new public="1" set="method" line="23"><f a="width:height:image">
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.UInt32Array"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This struct is the base of Pixelimage and Pixelshape abstracts</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="pixelimage.Pixelimage" params="" file="src/pixelimage/Pixelimage.hx">
		<from><icast><c path="pixelimage.ImageStruct"/></icast></from>
		<this><c path="pixelimage.ImageStruct"/></this>
		<to><icast><c path="pixelimage.ImageStruct"/></icast></to>
		<meta><m n=":transient"/></meta>
		<impl><class path="pixelimage._Pixelimage.Pixelimage_Impl_" params="" file="src/pixelimage/Pixelimage.hx" private="1" module="pixelimage.Pixelimage" final="1">
	<width public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>provides the width used by the UInt32Array</haxe_doc>
	</width>
	<get_width get="inline" set="null" line="33" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="Int"/>
</f></get_width>
	<height public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>provides the height used by the UInt32Array</haxe_doc>
	</height>
	<get_height get="inline" set="null" line="39" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="Int"/>
</f></get_height>
	<setRelativePosition public="1" set="method" line="44" static="1">
		<f a="this:x:y:?update" v=":::false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ update : false }</e></m></meta>
		<haxe_doc>setting relative position provide a drawing offset, it must be positive
        update is no currentl use yet</haxe_doc>
	</setRelativePosition>
	<transparent public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<haxe_doc>transparent to false will allow setARGB to overwrite pixels, true will alpha blend them when new pixel is semi transparent</haxe_doc>
	</transparent>
	<get_transparent get="inline" set="null" line="57" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="Bool"/>
</f></get_transparent>
	<set_transparent get="inline" set="null" line="58" static="1"><f a="this:v">
	<c path="pixelimage.ImageStruct"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_transparent>
	<mask public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.Pixelimage"/></mask>
	<get_mask get="inline" set="null" line="64" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="pixelimage.Pixelimage"/>
</f></get_mask>
	<set_mask get="inline" set="null" line="65" static="1"><f a="this:v">
	<c path="pixelimage.ImageStruct"/>
	<x path="pixelimage.Pixelimage"/>
	<x path="pixelimage.Pixelimage"/>
</f></set_mask>
	<image public="1" get="accessor" set="null" static="1"><x path="haxe.io.UInt32Array"/></image>
	<get_image get="inline" set="null" line="72" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="haxe.io.UInt32Array"/>
</f></get_image>
	<hasMask public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></hasMask>
	<set_hasMask get="inline" set="null" line="80" static="1"><f a="this:v">
	<c path="pixelimage.ImageStruct"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_hasMask>
	<get_hasMask get="inline" set="null" line="91" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="Bool"/>
</f></get_hasMask>
	<rectWindow get="accessor" set="accessor" static="1"><c path="pixelimage.algo.RectangleWindow"/></rectWindow>
	<get_rectWindow get="inline" set="null" line="93" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<c path="pixelimage.algo.RectangleWindow"/>
</f></get_rectWindow>
	<set_rectWindow get="inline" set="null" line="97" static="1">
		<f a="this:r">
			<c path="pixelimage.ImageStruct"/>
			<c path="pixelimage.algo.RectangleWindow"/>
			<c path="pixelimage.algo.RectangleWindow"/>
		</f>
		<meta><m n=":access"><e>pixelImage.ImageStruct</e></m></meta>
	</set_rectWindow>
	<_new public="1" get="inline" set="null" line="113" static="1">
		<f a="w:h">
			<x path="Int"/>
			<x path="Int"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<pos4 get="inline" set="null" line="127" static="1">
		<f a="this:x:y:?off" v=":::0">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":value"><e>{ off : 0 }</e></m></meta>
		<haxe_doc>this provides a location for a UIn8 access of a color channel</haxe_doc>
	</pos4>
	<position public="1" get="inline" set="null" line="132" static="1">
		<f a="this:x:y">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<haxe_doc>provides the location of the pixel after considering any relative internal x,y offset</haxe_doc>
	</position>
	<setPixel public="1" get="inline" set="null" line="153" static="1">
		<f a="this:x:y:color">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<haxe_doc>Provides a view for single color channel access, not usually used</haxe_doc>
	</setPixel>
	<zeroPixel public="1" get="inline" set="null" line="157" static="1"><f a="this:x:y">
	<c path="pixelimage.ImageStruct"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></zeroPixel>
	<setARGB public="1" get="inline" set="null" line="165" static="1">
		<f a="this:x:y:color">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<haxe_doc>The main way is set the pixel color at x, y
        applies an alpha blend if pixel is semi-transparent and if the pixelimage is transparent true</haxe_doc>
	</setARGB>
	<getPixel public="1" get="inline" set="null" line="175" static="1"><f a="this:x:y">
	<c path="pixelimage.ImageStruct"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
	<getARGB public="1" get="inline" set="null" line="183" static="1">
		<f a="this:x:y">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<haxe_doc>returns the current pixel colour, since canvas context is ABGR on little endian this will correct
        from the internal value</haxe_doc>
	</getARGB>
	<set_argbPixel public="1" get="inline" set="null" line="192" static="1">
		<f a="this:a:r:g:b:location">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>allows setting all 4 colour channels with a location
        @:see position   to obtain the location</haxe_doc>
	</set_argbPixel>
	<argbToPixel public="1" get="inline" set="null" line="200" static="1">
		<f a="this:a:r:g:b:location">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>used more internally to set colours from algorithms does not apply alpha blend</haxe_doc>
	</argbToPixel>
	<channelBlend public="1" get="inline" set="null" line="212" static="1">
		<f a="this:a:r:g:b:location">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.pixel.PixelChannel"/>
			<x path="pixelimage.pixel.PixelChannel"/>
			<x path="pixelimage.pixel.PixelChannel"/>
			<x path="pixelimage.pixel.PixelChannel"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>used internally is set colours from algorithms only applies alpha blend
        @see setARGB</haxe_doc>
	</channelBlend>
	<colorBlend public="1" get="inline" set="null" line="222" static="1">
		<f a="this:color:location">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>used internally to set colours from algorithms only applies 
        @see setARGB</haxe_doc>
	</colorBlend>
	<getPixelString public="1" get="inline" set="null" line="231" static="1">
		<f a="this:x:y">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>mainly used for color debugging provides getARGB in hex string format</haxe_doc>
	</getPixelString>
	<simpleRect public="1" get="inline" set="null" line="238" static="1">
		<f a="this:x:y:w:h:color">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>provides a simple filled Rectangle</haxe_doc>
	</simpleRect>
	<clearRect public="1" get="inline" set="null" line="255" static="1"><f a="this:x:y:w:h">
	<c path="pixelimage.ImageStruct"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearRect>
	<flippedX public="1" get="inline" set="null" line="278" static="1">
		<f a="this:x:y:w:h:?transparent:?inPlace:?includeMask" v=":::::false:false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, inPlace : false, transparent : false }</e></m></meta>
		<haxe_doc>creates a new Pixelimage that is flipped horizonally.
        inPlace overwrites current.</haxe_doc>
	</flippedX>
	<flippedY public="1" get="inline" set="null" line="314" static="1">
		<f a="this:x:y:w:h:?transparent:?inPlace:?includeMask" v=":::::false:false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, inPlace : false, transparent : false }</e></m></meta>
		<haxe_doc>creates a new Pixelimage that is flipped vertically.
        inPlace overwrites current.</haxe_doc>
	</flippedY>
	<spunClock90 public="1" get="inline" set="null" line="350" static="1">
		<f a="this:x:y:w:h:?transparent:?includeMask" v=":::::false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, transparent : false }</e></m></meta>
		<haxe_doc>creates a new Pixelimage base on current image, rotated 90° clockwise</haxe_doc>
	</spunClock90>
	<spunAntiClock90 public="1" get="inline" set="null" line="377" static="1">
		<f a="this:x:y:w:h:?transparent:?includeMask" v=":::::false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, transparent : false }</e></m></meta>
	</spunAntiClock90>
	<spun180 public="1" get="inline" set="null" line="404" static="1">
		<f a="this:x:y:w:h:?transparent:?includeMask" v=":::::false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, transparent : false }</e></m></meta>
	</spun180>
	<scaleXY public="1" get="inline" set="null" line="429" static="1">
		<f a="this:sx:sy:?transparent:?includeMask" v=":::false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, transparent : false }</e></m></meta>
	</scaleXY>
	<rotateClockwiseDegrees public="1" get="inline" set="null" line="451" static="1">
		<f a="this:angle:?centreX:?centreY:?transparent:?includeMask" v="::0.:0.:false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, transparent : false, centreY : 0., centreX : 0. }</e></m></meta>
	</rotateClockwiseDegrees>
	<rotateClockwiseRadians public="1" get="inline" set="null" line="469" static="1">
		<f a="this:theta:?centreX:?centreY:?transparent:?includeMask" v="::0.:0.:false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, transparent : false, centreY : 0., centreX : 0. }</e></m></meta>
	</rotateClockwiseRadians>
	<rotate public="1" get="inline" set="null" line="488" static="1">
		<f a="this:theta:?centreX:?centreY:?transparent:?includeMask" v="::0.:0.:false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, transparent : false, centreY : 0., centreX : 0. }</e></m></meta>
	</rotate>
	<scaleUpInt public="1" get="inline" set="null" line="558" static="1">
		<f a="this:?scaleW:?scaleH:?transparent:?includeMask" v=":2:2:false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<meta><m n=":value"><e>{ includeMask : false, transparent : false, scaleH : 2, scaleW : 2 }</e></m></meta>
	</scaleUpInt>
	<patternRect public="1" get="inline" set="null" line="585" static="1"><f a="this:x:y:w:h:foreColor:backColor:patternFill">
	<c path="pixelimage.ImageStruct"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Bool"/></c>
	<x path="Void"/>
</f></patternRect>
	<patternRectDown public="1" get="inline" set="null" line="615" static="1"><f a="this:x:y:w:h:foreColor:backColor:patternFill">
	<c path="pixelimage.ImageStruct"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Bool"/></c>
	<x path="Void"/>
</f></patternRectDown>
	<fillSquare public="1" get="inline" set="null" line="649" static="1">
		<f a="this:x:y:d:color">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>provides a simple filled square a short cut 
        @see simpleRect</haxe_doc>
	</fillSquare>
	<fillTri public="1" get="inline" set="null" line="662" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:color:?hasHit:?hasUndo" v="::::::::false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
		</f>
		<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		<haxe_doc>provides a filled triangle give a,b,c coordinates
        automagically rearranges coordinates so it always renders</haxe_doc>
	</fillTri>
	<tileTri public="1" get="inline" set="null" line="670" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:tileImage:?hasHit" v="::::::::false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
	</tileTri>
	<fillQuad public="1" get="inline" set="null" line="682" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:?hasHit" v="::::::::::false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitQuad"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		<haxe_doc>uses two triangles to create a filled quad using four coordinates a,b,c,d arranged clockwise</haxe_doc>
	</fillQuad>
	<tileQuad public="1" get="inline" set="null" line="693" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:dx:dy:tileImage:?hasHit" v="::::::::::false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitQuad"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
	</tileQuad>
	<fillGradTri public="1" get="inline" set="null" line="706" static="1">
		<f a="this:ax:ay:colA:bx:by:colB:cx:cy:colC:?hasHit" v="::::::::::true">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		<haxe_doc>creates a filled gradient triangle in OpenGL 3 color style for coordinates a,b,c
        with respective colors after coordinate pairs</haxe_doc>
	</fillGradTri>
	<imgTri public="1" get="inline" set="null" line="714" static="1">
		<f a="this:texture:win:ax:ay:au:av:bx:by:bu:bv:cx:cy:cu:cv:?hasHit" v=":::::::::::::::true">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.Pixelimage"/>
			<c path="pixelimage.algo.RectangleWindow"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
	</imgTri>
	<tileRect public="1" get="inline" set="null" line="721" static="1">
		<f a="this:x:y:wid:hi:tileImage:?hasHit" v="::::::false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitQuad"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
	</tileRect>
	<fillGradRect public="1" get="inline" set="null" line="732" static="1">
		<f a="this:x:y:wid:hi:colorA:colorB:colorC:colorD">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<a>
				<y><x path="Float"/></y>
				<x><x path="Float"/></x>
				<dy><x path="Float"/></dy>
				<cy><x path="Float"/></cy>
				<cx><x path="Float"/></cx>
				<bx><x path="Float"/></bx>
				<ay><x path="Float"/></ay>
				<ax><x path="Float"/></ax>
			</a>
		</f>
		<haxe_doc>uses two triangles to form rectangle x,y,width,height with a,b,c,d clockwise gradient colours</haxe_doc>
	</fillGradRect>
	<fillGradQuad public="1" get="inline" set="null" line="753" static="1">
		<f a="this:ax:ay:colorA:bx:by:colorB:cx:cy:colorC:dx:dy:colorD:?hasHit" v=":::::::::::::true">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		<haxe_doc>uses two triangle to form a quad with clockwise coordinates a,b,c,d
        with respective colours after each coordinate pair

        a better render maybe possible see commented out code in algo.QuadPixel and lerp code in algo.GeomPixel
        ( better render approach compiles but does not yet work, maybe easy? ).</haxe_doc>
	</fillGradQuad>
	<imgQuad public="1" get="inline" set="null" line="764" static="1">
		<f a="this:texture:win:ax:ay:bx:by:cx:cy:dx:dy:?hasHit" v=":::::::::::true">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.Pixelimage"/>
			<c path="pixelimage.algo.RectangleWindow"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
	</imgQuad>
	<imgRect public="1" get="inline" set="null" line="773" static="1">
		<f a="this:texture:win:x:y:wid:hi:?theta:?centreX:?centreY:?skewX:?skewY:?scaleX:?scaleY:?hasHit" v=":::::::0.:0.:0.:0.:0.:1.:1.:true">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.Pixelimage"/>
			<c path="pixelimage.algo.RectangleWindow"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, scaleY : 1., scaleX : 1., skewY : 0., skewX : 0., centreY : 0., centreX : 0., theta : 0. }</e></m></meta>
	</imgRect>
	<imgNineSlice public="1" get="inline" set="null" line="849" static="1">
		<f a="this:texture:win:x:y:wid:hi:left:top:fat:tall:widNew:hiNew:leftNew:topNew:fatNew:tallNew:?hasHit" v=":::::::::::::::::false">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.Pixelimage"/>
			<c path="pixelimage.algo.RectangleWindow"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
	</imgNineSlice>
	<fillLine public="1" get="inline" set="null" line="873" static="1">
		<f a="this:px:py:qx:qy:thick:color:?hasHit:?debugCorners" v=":::::::true:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ debugCorners : false, hasHit : true }</e></m></meta>
		<haxe_doc>provides a thick line using two triangles vector p, q
        debug corners draws coloured squares on the corners for development</haxe_doc>
	</fillLine>
	<tileLine public="1" get="inline" set="null" line="888" static="1">
		<f a="this:px:py:qx:qy:thick:tileImage:?hasHit:?debugCorners" v=":::::::false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ debugCorners : false, hasHit : false }</e></m></meta>
		<haxe_doc>tiles a thick line using two triangles vector p, q
        debug corners draws coloured squares on the corners for development</haxe_doc>
	</tileLine>
	<fillGradLine public="1" get="inline" set="null" line="905" static="1">
		<f a="this:px:py:qx:qy:thick:colorA:colorB:colorC:colorD:?hasHit:?debugCorners" v="::::::::::false:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ debugCorners : false, hasHit : false }</e></m></meta>
		<haxe_doc>provides a thick line using two gradient triangle vector p,q
        the four colors are arranged clockwise a,b,c,d
        debug corners draws coloured squares on the corners for development</haxe_doc>
	</fillGradLine>
	<putPixelImage public="1" get="inline" set="null" line="920" static="1">
		<f a="this:pixelImage:x:y:?useAvaliableMask:?forceClear" v="::::true:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ forceClear : false, useAvaliableMask : true }</e></m></meta>
		<haxe_doc>used to draw one pixelimage on part of another, essentially it is a copy
        black transparent pixels are ignored.
        this is used also internally so that shapes can be composed with transparent false 
        useful for adding over and taking away parts of shapes before drawing on the main Pixelimage.</haxe_doc>
	</putPixelImage>
	<putPixelImageRect public="1" get="inline" set="null" line="939" static="1">
		<f a="this:pixelImage:x:y:rectLeft:rectTop:rectRight:rectBottom:?useAvaliableMask:?forceClear" v="::::::::true:false">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ forceClear : false, useAvaliableMask : true }</e></m></meta>
	</putPixelImageRect>
	<transferClone public="1" get="inline" set="null" line="1005" static="1">
		<f a="this">
			<c path="pixelimage.ImageStruct"/>
			<x path="pixelimage.Pixelimage"/>
		</f>
		<haxe_doc>Currently library only supports Javascript target and puts the UInt32Array on the canvas context
        hope to add c++ and some toolkits later.</haxe_doc>
	</transferClone>
	<transferIn public="1" get="inline" set="null" line="1013" static="1"><f a="this:p">
	<c path="pixelimage.ImageStruct"/>
	<x path="pixelimage.Pixelimage"/>
	<x path="Void"/>
</f></transferIn>
	<getBytes public="1" get="inline" set="null" line="1025" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
	<fromBytes public="1" get="inline" set="null" line="1030" static="1"><f a="this:bytes:pos">
	<c path="pixelimage.ImageStruct"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fromBytes>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="pixelimage._Pixelimage.Pixelimage_Impl_" params="" file="src/pixelimage/Pixelimage.hx" private="1" module="pixelimage.Pixelimage" final="1">
		<width public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>provides the width used by the UInt32Array</haxe_doc>
		</width>
		<get_width get="inline" set="null" line="33" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="Int"/>
</f></get_width>
		<height public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>provides the height used by the UInt32Array</haxe_doc>
		</height>
		<get_height get="inline" set="null" line="39" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="Int"/>
</f></get_height>
		<setRelativePosition public="1" set="method" line="44" static="1">
			<f a="this:x:y:?update" v=":::false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ update : false }</e></m></meta>
			<haxe_doc>setting relative position provide a drawing offset, it must be positive
        update is no currentl use yet</haxe_doc>
		</setRelativePosition>
		<transparent public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<haxe_doc>transparent to false will allow setARGB to overwrite pixels, true will alpha blend them when new pixel is semi transparent</haxe_doc>
		</transparent>
		<get_transparent get="inline" set="null" line="57" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="Bool"/>
</f></get_transparent>
		<set_transparent get="inline" set="null" line="58" static="1"><f a="this:v">
	<c path="pixelimage.ImageStruct"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_transparent>
		<mask public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.Pixelimage"/></mask>
		<get_mask get="inline" set="null" line="64" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="pixelimage.Pixelimage"/>
</f></get_mask>
		<set_mask get="inline" set="null" line="65" static="1"><f a="this:v">
	<c path="pixelimage.ImageStruct"/>
	<x path="pixelimage.Pixelimage"/>
	<x path="pixelimage.Pixelimage"/>
</f></set_mask>
		<image public="1" get="accessor" set="null" static="1"><x path="haxe.io.UInt32Array"/></image>
		<get_image get="inline" set="null" line="72" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="haxe.io.UInt32Array"/>
</f></get_image>
		<hasMask public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></hasMask>
		<set_hasMask get="inline" set="null" line="80" static="1"><f a="this:v">
	<c path="pixelimage.ImageStruct"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_hasMask>
		<get_hasMask get="inline" set="null" line="91" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<x path="Bool"/>
</f></get_hasMask>
		<rectWindow get="accessor" set="accessor" static="1"><c path="pixelimage.algo.RectangleWindow"/></rectWindow>
		<get_rectWindow get="inline" set="null" line="93" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<c path="pixelimage.algo.RectangleWindow"/>
</f></get_rectWindow>
		<set_rectWindow get="inline" set="null" line="97" static="1">
			<f a="this:r">
				<c path="pixelimage.ImageStruct"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<c path="pixelimage.algo.RectangleWindow"/>
			</f>
			<meta><m n=":access"><e>pixelImage.ImageStruct</e></m></meta>
		</set_rectWindow>
		<_new public="1" get="inline" set="null" line="113" static="1">
			<f a="w:h">
				<x path="Int"/>
				<x path="Int"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<pos4 get="inline" set="null" line="127" static="1">
			<f a="this:x:y:?off" v=":::0">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ off : 0 }</e></m></meta>
			<haxe_doc>this provides a location for a UIn8 access of a color channel</haxe_doc>
		</pos4>
		<position public="1" get="inline" set="null" line="132" static="1">
			<f a="this:x:y">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>provides the location of the pixel after considering any relative internal x,y offset</haxe_doc>
		</position>
		<setPixel public="1" get="inline" set="null" line="153" static="1">
			<f a="this:x:y:color">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Provides a view for single color channel access, not usually used</haxe_doc>
		</setPixel>
		<zeroPixel public="1" get="inline" set="null" line="157" static="1"><f a="this:x:y">
	<c path="pixelimage.ImageStruct"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></zeroPixel>
		<setARGB public="1" get="inline" set="null" line="165" static="1">
			<f a="this:x:y:color">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>The main way is set the pixel color at x, y
        applies an alpha blend if pixel is semi-transparent and if the pixelimage is transparent true</haxe_doc>
		</setARGB>
		<getPixel public="1" get="inline" set="null" line="175" static="1"><f a="this:x:y">
	<c path="pixelimage.ImageStruct"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<getARGB public="1" get="inline" set="null" line="183" static="1">
			<f a="this:x:y">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>returns the current pixel colour, since canvas context is ABGR on little endian this will correct
        from the internal value</haxe_doc>
		</getARGB>
		<set_argbPixel public="1" get="inline" set="null" line="192" static="1">
			<f a="this:a:r:g:b:location">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>allows setting all 4 colour channels with a location
        @:see position   to obtain the location</haxe_doc>
		</set_argbPixel>
		<argbToPixel public="1" get="inline" set="null" line="200" static="1">
			<f a="this:a:r:g:b:location">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>used more internally to set colours from algorithms does not apply alpha blend</haxe_doc>
		</argbToPixel>
		<channelBlend public="1" get="inline" set="null" line="212" static="1">
			<f a="this:a:r:g:b:location">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.pixel.PixelChannel"/>
				<x path="pixelimage.pixel.PixelChannel"/>
				<x path="pixelimage.pixel.PixelChannel"/>
				<x path="pixelimage.pixel.PixelChannel"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>used internally is set colours from algorithms only applies alpha blend
        @see setARGB</haxe_doc>
		</channelBlend>
		<colorBlend public="1" get="inline" set="null" line="222" static="1">
			<f a="this:color:location">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>used internally to set colours from algorithms only applies 
        @see setARGB</haxe_doc>
		</colorBlend>
		<getPixelString public="1" get="inline" set="null" line="231" static="1">
			<f a="this:x:y">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>mainly used for color debugging provides getARGB in hex string format</haxe_doc>
		</getPixelString>
		<simpleRect public="1" get="inline" set="null" line="238" static="1">
			<f a="this:x:y:w:h:color">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>provides a simple filled Rectangle</haxe_doc>
		</simpleRect>
		<clearRect public="1" get="inline" set="null" line="255" static="1"><f a="this:x:y:w:h">
	<c path="pixelimage.ImageStruct"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearRect>
		<flippedX public="1" get="inline" set="null" line="278" static="1">
			<f a="this:x:y:w:h:?transparent:?inPlace:?includeMask" v=":::::false:false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, inPlace : false, transparent : false }</e></m></meta>
			<haxe_doc>creates a new Pixelimage that is flipped horizonally.
        inPlace overwrites current.</haxe_doc>
		</flippedX>
		<flippedY public="1" get="inline" set="null" line="314" static="1">
			<f a="this:x:y:w:h:?transparent:?inPlace:?includeMask" v=":::::false:false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, inPlace : false, transparent : false }</e></m></meta>
			<haxe_doc>creates a new Pixelimage that is flipped vertically.
        inPlace overwrites current.</haxe_doc>
		</flippedY>
		<spunClock90 public="1" get="inline" set="null" line="350" static="1">
			<f a="this:x:y:w:h:?transparent:?includeMask" v=":::::false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, transparent : false }</e></m></meta>
			<haxe_doc>creates a new Pixelimage base on current image, rotated 90° clockwise</haxe_doc>
		</spunClock90>
		<spunAntiClock90 public="1" get="inline" set="null" line="377" static="1">
			<f a="this:x:y:w:h:?transparent:?includeMask" v=":::::false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, transparent : false }</e></m></meta>
		</spunAntiClock90>
		<spun180 public="1" get="inline" set="null" line="404" static="1">
			<f a="this:x:y:w:h:?transparent:?includeMask" v=":::::false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, transparent : false }</e></m></meta>
		</spun180>
		<scaleXY public="1" get="inline" set="null" line="429" static="1">
			<f a="this:sx:sy:?transparent:?includeMask" v=":::false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, transparent : false }</e></m></meta>
		</scaleXY>
		<rotateClockwiseDegrees public="1" get="inline" set="null" line="451" static="1">
			<f a="this:angle:?centreX:?centreY:?transparent:?includeMask" v="::0.:0.:false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, transparent : false, centreY : 0., centreX : 0. }</e></m></meta>
		</rotateClockwiseDegrees>
		<rotateClockwiseRadians public="1" get="inline" set="null" line="469" static="1">
			<f a="this:theta:?centreX:?centreY:?transparent:?includeMask" v="::0.:0.:false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, transparent : false, centreY : 0., centreX : 0. }</e></m></meta>
		</rotateClockwiseRadians>
		<rotate public="1" get="inline" set="null" line="488" static="1">
			<f a="this:theta:?centreX:?centreY:?transparent:?includeMask" v="::0.:0.:false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, transparent : false, centreY : 0., centreX : 0. }</e></m></meta>
		</rotate>
		<scaleUpInt public="1" get="inline" set="null" line="558" static="1">
			<f a="this:?scaleW:?scaleH:?transparent:?includeMask" v=":2:2:false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ includeMask : false, transparent : false, scaleH : 2, scaleW : 2 }</e></m></meta>
		</scaleUpInt>
		<patternRect public="1" get="inline" set="null" line="585" static="1"><f a="this:x:y:w:h:foreColor:backColor:patternFill">
	<c path="pixelimage.ImageStruct"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Bool"/></c>
	<x path="Void"/>
</f></patternRect>
		<patternRectDown public="1" get="inline" set="null" line="615" static="1"><f a="this:x:y:w:h:foreColor:backColor:patternFill">
	<c path="pixelimage.ImageStruct"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Bool"/></c>
	<x path="Void"/>
</f></patternRectDown>
		<fillSquare public="1" get="inline" set="null" line="649" static="1">
			<f a="this:x:y:d:color">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>provides a simple filled square a short cut 
        @see simpleRect</haxe_doc>
		</fillSquare>
		<fillTri public="1" get="inline" set="null" line="662" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:color:?hasHit:?hasUndo" v="::::::::false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
			<haxe_doc>provides a filled triangle give a,b,c coordinates
        automagically rearranges coordinates so it always renders</haxe_doc>
		</fillTri>
		<tileTri public="1" get="inline" set="null" line="670" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:tileImage:?hasHit" v="::::::::false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</tileTri>
		<fillQuad public="1" get="inline" set="null" line="682" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:?hasHit" v="::::::::::false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitQuad"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
			<haxe_doc>uses two triangles to create a filled quad using four coordinates a,b,c,d arranged clockwise</haxe_doc>
		</fillQuad>
		<tileQuad public="1" get="inline" set="null" line="693" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:dx:dy:tileImage:?hasHit" v="::::::::::false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitQuad"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</tileQuad>
		<fillGradTri public="1" get="inline" set="null" line="706" static="1">
			<f a="this:ax:ay:colA:bx:by:colB:cx:cy:colC:?hasHit" v="::::::::::true">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
			<haxe_doc>creates a filled gradient triangle in OpenGL 3 color style for coordinates a,b,c
        with respective colors after coordinate pairs</haxe_doc>
		</fillGradTri>
		<imgTri public="1" get="inline" set="null" line="714" static="1">
			<f a="this:texture:win:ax:ay:au:av:bx:by:bu:bv:cx:cy:cu:cv:?hasHit" v=":::::::::::::::true">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		</imgTri>
		<tileRect public="1" get="inline" set="null" line="721" static="1">
			<f a="this:x:y:wid:hi:tileImage:?hasHit" v="::::::false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitQuad"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</tileRect>
		<fillGradRect public="1" get="inline" set="null" line="732" static="1">
			<f a="this:x:y:wid:hi:colorA:colorB:colorC:colorD">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<a>
					<y><x path="Float"/></y>
					<x><x path="Float"/></x>
					<dy><x path="Float"/></dy>
					<cy><x path="Float"/></cy>
					<cx><x path="Float"/></cx>
					<bx><x path="Float"/></bx>
					<ay><x path="Float"/></ay>
					<ax><x path="Float"/></ax>
				</a>
			</f>
			<haxe_doc>uses two triangles to form rectangle x,y,width,height with a,b,c,d clockwise gradient colours</haxe_doc>
		</fillGradRect>
		<fillGradQuad public="1" get="inline" set="null" line="753" static="1">
			<f a="this:ax:ay:colorA:bx:by:colorB:cx:cy:colorC:dx:dy:colorD:?hasHit" v=":::::::::::::true">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
			<haxe_doc>uses two triangle to form a quad with clockwise coordinates a,b,c,d
        with respective colours after each coordinate pair

        a better render maybe possible see commented out code in algo.QuadPixel and lerp code in algo.GeomPixel
        ( better render approach compiles but does not yet work, maybe easy? ).</haxe_doc>
		</fillGradQuad>
		<imgQuad public="1" get="inline" set="null" line="764" static="1">
			<f a="this:texture:win:ax:ay:bx:by:cx:cy:dx:dy:?hasHit" v=":::::::::::true">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		</imgQuad>
		<imgRect public="1" get="inline" set="null" line="773" static="1">
			<f a="this:texture:win:x:y:wid:hi:?theta:?centreX:?centreY:?skewX:?skewY:?scaleX:?scaleY:?hasHit" v=":::::::0.:0.:0.:0.:0.:1.:1.:true">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, scaleY : 1., scaleX : 1., skewY : 0., skewX : 0., centreY : 0., centreX : 0., theta : 0. }</e></m></meta>
		</imgRect>
		<imgNineSlice public="1" get="inline" set="null" line="849" static="1">
			<f a="this:texture:win:x:y:wid:hi:left:top:fat:tall:widNew:hiNew:leftNew:topNew:fatNew:tallNew:?hasHit" v=":::::::::::::::::false">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</imgNineSlice>
		<fillLine public="1" get="inline" set="null" line="873" static="1">
			<f a="this:px:py:qx:qy:thick:color:?hasHit:?debugCorners" v=":::::::true:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : true }</e></m></meta>
			<haxe_doc>provides a thick line using two triangles vector p, q
        debug corners draws coloured squares on the corners for development</haxe_doc>
		</fillLine>
		<tileLine public="1" get="inline" set="null" line="888" static="1">
			<f a="this:px:py:qx:qy:thick:tileImage:?hasHit:?debugCorners" v=":::::::false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : false }</e></m></meta>
			<haxe_doc>tiles a thick line using two triangles vector p, q
        debug corners draws coloured squares on the corners for development</haxe_doc>
		</tileLine>
		<fillGradLine public="1" get="inline" set="null" line="905" static="1">
			<f a="this:px:py:qx:qy:thick:colorA:colorB:colorC:colorD:?hasHit:?debugCorners" v="::::::::::false:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : false }</e></m></meta>
			<haxe_doc>provides a thick line using two gradient triangle vector p,q
        the four colors are arranged clockwise a,b,c,d
        debug corners draws coloured squares on the corners for development</haxe_doc>
		</fillGradLine>
		<putPixelImage public="1" get="inline" set="null" line="920" static="1">
			<f a="this:pixelImage:x:y:?useAvaliableMask:?forceClear" v="::::true:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceClear : false, useAvaliableMask : true }</e></m></meta>
			<haxe_doc>used to draw one pixelimage on part of another, essentially it is a copy
        black transparent pixels are ignored.
        this is used also internally so that shapes can be composed with transparent false 
        useful for adding over and taking away parts of shapes before drawing on the main Pixelimage.</haxe_doc>
		</putPixelImage>
		<putPixelImageRect public="1" get="inline" set="null" line="939" static="1">
			<f a="this:pixelImage:x:y:rectLeft:rectTop:rectRight:rectBottom:?useAvaliableMask:?forceClear" v="::::::::true:false">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceClear : false, useAvaliableMask : true }</e></m></meta>
		</putPixelImageRect>
		<transferClone public="1" get="inline" set="null" line="1005" static="1">
			<f a="this">
				<c path="pixelimage.ImageStruct"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<haxe_doc>Currently library only supports Javascript target and puts the UInt32Array on the canvas context
        hope to add c++ and some toolkits later.</haxe_doc>
		</transferClone>
		<transferIn public="1" get="inline" set="null" line="1013" static="1"><f a="this:p">
	<c path="pixelimage.ImageStruct"/>
	<x path="pixelimage.Pixelimage"/>
	<x path="Void"/>
</f></transferIn>
		<getBytes public="1" get="inline" set="null" line="1025" static="1"><f a="this">
	<c path="pixelimage.ImageStruct"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<fromBytes public="1" get="inline" set="null" line="1030" static="1"><f a="this:bytes:pos">
	<c path="pixelimage.ImageStruct"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fromBytes>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.PixelimageDoc" params="" file="src/pixelimage/PixelimageDoc.hx">
		<main public="1" set="method" line="8" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<abstract path="pixelimage.Pixelshape" params="" file="src/pixelimage/Pixelshape.hx">
		<this><x path="pixelimage.Pixelimage"/></this>
		<to><icast><x path="pixelimage.Pixelimage"/></icast></to>
		<meta>
			<m n=":transient"/>
			<m n=":forward"/>
		</meta>
		<impl><class path="pixelimage._Pixelshape.Pixelshape_Impl_" params="" file="src/pixelimage/Pixelshape.hx" private="1" module="pixelimage.Pixelshape" final="1">
	<_new public="1" get="inline" set="null" line="37" static="1">
		<f a="w:h">
			<x path="Int"/>
			<x path="Int"/>
			<x path="pixelimage.Pixelshape"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<lineGrid public="1" get="inline" set="null" line="60" static="1"><f a="this:x:y:w:h:delta:thick:color">
	<x path="pixelimage.Pixelimage"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></lineGrid>
	<lineGridWH public="1" get="inline" set="null" line="71" static="1"><f a="this:x:y:w:h:deltaW:deltaH:thick:color">
	<x path="pixelimage.Pixelimage"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></lineGridWH>
	<fillRoundRect public="1" get="inline" set="null" line="102" static="1">
		<f a="this:x:y:hi:wid:color:?dx:?dy:?fat:?tall" v="::::::-1.:-1.:-1.:-1.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
		<haxe_doc>x, y      - position
        hi, wid   - the outside dimensions
        dx, dy    - define the 9-slice distance in from x, y, dy can default to dx
        fat, tall - the inner dimensions of the 9-slice centre, optional</haxe_doc>
	</fillRoundRect>
	<lineRoundRect public="1" get="inline" set="null" line="112" static="1">
		<f a="this:x:y:hi:wid:thick:color:?dx:?dy:?fat:?tall" v=":::::::-1.:-1.:-1.:-1.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
	</lineRoundRect>
	<fillGrad4RoundRect public="1" get="inline" set="null" line="132" static="1">
		<f a="this:x:y:hi:wid:colorA:colorB:colorC:colorD:?dx:?dy:?fat:?tall" v=":::::::::-1.:-1.:-1.:-1.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
		<haxe_doc>x, y      - position
        hi, wid   - the outside dimensions
        dx, dy    - define the 9-slice distance in from x, y, dy can default to dx
        fat, tall - the inner dimensions of the 9-slice centre, optional</haxe_doc>
	</fillGrad4RoundRect>
	<lineGrad4RoundRect public="1" get="inline" set="null" line="142" static="1">
		<f a="this:x:y:hi:wid:thick:colorA:colorB:colorC:colorD:?dx:?dy:?fat:?tall" v="::::::::::-1.:-1.:-1.:-1.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
	</lineGrad4RoundRect>
	<testFillSimonSaysQuadrant public="1" get="inline" set="null" line="152" static="1"><f a="this:cx:cy:radius">
	<x path="pixelimage.Pixelimage"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></testFillSimonSaysQuadrant>
	<fillQuadrantI public="1" get="inline" set="null" line="162" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
	</fillQuadrantI>
	<tileQuadrantI public="1" get="inline" set="null" line="170" static="1">
		<f a="this:cx:cy:rx:ry:tileImage:?phi" v="::::::0.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
	</tileQuadrantI>
	<fillQuadrantII public="1" get="inline" set="null" line="177" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
	</fillQuadrantII>
	<tileQuadrantII public="1" get="inline" set="null" line="184" static="1">
		<f a="this:cx:cy:rx:ry:tileImage:?phi" v="::::::0.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
	</tileQuadrantII>
	<fillQuadrantIII public="1" get="inline" set="null" line="191" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
	</fillQuadrantIII>
	<tileQuadrantIII public="1" get="inline" set="null" line="198" static="1">
		<f a="this:cx:cy:rx:ry:tileImage:?phi" v="::::::0.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
	</tileQuadrantIII>
	<fillQuadrantIV public="1" get="inline" set="null" line="205" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
	</fillQuadrantIV>
	<tileQuadrantIV public="1" get="inline" set="null" line="212" static="1">
		<f a="this:cx:cy:rx:ry:tileImage:?phi" v="::::::0.">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
	</tileQuadrantIV>
	<fillCircle public="1" get="inline" set="null" line="218" static="1">
		<f a="this:cx:cy:r:color:?phi" v=":::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ phi : 0 }</e></m>
			<m n=":access"><e>pixelimage.Pixelimage.fillEllipseTri</e></m>
		</meta>
	</fillCircle>
	<fillEllipse public="1" get="inline" set="null" line="223" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ phi : 0 }</e></m>
			<m n=":access"><e>pixelimage.Pixelimage.fillEllipseTri</e></m>
		</meta>
	</fillEllipse>
	<fillArrowHead public="1" get="inline" set="null" line="227" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillArrowHead>
	<fillPentagon public="1" get="inline" set="null" line="231" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillPentagon>
	<fillHexagon public="1" get="inline" set="null" line="235" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillHexagon>
	<fillHeptagon public="1" get="inline" set="null" line="239" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillHeptagon>
	<fillSeptagon public="1" get="inline" set="null" line="243" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillSeptagon>
	<fillOctagon public="1" get="inline" set="null" line="247" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillOctagon>
	<fillNonagon public="1" get="inline" set="null" line="251" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillNonagon>
	<fillEnneagon public="1" get="inline" set="null" line="255" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillEnneagon>
	<fillDecagon public="1" get="inline" set="null" line="259" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillDecagon>
	<fillHendecagon public="1" get="inline" set="null" line="263" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillHendecagon>
	<fillUndecagon public="1" get="inline" set="null" line="267" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillUndecagon>
	<fillDodecagon public="1" get="inline" set="null" line="271" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
	</fillDodecagon>
	<softFillQuint public="1" get="inline" set="null" line="282" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:softC:?hasHit" v=":::::::::::false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitQuad"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
	</softFillQuint>
	<fillSoftQuad public="1" get="inline" set="null" line="298" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitQuad"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
	</fillSoftQuad>
	<fillSoftQuadFudge public="1" get="inline" set="null" line="314" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitQuad"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
	</fillSoftQuadFudge>
	<fillSoftQuadQuarter public="1" get="inline" set="null" line="328" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitQuad"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
	</fillSoftQuadQuarter>
	<fillSoftLine public="1" get="inline" set="null" line="339" static="1">
		<f a="this:px:py:qx:qy:thick:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit:?debugCorners" v=":::::::40:true:true:true:true:true:false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ debugCorners : false, hasHit : true, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
	</fillSoftLine>
	<fillSoftLineLuxury public="1" get="inline" set="null" line="354" static="1">
		<f a="this:px:py:qx:qy:thick:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit:?debugCorners" v=":::::::40:true:true:true:true:true:false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ debugCorners : false, hasHit : true, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
	</fillSoftLineLuxury>
	<softFillTriangle public="1" get="inline" set="null" line="370" static="1">
		<f a="this:ax:ay:bx:by:cx:cy:color:soft3:?softAB:?softBC:?softCA:?hasHit" v=":::::::::true:true:true:false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitTri"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false, softCA : true, softBC : true, softAB : true }</e></m></meta>
	</softFillTriangle>
	<sweepTri public="1" get="inline" set="null" line="383" static="1">
		<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:color:?hasHit" v="::::::::false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
	</sweepTri>
	<tileSweepTri public="1" get="inline" set="null" line="398" static="1">
		<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:tileImage:?hasHit" v="::::::::false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Bool"/>
			<c path="pixelimage.algo.HitTri"/>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
	</tileSweepTri>
	<fillPie public="1" get="inline" set="null" line="414" static="1">
		<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:color:?hasHit:?targetError" v="::::::::false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, hasHit : false }</e></m></meta>
	</fillPie>
	<tilePie public="1" get="inline" set="null" line="455" static="1">
		<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:tileImage:?hasHit:?targetError" v="::::::::false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, hasHit : false }</e></m></meta>
	</tilePie>
	<sweepGradTri public="1" get="inline" set="null" line="494" static="1">
		<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:colA:colB:colC:?hasHit" v="::::::::::false">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
	</sweepGradTri>
	<fillRadialPie public="1" get="inline" set="null" line="509" static="1">
		<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:centreColor:outerColor:?hasHit:?targetError" v=":::::::::false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, hasHit : false }</e></m></meta>
	</fillRadialPie>
	<imgQuadFudge public="1" get="inline" set="null" line="552" static="1">
		<f a="this:texture:win:ax:ay:bx:by:cx:cy:dx:dy:?hasHit" v=":::::::::::true">
			<x path="pixelimage.Pixelimage"/>
			<x path="pixelimage.Pixelimage"/>
			<c path="pixelimage.algo.RectangleWindow"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		<haxe_doc>works with image Fudge of UV values, deprediated unless turns out useful in edge cases.</haxe_doc>
	</imgQuadFudge>
	<imgRectFudge public="1" get="inline" set="null" line="560" static="1">
		<f a="this:texture:win:x:y:wid:hi:?theta:?centreX:?centreY:?skewX:?skewY:?hasHit" v=":::::::0.:0.:0.:0.:0.:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="pixelimage.Pixelimage"/>
			<c path="pixelimage.algo.RectangleWindow"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, skewY : 0., skewX : 0., centreY : 0., centreX : 0., theta : 0. }</e></m></meta>
	</imgRectFudge>
	<fillArrow public="1" get="inline" set="null" line="619" static="1">
		<f a="this:px:py:qx:qy:thick:color:?flare:?reverseFlare:?hasHit" v=":::::::false:false:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, reverseFlare : false, flare : false }</e></m></meta>
		<haxe_doc>provides a thick arrow using two triangles vector p, q</haxe_doc>
	</fillArrow>
	<fillArrowBoth public="1" get="inline" set="null" line="625" static="1">
		<f a="this:px:py:qx:qy:thick:color:?hasHit" v=":::::::true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
	</fillArrowBoth>
	<fillFixArrow public="1" get="inline" set="null" line="630" static="1">
		<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?flare:?reverseFlare:?hasHit" v=":::::::::false:false:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, reverseFlare : false, flare : false }</e></m></meta>
	</fillFixArrow>
	<fillFixArrowBoth public="1" get="inline" set="null" line="636" static="1">
		<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?hasHit" v=":::::::::true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
	</fillFixArrowBoth>
	<fillSoftArrow public="1" get="inline" set="null" line="642" static="1">
		<f a="this:px:py:qx:qy:thick:color:?flare:?reverseFlare:?soft:?hasHit" v=":::::::false:false:40.:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, soft : 40., reverseFlare : false, flare : false }</e></m></meta>
	</fillSoftArrow>
	<fillSoftArrowBoth public="1" get="inline" set="null" line="647" static="1">
		<f a="this:px:py:qx:qy:thick:color:?soft:?hasHit" v=":::::::40.:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, soft : 40. }</e></m></meta>
	</fillSoftArrowBoth>
	<fillSoftFixArrow public="1" get="inline" set="null" line="652" static="1">
		<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?flare:?reverseFlare:?soft:?hasHit" v=":::::::::false:false:40.:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, soft : 40., reverseFlare : false, flare : false }</e></m></meta>
	</fillSoftFixArrow>
	<fillSoftFixArrowBoth public="1" get="inline" set="null" line="657" static="1">
		<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?soft:?hasHit" v=":::::::::40.:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, soft : 40. }</e></m></meta>
	</fillSoftFixArrowBoth>
	<gradThickArrow public="1" get="inline" set="null" line="664" static="1">
		<f a="this:px:py:qx:qy:thick:color1:color2:?flare:reverseFlare:?hasHit" v="::::::::false::true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, flare : false }</e></m></meta>
	</gradThickArrow>
	<gradThickArrowBoth public="1" get="inline" set="null" line="669" static="1">
		<f a="this:px:py:qx:qy:thick:color1:color2:?hasHit" v="::::::::true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
	</gradThickArrowBoth>
	<gradThickFixArrow public="1" get="inline" set="null" line="674" static="1">
		<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color1:color2:?flare:?reverseFlare:?hasHit" v="::::::::::false:false:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true, reverseFlare : false, flare : false }</e></m></meta>
	</gradThickFixArrow>
	<gradThickFixArrowBoth public="1" get="inline" set="null" line="679" static="1">
		<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color1:color2:?hasHit" v="::::::::::true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
		</f>
		<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
	</gradThickFixArrowBoth>
	<fillEllipseTri public="1" get="inline" set="null" line="690" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi:?printSides:?targetError" v="::::::0:false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0 }</e></m></meta>
		<haxe_doc>this is used for drawing a filled ellipse or circle ( using triangles ), it uses more sides when larger and can be tweaked with targetError
        drawn from the circles/ellipses centre, with rx and ry the radius, phi allows rotatation of ellipses
        setup so large ellipses automatically use more sides.</haxe_doc>
	</fillEllipseTri>
	<softFillEllipseTri public="1" get="inline" set="null" line="699" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi:?softC:?printSides:?targetError" v="::::::0:10:false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, softC : 10, phi : 0 }</e></m></meta>
	</softFillEllipseTri>
	<tileEllipseTri public="1" get="inline" set="null" line="708" static="1">
		<f a="this:cx:cy:rx:ry:tileImage:?phi:?printSides:?targetError" v="::::::0:false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0 }</e></m></meta>
	</tileEllipseTri>
	<lineEllipseTri public="1" get="inline" set="null" line="726" static="1">
		<f a="this:cx:cy:rx:ry:drx:dry:color:?phi:?printSides:?targetError" v="::::::::0:false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0 }</e></m></meta>
		<haxe_doc>this is provides a thick outline ellipse or circle ( using triangles ), large ones have more sides.
        @:see fillEllipseTri
        it uses a temp pixelimage with transparent false,
        and a second ellipse to remove the centre before copying over pixels
        setup so large ellipses automatically use more sides.
        for phi rotated ellipses it over estimates the temp pixelimage to be safe</haxe_doc>
	</lineEllipseTri>
	<fillRadialEllipseTri public="1" get="inline" set="null" line="765" static="1">
		<f a="this:cx:cy:rx:ry:colorIn:colorOut:?gx:?gy:?phi:?printSides:?targetError" v=":::::::0.:0.:0:false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0, gy : 0., gx : 0. }</e></m></meta>
		<haxe_doc>provides a filled ellipse/circle using triangles and more sides for large with a radial color gradient from the centre 
        colorIn is the internal colour and colorOut the external one, gx and gy -1 to 1 provide offset centre
        there are lots of limitations, gx and gy max and min obviously look bad and may need to scale them to 0.7 for rotated ellipse</haxe_doc>
	</fillRadialEllipseTri>
	<lineRadialEllipseTri public="1" get="inline" set="null" line="781" static="1">
		<f a="this:cx:cy:rx:ry:drx:dry:colorIn:colorOut:?gx:?gy:?phi:?printSides:?targetError" v=":::::::::0.:0.:0:false:1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0, gy : 0., gx : 0. }</e></m></meta>
		<haxe_doc>radial ellipse thick line 
        @see fillRadialEllipseTri</haxe_doc>
	</lineRadialEllipseTri>
	<fillRadialRectangle public="1" get="inline" set="null" line="820" static="1">
		<f a="this:x:y:wid:hi:colorIn:colorOut:?gx:?gy" v=":::::::0:0">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ gy : 0, gx : 0 }</e></m></meta>
		<haxe_doc>provides a radial colour gradient, it uses a temp pixelimage to draw a rectangle and then radial ellipse within.
        @:see fillRadialEllipseTri</haxe_doc>
	</fillRadialRectangle>
	<fillQuadrant public="1" get="inline" set="null" line="839" static="1">
		<f a="this:cx:cy:rx:ry:startAngle:color:?phi:?targetError" v="::::::::1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05 }</e></m></meta>
		<haxe_doc>fill Quadrant draws a quarter arc, for rounded rectangle there are I,II,III,IV defined ones in Pixelshape</haxe_doc>
	</fillQuadrant>
	<tileQuadrant public="1" get="inline" set="null" line="849" static="1">
		<f a="this:cx:cy:rx:ry:startAngle:tileImage:?phi:?targetError" v="::::::::1.05">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ targetError : 1.05 }</e></m></meta>
		<haxe_doc>tiles Quadrant draws a quarter arc, for rounded rectangle there are I,II,III,IV defined ones in Pixelshape</haxe_doc>
	</tileQuadrant>
	<fillPolyBuild public="1" get="inline" set="null" line="864" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi:?sides:?cornerUp" v="::::::0.:36:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0. }</e></m></meta>
		<haxe_doc>this provides building block for regular polygons,ellipses and circles
        cornerUp false will have polygon with flat edge on the top
        defined from centre cx,cy the radius allow stretching the regualar and phi controls rotation
        sides defines the sides required
        would be nice to add skew in future?
        cornerUp may need debugging</haxe_doc>
	</fillPolyBuild>
	<softFillPolyBuild public="1" get="inline" set="null" line="871" static="1">
		<f a="this:cx:cy:rx:ry:color:?phi:?sides:?softC:?cornerUp" v="::::::0.:36:10.:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ cornerUp : true, softC : 10., sides : 36, phi : 0. }</e></m></meta>
	</softFillPolyBuild>
	<tilePolyBuild public="1" get="inline" set="null" line="886" static="1">
		<f a="this:cx:cy:rx:ry:tileImage:?phi:?sides:?cornerUp" v="::::::0.:36:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0. }</e></m></meta>
		<haxe_doc>this provides building block for image tiled regular polygons,ellipses and circles
        cornerUp false will have polygon with flat edge on the top
        defined from centre cx,cy the radius allow stretching the regualar and phi controls rotation
        sides defines the sides required
        would be nice to add skew in future?
        cornerUp may need debugging</haxe_doc>
	</tilePolyBuild>
	<fillRadialPolyon public="1" get="inline" set="null" line="899" static="1">
		<f a="this:cx:cy:rx:ry:colorIn:colorOut:?gx:?gy:?phi:?sides:?cornerUp" v=":::::::0.:0.:0.:36:true">
			<x path="pixelimage.Pixelimage"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0., gy : 0., gx : 0. }</e></m></meta>
		<haxe_doc>@see fillPolyBuild
        this is a version with radial gradient applied so the centre is one color, but only used gradient triangles so limited</haxe_doc>
	</fillRadialPolyon>
</class></impl>
	</abstract>
	<class path="pixelimage._Pixelshape.Pixelshape_Impl_" params="" file="src/pixelimage/Pixelshape.hx" private="1" module="pixelimage.Pixelshape" final="1">
		<_new public="1" get="inline" set="null" line="37" static="1">
			<f a="w:h">
				<x path="Int"/>
				<x path="Int"/>
				<x path="pixelimage.Pixelshape"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<lineGrid public="1" get="inline" set="null" line="60" static="1"><f a="this:x:y:w:h:delta:thick:color">
	<x path="pixelimage.Pixelimage"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></lineGrid>
		<lineGridWH public="1" get="inline" set="null" line="71" static="1"><f a="this:x:y:w:h:deltaW:deltaH:thick:color">
	<x path="pixelimage.Pixelimage"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></lineGridWH>
		<fillRoundRect public="1" get="inline" set="null" line="102" static="1">
			<f a="this:x:y:hi:wid:color:?dx:?dy:?fat:?tall" v="::::::-1.:-1.:-1.:-1.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
			<haxe_doc>x, y      - position
        hi, wid   - the outside dimensions
        dx, dy    - define the 9-slice distance in from x, y, dy can default to dx
        fat, tall - the inner dimensions of the 9-slice centre, optional</haxe_doc>
		</fillRoundRect>
		<lineRoundRect public="1" get="inline" set="null" line="112" static="1">
			<f a="this:x:y:hi:wid:thick:color:?dx:?dy:?fat:?tall" v=":::::::-1.:-1.:-1.:-1.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
		</lineRoundRect>
		<fillGrad4RoundRect public="1" get="inline" set="null" line="132" static="1">
			<f a="this:x:y:hi:wid:colorA:colorB:colorC:colorD:?dx:?dy:?fat:?tall" v=":::::::::-1.:-1.:-1.:-1.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
			<haxe_doc>x, y      - position
        hi, wid   - the outside dimensions
        dx, dy    - define the 9-slice distance in from x, y, dy can default to dx
        fat, tall - the inner dimensions of the 9-slice centre, optional</haxe_doc>
		</fillGrad4RoundRect>
		<lineGrad4RoundRect public="1" get="inline" set="null" line="142" static="1">
			<f a="this:x:y:hi:wid:thick:colorA:colorB:colorC:colorD:?dx:?dy:?fat:?tall" v="::::::::::-1.:-1.:-1.:-1.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
		</lineGrad4RoundRect>
		<testFillSimonSaysQuadrant public="1" get="inline" set="null" line="152" static="1"><f a="this:cx:cy:radius">
	<x path="pixelimage.Pixelimage"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></testFillSimonSaysQuadrant>
		<fillQuadrantI public="1" get="inline" set="null" line="162" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</fillQuadrantI>
		<tileQuadrantI public="1" get="inline" set="null" line="170" static="1">
			<f a="this:cx:cy:rx:ry:tileImage:?phi" v="::::::0.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</tileQuadrantI>
		<fillQuadrantII public="1" get="inline" set="null" line="177" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</fillQuadrantII>
		<tileQuadrantII public="1" get="inline" set="null" line="184" static="1">
			<f a="this:cx:cy:rx:ry:tileImage:?phi" v="::::::0.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</tileQuadrantII>
		<fillQuadrantIII public="1" get="inline" set="null" line="191" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</fillQuadrantIII>
		<tileQuadrantIII public="1" get="inline" set="null" line="198" static="1">
			<f a="this:cx:cy:rx:ry:tileImage:?phi" v="::::::0.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</tileQuadrantIII>
		<fillQuadrantIV public="1" get="inline" set="null" line="205" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</fillQuadrantIV>
		<tileQuadrantIV public="1" get="inline" set="null" line="212" static="1">
			<f a="this:cx:cy:rx:ry:tileImage:?phi" v="::::::0.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</tileQuadrantIV>
		<fillCircle public="1" get="inline" set="null" line="218" static="1">
			<f a="this:cx:cy:r:color:?phi" v=":::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ phi : 0 }</e></m>
				<m n=":access"><e>pixelimage.Pixelimage.fillEllipseTri</e></m>
			</meta>
		</fillCircle>
		<fillEllipse public="1" get="inline" set="null" line="223" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ phi : 0 }</e></m>
				<m n=":access"><e>pixelimage.Pixelimage.fillEllipseTri</e></m>
			</meta>
		</fillEllipse>
		<fillArrowHead public="1" get="inline" set="null" line="227" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillArrowHead>
		<fillPentagon public="1" get="inline" set="null" line="231" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillPentagon>
		<fillHexagon public="1" get="inline" set="null" line="235" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillHexagon>
		<fillHeptagon public="1" get="inline" set="null" line="239" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillHeptagon>
		<fillSeptagon public="1" get="inline" set="null" line="243" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillSeptagon>
		<fillOctagon public="1" get="inline" set="null" line="247" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillOctagon>
		<fillNonagon public="1" get="inline" set="null" line="251" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillNonagon>
		<fillEnneagon public="1" get="inline" set="null" line="255" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillEnneagon>
		<fillDecagon public="1" get="inline" set="null" line="259" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillDecagon>
		<fillHendecagon public="1" get="inline" set="null" line="263" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillHendecagon>
		<fillUndecagon public="1" get="inline" set="null" line="267" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillUndecagon>
		<fillDodecagon public="1" get="inline" set="null" line="271" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi" v="::::::0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0 }</e></m></meta>
		</fillDodecagon>
		<softFillQuint public="1" get="inline" set="null" line="282" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:softC:?hasHit" v=":::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitQuad"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</softFillQuint>
		<fillSoftQuad public="1" get="inline" set="null" line="298" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitQuad"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
		</fillSoftQuad>
		<fillSoftQuadFudge public="1" get="inline" set="null" line="314" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitQuad"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
		</fillSoftQuadFudge>
		<fillSoftQuadQuarter public="1" get="inline" set="null" line="328" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitQuad"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
		</fillSoftQuadQuarter>
		<fillSoftLine public="1" get="inline" set="null" line="339" static="1">
			<f a="this:px:py:qx:qy:thick:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit:?debugCorners" v=":::::::40:true:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : true, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
		</fillSoftLine>
		<fillSoftLineLuxury public="1" get="inline" set="null" line="354" static="1">
			<f a="this:px:py:qx:qy:thick:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit:?debugCorners" v=":::::::40:true:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : true, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
		</fillSoftLineLuxury>
		<softFillTriangle public="1" get="inline" set="null" line="370" static="1">
			<f a="this:ax:ay:bx:by:cx:cy:color:soft3:?softAB:?softBC:?softCA:?hasHit" v=":::::::::true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitTri"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softCA : true, softBC : true, softAB : true }</e></m></meta>
		</softFillTriangle>
		<sweepTri public="1" get="inline" set="null" line="383" static="1">
			<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:color:?hasHit" v="::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</sweepTri>
		<tileSweepTri public="1" get="inline" set="null" line="398" static="1">
			<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:tileImage:?hasHit" v="::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<c path="pixelimage.algo.HitTri"/>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</tileSweepTri>
		<fillPie public="1" get="inline" set="null" line="414" static="1">
			<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:color:?hasHit:?targetError" v="::::::::false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, hasHit : false }</e></m></meta>
		</fillPie>
		<tilePie public="1" get="inline" set="null" line="455" static="1">
			<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:tileImage:?hasHit:?targetError" v="::::::::false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, hasHit : false }</e></m></meta>
		</tilePie>
		<sweepGradTri public="1" get="inline" set="null" line="494" static="1">
			<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:colA:colB:colC:?hasHit" v="::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</sweepGradTri>
		<fillRadialPie public="1" get="inline" set="null" line="509" static="1">
			<f a="this:ax:ay:rx:ry:startRadian:sweepRadian:centreColor:outerColor:?hasHit:?targetError" v=":::::::::false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, hasHit : false }</e></m></meta>
		</fillRadialPie>
		<imgQuadFudge public="1" get="inline" set="null" line="552" static="1">
			<f a="this:texture:win:ax:ay:bx:by:cx:cy:dx:dy:?hasHit" v=":::::::::::true">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
			<haxe_doc>works with image Fudge of UV values, deprediated unless turns out useful in edge cases.</haxe_doc>
		</imgQuadFudge>
		<imgRectFudge public="1" get="inline" set="null" line="560" static="1">
			<f a="this:texture:win:x:y:wid:hi:?theta:?centreX:?centreY:?skewX:?skewY:?hasHit" v=":::::::0.:0.:0.:0.:0.:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, skewY : 0., skewX : 0., centreY : 0., centreX : 0., theta : 0. }</e></m></meta>
		</imgRectFudge>
		<fillArrow public="1" get="inline" set="null" line="619" static="1">
			<f a="this:px:py:qx:qy:thick:color:?flare:?reverseFlare:?hasHit" v=":::::::false:false:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, reverseFlare : false, flare : false }</e></m></meta>
			<haxe_doc>provides a thick arrow using two triangles vector p, q</haxe_doc>
		</fillArrow>
		<fillArrowBoth public="1" get="inline" set="null" line="625" static="1">
			<f a="this:px:py:qx:qy:thick:color:?hasHit" v=":::::::true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		</fillArrowBoth>
		<fillFixArrow public="1" get="inline" set="null" line="630" static="1">
			<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?flare:?reverseFlare:?hasHit" v=":::::::::false:false:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, reverseFlare : false, flare : false }</e></m></meta>
		</fillFixArrow>
		<fillFixArrowBoth public="1" get="inline" set="null" line="636" static="1">
			<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?hasHit" v=":::::::::true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		</fillFixArrowBoth>
		<fillSoftArrow public="1" get="inline" set="null" line="642" static="1">
			<f a="this:px:py:qx:qy:thick:color:?flare:?reverseFlare:?soft:?hasHit" v=":::::::false:false:40.:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, soft : 40., reverseFlare : false, flare : false }</e></m></meta>
		</fillSoftArrow>
		<fillSoftArrowBoth public="1" get="inline" set="null" line="647" static="1">
			<f a="this:px:py:qx:qy:thick:color:?soft:?hasHit" v=":::::::40.:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, soft : 40. }</e></m></meta>
		</fillSoftArrowBoth>
		<fillSoftFixArrow public="1" get="inline" set="null" line="652" static="1">
			<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?flare:?reverseFlare:?soft:?hasHit" v=":::::::::false:false:40.:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, soft : 40., reverseFlare : false, flare : false }</e></m></meta>
		</fillSoftFixArrow>
		<fillSoftFixArrowBoth public="1" get="inline" set="null" line="657" static="1">
			<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?soft:?hasHit" v=":::::::::40.:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, soft : 40. }</e></m></meta>
		</fillSoftFixArrowBoth>
		<gradThickArrow public="1" get="inline" set="null" line="664" static="1">
			<f a="this:px:py:qx:qy:thick:color1:color2:?flare:reverseFlare:?hasHit" v="::::::::false::true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, flare : false }</e></m></meta>
		</gradThickArrow>
		<gradThickArrowBoth public="1" get="inline" set="null" line="669" static="1">
			<f a="this:px:py:qx:qy:thick:color1:color2:?hasHit" v="::::::::true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		</gradThickArrowBoth>
		<gradThickFixArrow public="1" get="inline" set="null" line="674" static="1">
			<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color1:color2:?flare:?reverseFlare:?hasHit" v="::::::::::false:false:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true, reverseFlare : false, flare : false }</e></m></meta>
		</gradThickFixArrow>
		<gradThickFixArrowBoth public="1" get="inline" set="null" line="679" static="1">
			<f a="this:px:py:qx:qy:arrowWidth:arrowHeight:thick:color1:color2:?hasHit" v="::::::::::true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : true }</e></m></meta>
		</gradThickFixArrowBoth>
		<fillEllipseTri public="1" get="inline" set="null" line="690" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi:?printSides:?targetError" v="::::::0:false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0 }</e></m></meta>
			<haxe_doc>this is used for drawing a filled ellipse or circle ( using triangles ), it uses more sides when larger and can be tweaked with targetError
        drawn from the circles/ellipses centre, with rx and ry the radius, phi allows rotatation of ellipses
        setup so large ellipses automatically use more sides.</haxe_doc>
		</fillEllipseTri>
		<softFillEllipseTri public="1" get="inline" set="null" line="699" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi:?softC:?printSides:?targetError" v="::::::0:10:false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, softC : 10, phi : 0 }</e></m></meta>
		</softFillEllipseTri>
		<tileEllipseTri public="1" get="inline" set="null" line="708" static="1">
			<f a="this:cx:cy:rx:ry:tileImage:?phi:?printSides:?targetError" v="::::::0:false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0 }</e></m></meta>
		</tileEllipseTri>
		<lineEllipseTri public="1" get="inline" set="null" line="726" static="1">
			<f a="this:cx:cy:rx:ry:drx:dry:color:?phi:?printSides:?targetError" v="::::::::0:false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0 }</e></m></meta>
			<haxe_doc>this is provides a thick outline ellipse or circle ( using triangles ), large ones have more sides.
        @:see fillEllipseTri
        it uses a temp pixelimage with transparent false,
        and a second ellipse to remove the centre before copying over pixels
        setup so large ellipses automatically use more sides.
        for phi rotated ellipses it over estimates the temp pixelimage to be safe</haxe_doc>
		</lineEllipseTri>
		<fillRadialEllipseTri public="1" get="inline" set="null" line="765" static="1">
			<f a="this:cx:cy:rx:ry:colorIn:colorOut:?gx:?gy:?phi:?printSides:?targetError" v=":::::::0.:0.:0:false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0, gy : 0., gx : 0. }</e></m></meta>
			<haxe_doc>provides a filled ellipse/circle using triangles and more sides for large with a radial color gradient from the centre 
        colorIn is the internal colour and colorOut the external one, gx and gy -1 to 1 provide offset centre
        there are lots of limitations, gx and gy max and min obviously look bad and may need to scale them to 0.7 for rotated ellipse</haxe_doc>
		</fillRadialEllipseTri>
		<lineRadialEllipseTri public="1" get="inline" set="null" line="781" static="1">
			<f a="this:cx:cy:rx:ry:drx:dry:colorIn:colorOut:?gx:?gy:?phi:?printSides:?targetError" v=":::::::::0.:0.:0:false:1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05, printSides : false, phi : 0, gy : 0., gx : 0. }</e></m></meta>
			<haxe_doc>radial ellipse thick line 
        @see fillRadialEllipseTri</haxe_doc>
		</lineRadialEllipseTri>
		<fillRadialRectangle public="1" get="inline" set="null" line="820" static="1">
			<f a="this:x:y:wid:hi:colorIn:colorOut:?gx:?gy" v=":::::::0:0">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ gy : 0, gx : 0 }</e></m></meta>
			<haxe_doc>provides a radial colour gradient, it uses a temp pixelimage to draw a rectangle and then radial ellipse within.
        @:see fillRadialEllipseTri</haxe_doc>
		</fillRadialRectangle>
		<fillQuadrant public="1" get="inline" set="null" line="839" static="1">
			<f a="this:cx:cy:rx:ry:startAngle:color:?phi:?targetError" v="::::::::1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05 }</e></m></meta>
			<haxe_doc>fill Quadrant draws a quarter arc, for rounded rectangle there are I,II,III,IV defined ones in Pixelshape</haxe_doc>
		</fillQuadrant>
		<tileQuadrant public="1" get="inline" set="null" line="849" static="1">
			<f a="this:cx:cy:rx:ry:startAngle:tileImage:?phi:?targetError" v="::::::::1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05 }</e></m></meta>
			<haxe_doc>tiles Quadrant draws a quarter arc, for rounded rectangle there are I,II,III,IV defined ones in Pixelshape</haxe_doc>
		</tileQuadrant>
		<fillPolyBuild public="1" get="inline" set="null" line="864" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi:?sides:?cornerUp" v="::::::0.:36:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0. }</e></m></meta>
			<haxe_doc>this provides building block for regular polygons,ellipses and circles
        cornerUp false will have polygon with flat edge on the top
        defined from centre cx,cy the radius allow stretching the regualar and phi controls rotation
        sides defines the sides required
        would be nice to add skew in future?
        cornerUp may need debugging</haxe_doc>
		</fillPolyBuild>
		<softFillPolyBuild public="1" get="inline" set="null" line="871" static="1">
			<f a="this:cx:cy:rx:ry:color:?phi:?sides:?softC:?cornerUp" v="::::::0.:36:10.:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerUp : true, softC : 10., sides : 36, phi : 0. }</e></m></meta>
		</softFillPolyBuild>
		<tilePolyBuild public="1" get="inline" set="null" line="886" static="1">
			<f a="this:cx:cy:rx:ry:tileImage:?phi:?sides:?cornerUp" v="::::::0.:36:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0. }</e></m></meta>
			<haxe_doc>this provides building block for image tiled regular polygons,ellipses and circles
        cornerUp false will have polygon with flat edge on the top
        defined from centre cx,cy the radius allow stretching the regualar and phi controls rotation
        sides defines the sides required
        would be nice to add skew in future?
        cornerUp may need debugging</haxe_doc>
		</tilePolyBuild>
		<fillRadialPolyon public="1" get="inline" set="null" line="899" static="1">
			<f a="this:cx:cy:rx:ry:colorIn:colorOut:?gx:?gy:?phi:?sides:?cornerUp" v=":::::::0.:0.:0.:36:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0., gy : 0., gx : 0. }</e></m></meta>
			<haxe_doc>@see fillPolyBuild
        this is a version with radial gradient applied so the centre is one color, but only used gradient triangles so limited</haxe_doc>
		</fillRadialPolyon>
	</class>
	<class path="pixelimage.algo._ArrowPixel.ArrowPixel_Fields_" params="" file="src/pixelimage/algo/ArrowPixel.hx" private="1" module="pixelimage.algo.ArrowPixel" final="1">
		<fillLineArrow public="1" get="inline" set="null" line="13" static="1">
			<f a="pixelImage:px:py:qx:qy:thick:color:?flare:?reverseFlare:?hasHit" v=":::::::false:false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, reverseFlare : false, flare : false }</e></m></meta>
		</fillLineArrow>
		<fillSoftLineArrow public="1" get="inline" set="null" line="64" static="1">
			<f a="pixelImage:px:py:qx:qy:thick:color:?flare:?reverseFlare:?soft:?hasHit" v=":::::::false:false:40.:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, soft : 40., reverseFlare : false, flare : false }</e></m></meta>
		</fillSoftLineArrow>
		<gradThickLineArrow public="1" get="inline" set="null" line="119" static="1">
			<f a="pixelImage:px:py:qx:qy:thick:color1:color2:?flare:?reverseFlare:?hasHit" v="::::::::false:false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, reverseFlare : false, flare : false }</e></m></meta>
		</gradThickLineArrow>
		<fillLineArrowBoth public="1" get="inline" set="null" line="169" static="1">
			<f a="pixelImage:px:py:qx:qy:thick:color:?hasHit" v=":::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</fillLineArrowBoth>
		<fillSoftLineArrowBoth public="1" get="inline" set="null" line="235" static="1">
			<f a="pixelImage:px:py:qx:qy:thick:color:?soft:?hasHit" v=":::::::40.:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, soft : 40. }</e></m></meta>
		</fillSoftLineArrowBoth>
		<gradThickLineArrowBoth public="1" get="inline" set="null" line="301" static="1">
			<f a="pixelImage:px:py:qx:qy:thick:color1:color2:?hasHit" v="::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</gradThickLineArrowBoth>
		<fillLineFixedArrow public="1" get="inline" set="null" line="371" static="1">
			<f a="pixelImage:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?flare:?reverseFlare:?hasHit" v=":::::::::false:false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, reverseFlare : false, flare : false }</e></m></meta>
		</fillLineFixedArrow>
		<fillSoftLineFixedArrow public="1" get="inline" set="null" line="433" static="1">
			<f a="pixelImage:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?flare:?reverseFlare:?soft:?hasHit" v=":::::::::false:false:40.:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, soft : 40., reverseFlare : false, flare : false }</e></m></meta>
		</fillSoftLineFixedArrow>
		<gradThickLineFixedArrow public="1" get="inline" set="null" line="490" static="1">
			<f a="pixelImage:px:py:qx:qy:arrowWidth:arrowHeight:thick:color1:color2:?flare:?reverseFlare:?hasHit" v="::::::::::false:false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, reverseFlare : false, flare : false }</e></m></meta>
		</gradThickLineFixedArrow>
		<fillLineFixedArrowBoth public="1" get="inline" set="null" line="550" static="1">
			<f a="pixelImage:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?hasHit" v=":::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</fillLineFixedArrowBoth>
		<fillSoftLineFixedArrowBoth public="1" get="inline" set="null" line="627" static="1">
			<f a="pixelImage:px:py:qx:qy:arrowWidth:arrowHeight:thick:color:?soft:?hasHit" v=":::::::::40.:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, soft : 40. }</e></m></meta>
		</fillSoftLineFixedArrowBoth>
		<gradThickLineFixedArrowBoth public="1" get="inline" set="null" line="702" static="1">
			<f a="pixelImage:px:py:qx:qy:arrowWidth:arrowHeight:thick:color1:color2:?hasHit" v="::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTriArray"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</gradThickLineFixedArrowBoth>
	</class>
	<class path="pixelimage.algo.CirclePixel" params="" file="src/pixelimage/algo/CirclePixel.hx">
		<_circleError public="1" expr="circleError">
			<f a="radius:?targetE:?minN:?maxN">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>circleError</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">circleError</font> module level field
       @param targetE defaults 1.05 adjust to change the quality of the circle
       @param minN defaults 12, minimum sides used
       @param maxN defaults 500, maximum sides used]]></haxe_doc>
		</_circleError>
		<_getSidesDivisible4 public="1" expr="getSidesDivisible4">
			<f a="rx:ry:targetError">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>getSidesDivisible4</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">getSidesDivisible4</font> module level field
       @param targetE defaults 1.05 adjust to change the quality of the circle
       @return uses min dimension for target diameter returns nearest divisble by 4]]></haxe_doc>
		</_getSidesDivisible4>
		<new public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.algo._CirclePixel.CirclePixel_Fields_" params="" file="src/pixelimage/algo/CirclePixel.hx" private="1" module="pixelimage.algo.CirclePixel" final="1">
		<circleError public="1" get="inline" set="null" line="7" static="1">
			<f a="radius:?targetE:?minN:?maxN" v=":1.05:12:500">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ maxN : 500, minN : 12, targetE : 1.05 }</e></m></meta>
		</circleError>
		<getSidesDivisible4 public="1" get="inline" set="null" line="18" static="1">
			<f a="rx:ry:?targetError" v="::1.05">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05 }</e></m></meta>
		</getSidesDivisible4>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.algo.RectangleWindow" params="" file="src/pixelimage/algo/GeomPix.hx" module="pixelimage.algo.GeomPix">
		<minMax public="1" get="inline" set="null" line="21" static="1"><f a="x:y:maxX:maxY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="pixelimage.algo.RectangleWindow"/>
</f></minMax>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<new public="1" get="inline" set="null" line="14"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.algo.GeomPix" params="" file="src/pixelimage/algo/GeomPix.hx">
		<_smootherStep public="1" expr="smootherStep">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>smootherStep</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">smoothStep</font> module level field]]></haxe_doc>
		</_smootherStep>
		<_lerp public="1" expr="lerp">
			<f a="a:b:t">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>lerp</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">lerp</font> module level field]]></haxe_doc>
		</_lerp>
		<_lerp4Colors public="1" expr="lerp4Colors">
			<f a="colorhiA:colorhiB:colorloC:colorloD:u:v:smooth">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>lerp4Colors</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">lerp4Colors</font> module level field
       @param smooth defaults to true]]></haxe_doc>
		</_lerp4Colors>
		<_cross2d public="1" expr="cross2d">
			<f a="ax:ay:bx:by">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>cross2d</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">cross2d</font> module level field]]></haxe_doc>
		</_cross2d>
		<_dot public="1" expr="dot">
			<f a="ax:ay:bx:by">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>dot</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">dot</font> module level field]]></haxe_doc>
		</_dot>
		<_dotSame public="1" expr="dotSame">
			<f a="ax:ay">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>dotSame</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">dotSame</font> module level field]]></haxe_doc>
		</_dotSame>
		<_distanceSquarePointToSegment public="1" expr="distanceSquarePointToSegment">
			<f a="x:y:x1:y1:x2:y2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>distanceSquarePointToSegment</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">distanceSquarePointToSegment</font> module level field]]></haxe_doc>
		</_distanceSquarePointToSegment>
		<_rotX public="1" expr="rotX">
			<f a="x:y:sin:cos">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>rotX</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">rotX</font> module level field]]></haxe_doc>
		</_rotX>
		<_rotY public="1" expr="rotY">
			<f a="x:y:sin:cos">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>rotY</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">rotY</font> module level field]]></haxe_doc>
		</_rotY>
		<new public="1" set="method" line="97">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.algo._GeomPix.GeomPix_Fields_" params="" file="src/pixelimage/algo/GeomPix.hx" private="1" module="pixelimage.algo.GeomPix" final="1">
		<smootherStep public="1" get="inline" set="null" line="27" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></smootherStep>
		<lerp public="1" get="inline" set="null" line="32" static="1"><f a="a:b:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></lerp>
		<lerp4Colors public="1" get="inline" set="null" line="37" static="1">
			<f a="colorhiA:colorhiB:colorloC:colorloD:u:v:?smooth" v="::::::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ smooth : true }</e></m></meta>
		</lerp4Colors>
		<lerp2Colors public="1" get="inline" set="null" line="44" static="1">
			<f a="colA:colB:t:?smooth" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ smooth : true }</e></m></meta>
		</lerp2Colors>
		<cross2d public="1" get="inline" set="null" line="64" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></cross2d>
		<dot public="1" get="inline" set="null" line="67" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></dot>
		<dotSame public="1" get="inline" set="null" line="70" static="1"><f a="ax:ay">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></dotSame>
		<distanceSquarePointToSegment public="1" get="inline" set="null" line="76" static="1"><f a="x:y:x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distanceSquarePointToSegment>
		<rotX public="1" get="inline" set="null" line="89" static="1"><f a="x:y:sin:cos">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></rotX>
		<rotY public="1" get="inline" set="null" line="93" static="1"><f a="x:y:sin:cos">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></rotY>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.algo.IhitObj" params="" file="src/pixelimage/algo/IhitObj.hx" interface="1">
		<hit public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hit>
		<undoImage public="1"><x path="Null"><x path="pixelimage.Pixelimage"/></x></undoImage>
		<undoX public="1"><x path="Int"/></undoX>
		<undoY public="1"><x path="Int"/></undoY>
	</class>
	<class path="pixelimage.algo.HitEllipse" params="" file="src/pixelimage/algo/HitEllipse.hx">
		<implements path="pixelimage.algo.IhitObj"/>
		<cx public="1"><x path="Float"/></cx>
		<cy public="1"><x path="Float"/></cy>
		<rx public="1"><x path="Float"/></rx>
		<ry public="1"><x path="Float"/></ry>
		<phi public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</phi>
		<x_phi_rx><x path="Float"/></x_phi_rx>
		<x_phi_ry><x path="Float"/></x_phi_ry>
		<y_phi_rx><x path="Float"/></y_phi_rx>
		<y_phi_ry><x path="Float"/></y_phi_ry>
		<undoImage public="1" expr="null">
			<x path="Null"><x path="pixelimage.Pixelimage"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</undoImage>
		<undoX public="1"><x path="Int"/></undoX>
		<undoY public="1"><x path="Int"/></undoY>
		<hit public="1" get="inline" set="null" line="36"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hit>
		<new get="inline" set="null" line="17">
			<f a="cx:cy:rx:ry:?phi" v="::::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ phi : 0. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.algo.HitQuad" params="" file="src/pixelimage/algo/HitQuad.hx">
		<implements path="pixelimage.algo.IhitObj"/>
		<ax public="1"><x path="Float"/></ax>
		<ay public="1"><x path="Float"/></ay>
		<bx public="1"><x path="Float"/></bx>
		<by public="1"><x path="Float"/></by>
		<cx public="1"><x path="Float"/></cx>
		<cy public="1"><x path="Float"/></cy>
		<dx public="1"><x path="Float"/></dx>
		<dy public="1"><x path="Float"/></dy>
		<triABD public="1"><c path="pixelimage.algo.HitTri"/></triABD>
		<triBCD public="1"><c path="pixelimage.algo.HitTri"/></triBCD>
		<xIter4 public="1"><x path="pixelimage.iter.IteratorRange"/></xIter4>
		<yIter4 public="1"><x path="pixelimage.iter.IteratorRange"/></yIter4>
		<undoImage public="1" expr="null">
			<x path="Null"><x path="pixelimage.Pixelimage"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</undoImage>
		<undoX public="1"><x path="Int"/></undoX>
		<undoY public="1"><x path="Int"/></undoY>
		<preCalculateValues public="1" get="inline" set="null" line="43"><f a=""><x path="Void"/></f></preCalculateValues>
		<hit public="1" get="inline" set="null" line="51"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hit>
		<pushTriangles public="1" get="inline" set="null" line="65"><f a="arrTri">
	<c path="Array"><c path="pixelimage.algo.HitTri"/></c>
	<c path="Array"><c path="pixelimage.algo.HitTri"/></c>
</f></pushTriangles>
		<new public="1" get="inline" set="null" line="25">
			<f a="ax:ay:bx:by:cx:cy:dx:dy:?preCalculated" v="::::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ preCalculated : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.algo.HitTri" params="" file="src/pixelimage/algo/HitTri.hx">
		<implements path="pixelimage.algo.IhitObj"/>
		<ax public="1"><x path="Float"/></ax>
		<ay public="1"><x path="Float"/></ay>
		<bx public="1"><x path="Float"/></bx>
		<by public="1"><x path="Float"/></by>
		<cx public="1"><x path="Float"/></cx>
		<cy public="1"><x path="Float"/></cy>
		<preCalculated public="1"><x path="Bool"/></preCalculated>
		<s0><x path="Float"/></s0>
		<sx><x path="Float"/></sx>
		<sy><x path="Float"/></sy>
		<t0><x path="Float"/></t0>
		<tx><x path="Float"/></tx>
		<ty><x path="Float"/></ty>
		<A><x path="Float"/></A>
		<xIter3 public="1"><x path="pixelimage.iter.IteratorRange"/></xIter3>
		<yIter3 public="1"><x path="pixelimage.iter.IteratorRange"/></yIter3>
		<undoImage public="1" expr="null">
			<x path="Null"><x path="pixelimage.Pixelimage"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</undoImage>
		<undoX public="1"><x path="Int"/></undoX>
		<undoY public="1"><x path="Int"/></undoY>
		<preCalculateValues public="1" get="inline" set="null" line="52"><f a=""><x path="Void"/></f></preCalculateValues>
		<hit public="1" get="inline" set="null" line="65"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hit>
		<new public="1" get="inline" set="null" line="27">
			<f a="ax:ay:bx:by:cx:cy:?preCalculated" v="::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ preCalculated : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.algo.HitTriArray" params="" file="src/pixelimage/algo/HitTriArray.hx">
		<implements path="pixelimage.algo.IhitObj"/>
		<triArr public="1"><c path="Array"><c path="pixelimage.algo.HitTri"/></c></triArr>
		<xRange><x path="pixelimage.iter.IteratorRange"/></xRange>
		<yRange><x path="pixelimage.iter.IteratorRange"/></yRange>
		<undoImage public="1" expr="null">
			<x path="Null"><x path="pixelimage.Pixelimage"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</undoImage>
		<undoX public="1"><x path="Int"/></undoX>
		<undoY public="1"><x path="Int"/></undoY>
		<boundsCalculated public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</boundsCalculated>
		<calculateBounds get="inline" set="null" line="20"><f a=""><x path="Void"/></f></calculateBounds>
		<hit public="1" get="inline" set="null" line="41"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hit>
		<new public="1" get="inline" set="null" line="16"><f a="triArr">
	<c path="Array"><c path="pixelimage.algo.HitTri"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.algo.LinePixel" params="" file="src/pixelimage/algo/LinePixel.hx">
		<_rotateLine public="1" expr="rotateLine">
			<f a="pixelImage:px:py:thick:h:theta:color:hasHit:debugCorners">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>rotateLine</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">rotateLine</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_rotateLine>
		<_rotateTileLine public="1" expr="rotateTileLine">
			<f a="pixelImage:px:py:thick:h:theta:tileImage:hasHit:?debugCorners">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>rotateTileLine</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">rotateTileLine</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_rotateTileLine>
		<_rotateGradLine public="1" expr="rotateGradLine">
			<f a="pixelImage:px:py:thick:h:theta:colorA:colorB:colorC:colorD:hasHit:?debugCorners">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>rotateGradLine</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">rotateGradLine</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_rotateGradLine>
		<new public="1" set="method" line="544">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.algo._LinePixel.LinePixel_Fields_" params="" file="src/pixelimage/algo/LinePixel.hx" private="1" module="pixelimage.algo.LinePixel" final="1">
		<rotateLine public="1" get="inline" set="null" line="15" static="1">
			<f a="pixelImage:px:py:thick:h:theta:color:?hasHit:?debugCorners" v=":::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : false }</e></m></meta>
		</rotateLine>
		<rotateSoftLine public="1" get="inline" set="null" line="69" static="1">
			<f a="pixelImage:px:py:thick:h:theta:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit:?debugCorners" v=":::::::40.:true:true:true:true:false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40. }</e></m></meta>
		</rotateSoftLine>
		<rotateSoftLineLuxury public="1" get="inline" set="null" line="123" static="1">
			<f a="pixelImage:px:py:thick:h:theta:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit:?debugCorners" v=":::::::40.:true:true:true:true:false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40. }</e></m></meta>
		</rotateSoftLineLuxury>
		<rotateSoftLinePartial public="1" get="inline" set="null" line="177" static="1">
			<f a="pixelImage:px:py:thick:h:theta:color:?softC:?softTop:?softRight:?softBottom:?softLeft:?hasHit:?debugCorners" v=":::::::10.:true:true:true:true:false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : false, softLeft : true, softBottom : true, softRight : true, softTop : true, softC : 10. }</e></m></meta>
		</rotateSoftLinePartial>
		<rotateLineFlare public="1" get="inline" set="null" line="226" static="1">
			<f a="pixelImage:px:py:thick1:thick2:h:theta:color:?hasHit" v="::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</rotateLineFlare>
		<rotateSoftLineFlare public="1" get="inline" set="null" line="274" static="1">
			<f a="pixelImage:px:py:thick1:thick2:h:theta:color:?softC:?softTop:?softRight:?softBottom:?softLeft:?hasHit" v="::::::::10.:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softLeft : true, softBottom : true, softRight : true, softTop : true, softC : 10. }</e></m></meta>
		</rotateSoftLineFlare>
		<rotateSoftLineFlarePartial public="1" get="inline" set="null" line="322" static="1">
			<f a="pixelImage:px:py:thick1:thick2:h:theta:color:?softC:?softTop:?softRight:?softBottom:?softLeft:?hasHit" v="::::::::10.:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softLeft : true, softBottom : true, softRight : true, softTop : true, softC : 10. }</e></m></meta>
		</rotateSoftLineFlarePartial>
		<rotateTileLine public="1" get="inline" set="null" line="367" static="1">
			<f a="pixelImage:px:py:thick:h:theta:tileImage:?hasHit:?debugCorners" v=":::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : false }</e></m></meta>
		</rotateTileLine>
		<rotateTileLineFlare public="1" get="inline" set="null" line="416" static="1">
			<f a="pixelImage:px:py:thick1:thick2:h:theta:tileImage:?hasHit" v="::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</rotateTileLineFlare>
		<rotateGradLine public="1" get="inline" set="null" line="461" static="1">
			<f a="pixelImage:px:py:thick:h:theta:colorA:colorB:colorC:colorD:?hasHit:?debugCorners" v="::::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ debugCorners : false, hasHit : false }</e></m></meta>
		</rotateGradLine>
		<rotateGradLineFlare public="1" get="inline" set="null" line="511" static="1">
			<f a="pixelImage:px:py:thick1:thick2:h:theta:colorA:colorB:colorC:colorD:?hasHit" v=":::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</rotateGradLineFlare>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.algo.PolyPixel" params="" file="src/pixelimage/algo/PolyPixel.hx">
		<_fillPolygonBuild public="1" expr="fillPolygonBuild">
			<f a="pixelimage:cx:cy:rx:ry:color:?phi:?sides:cornerUp">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>fillPolygonBuild</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">fillPolygonBuild</font> module level field]]></haxe_doc>
		</_fillPolygonBuild>
		<_tilePolygonBuild public="1" expr="tilePolygonBuild">
			<f a="pixelimage:cx:cy:rx:ry:tileImage:?phi:?sides:cornerUp">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>tilePolygonBuild</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">tilePolygonBuild</font> module level field]]></haxe_doc>
		</_tilePolygonBuild>
		<_fillRadialPolyBuild public="1" expr="fillRadialPolyBuild">
			<f a="pixelimage:cx:cy:rx:ry:colorIn:colorOut:?gx:?gy:?phi:?sides:cornerUp">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>fillRadialPolyBuild</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">fillRadialPolyBuild</font> module level field]]></haxe_doc>
		</_fillRadialPolyBuild>
		<new public="1" set="method" line="250">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.algo._PolyPixel.PolyPixel_Fields_" params="" file="src/pixelimage/algo/PolyPixel.hx" private="1" module="pixelimage.algo.PolyPixel" final="1">
		<fillPolygonBuild public="1" get="inline" set="null" line="13" static="1">
			<f a="pixelimage:cx:cy:rx:ry:color:?phi:?sides:?cornerUp" v="::::::0.:36:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0. }</e></m></meta>
		</fillPolygonBuild>
		<softFillPolygonBuild public="1" get="inline" set="null" line="73" static="1">
			<f a="pixelimage:cx:cy:rx:ry:color:?phi:?sides:?softC:?cornerUp" v="::::::0.:36:10:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerUp : true, softC : 10, sides : 36, phi : 0. }</e></m></meta>
		</softFillPolygonBuild>
		<tilePolygonBuild public="1" get="inline" set="null" line="132" static="1">
			<f a="pixelimage:cx:cy:rx:ry:tileImage:?phi:?sides:?cornerUp" v="::::::0.:36:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0. }</e></m></meta>
		</tilePolygonBuild>
		<fillRadialPolyBuild public="1" get="inline" set="null" line="192" static="1">
			<f a="pixelimage:cx:cy:rx:ry:colorIn:colorOut:?gx:?gy:?phi:?sides:?cornerUp" v=":::::::0:0:0.:36:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerUp : true, sides : 36, phi : 0., gy : 0, gx : 0 }</e></m></meta>
		</fillRadialPolyBuild>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.algo.QuadPixel" params="" file="src/pixelimage/algo/QuadPixel.hx">
		<_fillQuadrilateral public="1" expr="fillQuadrilateral">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:color:hasHit">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>fillQuadrilateral</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">rotateGradLine</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_fillQuadrilateral>
		<_tileQuadrilateral public="1" expr="tileQuadrilateral">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:tileImage:hasHit">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>tileQuadrilateral</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">rotateGradLine</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_tileQuadrilateral>
		<_fillGradQuadrilateral public="1" expr="fillGradQuadrilateral">
			<f a="pixelImage:ax:ay:colorA:bx:by:colorB:cx:cy:colorC:dx:dy:colorD:hasHit">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>fillGradQuadrilateral</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">rotateGradLine</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_fillGradQuadrilateral>
		<new public="1" set="method" line="303">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.algo._QuadPixel.QuadPixel_Fields_" params="" file="src/pixelimage/algo/QuadPixel.hx" private="1" module="pixelimage.algo.QuadPixel" final="1">
		<fillQuadrilateral public="1" get="inline" set="null" line="15" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:color:?hasHit" v="::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</fillQuadrilateral>
		<fillSoftQuadrilateral public="1" get="inline" set="null" line="40" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
		</fillSoftQuadrilateral>
		<fillSoftQuadrilateralFudge public="1" get="inline" set="null" line="64" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
		</fillSoftQuadrilateralFudge>
		<fillSoftQuadrilateralQuarter public="1" get="inline" set="null" line="89" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:color:?soft:?softAB:?softBC:?softCD:?softDA:?hasHit" v="::::::::::40:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softDA : true, softCD : true, softBC : true, softAB : true, soft : 40 }</e></m></meta>
		</fillSoftQuadrilateralQuarter>
		<tileQuadrilateral public="1" get="inline" set="null" line="114" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:tileImage:?hasHit" v="::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</tileQuadrilateral>
		<fillGradQuadrilateral public="1" get="inline" set="null" line="133" static="1">
			<f a="pixelImage:ax:ay:colorA:bx:by:colorB:cx:cy:colorC:dx:dy:colorD:?hasHit" v=":::::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</fillGradQuadrilateral>
		<imgQuadrilateralFudge public="1" get="inline" set="null" line="153" static="1">
			<f a="pixelImage:texture:win:ax:ay:bx:by:cx:cy:dx:dy:?hasHit" v=":::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</imgQuadrilateralFudge>
		<imgQuadrilateral public="1" get="inline" set="null" line="175" static="1">
			<f a="pixelImage:texture:win:ax:ay:bx:by:cx:cy:dx:dy:?au:?av:?bu:?bv:?cu:?cv:?du:?dv:?hasHit" v=":::::::::::0.:0.:1.:0.:1.:1.:0.:1.:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, dv : 1., du : 0., cv : 1., cu : 1., bv : 0., bu : 1., av : 0., au : 0. }</e></m></meta>
		</imgQuadrilateral>
		<imageNineSlice public="1" get="inline" set="null" line="198" static="1">
			<f a="pixelImage:texture:win:x:y:wid:hi:left:top:fat:tall:widNew:hiNew:leftNew:topNew:fatNew:tallNew:?hasHit" v=":::::::::::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</imageNineSlice>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.algo._QuadrantPixel.QuadrantPixel_Fields_" params="" file="src/pixelimage/algo/QuadrantPixel.hx" private="1" module="pixelimage.algo.QuadrantPixel" final="1">
		<solidQuadrant public="1" get="inline" set="null" line="15" static="1">
			<f a="pixelimage:cx:cy:rx:ry:startAngle:color:?phi:?targetError" v="::::::::1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05 }</e></m></meta>
			<haxe_doc>* fillQuadrant draws a quarter arc.
     *</haxe_doc>
		</solidQuadrant>
		<tileSolidQuadrant public="1" get="inline" set="null" line="62" static="1">
			<f a="pixelimage:cx:cy:rx:ry:startAngle:tileImage:?phi:?targetError" v="::::::::1.05">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 1.05 }</e></m></meta>
			<haxe_doc>* fillQuadrant draws a quarter arc.
     *</haxe_doc>
		</tileSolidQuadrant>
	</class>
	<class path="pixelimage.algo._QuintPixel.QuintPixel_Fields_" params="" file="src/pixelimage/algo/QuintPixel.hx" private="1" module="pixelimage.algo.QuintPixel" final="1">
		<softFillQuintilateral public="1" get="inline" set="null" line="20" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:color:?softC:?hasHit" v="::::::::::10:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softC : 10 }</e></m></meta>
		</softFillQuintilateral>
		<softFillQuintilateralPartial public="1" get="inline" set="null" line="63" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:dx:dy:color:?softC:?softTop:?softRight:?softBottom:?softLeft:?hasHit" v="::::::::::10:true:true:true:true:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitQuad"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softLeft : true, softBottom : true, softRight : true, softTop : true, softC : 10 }</e></m></meta>
		</softFillQuintilateralPartial>
	</class>
	<class path="pixelimage.algo.RectanglePixel" params="" file="src/pixelimage/algo/RectanglePixel.hx">
		<_fillRadialRect public="1" expr="fillRadialRect">
			<f a="pixelimage:x:y:wid:hi:colorIn:colorOut:?gx:?gy:?edgePoints">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>fillRadialRect</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">fillRadialRect</font> module level field]]></haxe_doc>
		</_fillRadialRect>
		<new public="1" set="method" line="82">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.algo._RectanglePixel.RectanglePixel_Fields_" params="" file="src/pixelimage/algo/RectanglePixel.hx" private="1" module="pixelimage.algo.RectanglePixel" final="1">
		<fillRadialRect public="1" get="inline" set="null" line="14" static="1">
			<f a="pixelimage:x:y:wid:hi:colorIn:colorOut:?gx:?gy:?edgePoints" v=":::::::0:0:4">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ edgePoints : 4, gy : 0, gx : 0 }</e></m></meta>
		</fillRadialRect>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.algo.RoundRecPixel" params="" file="src/pixelimage/algo/RoundRecPixel.hx">
		<_fillRoundRectangle public="1" expr="fillRoundRectangle">
			<f a="pixelshape:x:y:wid:hi:color:?dx:?dy:?fat:?tall">
				<x path="pixelimage.Pixelshape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>fillRoundRectangle</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">fillRoundRectangle</font> module level field]]></haxe_doc>
		</_fillRoundRectangle>
		<_tileRoundRectangle public="1" expr="tileRoundRectangle">
			<f a="pixelshape:x:y:wid:hi:tileImage:?dx:?dy:?fat:?tall">
				<x path="pixelimage.Pixelshape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>tileRoundRectangle</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">tileRoundRectangle</font> module level field]]></haxe_doc>
		</_tileRoundRectangle>
		<_fillGrad4RoundRectangle public="1" expr="fillGrad4RoundRectangle">
			<f a="pixelshape:x:y:hi:wid:colorA:colorB:colorC:colorD:?dx:?dy:?fat:?tall">
				<x path="pixelimage.Pixelshape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>fillGrad4RoundRectangle</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">fillGrad4RoundRectangle</font> module level field]]></haxe_doc>
		</_fillGrad4RoundRectangle>
		<new public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.algo._RoundRecPixel.RoundRecPixel_Fields_" params="" file="src/pixelimage/algo/RoundRecPixel.hx" private="1" module="pixelimage.algo.RoundRecPixel" final="1">
		<fillRoundRectangle public="1" get="inline" set="null" line="20" static="1">
			<f a="pixelshape:x:y:wid:hi:color:?dx:?dy:?fat:?tall" v="::::::-1.:-1.:-1.:-1.">
				<x path="pixelimage.Pixelshape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
			<haxe_doc>x, y      - position
        hi, wid   - the outside dimensions
        dx, dy    - define the 9-slice distance in from x, y, dy can default to dx
        fat, tall - the inner dimensions of the 9-slice centre, optional</haxe_doc>
		</fillRoundRectangle>
		<tileRoundRectangle public="1" get="inline" set="null" line="60" static="1">
			<f a="pixelshape:x:y:wid:hi:tileImage:?dx:?dy:?fat:?tall" v="::::::-1.:-1.:-1.:-1.">
				<x path="pixelimage.Pixelshape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
			<haxe_doc>x, y      - position
        hi, wid   - the outside dimensions
        dx, dy    - define the 9-slice distance in from x, y, dy can default to dx
        fat, tall - the inner dimensions of the 9-slice centre, optional</haxe_doc>
		</tileRoundRectangle>
		<fillGrad4RoundRectangle public="1" get="inline" set="null" line="100" static="1">
			<f a="pixelshape:x:y:hi:wid:colorA:colorB:colorC:colorD:?dx:?dy:?fat:?tall" v=":::::::::-1.:-1.:-1.:-1.">
				<x path="pixelimage.Pixelshape"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tall : -1., fat : -1., dy : -1., dx : -1. }</e></m></meta>
			<haxe_doc>x, y      - position
        hi, wid   - the outside dimensions
        dx, dy    - define the 9-slice distance in from x, y, dy can default to dx
        fat, tall - the inner dimensions of the 9-slice centre, optional</haxe_doc>
		</fillGrad4RoundRectangle>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.algo.TriPixel" params="" file="src/pixelimage/algo/TriPixel.hx">
		<_fillTriUnsafe public="1" expr="fillTriUnsafe">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:hasHit:hasUndo">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>fillTriUnsafe</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">fillTriUnsafe</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_fillTriUnsafe>
		<_tileTriUnsafe public="1" expr="tileTriUnsafe">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:tileImage:hasHit:hasUndo">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>tileTriUnsafe</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">tileTriUnsafe</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_tileTriUnsafe>
		<_fillGradTriangle public="1" expr="fillGradTriangle">
			<f a="pixelImage:ax:ay:colA:bx:by:colB:cx:cy:colC:hasHit:hasUndo">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>fillGradTriangle</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">fillGradTriangle</font> module level field
       @param hasHit defaults false, since a HitTri has runtime overhead.]]></haxe_doc>
		</_fillGradTriangle>
		<new public="1" set="method" line="1104">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.algo._TriPixel.TriPixel_Fields_" params="" file="src/pixelimage/algo/TriPixel.hx" private="1" module="pixelimage.algo.TriPixel" final="1">
		<fillTriangle public="1" get="inline" set="null" line="19" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?hasHit:?hasUndo" v="::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
			<haxe_doc>provides a filled triangle give a,b,c coordinates
        automagically rearranges coordinates so it always renders</haxe_doc>
		</fillTriangle>
		<fillTriUnsafe public="1" get="inline" set="null" line="40" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?hasHit:?hasUndo" v="::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</fillTriUnsafe>
		<fillTriangle2 public="1" get="inline" set="null" line="99" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?hasHit" v="::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</fillTriangle2>
		<fillTriUnsafe2 public="1" get="inline" set="null" line="120" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?hasHit:?hasUndo" v="::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</fillTriUnsafe2>
		<tileTriangle public="1" get="inline" set="null" line="181" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:tileImage:?hasHit" v="::::::::false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false }</e></m></meta>
		</tileTriangle>
		<tileTriUnsafe public="1" get="inline" set="null" line="202" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:tileImage:?hasHit:?hasUndo" v="::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</tileTriUnsafe>
		<fillGradTriangle public="1" get="inline" set="null" line="263" static="1">
			<f a="pixelImage:ax:ay:colA:bx:by:colB:cx:cy:colC:?hasHit:?hasUndo" v="::::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</fillGradTriangle>
		<topRightImgTriFudge public="1" get="inline" set="null" line="327" static="1">
			<f a="pixelImage:texture:win:ax:ay:bx:by:cx:cy:?hasHit:?hasUndo" v=":::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</topRightImgTriFudge>
		<bottomLeftImgTriFudge public="1" get="inline" set="null" line="335" static="1">
			<f a="pixelImage:texture:win:dx:dy:cx:cy:ax:ay:?hasHit:?hasUndo" v=":::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</bottomLeftImgTriFudge>
		<uvTriangleFudge public="1" get="inline" set="null" line="347" static="1">
			<f a="pixelImage:texture:win:ax:ay:au:av:bx:by:bu:bv:cx:cy:cu:cv:?hasHit:?hasUndo" v=":::::::::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
			<haxe_doc>This is the first attempt at UV mapping it does not swap A B and so does not work properly, but can be used with fudged triangles above.
        Likely will remove in future but keeping incase it is useful for edge cases.</haxe_doc>
		</uvTriangleFudge>
		<topLeftImgTri public="1" get="inline" set="null" line="400" static="1">
			<f a="pixelImage:texture:win:ax:ay:bx:by:dx:dy:?hasHit:?hasUndo" v=":::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</topLeftImgTri>
		<bottomRightImgTri public="1" get="inline" set="null" line="410" static="1">
			<f a="pixelImage:texture:win:bx:by:cx:cy:dx:dy:?hasHit:?hasUndo" v=":::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</bottomRightImgTri>
		<uvTriangle public="1" get="inline" set="null" line="420" static="1">
			<f a="pixelImage:texture:win:ax:ay:au:av:bx:by:bu:bv:cx:cy:cu:cv:?hasHit:?hasUndo" v=":::::::::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</uvTriangle>
		<uvTriangleSoft3 public="1" get="inline" set="null" line="483" static="1">
			<f a="pixelImage:texture:win:ax:ay:au:av:bx:by:bu:bv:cx:cy:cu:cv:soft3:?hasHit:?hasUndo" v="::::::::::::::::false:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : true, hasHit : false }</e></m></meta>
		</uvTriangleSoft3>
		<fillTriTwoSoft public="1" get="inline" set="null" line="569" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?softC:?hasHit" v="::::::::10:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasHit : false, softC : 10 }</e></m></meta>
		</fillTriTwoSoft>
		<fillTriSoftC public="1" get="inline" set="null" line="592" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?softC:?hasHit:?hasUndo" v="::::::::10:false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false, softC : 10 }</e></m></meta>
		</fillTriSoftC>
		<fillTriSoft3 public="1" get="inline" set="null" line="666" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?soft3:?softAB:?softBC:?softCA:?hasHit:?hasUndo" v="::::::::40:true:true:true:false:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : true, hasHit : false, softCA : true, softBC : true, softAB : true, soft3 : 40 }</e></m></meta>
		</fillTriSoft3>
		<fillQuarterSoft public="1" get="inline" set="null" line="783" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?soft3:?softAB:?softBC:?softCA:?hasHit:?hasUndo" v="::::::::40:true:true:true:false:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : true, hasHit : false, softCA : true, softBC : true, softAB : true, soft3 : 40 }</e></m></meta>
		</fillQuarterSoft>
		<fillTriExtra0 public="1" get="inline" set="null" line="879" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?hasHit:?hasUndo" v="::::::::false:true">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : true, hasHit : false }</e></m></meta>
		</fillTriExtra0>
		<fillTriExtra1 public="1" get="inline" set="null" line="950" static="1">
			<f a="pixelImage:ax:ay:bx:by:cx:cy:color:?hasHit:?hasUndo" v="::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</fillTriExtra1>
		<uvTriangleTexture3 public="1" get="inline" set="null" line="1011" static="1">
			<f a="pixelImage:textureA:winA:textureB:winB:textureC:winC:ax:ay:au:av:bx:by:bu:bv:cx:cy:cu:cv:?hasHit:?hasUndo" v=":::::::::::::::::::false:false">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="pixelimage.Pixelimage"/>
				<c path="pixelimage.algo.RectangleWindow"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Null"><c path="pixelimage.algo.HitTri"/></x>
			</f>
			<meta><m n=":value"><e>{ hasUndo : false, hasHit : false }</e></m></meta>
		</uvTriangleTexture3>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.draw.DrawGradThickHelper" params="" file="src/pixelimage/draw/DrawGradThickHelper.hx">
		<implements path="justPath.ILinePathContext"/>
		<svgLinePath><c path="justPath.SvgLinePath"/></svgLinePath>
		<x0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x0>
		<y0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y0>
		<toggleDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</toggleDraw>
		<strokeWidth><x path="Float"/></strokeWidth>
		<strokeTopColor public="1"><x path="Int"/></strokeTopColor>
		<strokeBottomColor public="1"><x path="Int"/></strokeBottomColor>
		<translateX><x path="Float"/></translateX>
		<translateY><x path="Float"/></translateY>
		<scaleX><x path="Float"/></scaleX>
		<scaleY><x path="Float"/></scaleY>
		<pixelImage><x path="pixelimage.Pixelimage"/></pixelImage>
		<info><c path="pixelimage.algo.HitQuad"/></info>
		<oldInfo><c path="pixelimage.algo.HitQuad"/></oldInfo>
		<lineSegmentTo public="1" set="method" line="45"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<lineTo public="1" set="method" line="62"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="79"><f a="x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<quadTo public="1" set="method" line="86"><f a="x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadTo>
		<curveTo public="1" set="method" line="90"><f a="x2:y2:x3:y3:x4:y4">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<quadThru public="1" set="method" line="94"><f a="x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadThru>
		<archBezier public="1" get="inline" set="null" line="98"><f a="distance:distance2:radius:rotation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></archBezier>
		<triangleArch public="1" get="inline" set="null" line="106"><f a="distance:distance2:radius:rotation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></triangleArch>
		<new public="1" set="method" line="26">
			<f a="pixelImage:strokeWidth:strokeTopColor:strokeBottomColor:?translateX:?translateY:?scaleX:?scaleY" v="::::0.:0.:1.:1.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.draw.DrawShapeHelper" params="" file="src/pixelimage/draw/DrawShapeHelper.hx">
		<implements path="justPath.ILinePathContext"/>
		<svgLinePath><c path="justPath.SvgLinePath"/></svgLinePath>
		<x0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x0>
		<y0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y0>
		<toggleDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</toggleDraw>
		<strokeWidth><x path="Float"/></strokeWidth>
		<strokeColor><x path="Int"/></strokeColor>
		<translateX><x path="Float"/></translateX>
		<translateY><x path="Float"/></translateY>
		<scaleX><x path="Float"/></scaleX>
		<scaleY><x path="Float"/></scaleY>
		<pixelImage><x path="pixelimage.Pixelimage"/></pixelImage>
		<info><c path="pixelimage.algo.HitQuad"/></info>
		<oldInfo><c path="pixelimage.algo.HitQuad"/></oldInfo>
		<lineSegmentTo public="1" set="method" line="42"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<lineTo public="1" set="method" line="63"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="80"><f a="x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<quadTo public="1" set="method" line="87"><f a="x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadTo>
		<curveTo public="1" set="method" line="91"><f a="x2:y2:x3:y3:x4:y4">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<quadThru public="1" set="method" line="95"><f a="x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadThru>
		<archBezier public="1" get="inline" set="null" line="99"><f a="distance:distance2:radius:rotation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></archBezier>
		<triangleArch public="1" get="inline" set="null" line="107"><f a="distance:distance2:radius:rotation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></triangleArch>
		<new public="1" set="method" line="25">
			<f a="pixelImage:strokeWidth:strokeColor:?translateX:?translateY:?scaleX:?scaleY" v=":::0.:0.:1.:1.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.draw.DrawTileHelper" params="" file="src/pixelimage/draw/DrawTileHelper.hx">
		<implements path="justPath.ILinePathContext"/>
		<svgLinePath><c path="justPath.SvgLinePath"/></svgLinePath>
		<x0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x0>
		<y0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y0>
		<toggleDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</toggleDraw>
		<strokeWidth><x path="Float"/></strokeWidth>
		<tileImageStroke><x path="pixelimage.Pixelimage"/></tileImageStroke>
		<translateX><x path="Float"/></translateX>
		<translateY><x path="Float"/></translateY>
		<scaleX><x path="Float"/></scaleX>
		<scaleY><x path="Float"/></scaleY>
		<pixelImage><x path="pixelimage.Pixelimage"/></pixelImage>
		<info><c path="pixelimage.algo.HitQuad"/></info>
		<oldInfo><c path="pixelimage.algo.HitQuad"/></oldInfo>
		<lineSegmentTo public="1" set="method" line="41"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<lineTo public="1" set="method" line="58"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="74"><f a="x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<quadTo public="1" set="method" line="81"><f a="x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadTo>
		<curveTo public="1" set="method" line="85"><f a="x2:y2:x3:y3:x4:y4">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<quadThru public="1" set="method" line="89"><f a="x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadThru>
		<archBezier public="1" get="inline" set="null" line="93"><f a="distance:distance2:radius:rotation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></archBezier>
		<triangleArch public="1" get="inline" set="null" line="101"><f a="distance:distance2:radius:rotation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></triangleArch>
		<new public="1" set="method" line="25">
			<f a="pixelImage:strokeWidth:tileImageStroke:?translateX:?translateY:?scaleX:?scaleY" v=":::0.:0.:1.:1.">
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="pixelimage.Pixelimage"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.fontImage.CharPlacement1D" params="" file="src/pixelimage/fontImage/OneDfont.hx" module="pixelimage.fontImage.OneDfont">
		<currX public="1"><x path="Int"/></currX>
		<currY public="1"><x path="Int"/></currY>
		<minX public="1"><x path="Int"/></minX>
		<maxX public="1"><x path="Int"/></maxX>
		<new public="1" get="inline" set="null" line="10"><f a="currX:currY:minX:maxX">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.fontImage.OneDfont" params="" file="src/pixelimage/fontImage/OneDfont.hx">
		<fontImage public="1"><x path="pixelimage.Pixelimage"/></fontImage>
		<startingAscii public="1"><x path="Int"/></startingAscii>
		<markerColor public="1"><x path="Int"/></markerColor>
		<pairOffset public="1"><x path="Null"><c path="haxe.ds.StringMap"><x path="Int"/></c></x></pairOffset>
		<markers expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</markers>
		<findMarkers get="inline" set="null" line="38"><f a=""><x path="Void"/></f></findMarkers>
		<createPlacement public="1" get="inline" set="null" line="48">
			<f a="str:?spacingX" v=":0">
				<c path="String"/>
				<x path="Int"/>
				<c path="Array"><c path="pixelimage.fontImage.CharPlacement1D"/></c>
			</f>
			<meta><m n=":value"><e>{ spacingX : 0 }</e></m></meta>
		</createPlacement>
		<drawString public="1" get="inline" set="null" line="98">
			<f a="str:?spacingX:?transparent" v=":0:false">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ transparent : false, spacingX : 0 }</e></m></meta>
			<haxe_doc>This is used to draw strings, but it is useful that 
        createPlacement and drawPlacement can be used separately 
        to allow for instance curved y placement</haxe_doc>
		</drawString>
		<drawCurveY public="1" get="inline" set="null" line="105">
			<f a="charPos:fy:?transparent" v="::false">
				<c path="Array"><c path="pixelimage.fontImage.CharPlacement1D"/></c>
				<f a="x">
					<x path="Int"/>
					<x path="Int"/>
				</f>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ transparent : false }</e></m></meta>
		</drawCurveY>
		<widthArrCharPlacement1D public="1" get="inline" set="null" line="124"><f a="charPos">
	<c path="Array"><c path="pixelimage.fontImage.CharPlacement1D"/></c>
	<x path="Int"/>
</f></widthArrCharPlacement1D>
		<drawPlacement public="1" get="inline" set="null" line="130">
			<f a="pixelImage:charPos:?yOffSet" v="::0">
				<x path="pixelimage.Pixelimage"/>
				<c path="Array"><c path="pixelimage.fontImage.CharPlacement1D"/></c>
				<x path="Int"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ yOffSet : 0 }</e></m></meta>
		</drawPlacement>
		<new public="1" set="method" line="30">
			<f a="fontImage:?startingAscii:?markerColor:?pairOffset" v=":33:0xFFFFFFFF:null">
				<x path="pixelimage.Pixelimage"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.ds.StringMap"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pairOffset : null, markerColor : 0xFFFFFFFF, startingAscii : 33 }</e></m></meta>
			<haxe_doc>assumes font in a single row, with white marker pixels on the top pixel row to provide ascii start and end character information.
        currently setup that the last char is the spacebar one, as per current test data.</haxe_doc>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.fontImage._TestLem.TestLem_Fields_" params="" file="src/pixelimage/fontImage/TestLem.hx" private="1" module="pixelimage.fontImage.TestLem" final="1">
		<lemBlue public="1" set="method" line="6" static="1"><f a=""><c path="String"/></f></lemBlue>
		<lemYellow public="1" set="method" line="9" static="1"><f a=""><c path="String"/></f></lemYellow>
		<lemRed public="1" set="method" line="12" static="1"><f a=""><c path="String"/></f></lemRed>
		<lemCyan public="1" set="method" line="15" static="1"><f a=""><c path="String"/></f></lemCyan>
		<lemPurple public="1" set="method" line="18" static="1"><f a=""><c path="String"/></f></lemPurple>
		<lemOrange public="1" set="method" line="21" static="1"><f a=""><c path="String"/></f></lemOrange>
		<lemGreen public="1" set="method" line="24" static="1"><f a=""><c path="String"/></f></lemGreen>
	</class>
	<class path="pixelimage.formats._Format.Format_Fields_" params="" file="src/pixelimage/formats/Format.hx" private="1" module="pixelimage.formats.Format" final="1">
		<toPNG public="1" get="inline" set="null" line="10" static="1">
			<f a="pixelShape:name:?level" v="::9">
				<x path="pixelimage.Pixelshape"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
		</toPNG>
		<fromPNG public="1" get="inline" set="null" line="54" static="1">
			<f a="name:?transparent" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="pixelimage.Pixelimage"/>
			</f>
			<meta><m n=":value"><e>{ transparent : true }</e></m></meta>
		</fromPNG>
		<get_dir public="1" set="method" line="82" static="1"><f a=""><c path="String"/></f></get_dir>
	</class>
	<class path="vision.ds._Image.Image_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Image.hx" private="1" module="vision.ds.Image" final="1">
		<OFFSET expr="4" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
			<haxe_doc>* the first 4 bytes represent width.</haxe_doc>
		</OFFSET>
		<underlying public="1" get="accessor" set="null" static="1">
			<x path="vision.ds.ByteArray"/>
			<haxe_doc>Returns the underlying type of this abstract.</haxe_doc>
		</underlying>
		<get_underlying get="inline" set="null" line="31" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.ByteArray"/>
</f></get_underlying>
		<width public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The width of the image.</haxe_doc>
		</width>
		<get_width get="inline" set="null" line="46" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
</f></get_width>
		<height public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The height of the image.</haxe_doc>
		</height>
		<get_height get="inline" set="null" line="62" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
</f></get_height>
		<_new public="1" get="inline" set="null" line="77" static="1">
			<f a="width:height:?color" v="::0x00000000">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta>
				<m n=":value"><e>{ color : 0x00000000 }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new image of the given size. Onces created, the image cannot be resized.

		@param width The width of the image.
		@param height The height of the image.
		@param color The color to fill the image with. if unspecified, the image is transparent.</haxe_doc>
		</_new>
		<getColorFromStartingBytePos get="inline" set="null" line="90" static="1"><f a="this:position">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
</f></getColorFromStartingBytePos>
		<setColorFromStartingBytePos get="inline" set="null" line="95" static="1"><f a="this:position:c">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></setColorFromStartingBytePos>
		<getPixel public="1" get="inline" set="null" line="114" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Gets the color of the pixel at the given coordinates.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the coordinates are out of bounds.
		@return The color of the pixel at the given coordinates.</haxe_doc>
		</getPixel>
		<getSafePixel public="1" get="inline" set="null" line="135" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Gets the color of the pixel at the given coordinates.

		Coordinates outside the bounds of the image are allowed.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return The color of the pixel at the given coordinates.</haxe_doc>
		</getSafePixel>
		<getUnsafePixel get="inline" set="null" line="143" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":allow"><e>vision</e></m></meta>
		</getUnsafePixel>
		<getFloatingPixel public="1" get="inline" set="null" line="191" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc><![CDATA[Gets the color of the pixel at the given coordinates.
		These coordinates can also be of type `Float`, in which case
		the value returned should be an interpolation of the surrounding, physical pixels:

		### How Does This Work?

		Lets say we want the pixel at `(0.5, 0.5)`:
		```
		(0,0)   (1,0)                                     
														 
			  ·     < Y (0.5)                      
														 
		(0,1)   (1,1)                                     
			  ^                                           
			X (0.5)                                        
		```

		First, we're going to calculate the actual fraction - the means, extracting the numbers after the decimal point:

			final xFraction = x - Std.int(x);
			final yFraction = y - Std.int(y);


		Then, we just multiply each of the surrounding pixel's value by it's distance from the initial X value (using `xFraction` and `yFraction`):

			final pixelsBeforeYMultiplier = 1 - yFraction, pixelsAfterYMultiplier = yFraction;
			final pixelsBeforeXMultiplier = 1 - xFraction, pixelsAfterXMultiplier = xFraction;
			final bottomLayer = pixelsBeforeYMultiplier * (pixelsBeforeXMultiplier * getPixel(Std.int(x), Std.int(y)) + pixelsAfterXMultiplier * getPixel(Std.int(x) + 1, Std.int(y)));
			final topLayer = pixelsAfterYMultiplier * (pixelsBeforeXMultiplier * getPixel(Std.int(x), Std.int(y) + 1) + pixelsAfterXMultiplier * getPixel(Std.int(x) + 1, Std.int(y) + 1));


		And add the two layers to get the result:


			var finalColor:Color = Std.int(bottomLayer + topLayer);


		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the coordinates are out of bounds.
		@return The color of the pixel at the given coordinates.]]></haxe_doc>
		</getFloatingPixel>
		<setPixel public="1" get="inline" set="null" line="213" static="1">
			<f a="this:x:y:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the color of the pixel at the given coordinates.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.
		@param color The color to set the pixel to.

		@throws OutOfBounds if the pixel is out of bounds.</haxe_doc>
		</setPixel>
		<hasPixel public="1" get="inline" set="null" line="232" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks if the given coordinates are within the bounds of the image.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return True if the coordinates are within the bounds of the image.</haxe_doc>
		</hasPixel>
		<copyPixelFrom public="1" get="inline" set="null" line="246" static="1">
			<f a="this:image:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Copies a pixel from the given image to this image.

		@param image The image to copy the pixel from.
		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the given coordinates are outside the bounds of one or both of the images
		@return The color of the pixel at the given coordinates.</haxe_doc>
		</copyPixelFrom>
		<copyPixelTo public="1" get="inline" set="null" line="262" static="1">
			<f a="this:image:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Copies a pixel from the given image to this image.

		@param image The image to copy the pixel to.
		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the given coordinates are outside the bounds of one or both of the images
		@return The color of the pixel at the given coordinates.</haxe_doc>
		</copyPixelTo>
		<paintPixel public="1" get="inline" set="null" line="278" static="1">
			<f a="this:x:y:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the color of a pixel, but doesn't completely overwrite the pixel:

		- if the color of the new pixel is the same as the old pixel, the old pixel is kept.
		- if the alpha of the new pixel is 0, the old pixel is kept.
		- if the alpha of the new pixel is 255, the new pixel is kept.
		- if the alpha of the new pixel is between 0 and 255, the new pixel is blended with the old pixel.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.
		@param color The color to set the pixel to. pay attention to the alpha value.</haxe_doc>
		</paintPixel>
		<fillRect public="1" get="inline" set="null" line="298" static="1">
			<f a="this:x:y:width:height:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a rectangle of pixels to the given color, essentially filling it with the given color.

		@param rect The rectangle to fill: The fill starts at (x, y) and extends to (x + width, y + height), not including the endpoints.
		@param color The color to fill that rectangular portion with.</haxe_doc>
		</fillRect>
		<drawRect public="1" get="inline" set="null" line="314" static="1">
			<f a="this:x:y:width:height:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws a rectangular outline of the given color.

		This function is a shortcut for just doing repeated calls to drawLine.

		@param rect The rectangle to draw the outline of.
		@param color The color to draw the outline with.</haxe_doc>
		</drawRect>
		<getImagePortion public="1" get="inline" set="null" line="329" static="1">
			<f a="this:rect">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Rectangle"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Returns a portion of the image, specified by a rectangle.

		@param rect The rectangle specifying the portion of the image to return.

		@throws OutOfBounds if the portion of the image to get is outside the bounds of the original image.
		@return A new image containing the specified portion of the original image.</haxe_doc>
		</getImagePortion>
		<setImagePortion public="1" get="inline" set="null" line="347" static="1">
			<f a="this:rect:image">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Rectangle"/>
				<x path="vision.ds.Image"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a portion of the image, specified by a rectangle, to another image.

		@param rect The rectangle specifying the portion of the image to set.
		@param image The image to set the portion of the image to.

		@throws OutOfBounds if the portion of the image to set is outside the bounds of the original image.</haxe_doc>
		</setImagePortion>
		<drawLine public="1" get="inline" set="null" line="362" static="1">
			<f a="this:x1:y1:x2:y2:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws a line from (x1, y1) to (x2, y2) using the given color.</haxe_doc>
		</drawLine>
		<drawRay2D public="1" get="inline" set="null" line="397" static="1">
			<f a="this:line:color">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Ray2D"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws an intine line specified by a Ray2D object.

		**Notice** - The (0, 0) point is **not** the same is `image.getPixel(0, 0)`,
		but rather the bottom left corner of the image - `image.getPixel(0, image.height - 1)`.

		This "vertical flip" is done to match the way the ray is draw on the cartesian plane.

		@param line The line to draw.
		@param color The color to draw the line with.

		@see Ray2D</haxe_doc>
		</drawRay2D>
		<drawLine2D public="1" get="inline" set="null" line="436" static="1">
			<f a="this:line:color">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Line2D"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws a `Line2D` object using the given color.

		If the line segment is not completely within the image, 
		it doesn't throw an error, but just draws the part of the 
		line segment that is within the image.

		@param line The line segment to draw.
		@param color The color to draw the line segment with.

		@see Line2D</haxe_doc>
		</drawLine2D>
		<drawQuadraticBezier public="1" get="inline" set="null" line="475" static="1">
			<f a="this:line:control:color:?accuracy" v="::::1000">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Line2D"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ accuracy : 1000 }</e></m></meta>
			<haxe_doc>Draws a curved line specified by a line and one control point.

		This method draws a quadratic Bezier curve.

		@param line The line to draw.
		@param control The control point of the curve.
		@param color The color to draw the line with.
		@param accuracy The number of iterations to use when drawing the curve. the higher the number, the more iterations are used, and the more accurate the curve is. for example, accuracy of 100 will draw the curve with 100 iterations, and will draw 100 points on the curve. **default is 1000**

		@see Line2D</haxe_doc>
		</drawQuadraticBezier>
		<drawCubicBezier public="1" get="inline" set="null" line="514" static="1">
			<f a="this:line:control1:control2:color:?accuracy" v=":::::1000">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Line2D"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ accuracy : 1000 }</e></m></meta>
			<haxe_doc>Draws a curved line specified by a line and two control points.

		This method draws a cubic Bezier curve.

		@param line The line to draw.
		@param control1 The first control point of the curve.
		@param control2 The second control point of the curve.
		@param color The color to draw the curve with.
		@param accuracy The number of iterations to use when drawing the curve. the higher the number, the more iterations are used, and the more accurate the curve is. for example, accuracy of 100 will draw the curve with 100 iterations, and will draw 100 points on the curve. **default is 1000**

		@see Line2D</haxe_doc>
		</drawCubicBezier>
		<fillCircle public="1" get="inline" set="null" line="554" static="1">
			<f a="this:X:Y:r:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fills a circle with the given color:

		 - The center of the circle is at (X, Y)
		 - The radius of the circle is r
		 - Anti-aliasing will not be used.

		@param x The x coordinate of the center of the circle.
		@param y The y coordinate of the center of the circle.
		@param r The radius of the circle.
		@param color The color to draw the circle with.</haxe_doc>
		</fillCircle>
		<drawCircle public="1" get="inline" set="null" line="597" static="1">
			<f a="this:X:Y:r:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws a circle of the given color:

		 - The center of the circle is at (X, Y)
		 - The radius of the circle is r
		 - Anti-aliasing will not be used.

		@param x The x coordinate of the center of the circle.
		@param y The y coordinate of the center of the circle.
		@param r The radius of the circle.
		@param color The color to draw the circle with.</haxe_doc>
		</drawCircle>
		<drawEllipse public="1" get="inline" set="null" line="627" static="1">
			<f a="this:centerX:centerY:radiusX:radiusY:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws an ellipse of the given color:

		 - The center of the ellipse is at (X, Y)
		 - The radius of the ellipse is r
		 - Anti-aliasing will not be used.

		@param centerX The x coordinate of the center of the ellipse.
		@param centerY The y coordinate of the center of the ellipse.
		@param radiusX The x radius of the ellipse.
		@param radiusY The y radius of the ellipse.
		@param color The color to draw the ellipse with.</haxe_doc>
		</drawEllipse>
		<fillColorRecursive public="1" set="method" line="710" static="1">
			<f a="this:position:color">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Recursively fills a section of the image. the section filled has to match
		`position`'s color.

		when the fill encounters a color that is not `position`'s color, it
		will stop filling in that direction.

		**Warning** - this function is recursive. This function is not slow, but can trigger
		a stack overflow if used on large images. This is only here so an implementation will be available.

		@param position The position to start filling at. you can use a Point2D or IntPoint2D.
		@param color The color to fill with.</haxe_doc>
		</fillColorRecursive>
		<fillColor public="1" set="method" line="739" static="1">
			<f a="this:position:color">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fills a section of the image. the section filled has to match
		`position`'s color.

		This uses the BFS `Breadth First Search` algorithm

		@param position The position to start filling at. you can use a Point2D or IntPoint2D.
		@param color The color to fill with.</haxe_doc>
		</fillColor>
		<fillUntilColor public="1" set="method" line="776" static="1">
			<f a="this:position:color:borderColor">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fills a section of the image. the section filled has to be bordered by pixels of color `borderColor`.

		This uses the BFS `Breadth First Search` algorithm

		@param position The position to start filling at. you can use a Point2D or IntPoint2D.
		@param color The color to fill with.
		@param borderColor The color upon which to stop filling.</haxe_doc>
		</fillUntilColor>
		<clone public="1" set="method" line="816" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Clones this image.

		Useful if you want to operate on `this` image, without modifying it:

			var blurred = Vision.gaussianBlur(image.clone());</haxe_doc>
		</clone>
		<mirror public="1" set="method" line="824" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.Image"/>
</f></mirror>
		<flip public="1" set="method" line="832" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.Image"/>
</f></flip>
		<resize public="1" get="inline" set="null" line="840" static="1"><f a="this:newWidth:newHeight:?algorithm">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.ImageResizeAlgorithm"/>
	<x path="vision.ds.Image"/>
</f></resize>
		<toString public="1" set="method" line="873" static="1">
			<f a="this:?special" v=":true">
				<x path="vision.ds.ByteArray"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ special : true }</e></m></meta>
			<haxe_doc>Gets the image as a string.

		@param special When using the `Console.hx` haxelib, images can be printed to the console
		with color. set this to false if you don't want this to happen. Set to `true` by default.</haxe_doc>
		</toString>
		<forEachPixel public="1" get="inline" set="null" line="889" static="1"><f a="this:callback">
	<x path="vision.ds.ByteArray"/>
	<f a="x:y:color">
		<x path="Int"/>
		<x path="Int"/>
		<x path="vision.ds.Color"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forEachPixel>
		<iterator public="1" get="inline" set="null" line="897" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<t path="Iterator"><c path="vision.ds.Pixel"/></t>
</f></iterator>
		<from2DArray public="1" set="method" line="969" static="1">
			<f a="array">
				<c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":from"/></meta>
		</from2DArray>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.formats._VisionImage.VisionImage_Fields_" params="" file="src/pixelimage/formats/VisionImage.hx" private="1" module="pixelimage.formats.VisionImage" final="1">
		<imageOff final="1" public="1" set="null" expr="vision.ds.Image.OFFSET" line="7" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>vision.ds.Image.OFFSET</e></m>
				<m n=":access"><e>vision.ds.Image.OFFSET</e></m>
			</meta>
			<haxe_doc>Allows injection of Bytes data directly into the Image and direct extraction</haxe_doc>
		</imageOff>
		<imageLen public="1" get="inline" set="null" line="10" static="1"><f a="image">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
</f></imageLen>
		<injectBytesInImage public="1" get="inline" set="null" line="13" static="1"><f a="bytes:image">
	<c path="haxe.io.Bytes"/>
	<x path="vision.ds.Image"/>
	<x path="Void"/>
</f></injectBytesInImage>
		<extractBytesFromImage public="1" get="inline" set="null" line="15" static="1"><f a="image">
	<x path="vision.ds.Image"/>
	<c path="haxe.io.Bytes"/>
</f></extractBytesFromImage>
	</class>
	<class path="pixelimage.iter.BoundIterator" params="" file="src/pixelimage/iter/BoundIterator.hx">
		<_boundIterator3 public="1" expr="boundIterator3">
			<f a="a:b:c">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":value"><e>boundIterator3</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">boundIterator3</font> module level field]]></haxe_doc>
		</_boundIterator3>
		<_boundIterator4 public="1" expr="boundIterator4">
			<f a="a:b:c:d">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":value"><e>boundIterator4</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">fillGrad4RoundRectangle</font> module level field]]></haxe_doc>
		</_boundIterator4>
		<_boundIteratorX public="1" expr="boundIteratorX">
			<f a="pMin:pMax">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":value"><e>boundIteratorX</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">boundIteratorX</font> module level field]]></haxe_doc>
		</_boundIteratorX>
		<new public="1" set="method" line="69">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.iter._BoundIterator.BoundIterator_Fields_" params="" file="src/pixelimage/iter/BoundIterator.hx" private="1" module="pixelimage.iter.BoundIterator" final="1">
		<boundIterator3 public="1" get="inline" set="null" line="8" static="1"><f a="a:b:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="pixelimage.iter.IteratorRange"/>
</f></boundIterator3>
		<boundIterator4 public="1" get="inline" set="null" line="27" static="1"><f a="a:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="pixelimage.iter.IteratorRange"/>
</f></boundIterator4>
		<boundIteratorX public="1" get="inline" set="null" line="52" static="1"><f a="pMin:pMax">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="pixelimage.iter.IteratorRange"/>
</f></boundIteratorX>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.iter.IntIterStart" params="" file="src/pixelimage/iter/IteratorRange.hx" module="pixelimage.iter.IteratorRange">
		<start public="1"><x path="Int"/></start>
		<max public="1"><x path="Int"/></max>
		<new public="1" set="method" line="9"><f a="min_:max_">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Like a normal IntIterator but allows access of start and max after construction and reuse.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access">
				<e>IntIterator.min</e>
				<e>IntIterator.max</e>
			</m>
		</meta>
	</class>
	<abstract path="pixelimage.iter.IteratorRange" params="" file="src/pixelimage/iter/IteratorRange.hx">
		<from>
			<icast><c path="pixelimage.iter.IntIterStart"/></icast>
			<icast field="fromIterator"><c path="IntIterator"/></icast>
		</from>
		<this><c path="pixelimage.iter.IntIterStart"/></this>
		<to><icast field="toIterStart"><x path="pixelimage.iter.IteratorRange"/></icast></to>
		<meta>
			<m n=":transitive"/>
			<m n=":access">
				<e>IntIterator.min</e>
				<e>IntIterator.max</e>
			</m>
			<m n=":forward"/>
		</meta>
		<impl><class path="pixelimage.iter._IteratorRange.IteratorRange_Impl_" params="" file="src/pixelimage/iter/IteratorRange.hx" private="1" module="pixelimage.iter.IteratorRange" final="1">
	<startLength public="1" get="inline" set="null" line="19" static="1"><f a="min:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pixelimage.iter.IteratorRange"/>
</f></startLength>
	<_new public="1" get="inline" set="null" line="22" static="1">
		<f a="min:max">
			<x path="Int"/>
			<x path="Int"/>
			<x path="pixelimage.iter.IteratorRange"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<fromIterator public="1" get="inline" set="null" line="28" static="1">
		<f a="ii">
			<c path="IntIterator"/>
			<x path="pixelimage.iter.IteratorRange"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromIterator>
	<toIterStart set="method" line="32" static="1">
		<f a="this">
			<c path="pixelimage.iter.IntIterStart"/>
			<x path="pixelimage.iter.IteratorRange"/>
		</f>
		<meta><m n=":to"/></meta>
	</toIterStart>
	<iterator public="1" get="inline" set="null" line="35" static="1"><f a="this">
	<c path="pixelimage.iter.IntIterStart"/>
	<c path="IntIterator"/>
</f></iterator>
	<adding public="1" get="inline" set="null" line="39" static="1">
		<f a="a:b">
			<x path="pixelimage.iter.IteratorRange"/>
			<x path="pixelimage.iter.IteratorRange"/>
			<x path="pixelimage.iter.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</adding>
	<add public="1" get="inline" set="null" line="43" static="1"><f a="this:b">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="pixelimage.iter.IteratorRange"/>
	<x path="pixelimage.iter.IteratorRange"/>
</f></add>
	<length public="1" get="accessor" set="accessor" static="1"><x path="Int"/></length>
	<get_length get="inline" set="null" line="51" static="1"><f a="this">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
</f></get_length>
	<set_length get="inline" set="null" line="55" static="1"><f a="this:l">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
	<contains public="1" get="inline" set="null" line="60" static="1"><f a="this:v">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></contains>
	<containsF public="1" get="inline" set="null" line="64" static="1"><f a="this:v">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></containsF>
	<isWithin public="1" get="inline" set="null" line="68" static="1"><f a="this:ir">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="pixelimage.iter.IteratorRange"/>
	<x path="Bool"/>
</f></isWithin>
	<moveRange public="1" get="inline" set="null" line="72" static="1"><f a="this:v">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Void"/>
</f></moveRange>
	<addAssign public="1" get="inline" set="null" line="78" static="1">
		<f a="a:v">
			<x path="pixelimage.iter.IteratorRange"/>
			<x path="Int"/>
			<x path="pixelimage.iter.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A += B</e></m></meta>
	</addAssign>
	<minusAssign public="1" get="inline" set="null" line="84" static="1">
		<f a="a:v">
			<x path="pixelimage.iter.IteratorRange"/>
			<x path="Int"/>
			<x path="pixelimage.iter.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A -= B</e></m></meta>
	</minusAssign>
	<ifContainMove public="1" get="inline" set="null" line="88" static="1"><f a="this:v:amount">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></ifContainMove>
	<meta><m n=":access">
	<e>IntIterator.min</e>
	<e>IntIterator.max</e>
</m></meta>
</class></impl>
	</abstract>
	<class path="pixelimage.iter._IteratorRange.IteratorRange_Impl_" params="" file="src/pixelimage/iter/IteratorRange.hx" private="1" module="pixelimage.iter.IteratorRange" final="1">
		<startLength public="1" get="inline" set="null" line="19" static="1"><f a="min:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="pixelimage.iter.IteratorRange"/>
</f></startLength>
		<_new public="1" get="inline" set="null" line="22" static="1">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<fromIterator public="1" get="inline" set="null" line="28" static="1">
			<f a="ii">
				<c path="IntIterator"/>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromIterator>
		<toIterStart set="method" line="32" static="1">
			<f a="this">
				<c path="pixelimage.iter.IntIterStart"/>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":to"/></meta>
		</toIterStart>
		<iterator public="1" get="inline" set="null" line="35" static="1"><f a="this">
	<c path="pixelimage.iter.IntIterStart"/>
	<c path="IntIterator"/>
</f></iterator>
		<adding public="1" get="inline" set="null" line="39" static="1">
			<f a="a:b">
				<x path="pixelimage.iter.IteratorRange"/>
				<x path="pixelimage.iter.IteratorRange"/>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</adding>
		<add public="1" get="inline" set="null" line="43" static="1"><f a="this:b">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="pixelimage.iter.IteratorRange"/>
	<x path="pixelimage.iter.IteratorRange"/>
</f></add>
		<length public="1" get="accessor" set="accessor" static="1"><x path="Int"/></length>
		<get_length get="inline" set="null" line="51" static="1"><f a="this">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
</f></get_length>
		<set_length get="inline" set="null" line="55" static="1"><f a="this:l">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
		<contains public="1" get="inline" set="null" line="60" static="1"><f a="this:v">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></contains>
		<containsF public="1" get="inline" set="null" line="64" static="1"><f a="this:v">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></containsF>
		<isWithin public="1" get="inline" set="null" line="68" static="1"><f a="this:ir">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="pixelimage.iter.IteratorRange"/>
	<x path="Bool"/>
</f></isWithin>
		<moveRange public="1" get="inline" set="null" line="72" static="1"><f a="this:v">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Void"/>
</f></moveRange>
		<addAssign public="1" get="inline" set="null" line="78" static="1">
			<f a="a:v">
				<x path="pixelimage.iter.IteratorRange"/>
				<x path="Int"/>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A += B</e></m></meta>
		</addAssign>
		<minusAssign public="1" get="inline" set="null" line="84" static="1">
			<f a="a:v">
				<x path="pixelimage.iter.IteratorRange"/>
				<x path="Int"/>
				<x path="pixelimage.iter.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A -= B</e></m></meta>
		</minusAssign>
		<ifContainMove public="1" get="inline" set="null" line="88" static="1"><f a="this:v:amount">
	<c path="pixelimage.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></ifContainMove>
		<meta><m n=":access">
	<e>IntIterator.min</e>
	<e>IntIterator.max</e>
</m></meta>
	</class>
	<class path="pixelimage.pixel.ColorHelp" params="" file="src/pixelimage/pixel/ColorHelp.hx">
		<rgbInt_ public="1" expr="rgbInt">
			<f a="c">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>rgbInt</e></m></meta>
		</rgbInt_>
		<colorAlpha_ public="1" expr="colorAlpha">
			<f a="color:alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>colorAlpha</e></m></meta>
		</colorAlpha_>
		<from_argb_ public="1" expr="from_argb">
			<f a="a:r:g:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>from_argb</e></m></meta>
		</from_argb_>
		<toHexInt_ public="1" expr="toHexInt">
			<f a="c">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>toHexInt</e></m></meta>
		</toHexInt_>
		<alphaChannel_ public="1" expr="alphaChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>alphaChannel</e></m></meta>
		</alphaChannel_>
		<redChannel_ public="1" expr="redChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>redChannel</e></m></meta>
		</redChannel_>
		<greenChannel_ public="1" expr="greenChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>greenChannel</e></m></meta>
		</greenChannel_>
		<blueChannel_ public="1" expr="blueChannel">
			<f a="int">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>blueChannel</e></m></meta>
		</blueChannel_>
		<argbInt_ public="1" expr="argbInt">
			<f a="a:r:g:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>argbInt</e></m></meta>
		</argbInt_>
		<alphaAvg_ public="1" expr="alphaAvg">
			<f a="a:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>alphaAvg</e></m></meta>
		</alphaAvg_>
		<redAvg_ public="1" expr="redAvg">
			<f a="a:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>redAvg</e></m></meta>
		</redAvg_>
		<greenAvg_ public="1" expr="greenAvg">
			<f a="a:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>greenAvg</e></m></meta>
		</greenAvg_>
		<blueAvg_ public="1" expr="blueAvg">
			<f a="a:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>blueAvg</e></m></meta>
		</blueAvg_>
		<argbIntAvg_ public="1" expr="argbIntAvg">
			<f a="c0:c1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>argbIntAvg</e></m></meta>
		</argbIntAvg_>
		<new public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.pixel._ColorHelp.ColorHelp_Fields_" params="" file="src/pixelimage/pixel/ColorHelp.hx" private="1" module="pixelimage.pixel.ColorHelp" final="1">
		<stringColor public="1" get="inline" set="null" line="6" static="1"><f a="col:?alpha">
	<x path="Int"/>
	<x path="Float"/>
	<c path="String"/>
</f></stringColor>
		<stringHashARGB public="1" get="inline" set="null" line="18" static="1"><f a="col">
	<x path="Int"/>
	<c path="String"/>
</f></stringHashARGB>
		<alphaChannel public="1" get="inline" set="null" line="21" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></alphaChannel>
		<redChannel public="1" get="inline" set="null" line="24" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></redChannel>
		<greenChannel public="1" get="inline" set="null" line="27" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></greenChannel>
		<blueChannel public="1" get="inline" set="null" line="30" static="1"><f a="int">
	<x path="Int"/>
	<x path="Float"/>
</f></blueChannel>
		<AplusRGB public="1" get="inline" set="null" line="33" static="1"><f a="col:alpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></AplusRGB>
		<argbInt public="1" get="inline" set="null" line="36" static="1"><f a="a:r:g:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></argbInt>
		<avg public="1" get="inline" set="null" line="39" static="1"><f a="p:q">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></avg>
		<between public="1" get="inline" set="null" line="42" static="1">
			<f a="a:b:?t" v="::0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ t : 0.5 }</e></m></meta>
		</between>
		<alphaAvg public="1" get="inline" set="null" line="45" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></alphaAvg>
		<alphaBetween public="1" get="inline" set="null" line="48" static="1">
			<f a="a:b:?t" v="::0.5">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ t : 0.5 }</e></m></meta>
		</alphaBetween>
		<redAvg public="1" get="inline" set="null" line="51" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></redAvg>
		<redBetween public="1" get="inline" set="null" line="54" static="1">
			<f a="a:b:?t" v="::0.5">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ t : 0.5 }</e></m></meta>
		</redBetween>
		<greenAvg public="1" get="inline" set="null" line="57" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></greenAvg>
		<greenBetween public="1" get="inline" set="null" line="60" static="1">
			<f a="a:b:?t" v="::0.5">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ t : 0.5 }</e></m></meta>
		</greenBetween>
		<blueAvg public="1" get="inline" set="null" line="63" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></blueAvg>
		<blueBetween public="1" get="inline" set="null" line="66" static="1">
			<f a="a:b:?t" v="::0.5">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ t : 0.5 }</e></m></meta>
		</blueBetween>
		<from_argb public="1" get="inline" set="null" line="69" static="1"><f a="a:r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></from_argb>
		<argbIntAvg public="1" get="inline" set="null" line="75" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></argbIntAvg>
		<argbIntBetween public="1" get="inline" set="null" line="81" static="1">
			<f a="a:b:?t" v="::0.5">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ t : 0.5 }</e></m></meta>
		</argbIntBetween>
		<hexToARGB public="1" get="inline" set="null" line="86" static="1"><f a="int">
	<x path="Int"/>
	<a>
		<r><x path="Float"/></r>
		<g><x path="Float"/></g>
		<b><x path="Float"/></b>
		<a><x path="Float"/></a>
	</a>
</f></hexToARGB>
		<toHexInt public="1" get="inline" set="null" line="95" static="1"><f a="c">
	<x path="Float"/>
	<x path="Int"/>
</f></toHexInt>
		<rgbInt public="1" get="inline" set="null" line="98" static="1"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></rgbInt>
		<getAlpha public="1" get="inline" set="null" line="102" static="1"><f a="c">
	<x path="Float"/>
	<x path="Float"/>
</f></getAlpha>
		<alpha1 public="1" get="inline" set="null" line="105" static="1"><f a=""><x path="Float"/></f></alpha1>
		<getColor public="1" get="inline" set="null" line="108" static="1"><f a="c">
	<x path="Float"/>
	<x path="Int"/>
</f></getColor>
		<colorAlpha public="1" get="inline" set="null" line="113" static="1"><f a="color:alpha">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Int"/>
</f></colorAlpha>
		<colorIntAlpha public="1" get="inline" set="null" line="117" static="1"><f a="color:alpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></colorIntAlpha>
		<luminosityGrey public="1" get="inline" set="null" line="138" static="1">
			<f a="color:?useAlpha" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAlpha : true }</e></m></meta>
		</luminosityGrey>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.pixel.PixAlgo" params="" file="src/pixelimage/pixel/PixAlgo.hx">
		<_boundChannel public="1" expr="boundChannel">
			<f a="f">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>boundChannel</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">boundChannel</font> module level field]]></haxe_doc>
		</_boundChannel>
		<_colBlendFunc public="1" expr="colBlendFunc">
			<f a="x1:x2:a3:a2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>colBlendFunc</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">colBlendFunc</font> module level field]]></haxe_doc>
		</_colBlendFunc>
		<_alphaBlendFunc public="1" expr="alphaBlendFunc">
			<f a="a3:a2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>alphaBlendFunc</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">alphaBlendFunc</font> module level field]]></haxe_doc>
		</_alphaBlendFunc>
		<_channelFloat public="1" expr="channelFloat">
			<f a="color">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>channelFloat</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">channelFloat</font> module level field]]></haxe_doc>
		</_channelFloat>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.pixel._PixAlgo.PixAlgo_Fields_" params="" file="src/pixelimage/pixel/PixAlgo.hx" private="1" module="pixelimage.pixel.PixAlgo" final="1">
		<boundChannel public="1" get="inline" set="null" line="4" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></boundChannel>
		<colBlendFunc public="1" get="inline" set="null" line="11" static="1"><f a="x1:x2:a3:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></colBlendFunc>
		<alphaBlendFunc public="1" get="inline" set="null" line="13" static="1"><f a="a3:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></alphaBlendFunc>
		<channelFloat public="1" get="inline" set="null" line="15" static="1"><f a="color">
	<x path="Int"/>
	<x path="Float"/>
</f></channelFloat>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="pixelimage.pixel.Pixel28" params="" file="src/pixelimage/pixel/Pixel28.hx">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>This is an abstract RGB or BGR pixel 
    not used much
    @see Pixel32</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":transient"/>
		</meta>
		<impl><class path="pixelimage.pixel._Pixel28.Pixel28_Impl_" params="" file="src/pixelimage/pixel/Pixel28.hx" private="1" module="pixelimage.pixel.Pixel28" final="1">
	<_new public="1" get="inline" set="null" line="12" static="1">
		<f a="v">
			<x path="Int"/>
			<x path="pixelimage.pixel.Pixel28"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<c1 public="1" get="accessor" set="accessor" static="1"><x path="Int"/></c1>
	<get_c1 get="inline" set="null" line="18" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_c1>
	<set_c1 get="inline" set="null" line="20" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_c1>
	<c2 public="1" get="accessor" set="accessor" static="1"><x path="Int"/></c2>
	<get_c2 get="inline" set="null" line="27" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_c2>
	<set_c2 get="inline" set="null" line="29" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_c2>
	<c3 public="1" get="accessor" set="accessor" static="1"><x path="Int"/></c3>
	<get_c3 get="inline" set="null" line="36" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_c3>
	<set_c3 get="inline" set="null" line="38" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_c3>
	<flip13 public="1" get="inline" set="null" line="44" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel28"/>
</f></flip13>
	<transferColor public="1" get="inline" set="null" line="47" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel28"/>
</f></transferColor>
	<stringHash public="1" get="inline" set="null" line="50" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></stringHash>
	<fromChannels public="1" get="inline" set="null" line="53" static="1"><f a="ch1:ch2:ch3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel28"/>
</f></fromChannels>
</class></impl>
	</abstract>
	<class path="pixelimage.pixel._Pixel28.Pixel28_Impl_" params="" file="src/pixelimage/pixel/Pixel28.hx" private="1" module="pixelimage.pixel.Pixel28" final="1">
		<_new public="1" get="inline" set="null" line="12" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="pixelimage.pixel.Pixel28"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<c1 public="1" get="accessor" set="accessor" static="1"><x path="Int"/></c1>
		<get_c1 get="inline" set="null" line="18" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_c1>
		<set_c1 get="inline" set="null" line="20" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_c1>
		<c2 public="1" get="accessor" set="accessor" static="1"><x path="Int"/></c2>
		<get_c2 get="inline" set="null" line="27" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_c2>
		<set_c2 get="inline" set="null" line="29" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_c2>
		<c3 public="1" get="accessor" set="accessor" static="1"><x path="Int"/></c3>
		<get_c3 get="inline" set="null" line="36" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_c3>
		<set_c3 get="inline" set="null" line="38" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_c3>
		<flip13 public="1" get="inline" set="null" line="44" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel28"/>
</f></flip13>
		<transferColor public="1" get="inline" set="null" line="47" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel28"/>
</f></transferColor>
		<stringHash public="1" get="inline" set="null" line="50" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></stringHash>
		<fromChannels public="1" get="inline" set="null" line="53" static="1"><f a="ch1:ch2:ch3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel28"/>
</f></fromChannels>
	</class>
	<abstract path="pixelimage.pixel.Pixel32" params="" file="src/pixelimage/pixel/Pixel32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>provides an abstract 32 bit color ARGB or ABGR
    can decompose channels c0,c1,c2,c3
    transferColor is used to flip R and B when drawing and reading from the canvas ( as required endian )
    channelBlend and alphaBlend are algorthms to blend a semi transparent pixel over another it does not transfer color channels</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":transient"/>
		</meta>
		<impl><class path="pixelimage.pixel._Pixel32.Pixel32_Impl_" params="" file="src/pixelimage/pixel/Pixel32.hx" private="1" module="pixelimage.pixel.Pixel32" final="1">
	<_new public="1" get="inline" set="null" line="14" static="1">
		<f a="v">
			<x path="Int"/>
			<x path="pixelimage.pixel.Pixel32"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<hexChannel public="1" get="inline" set="null" line="22" static="1">
		<f a="this:i">
			<x path="Int"/>
			<x path="Int"/>
			<x path="pixelimage.pixel.PixelChannel"/>
		</f>
		<haxe_doc><![CDATA[returns the 0x00 -> 0xFF number component
        in ARGB, 0 -> B, 1 -> G, 2 - R, 3 -> A]]></haxe_doc>
	</hexChannel>
	<c0 public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.pixel.PixelChannel"/></c0>
	<get_c0 get="inline" set="null" line="39" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></get_c0>
	<set_c0 get="inline" set="null" line="41" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></set_c0>
	<c1 public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.pixel.PixelChannel"/></c1>
	<get_c1 get="inline" set="null" line="48" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></get_c1>
	<set_c1 get="inline" set="null" line="50" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></set_c1>
	<c2 public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.pixel.PixelChannel"/></c2>
	<get_c2 get="inline" set="null" line="57" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></get_c2>
	<set_c2 get="inline" set="null" line="59" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></set_c2>
	<c3 public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.pixel.PixelChannel"/></c3>
	<get_c3 get="inline" set="null" line="66" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></get_c3>
	<set_c3 get="inline" set="null" line="68" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></set_c3>
	<flip13 public="1" get="inline" set="null" line="74" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></flip13>
	<transferColor public="1" get="inline" set="null" line="77" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></transferColor>
	<stringHash public="1" get="inline" set="null" line="80" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></stringHash>
	<isTransparent public="1" get="inline" set="null" line="83" static="1"><f a="this">
	<x path="Int"/>
	<x path="Bool"/>
</f></isTransparent>
	<fromPixel28Alpha public="1" get="inline" set="null" line="86" static="1"><f a="col:alpha">
	<x path="pixelimage.pixel.Pixel28"/>
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></fromPixel28Alpha>
	<fromChannels public="1" get="inline" set="null" line="89" static="1"><f a="ch0:ch1:ch2:ch3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></fromChannels>
	<from_argb public="1" get="inline" set="null" line="92" static="1"><f a="a:r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></from_argb>
	<maskPixel public="1" get="inline" set="null" line="98" static="1"><f a="this:m">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></maskPixel>
	<channelBlend public="1" get="inline" set="null" line="118" static="1"><f a="this:ch0:ch1:ch2:ch3">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></channelBlend>
	<alphaBlend public="1" get="inline" set="null" line="136" static="1">
		<f a="this:rhs">
			<x path="Int"/>
			<x path="pixelimage.pixel.Pixel32"/>
			<x path="pixelimage.pixel.Pixel32"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</alphaBlend>
	<colBlendFunc get="inline" set="null" line="154" static="1"><f a="x1:x2:a3:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></colBlendFunc>
	<alphaBlendFunc get="inline" set="null" line="157" static="1"><f a="a3:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></alphaBlendFunc>
</class></impl>
	</abstract>
	<class path="pixelimage.pixel._Pixel32.Pixel32_Impl_" params="" file="src/pixelimage/pixel/Pixel32.hx" private="1" module="pixelimage.pixel.Pixel32" final="1">
		<_new public="1" get="inline" set="null" line="14" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="pixelimage.pixel.Pixel32"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<hexChannel public="1" get="inline" set="null" line="22" static="1">
			<f a="this:i">
				<x path="Int"/>
				<x path="Int"/>
				<x path="pixelimage.pixel.PixelChannel"/>
			</f>
			<haxe_doc><![CDATA[returns the 0x00 -> 0xFF number component
        in ARGB, 0 -> B, 1 -> G, 2 - R, 3 -> A]]></haxe_doc>
		</hexChannel>
		<c0 public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.pixel.PixelChannel"/></c0>
		<get_c0 get="inline" set="null" line="39" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></get_c0>
		<set_c0 get="inline" set="null" line="41" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></set_c0>
		<c1 public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.pixel.PixelChannel"/></c1>
		<get_c1 get="inline" set="null" line="48" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></get_c1>
		<set_c1 get="inline" set="null" line="50" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></set_c1>
		<c2 public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.pixel.PixelChannel"/></c2>
		<get_c2 get="inline" set="null" line="57" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></get_c2>
		<set_c2 get="inline" set="null" line="59" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></set_c2>
		<c3 public="1" get="accessor" set="accessor" static="1"><x path="pixelimage.pixel.PixelChannel"/></c3>
		<get_c3 get="inline" set="null" line="66" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></get_c3>
		<set_c3 get="inline" set="null" line="68" static="1"><f a="this:v">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
</f></set_c3>
		<flip13 public="1" get="inline" set="null" line="74" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></flip13>
		<transferColor public="1" get="inline" set="null" line="77" static="1"><f a="this">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></transferColor>
		<stringHash public="1" get="inline" set="null" line="80" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></stringHash>
		<isTransparent public="1" get="inline" set="null" line="83" static="1"><f a="this">
	<x path="Int"/>
	<x path="Bool"/>
</f></isTransparent>
		<fromPixel28Alpha public="1" get="inline" set="null" line="86" static="1"><f a="col:alpha">
	<x path="pixelimage.pixel.Pixel28"/>
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></fromPixel28Alpha>
		<fromChannels public="1" get="inline" set="null" line="89" static="1"><f a="ch0:ch1:ch2:ch3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></fromChannels>
		<from_argb public="1" get="inline" set="null" line="92" static="1"><f a="a:r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></from_argb>
		<maskPixel public="1" get="inline" set="null" line="98" static="1"><f a="this:m">
	<x path="Int"/>
	<x path="pixelimage.pixel.Pixel32"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></maskPixel>
		<channelBlend public="1" get="inline" set="null" line="118" static="1"><f a="this:ch0:ch1:ch2:ch3">
	<x path="Int"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.PixelChannel"/>
	<x path="pixelimage.pixel.Pixel32"/>
</f></channelBlend>
		<alphaBlend public="1" get="inline" set="null" line="136" static="1">
			<f a="this:rhs">
				<x path="Int"/>
				<x path="pixelimage.pixel.Pixel32"/>
				<x path="pixelimage.pixel.Pixel32"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</alphaBlend>
		<colBlendFunc get="inline" set="null" line="154" static="1"><f a="x1:x2:a3:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></colBlendFunc>
		<alphaBlendFunc get="inline" set="null" line="157" static="1"><f a="a3:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></alphaBlendFunc>
	</class>
	<abstract path="pixelimage.pixel.PixelChannel" params="" file="src/pixelimage/pixel/PixelChannel.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast field="toHexInt"><x path="Float"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="colIntToFloat"><x path="Float"/></icast>
			<icast field="stringHash"><c path="String"/></icast>
		</to>
		<haxe_doc>helper for working with colour channels
    so providing float ones for calculations and bounding for when converting back</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":transient"/>
		</meta>
		<impl><class path="pixelimage.pixel._PixelChannel.PixelChannel_Impl_" params="" file="src/pixelimage/pixel/PixelChannel.hx" private="1" module="pixelimage.pixel.PixelChannel" final="1">
	<_new public="1" get="inline" set="null" line="9" static="1">
		<f a="v">
			<x path="Int"/>
			<x path="pixelimage.pixel.PixelChannel"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<toHexInt public="1" get="inline" set="null" line="14" static="1">
		<f a="c">
			<x path="Float"/>
			<x path="pixelimage.pixel.PixelChannel"/>
		</f>
		<meta><m n=":from"/></meta>
	</toHexInt>
	<colIntToFloat public="1" get="inline" set="null" line="17" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":to"/></meta>
	</colIntToFloat>
	<stringHash public="1" get="inline" set="null" line="20" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":to"/></meta>
	</stringHash>
	<boundChannel public="1" get="inline" set="null" line="22" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></boundChannel>
</class></impl>
	</abstract>
	<class path="pixelimage.pixel._PixelChannel.PixelChannel_Impl_" params="" file="src/pixelimage/pixel/PixelChannel.hx" private="1" module="pixelimage.pixel.PixelChannel" final="1">
		<_new public="1" get="inline" set="null" line="9" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="pixelimage.pixel.PixelChannel"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<toHexInt public="1" get="inline" set="null" line="14" static="1">
			<f a="c">
				<x path="Float"/>
				<x path="pixelimage.pixel.PixelChannel"/>
			</f>
			<meta><m n=":from"/></meta>
		</toHexInt>
		<colIntToFloat public="1" get="inline" set="null" line="17" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":to"/></meta>
		</colIntToFloat>
		<stringHash public="1" get="inline" set="null" line="20" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":to"/></meta>
		</stringHash>
		<boundChannel public="1" get="inline" set="null" line="22" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></boundChannel>
	</class>
	<class path="pixelimage.pixel.PixelsTransform" params="" file="src/pixelimage/pixel/PixelsTransform.hx">
		<_pixelsTransform public="1" expr="pixelsTransform">
			<f a="imageTarget:imageSource:transformFunc:xTarget:yTarget:xSource:ySource:w:h">
				<x path="pixelimage.Pixelimage"/>
				<x path="pixelimage.Pixelimage"/>
				<f a="colorTarget:colorSource">
					<x path="pixelimage.pixel.Pixel32"/>
					<x path="pixelimage.pixel.Pixel32"/>
					<x path="pixelimage.pixel.Pixel28"/>
				</f>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>pixelsTransform</e></m></meta>
			<haxe_doc><![CDATA[<font color="LightPink" font-weight:"Bold">pixelsTransform</font> module level field]]></haxe_doc>
		</_pixelsTransform>
		<new public="1" set="method" line="32">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="pixelimage.pixel._PixelsTransform.PixelsTransform_Fields_" params="" file="src/pixelimage/pixel/PixelsTransform.hx" private="1" module="pixelimage.pixel.PixelsTransform" final="1">
		<pixelsTransform public="1" set="method" line="8" static="1"><f a="imageTarget:imageSource:transformFunc:xTarget:yTarget:xSource:ySource:w:h">
	<x path="pixelimage.Pixelimage"/>
	<x path="pixelimage.Pixelimage"/>
	<f a="colorTarget:colorSource">
		<x path="pixelimage.pixel.Pixel32"/>
		<x path="pixelimage.pixel.Pixel32"/>
		<x path="pixelimage.pixel.Pixel28"/>
	</f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pixelsTransform>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.pixel._TwoGrad.TwoGrad_" params="" file="src/pixelimage/pixel/TwoGrad.hx" private="1" module="pixelimage.pixel.TwoGrad">
		<colorClock public="1"><x path="Int"/></colorClock>
		<colorAnti public="1"><x path="Int"/></colorAnti>
		<new public="1" set="method" line="8"><f a="colorClock:colorAnti">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="pixelimage.pixel.TwoGrad" params="" file="src/pixelimage/pixel/TwoGrad.hx">
		<from><icast><c path="pixelimage.pixel._TwoGrad.TwoGrad_"/></icast></from>
		<this><c path="pixelimage.pixel._TwoGrad.TwoGrad_"/></this>
		<meta>
			<m n=":forward"/>
			<m n=":transitive"/>
			<m n=":access"><e>cornerContour.color.TwoGrad</e></m>
		</meta>
		<impl><class path="pixelimage.pixel._TwoGrad.TwoGrad_Impl_" params="" file="src/pixelimage/pixel/TwoGrad.hx" private="1" module="pixelimage.pixel.TwoGrad" final="1">
	<_new public="1" get="inline" set="null" line="17" static="1">
		<f a="colorClock:colorAnti">
			<x path="Int"/>
			<x path="Int"/>
			<x path="pixelimage.pixel.TwoGrad"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<average public="1" get="inline" set="null" line="22" static="1"><f a="this">
	<c path="pixelimage.pixel._TwoGrad.TwoGrad_"/>
	<x path="Int"/>
</f></average>
	<meta><m n=":access"><e>cornerContour.color.TwoGrad</e></m></meta>
</class></impl>
	</abstract>
	<class path="pixelimage.pixel._TwoGrad.TwoGrad_Impl_" params="" file="src/pixelimage/pixel/TwoGrad.hx" private="1" module="pixelimage.pixel.TwoGrad" final="1">
		<_new public="1" get="inline" set="null" line="17" static="1">
			<f a="colorClock:colorAnti">
				<x path="Int"/>
				<x path="Int"/>
				<x path="pixelimage.pixel.TwoGrad"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<average public="1" get="inline" set="null" line="22" static="1"><f a="this">
	<c path="pixelimage.pixel._TwoGrad.TwoGrad_"/>
	<x path="Int"/>
</f></average>
		<meta><m n=":access"><e>cornerContour.color.TwoGrad</e></m></meta>
	</class>
	<class path="pixelimage.textureImage._TestNineSlice.TestNineSlice_Fields_" params="" file="src/pixelimage/textureImage/TestNineSlice.hx" private="1" module="pixelimage.textureImage.TestNineSlice" final="1"><testNineSliceButton public="1" set="method" line="3" static="1"><f a=""><c path="String"/></f></testNineSliceButton></class>
	<class path="pixelimage.textureImage._TestTiger.TestTiger_Fields_" params="" file="src/pixelimage/textureImage/TestTiger.hx" private="1" module="pixelimage.textureImage.TestTiger" final="1"><testTiger public="1" set="method" line="3" static="1"><f a=""><c path="String"/></f></testTiger></class>
	<class path="pixelimage.triangleGML.coreShape.ShapeInterface" params="" file="src/pixelimage/triangleGML/coreShape/ShapeInterface.hx" interface="1">
		<setParameter public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<translate public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<clear public="1" set="method"><f a="pixelShape:color">
	<x path="pixelimage.Pixelshape"/>
	<x path="Int"/>
	<x path="pixelimage.Pixelshape"/>
</f></clear>
		<hit public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hit>
		<render public="1" set="method"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
	</class>
	<class path="pixelimage.triangleGML.coreShape.GroupShape" params="" file="src/pixelimage/triangleGML/coreShape/GroupShape.hx" abstract="1">
		<implements path="pixelimage.triangleGML.coreShape.ShapeInterface"/>
		<isDirty expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isDirty>
		<visibility public="1"><x path="Bool"/></visibility>
		<opacity public="1"><x path="Float"/></opacity>
		<offX public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</offX>
		<offY public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</offY>
		<hitObj public="1" expr="null">
			<x path="Null"><c path="pixelimage.algo.IhitObj"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</hitObj>
		<setParameter public="1" set="method" line="37"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<translate public="1" set="method" line="47"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<render public="1" set="method" line="51"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<clear public="1" set="method" line="54"><f a="pixelShape:color">
	<x path="pixelimage.Pixelshape"/>
	<x path="Int"/>
	<x path="pixelimage.Pixelshape"/>
</f></clear>
		<hit public="1" set="method" line="57"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hit>
		<new public="1" set="method" line="33">
			<f a="?opacity:?visibility" v="1.:true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.triangleGML.coreShape.BasicShape" params="" file="src/pixelimage/triangleGML/coreShape/BasicShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.GroupShape"/>
		<dashLength public="1" expr="2." line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.</e></m></meta>
		</dashLength>
		<gapLength public="1" expr="1." line="12" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</gapLength>
		<strokeColor public="1"><x path="Int"/></strokeColor>
		<strokeWidth public="1"><x path="Float"/></strokeWidth>
		<strokeDashGapArray public="1"><x path="Null"><c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c></x></strokeDashGapArray>
		<setParameter public="1" set="method" line="37" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<new public="1" set="method" line="30">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray" v="1.:true:0x000000:1.:null">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.triangleGML.contour.ArrowShape" params="" file="src/pixelimage/triangleGML/contour/ArrowShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<both public="1"><x path="Bool"/></both>
		<flare public="1"><x path="Bool"/></flare>
		<reverseFlare public="1"><x path="Bool"/></reverseFlare>
		<arrowWidth public="1"><x path="Float"/></arrowWidth>
		<arrowHeight public="1"><x path="Float"/></arrowHeight>
		<soft public="1"><x path="Float"/></soft>
		<setParameter public="1" set="method" line="47" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="73" override="1"><f a="pixelImage">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="34">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?both:?flare:?reverseFlare:?x1:?y1:?x2:?y2:?arrowWidth:?arrowHeight:?soft" v="1.:true:0xFFF00000:1.:null:false:false:false:0.:0.:0.:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ soft : 0., arrowHeight : 0., arrowWidth : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., reverseFlare : false, flare : false, both : false, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0xFFF00000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.coreShape.FillShape" params="" file="src/pixelimage/triangleGML/coreShape/FillShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<fill public="1"><x path="Int"/></fill>
		<setParameter public="1" set="method" line="20" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<new public="1" set="method" line="16">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill" v="1.:true:0x000000:1.:null:0x000000">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.triangleGML.contour.CubicCurveShape" params="" file="src/pixelimage/triangleGML/contour/CubicCurveShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<x3 public="1"><x path="Float"/></x3>
		<y3 public="1"><x path="Float"/></y3>
		<x4 public="1"><x path="Float"/></x4>
		<y4 public="1"><x path="Float"/></y4>
		<setParameter public="1" set="method" line="43" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="65" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="32">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?x1:?y1:?x2:?y2:?x3:?y3:?x4:?y4" v="1.:true:0x000000:1.:null:0x000000:0.:0.:0.:0.:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y4 : 0., x4 : 0., y3 : 0., x3 : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.LineGridShape" params="" file="src/pixelimage/triangleGML/contour/LineGridShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<delta public="1"><x path="Float"/></delta>
		<deltaH public="1"><x path="Float"/></deltaH>
		<setParameter public="1" set="method" line="36" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="54" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="27">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?left:?top:?width:?height:?delta:?deltaH" v="1.:true:0xFFF00000:1.:null:0.:0.:1.:1.:1.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ deltaH : 0., delta : 1., height : 1., width : 1., top : 0., left : 0., strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0xFFF00000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.LineShape" params="" file="src/pixelimage/triangleGML/contour/LineShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<soft public="1"><x path="Float"/></soft>
		<luxury public="1"><x path="Bool"/></luxury>
		<setParameter public="1" set="method" line="36" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="55" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="27">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?x1:?y1:?x2:?y2:?soft:?luxury" v="1.:true:0xFFF00000:1.:null:0.:0.:0.:0.:0.:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ luxury : false, soft : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0xFFF00000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.PolyLineShape" params="" file="src/pixelimage/triangleGML/contour/PolyLineShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<points public="1"><x path="Null"><c path="Array"><x path="Float"/></c></x></points>
		<setParameter public="1" set="method" line="23" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="32" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="19">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?points" v="1.:true:0x000000:1.:null:0x000000:null">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ points : null, fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.QuadCurveShape" params="" file="src/pixelimage/triangleGML/contour/QuadCurveShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<x3 public="1"><x path="Float"/></x3>
		<y3 public="1"><x path="Float"/></y3>
		<thru public="1"><x path="Bool"/></thru>
		<setParameter public="1" set="method" line="41" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="61" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="31">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?thru:?x1:?y1:?x2:?y2:?x3:?y3" v="1.:true:0x000000:1.:null:0x000000:false:0.:0.:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y3 : 0., x3 : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., thru : false, fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.QuadShape" params="" file="src/pixelimage/triangleGML/contour/QuadShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<aX public="1"><x path="Float"/></aX>
		<aY public="1"><x path="Float"/></aY>
		<bX public="1"><x path="Float"/></bX>
		<bY public="1"><x path="Float"/></bY>
		<cX public="1"><x path="Float"/></cX>
		<cY public="1"><x path="Float"/></cY>
		<dX public="1"><x path="Float"/></dX>
		<dY public="1"><x path="Float"/></dY>
		<soft public="1"><x path="Float"/></soft>
		<luxury public="1"><x path="Bool"/></luxury>
		<setParameter public="1" set="method" line="44" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="70" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<clear public="1" set="method" line="83" override="1"><f a="pixelShape:color">
	<x path="pixelimage.Pixelshape"/>
	<x path="Int"/>
	<x path="pixelimage.Pixelshape"/>
</f></clear>
		<new public="1" set="method" line="31">
			<f a="?opacity:?visibility:?strokeColor:?aX:?aY:?bX:?bY:?cX:?cY:?dX:?dY:?soft:?luxury" v="1.:true:0xFFF00000:0.:0.:1.:0.:1.:1.:0.:1.:0.:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ luxury : false, soft : 0., dY : 1., dX : 0., cY : 1., cX : 1., bY : 0., bX : 1., aY : 0., aX : 0., strokeColor : 0xFFF00000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.QuadSoftShape" params="" file="src/pixelimage/triangleGML/contour/QuadSoftShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<aX public="1"><x path="Float"/></aX>
		<aY public="1"><x path="Float"/></aY>
		<bX public="1"><x path="Float"/></bX>
		<bY public="1"><x path="Float"/></bY>
		<cX public="1"><x path="Float"/></cX>
		<cY public="1"><x path="Float"/></cY>
		<dX public="1"><x path="Float"/></dX>
		<dY public="1"><x path="Float"/></dY>
		<soft public="1"><x path="Float"/></soft>
		<softAB public="1"><x path="Bool"/></softAB>
		<softBC public="1"><x path="Bool"/></softBC>
		<softCD public="1"><x path="Bool"/></softCD>
		<softDA public="1"><x path="Bool"/></softDA>
		<setParameter public="1" set="method" line="54" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="86" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="38">
			<f a="?opacity:?visibility:?strokeColor:?aX:?aY:?bX:?bY:?cX:?cY:?dX:?dY:?soft:?softAB:?softBC:?softCD:?softDA" v="1.:true:0xFFF00000:0.:0.:1.:0.:1.:1.:0.:1.:40.:true:true:true:true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ softDA : true, softCD : true, softBC : true, softAB : true, soft : 40., dY : 1., dX : 0., cY : 1., cX : 1., bY : 0., bX : 1., aY : 0., aX : 0., strokeColor : 0xFFF00000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.QuintShape" params="" file="src/pixelimage/triangleGML/contour/QuintShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<aX public="1"><x path="Float"/></aX>
		<aY public="1"><x path="Float"/></aY>
		<bX public="1"><x path="Float"/></bX>
		<bY public="1"><x path="Float"/></bY>
		<cX public="1"><x path="Float"/></cX>
		<cY public="1"><x path="Float"/></cY>
		<dX public="1"><x path="Float"/></dX>
		<dY public="1"><x path="Float"/></dY>
		<softC public="1"><x path="Float"/></softC>
		<setParameter public="1" set="method" line="41" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="65" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="29">
			<f a="?opacity:?visibility:?strokeColor:?aX:?aY:?bX:?bY:?cX:?cY:?dX:?dY:?softC" v="1.:true:0xFFF00000:0.:0.:1.:0.:1.:1.:0.:1.:10.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ softC : 10., dY : 1., dX : 0., cY : 1., cX : 1., bY : 0., bX : 1., aY : 0., aX : 0., strokeColor : 0xFFF00000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.SoftEllipseShape" params="" file="src/pixelimage/triangleGML/contour/SoftEllipseShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<softC public="1"><x path="Float"/></softC>
		<setParameter public="1" set="method" line="28" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="44" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="21">
			<f a="?opacity:?visibility:?strokeColor:?left:?top:?width:?height:?softC" v="1.:true:0x000000:0.:0.:1.:1.:10.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ softC : 10., height : 1., width : 1., top : 0., left : 0., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.ThruCurveShape" params="" file="src/pixelimage/triangleGML/contour/ThruCurveShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<x3 public="1"><x path="Float"/></x3>
		<y3 public="1"><x path="Float"/></y3>
		<setParameter public="1" set="method" line="38" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="56" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="29">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?x1:?y1:?x2:?y2:?x3:?y3" v="1.:true:0x000000:1.:null:0x000000:0.:0.:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y3 : 0., x3 : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.contour.TriangleSoftShape" params="" file="src/pixelimage/triangleGML/contour/TriangleSoftShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<aX public="1"><x path="Float"/></aX>
		<aY public="1"><x path="Float"/></aY>
		<bX public="1"><x path="Float"/></bX>
		<bY public="1"><x path="Float"/></bY>
		<cX public="1"><x path="Float"/></cX>
		<cY public="1"><x path="Float"/></cY>
		<soft3 public="1"><x path="Float"/></soft3>
		<softAB public="1"><x path="Bool"/></softAB>
		<softBC public="1"><x path="Bool"/></softBC>
		<softCA public="1"><x path="Bool"/></softCA>
		<setParameter public="1" set="method" line="46" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="72" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="32">
			<f a="?opacity:?visibility:?strokeColor:?aX:?aY:?bX:?bY:?cX:?cY:?soft3:?softAB:?softBC:?softCA" v="1.:true:0xFFF00000:0.:0.:1.:0.:1.:1.:10.:true:true:true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ softCA : true, softBC : true, softAB : true, soft3 : 10., cY : 1., cX : 1., bY : 0., bX : 1., aY : 0., aX : 0., strokeColor : 0xFFF00000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.coreShape.BasicGradient" params="" file="src/pixelimage/triangleGML/coreShape/BasicGradient.hx">
		<extends path="pixelimage.triangleGML.coreShape.GroupShape"/>
		<cornerColors public="1" expr="new Array&lt;Int&gt;()">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Int>()]]></e></m></meta>
		</cornerColors>
		<setParameter public="1" set="method" line="15" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<new public="1" set="method" line="8">
			<f a="?opacity:?visibility:?cornerColors" v="1.:true:null">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cornerColors : null, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<abstract path="pixelimage.triangleGML.coreShape.DashGap" params="" file="src/pixelimage/triangleGML/coreShape/BasicShape.hx" module="pixelimage.triangleGML.coreShape.BasicShape">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="pixelimage.triangleGML.coreShape._BasicShape.DashGap_Impl_" params="" file="src/pixelimage/triangleGML/coreShape/BasicShape.hx" private="1" module="pixelimage.triangleGML.coreShape.BasicShape" extern="1" final="1">
	<DASH public="1" get="inline" set="null" expr="cast &quot;dash&quot;" line="5" static="1">
		<x path="pixelimage.triangleGML.coreShape.DashGap"/>
		<meta>
			<m n=":value"><e>cast "dash"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DASH>
	<GAP public="1" get="inline" set="null" expr="cast &quot;gap&quot;" line="6" static="1">
		<x path="pixelimage.triangleGML.coreShape.DashGap"/>
		<meta>
			<m n=":value"><e>cast "gap"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GAP>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="pixelimage.triangleGML.coreShape._BasicShape.DashGap_Impl_" params="" file="src/pixelimage/triangleGML/coreShape/BasicShape.hx" private="1" module="pixelimage.triangleGML.coreShape.BasicShape" extern="1" final="1">
		<DASH public="1" get="inline" set="null" expr="cast &quot;dash&quot;" line="5" static="1">
			<x path="pixelimage.triangleGML.coreShape.DashGap"/>
			<meta>
				<m n=":value"><e>cast "dash"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DASH>
		<GAP public="1" get="inline" set="null" expr="cast &quot;gap&quot;" line="6" static="1">
			<x path="pixelimage.triangleGML.coreShape.DashGap"/>
			<meta>
				<m n=":value"><e>cast "gap"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GAP>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="pixelimage.triangleGML.coreShape.PatternShape" params="" file="src/pixelimage/triangleGML/coreShape/PatternShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<strokeColor0 public="1"><x path="Int"/></strokeColor0>
		<strokeColor1 public="1"><x path="Int"/></strokeColor1>
		<fillColor0 public="1"><x path="Int"/></fillColor0>
		<fillColor1 public="1"><x path="Int"/></fillColor1>
		<strokePatternFill public="1"><x path="Null"><c path="Array"><x path="Bool"/></c></x></strokePatternFill>
		<strokePatternWidth public="1"><x path="Int"/></strokePatternWidth>
		<strokePatternHeight public="1"><x path="Int"/></strokePatternHeight>
		<strokePatternAcross public="1"><x path="Bool"/></strokePatternAcross>
		<strokePatternScale public="1"><x path="Int"/></strokePatternScale>
		<fillPatternFill public="1"><x path="Null"><c path="Array"><x path="Bool"/></c></x></fillPatternFill>
		<fillPatternWidth public="1"><x path="Int"/></fillPatternWidth>
		<fillPatternHeight public="1"><x path="Int"/></fillPatternHeight>
		<fillPatternAcross public="1"><x path="Bool"/></fillPatternAcross>
		<fillPatternScale public="1"><x path="Int"/></fillPatternScale>
		<tiledBorder public="1"><x path="Bool"/></tiledBorder>
		<tileImageStroke public="1"><x path="pixelimage.Pixelshape"/></tileImageStroke>
		<tileImageFill public="1"><x path="pixelimage.Pixelshape"/></tileImageFill>
		<setParameter public="1" set="method" line="77" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="124" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<buildPatternTemplates public="1" set="method" line="129"><f a=""><x path="Void"/></f></buildPatternTemplates>
		<new public="1" set="method" line="51">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?fillColor0:?fillColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fillPatternFill:?fillPatternWidth:?fillPatternHeight:?fillPatternAcross:?fillPatternScale" v="1.:true:0x00000000:1.:null:0x00000000:0x00000000:0x00000000:0x00000000:null:null:null:true:1:null:16:16:true:1">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillPatternScale : 1, fillPatternAcross : true, fillPatternHeight : 16, fillPatternWidth : 16, fillPatternFill : null, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, fillColor1 : 0x00000000, fillColor0 : 0x00000000, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x00000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.triangleGML.coreShape.PatternStroke" params="" file="src/pixelimage/triangleGML/coreShape/PatternStroke.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicShape"/>
		<strokeColor0 public="1"><x path="Int"/></strokeColor0>
		<strokeColor1 public="1"><x path="Int"/></strokeColor1>
		<strokePatternFill public="1"><x path="Null"><c path="Array"><x path="Bool"/></c></x></strokePatternFill>
		<strokePatternWidth public="1"><x path="Int"/></strokePatternWidth>
		<strokePatternHeight public="1"><x path="Int"/></strokePatternHeight>
		<strokePatternAcross public="1"><x path="Bool"/></strokePatternAcross>
		<strokePatternScale public="1"><x path="Int"/></strokePatternScale>
		<tileImageStroke public="1"><x path="pixelimage.Pixelshape"/></tileImageStroke>
		<setParameter public="1" set="method" line="46" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="73" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<buildPatternTemplates public="1" set="method" line="77"><f a=""><x path="Void"/></f></buildPatternTemplates>
		<new public="1" set="method" line="34">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale" v="1.:true:0x00000000:1.:null:0x00000000:0x00000000:null:null:null:true:1">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x00000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.triangleGML.coreShape.TriangleGML" params="" file="src/pixelimage/triangleGML/coreShape/TriangleGML.hx">
		<withString public="1" get="inline" set="null" line="38" static="1">
			<f a="pixelShape:str:?x:?y" v="::0.:0.">
				<x path="pixelimage.Pixelshape"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixelimage.triangleGML.coreShape.TriangleGML"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</withString>
		<pixelShape><x path="pixelimage.Pixelshape"/></pixelShape>
		<xml><c path="Xml"/></xml>
		<offX><x path="Float"/></offX>
		<offY><x path="Float"/></offY>
		<shapes public="1"><c path="Array"><c path="pixelimage.triangleGML.coreShape.ShapeInterface"/></c></shapes>
		<addShape public="1" set="method" line="30">
			<f a="str:?x:?y" v=":0.:0.">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixelimage.triangleGML.coreShape.TriangleGML"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</addShape>
		<process set="method" line="44"><f a=""><x path="Void"/></f></process>
		<processShape set="method" line="49"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></processShape>
		<new public="1" set="method" line="23">
			<f a="pixelShape:xml:?x:?y" v="::0.:0.">
				<x path="pixelimage.Pixelshape"/>
				<c path="Xml"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</new>
	</class>
	<abstract path="pixelimage.triangleGML.coreShape.TriangleGMLname" params="" file="src/pixelimage/triangleGML/coreShape/TriangleGML.hx" module="pixelimage.triangleGML.coreShape.TriangleGML">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="pixelimage.triangleGML.coreShape._TriangleGML.TriangleGMLname_Impl_" params="" file="src/pixelimage/triangleGML/coreShape/TriangleGML.hx" private="1" module="pixelimage.triangleGML.coreShape.TriangleGML" extern="1" final="1">
	<ARROW_SHAPE public="1" get="inline" set="null" expr="cast &quot;ArrowShape&quot;" line="67" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "ArrowShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ARROW_SHAPE>
	<CUBIC_CURVE_SHAPE public="1" get="inline" set="null" expr="cast &quot;CubicCurveShape&quot;" line="68" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "CubicCurveShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CUBIC_CURVE_SHAPE>
	<LINE_GRID_SHAPE public="1" get="inline" set="null" expr="cast &quot;LineGridShape&quot;" line="69" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "LineGridShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LINE_GRID_SHAPE>
	<LINE_SHAPE public="1" get="inline" set="null" expr="cast &quot;LineShape&quot;" line="70" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "LineShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LINE_SHAPE>
	<POLY_LINE_SHAPE public="1" get="inline" set="null" expr="cast &quot;PolyLineShape&quot;" line="71" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "PolyLineShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POLY_LINE_SHAPE>
	<QUAD_CURVE_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuadCurveShape&quot;" line="72" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "QuadCurveShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUAD_CURVE_SHAPE>
	<QUAD_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuadShape&quot;" line="73" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "QuadShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUAD_SHAPE>
	<QUAD_SOFT_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuadSoftShape&quot;" line="74" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "QuadSoftShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUAD_SOFT_SHAPE>
	<QUINT_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuintShape&quot;" line="75" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "QuintShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUINT_SHAPE>
	<SOFT_ELLIPSE_SHAPE public="1" get="inline" set="null" expr="cast &quot;SoftEllipseShape&quot;" line="76" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "SoftEllipseShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SOFT_ELLIPSE_SHAPE>
	<THRU_CURVE_SHAPE public="1" get="inline" set="null" expr="cast &quot;ThruCurveShape&quot;" line="77" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "ThruCurveShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</THRU_CURVE_SHAPE>
	<TRIANGLE_SOFT_SHAPE public="1" get="inline" set="null" expr="cast &quot;TriangleSoftShape&quot;" line="78" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "TriangleSoftShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TRIANGLE_SOFT_SHAPE>
	<ARROW_THICK_GRADIENT public="1" get="inline" set="null" expr="cast &quot;ArrowThickGradient&quot;" line="80" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "ArrowThickGradient"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ARROW_THICK_GRADIENT>
	<ELLIPSE_RADIAL_GRADIENT public="1" get="inline" set="null" expr="cast &quot;EllipseRadialGradient&quot;" line="81" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "EllipseRadialGradient"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ELLIPSE_RADIAL_GRADIENT>
	<PATH_ELEMENT_THICK_GRADIENT public="1" get="inline" set="null" expr="cast &quot;PathElementThickGradient&quot;" line="82" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "PathElementThickGradient"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PATH_ELEMENT_THICK_GRADIENT>
	<QUAD_GRADIENT public="1" get="inline" set="null" expr="cast &quot;QuadGradient&quot;" line="83" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "QuadGradient"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUAD_GRADIENT>
	<TRIANGLE_GRADIENT public="1" get="inline" set="null" expr="cast &quot;TriangleGradient&quot;" line="84" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "TriangleGradient"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TRIANGLE_GRADIENT>
	<LINE_GRADIENT public="1" get="inline" set="null" expr="cast &quot;LineGradient&quot;" line="86" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "LineGradient"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LINE_GRADIENT>
	<POLY_LINE_GRADIENT public="1" get="inline" set="null" expr="cast &quot;PolyLineGradient&quot;" line="87" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "PolyLineGradient"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POLY_LINE_GRADIENT>
	<CUBIC_CURVE_PATTERN public="1" get="inline" set="null" expr="cast &quot;CubicCurvePattern&quot;" line="89" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "CubicCurvePattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CUBIC_CURVE_PATTERN>
	<LINE_PATTERN public="1" get="inline" set="null" expr="cast &quot;LinePattern&quot;" line="90" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "LinePattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LINE_PATTERN>
	<QUAD_PATTERN public="1" get="inline" set="null" expr="cast &quot;QuadPattern&quot;" line="91" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "QuadPattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUAD_PATTERN>
	<TRIANGLE_PATTERN public="1" get="inline" set="null" expr="cast &quot;TrianglePattern&quot;" line="92" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "TrianglePattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TRIANGLE_PATTERN>
	<ARC_PATTERN public="1" get="inline" set="null" expr="cast &quot;ArcPattern&quot;" line="94" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "ArcPattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ARC_PATTERN>
	<CIRCLE_PATTERN public="1" get="inline" set="null" expr="cast &quot;CirclePattern&quot;" line="95" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "CirclePattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CIRCLE_PATTERN>
	<ELLIPSE_PATTERN public="1" get="inline" set="null" expr="cast &quot;EllipsePattern&quot;" line="96" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "EllipsePattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ELLIPSE_PATTERN>
	<PATH_ELEMENT_PATTERN public="1" get="inline" set="null" expr="cast &quot;PathElementPattern&quot;" line="97" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "PathElementPattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PATH_ELEMENT_PATTERN>
	<PATH_SOFT_ELEMENT_PATTERN public="1" get="inline" set="null" expr="cast &quot;PathSoftElementPattern&quot;" line="98" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "PathSoftElementPattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PATH_SOFT_ELEMENT_PATTERN>
	<QUADRILATERAL_PATTERN public="1" get="inline" set="null" expr="cast &quot;QuadrilateralPattern&quot;" line="99" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "QuadrilateralPattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUADRILATERAL_PATTERN>
	<RECTANGLE_PATTERN public="1" get="inline" set="null" expr="cast &quot;RectanglePattern&quot;" line="100" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "RectanglePattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RECTANGLE_PATTERN>
	<SQUARE_PATTERN public="1" get="inline" set="null" expr="cast &quot;SquarePattern&quot;" line="101" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "SquarePattern"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SQUARE_PATTERN>
	<ARC_SHAPE public="1" get="inline" set="null" expr="cast &quot;ArcShape&quot;" line="103" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "ArcShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ARC_SHAPE>
	<CIRCLE_SHAPE public="1" get="inline" set="null" expr="cast &quot;CircleShape&quot;" line="104" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "CircleShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CIRCLE_SHAPE>
	<ELLIPSE_SHAPE public="1" get="inline" set="null" expr="cast &quot;EllipseShape&quot;" line="105" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "EllipseShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ELLIPSE_SHAPE>
	<PATH_ELEMENT_SHAPE public="1" get="inline" set="null" expr="cast &quot;PathElementShape&quot;" line="106" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "PathElementShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PATH_ELEMENT_SHAPE>
	<QUADRILATERAL_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuadrilateralShape&quot;" line="107" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "QuadrilateralShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</QUADRILATERAL_SHAPE>
	<RECTANGLE_SHAPE public="1" get="inline" set="null" expr="cast &quot;RectangleShape&quot;" line="108" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "RectangleShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RECTANGLE_SHAPE>
	<SQUARE_SHAPE public="1" get="inline" set="null" expr="cast &quot;SquareShape&quot;" line="109" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "SquareShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SQUARE_SHAPE>
	<STAR6_SHAPE public="1" get="inline" set="null" expr="cast &quot;Star6Shape&quot;" line="110" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "Star6Shape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</STAR6_SHAPE>
	<TRIANGLE_SHAPE public="1" get="inline" set="null" expr="cast &quot;TriangleShape&quot;" line="111" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "TriangleShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TRIANGLE_SHAPE>
	<VE_PATH_ELEMENT_SHAPE public="1" get="inline" set="null" expr="cast &quot;VePathElementShape&quot;" line="112" static="1">
		<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
		<meta>
			<m n=":value"><e>cast "VePathElementShape"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VE_PATH_ELEMENT_SHAPE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="pixelimage.triangleGML.coreShape._TriangleGML.TriangleGMLname_Impl_" params="" file="src/pixelimage/triangleGML/coreShape/TriangleGML.hx" private="1" module="pixelimage.triangleGML.coreShape.TriangleGML" extern="1" final="1">
		<ARROW_SHAPE public="1" get="inline" set="null" expr="cast &quot;ArrowShape&quot;" line="67" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "ArrowShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ARROW_SHAPE>
		<CUBIC_CURVE_SHAPE public="1" get="inline" set="null" expr="cast &quot;CubicCurveShape&quot;" line="68" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "CubicCurveShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CUBIC_CURVE_SHAPE>
		<LINE_GRID_SHAPE public="1" get="inline" set="null" expr="cast &quot;LineGridShape&quot;" line="69" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "LineGridShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LINE_GRID_SHAPE>
		<LINE_SHAPE public="1" get="inline" set="null" expr="cast &quot;LineShape&quot;" line="70" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "LineShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LINE_SHAPE>
		<POLY_LINE_SHAPE public="1" get="inline" set="null" expr="cast &quot;PolyLineShape&quot;" line="71" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "PolyLineShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POLY_LINE_SHAPE>
		<QUAD_CURVE_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuadCurveShape&quot;" line="72" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "QuadCurveShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUAD_CURVE_SHAPE>
		<QUAD_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuadShape&quot;" line="73" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "QuadShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUAD_SHAPE>
		<QUAD_SOFT_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuadSoftShape&quot;" line="74" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "QuadSoftShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUAD_SOFT_SHAPE>
		<QUINT_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuintShape&quot;" line="75" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "QuintShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUINT_SHAPE>
		<SOFT_ELLIPSE_SHAPE public="1" get="inline" set="null" expr="cast &quot;SoftEllipseShape&quot;" line="76" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "SoftEllipseShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SOFT_ELLIPSE_SHAPE>
		<THRU_CURVE_SHAPE public="1" get="inline" set="null" expr="cast &quot;ThruCurveShape&quot;" line="77" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "ThruCurveShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</THRU_CURVE_SHAPE>
		<TRIANGLE_SOFT_SHAPE public="1" get="inline" set="null" expr="cast &quot;TriangleSoftShape&quot;" line="78" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "TriangleSoftShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TRIANGLE_SOFT_SHAPE>
		<ARROW_THICK_GRADIENT public="1" get="inline" set="null" expr="cast &quot;ArrowThickGradient&quot;" line="80" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "ArrowThickGradient"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ARROW_THICK_GRADIENT>
		<ELLIPSE_RADIAL_GRADIENT public="1" get="inline" set="null" expr="cast &quot;EllipseRadialGradient&quot;" line="81" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "EllipseRadialGradient"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ELLIPSE_RADIAL_GRADIENT>
		<PATH_ELEMENT_THICK_GRADIENT public="1" get="inline" set="null" expr="cast &quot;PathElementThickGradient&quot;" line="82" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "PathElementThickGradient"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PATH_ELEMENT_THICK_GRADIENT>
		<QUAD_GRADIENT public="1" get="inline" set="null" expr="cast &quot;QuadGradient&quot;" line="83" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "QuadGradient"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUAD_GRADIENT>
		<TRIANGLE_GRADIENT public="1" get="inline" set="null" expr="cast &quot;TriangleGradient&quot;" line="84" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "TriangleGradient"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TRIANGLE_GRADIENT>
		<LINE_GRADIENT public="1" get="inline" set="null" expr="cast &quot;LineGradient&quot;" line="86" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "LineGradient"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LINE_GRADIENT>
		<POLY_LINE_GRADIENT public="1" get="inline" set="null" expr="cast &quot;PolyLineGradient&quot;" line="87" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "PolyLineGradient"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POLY_LINE_GRADIENT>
		<CUBIC_CURVE_PATTERN public="1" get="inline" set="null" expr="cast &quot;CubicCurvePattern&quot;" line="89" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "CubicCurvePattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CUBIC_CURVE_PATTERN>
		<LINE_PATTERN public="1" get="inline" set="null" expr="cast &quot;LinePattern&quot;" line="90" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "LinePattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LINE_PATTERN>
		<QUAD_PATTERN public="1" get="inline" set="null" expr="cast &quot;QuadPattern&quot;" line="91" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "QuadPattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUAD_PATTERN>
		<TRIANGLE_PATTERN public="1" get="inline" set="null" expr="cast &quot;TrianglePattern&quot;" line="92" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "TrianglePattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TRIANGLE_PATTERN>
		<ARC_PATTERN public="1" get="inline" set="null" expr="cast &quot;ArcPattern&quot;" line="94" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "ArcPattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ARC_PATTERN>
		<CIRCLE_PATTERN public="1" get="inline" set="null" expr="cast &quot;CirclePattern&quot;" line="95" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "CirclePattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CIRCLE_PATTERN>
		<ELLIPSE_PATTERN public="1" get="inline" set="null" expr="cast &quot;EllipsePattern&quot;" line="96" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "EllipsePattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ELLIPSE_PATTERN>
		<PATH_ELEMENT_PATTERN public="1" get="inline" set="null" expr="cast &quot;PathElementPattern&quot;" line="97" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "PathElementPattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PATH_ELEMENT_PATTERN>
		<PATH_SOFT_ELEMENT_PATTERN public="1" get="inline" set="null" expr="cast &quot;PathSoftElementPattern&quot;" line="98" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "PathSoftElementPattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PATH_SOFT_ELEMENT_PATTERN>
		<QUADRILATERAL_PATTERN public="1" get="inline" set="null" expr="cast &quot;QuadrilateralPattern&quot;" line="99" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "QuadrilateralPattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUADRILATERAL_PATTERN>
		<RECTANGLE_PATTERN public="1" get="inline" set="null" expr="cast &quot;RectanglePattern&quot;" line="100" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "RectanglePattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RECTANGLE_PATTERN>
		<SQUARE_PATTERN public="1" get="inline" set="null" expr="cast &quot;SquarePattern&quot;" line="101" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "SquarePattern"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SQUARE_PATTERN>
		<ARC_SHAPE public="1" get="inline" set="null" expr="cast &quot;ArcShape&quot;" line="103" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "ArcShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ARC_SHAPE>
		<CIRCLE_SHAPE public="1" get="inline" set="null" expr="cast &quot;CircleShape&quot;" line="104" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "CircleShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CIRCLE_SHAPE>
		<ELLIPSE_SHAPE public="1" get="inline" set="null" expr="cast &quot;EllipseShape&quot;" line="105" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "EllipseShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ELLIPSE_SHAPE>
		<PATH_ELEMENT_SHAPE public="1" get="inline" set="null" expr="cast &quot;PathElementShape&quot;" line="106" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "PathElementShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PATH_ELEMENT_SHAPE>
		<QUADRILATERAL_SHAPE public="1" get="inline" set="null" expr="cast &quot;QuadrilateralShape&quot;" line="107" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "QuadrilateralShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</QUADRILATERAL_SHAPE>
		<RECTANGLE_SHAPE public="1" get="inline" set="null" expr="cast &quot;RectangleShape&quot;" line="108" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "RectangleShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RECTANGLE_SHAPE>
		<SQUARE_SHAPE public="1" get="inline" set="null" expr="cast &quot;SquareShape&quot;" line="109" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "SquareShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SQUARE_SHAPE>
		<STAR6_SHAPE public="1" get="inline" set="null" expr="cast &quot;Star6Shape&quot;" line="110" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "Star6Shape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</STAR6_SHAPE>
		<TRIANGLE_SHAPE public="1" get="inline" set="null" expr="cast &quot;TriangleShape&quot;" line="111" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "TriangleShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TRIANGLE_SHAPE>
		<VE_PATH_ELEMENT_SHAPE public="1" get="inline" set="null" expr="cast &quot;VePathElementShape&quot;" line="112" static="1">
			<x path="pixelimage.triangleGML.coreShape.TriangleGMLname"/>
			<meta>
				<m n=":value"><e>cast "VePathElementShape"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VE_PATH_ELEMENT_SHAPE>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="pixelimage.triangleGML.coreShape._TriangleGML.TriangleGML_Fields_" params="" file="src/pixelimage/triangleGML/coreShape/TriangleGML.hx" private="1" module="pixelimage.triangleGML.coreShape.TriangleGML" final="1">
		<getTriangleGML public="1" set="method" line="115" static="1"><f a="nodeName">
	<c path="String"/>
	<c path="pixelimage.triangleGML.coreShape.ShapeInterface"/>
</f></getTriangleGML>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixelimage.triangleGML.coreShape._XMLshapeSamples2.XMLshapeSamples2_Fields_" params="" file="src/pixelimage/triangleGML/coreShape/XMLshapeSamples2.hx" private="1" module="pixelimage.triangleGML.coreShape.XMLshapeSamples2" final="1">
		<shapeTestArr public="1" set="method" line="3" static="1"><f a=""><c path="Array"><c path="String"/></c></f></shapeTestArr>
		<arcTest public="1" expr="&quot;&lt;ArcShape \n                        left=\&quot;100\&quot;  top=\&quot;100\&quot; \n                        width=\&quot;500\&quot; height=\&quot;480\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; strokeWidth=\&quot;5\&quot; \n                        fill=\&quot;0xFF00FF00\&quot; \n                        startAngle=\&quot;0\&quot; sweepAngle=\&quot;240\&quot;\n                        arcType=\&quot;pie\&quot;&gt;&lt;/ArcShape&gt;&quot;" line="32" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<ArcShape \n                        left=\"100\"  top=\"100\" \n                        width=\"500\" height=\"480\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"5\" \n                        fill=\"0xFF00FF00\" \n                        startAngle=\"0\" sweepAngle=\"240\"\n                        arcType=\"pie\"></ArcShape>"]]></e></m></meta>
		</arcTest>
		<circleTest public="1" expr="&quot;&lt;CircleShape \n                        left=\&quot;200\&quot; top=\&quot;200\&quot; \n                        diameter=\&quot;300\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; strokeWidth=\&quot;10\&quot; \n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/CircleShape&gt;&quot;" line="41" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<CircleShape \n                        left=\"200\" top=\"200\" \n                        diameter=\"300\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"10\" \n                        fill=\"0xFF00FF00\">\n                    </CircleShape>"]]></e></m></meta>
		</circleTest>
		<cubicCurveTest public="1" expr="&quot;&lt;CubicCurveShape \n                        thru=\&quot;true\&quot; \n                        x1=\&quot;100\&quot; y1=\&quot;100\&quot; \n                        x2=\&quot;200\&quot; y2=\&quot;150\&quot; \n                        x3=\&quot;130\&quot; y3=\&quot;220\&quot; \n                        strokeColor=\&quot;0xFF0000\&quot; strokeWidth=\&quot;1\&quot; \n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/CubicCurveShape&gt;&quot;" line="50" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<CubicCurveShape \n                        thru=\"true\" \n                        x1=\"100\" y1=\"100\" \n                        x2=\"200\" y2=\"150\" \n                        x3=\"130\" y3=\"220\" \n                        strokeColor=\"0xFF0000\" strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\">\n                    </CubicCurveShape>"]]></e></m></meta>
		</cubicCurveTest>
		<ellipseArcTest public="1" expr="&quot;&lt;EllipseArcTest \n                        left=\&quot;100\&quot;  top=\&quot;100\&quot; \n                        width=\&quot;200\&quot; height=\&quot;50\&quot; \n                        strokeColor=\&quot;0xFF0000\&quot; strokeWidth=\&quot;1\&quot; \n                        fill=\&quot;0xFF00FF00\&quot; \n                        startAngle=\&quot;10\&quot; sweepAngle=\&quot;90\&quot;&gt;\n                    &lt;/EllipseArcTest&gt;&quot;" line="60" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<EllipseArcTest \n                        left=\"100\"  top=\"100\" \n                        width=\"200\" height=\"50\" \n                        strokeColor=\"0xFF0000\" strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\" \n                        startAngle=\"10\" sweepAngle=\"90\">\n                    </EllipseArcTest>"]]></e></m></meta>
		</ellipseArcTest>
		<ellipseTest public="1" expr="&quot;&lt;EllipseShape \n                        top=\&quot;100\&quot; \n                        width=\&quot;200\&quot; \n                        height=\&quot;50\&quot; \n                        strokeColor=\&quot;0xFF0000\&quot; strokeWidth=\&quot;1\&quot; \n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/EllipseShape&gt;&quot;" line="69" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<EllipseShape \n                        top=\"100\" \n                        width=\"200\" \n                        height=\"50\" \n                        strokeColor=\"0xFF0000\" strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\">\n                    </EllipseShape>"]]></e></m></meta>
		</ellipseTest>
		<imageElement public="1" expr="&quot;&lt;ImageElement  \n                        left=\&quot;100\&quot; top=\&quot;100\&quot; \n                        width=\&quot;200\&quot; height=\&quot;50\&quot; \n                        contents=\&quot;image\&quot;&gt;\n                    &lt;/ImageElement&gt;&quot;" line="78" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<ImageElement  \n                        left=\"100\" top=\"100\" \n                        width=\"200\" height=\"50\" \n                        contents=\"image\">\n                    </ImageElement>"]]></e></m></meta>
		</imageElement>
		<lineGradientTest public="1" expr="&quot;&lt;LineGradient \n                        x1=\&quot;100\&quot; y1=\&quot;300\&quot; \n                        x2=\&quot;300\&quot; y2=\&quot;120\&quot; \n                        strokewidth=\&quot;1\&quot; \n                        colorA=\&quot;0xFF0000\&quot; colorB=\&quot;0xa00cc0\&quot; colorC=\&quot;0x0fa00f\&quot; colorD=\&quot;0x000fff\&quot;&gt;\n                    &lt;/LineGradient&gt;&quot;" line="85" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<LineGradient \n                        x1=\"100\" y1=\"300\" \n                        x2=\"300\" y2=\"120\" \n                        strokewidth=\"1\" \n                        colorA=\"0xFF0000\" colorB=\"0xa00cc0\" colorC=\"0x0fa00f\" colorD=\"0x000fff\">\n                    </LineGradient>"]]></e></m></meta>
		</lineGradientTest>
		<lineShapeTest public="1" expr="&quot;&lt;LineShape \n                        x1=\&quot;100\&quot; y1=\&quot;300\&quot; \n                        x2=\&quot;360\&quot; y2=\&quot;120\&quot; \n                        strokeWidth=\&quot;30\&quot; strokeColor=\&quot;0xffFF0000\&quot;&gt;\n                    &lt;/LineShape&gt;&quot;" line="93" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<LineShape \n                        x1=\"100\" y1=\"300\" \n                        x2=\"360\" y2=\"120\" \n                        strokeWidth=\"30\" strokeColor=\"0xffFF0000\">\n                    </LineShape>"]]></e></m></meta>
		</lineShapeTest>
		<arrowShapeTest public="1" expr="&quot;&lt;ArrowShape\n                        flare=\&quot;true\&quot;\n                        both=\&quot;true\&quot;\n                        x1=\&quot;100\&quot; y1=\&quot;300\&quot; \n                        x2=\&quot;360\&quot; y2=\&quot;120\&quot; \n                        arrowWidth=\&quot;60\&quot;\n                        arrowHeight=\&quot;50\&quot;\n                        strokeWidth=\&quot;5\&quot; strokeColor=\&quot;0xffFF0000\&quot;&gt;\n                    &lt;/ArrowShape&gt;&quot;" line="100" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<ArrowShape\n                        flare=\"true\"\n                        both=\"true\"\n                        x1=\"100\" y1=\"300\" \n                        x2=\"360\" y2=\"120\" \n                        arrowWidth=\"60\"\n                        arrowHeight=\"50\"\n                        strokeWidth=\"5\" strokeColor=\"0xffFF0000\">\n                    </ArrowShape>"]]></e></m></meta>
		</arrowShapeTest>
		<arrowThickGradientTest public="1" expr="&quot;&lt;ArrowThickGradient\n                        flare=\&quot;true\&quot;\n                        reverseFlare=\&quot;true\&quot;\n                        both=\&quot;true\&quot;\n                        x1=\&quot;100\&quot; y1=\&quot;300\&quot; \n                        x2=\&quot;360\&quot; y2=\&quot;120\&quot; \n                        arrowWidth=\&quot;60\&quot;\n                        arrowHeight=\&quot;50\&quot;\n                        strokeWidth=\&quot;5\&quot; strokeTopColor=\&quot;0xFF9000FF\&quot; strokeBottomColor=\&quot;0xffffa200\&quot;&gt;\n                    &lt;/ArrowThickGradient&gt;&quot;" line="110" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<ArrowThickGradient\n                        flare=\"true\"\n                        reverseFlare=\"true\"\n                        both=\"true\"\n                        x1=\"100\" y1=\"300\" \n                        x2=\"360\" y2=\"120\" \n                        arrowWidth=\"60\"\n                        arrowHeight=\"50\"\n                        strokeWidth=\"5\" strokeTopColor=\"0xFF9000FF\" strokeBottomColor=\"0xffffa200\">\n                    </ArrowThickGradient>"]]></e></m></meta>
		</arrowThickGradientTest>
		<quadtest_d public="1" expr="&quot;M200,300 Q400,50 600,300 T1000,300,L50,50 L20,20 L100,200 C100,100 250,100 250,200S400,300 400,200&quot;" line="121" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"M200,300 Q400,50 600,300 T1000,300,L50,50 L20,20 L100,200 C100,100 250,100 250,200S400,300 400,200"</e></m></meta>
		</quadtest_d>
		<cubictest_d public="1" expr="&quot;M100,200 C100,100 250,100 250,200S400,300 400,200&quot;" line="122" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"M100,200 C100,100 250,100 250,200S400,300 400,200"</e></m></meta>
		</cubictest_d>
		<pathElementQuadTest public="1" expr="&quot;&lt;PathElementShape \n                        pathData=\&quot;$quadtest_d\&quot; \n                        strokeWidth=\&quot;10\&quot; strokeColor=\&quot;0xFFFF0000\&quot; \n                        fill=\&quot;0x0000ff\&quot;&gt;\n                    &lt;/PathElementShape&gt;&quot;" line="125" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<PathElementShape \n                        pathData=\"$quadtest_d\" \n                        strokeWidth=\"10\" strokeColor=\"0xFFFF0000\" \n                        fill=\"0x0000ff\">\n                    </PathElementShape>"]]></e></m></meta>
		</pathElementQuadTest>
		<pathElementThickGradTest public="1" expr="&quot;&lt;PathElementThickGradient\n                        pathData=\&quot;$quadtest_d\&quot; \n                        strokeWidth=\&quot;25\&quot; strokeTopColor=\&quot;0xFFFF0000\&quot; strokeBottomColor=\&quot;0xFF00FFBB\&quot; \n                        fill=\&quot;0x0000ff\&quot;&gt;\n                    &lt;/PathElementThickGradient&gt;&quot;" line="131" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<PathElementThickGradient\n                        pathData=\"$quadtest_d\" \n                        strokeWidth=\"25\" strokeTopColor=\"0xFFFF0000\" strokeBottomColor=\"0xFF00FFBB\" \n                        fill=\"0x0000ff\">\n                    </PathElementThickGradient>"]]></e></m></meta>
		</pathElementThickGradTest>
		<pathElementCubicTest public="1" expr="&quot;&lt;PathElementShape \n                        pathData=\&quot;$cubictest_d\&quot; \n                        translateX=\&quot;0\&quot;\n                        translateY=\&quot;0\&quot;\n                        strokeWidth=\&quot;30\&quot; strokeColor=\&quot;0xFFFF0000\&quot; \n                        fill=\&quot;0xff0000ff\&quot;&gt;\n                    &lt;/PathElementShape&gt;&quot;" line="137" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<PathElementShape \n                        pathData=\"$cubictest_d\" \n                        translateX=\"0\"\n                        translateY=\"0\"\n                        strokeWidth=\"30\" strokeColor=\"0xFFFF0000\" \n                        fill=\"0xff0000ff\">\n                    </PathElementShape>"]]></e></m></meta>
		</pathElementCubicTest>
		<vePathElementShape public="1" expr="&quot;&lt;VePathElementShape\n                        pathData=\&quot;$quadtest_d\&quot; \n                        translateX=\&quot;0\&quot;\n                        translateY=\&quot;0\&quot;\n                        strokeWidths=\&quot;[ 10, 20, 30, 40, 50, 60, 70 ]\&quot; \n                        strokeColors=\&quot;[ 0xFF9400D3, 0xFF4b0082, 0xFF0000FF, 0xFF00ff00, 0xFFFFFF00, 0xFFFF7F00, 0xFFFF0000 ]\&quot; \n                        fill=\&quot;0xff0000ff\&quot;&gt;\n                    &lt;/VePathElementShape&gt;&quot;" line="145" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<VePathElementShape\n                        pathData=\"$quadtest_d\" \n                        translateX=\"0\"\n                        translateY=\"0\"\n                        strokeWidths=\"[ 10, 20, 30, 40, 50, 60, 70 ]\" \n                        strokeColors=\"[ 0xFF9400D3, 0xFF4b0082, 0xFF0000FF, 0xFF00ff00, 0xFFFFFF00, 0xFFFF7F00, 0xFFFF0000 ]\" \n                        fill=\"0xff0000ff\">\n                    </VePathElementShape>"]]></e></m></meta>
		</vePathElementShape>
		<polyLineGradientTest public="1" expr="&quot;&lt;PolyLineGradient \n                        points= \&quot;[ 100, 100, 50, 50, 30, 30, 70, 200 ]\&quot; \n                        colorDirection=\&quot;longways\&quot; \n                        cornerColors=\&quot;[ 0xFFFF0000, 0xFFb1afcc, 0xFFaaaa00, 0xFFcc00cc ]\&quot;&gt;\n                    &lt;/PolyLineGradient&gt;&quot;" line="154" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<PolyLineGradient \n                        points= \"[ 100, 100, 50, 50, 30, 30, 70, 200 ]\" \n                        colorDirection=\"longways\" \n                        cornerColors=\"[ 0xFFFF0000, 0xFFb1afcc, 0xFFaaaa00, 0xFFcc00cc ]\">\n                    </PolyLineGradient>"]]></e></m></meta>
		</polyLineGradientTest>
		<polyLineShapeTest public="1" expr="&quot;&lt;PolyLineShape \n                        points= \&quot;[ 100, 100, 50, 50, 30, 30, 70, 200 ]\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; strokeWidth=\&quot;1\&quot; \n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/PolyLineShape&gt;&quot;" line="161" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<PolyLineShape \n                        points= \"[ 100, 100, 50, 50, 30, 30, 70, 200 ]\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\">\n                    </PolyLineShape>"]]></e></m></meta>
		</polyLineShapeTest>
		<quadCurveTest public="1" expr="&quot;&lt;QuadCurveShape \n                        x1=\&quot;100\&quot; y1=\&quot;300\&quot; \n                        x2=\&quot;300\&quot; y2=\&quot;120\&quot; \n                        x3=\&quot;130\&quot; y3=\&quot;220\&quot; \n                        x4=\&quot;500\&quot; y4=\&quot;500\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; strokeWidth=\&quot;1\&quot;&gt;\n                    &lt;/QuadCurveShape&gt;&quot;" line="168" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<QuadCurveShape \n                        x1=\"100\" y1=\"300\" \n                        x2=\"300\" y2=\"120\" \n                        x3=\"130\" y3=\"220\" \n                        x4=\"500\" y4=\"500\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"1\">\n                    </QuadCurveShape>"]]></e></m></meta>
		</quadCurveTest>
		<quadShape public="1" expr="&quot;&lt;QuadShape \n                        x1=\&quot;100\&quot; y1=\&quot;300\&quot; \n                        x2=\&quot;300\&quot; y2=\&quot;120\&quot; \n                        x3=\&quot;130\&quot; y3=\&quot;220\&quot; \n                        x4=\&quot;500\&quot; y4=\&quot;500\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; strokeWidth=\&quot;1\&quot; \n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/QuadShape&gt;&quot;" line="178" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<QuadShape \n                        x1=\"100\" y1=\"300\" \n                        x2=\"300\" y2=\"120\" \n                        x3=\"130\" y3=\"220\" \n                        x4=\"500\" y4=\"500\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\">\n                    </QuadShape>"]]></e></m></meta>
		</quadShape>
		<rectangleShape public="1" expr="&quot;&lt;RectangleShape \n                        left=\&quot;100\&quot; top=\&quot;100\&quot; \n                        width=\&quot;200\&quot; height=\&quot;50\&quot; \n                        rounded=\&quot;true\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; \n                        strokeWidth=\&quot;1\&quot; \n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/RectangleShape&gt;&quot;" line="188" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<RectangleShape \n                        left=\"100\" top=\"100\" \n                        width=\"200\" height=\"50\" \n                        rounded=\"true\" \n                        strokeColor=\"0xFFFF0000\" \n                        strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\">\n                    </RectangleShape>"]]></e></m></meta>
		</rectangleShape>
		<squareShape public="1" expr="&quot;&lt;SquareShape \n                        left=\&quot;100\&quot; top=\&quot;100\&quot; \n                        diameter=\&quot;90\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; strokeWidth=\&quot;1\&quot; \n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/SquareShape&gt;&quot;" line="199" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<SquareShape \n                        left=\"100\" top=\"100\" \n                        diameter=\"90\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\">\n                    </SquareShape>"]]></e></m></meta>
		</squareShape>
		<star6Shape public="1" expr="&quot;&lt;SquareShape \n                        left=\&quot;100\&quot; top=\&quot;100\&quot; \n                        diameter=\&quot;90\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; strokeWidth=\&quot;1\&quot; \n                        rotation = \&quot;0\&quot;\n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/SquareShape&gt;&quot;" line="206" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<SquareShape \n                        left=\"100\" top=\"100\" \n                        diameter=\"90\" \n                        strokeColor=\"0xFFFF0000\" strokeWidth=\"1\" \n                        rotation = \"0\"\n                        fill=\"0xFF00FF00\">\n                    </SquareShape>"]]></e></m></meta>
		</star6Shape>
		<tileRectangleTest public="1" expr="&quot;&lt;RectanglePattern \n                        left=\&quot;100\&quot; top=\&quot;100\&quot; \n                        width=\&quot;600\&quot; height=\&quot;400\&quot; \n                        rounded=\&quot;true\&quot; \n                        strokeColor=\&quot;0xFFFF0000\&quot; \n                        strokeWidth=\&quot;12\&quot; \n                        fillColor0=\&quot;0xFF1912F9\&quot;\n                        fillColor1=\&quot;0xFF5CC7B3\&quot;\n                        strokeColor0=\&quot;0xFFF1FF33\&quot;\n                        strokeColor1=\&quot;0xFFF7287B\&quot; \n                        strokePatternFill=\&quot;[false,true]\&quot;\n                        strokePatternWidth=\&quot;2\&quot;\n                        strokePatternHeight=\&quot;2\&quot;\n                        strokePatternAcross=\&quot;true\&quot;\n                        strokePatternScale=\&quot;8\&quot;\n                        fillPatternFill=\&quot;[true,true,true,true,false,false,false,false]\&quot;\n                        fillPatternWidth=\&quot;8\&quot;\n                        fillPatternHeight=\&quot;8\&quot;\n                        fillPatternAcross=\&quot;true\&quot;\n                        fillPatternScale=\&quot;8\&quot;&gt;\n                    &lt;/RectanglePattern&gt;&quot;" line="215" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<RectanglePattern \n                        left=\"100\" top=\"100\" \n                        width=\"600\" height=\"400\" \n                        rounded=\"true\" \n                        strokeColor=\"0xFFFF0000\" \n                        strokeWidth=\"12\" \n                        fillColor0=\"0xFF1912F9\"\n                        fillColor1=\"0xFF5CC7B3\"\n                        strokeColor0=\"0xFFF1FF33\"\n                        strokeColor1=\"0xFFF7287B\" \n                        strokePatternFill=\"[false,true]\"\n                        strokePatternWidth=\"2\"\n                        strokePatternHeight=\"2\"\n                        strokePatternAcross=\"true\"\n                        strokePatternScale=\"8\"\n                        fillPatternFill=\"[true,true,true,true,false,false,false,false]\"\n                        fillPatternWidth=\"8\"\n                        fillPatternHeight=\"8\"\n                        fillPatternAcross=\"true\"\n                        fillPatternScale=\"8\">\n                    </RectanglePattern>"]]></e></m></meta>
		</tileRectangleTest>
		<triangleGradientTest public="1" expr="&quot;&lt;TriangleGradient \n                        aX=\&quot;100\&quot; aY=\&quot;100\&quot; \n                        bX=\&quot;200\&quot; bY=\&quot;150\&quot; \n                        cX=\&quot;130\&quot; cY=\&quot;220\&quot; \n                        colorA=\&quot;0xffFF0000\&quot; colorB=\&quot;0xff0f00ff\&quot; colorC=\&quot;0xffcc00cc\&quot;&gt;\n                    &lt;/TriangleGradient&gt;&quot;" line="237" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<TriangleGradient \n                        aX=\"100\" aY=\"100\" \n                        bX=\"200\" bY=\"150\" \n                        cX=\"130\" cY=\"220\" \n                        colorA=\"0xffFF0000\" colorB=\"0xff0f00ff\" colorC=\"0xffcc00cc\">\n                    </TriangleGradient>"]]></e></m></meta>
		</triangleGradientTest>
		<triangleShape public="1" expr="&quot;&lt;TriangleShape \n                        x1=\&quot;100\&quot; y1=\&quot;100\&quot; \n                        x2=\&quot;200\&quot; y2=\&quot;150\&quot; \n                        x3=\&quot;130\&quot; y3=\&quot;220\&quot; \n                        strokeColor=\&quot;0xFF0000\&quot; strokeWidth=\&quot;1\&quot; \n                        fill=\&quot;0xFF00FF00\&quot;&gt;\n                    &lt;/TriangleShape&gt;&quot;" line="245" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<TriangleShape \n                        x1=\"100\" y1=\"100\" \n                        x2=\"200\" y2=\"150\" \n                        x3=\"130\" y3=\"220\" \n                        strokeColor=\"0xFF0000\" strokeWidth=\"1\" \n                        fill=\"0xFF00FF00\">\n                    </TriangleShape>"]]></e></m></meta>
		</triangleShape>
		<lineGridShape public="1" expr="&quot;&lt;LineGridShape\n                        left = \&quot;100\&quot;  top  = \&quot;100\&quot;\n                        width = \&quot;2048\&quot; height = \&quot;1536\&quot;\n                        delta = \&quot;100\&quot; deltaH = \&quot;100\&quot;\n                        strokeColor=\&quot;0xfF003300\&quot; strokeWidth=\&quot;2.5\&quot;&gt;\n                    &lt;/LineGridShape&gt;&quot;" line="253" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<LineGridShape\n                        left = \"100\"  top  = \"100\"\n                        width = \"2048\" height = \"1536\"\n                        delta = \"100\" deltaH = \"100\"\n                        strokeColor=\"0xfF003300\" strokeWidth=\"2.5\">\n                    </LineGridShape>"]]></e></m></meta>
		</lineGridShape>
	</class>
	<class path="pixelimage.triangleGML.gradient.ArrowThickGradient" params="" file="src/pixelimage/triangleGML/gradient/ArrowThickGradient.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<both public="1"><x path="Bool"/></both>
		<flare public="1"><x path="Bool"/></flare>
		<reverseFlare public="1"><x path="Bool"/></reverseFlare>
		<arrowWidth public="1"><x path="Float"/></arrowWidth>
		<arrowHeight public="1"><x path="Float"/></arrowHeight>
		<strokeTopColor public="1"><x path="Int"/></strokeTopColor>
		<strokeBottomColor public="1"><x path="Int"/></strokeBottomColor>
		<setParameter public="1" set="method" line="50" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="78" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="36">
			<f a="?opacity:?visibility:?strokeTopColor:?strokeBottomColor:?strokeWidth:?strokeDashGapArray:?both:?flare:?reverseFlare:?x1:?y1:?x2:?y2:?arrowWidth:?arrowHeight" v="1.:true:0xFF000000:0xFFFFFFFF:1.:null:false:false:false:0.:0.:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ arrowHeight : 0., arrowWidth : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., reverseFlare : false, flare : false, both : false, strokeDashGapArray : null, strokeWidth : 1., strokeBottomColor : 0xFFFFFFFF, strokeTopColor : 0xFF000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.gradient.EllipseRadialGradient" params="" file="src/pixelimage/triangleGML/gradient/EllipseRadialGradient.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicGradient"/>
		<centreX public="1"><x path="Float"/></centreX>
		<centreY public="1"><x path="Float"/></centreY>
		<radiusX public="1"><x path="Float"/></radiusX>
		<radiusY public="1"><x path="Float"/></radiusY>
		<colorIn public="1"><x path="Int"/></colorIn>
		<colorOut public="1"><x path="Int"/></colorOut>
		<gradientCentreX public="1"><x path="Float"/></gradientCentreX>
		<gradientCentreY public="1"><x path="Float"/></gradientCentreY>
		<rotation public="1"><x path="Float"/></rotation>
		<setParameter public="1" set="method" line="40" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="64" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="30">
			<f a="?opacity:?visibility:?centreX:?centreY:?radiusX:?radiusY:?colorIn:?colorOut:?gradientCentreX:?gradientCentreY:?rotation" v="1.:true:30:30:10:10:0xFFFFFF00:0xFF0000FF:-1.:-1.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rotation : 0., gradientCentreY : -1., gradientCentreX : -1., colorOut : 0xFF0000FF, colorIn : 0xFFFFFF00, radiusY : 10, radiusX : 10, centreY : 30, centreX : 30, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.gradient.PathElementThickGradient" params="" file="src/pixelimage/triangleGML/gradient/PathElementThickGradient.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<implements path="justPath.ILinePathContext"/>
		<pathData public="1"><c path="String"/></pathData>
		<strokeTopColor public="1"><x path="Int"/></strokeTopColor>
		<strokeBottomColor public="1"><x path="Int"/></strokeBottomColor>
		<translateX public="1"><x path="Float"/></translateX>
		<translateY public="1"><x path="Float"/></translateY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<x0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x0>
		<y0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y0>
		<temp><x path="pixelimage.Pixelimage"/></temp>
		<setParameter public="1" set="method" line="45" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="67" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<toggleDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</toggleDraw>
		<info><a>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<cy><x path="Float"/></cy>
	<cx><x path="Float"/></cx>
	<by><x path="Float"/></by>
	<bx><x path="Float"/></bx>
	<ay><x path="Float"/></ay>
	<ax><x path="Float"/></ax>
</a></info>
		<lineSegmentTo public="1" set="method" line="83"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<lineTo public="1" set="method" line="104"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="121"><f a="x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<new public="1" set="method" line="20">
			<f a="?opacity:?visibility:?strokeTopColor:?strokeBottomColor:?strokeWidth:?strokeDashGapArray:?fill:?pathData:?translateX:?translateY:?scaleX:?scaleY" v="1.:true:0xFF000000:0xFFFFFFFF:1.:null:0x000000:&quot;&quot;:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0., pathData : "", fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeBottomColor : 0xFFFFFFFF, strokeTopColor : 0xFF000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.gradient.QuadGradient" params="" file="src/pixelimage/triangleGML/gradient/QuadGradient.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicGradient"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<color1 public="1"><x path="Int"/></color1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<color2 public="1"><x path="Float"/></color2>
		<x3 public="1"><x path="Float"/></x3>
		<y3 public="1"><x path="Float"/></y3>
		<color3 public="1"><x path="Float"/></color3>
		<x4 public="1"><x path="Float"/></x4>
		<y4 public="1"><x path="Float"/></y4>
		<color4 public="1"><x path="Float"/></color4>
		<setParameter public="1" set="method" line="46" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="76" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="35">
			<f a="?opacity:?visibility:?x1:?y1:?color1:?x2:?y2:?color2:?x3:?y3:?color3:?x4:?y4:?color4" v="1.:true:0.:0.:0xffd9ff00:0.:0.:0xFFFF00FB:0.:0.:0xFF00FFBF:0.:0.:0xFFFF9500">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color4 : 0xFFFF9500, y4 : 0., x4 : 0., color3 : 0xFF00FFBF, y3 : 0., x3 : 0., color2 : 0xFFFF00FB, y2 : 0., x2 : 0., color1 : 0xffd9ff00, y1 : 0., x1 : 0., visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.gradient.TriangleGradient" params="" file="src/pixelimage/triangleGML/gradient/TriangleGradient.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicGradient"/>
		<aX public="1"><x path="Float"/></aX>
		<aY public="1"><x path="Float"/></aY>
		<bX public="1"><x path="Float"/></bX>
		<bY public="1"><x path="Float"/></bY>
		<cX public="1"><x path="Float"/></cX>
		<cY public="1"><x path="Float"/></cY>
		<setParameter public="1" set="method" line="35" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="59" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="26">
			<f a="?opacity:?visibility:?aX:?aY:?bX:?bY:?cX:?cY:?colorA:?colorB:?colorC" v="1.:true:0.:0.:1.:0.:0.:1.:0xFFFF0000:0xFF00FF00:0xFF0000FF">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ colorC : 0xFF0000FF, colorB : 0xFF00FF00, colorA : 0xFFFF0000, cY : 1., cX : 0., bY : 0., bX : 1., aY : 0., aX : 0., visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.gradientContour.LineGradient" params="" file="src/pixelimage/triangleGML/gradientContour/LineGradient.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicGradient"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<strokeWidth public="1"><x path="Float"/></strokeWidth>
		<setParameter public="1" set="method" line="32" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="68" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="24">
			<f a="?opacity:?visibility:?x1:?y1:?x2:?y2:?colorA:?colorB:?colorC:?colorD:?strokeWidth" v="1.:true:0.:0.:0.:0.:0xFFFF9900:0xFFBFFF00:0xFF00EAFF:0xFF7300FF:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ strokeWidth : 1., colorD : 0xFF7300FF, colorC : 0xFF00EAFF, colorB : 0xFFBFFF00, colorA : 0xFFFF9900, y2 : 0., x2 : 0., y1 : 0., x1 : 0., visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="pixelimage.triangleGML.gradientContour.ColorDirection" params="" file="src/pixelimage/triangleGML/gradientContour/PolyLineGradient.hx" module="pixelimage.triangleGML.gradientContour.PolyLineGradient">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="pixelimage.triangleGML.gradientContour._PolyLineGradient.ColorDirection_Impl_" params="" file="src/pixelimage/triangleGML/gradientContour/PolyLineGradient.hx" private="1" module="pixelimage.triangleGML.gradientContour.PolyLineGradient" extern="1" final="1">
	<widthways public="1" get="inline" set="null" expr="cast &quot;widthways&quot;" line="7" static="1">
		<x path="pixelimage.triangleGML.gradientContour.ColorDirection"/>
		<meta>
			<m n=":value"><e>cast "widthways"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</widthways>
	<longways public="1" get="inline" set="null" expr="cast &quot;longways&quot;" line="8" static="1">
		<x path="pixelimage.triangleGML.gradientContour.ColorDirection"/>
		<meta>
			<m n=":value"><e>cast "longways"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</longways>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="pixelimage.triangleGML.gradientContour._PolyLineGradient.ColorDirection_Impl_" params="" file="src/pixelimage/triangleGML/gradientContour/PolyLineGradient.hx" private="1" module="pixelimage.triangleGML.gradientContour.PolyLineGradient" extern="1" final="1">
		<widthways public="1" get="inline" set="null" expr="cast &quot;widthways&quot;" line="7" static="1">
			<x path="pixelimage.triangleGML.gradientContour.ColorDirection"/>
			<meta>
				<m n=":value"><e>cast "widthways"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</widthways>
		<longways public="1" get="inline" set="null" expr="cast &quot;longways&quot;" line="8" static="1">
			<x path="pixelimage.triangleGML.gradientContour.ColorDirection"/>
			<meta>
				<m n=":value"><e>cast "longways"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</longways>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="pixelimage.triangleGML.gradientContour.PolyLineGradient" params="" file="src/pixelimage/triangleGML/gradientContour/PolyLineGradient.hx">
		<extends path="pixelimage.triangleGML.coreShape.BasicGradient"/>
		<points public="1"><x path="Null"><c path="Array"><x path="Float"/></c></x></points>
		<strokeWidth public="1"><x path="Float"/></strokeWidth>
		<colorDirection public="1"><x path="pixelimage.triangleGML.gradientContour.ColorDirection"/></colorDirection>
		<setParameter public="1" set="method" line="28" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="44" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="22">
			<f a="?opacity:?visibility:?strokeWidth:?points:?colorDirection:?colors" v="1.:true:1.:null:longways:null">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<x path="pixelimage.triangleGML.gradientContour.ColorDirection"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ colors : null, colorDirection : longways, points : null, strokeWidth : 1., visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternContour.CubicCurvePattern" params="" file="src/pixelimage/triangleGML/patternContour/CubicCurvePattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternStroke"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<x3 public="1"><x path="Float"/></x3>
		<y3 public="1"><x path="Float"/></y3>
		<x4 public="1"><x path="Float"/></x4>
		<y4 public="1"><x path="Float"/></y4>
		<translateX public="1"><x path="Float"/></translateX>
		<translateY public="1"><x path="Float"/></translateY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<setParameter public="1" set="method" line="67" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="89" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="50">
			<f a="?opacity:?visibility:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fill:?thru:?x1:?y1:?x2:?y2:?x3:?y3:?x4:?y4:?translateX:?translateY:?scaleX:?scaleY" v="1.:true:1.:null:0x00000000:0x00000000:null:null:null:true:1:0x000000:false:0.:0.:0.:0.:0.:0.:0.:0.:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0., y4 : 0., x4 : 0., y3 : 0., x3 : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., thru : false, fill : 0x000000, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternContour.LinePattern" params="" file="src/pixelimage/triangleGML/patternContour/LinePattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternStroke"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<setParameter public="1" set="method" line="42" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="56" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="33">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?x1:?y1:?x2:?y2" v="1.:true:0xFFF00000:1.:null:0x00000000:0x00000000:null:null:null:true:1:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y2 : 0., x2 : 0., y1 : 0., x1 : 0., strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0xFFF00000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternContour.QuadPattern" params="" file="src/pixelimage/triangleGML/patternContour/QuadPattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternStroke"/>
		<aX public="1"><x path="Float"/></aX>
		<aY public="1"><x path="Float"/></aY>
		<bX public="1"><x path="Float"/></bX>
		<bY public="1"><x path="Float"/></bY>
		<cX public="1"><x path="Float"/></cX>
		<cY public="1"><x path="Float"/></cY>
		<dX public="1"><x path="Float"/></dX>
		<dY public="1"><x path="Float"/></dY>
		<setParameter public="1" set="method" line="49" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="71" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="36">
			<f a="?opacity:?visibility:?strokeColor0:?strokeColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?aX:?aY:?bX:?bY:?cX:?cY:?dX:?dY" v="1.:true:0x00000000:0x00000000:null:null:null:true:1:0.:0.:1.:0.:1.:1.:0.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dY : 1., dX : 0., cY : 1., cX : 1., bY : 0., bX : 1., aY : 0., aX : 0., strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternContour.TrianglePattern" params="" file="src/pixelimage/triangleGML/patternContour/TrianglePattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternStroke"/>
		<aX public="1"><x path="Float"/></aX>
		<aY public="1"><x path="Float"/></aY>
		<bX public="1"><x path="Float"/></bX>
		<bY public="1"><x path="Float"/></bY>
		<cX public="1"><x path="Float"/></cX>
		<cY public="1"><x path="Float"/></cY>
		<setParameter public="1" set="method" line="43" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="61" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="32">
			<f a="?opacity:?visibility:?strokeColor0:?strokeColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?aX:?aY:?bX:?bY:?cX:?cY" v="1.:true:0x00000000:0x00000000:null:null:null:true:1:0.:0.:1.:0.:0.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cY : 1., cX : 0., bY : 0., bX : 1., aY : 0., aX : 0., strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternShape.ArcPattern" params="" file="src/pixelimage/triangleGML/patternShape/ArcPattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<startAngle public="1"><x path="Float"/></startAngle>
		<sweepAngle public="1"><x path="Float"/></sweepAngle>
		<arcType public="1"><x path="pixelimage.triangleGML.shape.ArcType"/></arcType>
		<rx><x path="Float"/></rx>
		<ry><x path="Float"/></ry>
		<setParameter public="1" set="method" line="60" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="84" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<chord set="method" line="102"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></chord>
		<ellipse set="method" line="124"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></ellipse>
		<pie set="method" line="128"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></pie>
		<new public="1" set="method" line="48">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?fillColor0:?fillColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fillPatternFill:?fillPatternWidth:?fillPatternHeight:?fillPatternAcross:?fillPatternScale:?left:?top:?width:?height:?startAngle:?sweepAngle:?arcType" v="1.:true:0x000000:1.:null:0x00000000:0x00000000:0x00000000:0x00000000:null:null:null:true:1:null:16:16:true:1:0.:0.:1.:1.:0.:0.:Pie">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.triangleGML.shape.ArcType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ arcType : Pie, sweepAngle : 0., startAngle : 0., height : 1., width : 1., top : 0., left : 0., fillPatternScale : 1, fillPatternAcross : true, fillPatternHeight : 16, fillPatternWidth : 16, fillPatternFill : null, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, fillColor1 : 0x00000000, fillColor0 : 0x00000000, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternShape.CirclePattern" params="" file="src/pixelimage/triangleGML/patternShape/CirclePattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<diameter public="1"><x path="Float"/></diameter>
		<setParameter public="1" set="method" line="46" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="58" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<buildCircle set="method" line="70"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></buildCircle>
		<new public="1" set="method" line="37">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?fillColor0:?fillColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fillPatternFill:?fillPatternWidth:?fillPatternHeight:?fillPatternAcross:?fillPatternScale:?left:?top:?diameter" v="1.:true:0x000000:1.:null:0x00000000:0x00000000:0x00000000:0x00000000:null:null:null:true:1:null:16:16:true:1:0.:0.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ diameter : 1., top : 0., left : 0., fillPatternScale : 1, fillPatternAcross : true, fillPatternHeight : 16, fillPatternWidth : 16, fillPatternFill : null, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, fillColor1 : 0x00000000, fillColor0 : 0x00000000, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternShape.EllipsePattern" params="" file="src/pixelimage/triangleGML/patternShape/EllipsePattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<setParameter public="1" set="method" line="49" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="63" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="39">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?fillColor0:?fillColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fillPatternFill:?fillPatternWidth:?fillPatternHeight:?fillPatternAcross:?fillPatternScale:?left:?top:?width:?height" v="1.:true:0x000000:1.:null:0x00000000:0x00000000:0x00000000:0x00000000:null:null:null:true:1:null:16:16:true:1:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 1., width : 1., top : 0., left : 0., fillPatternScale : 1, fillPatternAcross : true, fillPatternHeight : 16, fillPatternWidth : 16, fillPatternFill : null, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, fillColor1 : 0x00000000, fillColor0 : 0x00000000, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternShape.PathElementPattern" params="" file="src/pixelimage/triangleGML/patternShape/PathElementPattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternShape"/>
		<implements path="justPath.ILinePathContext"/>
		<pathData public="1"><c path="String"/></pathData>
		<translateX public="1"><x path="Float"/></translateX>
		<translateY public="1"><x path="Float"/></translateY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<x0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x0>
		<y0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y0>
		<temp><x path="pixelimage.Pixelshape"/></temp>
		<toggleDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</toggleDraw>
		<info><a>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<cy><x path="Float"/></cy>
	<cx><x path="Float"/></cx>
	<by><x path="Float"/></by>
	<bx><x path="Float"/></bx>
	<ay><x path="Float"/></ay>
	<ax><x path="Float"/></ax>
</a></info>
		<oldInfo><a>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<cy><x path="Float"/></cy>
	<cx><x path="Float"/></cx>
	<by><x path="Float"/></by>
	<bx><x path="Float"/></bx>
	<ay><x path="Float"/></ay>
	<ax><x path="Float"/></ax>
</a></oldInfo>
		<setParameter public="1" set="method" line="62" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="78" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<lineSegmentTo public="1" set="method" line="95"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<lineTo public="1" set="method" line="115"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="131"><f a="x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<new public="1" set="method" line="23">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?fillColor0:?fillColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fillPatternFill:?fillPatternWidth:?fillPatternHeight:?fillPatternAcross:?fillPatternScale:?pathData:?translateX:?translateY:?scaleX:?scaleY" v="1.:true:0x000000:1.:null:0x00000000:0x00000000:0x00000000:0x00000000:null:null:null:true:1:null:16:16:true:1:&quot;&quot;:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0., pathData : "", fillPatternScale : 1, fillPatternAcross : true, fillPatternHeight : 16, fillPatternWidth : 16, fillPatternFill : null, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, fillColor1 : 0x00000000, fillColor0 : 0x00000000, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternShape.QuadrilateralPattern" params="" file="src/pixelimage/triangleGML/patternShape/QuadrilateralPattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<x3 public="1"><x path="Float"/></x3>
		<y3 public="1"><x path="Float"/></y3>
		<x4 public="1"><x path="Float"/></x4>
		<y4 public="1"><x path="Float"/></y4>
		<setParameter public="1" set="method" line="61" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="83" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="47">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?fillColor0:?fillColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fillPatternFill:?fillPatternWidth:?fillPatternHeight:?fillPatternAcross:?fillPatternScale:?x1:?y1:?x2:?y2:?x3:?y3:?x4:?y4" v="1.:true:0x000000:1.:null:0x00000000:0x00000000:0x00000000:0x00000000:null:null:null:true:1:null:16:16:true:1:0.:0.:0.:0.:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y4 : 0., x4 : 0., y3 : 0., x3 : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., fillPatternScale : 1, fillPatternAcross : true, fillPatternHeight : 16, fillPatternWidth : 16, fillPatternFill : null, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, fillColor1 : 0x00000000, fillColor0 : 0x00000000, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternShape.RectanglePattern" params="" file="src/pixelimage/triangleGML/patternShape/RectanglePattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<rounded public="1"><x path="Bool"/></rounded>
		<setParameter public="1" set="method" line="53" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="69" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<buildRectangles public="1" set="method" line="81"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></buildRectangles>
		<new public="1" set="method" line="42">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?fillColor0:?fillColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fillPatternFill:?fillPatternWidth:?fillPatternHeight:?fillPatternAcross:?fillPatternScale:?left:?top:?width:?height:?rounded" v="1.:true:0x000000:1.:null:0x00000000:0x00000000:0x00000000:0x00000000:null:null:null:true:1:null:16:16:true:1:0.:0.:1.:1.:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rounded : false, height : 1., width : 1., top : 0., left : 0., fillPatternScale : 1, fillPatternAcross : true, fillPatternHeight : 16, fillPatternWidth : 16, fillPatternFill : null, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, fillColor1 : 0x00000000, fillColor0 : 0x00000000, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.patternShape.SquarePattern" params="" file="src/pixelimage/triangleGML/patternShape/SquarePattern.hx">
		<extends path="pixelimage.triangleGML.coreShape.PatternShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<diameter public="1"><x path="Float"/></diameter>
		<setParameter public="1" set="method" line="48" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="60" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<buildSquare set="method" line="71"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></buildSquare>
		<new public="1" set="method" line="39">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?strokeColor0:?strokeColor1:?fillColor0:?fillColor1:?strokePatternFill:?strokePatternWidth:?strokePatternHeight:?strokePatternAcross:?strokePatternScale:?fillPatternFill:?fillPatternWidth:?fillPatternHeight:?fillPatternAcross:?fillPatternScale:?left:?top:?diameter" v="1.:true:0x000000:1.:null:0x00000000:0x00000000:0x00000000:0x00000000:null:null:null:true:1:null:16:16:true:1:0.:0.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ diameter : 1., top : 0., left : 0., fillPatternScale : 1, fillPatternAcross : true, fillPatternHeight : 16, fillPatternWidth : 16, fillPatternFill : null, strokePatternScale : 1, strokePatternAcross : true, strokePatternHeight : null, strokePatternWidth : null, strokePatternFill : null, fillColor1 : 0x00000000, fillColor0 : 0x00000000, strokeColor1 : 0x00000000, strokeColor0 : 0x00000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="pixelimage.triangleGML.shape.ArcType" params="" file="src/pixelimage/triangleGML/shape/ArcShape.hx" module="pixelimage.triangleGML.shape.ArcShape">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="pixelimage.triangleGML.shape._ArcShape.ArcType_Impl_" params="" file="src/pixelimage/triangleGML/shape/ArcShape.hx" private="1" module="pixelimage.triangleGML.shape.ArcShape" extern="1" final="1">
	<Chord public="1" get="inline" set="null" expr="cast &quot;chord&quot;" line="7" static="1">
		<x path="pixelimage.triangleGML.shape.ArcType"/>
		<meta>
			<m n=":value"><e>cast "chord"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Chord>
	<Ellipse public="1" get="inline" set="null" expr="cast &quot;ellipse&quot;" line="8" static="1">
		<x path="pixelimage.triangleGML.shape.ArcType"/>
		<meta>
			<m n=":value"><e>cast "ellipse"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Ellipse>
	<Pie public="1" get="inline" set="null" expr="cast &quot;pie&quot;" line="9" static="1">
		<x path="pixelimage.triangleGML.shape.ArcType"/>
		<meta>
			<m n=":value"><e>cast "pie"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Pie>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="pixelimage.triangleGML.shape._ArcShape.ArcType_Impl_" params="" file="src/pixelimage/triangleGML/shape/ArcShape.hx" private="1" module="pixelimage.triangleGML.shape.ArcShape" extern="1" final="1">
		<Chord public="1" get="inline" set="null" expr="cast &quot;chord&quot;" line="7" static="1">
			<x path="pixelimage.triangleGML.shape.ArcType"/>
			<meta>
				<m n=":value"><e>cast "chord"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Chord>
		<Ellipse public="1" get="inline" set="null" expr="cast &quot;ellipse&quot;" line="8" static="1">
			<x path="pixelimage.triangleGML.shape.ArcType"/>
			<meta>
				<m n=":value"><e>cast "ellipse"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Ellipse>
		<Pie public="1" get="inline" set="null" expr="cast &quot;pie&quot;" line="9" static="1">
			<x path="pixelimage.triangleGML.shape.ArcType"/>
			<meta>
				<m n=":value"><e>cast "pie"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Pie>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="pixelimage.triangleGML.shape.ArcShape" params="" file="src/pixelimage/triangleGML/shape/ArcShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<startAngle public="1"><x path="Float"/></startAngle>
		<sweepAngle public="1"><x path="Float"/></sweepAngle>
		<arcType public="1"><x path="pixelimage.triangleGML.shape.ArcType"/></arcType>
		<rx><x path="Float"/></rx>
		<ry><x path="Float"/></ry>
		<setParameter public="1" set="method" line="50" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="74" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<chord set="method" line="89"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></chord>
		<ellipse set="method" line="111"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></ellipse>
		<pie set="method" line="115"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></pie>
		<new public="1" set="method" line="38">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?left:?top:?width:?height:?startAngle:?sweepAngle:?arcType" v="1.:true:0x000000:1.:null:0x000000:0.:0.:1.:1.:0.:0.:Pie">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="pixelimage.triangleGML.shape.ArcType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ arcType : Pie, sweepAngle : 0., startAngle : 0., height : 1., width : 1., top : 0., left : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.CircleShape" params="" file="src/pixelimage/triangleGML/shape/CircleShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<diameter public="1"><x path="Float"/></diameter>
		<setParameter public="1" set="method" line="28" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="40" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<buildCircle set="method" line="49"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></buildCircle>
		<new public="1" set="method" line="22">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?left:?top:?diameter" v="1.:true:0x000000:1.:null:0x000000:0.:0.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ diameter : 1., top : 0., left : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.ComponentShape" params="" file="src/pixelimage/triangleGML/shape/ComponentShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<setParameter public="1" set="method" line="30" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<new public="1" set="method" line="23">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?left:?top:?width:?height" v="1.:true:0x000000:1.:null:0x000000:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 1., width : 1., top : 0., left : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.triangleGML.shape.EllipseShape" params="" file="src/pixelimage/triangleGML/shape/EllipseShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<setParameter public="1" set="method" line="31" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="45" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="24">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?left:?top:?width:?height" v="1.:true:0x000000:1.:null:0x000000:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 1., width : 1., top : 0., left : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.PathElementShape" params="" file="src/pixelimage/triangleGML/shape/PathElementShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<implements path="justPath.ILinePathContext"/>
		<pathData public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</pathData>
		<translateX public="1"><x path="Float"/></translateX>
		<translateY public="1"><x path="Float"/></translateY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<x0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x0>
		<y0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y0>
		<temp><x path="pixelimage.Pixelimage"/></temp>
		<toggleDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</toggleDraw>
		<info><a>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<cy><x path="Float"/></cy>
	<cx><x path="Float"/></cx>
	<by><x path="Float"/></by>
	<bx><x path="Float"/></bx>
	<ay><x path="Float"/></ay>
	<ax><x path="Float"/></ax>
</a></info>
		<setParameter public="1" set="method" line="44" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="60" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<drawing public="1" set="method" line="72"><f a=""><x path="Void"/></f></drawing>
		<lineSegmentTo public="1" set="method" line="77"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<lineTo public="1" set="method" line="97"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="113"><f a="x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<new public="1" set="method" line="23">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?pathData:?translateX:?translateY:?scaleX:?scaleY" v="1.:true:0x000000:1.:null:0x000000:&quot;&quot;:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0., pathData : "", fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.PathSoftElementShape" params="" file="src/pixelimage/triangleGML/shape/PathSoftElementShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<implements path="justPath.ILinePathContext"/>
		<pathData public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</pathData>
		<translateX public="1"><x path="Float"/></translateX>
		<translateY public="1"><x path="Float"/></translateY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<x0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x0>
		<y0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y0>
		<temp><x path="pixelimage.Pixelshape"/></temp>
		<soft><x path="Float"/></soft>
		<toggleDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</toggleDraw>
		<info><a>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<cy><x path="Float"/></cy>
	<cx><x path="Float"/></cx>
	<by><x path="Float"/></by>
	<bx><x path="Float"/></bx>
	<ay><x path="Float"/></ay>
	<ax><x path="Float"/></ax>
</a></info>
		<setParameter public="1" set="method" line="46" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="64" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<drawing public="1" set="method" line="76"><f a=""><x path="Void"/></f></drawing>
		<lineSegmentTo public="1" set="method" line="81"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<lineTo public="1" set="method" line="101"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="117"><f a="x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<new public="1" set="method" line="23">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?soft:?pathData:?translateX:?translateY:?scaleX:?scaleY" v="1.:true:0x000000:1.:null:0x000000:40.:&quot;&quot;:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0., pathData : "", soft : 40., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="pixelimage.triangleGML.shape.QuadrilateralShape" params="" file="src/pixelimage/triangleGML/shape/QuadrilateralShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<x3 public="1"><x path="Float"/></x3>
		<y3 public="1"><x path="Float"/></y3>
		<x4 public="1"><x path="Float"/></x4>
		<y4 public="1"><x path="Float"/></y4>
		<setParameter public="1" set="method" line="44" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="66" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="33">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?x1:?y1:?x2:?y2:?x3:?y3:?x4:?y4" v="1.:true:0x000000:1.:null:0x000000:0.:0.:0.:0.:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y4 : 0., x4 : 0., y3 : 0., x3 : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.RectangleShape" params="" file="src/pixelimage/triangleGML/shape/RectangleShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<rounded public="1"><x path="Bool"/></rounded>
		<setParameter public="1" set="method" line="35" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="51" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="27">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?left:?top:?width:?height:?rounded" v="1.:true:0x000000:1.:null:0x000000:0.:0.:1.:1.:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rounded : false, height : 1., width : 1., top : 0., left : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.SquareShape" params="" file="src/pixelimage/triangleGML/shape/SquareShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<diameter public="1"><x path="Float"/></diameter>
		<rounded public="1"><x path="Bool"/></rounded>
		<setParameter public="1" set="method" line="35" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="49" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<buildSquare set="method" line="61"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></buildSquare>
		<buildRounded set="method" line="65"><f a="temp">
	<x path="pixelimage.Pixelshape"/>
	<x path="Void"/>
</f></buildRounded>
		<new public="1" set="method" line="28">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?left:?top:?diameter:?rounded" v="1.:true:0x000000:1.:null:0x000000:0.:0.:1.:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rounded : false, diameter : 1., top : 0., left : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.Star6Shape" params="" file="src/pixelimage/triangleGML/shape/Star6Shape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<diameter public="1"><x path="Float"/></diameter>
		<rotation public="1"><x path="Float"/></rotation>
		<setParameter public="1" set="method" line="34" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="49" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="27">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?left:?top:?diameter:?rotation" v="1.:true:0x000000:1.:null:0x000000:0.:0.:1.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rotation : 0., diameter : 1., top : 0., left : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.TriangleShape" params="" file="src/pixelimage/triangleGML/shape/TriangleShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<x1 public="1"><x path="Float"/></x1>
		<y1 public="1"><x path="Float"/></y1>
		<x2 public="1"><x path="Float"/></x2>
		<y2 public="1"><x path="Float"/></y2>
		<x3 public="1"><x path="Float"/></x3>
		<y3 public="1"><x path="Float"/></y3>
		<setParameter public="1" set="method" line="38" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="56" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="29">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?x1:?y1:?x2:?y2:?x3:?y3" v="1.:true:0x000000:1.:null:0x000000:0.:0.:0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y3 : 0., x3 : 0., y2 : 0., x2 : 0., y1 : 0., x1 : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.shape.VePathElementShape" params="" file="src/pixelimage/triangleGML/shape/VePathElementShape.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<implements path="justPath.ILinePathContext"/>
		<pathData public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</pathData>
		<strokeColors public="1"><x path="Null"><c path="Array"><x path="Int"/></c></x></strokeColors>
		<strokeWidths public="1"><x path="Null"><c path="Array"><x path="Float"/></c></x></strokeWidths>
		<translateX public="1"><x path="Float"/></translateX>
		<translateY public="1"><x path="Float"/></translateY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<sp public="1"><c path="justPath.SvgLinePath"/></sp>
		<x0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</x0>
		<y0 expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</y0>
		<temp><x path="pixelimage.Pixelshape"/></temp>
		<toggleDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</toggleDraw>
		<info><a>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<cy><x path="Float"/></cy>
	<cx><x path="Float"/></cx>
	<by><x path="Float"/></by>
	<bx><x path="Float"/></bx>
	<ay><x path="Float"/></ay>
	<ax><x path="Float"/></ax>
</a></info>
		<setParameter public="1" set="method" line="49" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="71" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<drawing public="1" set="method" line="93"><f a=""><x path="Void"/></f></drawing>
		<lineSegmentTo public="1" set="method" line="98"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineSegmentTo>
		<lineTo public="1" set="method" line="118"><f a="x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="131"><f a="x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<new public="1" set="method" line="26">
			<f a="?opacity:?visibility:?strokeColors:?strokeWidths:?strokeDashGapArray:?fill:?pathData:?translateX:?translateY:?scaleX:?scaleY" v="1.:true:null:null:null:0x000000:&quot;&quot;:0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1., scaleX : 1., translateY : 0., translateX : 0., pathData : "", fill : 0x000000, strokeDashGapArray : null, strokeWidths : null, strokeColors : null, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="pixelimage.triangleGML.textureShape.ImageElement" params="" file="src/pixelimage/triangleGML/textureShape/ImageElement.hx">
		<extends path="pixelimage.triangleGML.coreShape.FillShape"/>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<content public="1"><c path="String"/></content>
		<setParameter public="1" set="method" line="34" override="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setParameter>
		<render public="1" set="method" line="50" override="1"><f a="pixelShape">
	<x path="pixelimage.Pixelshape"/>
	<x path="pixelimage.Pixelshape"/>
</f></render>
		<new public="1" set="method" line="26">
			<f a="?opacity:?visibility:?strokeColor:?strokeWidth:?strokeDashGapArray:?fill:?left:?top:?width:?height:?content" v="1.:true:0x000000:1.:null:0x000000:0.:0.:1.:1.:&quot;&quot;">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="pixelimage.triangleGML.coreShape.DashGap"/></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ content : "", height : 1., width : 1., top : 0., left : 0., fill : 0x000000, strokeDashGapArray : null, strokeWidth : 1., strokeColor : 0x000000, visibility : true, opacity : 1. }</e></m></meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<typedef path="sys.FileStat" params="" file="/home/nanjizal/haxe/versions/779b005/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<class path="sys.FileSystem" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/FileSystem.hx" extern="1">
		<exists public="1" set="method" line="30" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` exists.</haxe_doc>
		</exists>
		<rename public="1" set="method" line="34" static="1">
			<f a="path:newPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Renames/moves the file or directory specified by `path` to `newPath`.

		If `path` is not a valid file system entry, or if it is not accessible,
		or if `newPath` is not accessible, an exception is thrown.</haxe_doc>
		</rename>
		<stat public="1" set="method" line="38" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `FileStat` information for the file or directory specified by
		`path`.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" line="60" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. Symlinks will be
		followed and the path will be normalized.</haxe_doc>
		</fullPath>
		<absolutePath public="1" set="method" line="64" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. The path doesn't
		have to exist.</haxe_doc>
		</absolutePath>
		<kind get="inline" set="null" line="70" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></kind>
		<isDirectory public="1" set="method" line="74" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is not
		accessible, an exception is thrown.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" line="78" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" line="92" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" line="96" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`. Only empty directories can
		be deleted.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" line="100" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`. `"."` and `".."` are not included in the output.

		If `path` does not denote a valid directory, an exception is thrown.</haxe_doc>
		</readDirectory>
		<makeCompatiblePath get="inline" set="null" line="104" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></makeCompatiblePath>
		<haxe_doc>This class provides information about files and directories.

	If `null` is passed as a file path to any function in this class, the
	result is unspecified, and may differ from target to target.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.Http" params="" file="/home/nanjizal/haxe/versions/779b005/std/sys/Http.hx">
		<extends path="haxe.http.HttpBase"/>
		<PROXY public="1" expr="null" line="46" static="1">
			<a>
				<port><x path="Int"/></port>
				<host><c path="String"/></host>
				<auth><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></auth>
			</a>
			<meta><m n=":value"><e>null</e></m></meta>
		</PROXY>
		<noShutdown public="1"><x path="Bool"/></noShutdown>
		<cnxTimeout public="1"><x path="Float"/></cnxTimeout>
		<responseHeaders public="1"><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></responseHeaders>
		<chunk_size><x path="Null"><x path="Int"/></x></chunk_size>
		<chunk_buf><c path="haxe.io.Bytes"/></chunk_buf>
		<file><a>
	<size><x path="Int"/></size>
	<param><c path="String"/></param>
	<mimeType><c path="String"/></mimeType>
	<io><c path="haxe.io.Input"/></io>
	<filename><c path="String"/></filename>
</a></file>
		<request public="1" set="method" line="56"><f a="?post">
	<x path="Bool"/>
	<x path="Void"/>
</f></request>
		<customRequest public="1" set="method" line="90"><f a="post:api:?sock:?method">
	<x path="Bool"/>
	<c path="haxe.io.Output"/>
	<c path="sys.net.Socket"/>
	<c path="String"/>
	<x path="Void"/>
</f></customRequest>
		<writeBody set="method" line="255"><f a="body:fileInput:fileSize:boundary:sock">
	<x path="Null"><c path="haxe.io.BytesOutput"/></x>
	<x path="Null"><c path="haxe.io.Input"/></x>
	<x path="Int"/>
	<x path="Null"><c path="String"/></x>
	<c path="sys.net.Socket"/>
	<x path="Void"/>
</f></writeBody>
		<readHttpResponse set="method" line="280"><f a="api:sock">
	<c path="haxe.io.Output"/>
	<c path="sys.net.Socket"/>
	<x path="Void"/>
</f></readHttpResponse>
		<readChunk set="method" line="422"><f a="chunk_re:api:buf:len">
	<c path="EReg"/>
	<c path="haxe.io.Output"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></readChunk>
		<new public="1" set="method" line="48"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.io.File" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/io/File.hx" extern="1">
		<getContent public="1" set="method" line="29" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<getBytes public="1" set="method" line="33" static="1">
			<f a="path">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the binary content of the file specified by `path`.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getBytes>
		<saveContent public="1" set="method" line="38" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<saveBytes public="1" set="method" line="44" static="1">
			<f a="path:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `bytes` in the file specified by `path` in binary mode.

		If the file cannot be written to, an exception is thrown.

		If `path` or `bytes` are null, the result is unspecified.</haxe_doc>
		</saveBytes>
		<read public="1" set="method" line="50" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file does not exist or can not be read, an exception is thrown.

		Operations on the returned `FileInput` handle read on the opened file.

		File handles should be closed via `FileInput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" line="54" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<append public="1" set="method" line="58" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Similar to `sys.io.File.write`, but appends to the file if it exists
		instead of overwriting its contents.</haxe_doc>
		</append>
		<update public="1" set="method" line="62" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Similar to `sys.io.File.append`. While `append` can only seek or write
		starting from the end of the file's previous contents, `update` can
		seek to any position, so the file's previous contents can be
		selectively overwritten.</haxe_doc>
		</update>
		<copy public="1" set="method" line="69" static="1">
			<f a="srcPath:dstPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the contents of the file specified by `srcPath` to the file
		specified by `dstPath`.

		If the `srcPath` does not exist or cannot be read, or if the `dstPath`
		file cannot be written to, an exception is thrown.

		If the file at `dstPath` exists, its contents are overwritten.

		If `srcPath` or `dstPath` are null, the result is unspecified.</haxe_doc>
		</copy>
		<haxe_doc>API for reading and writing files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/io/FileInput.hx" extern="1">
		<extends path="haxe.io.Input"/>
		<__f><d/></__f>
		<readByte public="1" set="method" line="36" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<readBytes public="1" set="method" line="47" override="1">
			<f a="s:p:l">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</readBytes>
		<close public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></close>
		<seek public="1" set="method" line="63"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method" line="67"><f a=""><x path="Int"/></f></tell>
		<eof public="1" set="method" line="71"><f a=""><x path="Bool"/></f></eof>
		<new set="method" line="32"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<__f><d/></__f>
		<writeByte public="1" set="method" line="36" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="43" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="32"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.net.Host" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/net/Host.hx">
		<host public="1" set="null">
			<c path="String"/>
			<haxe_doc>The provided host string.</haxe_doc>
		</host>
		<ip public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The actual IP corresponding to the host.</haxe_doc>
		</ip>
		<ipv6 set="null"><t path="haxe.io.BytesData"/></ipv6>
		<new public="1" set="method" line="35">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Host : the name can be an IP in the form "127.0.0.1" or an host name such as "google.com", in which case
		the corresponding IP address is resolved using DNS. An exception occur if the host name could not be found.</haxe_doc>
		</new>
		<haxe_doc>A given IP host name.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.net._Socket.SocketInput" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket" extern="1">
		<extends path="haxe.io.Input"/>
		<__s><d/></__s>
		<readByte public="1" set="method" line="37" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="50" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="67" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="33"><f a="s">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="sys.net._Socket.SocketOutput" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket" extern="1">
		<extends path="haxe.io.Output"/>
		<__s><d/></__s>
		<writeByte public="1" set="method" line="81" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="94" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="107" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="77"><f a="s">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="sys.net.Socket" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/net/Socket.hx" extern="1">
		<select public="1" set="method" line="265" static="1">
			<f a="read:write:others:?timeout">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<x path="Float"/>
				<a>
					<write><c path="Array"><c path="sys.net.Socket"/></c></write>
					<read><c path="Array"><c path="sys.net.Socket"/></c></read>
					<others><c path="Array"><c path="sys.net.Socket"/></c></others>
				</a>
			</f>
			<haxe_doc>Wait until one of the sockets group is ready for the given operation:

		 - `read` contains sockets on which we want to wait for available data to be read,
		 - `write` contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
		 - `others` contains sockets on which we want to wait for exceptional conditions.
		 - `select` will block until one of the condition is met, in which case it will return the sockets for which the condition was true.

		In case a `timeout` (in seconds) is specified, select might wait at worst until the timeout expires.</haxe_doc>
		</select>
		<__s><d/></__s>
		<__timeout expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</__timeout>
		<__blocking expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__blocking>
		<__fastSend expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__fastSend>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use `setBlocking(false)` or `setTimeout` to prevent infinite waiting.</haxe_doc>
		</input>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use `setBlocking(false)` or `setTimeout` to prevent that.</haxe_doc>
		</output>
		<custom public="1">
			<d/>
			<haxe_doc>A custom value that can be associated with the socket. Can be used to retrieve your custom infos after a `select`.
	*</haxe_doc>
		</custom>
		<init set="method" line="133"><f a=""><x path="Void"/></f></init>
		<close public="1" set="method" line="145">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<read public="1" set="method" line="157">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read the whole data available on the socket.

		*Note*: this is **not** meant to be used together with `setBlocking(false)`,
		as it will always throw `haxe.io.Error.Blocked`. `input` methods should be used directly instead.</haxe_doc>
		</read>
		<write public="1" set="method" line="165">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write the whole data to the socket output.

		*Note*: this is **not** meant to be used together with `setBlocking(false)`, as
		`haxe.io.Error.Blocked` may be thrown mid-write with no indication of how many bytes have been written.
		`output.writeBytes()` should be used instead as it returns this information.</haxe_doc>
		</write>
		<connect public="1" set="method" line="169">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't successfully connect.</haxe_doc>
		</connect>
		<listen public="1" set="method" line="194">
			<f a="connections">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use `accept()` to accept incoming connections.</haxe_doc>
		</listen>
		<shutdown public="1" set="method" line="198">
			<f a="read:write">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shutdown the socket, either for reading or writing.</haxe_doc>
		</shutdown>
		<bind public="1" set="method" line="202">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bind the socket to the given host/port so it can afterwards listen for connections there.</haxe_doc>
		</bind>
		<accept public="1" set="method" line="216">
			<f a=""><c path="sys.net.Socket"/></f>
			<haxe_doc>Accept a new connected client. This will return a connected socket on which you can read/write some data.</haxe_doc>
		</accept>
		<peer public="1" set="method" line="225">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Return the information about the other side of a connected socket.</haxe_doc>
		</peer>
		<host public="1" set="method" line="235">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Return the information about our side of a connected socket.</haxe_doc>
		</host>
		<setTimeout public="1" set="method" line="245">
			<f a="timeout">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Gives a timeout (in seconds) after which blocking socket operations (such as reading and writing) will abort and throw an exception.</haxe_doc>
		</setTimeout>
		<waitForRead public="1" set="method" line="250">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Block until some data is available for read on the socket.</haxe_doc>
		</waitForRead>
		<setBlocking public="1" set="method" line="254">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediately by throwing a haxe.io.Error.Blocked value.</haxe_doc>
		</setBlocking>
		<setFastSend public="1" set="method" line="259">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediately send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<new public="1" set="method" line="129">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.ssl.Certificate" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Certificate.hx" extern="1">
		<loadFile public="1" set="method" line="38" static="1"><f a="file">
	<c path="String"/>
	<c path="sys.ssl.Certificate"/>
</f></loadFile>
		<loadPath public="1" set="method" line="42" static="1"><f a="path">
	<c path="String"/>
	<c path="sys.ssl.Certificate"/>
</f></loadPath>
		<fromString public="1" set="method" line="46" static="1"><f a="str">
	<c path="String"/>
	<c path="sys.ssl.Certificate"/>
</f></fromString>
		<loadDefaults public="1" set="method" line="50" static="1"><f a=""><c path="sys.ssl.Certificate"/></f></loadDefaults>
		<__h><x path="Null"><c path="sys.ssl.Certificate"/></x></__h>
		<__x><d/></__x>
		<commonName public="1" get="accessor" set="null"><x path="Null"><c path="String"/></x></commonName>
		<altNames public="1" get="accessor" set="null"><c path="Array"><c path="String"/></c></altNames>
		<notBefore public="1" get="accessor" set="null"><c path="Date"/></notBefore>
		<notAfter public="1" get="accessor" set="null"><c path="Date"/></notAfter>
		<get_commonName set="method" line="94"><f a=""><x path="Null"><c path="String"/></x></f></get_commonName>
		<get_altNames set="method" line="98"><f a=""><c path="Array"><c path="String"/></c></f></get_altNames>
		<subject public="1" set="method" line="102"><f a="field">
	<c path="String"/>
	<x path="Null"><c path="String"/></x>
</f></subject>
		<issuer public="1" set="method" line="106"><f a="field">
	<c path="String"/>
	<x path="Null"><c path="String"/></x>
</f></issuer>
		<get_notBefore set="method" line="110"><f a=""><c path="Date"/></f></get_notBefore>
		<get_notAfter set="method" line="115"><f a=""><c path="Date"/></f></get_notAfter>
		<next public="1" set="method" line="120"><f a=""><x path="Null"><c path="sys.ssl.Certificate"/></x></f></next>
		<add public="1" set="method" line="125"><f a="pem">
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<addDER public="1" set="method" line="129"><f a="der">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></addDER>
		<new set="method" line="33">
			<f a="x:?h">
				<d/>
				<c path="sys.ssl.Certificate"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>sys.ssl.Socket</e></m></meta>
		</new>
		<meta><m n=":coreApi"/></meta>
	</class>
	<typedef path="sys.ssl._Key.PKEY" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Key.hx" private="1" module="sys.ssl.Key"><d/></typedef>
	<class path="sys.ssl.Key" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Key.hx" extern="1">
		<loadFile public="1" set="method" line="37" static="1"><f a="file:?isPublic:?pass">
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="sys.ssl.Key"/>
</f></loadFile>
		<readPEM public="1" set="method" line="46" static="1"><f a="data:isPublic:?pass">
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="sys.ssl.Key"/>
</f></readPEM>
		<readDER public="1" set="method" line="50" static="1"><f a="data:isPublic">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
	<c path="sys.ssl.Key"/>
</f></readDER>
		<__k><t path="sys.ssl._Key.PKEY"/></__k>
		<new set="method" line="33"><f a="k">
	<t path="sys.ssl._Key.PKEY"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":coreApi"/></meta>
	</class>
	<typedef path="sys.ssl._Socket.SocketHandle" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket"><d/></typedef>
	<typedef path="sys.ssl._Socket.CONF" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket"><d/></typedef>
	<typedef path="sys.ssl._Socket.SSL" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket"><d/></typedef>
	<class path="sys.ssl._Socket.SocketInput" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket" extern="1">
		<extends path="haxe.io.Input"/>
		<__s>
			<c path="sys.ssl.Socket"/>
			<meta><m n=":allow"><e>sys.ssl.Socket</e></m></meta>
		</__s>
		<readByte public="1" set="method" line="39" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="53" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="71" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="35"><f a="s">
	<c path="sys.ssl.Socket"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="sys.ssl._Socket.SocketOutput" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket" extern="1">
		<extends path="haxe.io.Output"/>
		<__s>
			<c path="sys.ssl.Socket"/>
			<meta><m n=":allow"><e>sys.ssl.Socket</e></m></meta>
		</__s>
		<writeByte public="1" set="method" line="85" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="99" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="111" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="81"><f a="s">
	<c path="sys.ssl.Socket"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="sys.ssl.Socket" params="" file="/home/nanjizal/haxe/versions/779b005/std/cpp/_std/sys/ssl/Socket.hx" extern="1">
		<extends path="sys.net.Socket"/>
		<DEFAULT_VERIFY_CERT public="1" expr="true" line="120" static="1">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":value"><e>true</e></m></meta>
		</DEFAULT_VERIFY_CERT>
		<DEFAULT_CA public="1" static="1"><x path="Null"><c path="sys.ssl.Certificate"/></x></DEFAULT_CA>
		<conf><t path="sys.ssl._Socket.CONF"/></conf>
		<ssl><t path="sys.ssl._Socket.SSL"/></ssl>
		<verifyCert public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>Define if peer certificate is verified during SSL handshake.</haxe_doc>
		</verifyCert>
		<caCert><x path="Null"><c path="sys.ssl.Certificate"/></x></caCert>
		<hostname><c path="String"/></hostname>
		<ownCert><x path="Null"><c path="sys.ssl.Certificate"/></x></ownCert>
		<ownKey><x path="Null"><c path="sys.ssl.Key"/></x></ownKey>
		<altSNIContexts><x path="Null"><c path="Array"><a>
	<match><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></match>
	<key><c path="sys.ssl.Key"/></key>
	<cert><c path="sys.ssl.Certificate"/></cert>
</a></c></x></altSNIContexts>
		<sniCallback><d/></sniCallback>
		<handshakeDone><x path="Bool"/></handshakeDone>
		<init set="method" line="138" override="1"><f a=""><x path="Void"/></f></init>
		<connect public="1" set="method" line="151" override="1"><f a="host:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
		<handshake public="1" set="method" line="173">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Perform the SSL handshake.</haxe_doc>
		</handshake>
		<setCA public="1" set="method" line="187">
			<f a="cert">
				<c path="sys.ssl.Certificate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Configure the certificate chain for peer certificate verification.</haxe_doc>
		</setCA>
		<setHostname public="1" set="method" line="191">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Configure the hostname for Server Name Indication TLS extension.</haxe_doc>
		</setHostname>
		<setCertificate public="1" set="method" line="195">
			<f a="cert:key">
				<c path="sys.ssl.Certificate"/>
				<c path="sys.ssl.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Configure own certificate and private key.</haxe_doc>
		</setCertificate>
		<read public="1" set="method" line="200" override="1"><f a=""><c path="String"/></f></read>
		<write public="1" set="method" line="208" override="1"><f a="content">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<close public="1" set="method" line="213" override="1"><f a=""><x path="Void"/></f></close>
		<addSNICertificate public="1" set="method" line="228">
			<f a="cbServernameMatch:cert:key">
				<f a="">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<c path="sys.ssl.Certificate"/>
				<c path="sys.ssl.Key"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Configure additionals certificates and private keys for Server Name Indication extension.
		The callback may be called during handshake to determine the certificate to use.</haxe_doc>
		</addSNICertificate>
		<bind public="1" set="method" line="234" override="1"><f a="host:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bind>
		<accept public="1" set="method" line="240" override="1"><f a=""><c path="sys.ssl.Socket"/></f></accept>
		<peerCertificate public="1" set="method" line="255">
			<f a=""><c path="sys.ssl.Certificate"/></f>
			<haxe_doc>Return the certificate received from the other side of a connection.</haxe_doc>
		</peerCertificate>
		<buildSSLConfig set="method" line="260"><f a="server">
	<x path="Bool"/>
	<t path="sys.ssl._Socket.CONF"/>
</f></buildSSLConfig>
		<new public="1" set="method" line="119"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A TLS socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="vision.algorithms.BilinearInterpolation" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/algorithms/BilinearInterpolation.hx">
		<interpolate public="1" set="method" line="6" static="1"><f a="image:width:height">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Image"/>
</f></interpolate>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.Radix" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/algorithms/Radix.hx">
		<getMax params="T:Uint:Int64" set="method" line="34" static="1">
			<f a="array:?endIndex">
				<c path="Array"><c path="getMax.T"/></c>
				<x path="Int"/>
				<c path="getMax.T"/>
			</f>
			<haxe_doc>* Gets the maximum in array `array`.
	 * @param array an array of type `Int`, `Int64` or `UInt`
	 * @param endIndex optional, an index after which we stop checking for a maximum 
	 * (useful if the range in which the maximum value is present is known)</haxe_doc>
		</getMax>
		<countingSort params="T:Uint:Int64" set="method" line="52" static="1">
			<f a="array:exp:?endIndex">
				<c path="Array"><c path="countingSort.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="countingSort.T"/></c>
			</f>
			<haxe_doc>* Does a counting sort on `array` according to the digit's placement represented by `exp`
	 * @param array an array of type `Int`, `Int64` or `UInt`
	 * @param exp Represents the digit's "place" on which were going to count - `10` will count on the last digit, `100` will count on the second-to-last, etc.
	 * @param endIndex optional, an index after which we stop sorting</haxe_doc>
		</countingSort>
		<sort public="1" params="T:Uint:Int64" set="method" line="91" static="1">
			<f a="array">
				<c path="Array"><c path="sort.T"/></c>
				<c path="Array"><c path="sort.T"/></c>
			</f>
			<haxe_doc>Sorts an array of `Int`s / `UInt`s / `Int64` using **Radix Sort**.</haxe_doc>
		</sort>
		<haxe_doc>An implementation of radix sort in Haxe, by [Shahar Marcus](https://www.github.com/ShaharMS).

	Radix vs. ArraySort.sort:

	|Radix                                 | ArraySort.sort                |
	|:------------------------------------:|:-----------------------------:|
	|length: 38, time: 0.000s              | length: 38, time: 0.000s      |
	|length: 74, time: 0.000s              | length: 74, time: 0.000s      |
	|length: 146, time: 0.001s             | length: 146, time: 0.001s     |
	|length: 290, time: 0.001s             | length: 290, time: 0.002s     |
	|length: 578, time: 0.003s             | length: 578, time: 0.003s     |
	|length: 1154, time: 0.005s            | length: 1154, time: 0.006s    |
	|length: 2306, time: 0.01s             | length: 2306, time: 0.012s    |
	|length: 4610, time: 0.02s             | length: 4610, time: 0.022s    |
	|length: 9218, time: 0.0591s           | length: 9218, time: 0.048s    |
	|length: 18434, time: 0.0701s          | length: 18434, time: 0.0961s  |
	|length: 36866, time: 0.1614s          | length: 36866, time: 0.1882s  |
	|length: 73730, time: 0.3123s          | length: 73730, time: 0.3856s  |
	|length: 147458, time: 0.5837s         | length: 147458, time: 0.7417s |
	|length: 294914, time: 1.1621s         | length: 294914, time: 1.6143s |
	|length: 589826, time: 2.3471s         | length: 589826, time: 3.0588s |
	|length: 1179650, time: 4.7839s        | length: 1179650, time: 6.1441s|</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.ds.Array2D" params="T" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Array2D.hx">
		<inner public="1">
			<c path="Array"><c path="vision.ds.Array2D.T"/></c>
			<haxe_doc><![CDATA[The underlying `Array<T>` instance that holds the data.]]></haxe_doc>
		</inner>
		<width public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>The 2D array's width.</haxe_doc>
		</width>
		<height public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>The 2D array's height.</haxe_doc>
		</height>
		<length public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The amount of elements in this `Array2D`.</haxe_doc>
		</length>
		<get public="1" get="inline" set="null" line="47">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<c path="vision.ds.Array2D.T"/>
			</f>
			<haxe_doc>Gets the element at row `x`, column `y`</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="54">
			<f a="x:y:val">
				<x path="Int"/>
				<x path="Int"/>
				<c path="vision.ds.Array2D.T"/>
				<c path="vision.ds.Array2D.T"/>
			</f>
			<haxe_doc>Sets the element at row `x`, column `y`</haxe_doc>
		</set>
		<iterator public="1" get="inline" set="null" line="65">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="vision.ds.Array2D.T"/></c></f>
			<haxe_doc><![CDATA[Returns an array iterator for this `Array2D`.
	    
		Values are iterated on from left to right, top to bottom:
		
		`(x, y)...(x + 5, y) -> (x, y + 1)...(x + 5, y + 1) -> (x, y + 2)...`]]></haxe_doc>
		</iterator>
		<get_length get="inline" set="null" line="69"><f a=""><x path="Int"/></f></get_length>
		<set_length get="inline" set="null" line="73"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
		<set_width get="inline" set="null" line="78"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<set_height get="inline" set="null" line="83"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<new public="1" get="inline" set="null" line="36">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Array2D` instance. The created array can be filled in with non-null values, and thats target-dependent:

		 - on dynamic targets, values are always `null`
		 - on static targets, `0`, `0.0` or `false` are filled in for Int, Float and Bool respectively. Other types are filled in with `null`
	    
	    @param width The array's width
	    @param height The array's height</haxe_doc>
		</new>
		<haxe_doc><![CDATA[A 2D array, faster than an `Array<Array<T>>`.]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.ds.ByteArray" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ByteArray.hx">
		<from><icast><c path="haxe.io.Bytes"/></icast></from>
		<this><c path="haxe.io.Bytes"/></this>
		<to><icast><c path="haxe.io.Bytes"/></icast></to>
		<haxe_doc>An abstract over `haxe.io.Bytes`, allows array access.</haxe_doc>
		<meta><m n=":forward"/></meta>
		<impl><class path="vision.ds._ByteArray.ByteArray_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ByteArray.hx" private="1" module="vision.ds.ByteArray" final="1">
	<read get="inline" set="null" line="11" static="1">
		<f a="this:index">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</read>
	<write get="inline" set="null" line="15" static="1">
		<f a="this:index:value">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</write>
	<_new public="1" get="inline" set="null" line="22" static="1">
		<f a="length">
			<x path="Int"/>
			<x path="vision.ds.ByteArray"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new `ByteArray`</haxe_doc>
	</_new>
</class></impl>
	</abstract>
	<class path="vision.ds._ByteArray.ByteArray_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ByteArray.hx" private="1" module="vision.ds.ByteArray" final="1">
		<read get="inline" set="null" line="11" static="1">
			<f a="this:index">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</read>
		<write get="inline" set="null" line="15" static="1">
			<f a="this:index:value">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</write>
		<_new public="1" get="inline" set="null" line="22" static="1">
			<f a="length">
				<x path="Int"/>
				<x path="vision.ds.ByteArray"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new `ByteArray`</haxe_doc>
		</_new>
	</class>
	<abstract path="vision.ds.Color" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Color.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</to>
		<impl><class path="vision.ds._Color.Color_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Color.hx" private="1" module="vision.ds.Color" final="1">
	<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="19" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0x00000000</e></m></meta>
		<haxe_doc><![CDATA[&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;]]></haxe_doc>
	</TRANSPARENT>
	<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="24" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/ffffff.png)![color](https://www.colorhexa.com/ffffff.png)</haxe_doc>
	</WHITE>
	<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="29" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF808080</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/808080.png)![color](https://www.colorhexa.com/808080.png)</haxe_doc>
	</GRAY>
	<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="34" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF000000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/000000.png)![color](https://www.colorhexa.com/000000.png)</haxe_doc>
	</BLACK>
	<GREEN public="1" get="inline" set="null" expr="0xFF00FF00" line="39" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/00ff00.png)![color](https://www.colorhexa.com/00ff00.png)</haxe_doc>
	</GREEN>
	<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="44" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFFF00.png)![color](https://www.colorhexa.com/FFFF00.png)</haxe_doc>
	</YELLOW>
	<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="49" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFA500.png)![color](https://www.colorhexa.com/FFA500.png)</haxe_doc>
	</ORANGE>
	<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="54" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF0000.png)![color](https://www.colorhexa.com/FF0000.png)</haxe_doc>
	</RED>
	<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="59" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF800080</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/800080.png)![color](https://www.colorhexa.com/800080.png)</haxe_doc>
	</PURPLE>
	<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="64" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/0000ff.png)![color](https://www.colorhexa.com/0000ff.png)</haxe_doc>
	</BLUE>
	<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="69" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/8B4513.png)![color](https://www.colorhexa.com/8B4513.png)</haxe_doc>
	</BROWN>
	<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="74" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFC0CB.png)![color](https://www.colorhexa.com/FFC0CB.png)</haxe_doc>
	</PINK>
	<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="79" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF00FF.png)![color](https://www.colorhexa.com/FF00FF.png)</haxe_doc>
	</MAGENTA>
	<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="84" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/00FFFF.png)![color](https://www.colorhexa.com/00FFFF.png)</haxe_doc>
	</CYAN>
	<SILVER public="1" get="inline" set="null" expr="0xC0C0C0" line="89" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xC0C0C0</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/C0C0C0.png)![color](https://www.colorhexa.com/C0C0C0.png)</haxe_doc>
	</SILVER>
	<GOLD public="1" get="inline" set="null" expr="0xFFFFD700" line="94" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFD700.png)![color](https://www.colorhexa.com/FFD700.png)</haxe_doc>
	</GOLD>
	<OLIVE public="1" get="inline" set="null" expr="0xFF808000" line="99" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF808000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/808000.png)![color](https://www.colorhexa.com/808000.png)</haxe_doc>
	</OLIVE>
	<MAROON public="1" get="inline" set="null" expr="0xFF800000" line="104" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF800000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/800000.png)![color](https://www.colorhexa.com/800000.png)</haxe_doc>
	</MAROON>
	<NAVY public="1" get="inline" set="null" expr="0xFF000080" line="109" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF000080</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/000080.png)![color](https://www.colorhexa.com/000080.png)</haxe_doc>
	</NAVY>
	<TEAL public="1" get="inline" set="null" expr="0xFF008080" line="114" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF008080</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/008080.png)![color](https://www.colorhexa.com/008080.png)</haxe_doc>
	</TEAL>
	<FUCHSIA public="1" get="inline" set="null" expr="0xFFFF00FF" line="119" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF00FF.png)![color](https://www.colorhexa.com/FF00FF.png)</haxe_doc>
	</FUCHSIA>
	<AQUA public="1" get="inline" set="null" expr="0xFF00FFFF" line="124" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/00FFFF.png)![color](https://www.colorhexa.com/00FFFF.png)</haxe_doc>
	</AQUA>
	<LIME public="1" get="inline" set="null" expr="0xFF32CD32" line="129" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF32CD32</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/32CD32.png)![color](https://www.colorhexa.com/32CD32.png)</haxe_doc>
	</LIME>
	<ROYAL_BLUE public="1" get="inline" set="null" expr="0xFF4169E1" line="134" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF4169E1</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/4169E1.png)![color](https://www.colorhexa.com/4169E1.png)</haxe_doc>
	</ROYAL_BLUE>
	<red public="1" get="accessor" set="accessor" static="1"><x path="Int"/></red>
	<blue public="1" get="accessor" set="accessor" static="1"><x path="Int"/></blue>
	<green public="1" get="accessor" set="accessor" static="1"><x path="Int"/></green>
	<alpha public="1" get="accessor" set="accessor" static="1"><x path="Int"/></alpha>
	<redFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></redFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></blueFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></greenFloat>
	<alphaFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></alphaFloat>
	<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
	<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
	<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
	<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
	<rgb public="1" get="accessor" set="accessor" static="1">
		<x path="vision.ds.Color"/>
		<haxe_doc>The red, green and blue channels of this color as a 24 bit integer (from 0 to 0xFFFFFF, does not include alpha values)</haxe_doc>
	</rgb>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<COLOR_REGEX expr="~/^(0x|#)(([A-F0-9]{2}){3,4})$/" line="176" static="1">
		<c path="EReg"/>
		<meta><m n=":value"><e>~/^(0x|#)(([A-F0-9]{2}){3,4})$/</e></m></meta>
	</COLOR_REGEX>
	<fromInt public="1" get="inline" set="null" line="184" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Create a color from the least significant four bytes of an Int

		@param value Int with bytes in the format 0xAARRGGBB
		@return	The color as a Color</haxe_doc>
	</fromInt>
	<fromRGBA public="1" get="inline" set="null" line="197" static="1">
		<f a="Red:Green:Blue:?Alpha" v=":::255">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
		<haxe_doc>Generate a color from integer RGB values (0 to 255)

		@param Red	The red value of the color from 0 to 255
		@param Green	The green value of the color from 0 to 255
		@param Blue	The green value of the color from 0 to 255
		@param Alpha	How opaque the color should be, from 0 to 255
		@return The color as a Color</haxe_doc>
	</fromRGBA>
	<from8Bit public="1" get="inline" set="null" line="208" static="1">
		<f a="Value">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc><![CDATA[Generate a grayscale color from a single color channel value (0 to 255)

		@param Value	The channel value of the red, green & blue channels of the color
		@return The color as a Color]]></haxe_doc>
	</from8Bit>
	<fromRGBAFloat public="1" get="inline" set="null" line="222" static="1">
		<f a="Red:Green:Blue:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Generate a color from float RGB values (0 to 1)

		@param Red	The red value of the color from 0 to 1
		@param Green	The green value of the color from 0 to 1
		@param Blue	The green value of the color from 0 to 1
		@param Alpha	How opaque the color should be, from 0 to 1
		@return The color as a Color</haxe_doc>
	</fromRGBAFloat>
	<fromCMYK public="1" get="inline" set="null" line="237" static="1">
		<f a="Cyan:Magenta:Yellow:Black:?Alpha" v="::::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Generate a color from CMYK values (0 to 1)

		@param Cyan		The cyan value of the color from 0 to 1
		@param Magenta	The magenta value of the color from 0 to 1
		@param Yellow	The yellow value of the color from 0 to 1
		@param Black		The black value of the color from 0 to 1
		@param Alpha		How opaque the color should be, from 0 to 1
		@return The color as a Color</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="251" static="1">
		<f a="Hue:Saturation:Brightness:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Generate a color from HSB (aka HSV) components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
		@return	The color as a Color</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="265" static="1">
		<f a="Hue:Saturation:Lightness:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Generate a color from HSL components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Lightness	A number between 0 and 1, indicating the lightness of the color
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
		@return	The color as a Color</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="285" static="1">
		<f a="str">
			<c path="String"/>
			<x path="Null"><x path="vision.ds.Color"/></x>
		</f>
		<haxe_doc><![CDATA[Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.

		Examples (input -> output in hex):

		- `0x00FF00`    -> `0xFF00FF00`
		- `0xAA4578C2`  -> `0xAA4578C2`
		- `#0000FF`     -> `0xFF0000FF`
		- `#3F000011`   -> `0x3F000011`
		- `GRAY`        -> `0xFF808080`
		- `blue`        -> `0xFF0000FF`

		@param	str 	The string to be parsed
		@return	A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="306" static="1">
		<f a="?Alpha" v="255">
			<x path="Int"/>
			<c path="Array"><x path="vision.ds.Color"/></c>
		</f>
		<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
		<haxe_doc>Get HSB color wheel values in an array which will be 360 elements in size

		@param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
		@return	HSB color wheel as Array of Colors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="318" static="1">
		<f a="Color1:Color2:?Factor" v="::0.5">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Factor : 0.5 }</e></m></meta>
		<haxe_doc>Get an interpolated color based on two different colors.

		@param 	Color1 The first color
		@param 	Color2 The second color
		@param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2
		@return	The interpolated color</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="336" static="1">
		<f a="Color1:Color2:Steps:?Ease">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="vision.ds.Color"/></c>
		</f>
		<haxe_doc>Create a gradient from one color to another

		@param Color1 The color to shift from
		@param Color2 The color to shift to
		@param Steps How many colors the gradient should have
		@param Ease An optional easing function, such as those provided in FlxEase
		@return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
	</gradient>
	<multiply public="1" get="inline" set="null" line="356" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>Multiply the RGB and alpha channels of two Colors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="365" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>Add the RGB and alpha channels of two Colors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="373" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>Subtract the RGB and alpha channels of one Color from another</haxe_doc>
	</subtract>
	<divide public="1" get="inline" set="null" line="378" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
	</divide>
	<getComplementHarmony public="1" get="inline" set="null" line="388" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Returns a Complementary Color Harmony of this color.
		A complementary hue is one directly opposite the color given on the color wheel

		@return	The complimentary color</haxe_doc>
	</getComplementHarmony>
	<getAnalogousHarmony public="1" get="inline" set="null" line="399" static="1">
		<f a="this:?Threshold" v=":30">
			<x path="Int"/>
			<x path="Int"/>
			<t path="vision.ds.Harmony"/>
		</f>
		<meta><m n=":value"><e>{ Threshold : 30 }</e></m></meta>
		<haxe_doc>Returns an Analogous Color Harmony for the given color.
		An Analogous harmony are hues adjacent to each other on the color wheel

		@param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
		@return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getAnalogousHarmony>
	<getSplitComplementHarmony public="1" get="inline" set="null" line="413" static="1">
		<f a="this:?Threshold" v=":30">
			<x path="Int"/>
			<x path="Int"/>
			<t path="vision.ds.Harmony"/>
		</f>
		<meta><m n=":value"><e>{ Threshold : 30 }</e></m></meta>
		<haxe_doc>Returns an Split Complement Color Harmony for this color.
		A Split Complement harmony are the two hues on either side of the color's Complement

		@param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
		@return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getSplitComplementHarmony>
	<getTriadicHarmony public="1" get="inline" set="null" line="427" static="1">
		<f a="this">
			<x path="Int"/>
			<t path="vision.ds.TriadicHarmony"/>
		</f>
		<haxe_doc>Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant
		from each other on the color wheel.

		@return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
	</getTriadicHarmony>
	<to24Bit public="1" get="inline" set="null" line="439" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Return a 24 bit version of this color (i.e. without an alpha value)

		@return A 24 bit version of this color</haxe_doc>
	</to24Bit>
	<toHexString public="1" get="inline" set="null" line="450" static="1">
		<f a="this:?Alpha:?Prefix" v=":true:true">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ Prefix : true, Alpha : true }</e></m></meta>
		<haxe_doc>Return a String representation of the color in the format

		@param Alpha Whether to include the alpha value in the hes string
		@param Prefix Whether to include "0x" prefix at start of string
		@return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="460" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>Return a String representation of the color in the format #RRGGBB

		@return	A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<darken public="1" set="method" line="470" static="1">
		<f a="this:?Factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Factor : 0.2 }</e></m></meta>
		<haxe_doc>Get a darkened version of this color

		@param	Factor Value from 0 to 1 of how much to progress toward black.
		@return 	A darkened version of this color</haxe_doc>
	</darken>
	<lighten public="1" get="inline" set="null" line="483" static="1">
		<f a="this:?Factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Factor : 0.2 }</e></m></meta>
		<haxe_doc>Get a lightened version of this color

		@param	Factor Value from 0 to 1 of how much to progress toward white.
		@return 	A lightened version of this color</haxe_doc>
	</lighten>
	<invert public="1" get="inline" set="null" line="495" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Get the inversion of this color

		@return The inversion of this color</haxe_doc>
	</invert>
	<setRGBA public="1" get="inline" set="null" line="511" static="1">
		<f a="this:Red:Green:Blue:?Alpha" v="::::255">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
		<haxe_doc>Set RGB values as integers (0 to 255)

		@param Red	The red value of the color from 0 to 255
		@param Green	The green value of the color from 0 to 255
		@param Blue	The green value of the color from 0 to 255
		@param Alpha	How opaque the color should be, from 0 to 255
		@return This color</haxe_doc>
	</setRGBA>
	<setRGBAFloat public="1" get="inline" set="null" line="528" static="1">
		<f a="this:Red:Green:Blue:?Alpha" v="::::1">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Set RGB values as floats (0 to 1)

		@param Red	The red value of the color from 0 to 1
		@param Green	The green value of the color from 0 to 1
		@param Blue	The green value of the color from 0 to 1
		@param Alpha	How opaque the color should be, from 0 to 1
		@return This color</haxe_doc>
	</setRGBAFloat>
	<setCMYK public="1" get="inline" set="null" line="546" static="1">
		<f a="this:Cyan:Magenta:Yellow:Black:?Alpha" v=":::::1">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Set CMYK values as floats (0 to 1)

		@param Cyan		The cyan value of the color from 0 to 1
		@param Magenta	The magenta value of the color from 0 to 1
		@param Yellow	The yellow value of the color from 0 to 1
		@param Black		The black value of the color from 0 to 1
		@param Alpha		How opaque the color should be, from 0 to 1
		@return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="563" static="1">
		<f a="this:Hue:Saturation:Brightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Set HSB (aka HSV) components

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
		@return	This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="578" static="1">
		<f a="this:Hue:Saturation:Lightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Set HSL components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Lightness	A number between 0 and 1, indicating the lightness of the color
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
		@return	This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="587" static="1">
		<f a="this:Hue:Saturation:Chroma:Match:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<grayscale public="1" get="inline" set="null" line="611" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></grayscale>
	<_new public="1" get="inline" set="null" line="616" static="1">
		<f a="?value" v="0">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta>
			<m n=":value"><e>{ value : 0 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<getThis get="inline" set="null" line="620" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></getThis>
	<validate get="inline" set="null" line="628" static="1"><f a="this">
	<x path="Int"/>
	<x path="Void"/>
</f></validate>
	<get_red get="inline" set="null" line="634" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
	<get_green get="inline" set="null" line="638" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
	<get_blue get="inline" set="null" line="642" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
	<get_alpha get="inline" set="null" line="646" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_alpha>
	<get_redFloat get="inline" set="null" line="650" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
	<get_greenFloat get="inline" set="null" line="654" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
	<get_blueFloat get="inline" set="null" line="658" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
	<get_alphaFloat get="inline" set="null" line="662" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_alphaFloat>
	<set_red get="inline" set="null" line="666" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
	<set_green get="inline" set="null" line="673" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
	<set_blue get="inline" set="null" line="680" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
	<set_alpha get="inline" set="null" line="687" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_alpha>
	<set_redFloat get="inline" set="null" line="694" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
	<set_greenFloat get="inline" set="null" line="699" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
	<set_blueFloat get="inline" set="null" line="704" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
	<set_alphaFloat get="inline" set="null" line="709" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alphaFloat>
	<get_cyan get="inline" set="null" line="714" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
	<get_magenta get="inline" set="null" line="718" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
	<get_yellow get="inline" set="null" line="722" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
	<get_black get="inline" set="null" line="726" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
	<set_cyan get="inline" set="null" line="730" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
	<set_magenta get="inline" set="null" line="735" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
	<set_yellow get="inline" set="null" line="740" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
	<set_black get="inline" set="null" line="745" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
	<get_hue set="method" line="750" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
	<get_brightness get="inline" set="null" line="760" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
	<get_saturation get="inline" set="null" line="764" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
	<get_lightness get="inline" set="null" line="768" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
	<set_hue get="inline" set="null" line="772" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
	<set_saturation get="inline" set="null" line="777" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
	<set_brightness get="inline" set="null" line="782" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
	<set_lightness get="inline" set="null" line="787" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
	<set_rgb get="inline" set="null" line="792" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></set_rgb>
	<get_rgb get="inline" set="null" line="798" static="1"><f a="this">
	<x path="Int"/>
	<x path="vision.ds.Color"/>
</f></get_rgb>
	<maxColor get="inline" set="null" line="802" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
	<minColor get="inline" set="null" line="806" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
	<boundChannel get="inline" set="null" line="810" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
	<toString public="1" set="method" line="814" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<toInt public="1" set="method" line="822" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
	<color_greater_than_color get="inline" set="null" line="831" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</color_greater_than_color>
	<color_greater_than_int get="inline" set="null" line="836" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</color_greater_than_int>
	<int_greater_than_color get="inline" set="null" line="841" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</int_greater_than_color>
	<color_greater_than_float get="inline" set="null" line="846" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</color_greater_than_float>
	<float_greater_than_color get="inline" set="null" line="851" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</float_greater_than_color>
	<color_greater_than_equal_color get="inline" set="null" line="856" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</color_greater_than_equal_color>
	<color_greater_than_equal_int get="inline" set="null" line="861" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</color_greater_than_equal_int>
	<int_greater_than_equal_color get="inline" set="null" line="866" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</int_greater_than_equal_color>
	<color_greater_than_equal_float get="inline" set="null" line="871" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</color_greater_than_equal_float>
	<float_greater_than_equal_color get="inline" set="null" line="876" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</float_greater_than_equal_color>
	<color_less_than_color get="inline" set="null" line="881" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</color_less_than_color>
	<color_less_than_int get="inline" set="null" line="886" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</color_less_than_int>
	<int_less_than_color get="inline" set="null" line="891" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</int_less_than_color>
	<color_less_than_float get="inline" set="null" line="896" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</color_less_than_float>
	<float_less_than_color get="inline" set="null" line="901" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</float_less_than_color>
	<color_less_than_equal_color get="inline" set="null" line="906" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</color_less_than_equal_color>
	<color_less_than_equal_int get="inline" set="null" line="911" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</color_less_than_equal_int>
	<int_less_than_equal_color get="inline" set="null" line="916" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</int_less_than_equal_color>
	<color_less_than_equal_float get="inline" set="null" line="921" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</color_less_than_equal_float>
	<float_less_than_equal_color get="inline" set="null" line="926" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</float_less_than_equal_color>
	<color_equal_color get="inline" set="null" line="931" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</color_equal_color>
	<color_equal_int get="inline" set="null" line="936" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</color_equal_int>
	<int_equal_color get="inline" set="null" line="941" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</int_equal_color>
	<color_equal_float get="inline" set="null" line="946" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</color_equal_float>
	<float_equal_color get="inline" set="null" line="951" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</float_equal_color>
	<color_not_equal_color get="inline" set="null" line="956" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</color_not_equal_color>
	<color_not_equal_int get="inline" set="null" line="961" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</color_not_equal_int>
	<int_not_equal_color get="inline" set="null" line="966" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</int_not_equal_color>
	<color_not_equal_float get="inline" set="null" line="971" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</color_not_equal_float>
	<float_not_equal_color get="inline" set="null" line="976" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</float_not_equal_color>
	<color_bitwise_and_color get="inline" set="null" line="981" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
	</color_bitwise_and_color>
	<color_bitwise_and_int get="inline" set="null" line="986" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
	</color_bitwise_and_int>
	<int_bitwise_and_color get="inline" set="null" line="991" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
	</int_bitwise_and_color>
	<color_bitwise_or_color get="inline" set="null" line="996" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
	</color_bitwise_or_color>
	<color_bitwise_or_int get="inline" set="null" line="1001" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
	</color_bitwise_or_int>
	<int_bitwise_or_color get="inline" set="null" line="1006" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
	</int_bitwise_or_color>
	<color_bitwise_xor_color get="inline" set="null" line="1011" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
	</color_bitwise_xor_color>
	<color_bitwise_xor_int get="inline" set="null" line="1016" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
	</color_bitwise_xor_int>
	<int_bitwise_xor_color get="inline" set="null" line="1021" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
	</int_bitwise_xor_color>
	<color_bitwise_left_shift_color get="inline" set="null" line="1026" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
	</color_bitwise_left_shift_color>
	<color_bitwise_left_shift_int get="inline" set="null" line="1031" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
	</color_bitwise_left_shift_int>
	<int_bitwise_left_shift_color get="inline" set="null" line="1036" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
	</int_bitwise_left_shift_color>
	<color_bitwise_right_shift_color get="inline" set="null" line="1041" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
	</color_bitwise_right_shift_color>
	<color_bitwise_right_shift_int get="inline" set="null" line="1046" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
	</color_bitwise_right_shift_int>
	<int_bitwise_right_shift_color get="inline" set="null" line="1051" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
	</int_bitwise_right_shift_color>
	<color_bitwise_unsigned_right_shift_color get="inline" set="null" line="1056" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
	</color_bitwise_unsigned_right_shift_color>
	<color_bitwise_unsigned_right_shift_int get="inline" set="null" line="1061" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
	</color_bitwise_unsigned_right_shift_int>
	<int_bitwise_unsigned_right_shift_color get="inline" set="null" line="1066" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
	</int_bitwise_unsigned_right_shift_color>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._Color.Color_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Color.hx" private="1" module="vision.ds.Color" final="1">
		<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="19" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
			<haxe_doc><![CDATA[&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;]]></haxe_doc>
		</TRANSPARENT>
		<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="24" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/ffffff.png)![color](https://www.colorhexa.com/ffffff.png)</haxe_doc>
		</WHITE>
		<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="29" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF808080</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/808080.png)![color](https://www.colorhexa.com/808080.png)</haxe_doc>
		</GRAY>
		<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="34" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF000000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/000000.png)![color](https://www.colorhexa.com/000000.png)</haxe_doc>
		</BLACK>
		<GREEN public="1" get="inline" set="null" expr="0xFF00FF00" line="39" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/00ff00.png)![color](https://www.colorhexa.com/00ff00.png)</haxe_doc>
		</GREEN>
		<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="44" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFFF00.png)![color](https://www.colorhexa.com/FFFF00.png)</haxe_doc>
		</YELLOW>
		<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="49" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFA500.png)![color](https://www.colorhexa.com/FFA500.png)</haxe_doc>
		</ORANGE>
		<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="54" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF0000.png)![color](https://www.colorhexa.com/FF0000.png)</haxe_doc>
		</RED>
		<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="59" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF800080</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/800080.png)![color](https://www.colorhexa.com/800080.png)</haxe_doc>
		</PURPLE>
		<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="64" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/0000ff.png)![color](https://www.colorhexa.com/0000ff.png)</haxe_doc>
		</BLUE>
		<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="69" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/8B4513.png)![color](https://www.colorhexa.com/8B4513.png)</haxe_doc>
		</BROWN>
		<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="74" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFC0CB.png)![color](https://www.colorhexa.com/FFC0CB.png)</haxe_doc>
		</PINK>
		<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="79" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF00FF.png)![color](https://www.colorhexa.com/FF00FF.png)</haxe_doc>
		</MAGENTA>
		<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="84" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/00FFFF.png)![color](https://www.colorhexa.com/00FFFF.png)</haxe_doc>
		</CYAN>
		<SILVER public="1" get="inline" set="null" expr="0xC0C0C0" line="89" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xC0C0C0</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/C0C0C0.png)![color](https://www.colorhexa.com/C0C0C0.png)</haxe_doc>
		</SILVER>
		<GOLD public="1" get="inline" set="null" expr="0xFFFFD700" line="94" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFD700.png)![color](https://www.colorhexa.com/FFD700.png)</haxe_doc>
		</GOLD>
		<OLIVE public="1" get="inline" set="null" expr="0xFF808000" line="99" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF808000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/808000.png)![color](https://www.colorhexa.com/808000.png)</haxe_doc>
		</OLIVE>
		<MAROON public="1" get="inline" set="null" expr="0xFF800000" line="104" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF800000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/800000.png)![color](https://www.colorhexa.com/800000.png)</haxe_doc>
		</MAROON>
		<NAVY public="1" get="inline" set="null" expr="0xFF000080" line="109" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF000080</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/000080.png)![color](https://www.colorhexa.com/000080.png)</haxe_doc>
		</NAVY>
		<TEAL public="1" get="inline" set="null" expr="0xFF008080" line="114" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF008080</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/008080.png)![color](https://www.colorhexa.com/008080.png)</haxe_doc>
		</TEAL>
		<FUCHSIA public="1" get="inline" set="null" expr="0xFFFF00FF" line="119" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF00FF.png)![color](https://www.colorhexa.com/FF00FF.png)</haxe_doc>
		</FUCHSIA>
		<AQUA public="1" get="inline" set="null" expr="0xFF00FFFF" line="124" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/00FFFF.png)![color](https://www.colorhexa.com/00FFFF.png)</haxe_doc>
		</AQUA>
		<LIME public="1" get="inline" set="null" expr="0xFF32CD32" line="129" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF32CD32</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/32CD32.png)![color](https://www.colorhexa.com/32CD32.png)</haxe_doc>
		</LIME>
		<ROYAL_BLUE public="1" get="inline" set="null" expr="0xFF4169E1" line="134" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF4169E1</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/4169E1.png)![color](https://www.colorhexa.com/4169E1.png)</haxe_doc>
		</ROYAL_BLUE>
		<red public="1" get="accessor" set="accessor" static="1"><x path="Int"/></red>
		<blue public="1" get="accessor" set="accessor" static="1"><x path="Int"/></blue>
		<green public="1" get="accessor" set="accessor" static="1"><x path="Int"/></green>
		<alpha public="1" get="accessor" set="accessor" static="1"><x path="Int"/></alpha>
		<redFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></redFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></blueFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></greenFloat>
		<alphaFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></alphaFloat>
		<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
		<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
		<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
		<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
		<rgb public="1" get="accessor" set="accessor" static="1">
			<x path="vision.ds.Color"/>
			<haxe_doc>The red, green and blue channels of this color as a 24 bit integer (from 0 to 0xFFFFFF, does not include alpha values)</haxe_doc>
		</rgb>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<COLOR_REGEX expr="~/^(0x|#)(([A-F0-9]{2}){3,4})$/" line="176" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(0x|#)(([A-F0-9]{2}){3,4})$/</e></m></meta>
		</COLOR_REGEX>
		<fromInt public="1" get="inline" set="null" line="184" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Create a color from the least significant four bytes of an Int

		@param value Int with bytes in the format 0xAARRGGBB
		@return	The color as a Color</haxe_doc>
		</fromInt>
		<fromRGBA public="1" get="inline" set="null" line="197" static="1">
			<f a="Red:Green:Blue:?Alpha" v=":::255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
			<haxe_doc>Generate a color from integer RGB values (0 to 255)

		@param Red	The red value of the color from 0 to 255
		@param Green	The green value of the color from 0 to 255
		@param Blue	The green value of the color from 0 to 255
		@param Alpha	How opaque the color should be, from 0 to 255
		@return The color as a Color</haxe_doc>
		</fromRGBA>
		<from8Bit public="1" get="inline" set="null" line="208" static="1">
			<f a="Value">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc><![CDATA[Generate a grayscale color from a single color channel value (0 to 255)

		@param Value	The channel value of the red, green & blue channels of the color
		@return The color as a Color]]></haxe_doc>
		</from8Bit>
		<fromRGBAFloat public="1" get="inline" set="null" line="222" static="1">
			<f a="Red:Green:Blue:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Generate a color from float RGB values (0 to 1)

		@param Red	The red value of the color from 0 to 1
		@param Green	The green value of the color from 0 to 1
		@param Blue	The green value of the color from 0 to 1
		@param Alpha	How opaque the color should be, from 0 to 1
		@return The color as a Color</haxe_doc>
		</fromRGBAFloat>
		<fromCMYK public="1" get="inline" set="null" line="237" static="1">
			<f a="Cyan:Magenta:Yellow:Black:?Alpha" v="::::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Generate a color from CMYK values (0 to 1)

		@param Cyan		The cyan value of the color from 0 to 1
		@param Magenta	The magenta value of the color from 0 to 1
		@param Yellow	The yellow value of the color from 0 to 1
		@param Black		The black value of the color from 0 to 1
		@param Alpha		How opaque the color should be, from 0 to 1
		@return The color as a Color</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="251" static="1">
			<f a="Hue:Saturation:Brightness:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Generate a color from HSB (aka HSV) components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
		@return	The color as a Color</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="265" static="1">
			<f a="Hue:Saturation:Lightness:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Generate a color from HSL components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Lightness	A number between 0 and 1, indicating the lightness of the color
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
		@return	The color as a Color</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="285" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Null"><x path="vision.ds.Color"/></x>
			</f>
			<haxe_doc><![CDATA[Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.

		Examples (input -> output in hex):

		- `0x00FF00`    -> `0xFF00FF00`
		- `0xAA4578C2`  -> `0xAA4578C2`
		- `#0000FF`     -> `0xFF0000FF`
		- `#3F000011`   -> `0x3F000011`
		- `GRAY`        -> `0xFF808080`
		- `blue`        -> `0xFF0000FF`

		@param	str 	The string to be parsed
		@return	A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="306" static="1">
			<f a="?Alpha" v="255">
				<x path="Int"/>
				<c path="Array"><x path="vision.ds.Color"/></c>
			</f>
			<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
			<haxe_doc>Get HSB color wheel values in an array which will be 360 elements in size

		@param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
		@return	HSB color wheel as Array of Colors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="318" static="1">
			<f a="Color1:Color2:?Factor" v="::0.5">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Factor : 0.5 }</e></m></meta>
			<haxe_doc>Get an interpolated color based on two different colors.

		@param 	Color1 The first color
		@param 	Color2 The second color
		@param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2
		@return	The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="336" static="1">
			<f a="Color1:Color2:Steps:?Ease">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="vision.ds.Color"/></c>
			</f>
			<haxe_doc>Create a gradient from one color to another

		@param Color1 The color to shift from
		@param Color2 The color to shift to
		@param Steps How many colors the gradient should have
		@param Ease An optional easing function, such as those provided in FlxEase
		@return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
		</gradient>
		<multiply public="1" get="inline" set="null" line="356" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>Multiply the RGB and alpha channels of two Colors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="365" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>Add the RGB and alpha channels of two Colors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="373" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>Subtract the RGB and alpha channels of one Color from another</haxe_doc>
		</subtract>
		<divide public="1" get="inline" set="null" line="378" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
		</divide>
		<getComplementHarmony public="1" get="inline" set="null" line="388" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Returns a Complementary Color Harmony of this color.
		A complementary hue is one directly opposite the color given on the color wheel

		@return	The complimentary color</haxe_doc>
		</getComplementHarmony>
		<getAnalogousHarmony public="1" get="inline" set="null" line="399" static="1">
			<f a="this:?Threshold" v=":30">
				<x path="Int"/>
				<x path="Int"/>
				<t path="vision.ds.Harmony"/>
			</f>
			<meta><m n=":value"><e>{ Threshold : 30 }</e></m></meta>
			<haxe_doc>Returns an Analogous Color Harmony for the given color.
		An Analogous harmony are hues adjacent to each other on the color wheel

		@param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
		@return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getAnalogousHarmony>
		<getSplitComplementHarmony public="1" get="inline" set="null" line="413" static="1">
			<f a="this:?Threshold" v=":30">
				<x path="Int"/>
				<x path="Int"/>
				<t path="vision.ds.Harmony"/>
			</f>
			<meta><m n=":value"><e>{ Threshold : 30 }</e></m></meta>
			<haxe_doc>Returns an Split Complement Color Harmony for this color.
		A Split Complement harmony are the two hues on either side of the color's Complement

		@param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
		@return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getSplitComplementHarmony>
		<getTriadicHarmony public="1" get="inline" set="null" line="427" static="1">
			<f a="this">
				<x path="Int"/>
				<t path="vision.ds.TriadicHarmony"/>
			</f>
			<haxe_doc>Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant
		from each other on the color wheel.

		@return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
		</getTriadicHarmony>
		<to24Bit public="1" get="inline" set="null" line="439" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Return a 24 bit version of this color (i.e. without an alpha value)

		@return A 24 bit version of this color</haxe_doc>
		</to24Bit>
		<toHexString public="1" get="inline" set="null" line="450" static="1">
			<f a="this:?Alpha:?Prefix" v=":true:true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ Prefix : true, Alpha : true }</e></m></meta>
			<haxe_doc>Return a String representation of the color in the format

		@param Alpha Whether to include the alpha value in the hes string
		@param Prefix Whether to include "0x" prefix at start of string
		@return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="460" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Return a String representation of the color in the format #RRGGBB

		@return	A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<darken public="1" set="method" line="470" static="1">
			<f a="this:?Factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Factor : 0.2 }</e></m></meta>
			<haxe_doc>Get a darkened version of this color

		@param	Factor Value from 0 to 1 of how much to progress toward black.
		@return 	A darkened version of this color</haxe_doc>
		</darken>
		<lighten public="1" get="inline" set="null" line="483" static="1">
			<f a="this:?Factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Factor : 0.2 }</e></m></meta>
			<haxe_doc>Get a lightened version of this color

		@param	Factor Value from 0 to 1 of how much to progress toward white.
		@return 	A lightened version of this color</haxe_doc>
		</lighten>
		<invert public="1" get="inline" set="null" line="495" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Get the inversion of this color

		@return The inversion of this color</haxe_doc>
		</invert>
		<setRGBA public="1" get="inline" set="null" line="511" static="1">
			<f a="this:Red:Green:Blue:?Alpha" v="::::255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
			<haxe_doc>Set RGB values as integers (0 to 255)

		@param Red	The red value of the color from 0 to 255
		@param Green	The green value of the color from 0 to 255
		@param Blue	The green value of the color from 0 to 255
		@param Alpha	How opaque the color should be, from 0 to 255
		@return This color</haxe_doc>
		</setRGBA>
		<setRGBAFloat public="1" get="inline" set="null" line="528" static="1">
			<f a="this:Red:Green:Blue:?Alpha" v="::::1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Set RGB values as floats (0 to 1)

		@param Red	The red value of the color from 0 to 1
		@param Green	The green value of the color from 0 to 1
		@param Blue	The green value of the color from 0 to 1
		@param Alpha	How opaque the color should be, from 0 to 1
		@return This color</haxe_doc>
		</setRGBAFloat>
		<setCMYK public="1" get="inline" set="null" line="546" static="1">
			<f a="this:Cyan:Magenta:Yellow:Black:?Alpha" v=":::::1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Set CMYK values as floats (0 to 1)

		@param Cyan		The cyan value of the color from 0 to 1
		@param Magenta	The magenta value of the color from 0 to 1
		@param Yellow	The yellow value of the color from 0 to 1
		@param Black		The black value of the color from 0 to 1
		@param Alpha		How opaque the color should be, from 0 to 1
		@return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="563" static="1">
			<f a="this:Hue:Saturation:Brightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Set HSB (aka HSV) components

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
		@return	This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="578" static="1">
			<f a="this:Hue:Saturation:Lightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Set HSL components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Lightness	A number between 0 and 1, indicating the lightness of the color
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
		@return	This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="587" static="1">
			<f a="this:Hue:Saturation:Chroma:Match:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<grayscale public="1" get="inline" set="null" line="611" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></grayscale>
		<_new public="1" get="inline" set="null" line="616" static="1">
			<f a="?value" v="0">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta>
				<m n=":value"><e>{ value : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<getThis get="inline" set="null" line="620" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></getThis>
		<validate get="inline" set="null" line="628" static="1"><f a="this">
	<x path="Int"/>
	<x path="Void"/>
</f></validate>
		<get_red get="inline" set="null" line="634" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
		<get_green get="inline" set="null" line="638" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
		<get_blue get="inline" set="null" line="642" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
		<get_alpha get="inline" set="null" line="646" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_alpha>
		<get_redFloat get="inline" set="null" line="650" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
		<get_greenFloat get="inline" set="null" line="654" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
		<get_blueFloat get="inline" set="null" line="658" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
		<get_alphaFloat get="inline" set="null" line="662" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_alphaFloat>
		<set_red get="inline" set="null" line="666" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
		<set_green get="inline" set="null" line="673" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
		<set_blue get="inline" set="null" line="680" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
		<set_alpha get="inline" set="null" line="687" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_alpha>
		<set_redFloat get="inline" set="null" line="694" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
		<set_greenFloat get="inline" set="null" line="699" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
		<set_blueFloat get="inline" set="null" line="704" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
		<set_alphaFloat get="inline" set="null" line="709" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alphaFloat>
		<get_cyan get="inline" set="null" line="714" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
		<get_magenta get="inline" set="null" line="718" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
		<get_yellow get="inline" set="null" line="722" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
		<get_black get="inline" set="null" line="726" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
		<set_cyan get="inline" set="null" line="730" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
		<set_magenta get="inline" set="null" line="735" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
		<set_yellow get="inline" set="null" line="740" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
		<set_black get="inline" set="null" line="745" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
		<get_hue set="method" line="750" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
		<get_brightness get="inline" set="null" line="760" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
		<get_saturation get="inline" set="null" line="764" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
		<get_lightness get="inline" set="null" line="768" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
		<set_hue get="inline" set="null" line="772" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
		<set_saturation get="inline" set="null" line="777" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
		<set_brightness get="inline" set="null" line="782" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
		<set_lightness get="inline" set="null" line="787" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
		<set_rgb get="inline" set="null" line="792" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></set_rgb>
		<get_rgb get="inline" set="null" line="798" static="1"><f a="this">
	<x path="Int"/>
	<x path="vision.ds.Color"/>
</f></get_rgb>
		<maxColor get="inline" set="null" line="802" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
		<minColor get="inline" set="null" line="806" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
		<boundChannel get="inline" set="null" line="810" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
		<toString public="1" set="method" line="814" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<toInt public="1" set="method" line="822" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
		<color_greater_than_color get="inline" set="null" line="831" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</color_greater_than_color>
		<color_greater_than_int get="inline" set="null" line="836" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</color_greater_than_int>
		<int_greater_than_color get="inline" set="null" line="841" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</int_greater_than_color>
		<color_greater_than_float get="inline" set="null" line="846" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</color_greater_than_float>
		<float_greater_than_color get="inline" set="null" line="851" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</float_greater_than_color>
		<color_greater_than_equal_color get="inline" set="null" line="856" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</color_greater_than_equal_color>
		<color_greater_than_equal_int get="inline" set="null" line="861" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</color_greater_than_equal_int>
		<int_greater_than_equal_color get="inline" set="null" line="866" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</int_greater_than_equal_color>
		<color_greater_than_equal_float get="inline" set="null" line="871" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</color_greater_than_equal_float>
		<float_greater_than_equal_color get="inline" set="null" line="876" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</float_greater_than_equal_color>
		<color_less_than_color get="inline" set="null" line="881" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</color_less_than_color>
		<color_less_than_int get="inline" set="null" line="886" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</color_less_than_int>
		<int_less_than_color get="inline" set="null" line="891" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</int_less_than_color>
		<color_less_than_float get="inline" set="null" line="896" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</color_less_than_float>
		<float_less_than_color get="inline" set="null" line="901" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</float_less_than_color>
		<color_less_than_equal_color get="inline" set="null" line="906" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</color_less_than_equal_color>
		<color_less_than_equal_int get="inline" set="null" line="911" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</color_less_than_equal_int>
		<int_less_than_equal_color get="inline" set="null" line="916" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</int_less_than_equal_color>
		<color_less_than_equal_float get="inline" set="null" line="921" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</color_less_than_equal_float>
		<float_less_than_equal_color get="inline" set="null" line="926" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</float_less_than_equal_color>
		<color_equal_color get="inline" set="null" line="931" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</color_equal_color>
		<color_equal_int get="inline" set="null" line="936" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</color_equal_int>
		<int_equal_color get="inline" set="null" line="941" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</int_equal_color>
		<color_equal_float get="inline" set="null" line="946" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</color_equal_float>
		<float_equal_color get="inline" set="null" line="951" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</float_equal_color>
		<color_not_equal_color get="inline" set="null" line="956" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</color_not_equal_color>
		<color_not_equal_int get="inline" set="null" line="961" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</color_not_equal_int>
		<int_not_equal_color get="inline" set="null" line="966" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</int_not_equal_color>
		<color_not_equal_float get="inline" set="null" line="971" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</color_not_equal_float>
		<float_not_equal_color get="inline" set="null" line="976" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</float_not_equal_color>
		<color_bitwise_and_color get="inline" set="null" line="981" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		</color_bitwise_and_color>
		<color_bitwise_and_int get="inline" set="null" line="986" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		</color_bitwise_and_int>
		<int_bitwise_and_color get="inline" set="null" line="991" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		</int_bitwise_and_color>
		<color_bitwise_or_color get="inline" set="null" line="996" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
		</color_bitwise_or_color>
		<color_bitwise_or_int get="inline" set="null" line="1001" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
		</color_bitwise_or_int>
		<int_bitwise_or_color get="inline" set="null" line="1006" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
		</int_bitwise_or_color>
		<color_bitwise_xor_color get="inline" set="null" line="1011" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
		</color_bitwise_xor_color>
		<color_bitwise_xor_int get="inline" set="null" line="1016" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
		</color_bitwise_xor_int>
		<int_bitwise_xor_color get="inline" set="null" line="1021" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
		</int_bitwise_xor_color>
		<color_bitwise_left_shift_color get="inline" set="null" line="1026" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		</color_bitwise_left_shift_color>
		<color_bitwise_left_shift_int get="inline" set="null" line="1031" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		</color_bitwise_left_shift_int>
		<int_bitwise_left_shift_color get="inline" set="null" line="1036" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		</int_bitwise_left_shift_color>
		<color_bitwise_right_shift_color get="inline" set="null" line="1041" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		</color_bitwise_right_shift_color>
		<color_bitwise_right_shift_int get="inline" set="null" line="1046" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		</color_bitwise_right_shift_int>
		<int_bitwise_right_shift_color get="inline" set="null" line="1051" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		</int_bitwise_right_shift_color>
		<color_bitwise_unsigned_right_shift_color get="inline" set="null" line="1056" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
		</color_bitwise_unsigned_right_shift_color>
		<color_bitwise_unsigned_right_shift_int get="inline" set="null" line="1061" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
		</color_bitwise_unsigned_right_shift_int>
		<int_bitwise_unsigned_right_shift_color get="inline" set="null" line="1066" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
		</int_bitwise_unsigned_right_shift_color>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="vision.ds.Harmony" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Color.hx" module="vision.ds.Color"><a>
	<warmer><x path="vision.ds.Color"/></warmer>
	<original><x path="vision.ds.Color"/></original>
	<colder><x path="vision.ds.Color"/></colder>
</a></typedef>
	<typedef path="vision.ds.TriadicHarmony" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Color.hx" module="vision.ds.Color"><a>
	<color3><x path="vision.ds.Color"/></color3>
	<color2><x path="vision.ds.Color"/></color2>
	<color1><x path="vision.ds.Color"/></color1>
</a></typedef>
	<abstract path="vision.ds.Image" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Image.hx">
		<from><icast field="from2DArray"><c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c></icast></from>
		<this><x path="vision.ds.ByteArray"/></this>
		<haxe_doc>Represents a 2D image, as a matrix of Colors.</haxe_doc>
		<impl><class path="vision.ds._Image.Image_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Image.hx" private="1" module="vision.ds.Image" final="1">
	<OFFSET expr="4" line="24" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
		<haxe_doc>* the first 4 bytes represent width.</haxe_doc>
	</OFFSET>
	<underlying public="1" get="accessor" set="null" static="1">
		<x path="vision.ds.ByteArray"/>
		<haxe_doc>Returns the underlying type of this abstract.</haxe_doc>
	</underlying>
	<get_underlying get="inline" set="null" line="31" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.ByteArray"/>
</f></get_underlying>
	<width public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The width of the image.</haxe_doc>
	</width>
	<get_width get="inline" set="null" line="46" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
</f></get_width>
	<height public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The height of the image.</haxe_doc>
	</height>
	<get_height get="inline" set="null" line="62" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
</f></get_height>
	<_new public="1" get="inline" set="null" line="77" static="1">
		<f a="width:height:?color" v="::0x00000000">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Image"/>
		</f>
		<meta>
			<m n=":value"><e>{ color : 0x00000000 }</e></m>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new image of the given size. Onces created, the image cannot be resized.

		@param width The width of the image.
		@param height The height of the image.
		@param color The color to fill the image with. if unspecified, the image is transparent.</haxe_doc>
	</_new>
	<getColorFromStartingBytePos get="inline" set="null" line="90" static="1"><f a="this:position">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
</f></getColorFromStartingBytePos>
	<setColorFromStartingBytePos get="inline" set="null" line="95" static="1"><f a="this:position:c">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></setColorFromStartingBytePos>
	<getPixel public="1" get="inline" set="null" line="114" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Gets the color of the pixel at the given coordinates.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the coordinates are out of bounds.
		@return The color of the pixel at the given coordinates.</haxe_doc>
	</getPixel>
	<getSafePixel public="1" get="inline" set="null" line="135" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Gets the color of the pixel at the given coordinates.

		Coordinates outside the bounds of the image are allowed.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return The color of the pixel at the given coordinates.</haxe_doc>
	</getSafePixel>
	<getUnsafePixel get="inline" set="null" line="143" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":allow"><e>vision</e></m></meta>
	</getUnsafePixel>
	<getFloatingPixel public="1" get="inline" set="null" line="191" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc><![CDATA[Gets the color of the pixel at the given coordinates.
		These coordinates can also be of type `Float`, in which case
		the value returned should be an interpolation of the surrounding, physical pixels:

		### How Does This Work?

		Lets say we want the pixel at `(0.5, 0.5)`:
		```
		(0,0)   (1,0)                                     
														 
			  ·     < Y (0.5)                      
														 
		(0,1)   (1,1)                                     
			  ^                                           
			X (0.5)                                        
		```

		First, we're going to calculate the actual fraction - the means, extracting the numbers after the decimal point:

			final xFraction = x - Std.int(x);
			final yFraction = y - Std.int(y);


		Then, we just multiply each of the surrounding pixel's value by it's distance from the initial X value (using `xFraction` and `yFraction`):

			final pixelsBeforeYMultiplier = 1 - yFraction, pixelsAfterYMultiplier = yFraction;
			final pixelsBeforeXMultiplier = 1 - xFraction, pixelsAfterXMultiplier = xFraction;
			final bottomLayer = pixelsBeforeYMultiplier * (pixelsBeforeXMultiplier * getPixel(Std.int(x), Std.int(y)) + pixelsAfterXMultiplier * getPixel(Std.int(x) + 1, Std.int(y)));
			final topLayer = pixelsAfterYMultiplier * (pixelsBeforeXMultiplier * getPixel(Std.int(x), Std.int(y) + 1) + pixelsAfterXMultiplier * getPixel(Std.int(x) + 1, Std.int(y) + 1));


		And add the two layers to get the result:


			var finalColor:Color = Std.int(bottomLayer + topLayer);


		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the coordinates are out of bounds.
		@return The color of the pixel at the given coordinates.]]></haxe_doc>
	</getFloatingPixel>
	<setPixel public="1" get="inline" set="null" line="213" static="1">
		<f a="this:x:y:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets the color of the pixel at the given coordinates.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.
		@param color The color to set the pixel to.

		@throws OutOfBounds if the pixel is out of bounds.</haxe_doc>
	</setPixel>
	<hasPixel public="1" get="inline" set="null" line="232" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Checks if the given coordinates are within the bounds of the image.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return True if the coordinates are within the bounds of the image.</haxe_doc>
	</hasPixel>
	<copyPixelFrom public="1" get="inline" set="null" line="246" static="1">
		<f a="this:image:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.Image"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Copies a pixel from the given image to this image.

		@param image The image to copy the pixel from.
		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the given coordinates are outside the bounds of one or both of the images
		@return The color of the pixel at the given coordinates.</haxe_doc>
	</copyPixelFrom>
	<copyPixelTo public="1" get="inline" set="null" line="262" static="1">
		<f a="this:image:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.Image"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Copies a pixel from the given image to this image.

		@param image The image to copy the pixel to.
		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the given coordinates are outside the bounds of one or both of the images
		@return The color of the pixel at the given coordinates.</haxe_doc>
	</copyPixelTo>
	<paintPixel public="1" get="inline" set="null" line="278" static="1">
		<f a="this:x:y:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets the color of a pixel, but doesn't completely overwrite the pixel:

		- if the color of the new pixel is the same as the old pixel, the old pixel is kept.
		- if the alpha of the new pixel is 0, the old pixel is kept.
		- if the alpha of the new pixel is 255, the new pixel is kept.
		- if the alpha of the new pixel is between 0 and 255, the new pixel is blended with the old pixel.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.
		@param color The color to set the pixel to. pay attention to the alpha value.</haxe_doc>
	</paintPixel>
	<fillRect public="1" get="inline" set="null" line="298" static="1">
		<f a="this:x:y:width:height:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets a rectangle of pixels to the given color, essentially filling it with the given color.

		@param rect The rectangle to fill: The fill starts at (x, y) and extends to (x + width, y + height), not including the endpoints.
		@param color The color to fill that rectangular portion with.</haxe_doc>
	</fillRect>
	<drawRect public="1" get="inline" set="null" line="314" static="1">
		<f a="this:x:y:width:height:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws a rectangular outline of the given color.

		This function is a shortcut for just doing repeated calls to drawLine.

		@param rect The rectangle to draw the outline of.
		@param color The color to draw the outline with.</haxe_doc>
	</drawRect>
	<getImagePortion public="1" get="inline" set="null" line="329" static="1">
		<f a="this:rect">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Rectangle"/>
			<x path="vision.ds.Image"/>
		</f>
		<haxe_doc>Returns a portion of the image, specified by a rectangle.

		@param rect The rectangle specifying the portion of the image to return.

		@throws OutOfBounds if the portion of the image to get is outside the bounds of the original image.
		@return A new image containing the specified portion of the original image.</haxe_doc>
	</getImagePortion>
	<setImagePortion public="1" get="inline" set="null" line="347" static="1">
		<f a="this:rect:image">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Rectangle"/>
			<x path="vision.ds.Image"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets a portion of the image, specified by a rectangle, to another image.

		@param rect The rectangle specifying the portion of the image to set.
		@param image The image to set the portion of the image to.

		@throws OutOfBounds if the portion of the image to set is outside the bounds of the original image.</haxe_doc>
	</setImagePortion>
	<drawLine public="1" get="inline" set="null" line="362" static="1">
		<f a="this:x1:y1:x2:y2:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws a line from (x1, y1) to (x2, y2) using the given color.</haxe_doc>
	</drawLine>
	<drawRay2D public="1" get="inline" set="null" line="397" static="1">
		<f a="this:line:color">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Ray2D"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws an intine line specified by a Ray2D object.

		**Notice** - The (0, 0) point is **not** the same is `image.getPixel(0, 0)`,
		but rather the bottom left corner of the image - `image.getPixel(0, image.height - 1)`.

		This "vertical flip" is done to match the way the ray is draw on the cartesian plane.

		@param line The line to draw.
		@param color The color to draw the line with.

		@see Ray2D</haxe_doc>
	</drawRay2D>
	<drawLine2D public="1" get="inline" set="null" line="436" static="1">
		<f a="this:line:color">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Line2D"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws a `Line2D` object using the given color.

		If the line segment is not completely within the image, 
		it doesn't throw an error, but just draws the part of the 
		line segment that is within the image.

		@param line The line segment to draw.
		@param color The color to draw the line segment with.

		@see Line2D</haxe_doc>
	</drawLine2D>
	<drawQuadraticBezier public="1" get="inline" set="null" line="475" static="1">
		<f a="this:line:control:color:?accuracy" v="::::1000">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Line2D"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ accuracy : 1000 }</e></m></meta>
		<haxe_doc>Draws a curved line specified by a line and one control point.

		This method draws a quadratic Bezier curve.

		@param line The line to draw.
		@param control The control point of the curve.
		@param color The color to draw the line with.
		@param accuracy The number of iterations to use when drawing the curve. the higher the number, the more iterations are used, and the more accurate the curve is. for example, accuracy of 100 will draw the curve with 100 iterations, and will draw 100 points on the curve. **default is 1000**

		@see Line2D</haxe_doc>
	</drawQuadraticBezier>
	<drawCubicBezier public="1" get="inline" set="null" line="514" static="1">
		<f a="this:line:control1:control2:color:?accuracy" v=":::::1000">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Line2D"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ accuracy : 1000 }</e></m></meta>
		<haxe_doc>Draws a curved line specified by a line and two control points.

		This method draws a cubic Bezier curve.

		@param line The line to draw.
		@param control1 The first control point of the curve.
		@param control2 The second control point of the curve.
		@param color The color to draw the curve with.
		@param accuracy The number of iterations to use when drawing the curve. the higher the number, the more iterations are used, and the more accurate the curve is. for example, accuracy of 100 will draw the curve with 100 iterations, and will draw 100 points on the curve. **default is 1000**

		@see Line2D</haxe_doc>
	</drawCubicBezier>
	<fillCircle public="1" get="inline" set="null" line="554" static="1">
		<f a="this:X:Y:r:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Fills a circle with the given color:

		 - The center of the circle is at (X, Y)
		 - The radius of the circle is r
		 - Anti-aliasing will not be used.

		@param x The x coordinate of the center of the circle.
		@param y The y coordinate of the center of the circle.
		@param r The radius of the circle.
		@param color The color to draw the circle with.</haxe_doc>
	</fillCircle>
	<drawCircle public="1" get="inline" set="null" line="597" static="1">
		<f a="this:X:Y:r:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws a circle of the given color:

		 - The center of the circle is at (X, Y)
		 - The radius of the circle is r
		 - Anti-aliasing will not be used.

		@param x The x coordinate of the center of the circle.
		@param y The y coordinate of the center of the circle.
		@param r The radius of the circle.
		@param color The color to draw the circle with.</haxe_doc>
	</drawCircle>
	<drawEllipse public="1" get="inline" set="null" line="627" static="1">
		<f a="this:centerX:centerY:radiusX:radiusY:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws an ellipse of the given color:

		 - The center of the ellipse is at (X, Y)
		 - The radius of the ellipse is r
		 - Anti-aliasing will not be used.

		@param centerX The x coordinate of the center of the ellipse.
		@param centerY The y coordinate of the center of the ellipse.
		@param radiusX The x radius of the ellipse.
		@param radiusY The y radius of the ellipse.
		@param color The color to draw the ellipse with.</haxe_doc>
	</drawEllipse>
	<fillColorRecursive public="1" set="method" line="710" static="1">
		<f a="this:position:color">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Recursively fills a section of the image. the section filled has to match
		`position`'s color.

		when the fill encounters a color that is not `position`'s color, it
		will stop filling in that direction.

		**Warning** - this function is recursive. This function is not slow, but can trigger
		a stack overflow if used on large images. This is only here so an implementation will be available.

		@param position The position to start filling at. you can use a Point2D or IntPoint2D.
		@param color The color to fill with.</haxe_doc>
	</fillColorRecursive>
	<fillColor public="1" set="method" line="739" static="1">
		<f a="this:position:color">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Fills a section of the image. the section filled has to match
		`position`'s color.

		This uses the BFS `Breadth First Search` algorithm

		@param position The position to start filling at. you can use a Point2D or IntPoint2D.
		@param color The color to fill with.</haxe_doc>
	</fillColor>
	<fillUntilColor public="1" set="method" line="776" static="1">
		<f a="this:position:color:borderColor">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Fills a section of the image. the section filled has to be bordered by pixels of color `borderColor`.

		This uses the BFS `Breadth First Search` algorithm

		@param position The position to start filling at. you can use a Point2D or IntPoint2D.
		@param color The color to fill with.
		@param borderColor The color upon which to stop filling.</haxe_doc>
	</fillUntilColor>
	<clone public="1" set="method" line="816" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.Image"/>
		</f>
		<haxe_doc>Clones this image.

		Useful if you want to operate on `this` image, without modifying it:

			var blurred = Vision.gaussianBlur(image.clone());</haxe_doc>
	</clone>
	<mirror public="1" set="method" line="824" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.Image"/>
</f></mirror>
	<flip public="1" set="method" line="832" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.Image"/>
</f></flip>
	<resize public="1" get="inline" set="null" line="840" static="1"><f a="this:newWidth:newHeight:?algorithm">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.ImageResizeAlgorithm"/>
	<x path="vision.ds.Image"/>
</f></resize>
	<toString public="1" set="method" line="873" static="1">
		<f a="this:?special" v=":true">
			<x path="vision.ds.ByteArray"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ special : true }</e></m></meta>
		<haxe_doc>Gets the image as a string.

		@param special When using the `Console.hx` haxelib, images can be printed to the console
		with color. set this to false if you don't want this to happen. Set to `true` by default.</haxe_doc>
	</toString>
	<forEachPixel public="1" get="inline" set="null" line="889" static="1"><f a="this:callback">
	<x path="vision.ds.ByteArray"/>
	<f a="x:y:color">
		<x path="Int"/>
		<x path="Int"/>
		<x path="vision.ds.Color"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forEachPixel>
	<iterator public="1" get="inline" set="null" line="897" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<t path="Iterator"><c path="vision.ds.Pixel"/></t>
</f></iterator>
	<from2DArray public="1" set="method" line="969" static="1">
		<f a="array">
			<c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c>
			<x path="vision.ds.Image"/>
		</f>
		<meta><m n=":from"/></meta>
	</from2DArray>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._Image.PixelIterator" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Image.hx" private="1" module="vision.ds.Image">
		<i expr="4">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</i>
		<img><x path="vision.ds.Image"/></img>
		<next public="1" get="inline" set="null" line="995"><f a=""><c path="vision.ds.Pixel"/></f></next>
		<hasNext public="1" get="inline" set="null" line="1003"><f a=""><x path="Bool"/></f></hasNext>
		<new public="1" get="inline" set="null" line="991"><f a="img">
	<x path="vision.ds.Image"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.ds.ImageFormat" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ImageFormat.hx">
		<this><x path="Int"/></this>
		<haxe_doc>The image format to encode in.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds._ImageFormat.ImageFormat_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ImageFormat.hx" private="1" module="vision.ds.ImageFormat" extern="1" final="1">
	<PNG public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>PNG encoding</haxe_doc>
	</PNG>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._ImageFormat.ImageFormat_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ImageFormat.hx" private="1" module="vision.ds.ImageFormat" extern="1" final="1">
		<PNG public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>PNG encoding</haxe_doc>
		</PNG>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vision.ds.ImageResizeAlgorithm" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ImageResizeAlgorithm.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>The resize algorithm to use when changing the size of images.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds._ImageResizeAlgorithm.ImageResizeAlgorithm_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ImageResizeAlgorithm.hx" private="1" module="vision.ds.ImageResizeAlgorithm" extern="1" final="1">
	<NearestNeighbor public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.ImageResizeAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Nearest-Neighbor resizing. Works best for pixel art/resizing by powers of 2.</haxe_doc>
	</NearestNeighbor>
	<BilinearInterpolation public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="vision.ds.ImageResizeAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Bilinear Interpolation. The most reliable method for general resizing purposes. yields the "least lossless" result.</haxe_doc>
	</BilinearInterpolation>
	<BicubicInterpolation public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="vision.ds.ImageResizeAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Unimplemented.</haxe_doc>
	</BicubicInterpolation>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._ImageResizeAlgorithm.ImageResizeAlgorithm_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/ImageResizeAlgorithm.hx" private="1" module="vision.ds.ImageResizeAlgorithm" extern="1" final="1">
		<NearestNeighbor public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Nearest-Neighbor resizing. Works best for pixel art/resizing by powers of 2.</haxe_doc>
		</NearestNeighbor>
		<BilinearInterpolation public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Bilinear Interpolation. The most reliable method for general resizing purposes. yields the "least lossless" result.</haxe_doc>
		</BilinearInterpolation>
		<BicubicInterpolation public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Unimplemented.</haxe_doc>
		</BicubicInterpolation>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="vision.ds._IntPoint2D.Impl" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/IntPoint2D.hx" private="1" module="vision.ds.IntPoint2D"><x path="haxe.Int64"/></typedef>
	<abstract path="vision.ds.IntPoint2D" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/IntPoint2D.hx">
		<from><icast field="fromPoint2D"><c path="vision.ds.Point2D"/></icast></from>
		<this><t path="vision.ds._IntPoint2D.Impl"/></this>
		<to><icast field="toPoint2D"><c path="vision.ds.Point2D"/></icast></to>
		<haxe_doc>A 2D point represented by two, 32-bit integers.</haxe_doc>
		<impl><class path="vision.ds._IntPoint2D.IntPoint2D_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/IntPoint2D.hx" private="1" module="vision.ds.IntPoint2D" final="1">
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The `x` position of this `IntPoint2D`</haxe_doc>
	</x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The `y` position of this `IntPoint2D`</haxe_doc>
	</y>
	<_new public="1" get="inline" set="null" line="38" static="1">
		<f a="x:y">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.IntPoint2D"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get_y get="inline" set="null" line="46" static="1"><f a="this">
	<t path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
</f></get_y>
	<get_x get="inline" set="null" line="54" static="1"><f a="this">
	<t path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
</f></get_x>
	<set_y get="inline" set="null" line="62" static="1"><f a="this:y">
	<t path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
	<set_x get="inline" set="null" line="71" static="1"><f a="this:x">
	<t path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
	<toPoint2D public="1" get="inline" set="null" line="80" static="1">
		<f a="this">
			<t path="vision.ds._IntPoint2D.Impl"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<meta><m n=":to"/></meta>
	</toPoint2D>
	<fromPoint2D public="1" get="inline" set="null" line="84" static="1">
		<f a="p">
			<c path="vision.ds.Point2D"/>
			<x path="vision.ds.IntPoint2D"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPoint2D>
	<toString public="1" get="inline" set="null" line="91" static="1">
		<f a="this">
			<t path="vision.ds._IntPoint2D.Impl"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a `String` representations of this `IntPoint2D`.</haxe_doc>
	</toString>
	<copy public="1" get="inline" set="null" line="98" static="1">
		<f a="this">
			<t path="vision.ds._IntPoint2D.Impl"/>
			<x path="vision.ds.IntPoint2D"/>
		</f>
		<haxe_doc>Returns a new `IntPoint2D` instance, similar to this one.</haxe_doc>
	</copy>
</class></impl>
	</abstract>
	<class path="vision.ds._IntPoint2D.IntPoint2D_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/IntPoint2D.hx" private="1" module="vision.ds.IntPoint2D" final="1">
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The `x` position of this `IntPoint2D`</haxe_doc>
		</x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The `y` position of this `IntPoint2D`</haxe_doc>
		</y>
		<_new public="1" get="inline" set="null" line="38" static="1">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.IntPoint2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get_y get="inline" set="null" line="46" static="1"><f a="this">
	<t path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
</f></get_y>
		<get_x get="inline" set="null" line="54" static="1"><f a="this">
	<t path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
</f></get_x>
		<set_y get="inline" set="null" line="62" static="1"><f a="this:y">
	<t path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
		<set_x get="inline" set="null" line="71" static="1"><f a="this:x">
	<t path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
		<toPoint2D public="1" get="inline" set="null" line="80" static="1">
			<f a="this">
				<t path="vision.ds._IntPoint2D.Impl"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":to"/></meta>
		</toPoint2D>
		<fromPoint2D public="1" get="inline" set="null" line="84" static="1">
			<f a="p">
				<c path="vision.ds.Point2D"/>
				<x path="vision.ds.IntPoint2D"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPoint2D>
		<toString public="1" get="inline" set="null" line="91" static="1">
			<f a="this">
				<t path="vision.ds._IntPoint2D.Impl"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a `String` representations of this `IntPoint2D`.</haxe_doc>
		</toString>
		<copy public="1" get="inline" set="null" line="98" static="1">
			<f a="this">
				<t path="vision.ds._IntPoint2D.Impl"/>
				<x path="vision.ds.IntPoint2D"/>
			</f>
			<haxe_doc>Returns a new `IntPoint2D` instance, similar to this one.</haxe_doc>
		</copy>
	</class>
	<class path="vision.ds.Line2D" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Line2D.hx">
		<fromRay2D public="1" get="inline" set="null" line="75" static="1">
			<f a="ray">
				<c path="vision.ds.Ray2D"/>
				<c path="vision.ds.Line2D"/>
			</f>
			<haxe_doc><![CDATA[Takes an instance of `Ray2D`, and returns a new `Line2D` with the same direction.

		The `start` & `end` point may not be consistent. Set them manually if you need to.]]></haxe_doc>
		</fromRay2D>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The distance between `start` and `end`</haxe_doc>
		</length>
		<slope public="1" set="null">
			<x path="Float"/>
			<haxe_doc>The slope of the line stretched from `start` to `end`</haxe_doc>
		</slope>
		<degrees public="1" set="null">
			<x path="Float"/>
			<haxe_doc>The degrees of the line stretched from `start` to `end`</haxe_doc>
		</degrees>
		<radians public="1" set="null">
			<x path="Float"/>
			<haxe_doc>The radians of the line stretched from `start` to `end`</haxe_doc>
		</radians>
		<start public="1" set="accessor" expr="{ x : 0, y : 0 }">
			<c path="vision.ds.Point2D"/>
			<meta><m n=":value"><e>{ x : 0, y : 0 }</e></m></meta>
			<haxe_doc>The starting point of this `Line2D`.</haxe_doc>
		</start>
		<end public="1" set="accessor" expr="{ x : 0, y : 0 }">
			<c path="vision.ds.Point2D"/>
			<meta><m n=":value"><e>{ x : 0, y : 0 }</e></m></meta>
			<haxe_doc>The ending point of this `Line2D`.</haxe_doc>
		</end>
		<middle public="1" get="accessor" set="accessor">
			<c path="vision.ds.Point2D"/>
			<haxe_doc>The middle point of this `Line2D`</haxe_doc>
		</middle>
		<get_length get="inline" set="null" line="58"><f a=""><x path="Float"/></f></get_length>
		<toString public="1" get="inline" set="null" line="66">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns a `String` representation of this `Line2D`.</haxe_doc>
		</toString>
		<toRay2D public="1" get="inline" set="null" line="86">
			<f a=""><c path="vision.ds.Ray2D"/></f>
			<haxe_doc>Constructs a new `Ray2D` using this `Line2D`'s start point and slope.</haxe_doc>
		</toRay2D>
		<set_start get="inline" set="null" line="90"><f a="value">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
</f></set_start>
		<set_end get="inline" set="null" line="97"><f a="value">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
</f></set_end>
		<get_middle get="inline" set="null" line="104"><f a=""><c path="vision.ds.Point2D"/></f></get_middle>
		<set_middle get="inline" set="null" line="108"><f a="value">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
</f></set_middle>
		<new public="1" get="inline" set="null" line="48">
			<f a="start:end">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Constructs a new `Line2D` from two `Point2D`s</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Represents a 2-dimensional line, by `start` & `end` point]]></haxe_doc>
	</class>
	<typedef path="vision.ds.Matrix" params="T" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Matrix.hx">
		<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><c path="vision.ds.Matrix.T"/></x></x>
		<haxe_doc><![CDATA[Simply a `typedef` for a 2D vector.

	```haxe
	Matrix<T> = Vector<Vector<T>>
	```]]></haxe_doc>
	</typedef>
	<class path="vision.ds.Pixel" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Pixel.hx">
		<x public="1">
			<x path="Int"/>
			<haxe_doc>The row on which the pixel is on</haxe_doc>
		</x>
		<y public="1">
			<x path="Int"/>
			<haxe_doc>The column on which the pixel is on</haxe_doc>
		</y>
		<color public="1">
			<x path="vision.ds.Color"/>
			<haxe_doc>The color of the pixel, in `ARGB` format.</haxe_doc>
		</color>
		<new public="1" get="inline" set="null" line="29">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param x The row on which the pixel is on 
		@param y The column on which the pixel is on 
		@param color The color of the pixel, in `ARGB` format.</haxe_doc>
		</new>
		<haxe_doc>A structure useful for representing a pixel in an image.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="vision.ds.Point2D" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Point2D.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>The x-coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>The y-coordinate of the point.</haxe_doc>
		</y>
		<toString public="1" get="inline" set="null" line="31">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a `String` representations of this `Point2D`.</haxe_doc>
		</toString>
		<copy public="1" get="inline" set="null" line="38">
			<f a=""><c path="vision.ds.Point2D"/></f>
			<haxe_doc>Returns a new `Point2D` instance, similar to this one.</haxe_doc>
		</copy>
		<new public="1" get="inline" set="null" line="23">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>Initializes a new instance of the Point2D class with the specified x and y coordinates.

		you can construct a Point2D object by using the following syntax too:
		```haxe
		var point:Point2D = {x: 10, y: 20};
		```</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="vision.ds.Ray2D" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Ray2D.hx">
		<from2Points public="1" get="inline" set="null" line="66" static="1">
			<f a="point1:point2">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Ray2D"/>
			</f>
			<haxe_doc>Constructs a `Ray2D` from 2 `Point2D`s</haxe_doc>
		</from2Points>
		<point public="1">
			<c path="vision.ds.Point2D"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>The `Point2D` used in the constructor</haxe_doc>
		</point>
		<slope public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The direction of this `Ray2D`, in a rise-over-run format.</haxe_doc>
		</slope>
		<degrees public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The direction of this `Ray2D`, in degrees</haxe_doc>
		</degrees>
		<radians public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The direction of this `Ray2D`, in radians</haxe_doc>
		</radians>
		<yIntercept public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The `y` position in which `x = 0`</haxe_doc>
		</yIntercept>
		<xIntercept public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The `x` position in which `y = 0`</haxe_doc>
		</xIntercept>
		<getPointAtX public="1" get="inline" set="null" line="74">
			<f a="x">
				<x path="Float"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Gets the point on this `Ray2D` at `(x, y)` when `x` is given.</haxe_doc>
		</getPointAtX>
		<getPointAtY public="1" get="inline" set="null" line="81">
			<f a="y">
				<x path="Float"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Gets the point on this `Ray2D` at `(x, y)` when `y` is given.</haxe_doc>
		</getPointAtY>
		<intersect public="1" get="inline" set="null" line="93">
			<f a="ray">
				<c path="vision.ds.Ray2D"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Gets the intersection point between `this` and `ray`.

		If `this` and `ray` don't intersect, `null` is returned.

		@param ray The second ray to intersect with
		@return A `Point2D` instance, `null` if `this` and `ray` don't intersect</haxe_doc>
		</intersect>
		<set_slope get="inline" set="null" line="100"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_slope>
		<set_degrees get="inline" set="null" line="106"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_degrees>
		<set_radians get="inline" set="null" line="112"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<get_yIntercept get="inline" set="null" line="118"><f a=""><x path="Float"/></f></get_yIntercept>
		<get_xIntercept get="inline" set="null" line="126"><f a=""><x path="Float"/></f></get_xIntercept>
		<new public="1" get="inline" set="null" line="46">
			<f a="point:?m:?degrees:?radians">
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param point a point on the line
		@param m the slope of the line, optional - you can pass the angle/radians instead, and set this to null
		@param angle the angle of the line, optional - you can pass the slope/radians instead, and set this to null
		@param radians the radians of the line, optional - you can pass the slope/angle instead, and not set this</haxe_doc>
		</new>
		<haxe_doc>Represents a 2-dimensional ray on the cartesian coordinate system</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.ds.Rectangle" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/ds/Rectangle.hx">
		<x public="1">
			<x path="Int"/>
			<haxe_doc>The `x` position of this `Rectangle`</haxe_doc>
		</x>
		<y public="1">
			<x path="Int"/>
			<haxe_doc>The `y` position of this `Rectangle`</haxe_doc>
		</y>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>The `width` of this `Rectangle`</haxe_doc>
		</width>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>The `height` of this `Rectangle`</haxe_doc>
		</height>
		<new public="1" set="method" line="4">
			<f a="x:y:width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param height The `height` of this `Rectangle`
@param width The `width` of this `Rectangle`
@param y The `y` position of this `Rectangle`
@param x The `x` position of this `Rectangle`</haxe_doc>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="vision.exceptions.VisionException" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/exceptions/VisionException.hx">
		<extends path="haxe.Exception"/>
		<new public="1" set="method" line="22"><f a="message:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A type of error, thrown by components of the `Vision` library</haxe_doc>
	</class>
	<class path="vision.exceptions.ImageLoadingFailed" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/exceptions/ImageLoadingFailed.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="6"><f a="type:reason">
	<x path="vision.ds.ImageFormat"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.exceptions.ImageSavingFailed" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/exceptions/ImageSavingFailed.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="6"><f a="type:reason">
	<x path="vision.ds.ImageFormat"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.exceptions.OutOfBounds" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/exceptions/OutOfBounds.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="8"><f a="image:position">
	<x path="vision.ds.Image"/>
	<c path="vision.ds.Point2D"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.exceptions.Unimplemented" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/exceptions/Unimplemented.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="4"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.tools.ImageTools" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/tools/ImageTools.hx">
		<defaultResizeAlgorithm public="1" expr="BilinearInterpolation" line="38" static="1">
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<meta><m n=":value"><e>BilinearInterpolation</e></m></meta>
			<haxe_doc>* The default algorithm to use when resizing an image by "brute force" (setting its `width`/`height` when `vision_allow_resize` is defined)</haxe_doc>
		</defaultResizeAlgorithm>
		<loadFromFile public="1" set="method" line="58" static="1">
			<f a="?image:path:onComplete">
				<x path="vision.ds.Image"/>
				<c path="String"/>
				<f a="">
					<x path="vision.ds.Image"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Gets an image from a file. 

		the given path can be an absolute path or a relative path. a URL is valid too.  

		**Note: On `sys` targets, this function requires the `format` library, and only supports PNG.**

		To install:  
		  
		`haxelib install format`

		@param image optional, if you don't want to create a new image instance (usage: `image.loadFromFile("path/to/image.png")`)
		@param path the path to the image file. on js, it can only be a relative path/a URL

		@returns the image object.
		@throws LibraryRequired Thrown when used on `sys` targets without installing & including `format`
		@throws ImageLoadingFailed Thrown when trying to load a corrupted file.]]></haxe_doc>
		</loadFromFile>
		<saveToFile public="1" set="method" line="146" static="1">
			<f a="image:pathWithFileName:?saveFormat" v="::PNG">
				<x path="vision.ds.Image"/>
				<c path="String"/>
				<x path="vision.ds.ImageFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ saveFormat : PNG }</e></m></meta>
		</saveToFile>
		<addToScreen public="1" set="method" line="192" static="1">
			<f a="image:x:y:?units">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<a>
					<zIndex>
						<x path="Null"><c path="String"/></x>
						<meta><m n=":optional"/></meta>
					</zIndex>
					<yUnits>
						<x path="Null"><c path="String"/></x>
						<meta><m n=":optional"/></meta>
					</yUnits>
					<xUnits>
						<x path="Null"><c path="String"/></x>
						<meta><m n=":optional"/></meta>
					</xUnits>
				</a>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Adds an `Image` to the screen.

		**Currently, this function only works on the web**, and
		it uses an absolutely positioned canvas element.

		#### Notice - JS Only

		if you want to use this function to add an image to a web page,
		and also want to use different units than pixels, you can use the `units` parameter.

			addToScreen(image, 50, 20, {xUnits: "vw", yUnits: "vh", zIndex: 1});

		@param image the image to add.
		@param x the x position of the image.
		@param y the y position of the image.

		@returns the image object.</haxe_doc>
		</addToScreen>
		<getNeighborsOfPixel public="1" get="inline" set="null" line="225" static="1"><f a="image:x:y:kernalSize">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="vision.ds.Array2D"><x path="vision.ds.Color"/></c>
</f></getNeighborsOfPixel>
		<getNeighborsOfPixelIter public="1" get="inline" set="null" line="234" static="1">
			<f a="image:x:y:kernalSize:?circular" v="::::false">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="Iterator"><x path="vision.ds.Color"/></t>
			</f>
			<meta><m n=":value"><e>{ circular : false }</e></m></meta>
		</getNeighborsOfPixelIter>
		<grayscalePixel public="1" get="inline" set="null" line="238" static="1"><f a="pixel">
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></grayscalePixel>
		<haxe_doc>A class used to provide extra utilities to the `Image` class.

	Those properties are not included because they are not needed for the basic functionality of that object.

	to use those utilities, use this class at the top of you file:

		using vision.tools.ImageTools;</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.tools._ImageTools.NeighborsIterator" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/tools/ImageTools.hx" private="1" module="vision.tools.ImageTools">
		<roundedDown><x path="Int"/></roundedDown>
		<image><x path="vision.ds.Image"/></image>
		<x><x path="Int"/></x>
		<y><x path="Int"/></y>
		<X><x path="Int"/></X>
		<Y><x path="Int"/></Y>
		<circular><x path="Bool"/></circular>
		<next public="1" get="inline" set="null" line="406"><f a=""><x path="vision.ds.Color"/></f></next>
		<hasNext public="1" get="inline" set="null" line="417"><f a=""><x path="Bool"/></f></hasNext>
		<new public="1" get="inline" set="null" line="396">
			<f a="image:x:y:kernalSize:?circular" v="::::false">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ circular : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.tools.MathTools" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/tools/MathTools.hx">
		<PI public="1" get="accessor" set="null" static="1"><x path="Float"/></PI>
		<PI_OVER_2 public="1" get="accessor" set="null" static="1"><x path="Float"/></PI_OVER_2>
		<NEGATIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></POSITIVE_INFINITY>
		<NaN public="1" get="accessor" set="null" static="1"><x path="Float"/></NaN>
		<distanceFromRayToPoint2D public="1" get="inline" set="null" line="36" static="1"><f a="ray:point">
	<c path="vision.ds.Ray2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></distanceFromRayToPoint2D>
		<intersectionBetweenRay2Ds public="1" get="inline" set="null" line="40" static="1"><f a="ray:ray2">
	<c path="vision.ds.Ray2D"/>
	<c path="vision.ds.Ray2D"/>
	<c path="vision.ds.Point2D"/>
</f></intersectionBetweenRay2Ds>
		<findPointAtDistanceUsingX public="1" get="inline" set="null" line="82" static="1">
			<f a="ray:startXPos:distance:?goPositive" v=":::true">
				<c path="vision.ds.Ray2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":value"><e>{ goPositive : true }</e></m></meta>
			<haxe_doc>* Gets the point on `ray` , which is `distance` points away
	 * from `startXPos`.
	 * 
	 * In order to avoid returning two points (since
	 * any point on the ray has 2 points with the exact same distance from it),
	 * you have the `goPositive` value.
	 * 
	 * 
	 * @param startXPos The `x` position to start from.
	 * @param distance The distance from `start` to the resulting point.
	 * @param goPositive Whether or not the resulting point is in front/behind `start`. `true` means in front, `false` means behind.</haxe_doc>
		</findPointAtDistanceUsingX>
		<findPointAtDistanceUsingY public="1" get="inline" set="null" line="106" static="1">
			<f a="ray:startYPos:distance:?goPositive" v=":::true">
				<c path="vision.ds.Ray2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":value"><e>{ goPositive : true }</e></m></meta>
			<haxe_doc>* Gets the point on `ray` , which is `distance` points away
	 * from `startYPos`.
	 * 
	 * In order to avoid returning two points (since
	 * any point on the ray has 2 points with the exact same distance from it),
	 * you have the `goPositive` value.
	 * 
	 * 
	 * @param startYPos The `y` position to start from.
	 * @param distance The distance from `start` to the resulting point.
	 * @param goPositive Whether or not the resulting point is in front/behind `start`. `true` means in front, `false` means behind.</haxe_doc>
		</findPointAtDistanceUsingY>
		<distanceFromLineToPoint2D public="1" get="inline" set="null" line="121" static="1"><f a="line:point">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></distanceFromLineToPoint2D>
		<distanceBetweenLines2D public="1" get="inline" set="null" line="131" static="1"><f a="line1:line2">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Line2D"/>
	<x path="Float"/>
</f></distanceBetweenLines2D>
		<radiansFromLineToPoint2D public="1" get="inline" set="null" line="144" static="1"><f a="line:point">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></radiansFromLineToPoint2D>
		<intersectionBetweenLine2Ds public="1" get="inline" set="null" line="148" static="1"><f a="line1:line2">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Point2D"/>
</f></intersectionBetweenLine2Ds>
		<mirrorInsideRectangle public="1" get="inline" set="null" line="174" static="1"><f a="line:rect">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Rectangle"/>
	<c path="vision.ds.Line2D"/>
</f></mirrorInsideRectangle>
		<flipInsideRectangle public="1" get="inline" set="null" line="183" static="1"><f a="line:rect">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Rectangle"/>
	<c path="vision.ds.Line2D"/>
</f></flipInsideRectangle>
		<invertInsideRectangle public="1" get="inline" set="null" line="192" static="1"><f a="line:rect">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Rectangle"/>
	<c path="vision.ds.Line2D"/>
</f></invertInsideRectangle>
		<distanceFromPointToRay2D public="1" get="inline" set="null" line="209" static="1"><f a="point:line">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Ray2D"/>
	<x path="Float"/>
</f></distanceFromPointToRay2D>
		<distanceFromPointToLine2D public="1" set="method" line="222" static="1"><f a="point:line">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Line2D"/>
	<x path="Float"/>
</f></distanceFromPointToLine2D>
		<radiansFromPointToLine2D public="1" get="inline" set="null" line="241" static="1"><f a="point:line">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Line2D"/>
	<x path="Float"/>
</f></radiansFromPointToLine2D>
		<radiansFromPointToPoint2D public="1" get="inline" set="null" line="247" static="1"><f a="point1:point2">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></radiansFromPointToPoint2D>
		<degreesFromPointToPoint2D public="1" get="inline" set="null" line="253" static="1"><f a="point1:point2">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></degreesFromPointToPoint2D>
		<slopeFromPointToPoint2D public="1" get="inline" set="null" line="257" static="1"><f a="point1:point2">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></slopeFromPointToPoint2D>
		<distanceBetweenPoints public="1" get="inline" set="null" line="262" static="1"><f a="point1:point2">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></distanceBetweenPoints>
		<wrapInt public="1" get="inline" set="null" line="277" static="1">
			<f a="value:min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Ensures that the value is between min and max, by wrapping the value around
		when it is outside of the range.</haxe_doc>
		</wrapInt>
		<wrapFloat public="1" get="inline" set="null" line="290" static="1">
			<f a="value:min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Ensures that the value is between min and max, by wrapping the value around
		when it is outside of the range.</haxe_doc>
		</wrapFloat>
		<boundInt public="1" set="method" line="302" static="1">
			<f a="value:min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Ensures that the value is between min and max, by bounding the value when it is outside of the range.</haxe_doc>
		</boundInt>
		<boundFloat public="1" set="method" line="309" static="1">
			<f a="value:min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Ensures that the value is between min and max, by bounding the value when it is outside of the range.</haxe_doc>
		</boundFloat>
		<isPositive public="1" params="T" get="inline" set="null" line="316" static="1">
			<f a="number">
				<c path="isPositive.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>Returns `true` if `number` is positive, `false` if negative</haxe_doc>
		</isPositive>
		<flatten public="1" params="T" get="inline" set="null" line="325" static="1">
			<f a="array">
				<c path="Array"><c path="Array"><c path="flatten.T"/></c></c>
				<c path="Array"><c path="flatten.T"/></c>
			</f>
			<haxe_doc><![CDATA[* Takes a 2D array and flattens it to a regular, 1D array.
	 * @param array
	 * @return Array<T>]]></haxe_doc>
			<overloads><flatten public="1" params="T" get="inline" set="null" line="337">
	<f a="matrix">
		<t path="vision.ds.Matrix"><c path="flatten.T"/></t>
		<x path="haxe.ds.Vector"><c path="flatten.T"/></x>
	</f>
	<haxe_doc><![CDATA[* Takes a Matrix and flattens it into a Vector.
	 * @param matrix
	 * @return Vector<T>]]></haxe_doc>
</flatten></overloads>
		</flatten>
		<raise public="1" params="T" get="inline" set="null" line="350" static="1">
			<f a="array:delimiter">
				<c path="Array"><c path="raise.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="Array"><c path="raise.T"/></c></c>
			</f>
			<haxe_doc><![CDATA[* Takes a 1D array and turns it into a 2D array, while splitting into arrays every `delimiter` indexes
	 * @param array
	 * @param delimiter
	 * @return Array<T>]]></haxe_doc>
			<overloads><raise public="1" params="T" get="inline" set="null" line="365">
	<f a="vector:delimiter">
		<x path="haxe.ds.Vector"><c path="raise.T"/></x>
		<x path="Int"/>
		<t path="vision.ds.Matrix"><c path="raise.T"/></t>
	</f>
	<haxe_doc><![CDATA[* Takes a Vector and turns it into a Matrix, while splitting into vectors every `delimiter` indexes
	 * @param vector
	 * @param delimiter
	 * @return Array<T>]]></haxe_doc>
</raise></overloads>
		</raise>
		<slopeToDegrees public="1" get="inline" set="null" line="380" static="1"><f a="slope">
	<x path="Float"/>
	<x path="Float"/>
</f></slopeToDegrees>
		<slopeToRadians public="1" get="inline" set="null" line="384" static="1"><f a="slope">
	<x path="Float"/>
	<x path="Float"/>
</f></slopeToRadians>
		<degreesToSlope public="1" get="inline" set="null" line="388" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></degreesToSlope>
		<degreesToRadians public="1" get="inline" set="null" line="392" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></degreesToRadians>
		<radiansToDegrees public="1" get="inline" set="null" line="396" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></radiansToDegrees>
		<radiansToSlope public="1" get="inline" set="null" line="400" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></radiansToSlope>
		<cotan public="1" get="inline" set="null" line="404" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></cotan>
		<cosec public="1" get="inline" set="null" line="408" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></cosec>
		<sec public="1" get="inline" set="null" line="412" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></sec>
		<truncate public="1" set="method" line="416" static="1"><f a="num:numbersAfterDecimal">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></truncate>
		<minFloat public="1" get="inline" set="null" line="421" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<overloads><minFloat public="1" get="inline" set="null" line="430"><f a="values">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></minFloat></overloads>
		</minFloat>
		<min public="1" get="inline" set="null" line="439" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Int"/></x>
				<x path="Int"/>
			</f>
			<overloads><min public="1" get="inline" set="null" line="448"><f a="values">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
</f></min></overloads>
		</min>
		<maxFloat public="1" get="inline" set="null" line="457" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<overloads><maxFloat public="1" get="inline" set="null" line="466"><f a="values">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></maxFloat></overloads>
		</maxFloat>
		<max public="1" get="inline" set="null" line="475" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Int"/></x>
				<x path="Int"/>
			</f>
			<overloads><max public="1" get="inline" set="null" line="484"><f a="values">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
</f></max></overloads>
		</max>
		<isBetweenRanges public="1" set="method" line="493" static="1"><f a="value:ranges">
	<x path="Float"/>
	<x path="haxe.Rest"><a>
	<start><x path="Float"/></start>
	<end><x path="Float"/></end>
</a></x>
	<x path="Bool"/>
</f></isBetweenRanges>
		<average public="1" get="inline" set="null" line="508" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<overloads><average public="1" params="T:Uint:Int64:Float" get="inline" set="null" line="516"><f a="values">
	<c path="Array"><c path="average.T"/></c>
	<x path="Float"/>
</f></average></overloads>
		</average>
		<median public="1" params="T:Uint:Int64" get="inline" set="null" line="527" static="1">
			<f a="values">
				<x path="haxe.Rest"><c path="median.T"/></x>
				<c path="median.T"/>
			</f>
			<haxe_doc>* Gets the median of the given values. For large arrays, Radix sort is used to boost performance (1000 elements or above)</haxe_doc>
			<overloads>
				<median public="1" get="inline" set="null" line="560">
					<f a="values">
						<c path="Array"><x path="Float"/></c>
						<x path="Float"/>
					</f>
					<haxe_doc>* Gets the median of the given values.</haxe_doc>
				</median>
				<median public="1" params="T:UInt:Int64" get="inline" set="null" line="548">
					<f a="values">
						<c path="Array"><c path="median.T"/></c>
						<c path="median.T"/>
					</f>
					<haxe_doc>* Gets the median of the given values. For large arrays, Radix sort is used to boost performance (1000 elements or above)</haxe_doc>
				</median>
				<median public="1" get="inline" set="null" line="539">
					<f a="values">
						<x path="haxe.Rest"><x path="Float"/></x>
						<x path="Float"/>
					</f>
					<haxe_doc>* Gets the median of the given values.</haxe_doc>
				</median>
			</overloads>
		</median>
		<isInt public="1" get="inline" set="null" line="566" static="1"><f a="v">
	<x path="Float"/>
	<x path="Bool"/>
</f></isInt>
		<clamp public="1" get="inline" set="null" line="570" static="1"><f a="value:mi:ma">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
		<get_NEGATIVE_INFINITY get="inline" set="null" line="579" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_NEGATIVE_INFINITY>
		<get_POSITIVE_INFINITY get="inline" set="null" line="580" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_POSITIVE_INFINITY>
		<get_NaN get="inline" set="null" line="581" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_NaN>
		<get_PI_OVER_2 get="inline" set="null" line="582" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_PI_OVER_2>
		<get_PI get="inline" set="null" line="583" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_PI>
		<abs public="1" get="inline" set="null" line="586" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<acos public="1" get="inline" set="null" line="589" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<asin public="1" get="inline" set="null" line="592" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<atan public="1" get="inline" set="null" line="595" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" get="inline" set="null" line="598" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<ceil public="1" get="inline" set="null" line="601" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<cos public="1" get="inline" set="null" line="604" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<exp public="1" get="inline" set="null" line="607" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></exp>
		<floor public="1" get="inline" set="null" line="610" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<log public="1" get="inline" set="null" line="613" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></log>
		<pow public="1" get="inline" set="null" line="616" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<random public="1" get="inline" set="null" line="619" static="1"><f a=""><x path="Float"/></f></random>
		<round public="1" get="inline" set="null" line="622" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<sin public="1" get="inline" set="null" line="625" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<sqrt public="1" get="inline" set="null" line="628" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<tan public="1" get="inline" set="null" line="631" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<ffloor public="1" get="inline" set="null" line="634" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="637" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="640" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" get="inline" set="null" line="643" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isFinite>
		<isNaN public="1" get="inline" set="null" line="646" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isNaN>
		<haxe_doc>A class consisting of a **b u n c h** of static methods for manipulating values,
	calculating distances, intersections, etc.

	This class is fully compatible with haxe's `Math` class. That means you don't have to use
	both at the same time.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.tools.Number" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/tools/MathTools.hx" module="vision.tools.MathTools">
		<from>
			<icast><x path="Float"/></icast>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><x path="Float"/></icast>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</to>
		<impl><class path="vision.tools._MathTools.Number_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/tools/MathTools.hx" private="1" module="vision.tools.MathTools" extern="1" final="1"/></impl>
	</abstract>
	<class path="vision.tools._MathTools.Number_Impl_" params="" file="/home/nanjizal/haxe/haxelib/vision/1,1,0/src/vision/tools/MathTools.hx" private="1" module="vision.tools.MathTools" extern="1" final="1"/>
</haxe>