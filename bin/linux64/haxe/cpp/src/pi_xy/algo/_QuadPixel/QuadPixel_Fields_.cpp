// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_RectangleWindow
#include <pi_xy/algo/RectangleWindow.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo__QuadPixel_QuadPixel_Fields_
#include <pi_xy/algo/_QuadPixel/QuadPixel_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_18_fillQuadrilateral,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","fillQuadrilateral",0xf1160ad4,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.fillQuadrilateral","pi_xy/algo/QuadPixel.hx",18,0x68b40e73)
HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_48_fillSoftQuadrilateral,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","fillSoftQuadrilateral",0xa789fd0a,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.fillSoftQuadrilateral","pi_xy/algo/QuadPixel.hx",48,0x68b40e73)
HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_72_fillSoftQuadrilateralFudge,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","fillSoftQuadrilateralFudge",0x4d614c29,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.fillSoftQuadrilateralFudge","pi_xy/algo/QuadPixel.hx",72,0x68b40e73)
HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_97_fillSoftQuadrilateralQuarter,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","fillSoftQuadrilateralQuarter",0x77f4d842,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.fillSoftQuadrilateralQuarter","pi_xy/algo/QuadPixel.hx",97,0x68b40e73)
HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_122_tileQuadrilateral,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","tileQuadrilateral",0xc7ae3f49,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.tileQuadrilateral","pi_xy/algo/QuadPixel.hx",122,0x68b40e73)
HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_141_fillGradQuadrilateral,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","fillGradQuadrilateral",0xc5ed4ba6,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.fillGradQuadrilateral","pi_xy/algo/QuadPixel.hx",141,0x68b40e73)
HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_161_imgQuadrilateralFudge,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","imgQuadrilateralFudge",0x52d7fe1b,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.imgQuadrilateralFudge","pi_xy/algo/QuadPixel.hx",161,0x68b40e73)
HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_183_imgQuadrilateral,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","imgQuadrilateral",0x6fb49058,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.imgQuadrilateral","pi_xy/algo/QuadPixel.hx",183,0x68b40e73)
HX_LOCAL_STACK_FRAME(_hx_pos_da603ae7b1d3a0e2_206_imageNineSlice,"pi_xy.algo._QuadPixel.QuadPixel_Fields_","imageNineSlice",0x6a405ec7,"pi_xy.algo._QuadPixel.QuadPixel_Fields_.imageNineSlice","pi_xy/algo/QuadPixel.hx",206,0x68b40e73)
namespace pi_xy{
namespace algo{
namespace _QuadPixel{

void QuadPixel_Fields__obj::__construct() { }

Dynamic QuadPixel_Fields__obj::__CreateEmpty() { return new QuadPixel_Fields__obj; }

void *QuadPixel_Fields__obj::_hx_vtable = 0;

Dynamic QuadPixel_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< QuadPixel_Fields__obj > _hx_result = new QuadPixel_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool QuadPixel_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1d0470b0;
}

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::fillQuadrilateral( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,int color,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_18_fillQuadrilateral)
HXLINE(  21)		{
HXLINE(  21)			Float bx1 = bx;
HXDLIN(  21)			Float by1 = by;
HXDLIN(  21)			Float cx1 = dx;
HXDLIN(  21)			Float cy1 = dy;
HXDLIN(  21)			bool hasUndo = false;
HXDLIN(  21)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  21)			if (!(adjustWinding)) {
HXLINE(  21)				Float bx_ = bx1;
HXDLIN(  21)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE(  21)			{
HXLINE(  21)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  21)				Float sx = (cy1 - ay);
HXDLIN(  21)				Float sy = (ax - cx1);
HXDLIN(  21)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  21)				Float tx = (ay - by1);
HXDLIN(  21)				Float ty = (bx1 - ax);
HXDLIN(  21)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  21)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  21)				if ((ax > bx1)) {
HXLINE(  21)					if ((ax > cx1)) {
HXLINE(  21)						int min;
HXDLIN(  21)						if ((bx1 > cx1)) {
HXLINE(  21)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  21)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN(  21)						int ii_min = min;
HXDLIN(  21)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  21)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE(  21)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  21)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  21)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE(  21)					if ((bx1 > cx1)) {
HXLINE(  21)						int min1;
HXDLIN(  21)						if ((ax > cx1)) {
HXLINE(  21)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  21)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN(  21)						int ii_min2 = min1;
HXDLIN(  21)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  21)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE(  21)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  21)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  21)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN(  21)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  21)				if ((ay > by1)) {
HXLINE(  21)					if ((ay > cy1)) {
HXLINE(  21)						int min2;
HXDLIN(  21)						if ((by1 > cy1)) {
HXLINE(  21)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  21)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN(  21)						int ii_min4 = min2;
HXDLIN(  21)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  21)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE(  21)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  21)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  21)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE(  21)					if ((by1 > cy1)) {
HXLINE(  21)						int min3;
HXDLIN(  21)						if ((ay > cy1)) {
HXLINE(  21)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  21)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN(  21)						int ii_min6 = min3;
HXDLIN(  21)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  21)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE(  21)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  21)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  21)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN(  21)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  21)				if (hasUndo) {
HXLINE(  21)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  21)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  21)					 ::Dynamic imageType = null();
HXDLIN(  21)					 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  21)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  21)					::Dynamic undoImage1;
HXDLIN(  21)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE(  21)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  21)							 ::iterMagic::BytesImg b = byt;
HXDLIN(  21)							{
HXLINE(  21)								b->width = width;
HXDLIN(  21)								b->height = height;
HXDLIN(  21)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  21)								{
HXLINE(  21)									int len = b->length;
HXDLIN(  21)									int w = 0;
HXDLIN(  21)									{
HXLINE(  21)										int _g = 0;
HXDLIN(  21)										int _g1 = b->height;
HXDLIN(  21)										while((_g < _g1)){
HXLINE(  21)											_g = (_g + 1);
HXDLIN(  21)											int y = (_g - 1);
HXDLIN(  21)											{
HXLINE(  21)												int _g2 = 0;
HXDLIN(  21)												int _g3 = b->width;
HXDLIN(  21)												while((_g2 < _g3)){
HXLINE(  21)													_g2 = (_g2 + 1);
HXDLIN(  21)													int x = (_g2 - 1);
HXDLIN(  21)													{
HXLINE(  21)														w = (w + 1);
HXDLIN(  21)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  21)													{
HXLINE(  21)														w = (w + 1);
HXDLIN(  21)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  21)													{
HXLINE(  21)														w = (w + 1);
HXDLIN(  21)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  21)													{
HXLINE(  21)														w = (w + 1);
HXDLIN(  21)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  21)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE(  21)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  21)							{
HXLINE(  21)								a->width = width;
HXDLIN(  21)								a->height = height;
HXDLIN(  21)								a->data = ::Array_obj< int >::__new(0);
HXDLIN(  21)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)								{
HXLINE(  21)									int _g4 = 0;
HXDLIN(  21)									int _g5 = a->length;
HXDLIN(  21)									while((_g4 < _g5)){
HXLINE(  21)										_g4 = (_g4 + 1);
HXDLIN(  21)										int i = (_g4 - 1);
HXDLIN(  21)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN(  21)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE(  21)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  21)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  21)							{
HXLINE(  21)								b1->width = width;
HXDLIN(  21)								b1->height = height;
HXDLIN(  21)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)								int size = (b1->length * 4);
HXDLIN(  21)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  21)								{
HXLINE(  21)									int _g6 = 0;
HXDLIN(  21)									int _g7 = b1->length;
HXDLIN(  21)									while((_g6 < _g7)){
HXLINE(  21)										_g6 = (_g6 + 1);
HXDLIN(  21)										int i1 = (_g6 - 1);
HXDLIN(  21)										{
HXLINE(  21)											 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  21)											bool undoImage2;
HXDLIN(  21)											if ((i1 >= 0)) {
HXLINE(  21)												undoImage2 = (i1 < (this2->byteLength >> 2));
            											}
            											else {
HXLINE(  21)												undoImage2 = false;
            											}
HXDLIN(  21)											if (undoImage2) {
HXLINE(  21)												 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  21)												int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  21)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  21)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  21)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  21)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  21)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE(  21)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)							 ::iterMagic::VecIntImg v = vec;
HXDLIN(  21)							{
HXLINE(  21)								v->width = width;
HXDLIN(  21)								v->height = height;
HXDLIN(  21)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  21)								{
HXLINE(  21)									int _g8 = 0;
HXDLIN(  21)									int _g9 = v->length;
HXDLIN(  21)									while((_g8 < _g9)){
HXLINE(  21)										_g8 = (_g8 + 1);
HXDLIN(  21)										int i2 = (_g8 - 1);
HXDLIN(  21)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN(  21)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE(  21)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  21)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  21)							{
HXLINE(  21)								b2->width = width;
HXDLIN(  21)								b2->height = height;
HXDLIN(  21)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  21)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  21)								{
HXLINE(  21)									int len1 = b2->length;
HXDLIN(  21)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  21)									if (::hx::IsNull( d->head )) {
HXLINE(  21)										int _g10 = 0;
HXDLIN(  21)										int _g11 = len1;
HXDLIN(  21)										while((_g10 < _g11)){
HXLINE(  21)											_g10 = (_g10 + 1);
HXDLIN(  21)											int i3 = (_g10 - 1);
HXDLIN(  21)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE(  21)										int _g12 = 0;
HXDLIN(  21)										int _g13 = len1;
HXDLIN(  21)										while((_g12 < _g13)){
HXLINE(  21)											_g12 = (_g12 + 1);
HXDLIN(  21)											int i4 = (_g12 - 1);
HXDLIN(  21)											{
HXLINE(  21)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  21)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  21)												{
HXLINE(  21)													int _g14 = 0;
HXDLIN(  21)													int _g15 = i4;
HXDLIN(  21)													while((_g14 < _g15)){
HXLINE(  21)														_g14 = (_g14 + 1);
HXDLIN(  21)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE(  21)												if (::hx::IsNull( prev )) {
HXLINE(  21)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  21)													l = null();
            												}
            												else {
HXLINE(  21)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  21)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  21)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN(  21)					this1->image = undoImage1;
HXDLIN(  21)					this1->width = width;
HXDLIN(  21)					this1->height = height;
HXDLIN(  21)					this1->imageType = ( (int)(imageType) );
HXDLIN(  21)					undoImage = this1;
HXDLIN(  21)					{
HXLINE(  21)						int rectLeft = xIter3->start;
HXDLIN(  21)						int rectTop = yIter3->start;
HXDLIN(  21)						int rectRight = xIter3->max;
HXDLIN(  21)						bool forceClear = false;
HXDLIN(  21)						{
HXLINE(  21)							int _g16 = rectTop;
HXDLIN(  21)							int _g17 = yIter3->max;
HXDLIN(  21)							while((_g16 < _g17)){
HXLINE(  21)								_g16 = (_g16 + 1);
HXDLIN(  21)								int dy1 = (_g16 - 1);
HXDLIN(  21)								{
HXLINE(  21)									int _g18 = rectLeft;
HXDLIN(  21)									int _g19 = rectRight;
HXDLIN(  21)									while((_g18 < _g19)){
HXLINE(  21)										_g18 = (_g18 + 1);
HXDLIN(  21)										int dx1 = (_g18 - 1);
HXDLIN(  21)										::Dynamic this3 = pixelImage->image;
HXDLIN(  21)										int index;
HXDLIN(  21)										if (pixelImage->useVirtualPos) {
HXLINE(  21)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  21)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            										}
HXDLIN(  21)										int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  21)										int col;
HXDLIN(  21)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  21)											col = c;
            										}
HXDLIN(  21)										bool _hx_tmp;
HXDLIN(  21)										if (pixelImage->useMask) {
HXLINE(  21)											_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE(  21)											_hx_tmp = false;
            										}
HXDLIN(  21)										if (_hx_tmp) {
HXLINE(  21)											 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN(  21)											::Dynamic this5 = this4->image;
HXDLIN(  21)											int index1;
HXDLIN(  21)											if (this4->useVirtualPos) {
HXLINE(  21)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            											}
            											else {
HXLINE(  21)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            											}
HXDLIN(  21)											int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  21)											int v1;
HXDLIN(  21)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE(  21)												v1 = c1;
            											}
HXDLIN(  21)											int maskPixel = v1;
HXDLIN(  21)											int this6 = col;
HXDLIN(  21)											if ((maskPixel == 0)) {
HXLINE(  21)												col = this6;
            											}
            											else {
HXLINE(  21)												Float m0;
HXDLIN(  21)												int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  21)												if ((this7 == 0)) {
HXLINE(  21)													m0 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float m1;
HXDLIN(  21)												int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  21)												if ((this8 == 0)) {
HXLINE(  21)													m1 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float m2;
HXDLIN(  21)												int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  21)												if ((this9 == 0)) {
HXLINE(  21)													m2 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float m3;
HXDLIN(  21)												int this10 = (maskPixel & 255);
HXDLIN(  21)												if ((this10 == 0)) {
HXLINE(  21)													m3 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  21)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  21)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  21)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  21)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  21)										if ((col != 0)) {
HXLINE(  21)											int x1 = (dx1 - rectLeft);
HXDLIN(  21)											int y1 = (dy1 - rectTop);
HXDLIN(  21)											int c2 = col;
HXDLIN(  21)											bool _hx_tmp1;
HXDLIN(  21)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  21)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE(  21)												_hx_tmp1 = false;
            											}
HXDLIN(  21)											if (_hx_tmp1) {
HXLINE(  21)												int location;
HXDLIN(  21)												if (undoImage->useVirtualPos) {
HXLINE(  21)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE(  21)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN(  21)												int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  21)												int this12;
HXDLIN(  21)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)													this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            												}
            												else {
HXLINE(  21)													this12 = this11;
            												}
HXDLIN(  21)												Float a1;
HXDLIN(  21)												int this13 = ((this12 >> 24) & 255);
HXDLIN(  21)												if ((this13 == 0)) {
HXLINE(  21)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float r1;
HXDLIN(  21)												int this14 = ((this12 >> 16) & 255);
HXDLIN(  21)												if ((this14 == 0)) {
HXLINE(  21)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float g1;
HXDLIN(  21)												int this15 = ((this12 >> 8) & 255);
HXDLIN(  21)												if ((this15 == 0)) {
HXLINE(  21)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float b11;
HXDLIN(  21)												int this16 = (this12 & 255);
HXDLIN(  21)												if ((this16 == 0)) {
HXLINE(  21)													b11 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float a2;
HXDLIN(  21)												int this17 = ((col >> 24) & 255);
HXDLIN(  21)												if ((this17 == 0)) {
HXLINE(  21)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float r2;
HXDLIN(  21)												int this18 = ((col >> 16) & 255);
HXDLIN(  21)												if ((this18 == 0)) {
HXLINE(  21)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float g2;
HXDLIN(  21)												int this19 = ((col >> 8) & 255);
HXDLIN(  21)												if ((this19 == 0)) {
HXLINE(  21)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float b21;
HXDLIN(  21)												int this20 = (col & 255);
HXDLIN(  21)												if ((this20 == 0)) {
HXLINE(  21)													b21 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  21)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  21)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  21)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  21)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  21)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  21)												{
HXLINE(  21)													int _hx_tmp2;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  21)														_hx_tmp2 = blended;
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE(  21)												::Dynamic this21 = undoImage->image;
HXDLIN(  21)												int index2;
HXDLIN(  21)												if (undoImage->useVirtualPos) {
HXLINE(  21)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE(  21)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN(  21)												int _hx_tmp3;
HXDLIN(  21)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE(  21)													_hx_tmp3 = c2;
            												}
HXDLIN(  21)												::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE(  21)											if (forceClear) {
HXLINE(  21)												::Dynamic this22 = undoImage->image;
HXDLIN(  21)												int x2 = (dx1 - rectLeft);
HXDLIN(  21)												int y2 = (dy1 - rectTop);
HXDLIN(  21)												int index3;
HXDLIN(  21)												if (undoImage->useVirtualPos) {
HXLINE(  21)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE(  21)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN(  21)												::iterMagic::Iimg_obj::set(this22,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  21)				bool found = false;
HXDLIN(  21)				Float s = ((Float)0.);
HXDLIN(  21)				Float t = ((Float)0.);
HXDLIN(  21)				Float sxx = ((Float)0.);
HXDLIN(  21)				Float txx = ((Float)0.);
HXDLIN(  21)				{
HXLINE(  21)					int _g_min = xIter3->start;
HXDLIN(  21)					int _g_max = xIter3->max;
HXDLIN(  21)					while((_g_min < _g_max)){
HXLINE(  21)						_g_min = (_g_min + 1);
HXDLIN(  21)						int x3 = (_g_min - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)						txx = (tx * ( (Float)(x3) ));
HXLINE(  62)						found = false;
HXLINE(  21)						{
HXLINE(  21)							int _g_min1 = yIter3->start;
HXDLIN(  21)							int _g_max1 = yIter3->max;
HXDLIN(  21)							while((_g_min1 < _g_max1)){
HXLINE(  21)								_g_min1 = (_g_min1 + 1);
HXDLIN(  21)								int y3 = (_g_min1 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  21)								bool _hx_tmp4;
HXDLIN(  21)								if (!((s <= 0))) {
HXLINE(  21)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXLINE(  21)									_hx_tmp4 = true;
            								}
HXDLIN(  21)								if (_hx_tmp4) {
HXLINE(  21)									if (found) {
HXLINE(  21)										goto _hx_goto_11;
            									}
            								}
            								else {
HXLINE(  21)									if (((s + t) < A)) {
HXLINE(  21)										{
HXLINE(  21)											int c3 = color;
HXDLIN(  21)											bool _hx_tmp5;
HXDLIN(  21)											if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  21)												_hx_tmp5 = pixelImage->transparent;
            											}
            											else {
HXLINE(  21)												_hx_tmp5 = false;
            											}
HXDLIN(  21)											if (_hx_tmp5) {
HXLINE(  21)												int location1;
HXDLIN(  21)												if (pixelImage->useVirtualPos) {
HXLINE(  21)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  21)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            												}
HXDLIN(  21)												int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN(  21)												int this24;
HXDLIN(  21)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)													this24 = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            												}
            												else {
HXLINE(  21)													this24 = this23;
            												}
HXDLIN(  21)												Float a11;
HXDLIN(  21)												int this25 = ((this24 >> 24) & 255);
HXDLIN(  21)												if ((this25 == 0)) {
HXLINE(  21)													a11 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													a11 = (( (Float)(this25) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float r11;
HXDLIN(  21)												int this26 = ((this24 >> 16) & 255);
HXDLIN(  21)												if ((this26 == 0)) {
HXLINE(  21)													r11 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													r11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float g11;
HXDLIN(  21)												int this27 = ((this24 >> 8) & 255);
HXDLIN(  21)												if ((this27 == 0)) {
HXLINE(  21)													g11 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													g11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float b12;
HXDLIN(  21)												int this28 = (this24 & 255);
HXDLIN(  21)												if ((this28 == 0)) {
HXLINE(  21)													b12 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													b12 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float a21;
HXDLIN(  21)												int this29 = ((color >> 24) & 255);
HXDLIN(  21)												if ((this29 == 0)) {
HXLINE(  21)													a21 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													a21 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float r21;
HXDLIN(  21)												int this30 = ((color >> 16) & 255);
HXDLIN(  21)												if ((this30 == 0)) {
HXLINE(  21)													r21 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													r21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float g21;
HXDLIN(  21)												int this31 = ((color >> 8) & 255);
HXDLIN(  21)												if ((this31 == 0)) {
HXLINE(  21)													g21 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													g21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float b22;
HXDLIN(  21)												int this32 = (color & 255);
HXDLIN(  21)												if ((this32 == 0)) {
HXLINE(  21)													b22 = ((Float)0.);
            												}
            												else {
HXLINE(  21)													b22 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN(  21)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  21)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  21)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  21)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  21)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  21)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  21)												{
HXLINE(  21)													int _hx_tmp6;
HXDLIN(  21)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE(  21)														_hx_tmp6 = blended1;
            													}
HXDLIN(  21)													::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXLINE(  21)												::Dynamic this33 = pixelImage->image;
HXDLIN(  21)												int index4;
HXDLIN(  21)												if (pixelImage->useVirtualPos) {
HXLINE(  21)													index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  21)													index4 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            												}
HXDLIN(  21)												int _hx_tmp7;
HXDLIN(  21)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  21)													_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXLINE(  21)													_hx_tmp7 = c3;
            												}
HXDLIN(  21)												::iterMagic::Iimg_obj::set(this33,index4,_hx_tmp7);
            											}
            										}
HXLINE(  73)										found = true;
            									}
            									else {
HXLINE(  21)										if (found) {
HXLINE(  21)											goto _hx_goto_11;
            										}
            									}
            								}
            							}
            							_hx_goto_11:;
            						}
            					}
            				}
HXDLIN(  21)				if ((hasHit == true)) {
HXLINE(  21)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  21)					if (hasUndo) {
HXLINE(  21)						v2->undoImage = undoImage;
HXDLIN(  21)						v2->undoX = xIter3->start;
HXDLIN(  21)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXLINE(  22)		{
HXLINE(  22)			Float bx2 = cx;
HXDLIN(  22)			Float by2 = cy;
HXDLIN(  22)			Float cx2 = dx;
HXDLIN(  22)			Float cy2 = dy;
HXDLIN(  22)			bool hasUndo1 = false;
HXDLIN(  22)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  22)			if (!(adjustWinding1)) {
HXLINE(  22)				Float bx_1 = bx2;
HXDLIN(  22)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE(  22)			{
HXLINE(  22)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  22)				Float sx1 = (cy2 - by);
HXDLIN(  22)				Float sy1 = (bx - cx2);
HXDLIN(  22)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  22)				Float tx1 = (by - by2);
HXDLIN(  22)				Float ty1 = (bx2 - bx);
HXDLIN(  22)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  22)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  22)				if ((bx > bx2)) {
HXLINE(  22)					if ((bx > cx2)) {
HXLINE(  22)						int min4;
HXDLIN(  22)						if ((bx2 > cx2)) {
HXLINE(  22)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE(  22)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN(  22)						int ii_min8 = min4;
HXDLIN(  22)						int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN(  22)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE(  22)						int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN(  22)						int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  22)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE(  22)					if ((bx2 > cx2)) {
HXLINE(  22)						int min5;
HXDLIN(  22)						if ((bx > cx2)) {
HXLINE(  22)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE(  22)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN(  22)						int ii_min10 = min5;
HXDLIN(  22)						int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN(  22)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE(  22)						int ii_min11 = ::Math_obj::floor(bx);
HXDLIN(  22)						int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  22)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN(  22)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  22)				if ((by > by2)) {
HXLINE(  22)					if ((by > cy2)) {
HXLINE(  22)						int min6;
HXDLIN(  22)						if ((by2 > cy2)) {
HXLINE(  22)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  22)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN(  22)						int ii_min12 = min6;
HXDLIN(  22)						int ii_max12 = ::Math_obj::ceil(by);
HXDLIN(  22)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE(  22)						int ii_min13 = ::Math_obj::floor(by2);
HXDLIN(  22)						int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  22)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE(  22)					if ((by2 > cy2)) {
HXLINE(  22)						int min7;
HXDLIN(  22)						if ((by > cy2)) {
HXLINE(  22)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  22)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN(  22)						int ii_min14 = min7;
HXDLIN(  22)						int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN(  22)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE(  22)						int ii_min15 = ::Math_obj::floor(by);
HXDLIN(  22)						int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  22)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN(  22)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  22)				if (hasUndo1) {
HXLINE(  22)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  22)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  22)					 ::Dynamic imageType1 = null();
HXDLIN(  22)					 ::pi_xy::ImageStruct this34 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  22)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  22)					::Dynamic undoImage4;
HXDLIN(  22)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE(  22)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  22)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  22)							{
HXLINE(  22)								b5->width = width1;
HXDLIN(  22)								b5->height = height1;
HXDLIN(  22)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  22)								{
HXLINE(  22)									int len2 = b5->length;
HXDLIN(  22)									int w1 = 0;
HXDLIN(  22)									{
HXLINE(  22)										int _g20 = 0;
HXDLIN(  22)										int _g21 = b5->height;
HXDLIN(  22)										while((_g20 < _g21)){
HXLINE(  22)											_g20 = (_g20 + 1);
HXDLIN(  22)											int y4 = (_g20 - 1);
HXDLIN(  22)											{
HXLINE(  22)												int _g22 = 0;
HXDLIN(  22)												int _g23 = b5->width;
HXDLIN(  22)												while((_g22 < _g23)){
HXLINE(  22)													_g22 = (_g22 + 1);
HXDLIN(  22)													int x4 = (_g22 - 1);
HXDLIN(  22)													{
HXLINE(  22)														w1 = (w1 + 1);
HXDLIN(  22)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  22)													{
HXLINE(  22)														w1 = (w1 + 1);
HXDLIN(  22)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  22)													{
HXLINE(  22)														w1 = (w1 + 1);
HXDLIN(  22)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  22)													{
HXLINE(  22)														w1 = (w1 + 1);
HXDLIN(  22)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  22)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXLINE(  22)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  22)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  22)							{
HXLINE(  22)								a6->width = width1;
HXDLIN(  22)								a6->height = height1;
HXDLIN(  22)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  22)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)								{
HXLINE(  22)									int _g24 = 0;
HXDLIN(  22)									int _g25 = a6->length;
HXDLIN(  22)									while((_g24 < _g25)){
HXLINE(  22)										_g24 = (_g24 + 1);
HXDLIN(  22)										int i6 = (_g24 - 1);
HXDLIN(  22)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN(  22)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXLINE(  22)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  22)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  22)							{
HXLINE(  22)								b6->width = width1;
HXDLIN(  22)								b6->height = height1;
HXDLIN(  22)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)								int size1 = (b6->length * 4);
HXDLIN(  22)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  22)								{
HXLINE(  22)									int _g26 = 0;
HXDLIN(  22)									int _g27 = b6->length;
HXDLIN(  22)									while((_g26 < _g27)){
HXLINE(  22)										_g26 = (_g26 + 1);
HXDLIN(  22)										int i7 = (_g26 - 1);
HXDLIN(  22)										{
HXLINE(  22)											 ::haxe::io::ArrayBufferViewImpl this35 = b6->data;
HXDLIN(  22)											bool undoImage5;
HXDLIN(  22)											if ((i7 >= 0)) {
HXLINE(  22)												undoImage5 = (i7 < (this35->byteLength >> 2));
            											}
            											else {
HXLINE(  22)												undoImage5 = false;
            											}
HXDLIN(  22)											if (undoImage5) {
HXLINE(  22)												 ::haxe::io::Bytes _this1 = this35->bytes;
HXDLIN(  22)												int pos1 = ((i7 << 2) + this35->byteOffset);
HXDLIN(  22)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  22)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  22)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  22)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  22)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXLINE(  22)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  22)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  22)							{
HXLINE(  22)								v3->width = width1;
HXDLIN(  22)								v3->height = height1;
HXDLIN(  22)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  22)								{
HXLINE(  22)									int _g28 = 0;
HXDLIN(  22)									int _g29 = v3->length;
HXDLIN(  22)									while((_g28 < _g29)){
HXLINE(  22)										_g28 = (_g28 + 1);
HXDLIN(  22)										int i8 = (_g28 - 1);
HXDLIN(  22)										v3->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN(  22)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE(  22)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  22)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  22)							{
HXLINE(  22)								b7->width = width1;
HXDLIN(  22)								b7->height = height1;
HXDLIN(  22)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  22)								{
HXLINE(  22)									int len3 = b7->length;
HXDLIN(  22)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  22)									if (::hx::IsNull( d1->head )) {
HXLINE(  22)										int _g30 = 0;
HXDLIN(  22)										int _g31 = len3;
HXDLIN(  22)										while((_g30 < _g31)){
HXLINE(  22)											_g30 = (_g30 + 1);
HXDLIN(  22)											int i9 = (_g30 - 1);
HXDLIN(  22)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE(  22)										int _g32 = 0;
HXDLIN(  22)										int _g33 = len3;
HXDLIN(  22)										while((_g32 < _g33)){
HXLINE(  22)											_g32 = (_g32 + 1);
HXDLIN(  22)											int i10 = (_g32 - 1);
HXDLIN(  22)											{
HXLINE(  22)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  22)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  22)												{
HXLINE(  22)													int _g34 = 0;
HXDLIN(  22)													int _g35 = i10;
HXDLIN(  22)													while((_g34 < _g35)){
HXLINE(  22)														_g34 = (_g34 + 1);
HXDLIN(  22)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE(  22)												if (::hx::IsNull( prev1 )) {
HXLINE(  22)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  22)													l1 = null();
            												}
            												else {
HXLINE(  22)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  22)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  22)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN(  22)					this34->image = undoImage4;
HXDLIN(  22)					this34->width = width1;
HXDLIN(  22)					this34->height = height1;
HXDLIN(  22)					this34->imageType = ( (int)(imageType1) );
HXDLIN(  22)					undoImage3 = this34;
HXDLIN(  22)					{
HXLINE(  22)						int rectLeft1 = xIter31->start;
HXDLIN(  22)						int rectTop1 = yIter31->start;
HXDLIN(  22)						int rectRight1 = xIter31->max;
HXDLIN(  22)						bool forceClear1 = false;
HXDLIN(  22)						{
HXLINE(  22)							int _g36 = rectTop1;
HXDLIN(  22)							int _g37 = yIter31->max;
HXDLIN(  22)							while((_g36 < _g37)){
HXLINE(  22)								_g36 = (_g36 + 1);
HXDLIN(  22)								int dy2 = (_g36 - 1);
HXDLIN(  22)								{
HXLINE(  22)									int _g38 = rectLeft1;
HXDLIN(  22)									int _g39 = rectRight1;
HXDLIN(  22)									while((_g38 < _g39)){
HXLINE(  22)										_g38 = (_g38 + 1);
HXDLIN(  22)										int dx2 = (_g38 - 1);
HXDLIN(  22)										::Dynamic this36 = pixelImage->image;
HXDLIN(  22)										int index5;
HXDLIN(  22)										if (pixelImage->useVirtualPos) {
HXLINE(  22)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  22)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN(  22)										int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN(  22)										int col1;
HXDLIN(  22)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)											col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE(  22)											col1 = c4;
            										}
HXDLIN(  22)										bool _hx_tmp8;
HXDLIN(  22)										if (pixelImage->useMask) {
HXLINE(  22)											_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE(  22)											_hx_tmp8 = false;
            										}
HXDLIN(  22)										if (_hx_tmp8) {
HXLINE(  22)											 ::pi_xy::ImageStruct this37 = pixelImage->mask;
HXDLIN(  22)											::Dynamic this38 = this37->image;
HXDLIN(  22)											int index6;
HXDLIN(  22)											if (this37->useVirtualPos) {
HXLINE(  22)												index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx2) - this37->virtualX));
            											}
            											else {
HXLINE(  22)												index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this37->width) + dx2)) ));
            											}
HXDLIN(  22)											int c5 = ::iterMagic::Iimg_obj::get(this38,index6);
HXDLIN(  22)											int v4;
HXDLIN(  22)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)												v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE(  22)												v4 = c5;
            											}
HXDLIN(  22)											int maskPixel1 = v4;
HXDLIN(  22)											int this39 = col1;
HXDLIN(  22)											if ((maskPixel1 == 0)) {
HXLINE(  22)												col1 = this39;
            											}
            											else {
HXLINE(  22)												Float m01;
HXDLIN(  22)												int this40 = ((maskPixel1 >> 24) & 255);
HXDLIN(  22)												if ((this40 == 0)) {
HXLINE(  22)													m01 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													m01 = (( (Float)(this40) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float m11;
HXDLIN(  22)												int this41 = ((maskPixel1 >> 16) & 255);
HXDLIN(  22)												if ((this41 == 0)) {
HXLINE(  22)													m11 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													m11 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float m21;
HXDLIN(  22)												int this42 = ((maskPixel1 >> 8) & 255);
HXDLIN(  22)												if ((this42 == 0)) {
HXLINE(  22)													m21 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													m21 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float m31;
HXDLIN(  22)												int this43 = (maskPixel1 & 255);
HXDLIN(  22)												if ((this43 == 0)) {
HXLINE(  22)													m31 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													m31 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this39 >> 24) & 255)) )));
HXDLIN(  22)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this39 >> 16) & 255)) )));
HXDLIN(  22)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this39 >> 8) & 255)) )));
HXDLIN(  22)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this39 & 255)) )));
HXDLIN(  22)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  22)										if ((col1 != 0)) {
HXLINE(  22)											int x5 = (dx2 - rectLeft1);
HXDLIN(  22)											int y5 = (dy2 - rectTop1);
HXDLIN(  22)											int c6 = col1;
HXDLIN(  22)											bool _hx_tmp9;
HXDLIN(  22)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  22)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXLINE(  22)												_hx_tmp9 = false;
            											}
HXDLIN(  22)											if (_hx_tmp9) {
HXLINE(  22)												int location2;
HXDLIN(  22)												if (undoImage3->useVirtualPos) {
HXLINE(  22)													location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  22)													location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN(  22)												int this44 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  22)												int this45;
HXDLIN(  22)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)													this45 = ((((((this44 >> 24) & 255) << 24) | ((this44 & 255) << 16)) | (((this44 >> 8) & 255) << 8)) | ((this44 >> 16) & 255));
            												}
            												else {
HXLINE(  22)													this45 = this44;
            												}
HXDLIN(  22)												Float a12;
HXDLIN(  22)												int this46 = ((this45 >> 24) & 255);
HXDLIN(  22)												if ((this46 == 0)) {
HXLINE(  22)													a12 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													a12 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float r12;
HXDLIN(  22)												int this47 = ((this45 >> 16) & 255);
HXDLIN(  22)												if ((this47 == 0)) {
HXLINE(  22)													r12 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													r12 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float g12;
HXDLIN(  22)												int this48 = ((this45 >> 8) & 255);
HXDLIN(  22)												if ((this48 == 0)) {
HXLINE(  22)													g12 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													g12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float b13;
HXDLIN(  22)												int this49 = (this45 & 255);
HXDLIN(  22)												if ((this49 == 0)) {
HXLINE(  22)													b13 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													b13 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float a22;
HXDLIN(  22)												int this50 = ((col1 >> 24) & 255);
HXDLIN(  22)												if ((this50 == 0)) {
HXLINE(  22)													a22 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													a22 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float r22;
HXDLIN(  22)												int this51 = ((col1 >> 16) & 255);
HXDLIN(  22)												if ((this51 == 0)) {
HXLINE(  22)													r22 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													r22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float g22;
HXDLIN(  22)												int this52 = ((col1 >> 8) & 255);
HXDLIN(  22)												if ((this52 == 0)) {
HXLINE(  22)													g22 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													g22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float b23;
HXDLIN(  22)												int this53 = (col1 & 255);
HXDLIN(  22)												if ((this53 == 0)) {
HXLINE(  22)													b23 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													b23 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  22)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  22)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  22)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  22)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  22)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  22)												{
HXLINE(  22)													int _hx_tmp10;
HXDLIN(  22)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE(  22)														_hx_tmp10 = blended2;
            													}
HXDLIN(  22)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXLINE(  22)												::Dynamic this54 = undoImage3->image;
HXDLIN(  22)												int index7;
HXDLIN(  22)												if (undoImage3->useVirtualPos) {
HXLINE(  22)													index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  22)													index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN(  22)												int _hx_tmp11;
HXDLIN(  22)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)													_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE(  22)													_hx_tmp11 = c6;
            												}
HXDLIN(  22)												::iterMagic::Iimg_obj::set(this54,index7,_hx_tmp11);
            											}
            										}
            										else {
HXLINE(  22)											if (forceClear1) {
HXLINE(  22)												::Dynamic this55 = undoImage3->image;
HXDLIN(  22)												int x6 = (dx2 - rectLeft1);
HXDLIN(  22)												int y6 = (dy2 - rectTop1);
HXDLIN(  22)												int index8;
HXDLIN(  22)												if (undoImage3->useVirtualPos) {
HXLINE(  22)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  22)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN(  22)												::iterMagic::Iimg_obj::set(this55,index8,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  22)				bool found1 = false;
HXDLIN(  22)				Float s1 = ((Float)0.);
HXDLIN(  22)				Float t1 = ((Float)0.);
HXDLIN(  22)				Float sxx1 = ((Float)0.);
HXDLIN(  22)				Float txx1 = ((Float)0.);
HXDLIN(  22)				{
HXLINE(  22)					int _g_min2 = xIter31->start;
HXDLIN(  22)					int _g_max2 = xIter31->max;
HXDLIN(  22)					while((_g_min2 < _g_max2)){
HXLINE(  22)						_g_min2 = (_g_min2 + 1);
HXDLIN(  22)						int x7 = (_g_min2 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)						found1 = false;
HXLINE(  22)						{
HXLINE(  22)							int _g_min3 = yIter31->start;
HXDLIN(  22)							int _g_max3 = yIter31->max;
HXDLIN(  22)							while((_g_min3 < _g_max3)){
HXLINE(  22)								_g_min3 = (_g_min3 + 1);
HXDLIN(  22)								int y7 = (_g_min3 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  22)								bool _hx_tmp12;
HXDLIN(  22)								if (!((s1 <= 0))) {
HXLINE(  22)									_hx_tmp12 = (t1 <= 0);
            								}
            								else {
HXLINE(  22)									_hx_tmp12 = true;
            								}
HXDLIN(  22)								if (_hx_tmp12) {
HXLINE(  22)									if (found1) {
HXLINE(  22)										goto _hx_goto_23;
            									}
            								}
            								else {
HXLINE(  22)									if (((s1 + t1) < A1)) {
HXLINE(  22)										{
HXLINE(  22)											int c7 = color;
HXDLIN(  22)											bool _hx_tmp13;
HXDLIN(  22)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  22)												_hx_tmp13 = pixelImage->transparent;
            											}
            											else {
HXLINE(  22)												_hx_tmp13 = false;
            											}
HXDLIN(  22)											if (_hx_tmp13) {
HXLINE(  22)												int location3;
HXDLIN(  22)												if (pixelImage->useVirtualPos) {
HXLINE(  22)													location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x7) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  22)													location3 = ::Std_obj::_hx_int(( (Float)(((y7 * pixelImage->width) + x7)) ));
            												}
HXDLIN(  22)												int this56 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN(  22)												int this57;
HXDLIN(  22)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)													this57 = ((((((this56 >> 24) & 255) << 24) | ((this56 & 255) << 16)) | (((this56 >> 8) & 255) << 8)) | ((this56 >> 16) & 255));
            												}
            												else {
HXLINE(  22)													this57 = this56;
            												}
HXDLIN(  22)												Float a13;
HXDLIN(  22)												int this58 = ((this57 >> 24) & 255);
HXDLIN(  22)												if ((this58 == 0)) {
HXLINE(  22)													a13 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													a13 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float r13;
HXDLIN(  22)												int this59 = ((this57 >> 16) & 255);
HXDLIN(  22)												if ((this59 == 0)) {
HXLINE(  22)													r13 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													r13 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float g13;
HXDLIN(  22)												int this60 = ((this57 >> 8) & 255);
HXDLIN(  22)												if ((this60 == 0)) {
HXLINE(  22)													g13 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													g13 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float b14;
HXDLIN(  22)												int this61 = (this57 & 255);
HXDLIN(  22)												if ((this61 == 0)) {
HXLINE(  22)													b14 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													b14 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float a23;
HXDLIN(  22)												int this62 = ((color >> 24) & 255);
HXDLIN(  22)												if ((this62 == 0)) {
HXLINE(  22)													a23 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													a23 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float r23;
HXDLIN(  22)												int this63 = ((color >> 16) & 255);
HXDLIN(  22)												if ((this63 == 0)) {
HXLINE(  22)													r23 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													r23 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float g23;
HXDLIN(  22)												int this64 = ((color >> 8) & 255);
HXDLIN(  22)												if ((this64 == 0)) {
HXLINE(  22)													g23 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													g23 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float b24;
HXDLIN(  22)												int this65 = (color & 255);
HXDLIN(  22)												if ((this65 == 0)) {
HXLINE(  22)													b24 = ((Float)0.);
            												}
            												else {
HXLINE(  22)													b24 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  22)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  22)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  22)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  22)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  22)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  22)												int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  22)												{
HXLINE(  22)													int _hx_tmp14;
HXDLIN(  22)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE(  22)														_hx_tmp14 = blended3;
            													}
HXDLIN(  22)													::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXLINE(  22)												::Dynamic this66 = pixelImage->image;
HXDLIN(  22)												int index9;
HXDLIN(  22)												if (pixelImage->useVirtualPos) {
HXLINE(  22)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x7) - pixelImage->virtualX));
            												}
            												else {
HXLINE(  22)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * pixelImage->width) + x7)) ));
            												}
HXDLIN(  22)												int _hx_tmp15;
HXDLIN(  22)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)													_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE(  22)													_hx_tmp15 = c7;
            												}
HXDLIN(  22)												::iterMagic::Iimg_obj::set(this66,index9,_hx_tmp15);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXLINE(  22)										if (found1) {
HXLINE(  22)											goto _hx_goto_23;
            										}
            									}
            								}
            							}
            							_hx_goto_23:;
            						}
            					}
            				}
HXDLIN(  22)				if ((hasHit == true)) {
HXLINE(  22)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  22)					if (hasUndo1) {
HXLINE(  22)						v5->undoImage = undoImage3;
HXDLIN(  22)						v5->undoX = xIter31->start;
HXDLIN(  22)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXLINE(  28)		if ((hasHit == true)) {
HXLINE(  29)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE(  30)			return v6;
            		}
            		else {
HXLINE(  32)			return null();
            		}
HXLINE(  28)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(QuadPixel_Fields__obj,fillQuadrilateral,return )

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::fillSoftQuadrilateral( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,int color,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCD,::hx::Null< bool >  __o_softDA,::hx::Null< bool >  __o_hasHit){
            		Float soft = __o_soft.Default(40);
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCD = __o_softCD.Default(true);
            		bool softDA = __o_softDA.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_48_fillSoftQuadrilateral)
HXLINE(  51)		{
HXLINE(  51)			bool hasUndo = true;
HXDLIN(  51)			int aA = ((color >> 24) & 255);
HXDLIN(  51)			int rA = ((color >> 16) & 255);
HXDLIN(  51)			int gA = ((color >> 8) & 255);
HXDLIN(  51)			int bA = (color & 255);
HXDLIN(  51)			Float bcx = (bx - dx);
HXDLIN(  51)			Float bcy = (by - dy);
HXDLIN(  51)			Float acx = (ax - dx);
HXDLIN(  51)			Float acy = (ay - dy);
HXDLIN(  51)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  51)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  51)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  51)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  51)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  51)			if ((ax > bx)) {
HXLINE(  51)				if ((ax > dx)) {
HXLINE(  51)					int min;
HXDLIN(  51)					if ((bx > dx)) {
HXLINE(  51)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  51)						min = ::Math_obj::floor(bx);
            					}
HXDLIN(  51)					int ii_min = min;
HXDLIN(  51)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  51)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE(  51)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  51)					int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN(  51)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE(  51)				if ((bx > dx)) {
HXLINE(  51)					int min1;
HXDLIN(  51)					if ((ax > dx)) {
HXLINE(  51)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  51)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN(  51)					int ii_min2 = min1;
HXDLIN(  51)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  51)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE(  51)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  51)					int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN(  51)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN(  51)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  51)			if ((ay > by)) {
HXLINE(  51)				if ((ay > dy)) {
HXLINE(  51)					int min2;
HXDLIN(  51)					if ((by > dy)) {
HXLINE(  51)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  51)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN(  51)					int ii_min4 = min2;
HXDLIN(  51)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  51)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE(  51)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  51)					int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN(  51)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE(  51)				if ((by > dy)) {
HXLINE(  51)					int min3;
HXDLIN(  51)					if ((ay > dy)) {
HXLINE(  51)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  51)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN(  51)					int ii_min6 = min3;
HXDLIN(  51)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  51)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE(  51)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  51)					int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN(  51)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN(  51)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  51)			if (hasUndo) {
HXLINE(  51)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  51)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  51)				 ::Dynamic imageType = null();
HXDLIN(  51)				 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  51)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  51)				::Dynamic undoImage1;
HXDLIN(  51)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE(  51)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  51)						 ::iterMagic::BytesImg b = byt;
HXDLIN(  51)						{
HXLINE(  51)							b->width = width;
HXDLIN(  51)							b->height = height;
HXDLIN(  51)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  51)							{
HXLINE(  51)								int len = b->length;
HXDLIN(  51)								int w = 0;
HXDLIN(  51)								{
HXLINE(  51)									int _g = 0;
HXDLIN(  51)									int _g1 = b->height;
HXDLIN(  51)									while((_g < _g1)){
HXLINE(  51)										_g = (_g + 1);
HXDLIN(  51)										int y = (_g - 1);
HXDLIN(  51)										{
HXLINE(  51)											int _g2 = 0;
HXDLIN(  51)											int _g3 = b->width;
HXDLIN(  51)											while((_g2 < _g3)){
HXLINE(  51)												_g2 = (_g2 + 1);
HXDLIN(  51)												int x = (_g2 - 1);
HXDLIN(  51)												{
HXLINE(  51)													w = (w + 1);
HXDLIN(  51)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  51)												{
HXLINE(  51)													w = (w + 1);
HXDLIN(  51)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  51)												{
HXLINE(  51)													w = (w + 1);
HXDLIN(  51)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  51)												{
HXLINE(  51)													w = (w + 1);
HXDLIN(  51)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  51)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE(  51)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  51)						{
HXLINE(  51)							a->width = width;
HXDLIN(  51)							a->height = height;
HXDLIN(  51)							a->data = ::Array_obj< int >::__new(0);
HXDLIN(  51)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)							{
HXLINE(  51)								int _g4 = 0;
HXDLIN(  51)								int _g5 = a->length;
HXDLIN(  51)								while((_g4 < _g5)){
HXLINE(  51)									_g4 = (_g4 + 1);
HXDLIN(  51)									int i = (_g4 - 1);
HXDLIN(  51)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN(  51)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE(  51)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  51)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  51)						{
HXLINE(  51)							b1->width = width;
HXDLIN(  51)							b1->height = height;
HXDLIN(  51)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)							int size = (b1->length * 4);
HXDLIN(  51)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  51)							{
HXLINE(  51)								int _g6 = 0;
HXDLIN(  51)								int _g7 = b1->length;
HXDLIN(  51)								while((_g6 < _g7)){
HXLINE(  51)									_g6 = (_g6 + 1);
HXDLIN(  51)									int i1 = (_g6 - 1);
HXDLIN(  51)									{
HXLINE(  51)										 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  51)										bool undoImage2;
HXDLIN(  51)										if ((i1 >= 0)) {
HXLINE(  51)											undoImage2 = (i1 < (this2->byteLength >> 2));
            										}
            										else {
HXLINE(  51)											undoImage2 = false;
            										}
HXDLIN(  51)										if (undoImage2) {
HXLINE(  51)											 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  51)											int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  51)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  51)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  51)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  51)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  51)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE(  51)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)						 ::iterMagic::VecIntImg v = vec;
HXDLIN(  51)						{
HXLINE(  51)							v->width = width;
HXDLIN(  51)							v->height = height;
HXDLIN(  51)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  51)							{
HXLINE(  51)								int _g8 = 0;
HXDLIN(  51)								int _g9 = v->length;
HXDLIN(  51)								while((_g8 < _g9)){
HXLINE(  51)									_g8 = (_g8 + 1);
HXDLIN(  51)									int i2 = (_g8 - 1);
HXDLIN(  51)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN(  51)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE(  51)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  51)						{
HXLINE(  51)							b2->width = width;
HXDLIN(  51)							b2->height = height;
HXDLIN(  51)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  51)							{
HXLINE(  51)								int len1 = b2->length;
HXDLIN(  51)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  51)								if (::hx::IsNull( d->head )) {
HXLINE(  51)									int _g10 = 0;
HXDLIN(  51)									int _g11 = len1;
HXDLIN(  51)									while((_g10 < _g11)){
HXLINE(  51)										_g10 = (_g10 + 1);
HXDLIN(  51)										int i3 = (_g10 - 1);
HXDLIN(  51)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE(  51)									int _g12 = 0;
HXDLIN(  51)									int _g13 = len1;
HXDLIN(  51)									while((_g12 < _g13)){
HXLINE(  51)										_g12 = (_g12 + 1);
HXDLIN(  51)										int i4 = (_g12 - 1);
HXDLIN(  51)										{
HXLINE(  51)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  51)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  51)											{
HXLINE(  51)												int _g14 = 0;
HXDLIN(  51)												int _g15 = i4;
HXDLIN(  51)												while((_g14 < _g15)){
HXLINE(  51)													_g14 = (_g14 + 1);
HXDLIN(  51)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE(  51)											if (::hx::IsNull( prev )) {
HXLINE(  51)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  51)												l = null();
            											}
            											else {
HXLINE(  51)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  51)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  51)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN(  51)				this1->image = undoImage1;
HXDLIN(  51)				this1->width = width;
HXDLIN(  51)				this1->height = height;
HXDLIN(  51)				this1->imageType = ( (int)(imageType) );
HXDLIN(  51)				undoImage = this1;
HXDLIN(  51)				{
HXLINE(  51)					int rectLeft = xIter3->start;
HXDLIN(  51)					int rectTop = yIter3->start;
HXDLIN(  51)					int rectRight = xIter3->max;
HXDLIN(  51)					bool forceClear = false;
HXDLIN(  51)					{
HXLINE(  51)						int _g16 = rectTop;
HXDLIN(  51)						int _g17 = yIter3->max;
HXDLIN(  51)						while((_g16 < _g17)){
HXLINE(  51)							_g16 = (_g16 + 1);
HXDLIN(  51)							int dy1 = (_g16 - 1);
HXDLIN(  51)							{
HXLINE(  51)								int _g18 = rectLeft;
HXDLIN(  51)								int _g19 = rectRight;
HXDLIN(  51)								while((_g18 < _g19)){
HXLINE(  51)									_g18 = (_g18 + 1);
HXDLIN(  51)									int dx1 = (_g18 - 1);
HXDLIN(  51)									::Dynamic this3 = pixelImage->image;
HXDLIN(  51)									int index;
HXDLIN(  51)									if (pixelImage->useVirtualPos) {
HXLINE(  51)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  51)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN(  51)									int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  51)									int col;
HXDLIN(  51)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  51)										col = c;
            									}
HXDLIN(  51)									bool _hx_tmp;
HXDLIN(  51)									if (pixelImage->useMask) {
HXLINE(  51)										_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE(  51)										_hx_tmp = false;
            									}
HXDLIN(  51)									if (_hx_tmp) {
HXLINE(  51)										 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN(  51)										::Dynamic this5 = this4->image;
HXDLIN(  51)										int index1;
HXDLIN(  51)										if (this4->useVirtualPos) {
HXLINE(  51)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXLINE(  51)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN(  51)										int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  51)										int v1;
HXDLIN(  51)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE(  51)											v1 = c1;
            										}
HXDLIN(  51)										int maskPixel = v1;
HXDLIN(  51)										int this6 = col;
HXDLIN(  51)										if ((maskPixel == 0)) {
HXLINE(  51)											col = this6;
            										}
            										else {
HXLINE(  51)											Float m0;
HXDLIN(  51)											int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  51)											if ((this7 == 0)) {
HXLINE(  51)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float m1;
HXDLIN(  51)											int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  51)											if ((this8 == 0)) {
HXLINE(  51)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float m2;
HXDLIN(  51)											int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  51)											if ((this9 == 0)) {
HXLINE(  51)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float m3;
HXDLIN(  51)											int this10 = (maskPixel & 255);
HXDLIN(  51)											if ((this10 == 0)) {
HXLINE(  51)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  51)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  51)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  51)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  51)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  51)									if ((col != 0)) {
HXLINE(  51)										int x1 = (dx1 - rectLeft);
HXDLIN(  51)										int y1 = (dy1 - rectTop);
HXDLIN(  51)										int c2 = col;
HXDLIN(  51)										bool _hx_tmp1;
HXDLIN(  51)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  51)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXLINE(  51)											_hx_tmp1 = false;
            										}
HXDLIN(  51)										if (_hx_tmp1) {
HXLINE(  51)											int location;
HXDLIN(  51)											if (undoImage->useVirtualPos) {
HXLINE(  51)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE(  51)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN(  51)											int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  51)											int this12;
HXDLIN(  51)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)												this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            											}
            											else {
HXLINE(  51)												this12 = this11;
            											}
HXDLIN(  51)											Float a1;
HXDLIN(  51)											int this13 = ((this12 >> 24) & 255);
HXDLIN(  51)											if ((this13 == 0)) {
HXLINE(  51)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float r1;
HXDLIN(  51)											int this14 = ((this12 >> 16) & 255);
HXDLIN(  51)											if ((this14 == 0)) {
HXLINE(  51)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float g1;
HXDLIN(  51)											int this15 = ((this12 >> 8) & 255);
HXDLIN(  51)											if ((this15 == 0)) {
HXLINE(  51)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float b11;
HXDLIN(  51)											int this16 = (this12 & 255);
HXDLIN(  51)											if ((this16 == 0)) {
HXLINE(  51)												b11 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float a2;
HXDLIN(  51)											int this17 = ((col >> 24) & 255);
HXDLIN(  51)											if ((this17 == 0)) {
HXLINE(  51)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float r2;
HXDLIN(  51)											int this18 = ((col >> 16) & 255);
HXDLIN(  51)											if ((this18 == 0)) {
HXLINE(  51)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float g2;
HXDLIN(  51)											int this19 = ((col >> 8) & 255);
HXDLIN(  51)											if ((this19 == 0)) {
HXLINE(  51)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float b21;
HXDLIN(  51)											int this20 = (col & 255);
HXDLIN(  51)											if ((this20 == 0)) {
HXLINE(  51)												b21 = ((Float)0.);
            											}
            											else {
HXLINE(  51)												b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN(  51)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  51)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  51)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  51)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  51)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  51)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  51)											{
HXLINE(  51)												int _hx_tmp2;
HXDLIN(  51)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  51)													_hx_tmp2 = blended;
            												}
HXDLIN(  51)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXLINE(  51)											::Dynamic this21 = undoImage->image;
HXDLIN(  51)											int index2;
HXDLIN(  51)											if (undoImage->useVirtualPos) {
HXLINE(  51)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE(  51)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN(  51)											int _hx_tmp3;
HXDLIN(  51)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE(  51)												_hx_tmp3 = c2;
            											}
HXDLIN(  51)											::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            										}
            									}
            									else {
HXLINE(  51)										if (forceClear) {
HXLINE(  51)											::Dynamic this22 = undoImage->image;
HXDLIN(  51)											int x2 = (dx1 - rectLeft);
HXDLIN(  51)											int y2 = (dy1 - rectTop);
HXDLIN(  51)											int index3;
HXDLIN(  51)											if (undoImage->useVirtualPos) {
HXLINE(  51)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE(  51)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN(  51)											::iterMagic::Iimg_obj::set(this22,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  51)			bool found = false;
HXDLIN(  51)			Float min4 = ( (Float)(0) );
HXDLIN(  51)			Float max = ( (Float)(0) );
HXDLIN(  51)			int a5 = 0;
HXDLIN(  51)			int r3 = 0;
HXDLIN(  51)			int g3 = 0;
HXDLIN(  51)			int b4 = 0;
HXDLIN(  51)			{
HXLINE(  51)				int _g_min = xIter3->start;
HXDLIN(  51)				int _g_max = xIter3->max;
HXDLIN(  51)				while((_g_min < _g_max)){
HXLINE(  51)					_g_min = (_g_min + 1);
HXDLIN(  51)					int px = (_g_min - 1);
HXDLIN(  51)					Float pcx = (( (Float)(px) ) - dx);
HXLINE( 695)					found = false;
HXLINE(  51)					{
HXLINE(  51)						int _g_min1 = yIter3->start;
HXDLIN(  51)						int _g_max1 = yIter3->max;
HXDLIN(  51)						while((_g_min1 < _g_max1)){
HXLINE(  51)							_g_min1 = (_g_min1 + 1);
HXDLIN(  51)							int py = (_g_min1 - 1);
HXDLIN(  51)							Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  51)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  51)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  51)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  51)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  51)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  51)							bool _hx_tmp4;
HXDLIN(  51)							bool _hx_tmp5;
HXDLIN(  51)							if ((ratioA >= 0)) {
HXLINE(  51)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXLINE(  51)								_hx_tmp5 = false;
            							}
HXDLIN(  51)							if (_hx_tmp5) {
HXLINE(  51)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXLINE(  51)								_hx_tmp4 = false;
            							}
HXDLIN(  51)							if (_hx_tmp4) {
HXLINE(  51)								if (softAB) {
HXLINE(  51)									if (softDA) {
HXLINE(  51)										if ((ratioA < ratioC)) {
HXLINE(  51)											min4 = ratioA;
            										}
            										else {
HXLINE(  51)											min4 = ratioC;
            										}
HXDLIN(  51)										if ((ratioA > ratioB)) {
HXLINE(  51)											max = ratioA;
            										}
            										else {
HXLINE(  51)											max = ratioB;
            										}
HXDLIN(  51)										if (!((max > ratioC))) {
HXLINE(  51)											max = ratioC;
            										}
HXLINE( 728)										max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  51)										if (!((min4 < max))) {
HXLINE(  51)											min4 = ((max + min4) / ( (Float)(2) ));
            										}
HXDLIN(  51)										int i6 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN(  51)										if ((i6 > 255)) {
HXLINE(  24)											i6 = 255;
            										}
HXLINE(  51)										if ((i6 < 0)) {
HXLINE(  25)											i6 = 0;
            										}
HXLINE(  51)										a5 = i6;
            									}
            									else {
HXLINE( 722)										min4 = ratioC;
HXLINE(  51)										int i7 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN(  51)										if ((i7 > 255)) {
HXLINE(  24)											i7 = 255;
            										}
HXLINE(  51)										if ((i7 < 0)) {
HXLINE(  25)											i7 = 0;
            										}
HXLINE(  51)										a5 = i7;
            									}
            								}
            								else {
HXLINE(  51)									if (softDA) {
HXLINE( 709)										min4 = ratioA;
HXLINE(  51)										int i8 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN(  51)										if ((i8 > 255)) {
HXLINE(  24)											i8 = 255;
            										}
HXLINE(  51)										if ((i8 < 0)) {
HXLINE(  25)											i8 = 0;
            										}
HXLINE(  51)										a5 = i8;
            									}
            									else {
HXLINE(  51)										int i9 = ::Std_obj::_hx_int(( (Float)(aA) ));
HXDLIN(  51)										if ((i9 > 255)) {
HXLINE(  24)											i9 = 255;
            										}
HXLINE(  51)										if ((i9 < 0)) {
HXLINE(  25)											i9 = 0;
            										}
HXLINE(  51)										a5 = i9;
            									}
            								}
HXDLIN(  51)								int i10 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  51)								if ((i10 > 255)) {
HXLINE(  24)									i10 = 255;
            								}
HXLINE(  51)								if ((i10 < 0)) {
HXLINE(  25)									i10 = 0;
            								}
HXLINE( 747)								r3 = i10;
HXLINE(  51)								int i11 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  51)								if ((i11 > 255)) {
HXLINE(  24)									i11 = 255;
            								}
HXLINE(  51)								if ((i11 < 0)) {
HXLINE(  25)									i11 = 0;
            								}
HXLINE( 748)								g3 = i11;
HXLINE(  51)								int i12 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  51)								if ((i12 > 255)) {
HXLINE(  24)									i12 = 255;
            								}
HXLINE(  51)								if ((i12 < 0)) {
HXLINE(  25)									i12 = 0;
            								}
HXLINE( 749)								b4 = i12;
HXLINE(  51)								{
HXLINE(  51)									int location1;
HXDLIN(  51)									if (pixelImage->useVirtualPos) {
HXLINE(  51)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  51)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN(  51)									bool _hx_tmp6;
HXDLIN(  51)									if (pixelImage->transparent) {
HXLINE(  51)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXLINE(  51)										_hx_tmp6 = false;
            									}
HXDLIN(  51)									if (_hx_tmp6) {
HXLINE(  51)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN(  51)										int old;
HXDLIN(  51)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)											old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE(  51)											old = this23;
            										}
HXDLIN(  51)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  51)										Float a11;
HXDLIN(  51)										int this24 = ((old >> 24) & 255);
HXDLIN(  51)										if ((this24 == 0)) {
HXLINE(  51)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(  51)											a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN(  51)										Float r11;
HXDLIN(  51)										int this25 = ((old >> 16) & 255);
HXDLIN(  51)										if ((this25 == 0)) {
HXLINE(  51)											r11 = ((Float)0.);
            										}
            										else {
HXLINE(  51)											r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN(  51)										Float g11;
HXDLIN(  51)										int this26 = ((old >> 8) & 255);
HXDLIN(  51)										if ((this26 == 0)) {
HXLINE(  51)											g11 = ((Float)0.);
            										}
            										else {
HXLINE(  51)											g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN(  51)										Float b12;
HXDLIN(  51)										int this27 = (old & 255);
HXDLIN(  51)										if ((this27 == 0)) {
HXLINE(  51)											b12 = ((Float)0.);
            										}
            										else {
HXLINE(  51)											b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  51)										Float a21;
HXDLIN(  51)										int this28 = ((rhs >> 24) & 255);
HXDLIN(  51)										if ((this28 == 0)) {
HXLINE(  51)											a21 = ((Float)0.);
            										}
            										else {
HXLINE(  51)											a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  51)										Float r21;
HXDLIN(  51)										int this29 = ((rhs >> 16) & 255);
HXDLIN(  51)										if ((this29 == 0)) {
HXLINE(  51)											r21 = ((Float)0.);
            										}
            										else {
HXLINE(  51)											r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  51)										Float g21;
HXDLIN(  51)										int this30 = ((rhs >> 8) & 255);
HXDLIN(  51)										if ((this30 == 0)) {
HXLINE(  51)											g21 = ((Float)0.);
            										}
            										else {
HXLINE(  51)											g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  51)										Float b22;
HXDLIN(  51)										int this31 = (rhs & 255);
HXDLIN(  51)										if ((this31 == 0)) {
HXLINE(  51)											b22 = ((Float)0.);
            										}
            										else {
HXLINE(  51)											b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  51)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  51)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  51)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  51)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  51)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  51)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  51)										{
HXLINE(  51)											int _hx_tmp7;
HXDLIN(  51)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE(  51)												_hx_tmp7 = blended1;
            											}
HXDLIN(  51)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXLINE(  51)										int value;
HXDLIN(  51)										if (pixelImage->isLittle) {
HXLINE(  51)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXLINE(  51)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN(  51)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            									}
            								}
HXLINE( 751)								found = true;
            							}
            							else {
HXLINE(  51)								if (found) {
HXLINE(  51)									goto _hx_goto_36;
            								}
            							}
            						}
            						_hx_goto_36:;
            					}
            				}
            			}
HXDLIN(  51)			if ((hasHit == false)) {
HXLINE(  51)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  51)				if (hasUndo) {
HXLINE(  51)					v2->undoImage = undoImage;
HXDLIN(  51)					v2->undoX = xIter3->start;
HXDLIN(  51)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXLINE(  52)		{
HXLINE(  52)			bool hasUndo1 = true;
HXDLIN(  52)			int aA1 = ((color >> 24) & 255);
HXDLIN(  52)			int rA1 = ((color >> 16) & 255);
HXDLIN(  52)			int gA1 = ((color >> 8) & 255);
HXDLIN(  52)			int bA1 = (color & 255);
HXDLIN(  52)			Float bcx1 = (cx - dx);
HXDLIN(  52)			Float bcy1 = (cy - dy);
HXDLIN(  52)			Float acx1 = (bx - dx);
HXDLIN(  52)			Float acy1 = (by - dy);
HXDLIN(  52)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  52)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  52)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  52)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  52)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  52)			if ((bx > cx)) {
HXLINE(  52)				if ((bx > dx)) {
HXLINE(  52)					int min5;
HXDLIN(  52)					if ((cx > dx)) {
HXLINE(  52)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  52)						min5 = ::Math_obj::floor(cx);
            					}
HXDLIN(  52)					int ii_min8 = min5;
HXDLIN(  52)					int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN(  52)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE(  52)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN(  52)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN(  52)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE(  52)				if ((cx > dx)) {
HXLINE(  52)					int min6;
HXDLIN(  52)					if ((bx > dx)) {
HXLINE(  52)						min6 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE(  52)						min6 = ::Math_obj::ceil(bx);
            					}
HXDLIN(  52)					int ii_min10 = min6;
HXDLIN(  52)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN(  52)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE(  52)					int ii_min11 = ::Math_obj::floor(bx);
HXDLIN(  52)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN(  52)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN(  52)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  52)			if ((by > cy)) {
HXLINE(  52)				if ((by > dy)) {
HXLINE(  52)					int min7;
HXDLIN(  52)					if ((cy > dy)) {
HXLINE(  52)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  52)						min7 = ::Math_obj::floor(cy);
            					}
HXDLIN(  52)					int ii_min12 = min7;
HXDLIN(  52)					int ii_max12 = ::Math_obj::ceil(by);
HXDLIN(  52)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE(  52)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN(  52)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN(  52)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE(  52)				if ((cy > dy)) {
HXLINE(  52)					int min8;
HXDLIN(  52)					if ((by > dy)) {
HXLINE(  52)						min8 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE(  52)						min8 = ::Math_obj::ceil(by);
            					}
HXDLIN(  52)					int ii_min14 = min8;
HXDLIN(  52)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN(  52)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE(  52)					int ii_min15 = ::Math_obj::floor(by);
HXDLIN(  52)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN(  52)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN(  52)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  52)			if (hasUndo1) {
HXLINE(  52)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  52)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  52)				 ::Dynamic imageType1 = null();
HXDLIN(  52)				 ::pi_xy::ImageStruct this32 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  52)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  52)				::Dynamic undoImage4;
HXDLIN(  52)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE(  52)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  52)						 ::iterMagic::BytesImg b6 = byt1;
HXDLIN(  52)						{
HXLINE(  52)							b6->width = width1;
HXDLIN(  52)							b6->height = height1;
HXDLIN(  52)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  52)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  52)							{
HXLINE(  52)								int len2 = b6->length;
HXDLIN(  52)								int w1 = 0;
HXDLIN(  52)								{
HXLINE(  52)									int _g20 = 0;
HXDLIN(  52)									int _g21 = b6->height;
HXDLIN(  52)									while((_g20 < _g21)){
HXLINE(  52)										_g20 = (_g20 + 1);
HXDLIN(  52)										int y3 = (_g20 - 1);
HXDLIN(  52)										{
HXLINE(  52)											int _g22 = 0;
HXDLIN(  52)											int _g23 = b6->width;
HXDLIN(  52)											while((_g22 < _g23)){
HXLINE(  52)												_g22 = (_g22 + 1);
HXDLIN(  52)												int x3 = (_g22 - 1);
HXDLIN(  52)												{
HXLINE(  52)													w1 = (w1 + 1);
HXDLIN(  52)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  52)												{
HXLINE(  52)													w1 = (w1 + 1);
HXDLIN(  52)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  52)												{
HXLINE(  52)													w1 = (w1 + 1);
HXDLIN(  52)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  52)												{
HXLINE(  52)													w1 = (w1 + 1);
HXDLIN(  52)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  52)						undoImage4 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE(  52)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  52)						 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN(  52)						{
HXLINE(  52)							a7->width = width1;
HXDLIN(  52)							a7->height = height1;
HXDLIN(  52)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  52)							a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  52)							{
HXLINE(  52)								int _g24 = 0;
HXDLIN(  52)								int _g25 = a7->length;
HXDLIN(  52)								while((_g24 < _g25)){
HXLINE(  52)									_g24 = (_g24 + 1);
HXDLIN(  52)									int i13 = (_g24 - 1);
HXDLIN(  52)									a7->data[i13] = 0;
            								}
            							}
            						}
HXDLIN(  52)						undoImage4 = a7;
            					}
            					break;
            					case (int)2: {
HXLINE(  52)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  52)						 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN(  52)						{
HXLINE(  52)							b7->width = width1;
HXDLIN(  52)							b7->height = height1;
HXDLIN(  52)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  52)							int size1 = (b7->length * 4);
HXDLIN(  52)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  52)							{
HXLINE(  52)								int _g26 = 0;
HXDLIN(  52)								int _g27 = b7->length;
HXDLIN(  52)								while((_g26 < _g27)){
HXLINE(  52)									_g26 = (_g26 + 1);
HXDLIN(  52)									int i14 = (_g26 - 1);
HXDLIN(  52)									{
HXLINE(  52)										 ::haxe::io::ArrayBufferViewImpl this33 = b7->data;
HXDLIN(  52)										bool undoImage5;
HXDLIN(  52)										if ((i14 >= 0)) {
HXLINE(  52)											undoImage5 = (i14 < (this33->byteLength >> 2));
            										}
            										else {
HXLINE(  52)											undoImage5 = false;
            										}
HXDLIN(  52)										if (undoImage5) {
HXLINE(  52)											 ::haxe::io::Bytes _this1 = this33->bytes;
HXDLIN(  52)											int pos1 = ((i14 << 2) + this33->byteOffset);
HXDLIN(  52)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  52)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  52)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  52)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  52)						undoImage4 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE(  52)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  52)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  52)						{
HXLINE(  52)							v3->width = width1;
HXDLIN(  52)							v3->height = height1;
HXDLIN(  52)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  52)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  52)							{
HXLINE(  52)								int _g28 = 0;
HXDLIN(  52)								int _g29 = v3->length;
HXDLIN(  52)								while((_g28 < _g29)){
HXLINE(  52)									_g28 = (_g28 + 1);
HXDLIN(  52)									int i15 = (_g28 - 1);
HXDLIN(  52)									v3->data->__unsafe_set(i15,0);
            								}
            							}
            						}
HXDLIN(  52)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE(  52)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  52)						 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN(  52)						{
HXLINE(  52)							b8->width = width1;
HXDLIN(  52)							b8->height = height1;
HXDLIN(  52)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  52)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  52)							{
HXLINE(  52)								int len3 = b8->length;
HXDLIN(  52)								 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN(  52)								if (::hx::IsNull( d1->head )) {
HXLINE(  52)									int _g30 = 0;
HXDLIN(  52)									int _g31 = len3;
HXDLIN(  52)									while((_g30 < _g31)){
HXLINE(  52)										_g30 = (_g30 + 1);
HXDLIN(  52)										int i16 = (_g30 - 1);
HXDLIN(  52)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE(  52)									int _g32 = 0;
HXDLIN(  52)									int _g33 = len3;
HXDLIN(  52)									while((_g32 < _g33)){
HXLINE(  52)										_g32 = (_g32 + 1);
HXDLIN(  52)										int i17 = (_g32 - 1);
HXDLIN(  52)										{
HXLINE(  52)											 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN(  52)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  52)											{
HXLINE(  52)												int _g34 = 0;
HXDLIN(  52)												int _g35 = i17;
HXDLIN(  52)												while((_g34 < _g35)){
HXLINE(  52)													_g34 = (_g34 + 1);
HXDLIN(  52)													int i18 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  52)											if (::hx::IsNull( prev1 )) {
HXLINE(  52)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  52)												l1 = null();
            											}
            											else {
HXLINE(  52)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  52)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  52)						undoImage4 = b8;
            					}
            					break;
            				}
HXDLIN(  52)				this32->image = undoImage4;
HXDLIN(  52)				this32->width = width1;
HXDLIN(  52)				this32->height = height1;
HXDLIN(  52)				this32->imageType = ( (int)(imageType1) );
HXDLIN(  52)				undoImage3 = this32;
HXDLIN(  52)				{
HXLINE(  52)					int rectLeft1 = xIter31->start;
HXDLIN(  52)					int rectTop1 = yIter31->start;
HXDLIN(  52)					int rectRight1 = xIter31->max;
HXDLIN(  52)					bool forceClear1 = false;
HXDLIN(  52)					{
HXLINE(  52)						int _g36 = rectTop1;
HXDLIN(  52)						int _g37 = yIter31->max;
HXDLIN(  52)						while((_g36 < _g37)){
HXLINE(  52)							_g36 = (_g36 + 1);
HXDLIN(  52)							int dy2 = (_g36 - 1);
HXDLIN(  52)							{
HXLINE(  52)								int _g38 = rectLeft1;
HXDLIN(  52)								int _g39 = rectRight1;
HXDLIN(  52)								while((_g38 < _g39)){
HXLINE(  52)									_g38 = (_g38 + 1);
HXDLIN(  52)									int dx2 = (_g38 - 1);
HXDLIN(  52)									::Dynamic this34 = pixelImage->image;
HXDLIN(  52)									int index4;
HXDLIN(  52)									if (pixelImage->useVirtualPos) {
HXLINE(  52)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  52)										index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN(  52)									int c3 = ::iterMagic::Iimg_obj::get(this34,index4);
HXDLIN(  52)									int col1;
HXDLIN(  52)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE(  52)										col1 = c3;
            									}
HXDLIN(  52)									bool _hx_tmp8;
HXDLIN(  52)									if (pixelImage->useMask) {
HXLINE(  52)										_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE(  52)										_hx_tmp8 = false;
            									}
HXDLIN(  52)									if (_hx_tmp8) {
HXLINE(  52)										 ::pi_xy::ImageStruct this35 = pixelImage->mask;
HXDLIN(  52)										::Dynamic this36 = this35->image;
HXDLIN(  52)										int index5;
HXDLIN(  52)										if (this35->useVirtualPos) {
HXLINE(  52)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx2) - this35->virtualX));
            										}
            										else {
HXLINE(  52)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this35->width) + dx2)) ));
            										}
HXDLIN(  52)										int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN(  52)										int v4;
HXDLIN(  52)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)											v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE(  52)											v4 = c4;
            										}
HXDLIN(  52)										int maskPixel1 = v4;
HXDLIN(  52)										int this37 = col1;
HXDLIN(  52)										if ((maskPixel1 == 0)) {
HXLINE(  52)											col1 = this37;
            										}
            										else {
HXLINE(  52)											Float m01;
HXDLIN(  52)											int this38 = ((maskPixel1 >> 24) & 255);
HXDLIN(  52)											if ((this38 == 0)) {
HXLINE(  52)												m01 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												m01 = (( (Float)(this38) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float m11;
HXDLIN(  52)											int this39 = ((maskPixel1 >> 16) & 255);
HXDLIN(  52)											if ((this39 == 0)) {
HXLINE(  52)												m11 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												m11 = (( (Float)(this39) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float m21;
HXDLIN(  52)											int this40 = ((maskPixel1 >> 8) & 255);
HXDLIN(  52)											if ((this40 == 0)) {
HXLINE(  52)												m21 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												m21 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float m31;
HXDLIN(  52)											int this41 = (maskPixel1 & 255);
HXDLIN(  52)											if ((this41 == 0)) {
HXLINE(  52)												m31 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												m31 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this37 >> 24) & 255)) )));
HXDLIN(  52)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this37 >> 16) & 255)) )));
HXDLIN(  52)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this37 >> 8) & 255)) )));
HXDLIN(  52)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this37 & 255)) )));
HXDLIN(  52)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  52)									if ((col1 != 0)) {
HXLINE(  52)										int x4 = (dx2 - rectLeft1);
HXDLIN(  52)										int y4 = (dy2 - rectTop1);
HXDLIN(  52)										int c5 = col1;
HXDLIN(  52)										bool _hx_tmp9;
HXDLIN(  52)										if ((((c5 >> 24) & 255) < 254)) {
HXLINE(  52)											_hx_tmp9 = undoImage3->transparent;
            										}
            										else {
HXLINE(  52)											_hx_tmp9 = false;
            										}
HXDLIN(  52)										if (_hx_tmp9) {
HXLINE(  52)											int location2;
HXDLIN(  52)											if (undoImage3->useVirtualPos) {
HXLINE(  52)												location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  52)												location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN(  52)											int this42 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  52)											int this43;
HXDLIN(  52)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)												this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            											}
            											else {
HXLINE(  52)												this43 = this42;
            											}
HXDLIN(  52)											Float a12;
HXDLIN(  52)											int this44 = ((this43 >> 24) & 255);
HXDLIN(  52)											if ((this44 == 0)) {
HXLINE(  52)												a12 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float r12;
HXDLIN(  52)											int this45 = ((this43 >> 16) & 255);
HXDLIN(  52)											if ((this45 == 0)) {
HXLINE(  52)												r12 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float g12;
HXDLIN(  52)											int this46 = ((this43 >> 8) & 255);
HXDLIN(  52)											if ((this46 == 0)) {
HXLINE(  52)												g12 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float b13;
HXDLIN(  52)											int this47 = (this43 & 255);
HXDLIN(  52)											if ((this47 == 0)) {
HXLINE(  52)												b13 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float a22;
HXDLIN(  52)											int this48 = ((col1 >> 24) & 255);
HXDLIN(  52)											if ((this48 == 0)) {
HXLINE(  52)												a22 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float r22;
HXDLIN(  52)											int this49 = ((col1 >> 16) & 255);
HXDLIN(  52)											if ((this49 == 0)) {
HXLINE(  52)												r22 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float g22;
HXDLIN(  52)											int this50 = ((col1 >> 8) & 255);
HXDLIN(  52)											if ((this50 == 0)) {
HXLINE(  52)												g22 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float b23;
HXDLIN(  52)											int this51 = (col1 & 255);
HXDLIN(  52)											if ((this51 == 0)) {
HXLINE(  52)												b23 = ((Float)0.);
            											}
            											else {
HXLINE(  52)												b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN(  52)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  52)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  52)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  52)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  52)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  52)											int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  52)											{
HXLINE(  52)												int _hx_tmp10;
HXDLIN(  52)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)													_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE(  52)													_hx_tmp10 = blended2;
            												}
HXDLIN(  52)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            											}
            										}
            										else {
HXLINE(  52)											::Dynamic this52 = undoImage3->image;
HXDLIN(  52)											int index6;
HXDLIN(  52)											if (undoImage3->useVirtualPos) {
HXLINE(  52)												index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  52)												index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN(  52)											int _hx_tmp11;
HXDLIN(  52)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)												_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE(  52)												_hx_tmp11 = c5;
            											}
HXDLIN(  52)											::iterMagic::Iimg_obj::set(this52,index6,_hx_tmp11);
            										}
            									}
            									else {
HXLINE(  52)										if (forceClear1) {
HXLINE(  52)											::Dynamic this53 = undoImage3->image;
HXDLIN(  52)											int x5 = (dx2 - rectLeft1);
HXDLIN(  52)											int y5 = (dy2 - rectTop1);
HXDLIN(  52)											int index7;
HXDLIN(  52)											if (undoImage3->useVirtualPos) {
HXLINE(  52)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  52)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN(  52)											::iterMagic::Iimg_obj::set(this53,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  52)			bool found1 = false;
HXDLIN(  52)			Float min9 = ( (Float)(0) );
HXDLIN(  52)			Float max1 = ( (Float)(0) );
HXDLIN(  52)			int a9 = 0;
HXDLIN(  52)			int r6 = 0;
HXDLIN(  52)			int g6 = 0;
HXDLIN(  52)			int b10 = 0;
HXDLIN(  52)			{
HXLINE(  52)				int _g_min2 = xIter31->start;
HXDLIN(  52)				int _g_max2 = xIter31->max;
HXDLIN(  52)				while((_g_min2 < _g_max2)){
HXLINE(  52)					_g_min2 = (_g_min2 + 1);
HXDLIN(  52)					int px1 = (_g_min2 - 1);
HXDLIN(  52)					Float pcx1 = (( (Float)(px1) ) - dx);
HXLINE( 695)					found1 = false;
HXLINE(  52)					{
HXLINE(  52)						int _g_min3 = yIter31->start;
HXDLIN(  52)						int _g_max3 = yIter31->max;
HXDLIN(  52)						while((_g_min3 < _g_max3)){
HXLINE(  52)							_g_min3 = (_g_min3 + 1);
HXDLIN(  52)							int py1 = (_g_min3 - 1);
HXDLIN(  52)							Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN(  52)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  52)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  52)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  52)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  52)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  52)							bool _hx_tmp12;
HXDLIN(  52)							bool _hx_tmp13;
HXDLIN(  52)							if ((ratioA1 >= 0)) {
HXLINE(  52)								_hx_tmp13 = (ratioB1 >= 0);
            							}
            							else {
HXLINE(  52)								_hx_tmp13 = false;
            							}
HXDLIN(  52)							if (_hx_tmp13) {
HXLINE(  52)								_hx_tmp12 = (ratioC1 >= 0);
            							}
            							else {
HXLINE(  52)								_hx_tmp12 = false;
            							}
HXDLIN(  52)							if (_hx_tmp12) {
HXLINE(  52)								if (softBC) {
HXLINE(  52)									if (softCD) {
HXLINE(  52)										if ((ratioB1 < ratioC1)) {
HXLINE(  52)											min9 = ratioB1;
            										}
            										else {
HXLINE(  52)											min9 = ratioC1;
            										}
HXDLIN(  52)										if ((ratioA1 > ratioB1)) {
HXLINE(  52)											max1 = ratioA1;
            										}
            										else {
HXLINE(  52)											max1 = ratioB1;
            										}
HXDLIN(  52)										if (!((max1 > ratioC1))) {
HXLINE(  52)											max1 = ratioC1;
            										}
HXLINE( 735)										max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  52)										if (!((min9 < max1))) {
HXLINE(  52)											min9 = ((max1 + min9) / ( (Float)(2) ));
            										}
HXDLIN(  52)										int i19 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN(  52)										if ((i19 > 255)) {
HXLINE(  24)											i19 = 255;
            										}
HXLINE(  52)										if ((i19 < 0)) {
HXLINE(  25)											i19 = 0;
            										}
HXLINE(  52)										a9 = i19;
            									}
            									else {
HXLINE( 722)										min9 = ratioC1;
HXLINE(  52)										int i20 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN(  52)										if ((i20 > 255)) {
HXLINE(  24)											i20 = 255;
            										}
HXLINE(  52)										if ((i20 < 0)) {
HXLINE(  25)											i20 = 0;
            										}
HXLINE(  52)										a9 = i20;
            									}
            								}
            								else {
HXLINE(  52)									if (softCD) {
HXLINE( 712)										min9 = ratioB1;
HXLINE(  52)										int i21 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN(  52)										if ((i21 > 255)) {
HXLINE(  24)											i21 = 255;
            										}
HXLINE(  52)										if ((i21 < 0)) {
HXLINE(  25)											i21 = 0;
            										}
HXLINE(  52)										a9 = i21;
            									}
            									else {
HXLINE(  52)										int i22 = ::Std_obj::_hx_int(( (Float)(aA1) ));
HXDLIN(  52)										if ((i22 > 255)) {
HXLINE(  24)											i22 = 255;
            										}
HXLINE(  52)										if ((i22 < 0)) {
HXLINE(  25)											i22 = 0;
            										}
HXLINE(  52)										a9 = i22;
            									}
            								}
HXDLIN(  52)								int i23 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  52)								if ((i23 > 255)) {
HXLINE(  24)									i23 = 255;
            								}
HXLINE(  52)								if ((i23 < 0)) {
HXLINE(  25)									i23 = 0;
            								}
HXLINE( 747)								r6 = i23;
HXLINE(  52)								int i24 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  52)								if ((i24 > 255)) {
HXLINE(  24)									i24 = 255;
            								}
HXLINE(  52)								if ((i24 < 0)) {
HXLINE(  25)									i24 = 0;
            								}
HXLINE( 748)								g6 = i24;
HXLINE(  52)								int i25 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  52)								if ((i25 > 255)) {
HXLINE(  24)									i25 = 255;
            								}
HXLINE(  52)								if ((i25 < 0)) {
HXLINE(  25)									i25 = 0;
            								}
HXLINE( 749)								b10 = i25;
HXLINE(  52)								{
HXLINE(  52)									int location3;
HXDLIN(  52)									if (pixelImage->useVirtualPos) {
HXLINE(  52)										location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  52)										location3 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN(  52)									bool _hx_tmp14;
HXDLIN(  52)									if (pixelImage->transparent) {
HXLINE(  52)										_hx_tmp14 = (a9 < 254);
            									}
            									else {
HXLINE(  52)										_hx_tmp14 = false;
            									}
HXDLIN(  52)									if (_hx_tmp14) {
HXLINE(  52)										int this54 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN(  52)										int old1;
HXDLIN(  52)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)											old1 = ((((((this54 >> 24) & 255) << 24) | ((this54 & 255) << 16)) | (((this54 >> 8) & 255) << 8)) | ((this54 >> 16) & 255));
            										}
            										else {
HXLINE(  52)											old1 = this54;
            										}
HXDLIN(  52)										int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN(  52)										Float a13;
HXDLIN(  52)										int this55 = ((old1 >> 24) & 255);
HXDLIN(  52)										if ((this55 == 0)) {
HXLINE(  52)											a13 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											a13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float r13;
HXDLIN(  52)										int this56 = ((old1 >> 16) & 255);
HXDLIN(  52)										if ((this56 == 0)) {
HXLINE(  52)											r13 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											r13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float g13;
HXDLIN(  52)										int this57 = ((old1 >> 8) & 255);
HXDLIN(  52)										if ((this57 == 0)) {
HXLINE(  52)											g13 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											g13 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float b14;
HXDLIN(  52)										int this58 = (old1 & 255);
HXDLIN(  52)										if ((this58 == 0)) {
HXLINE(  52)											b14 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											b14 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float a23;
HXDLIN(  52)										int this59 = ((rhs1 >> 24) & 255);
HXDLIN(  52)										if ((this59 == 0)) {
HXLINE(  52)											a23 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											a23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float r23;
HXDLIN(  52)										int this60 = ((rhs1 >> 16) & 255);
HXDLIN(  52)										if ((this60 == 0)) {
HXLINE(  52)											r23 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											r23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float g23;
HXDLIN(  52)										int this61 = ((rhs1 >> 8) & 255);
HXDLIN(  52)										if ((this61 == 0)) {
HXLINE(  52)											g23 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											g23 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float b24;
HXDLIN(  52)										int this62 = (rhs1 & 255);
HXDLIN(  52)										if ((this62 == 0)) {
HXLINE(  52)											b24 = ((Float)0.);
            										}
            										else {
HXLINE(  52)											b24 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN(  52)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  52)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  52)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  52)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  52)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  52)										int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN(  52)										{
HXLINE(  52)											int _hx_tmp15;
HXDLIN(  52)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  52)												_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE(  52)												_hx_tmp15 = blended3;
            											}
HXDLIN(  52)											::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp15);
            										}
            									}
            									else {
HXLINE(  52)										int value1;
HXDLIN(  52)										if (pixelImage->isLittle) {
HXLINE(  52)											value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            										}
            										else {
HXLINE(  52)											value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            										}
HXDLIN(  52)										::iterMagic::Iimg_obj::set(pixelImage->image,location3,value1);
            									}
            								}
HXLINE( 751)								found1 = true;
            							}
            							else {
HXLINE(  52)								if (found1) {
HXLINE(  52)									goto _hx_goto_48;
            								}
            							}
            						}
            						_hx_goto_48:;
            					}
            				}
            			}
HXDLIN(  52)			if ((hasHit == false)) {
HXLINE(  52)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  52)				if (hasUndo1) {
HXLINE(  52)					v5->undoImage = undoImage3;
HXDLIN(  52)					v5->undoX = xIter31->start;
HXDLIN(  52)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXLINE(  53)		if ((hasHit == true)) {
HXLINE(  54)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE(  55)			return v6;
            		}
            		else {
HXLINE(  57)			return null();
            		}
HXLINE(  53)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC16(QuadPixel_Fields__obj,fillSoftQuadrilateral,return )

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::fillSoftQuadrilateralFudge( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,int color,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCD,::hx::Null< bool >  __o_softDA,::hx::Null< bool >  __o_hasHit){
            		Float soft = __o_soft.Default(40);
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCD = __o_softCD.Default(true);
            		bool softDA = __o_softDA.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_72_fillSoftQuadrilateralFudge)
HXLINE(  75)		{
HXLINE(  75)			bool hasUndo = true;
HXDLIN(  75)			int aA = ((color >> 24) & 255);
HXDLIN(  75)			int rA = ((color >> 16) & 255);
HXDLIN(  75)			int gA = ((color >> 8) & 255);
HXDLIN(  75)			int bA = (color & 255);
HXDLIN(  75)			Float bcx = (bx - cx);
HXDLIN(  75)			Float bcy = (by - cy);
HXDLIN(  75)			Float acx = (ax - cx);
HXDLIN(  75)			Float acy = (ay - cy);
HXDLIN(  75)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  75)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  75)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  75)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  75)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  75)			if ((ax > bx)) {
HXLINE(  75)				if ((ax > cx)) {
HXLINE(  75)					int min;
HXDLIN(  75)					if ((bx > cx)) {
HXLINE(  75)						min = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE(  75)						min = ::Math_obj::floor(bx);
            					}
HXDLIN(  75)					int ii_min = min;
HXDLIN(  75)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  75)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE(  75)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  75)					int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN(  75)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE(  75)				if ((bx > cx)) {
HXLINE(  75)					int min1;
HXDLIN(  75)					if ((ax > cx)) {
HXLINE(  75)						min1 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE(  75)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN(  75)					int ii_min2 = min1;
HXDLIN(  75)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  75)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE(  75)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  75)					int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN(  75)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN(  75)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  75)			if ((ay > by)) {
HXLINE(  75)				if ((ay > cy)) {
HXLINE(  75)					int min2;
HXDLIN(  75)					if ((by > cy)) {
HXLINE(  75)						min2 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE(  75)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN(  75)					int ii_min4 = min2;
HXDLIN(  75)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  75)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE(  75)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  75)					int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN(  75)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE(  75)				if ((by > cy)) {
HXLINE(  75)					int min3;
HXDLIN(  75)					if ((ay > cy)) {
HXLINE(  75)						min3 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE(  75)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN(  75)					int ii_min6 = min3;
HXDLIN(  75)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  75)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE(  75)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  75)					int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN(  75)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN(  75)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  75)			if (hasUndo) {
HXLINE(  75)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  75)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  75)				 ::Dynamic imageType = null();
HXDLIN(  75)				 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  75)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  75)				::Dynamic undoImage1;
HXDLIN(  75)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE(  75)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  75)						 ::iterMagic::BytesImg b = byt;
HXDLIN(  75)						{
HXLINE(  75)							b->width = width;
HXDLIN(  75)							b->height = height;
HXDLIN(  75)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  75)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  75)							{
HXLINE(  75)								int len = b->length;
HXDLIN(  75)								int w = 0;
HXDLIN(  75)								{
HXLINE(  75)									int _g = 0;
HXDLIN(  75)									int _g1 = b->height;
HXDLIN(  75)									while((_g < _g1)){
HXLINE(  75)										_g = (_g + 1);
HXDLIN(  75)										int y = (_g - 1);
HXDLIN(  75)										{
HXLINE(  75)											int _g2 = 0;
HXDLIN(  75)											int _g3 = b->width;
HXDLIN(  75)											while((_g2 < _g3)){
HXLINE(  75)												_g2 = (_g2 + 1);
HXDLIN(  75)												int x = (_g2 - 1);
HXDLIN(  75)												{
HXLINE(  75)													w = (w + 1);
HXDLIN(  75)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  75)												{
HXLINE(  75)													w = (w + 1);
HXDLIN(  75)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  75)												{
HXLINE(  75)													w = (w + 1);
HXDLIN(  75)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  75)												{
HXLINE(  75)													w = (w + 1);
HXDLIN(  75)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  75)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE(  75)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  75)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  75)						{
HXLINE(  75)							a->width = width;
HXDLIN(  75)							a->height = height;
HXDLIN(  75)							a->data = ::Array_obj< int >::__new(0);
HXDLIN(  75)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  75)							{
HXLINE(  75)								int _g4 = 0;
HXDLIN(  75)								int _g5 = a->length;
HXDLIN(  75)								while((_g4 < _g5)){
HXLINE(  75)									_g4 = (_g4 + 1);
HXDLIN(  75)									int i = (_g4 - 1);
HXDLIN(  75)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN(  75)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE(  75)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  75)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  75)						{
HXLINE(  75)							b1->width = width;
HXDLIN(  75)							b1->height = height;
HXDLIN(  75)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  75)							int size = (b1->length * 4);
HXDLIN(  75)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  75)							{
HXLINE(  75)								int _g6 = 0;
HXDLIN(  75)								int _g7 = b1->length;
HXDLIN(  75)								while((_g6 < _g7)){
HXLINE(  75)									_g6 = (_g6 + 1);
HXDLIN(  75)									int i1 = (_g6 - 1);
HXDLIN(  75)									{
HXLINE(  75)										 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  75)										bool undoImage2;
HXDLIN(  75)										if ((i1 >= 0)) {
HXLINE(  75)											undoImage2 = (i1 < (this2->byteLength >> 2));
            										}
            										else {
HXLINE(  75)											undoImage2 = false;
            										}
HXDLIN(  75)										if (undoImage2) {
HXLINE(  75)											 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  75)											int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  75)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  75)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  75)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  75)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  75)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE(  75)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  75)						 ::iterMagic::VecIntImg v = vec;
HXDLIN(  75)						{
HXLINE(  75)							v->width = width;
HXDLIN(  75)							v->height = height;
HXDLIN(  75)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  75)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  75)							{
HXLINE(  75)								int _g8 = 0;
HXDLIN(  75)								int _g9 = v->length;
HXDLIN(  75)								while((_g8 < _g9)){
HXLINE(  75)									_g8 = (_g8 + 1);
HXDLIN(  75)									int i2 = (_g8 - 1);
HXDLIN(  75)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN(  75)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE(  75)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  75)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  75)						{
HXLINE(  75)							b2->width = width;
HXDLIN(  75)							b2->height = height;
HXDLIN(  75)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  75)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  75)							{
HXLINE(  75)								int len1 = b2->length;
HXDLIN(  75)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  75)								if (::hx::IsNull( d->head )) {
HXLINE(  75)									int _g10 = 0;
HXDLIN(  75)									int _g11 = len1;
HXDLIN(  75)									while((_g10 < _g11)){
HXLINE(  75)										_g10 = (_g10 + 1);
HXDLIN(  75)										int i3 = (_g10 - 1);
HXDLIN(  75)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE(  75)									int _g12 = 0;
HXDLIN(  75)									int _g13 = len1;
HXDLIN(  75)									while((_g12 < _g13)){
HXLINE(  75)										_g12 = (_g12 + 1);
HXDLIN(  75)										int i4 = (_g12 - 1);
HXDLIN(  75)										{
HXLINE(  75)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  75)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  75)											{
HXLINE(  75)												int _g14 = 0;
HXDLIN(  75)												int _g15 = i4;
HXDLIN(  75)												while((_g14 < _g15)){
HXLINE(  75)													_g14 = (_g14 + 1);
HXDLIN(  75)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE(  75)											if (::hx::IsNull( prev )) {
HXLINE(  75)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  75)												l = null();
            											}
            											else {
HXLINE(  75)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  75)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  75)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN(  75)				this1->image = undoImage1;
HXDLIN(  75)				this1->width = width;
HXDLIN(  75)				this1->height = height;
HXDLIN(  75)				this1->imageType = ( (int)(imageType) );
HXDLIN(  75)				undoImage = this1;
HXDLIN(  75)				{
HXLINE(  75)					int rectLeft = xIter3->start;
HXDLIN(  75)					int rectTop = yIter3->start;
HXDLIN(  75)					int rectRight = xIter3->max;
HXDLIN(  75)					bool forceClear = false;
HXDLIN(  75)					{
HXLINE(  75)						int _g16 = rectTop;
HXDLIN(  75)						int _g17 = yIter3->max;
HXDLIN(  75)						while((_g16 < _g17)){
HXLINE(  75)							_g16 = (_g16 + 1);
HXDLIN(  75)							int dy1 = (_g16 - 1);
HXDLIN(  75)							{
HXLINE(  75)								int _g18 = rectLeft;
HXDLIN(  75)								int _g19 = rectRight;
HXDLIN(  75)								while((_g18 < _g19)){
HXLINE(  75)									_g18 = (_g18 + 1);
HXDLIN(  75)									int dx1 = (_g18 - 1);
HXDLIN(  75)									::Dynamic this3 = pixelImage->image;
HXDLIN(  75)									int index;
HXDLIN(  75)									if (pixelImage->useVirtualPos) {
HXLINE(  75)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  75)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN(  75)									int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  75)									int col;
HXDLIN(  75)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE(  75)										col = c;
            									}
HXDLIN(  75)									bool _hx_tmp;
HXDLIN(  75)									if (pixelImage->useMask) {
HXLINE(  75)										_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE(  75)										_hx_tmp = false;
            									}
HXDLIN(  75)									if (_hx_tmp) {
HXLINE(  75)										 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN(  75)										::Dynamic this5 = this4->image;
HXDLIN(  75)										int index1;
HXDLIN(  75)										if (this4->useVirtualPos) {
HXLINE(  75)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXLINE(  75)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN(  75)										int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  75)										int v1;
HXDLIN(  75)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE(  75)											v1 = c1;
            										}
HXDLIN(  75)										int maskPixel = v1;
HXDLIN(  75)										int this6 = col;
HXDLIN(  75)										if ((maskPixel == 0)) {
HXLINE(  75)											col = this6;
            										}
            										else {
HXLINE(  75)											Float m0;
HXDLIN(  75)											int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  75)											if ((this7 == 0)) {
HXLINE(  75)												m0 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float m1;
HXDLIN(  75)											int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  75)											if ((this8 == 0)) {
HXLINE(  75)												m1 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float m2;
HXDLIN(  75)											int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  75)											if ((this9 == 0)) {
HXLINE(  75)												m2 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float m3;
HXDLIN(  75)											int this10 = (maskPixel & 255);
HXDLIN(  75)											if ((this10 == 0)) {
HXLINE(  75)												m3 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  75)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  75)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  75)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  75)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  75)									if ((col != 0)) {
HXLINE(  75)										int x1 = (dx1 - rectLeft);
HXDLIN(  75)										int y1 = (dy1 - rectTop);
HXDLIN(  75)										int c2 = col;
HXDLIN(  75)										bool _hx_tmp1;
HXDLIN(  75)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  75)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXLINE(  75)											_hx_tmp1 = false;
            										}
HXDLIN(  75)										if (_hx_tmp1) {
HXLINE(  75)											int location;
HXDLIN(  75)											if (undoImage->useVirtualPos) {
HXLINE(  75)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE(  75)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN(  75)											int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  75)											int this12;
HXDLIN(  75)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)												this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            											}
            											else {
HXLINE(  75)												this12 = this11;
            											}
HXDLIN(  75)											Float a1;
HXDLIN(  75)											int this13 = ((this12 >> 24) & 255);
HXDLIN(  75)											if ((this13 == 0)) {
HXLINE(  75)												a1 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float r1;
HXDLIN(  75)											int this14 = ((this12 >> 16) & 255);
HXDLIN(  75)											if ((this14 == 0)) {
HXLINE(  75)												r1 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float g1;
HXDLIN(  75)											int this15 = ((this12 >> 8) & 255);
HXDLIN(  75)											if ((this15 == 0)) {
HXLINE(  75)												g1 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float b11;
HXDLIN(  75)											int this16 = (this12 & 255);
HXDLIN(  75)											if ((this16 == 0)) {
HXLINE(  75)												b11 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float a2;
HXDLIN(  75)											int this17 = ((col >> 24) & 255);
HXDLIN(  75)											if ((this17 == 0)) {
HXLINE(  75)												a2 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float r2;
HXDLIN(  75)											int this18 = ((col >> 16) & 255);
HXDLIN(  75)											if ((this18 == 0)) {
HXLINE(  75)												r2 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float g2;
HXDLIN(  75)											int this19 = ((col >> 8) & 255);
HXDLIN(  75)											if ((this19 == 0)) {
HXLINE(  75)												g2 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float b21;
HXDLIN(  75)											int this20 = (col & 255);
HXDLIN(  75)											if ((this20 == 0)) {
HXLINE(  75)												b21 = ((Float)0.);
            											}
            											else {
HXLINE(  75)												b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN(  75)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  75)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  75)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  75)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  75)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  75)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  75)											{
HXLINE(  75)												int _hx_tmp2;
HXDLIN(  75)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE(  75)													_hx_tmp2 = blended;
            												}
HXDLIN(  75)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXLINE(  75)											::Dynamic this21 = undoImage->image;
HXDLIN(  75)											int index2;
HXDLIN(  75)											if (undoImage->useVirtualPos) {
HXLINE(  75)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE(  75)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN(  75)											int _hx_tmp3;
HXDLIN(  75)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE(  75)												_hx_tmp3 = c2;
            											}
HXDLIN(  75)											::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            										}
            									}
            									else {
HXLINE(  75)										if (forceClear) {
HXLINE(  75)											::Dynamic this22 = undoImage->image;
HXDLIN(  75)											int x2 = (dx1 - rectLeft);
HXDLIN(  75)											int y2 = (dy1 - rectTop);
HXDLIN(  75)											int index3;
HXDLIN(  75)											if (undoImage->useVirtualPos) {
HXLINE(  75)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE(  75)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN(  75)											::iterMagic::Iimg_obj::set(this22,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  75)			bool found = false;
HXDLIN(  75)			Float min4 = ( (Float)(0) );
HXDLIN(  75)			Float max = ( (Float)(0) );
HXDLIN(  75)			int a5 = 0;
HXDLIN(  75)			int r3 = 0;
HXDLIN(  75)			int g3 = 0;
HXDLIN(  75)			int b4 = 0;
HXDLIN(  75)			{
HXLINE(  75)				int _g_min = xIter3->start;
HXDLIN(  75)				int _g_max = xIter3->max;
HXDLIN(  75)				while((_g_min < _g_max)){
HXLINE(  75)					_g_min = (_g_min + 1);
HXDLIN(  75)					int px = (_g_min - 1);
HXDLIN(  75)					Float pcx = (( (Float)(px) ) - cx);
HXLINE( 695)					found = false;
HXLINE(  75)					{
HXLINE(  75)						int _g_min1 = yIter3->start;
HXDLIN(  75)						int _g_max1 = yIter3->max;
HXDLIN(  75)						while((_g_min1 < _g_max1)){
HXLINE(  75)							_g_min1 = (_g_min1 + 1);
HXDLIN(  75)							int py = (_g_min1 - 1);
HXDLIN(  75)							Float pcy = (( (Float)(py) ) - cy);
HXDLIN(  75)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  75)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  75)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  75)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  75)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  75)							bool _hx_tmp4;
HXDLIN(  75)							bool _hx_tmp5;
HXDLIN(  75)							if ((ratioA >= 0)) {
HXLINE(  75)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXLINE(  75)								_hx_tmp5 = false;
            							}
HXDLIN(  75)							if (_hx_tmp5) {
HXLINE(  75)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXLINE(  75)								_hx_tmp4 = false;
            							}
HXDLIN(  75)							if (_hx_tmp4) {
HXLINE(  75)								if (softAB) {
HXLINE(  75)									if (softBC) {
HXLINE(  75)										if ((ratioB < ratioC)) {
HXLINE(  75)											min4 = ratioB;
            										}
            										else {
HXLINE(  75)											min4 = ratioC;
            										}
HXDLIN(  75)										if ((ratioA > ratioB)) {
HXLINE(  75)											max = ratioA;
            										}
            										else {
HXLINE(  75)											max = ratioB;
            										}
HXDLIN(  75)										if (!((max > ratioC))) {
HXLINE(  75)											max = ratioC;
            										}
HXLINE( 735)										max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE(  75)										if (!((min4 < max))) {
HXLINE(  75)											min4 = ((max + min4) / ( (Float)(2) ));
            										}
HXDLIN(  75)										int i6 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN(  75)										if ((i6 > 255)) {
HXLINE(  24)											i6 = 255;
            										}
HXLINE(  75)										if ((i6 < 0)) {
HXLINE(  25)											i6 = 0;
            										}
HXLINE(  75)										a5 = i6;
            									}
            									else {
HXLINE( 722)										min4 = ratioC;
HXLINE(  75)										int i7 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN(  75)										if ((i7 > 255)) {
HXLINE(  24)											i7 = 255;
            										}
HXLINE(  75)										if ((i7 < 0)) {
HXLINE(  25)											i7 = 0;
            										}
HXLINE(  75)										a5 = i7;
            									}
            								}
            								else {
HXLINE(  75)									if (softBC) {
HXLINE( 712)										min4 = ratioB;
HXLINE(  75)										int i8 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN(  75)										if ((i8 > 255)) {
HXLINE(  24)											i8 = 255;
            										}
HXLINE(  75)										if ((i8 < 0)) {
HXLINE(  25)											i8 = 0;
            										}
HXLINE(  75)										a5 = i8;
            									}
            									else {
HXLINE(  75)										int i9 = ::Std_obj::_hx_int(( (Float)(aA) ));
HXDLIN(  75)										if ((i9 > 255)) {
HXLINE(  24)											i9 = 255;
            										}
HXLINE(  75)										if ((i9 < 0)) {
HXLINE(  25)											i9 = 0;
            										}
HXLINE(  75)										a5 = i9;
            									}
            								}
HXDLIN(  75)								int i10 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN(  75)								if ((i10 > 255)) {
HXLINE(  24)									i10 = 255;
            								}
HXLINE(  75)								if ((i10 < 0)) {
HXLINE(  25)									i10 = 0;
            								}
HXLINE( 747)								r3 = i10;
HXLINE(  75)								int i11 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN(  75)								if ((i11 > 255)) {
HXLINE(  24)									i11 = 255;
            								}
HXLINE(  75)								if ((i11 < 0)) {
HXLINE(  25)									i11 = 0;
            								}
HXLINE( 748)								g3 = i11;
HXLINE(  75)								int i12 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN(  75)								if ((i12 > 255)) {
HXLINE(  24)									i12 = 255;
            								}
HXLINE(  75)								if ((i12 < 0)) {
HXLINE(  25)									i12 = 0;
            								}
HXLINE( 749)								b4 = i12;
HXLINE(  75)								{
HXLINE(  75)									int location1;
HXDLIN(  75)									if (pixelImage->useVirtualPos) {
HXLINE(  75)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  75)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN(  75)									bool _hx_tmp6;
HXDLIN(  75)									if (pixelImage->transparent) {
HXLINE(  75)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXLINE(  75)										_hx_tmp6 = false;
            									}
HXDLIN(  75)									if (_hx_tmp6) {
HXLINE(  75)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN(  75)										int old;
HXDLIN(  75)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)											old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE(  75)											old = this23;
            										}
HXDLIN(  75)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  75)										Float a11;
HXDLIN(  75)										int this24 = ((old >> 24) & 255);
HXDLIN(  75)										if ((this24 == 0)) {
HXLINE(  75)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(  75)											a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN(  75)										Float r11;
HXDLIN(  75)										int this25 = ((old >> 16) & 255);
HXDLIN(  75)										if ((this25 == 0)) {
HXLINE(  75)											r11 = ((Float)0.);
            										}
            										else {
HXLINE(  75)											r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN(  75)										Float g11;
HXDLIN(  75)										int this26 = ((old >> 8) & 255);
HXDLIN(  75)										if ((this26 == 0)) {
HXLINE(  75)											g11 = ((Float)0.);
            										}
            										else {
HXLINE(  75)											g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN(  75)										Float b12;
HXDLIN(  75)										int this27 = (old & 255);
HXDLIN(  75)										if ((this27 == 0)) {
HXLINE(  75)											b12 = ((Float)0.);
            										}
            										else {
HXLINE(  75)											b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  75)										Float a21;
HXDLIN(  75)										int this28 = ((rhs >> 24) & 255);
HXDLIN(  75)										if ((this28 == 0)) {
HXLINE(  75)											a21 = ((Float)0.);
            										}
            										else {
HXLINE(  75)											a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  75)										Float r21;
HXDLIN(  75)										int this29 = ((rhs >> 16) & 255);
HXDLIN(  75)										if ((this29 == 0)) {
HXLINE(  75)											r21 = ((Float)0.);
            										}
            										else {
HXLINE(  75)											r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  75)										Float g21;
HXDLIN(  75)										int this30 = ((rhs >> 8) & 255);
HXDLIN(  75)										if ((this30 == 0)) {
HXLINE(  75)											g21 = ((Float)0.);
            										}
            										else {
HXLINE(  75)											g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  75)										Float b22;
HXDLIN(  75)										int this31 = (rhs & 255);
HXDLIN(  75)										if ((this31 == 0)) {
HXLINE(  75)											b22 = ((Float)0.);
            										}
            										else {
HXLINE(  75)											b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  75)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  75)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  75)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  75)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  75)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  75)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  75)										{
HXLINE(  75)											int _hx_tmp7;
HXDLIN(  75)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  75)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE(  75)												_hx_tmp7 = blended1;
            											}
HXDLIN(  75)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXLINE(  75)										int value;
HXDLIN(  75)										if (pixelImage->isLittle) {
HXLINE(  75)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXLINE(  75)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN(  75)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            									}
            								}
HXLINE( 751)								found = true;
            							}
            							else {
HXLINE(  75)								if (found) {
HXLINE(  75)									goto _hx_goto_61;
            								}
            							}
            						}
            						_hx_goto_61:;
            					}
            				}
            			}
HXDLIN(  75)			if ((hasHit == false)) {
HXLINE(  75)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN(  75)				if (hasUndo) {
HXLINE(  75)					v2->undoImage = undoImage;
HXDLIN(  75)					v2->undoX = xIter3->start;
HXDLIN(  75)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXLINE(  76)		{
HXLINE(  76)			bool hasUndo1 = true;
HXDLIN(  76)			int aA1 = ((color >> 24) & 255);
HXDLIN(  76)			int rA1 = ((color >> 16) & 255);
HXDLIN(  76)			int gA1 = ((color >> 8) & 255);
HXDLIN(  76)			int bA1 = (color & 255);
HXDLIN(  76)			Float bcx1 = (cx - ax);
HXDLIN(  76)			Float bcy1 = (cy - ay);
HXDLIN(  76)			Float acx1 = (dx - ax);
HXDLIN(  76)			Float acy1 = (dy - ay);
HXDLIN(  76)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  76)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  76)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  76)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  76)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  76)			if ((dx > cx)) {
HXLINE(  76)				if ((dx > ax)) {
HXLINE(  76)					int min5;
HXDLIN(  76)					if ((cx > ax)) {
HXLINE(  76)						min5 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE(  76)						min5 = ::Math_obj::floor(cx);
            					}
HXDLIN(  76)					int ii_min8 = min5;
HXDLIN(  76)					int ii_max8 = ::Math_obj::ceil(dx);
HXDLIN(  76)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE(  76)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN(  76)					int ii_max9 = ::Math_obj::ceil(ax);
HXDLIN(  76)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE(  76)				if ((cx > ax)) {
HXLINE(  76)					int min6;
HXDLIN(  76)					if ((dx > ax)) {
HXLINE(  76)						min6 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE(  76)						min6 = ::Math_obj::ceil(dx);
            					}
HXDLIN(  76)					int ii_min10 = min6;
HXDLIN(  76)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN(  76)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE(  76)					int ii_min11 = ::Math_obj::floor(dx);
HXDLIN(  76)					int ii_max11 = ::Math_obj::ceil(ax);
HXDLIN(  76)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN(  76)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  76)			if ((dy > cy)) {
HXLINE(  76)				if ((dy > ay)) {
HXLINE(  76)					int min7;
HXDLIN(  76)					if ((cy > ay)) {
HXLINE(  76)						min7 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE(  76)						min7 = ::Math_obj::floor(cy);
            					}
HXDLIN(  76)					int ii_min12 = min7;
HXDLIN(  76)					int ii_max12 = ::Math_obj::ceil(dy);
HXDLIN(  76)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE(  76)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN(  76)					int ii_max13 = ::Math_obj::ceil(ay);
HXDLIN(  76)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE(  76)				if ((cy > ay)) {
HXLINE(  76)					int min8;
HXDLIN(  76)					if ((dy > ay)) {
HXLINE(  76)						min8 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE(  76)						min8 = ::Math_obj::ceil(dy);
            					}
HXDLIN(  76)					int ii_min14 = min8;
HXDLIN(  76)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN(  76)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE(  76)					int ii_min15 = ::Math_obj::floor(dy);
HXDLIN(  76)					int ii_max15 = ::Math_obj::ceil(ay);
HXDLIN(  76)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN(  76)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  76)			if (hasUndo1) {
HXLINE(  76)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  76)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  76)				 ::Dynamic imageType1 = null();
HXDLIN(  76)				 ::pi_xy::ImageStruct this32 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  76)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  76)				::Dynamic undoImage4;
HXDLIN(  76)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE(  76)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  76)						 ::iterMagic::BytesImg b6 = byt1;
HXDLIN(  76)						{
HXLINE(  76)							b6->width = width1;
HXDLIN(  76)							b6->height = height1;
HXDLIN(  76)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  76)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  76)							{
HXLINE(  76)								int len2 = b6->length;
HXDLIN(  76)								int w1 = 0;
HXDLIN(  76)								{
HXLINE(  76)									int _g20 = 0;
HXDLIN(  76)									int _g21 = b6->height;
HXDLIN(  76)									while((_g20 < _g21)){
HXLINE(  76)										_g20 = (_g20 + 1);
HXDLIN(  76)										int y3 = (_g20 - 1);
HXDLIN(  76)										{
HXLINE(  76)											int _g22 = 0;
HXDLIN(  76)											int _g23 = b6->width;
HXDLIN(  76)											while((_g22 < _g23)){
HXLINE(  76)												_g22 = (_g22 + 1);
HXDLIN(  76)												int x3 = (_g22 - 1);
HXDLIN(  76)												{
HXLINE(  76)													w1 = (w1 + 1);
HXDLIN(  76)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  76)												{
HXLINE(  76)													w1 = (w1 + 1);
HXDLIN(  76)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  76)												{
HXLINE(  76)													w1 = (w1 + 1);
HXDLIN(  76)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  76)												{
HXLINE(  76)													w1 = (w1 + 1);
HXDLIN(  76)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  76)						undoImage4 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE(  76)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  76)						 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN(  76)						{
HXLINE(  76)							a7->width = width1;
HXDLIN(  76)							a7->height = height1;
HXDLIN(  76)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  76)							a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  76)							{
HXLINE(  76)								int _g24 = 0;
HXDLIN(  76)								int _g25 = a7->length;
HXDLIN(  76)								while((_g24 < _g25)){
HXLINE(  76)									_g24 = (_g24 + 1);
HXDLIN(  76)									int i13 = (_g24 - 1);
HXDLIN(  76)									a7->data[i13] = 0;
            								}
            							}
            						}
HXDLIN(  76)						undoImage4 = a7;
            					}
            					break;
            					case (int)2: {
HXLINE(  76)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  76)						 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN(  76)						{
HXLINE(  76)							b7->width = width1;
HXDLIN(  76)							b7->height = height1;
HXDLIN(  76)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  76)							int size1 = (b7->length * 4);
HXDLIN(  76)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  76)							{
HXLINE(  76)								int _g26 = 0;
HXDLIN(  76)								int _g27 = b7->length;
HXDLIN(  76)								while((_g26 < _g27)){
HXLINE(  76)									_g26 = (_g26 + 1);
HXDLIN(  76)									int i14 = (_g26 - 1);
HXDLIN(  76)									{
HXLINE(  76)										 ::haxe::io::ArrayBufferViewImpl this33 = b7->data;
HXDLIN(  76)										bool undoImage5;
HXDLIN(  76)										if ((i14 >= 0)) {
HXLINE(  76)											undoImage5 = (i14 < (this33->byteLength >> 2));
            										}
            										else {
HXLINE(  76)											undoImage5 = false;
            										}
HXDLIN(  76)										if (undoImage5) {
HXLINE(  76)											 ::haxe::io::Bytes _this1 = this33->bytes;
HXDLIN(  76)											int pos1 = ((i14 << 2) + this33->byteOffset);
HXDLIN(  76)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  76)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  76)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  76)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  76)						undoImage4 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE(  76)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  76)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  76)						{
HXLINE(  76)							v3->width = width1;
HXDLIN(  76)							v3->height = height1;
HXDLIN(  76)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  76)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  76)							{
HXLINE(  76)								int _g28 = 0;
HXDLIN(  76)								int _g29 = v3->length;
HXDLIN(  76)								while((_g28 < _g29)){
HXLINE(  76)									_g28 = (_g28 + 1);
HXDLIN(  76)									int i15 = (_g28 - 1);
HXDLIN(  76)									v3->data->__unsafe_set(i15,0);
            								}
            							}
            						}
HXDLIN(  76)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE(  76)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  76)						 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN(  76)						{
HXLINE(  76)							b8->width = width1;
HXDLIN(  76)							b8->height = height1;
HXDLIN(  76)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  76)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  76)							{
HXLINE(  76)								int len3 = b8->length;
HXDLIN(  76)								 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN(  76)								if (::hx::IsNull( d1->head )) {
HXLINE(  76)									int _g30 = 0;
HXDLIN(  76)									int _g31 = len3;
HXDLIN(  76)									while((_g30 < _g31)){
HXLINE(  76)										_g30 = (_g30 + 1);
HXDLIN(  76)										int i16 = (_g30 - 1);
HXDLIN(  76)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE(  76)									int _g32 = 0;
HXDLIN(  76)									int _g33 = len3;
HXDLIN(  76)									while((_g32 < _g33)){
HXLINE(  76)										_g32 = (_g32 + 1);
HXDLIN(  76)										int i17 = (_g32 - 1);
HXDLIN(  76)										{
HXLINE(  76)											 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN(  76)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  76)											{
HXLINE(  76)												int _g34 = 0;
HXDLIN(  76)												int _g35 = i17;
HXDLIN(  76)												while((_g34 < _g35)){
HXLINE(  76)													_g34 = (_g34 + 1);
HXDLIN(  76)													int i18 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  76)											if (::hx::IsNull( prev1 )) {
HXLINE(  76)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  76)												l1 = null();
            											}
            											else {
HXLINE(  76)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  76)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  76)						undoImage4 = b8;
            					}
            					break;
            				}
HXDLIN(  76)				this32->image = undoImage4;
HXDLIN(  76)				this32->width = width1;
HXDLIN(  76)				this32->height = height1;
HXDLIN(  76)				this32->imageType = ( (int)(imageType1) );
HXDLIN(  76)				undoImage3 = this32;
HXDLIN(  76)				{
HXLINE(  76)					int rectLeft1 = xIter31->start;
HXDLIN(  76)					int rectTop1 = yIter31->start;
HXDLIN(  76)					int rectRight1 = xIter31->max;
HXDLIN(  76)					bool forceClear1 = false;
HXDLIN(  76)					{
HXLINE(  76)						int _g36 = rectTop1;
HXDLIN(  76)						int _g37 = yIter31->max;
HXDLIN(  76)						while((_g36 < _g37)){
HXLINE(  76)							_g36 = (_g36 + 1);
HXDLIN(  76)							int dy2 = (_g36 - 1);
HXDLIN(  76)							{
HXLINE(  76)								int _g38 = rectLeft1;
HXDLIN(  76)								int _g39 = rectRight1;
HXDLIN(  76)								while((_g38 < _g39)){
HXLINE(  76)									_g38 = (_g38 + 1);
HXDLIN(  76)									int dx2 = (_g38 - 1);
HXDLIN(  76)									::Dynamic this34 = pixelImage->image;
HXDLIN(  76)									int index4;
HXDLIN(  76)									if (pixelImage->useVirtualPos) {
HXLINE(  76)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  76)										index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN(  76)									int c3 = ::iterMagic::Iimg_obj::get(this34,index4);
HXDLIN(  76)									int col1;
HXDLIN(  76)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE(  76)										col1 = c3;
            									}
HXDLIN(  76)									bool _hx_tmp8;
HXDLIN(  76)									if (pixelImage->useMask) {
HXLINE(  76)										_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE(  76)										_hx_tmp8 = false;
            									}
HXDLIN(  76)									if (_hx_tmp8) {
HXLINE(  76)										 ::pi_xy::ImageStruct this35 = pixelImage->mask;
HXDLIN(  76)										::Dynamic this36 = this35->image;
HXDLIN(  76)										int index5;
HXDLIN(  76)										if (this35->useVirtualPos) {
HXLINE(  76)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx2) - this35->virtualX));
            										}
            										else {
HXLINE(  76)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this35->width) + dx2)) ));
            										}
HXDLIN(  76)										int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN(  76)										int v4;
HXDLIN(  76)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)											v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE(  76)											v4 = c4;
            										}
HXDLIN(  76)										int maskPixel1 = v4;
HXDLIN(  76)										int this37 = col1;
HXDLIN(  76)										if ((maskPixel1 == 0)) {
HXLINE(  76)											col1 = this37;
            										}
            										else {
HXLINE(  76)											Float m01;
HXDLIN(  76)											int this38 = ((maskPixel1 >> 24) & 255);
HXDLIN(  76)											if ((this38 == 0)) {
HXLINE(  76)												m01 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												m01 = (( (Float)(this38) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float m11;
HXDLIN(  76)											int this39 = ((maskPixel1 >> 16) & 255);
HXDLIN(  76)											if ((this39 == 0)) {
HXLINE(  76)												m11 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												m11 = (( (Float)(this39) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float m21;
HXDLIN(  76)											int this40 = ((maskPixel1 >> 8) & 255);
HXDLIN(  76)											if ((this40 == 0)) {
HXLINE(  76)												m21 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												m21 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float m31;
HXDLIN(  76)											int this41 = (maskPixel1 & 255);
HXDLIN(  76)											if ((this41 == 0)) {
HXLINE(  76)												m31 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												m31 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this37 >> 24) & 255)) )));
HXDLIN(  76)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this37 >> 16) & 255)) )));
HXDLIN(  76)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this37 >> 8) & 255)) )));
HXDLIN(  76)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this37 & 255)) )));
HXDLIN(  76)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  76)									if ((col1 != 0)) {
HXLINE(  76)										int x4 = (dx2 - rectLeft1);
HXDLIN(  76)										int y4 = (dy2 - rectTop1);
HXDLIN(  76)										int c5 = col1;
HXDLIN(  76)										bool _hx_tmp9;
HXDLIN(  76)										if ((((c5 >> 24) & 255) < 254)) {
HXLINE(  76)											_hx_tmp9 = undoImage3->transparent;
            										}
            										else {
HXLINE(  76)											_hx_tmp9 = false;
            										}
HXDLIN(  76)										if (_hx_tmp9) {
HXLINE(  76)											int location2;
HXDLIN(  76)											if (undoImage3->useVirtualPos) {
HXLINE(  76)												location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  76)												location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN(  76)											int this42 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  76)											int this43;
HXDLIN(  76)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)												this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            											}
            											else {
HXLINE(  76)												this43 = this42;
            											}
HXDLIN(  76)											Float a12;
HXDLIN(  76)											int this44 = ((this43 >> 24) & 255);
HXDLIN(  76)											if ((this44 == 0)) {
HXLINE(  76)												a12 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float r12;
HXDLIN(  76)											int this45 = ((this43 >> 16) & 255);
HXDLIN(  76)											if ((this45 == 0)) {
HXLINE(  76)												r12 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float g12;
HXDLIN(  76)											int this46 = ((this43 >> 8) & 255);
HXDLIN(  76)											if ((this46 == 0)) {
HXLINE(  76)												g12 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float b13;
HXDLIN(  76)											int this47 = (this43 & 255);
HXDLIN(  76)											if ((this47 == 0)) {
HXLINE(  76)												b13 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float a22;
HXDLIN(  76)											int this48 = ((col1 >> 24) & 255);
HXDLIN(  76)											if ((this48 == 0)) {
HXLINE(  76)												a22 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float r22;
HXDLIN(  76)											int this49 = ((col1 >> 16) & 255);
HXDLIN(  76)											if ((this49 == 0)) {
HXLINE(  76)												r22 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float g22;
HXDLIN(  76)											int this50 = ((col1 >> 8) & 255);
HXDLIN(  76)											if ((this50 == 0)) {
HXLINE(  76)												g22 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float b23;
HXDLIN(  76)											int this51 = (col1 & 255);
HXDLIN(  76)											if ((this51 == 0)) {
HXLINE(  76)												b23 = ((Float)0.);
            											}
            											else {
HXLINE(  76)												b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN(  76)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  76)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  76)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  76)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  76)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  76)											int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  76)											{
HXLINE(  76)												int _hx_tmp10;
HXDLIN(  76)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)													_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE(  76)													_hx_tmp10 = blended2;
            												}
HXDLIN(  76)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            											}
            										}
            										else {
HXLINE(  76)											::Dynamic this52 = undoImage3->image;
HXDLIN(  76)											int index6;
HXDLIN(  76)											if (undoImage3->useVirtualPos) {
HXLINE(  76)												index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  76)												index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN(  76)											int _hx_tmp11;
HXDLIN(  76)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)												_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE(  76)												_hx_tmp11 = c5;
            											}
HXDLIN(  76)											::iterMagic::Iimg_obj::set(this52,index6,_hx_tmp11);
            										}
            									}
            									else {
HXLINE(  76)										if (forceClear1) {
HXLINE(  76)											::Dynamic this53 = undoImage3->image;
HXDLIN(  76)											int x5 = (dx2 - rectLeft1);
HXDLIN(  76)											int y5 = (dy2 - rectTop1);
HXDLIN(  76)											int index7;
HXDLIN(  76)											if (undoImage3->useVirtualPos) {
HXLINE(  76)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  76)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN(  76)											::iterMagic::Iimg_obj::set(this53,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  76)			bool found1 = false;
HXDLIN(  76)			Float min9 = ( (Float)(0) );
HXDLIN(  76)			Float max1 = ( (Float)(0) );
HXDLIN(  76)			int a9 = 0;
HXDLIN(  76)			int r6 = 0;
HXDLIN(  76)			int g6 = 0;
HXDLIN(  76)			int b10 = 0;
HXDLIN(  76)			{
HXLINE(  76)				int _g_min2 = xIter31->start;
HXDLIN(  76)				int _g_max2 = xIter31->max;
HXDLIN(  76)				while((_g_min2 < _g_max2)){
HXLINE(  76)					_g_min2 = (_g_min2 + 1);
HXDLIN(  76)					int px1 = (_g_min2 - 1);
HXDLIN(  76)					Float pcx1 = (( (Float)(px1) ) - ax);
HXLINE( 695)					found1 = false;
HXLINE(  76)					{
HXLINE(  76)						int _g_min3 = yIter31->start;
HXDLIN(  76)						int _g_max3 = yIter31->max;
HXDLIN(  76)						while((_g_min3 < _g_max3)){
HXLINE(  76)							_g_min3 = (_g_min3 + 1);
HXDLIN(  76)							int py1 = (_g_min3 - 1);
HXDLIN(  76)							Float pcy1 = (( (Float)(py1) ) - ay);
HXDLIN(  76)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  76)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  76)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  76)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  76)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  76)							bool _hx_tmp12;
HXDLIN(  76)							bool _hx_tmp13;
HXDLIN(  76)							if ((ratioA1 >= 0)) {
HXLINE(  76)								_hx_tmp13 = (ratioB1 >= 0);
            							}
            							else {
HXLINE(  76)								_hx_tmp13 = false;
            							}
HXDLIN(  76)							if (_hx_tmp13) {
HXLINE(  76)								_hx_tmp12 = (ratioC1 >= 0);
            							}
            							else {
HXLINE(  76)								_hx_tmp12 = false;
            							}
HXDLIN(  76)							if (_hx_tmp12) {
HXLINE(  76)								if (softCD) {
HXLINE(  76)									if (softDA) {
HXLINE(  76)										if ((ratioA1 < ratioC1)) {
HXLINE(  76)											min9 = ratioA1;
            										}
            										else {
HXLINE(  76)											min9 = ratioC1;
            										}
HXDLIN(  76)										if ((ratioA1 > ratioB1)) {
HXLINE(  76)											max1 = ratioA1;
            										}
            										else {
HXLINE(  76)											max1 = ratioB1;
            										}
HXDLIN(  76)										if (!((max1 > ratioC1))) {
HXLINE(  76)											max1 = ratioC1;
            										}
HXLINE( 728)										max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE(  76)										if (!((min9 < max1))) {
HXLINE(  76)											min9 = ((max1 + min9) / ( (Float)(2) ));
            										}
HXDLIN(  76)										int i19 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN(  76)										if ((i19 > 255)) {
HXLINE(  24)											i19 = 255;
            										}
HXLINE(  76)										if ((i19 < 0)) {
HXLINE(  25)											i19 = 0;
            										}
HXLINE(  76)										a9 = i19;
            									}
            									else {
HXLINE( 722)										min9 = ratioC1;
HXLINE(  76)										int i20 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN(  76)										if ((i20 > 255)) {
HXLINE(  24)											i20 = 255;
            										}
HXLINE(  76)										if ((i20 < 0)) {
HXLINE(  25)											i20 = 0;
            										}
HXLINE(  76)										a9 = i20;
            									}
            								}
            								else {
HXLINE(  76)									if (softDA) {
HXLINE( 709)										min9 = ratioA1;
HXLINE(  76)										int i21 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN(  76)										if ((i21 > 255)) {
HXLINE(  24)											i21 = 255;
            										}
HXLINE(  76)										if ((i21 < 0)) {
HXLINE(  25)											i21 = 0;
            										}
HXLINE(  76)										a9 = i21;
            									}
            									else {
HXLINE(  76)										int i22 = ::Std_obj::_hx_int(( (Float)(aA1) ));
HXDLIN(  76)										if ((i22 > 255)) {
HXLINE(  24)											i22 = 255;
            										}
HXLINE(  76)										if ((i22 < 0)) {
HXLINE(  25)											i22 = 0;
            										}
HXLINE(  76)										a9 = i22;
            									}
            								}
HXDLIN(  76)								int i23 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN(  76)								if ((i23 > 255)) {
HXLINE(  24)									i23 = 255;
            								}
HXLINE(  76)								if ((i23 < 0)) {
HXLINE(  25)									i23 = 0;
            								}
HXLINE( 747)								r6 = i23;
HXLINE(  76)								int i24 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN(  76)								if ((i24 > 255)) {
HXLINE(  24)									i24 = 255;
            								}
HXLINE(  76)								if ((i24 < 0)) {
HXLINE(  25)									i24 = 0;
            								}
HXLINE( 748)								g6 = i24;
HXLINE(  76)								int i25 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN(  76)								if ((i25 > 255)) {
HXLINE(  24)									i25 = 255;
            								}
HXLINE(  76)								if ((i25 < 0)) {
HXLINE(  25)									i25 = 0;
            								}
HXLINE( 749)								b10 = i25;
HXLINE(  76)								{
HXLINE(  76)									int location3;
HXDLIN(  76)									if (pixelImage->useVirtualPos) {
HXLINE(  76)										location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  76)										location3 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN(  76)									bool _hx_tmp14;
HXDLIN(  76)									if (pixelImage->transparent) {
HXLINE(  76)										_hx_tmp14 = (a9 < 254);
            									}
            									else {
HXLINE(  76)										_hx_tmp14 = false;
            									}
HXDLIN(  76)									if (_hx_tmp14) {
HXLINE(  76)										int this54 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN(  76)										int old1;
HXDLIN(  76)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)											old1 = ((((((this54 >> 24) & 255) << 24) | ((this54 & 255) << 16)) | (((this54 >> 8) & 255) << 8)) | ((this54 >> 16) & 255));
            										}
            										else {
HXLINE(  76)											old1 = this54;
            										}
HXDLIN(  76)										int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN(  76)										Float a13;
HXDLIN(  76)										int this55 = ((old1 >> 24) & 255);
HXDLIN(  76)										if ((this55 == 0)) {
HXLINE(  76)											a13 = ((Float)0.);
            										}
            										else {
HXLINE(  76)											a13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN(  76)										Float r13;
HXDLIN(  76)										int this56 = ((old1 >> 16) & 255);
HXDLIN(  76)										if ((this56 == 0)) {
HXLINE(  76)											r13 = ((Float)0.);
            										}
            										else {
HXLINE(  76)											r13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN(  76)										Float g13;
HXDLIN(  76)										int this57 = ((old1 >> 8) & 255);
HXDLIN(  76)										if ((this57 == 0)) {
HXLINE(  76)											g13 = ((Float)0.);
            										}
            										else {
HXLINE(  76)											g13 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN(  76)										Float b14;
HXDLIN(  76)										int this58 = (old1 & 255);
HXDLIN(  76)										if ((this58 == 0)) {
HXLINE(  76)											b14 = ((Float)0.);
            										}
            										else {
HXLINE(  76)											b14 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN(  76)										Float a23;
HXDLIN(  76)										int this59 = ((rhs1 >> 24) & 255);
HXDLIN(  76)										if ((this59 == 0)) {
HXLINE(  76)											a23 = ((Float)0.);
            										}
            										else {
HXLINE(  76)											a23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN(  76)										Float r23;
HXDLIN(  76)										int this60 = ((rhs1 >> 16) & 255);
HXDLIN(  76)										if ((this60 == 0)) {
HXLINE(  76)											r23 = ((Float)0.);
            										}
            										else {
HXLINE(  76)											r23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN(  76)										Float g23;
HXDLIN(  76)										int this61 = ((rhs1 >> 8) & 255);
HXDLIN(  76)										if ((this61 == 0)) {
HXLINE(  76)											g23 = ((Float)0.);
            										}
            										else {
HXLINE(  76)											g23 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN(  76)										Float b24;
HXDLIN(  76)										int this62 = (rhs1 & 255);
HXDLIN(  76)										if ((this62 == 0)) {
HXLINE(  76)											b24 = ((Float)0.);
            										}
            										else {
HXLINE(  76)											b24 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN(  76)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  76)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  76)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  76)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  76)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  76)										int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN(  76)										{
HXLINE(  76)											int _hx_tmp15;
HXDLIN(  76)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  76)												_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE(  76)												_hx_tmp15 = blended3;
            											}
HXDLIN(  76)											::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp15);
            										}
            									}
            									else {
HXLINE(  76)										int value1;
HXDLIN(  76)										if (pixelImage->isLittle) {
HXLINE(  76)											value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            										}
            										else {
HXLINE(  76)											value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            										}
HXDLIN(  76)										::iterMagic::Iimg_obj::set(pixelImage->image,location3,value1);
            									}
            								}
HXLINE( 751)								found1 = true;
            							}
            							else {
HXLINE(  76)								if (found1) {
HXLINE(  76)									goto _hx_goto_73;
            								}
            							}
            						}
            						_hx_goto_73:;
            					}
            				}
            			}
HXDLIN(  76)			if ((hasHit == false)) {
HXLINE(  76)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,dx,dy,cx,cy,ax,ay,true);
HXDLIN(  76)				if (hasUndo1) {
HXLINE(  76)					v5->undoImage = undoImage3;
HXDLIN(  76)					v5->undoX = xIter31->start;
HXDLIN(  76)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXLINE(  77)		if ((hasHit == true)) {
HXLINE(  78)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE(  79)			return v6;
            		}
            		else {
HXLINE(  81)			return null();
            		}
HXLINE(  77)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC16(QuadPixel_Fields__obj,fillSoftQuadrilateralFudge,return )

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::fillSoftQuadrilateralQuarter( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,int color,::hx::Null< Float >  __o_soft,::hx::Null< bool >  __o_softAB,::hx::Null< bool >  __o_softBC,::hx::Null< bool >  __o_softCD,::hx::Null< bool >  __o_softDA,::hx::Null< bool >  __o_hasHit){
            		Float soft = __o_soft.Default(40);
            		bool softAB = __o_softAB.Default(true);
            		bool softBC = __o_softBC.Default(true);
            		bool softCD = __o_softCD.Default(true);
            		bool softDA = __o_softDA.Default(true);
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_97_fillSoftQuadrilateralQuarter)
HXLINE( 100)		{
HXLINE( 100)			bool hasUndo = true;
HXDLIN( 100)			int aA = ((color >> 24) & 255);
HXDLIN( 100)			int rA = ((color >> 16) & 255);
HXDLIN( 100)			int gA = ((color >> 8) & 255);
HXDLIN( 100)			int bA = (color & 255);
HXDLIN( 100)			Float bcx = (bx - cx);
HXDLIN( 100)			Float bcy = (by - cy);
HXDLIN( 100)			Float acx = (ax - cx);
HXDLIN( 100)			Float acy = (ay - cy);
HXDLIN( 100)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 100)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 100)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 100)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 100)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 100)			if ((ax > bx)) {
HXLINE( 100)				if ((ax > cx)) {
HXLINE( 100)					int min;
HXDLIN( 100)					if ((bx > cx)) {
HXLINE( 100)						min = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 100)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 100)					int ii_min = min;
HXDLIN( 100)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 100)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE( 100)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 100)					int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 100)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE( 100)				if ((bx > cx)) {
HXLINE( 100)					int min1;
HXDLIN( 100)					if ((ax > cx)) {
HXLINE( 100)						min1 = ::Math_obj::floor(cx);
            					}
            					else {
HXLINE( 100)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 100)					int ii_min2 = min1;
HXDLIN( 100)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 100)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE( 100)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 100)					int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 100)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN( 100)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 100)			if ((ay > by)) {
HXLINE( 100)				if ((ay > cy)) {
HXLINE( 100)					int min2;
HXDLIN( 100)					if ((by > cy)) {
HXLINE( 100)						min2 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 100)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 100)					int ii_min4 = min2;
HXDLIN( 100)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 100)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE( 100)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 100)					int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 100)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE( 100)				if ((by > cy)) {
HXLINE( 100)					int min3;
HXDLIN( 100)					if ((ay > cy)) {
HXLINE( 100)						min3 = ::Math_obj::floor(cy);
            					}
            					else {
HXLINE( 100)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 100)					int ii_min6 = min3;
HXDLIN( 100)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 100)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE( 100)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 100)					int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 100)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN( 100)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 100)			if (hasUndo) {
HXLINE( 100)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 100)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 100)				 ::Dynamic imageType = null();
HXDLIN( 100)				 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 100)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 100)				::Dynamic undoImage1;
HXDLIN( 100)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 100)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 100)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 100)						{
HXLINE( 100)							b->width = width;
HXDLIN( 100)							b->height = height;
HXDLIN( 100)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 100)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 100)							{
HXLINE( 100)								int len = b->length;
HXDLIN( 100)								int w = 0;
HXDLIN( 100)								{
HXLINE( 100)									int _g = 0;
HXDLIN( 100)									int _g1 = b->height;
HXDLIN( 100)									while((_g < _g1)){
HXLINE( 100)										_g = (_g + 1);
HXDLIN( 100)										int y = (_g - 1);
HXDLIN( 100)										{
HXLINE( 100)											int _g2 = 0;
HXDLIN( 100)											int _g3 = b->width;
HXDLIN( 100)											while((_g2 < _g3)){
HXLINE( 100)												_g2 = (_g2 + 1);
HXDLIN( 100)												int x = (_g2 - 1);
HXDLIN( 100)												{
HXLINE( 100)													w = (w + 1);
HXDLIN( 100)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 100)												{
HXLINE( 100)													w = (w + 1);
HXDLIN( 100)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 100)												{
HXLINE( 100)													w = (w + 1);
HXDLIN( 100)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 100)												{
HXLINE( 100)													w = (w + 1);
HXDLIN( 100)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 100)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE( 100)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 100)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 100)						{
HXLINE( 100)							a->width = width;
HXDLIN( 100)							a->height = height;
HXDLIN( 100)							a->data = ::Array_obj< int >::__new(0);
HXDLIN( 100)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 100)							{
HXLINE( 100)								int _g4 = 0;
HXDLIN( 100)								int _g5 = a->length;
HXDLIN( 100)								while((_g4 < _g5)){
HXLINE( 100)									_g4 = (_g4 + 1);
HXDLIN( 100)									int i = (_g4 - 1);
HXDLIN( 100)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 100)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE( 100)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 100)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 100)						{
HXLINE( 100)							b1->width = width;
HXDLIN( 100)							b1->height = height;
HXDLIN( 100)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 100)							int size = (b1->length * 4);
HXDLIN( 100)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 100)							{
HXLINE( 100)								int _g6 = 0;
HXDLIN( 100)								int _g7 = b1->length;
HXDLIN( 100)								while((_g6 < _g7)){
HXLINE( 100)									_g6 = (_g6 + 1);
HXDLIN( 100)									int i1 = (_g6 - 1);
HXDLIN( 100)									{
HXLINE( 100)										 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 100)										bool undoImage2;
HXDLIN( 100)										if ((i1 >= 0)) {
HXLINE( 100)											undoImage2 = (i1 < (this2->byteLength >> 2));
            										}
            										else {
HXLINE( 100)											undoImage2 = false;
            										}
HXDLIN( 100)										if (undoImage2) {
HXLINE( 100)											 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 100)											int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 100)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 100)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 100)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 100)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 100)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE( 100)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 100)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 100)						{
HXLINE( 100)							v->width = width;
HXDLIN( 100)							v->height = height;
HXDLIN( 100)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 100)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 100)							{
HXLINE( 100)								int _g8 = 0;
HXDLIN( 100)								int _g9 = v->length;
HXDLIN( 100)								while((_g8 < _g9)){
HXLINE( 100)									_g8 = (_g8 + 1);
HXDLIN( 100)									int i2 = (_g8 - 1);
HXDLIN( 100)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 100)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 100)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 100)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 100)						{
HXLINE( 100)							b2->width = width;
HXDLIN( 100)							b2->height = height;
HXDLIN( 100)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 100)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 100)							{
HXLINE( 100)								int len1 = b2->length;
HXDLIN( 100)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 100)								if (::hx::IsNull( d->head )) {
HXLINE( 100)									int _g10 = 0;
HXDLIN( 100)									int _g11 = len1;
HXDLIN( 100)									while((_g10 < _g11)){
HXLINE( 100)										_g10 = (_g10 + 1);
HXDLIN( 100)										int i3 = (_g10 - 1);
HXDLIN( 100)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 100)									int _g12 = 0;
HXDLIN( 100)									int _g13 = len1;
HXDLIN( 100)									while((_g12 < _g13)){
HXLINE( 100)										_g12 = (_g12 + 1);
HXDLIN( 100)										int i4 = (_g12 - 1);
HXDLIN( 100)										{
HXLINE( 100)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 100)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 100)											{
HXLINE( 100)												int _g14 = 0;
HXDLIN( 100)												int _g15 = i4;
HXDLIN( 100)												while((_g14 < _g15)){
HXLINE( 100)													_g14 = (_g14 + 1);
HXDLIN( 100)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 100)											if (::hx::IsNull( prev )) {
HXLINE( 100)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 100)												l = null();
            											}
            											else {
HXLINE( 100)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 100)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 100)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 100)				this1->image = undoImage1;
HXDLIN( 100)				this1->width = width;
HXDLIN( 100)				this1->height = height;
HXDLIN( 100)				this1->imageType = ( (int)(imageType) );
HXDLIN( 100)				undoImage = this1;
HXDLIN( 100)				{
HXLINE( 100)					int rectLeft = xIter3->start;
HXDLIN( 100)					int rectTop = yIter3->start;
HXDLIN( 100)					int rectRight = xIter3->max;
HXDLIN( 100)					bool forceClear = false;
HXDLIN( 100)					{
HXLINE( 100)						int _g16 = rectTop;
HXDLIN( 100)						int _g17 = yIter3->max;
HXDLIN( 100)						while((_g16 < _g17)){
HXLINE( 100)							_g16 = (_g16 + 1);
HXDLIN( 100)							int dy1 = (_g16 - 1);
HXDLIN( 100)							{
HXLINE( 100)								int _g18 = rectLeft;
HXDLIN( 100)								int _g19 = rectRight;
HXDLIN( 100)								while((_g18 < _g19)){
HXLINE( 100)									_g18 = (_g18 + 1);
HXDLIN( 100)									int dx1 = (_g18 - 1);
HXDLIN( 100)									::Dynamic this3 = pixelImage->image;
HXDLIN( 100)									int index;
HXDLIN( 100)									if (pixelImage->useVirtualPos) {
HXLINE( 100)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 100)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 100)									int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 100)									int col;
HXDLIN( 100)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 100)										col = c;
            									}
HXDLIN( 100)									bool _hx_tmp;
HXDLIN( 100)									if (pixelImage->useMask) {
HXLINE( 100)										_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 100)										_hx_tmp = false;
            									}
HXDLIN( 100)									if (_hx_tmp) {
HXLINE( 100)										 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 100)										::Dynamic this5 = this4->image;
HXDLIN( 100)										int index1;
HXDLIN( 100)										if (this4->useVirtualPos) {
HXLINE( 100)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXLINE( 100)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN( 100)										int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 100)										int v1;
HXDLIN( 100)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE( 100)											v1 = c1;
            										}
HXDLIN( 100)										int maskPixel = v1;
HXDLIN( 100)										int this6 = col;
HXDLIN( 100)										if ((maskPixel == 0)) {
HXLINE( 100)											col = this6;
            										}
            										else {
HXLINE( 100)											Float m0;
HXDLIN( 100)											int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 100)											if ((this7 == 0)) {
HXLINE( 100)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float m1;
HXDLIN( 100)											int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 100)											if ((this8 == 0)) {
HXLINE( 100)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float m2;
HXDLIN( 100)											int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 100)											if ((this9 == 0)) {
HXLINE( 100)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float m3;
HXDLIN( 100)											int this10 = (maskPixel & 255);
HXDLIN( 100)											if ((this10 == 0)) {
HXLINE( 100)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 100)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 100)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 100)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 100)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 100)									if ((col != 0)) {
HXLINE( 100)										int x1 = (dx1 - rectLeft);
HXDLIN( 100)										int y1 = (dy1 - rectTop);
HXDLIN( 100)										int c2 = col;
HXDLIN( 100)										bool _hx_tmp1;
HXDLIN( 100)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 100)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXLINE( 100)											_hx_tmp1 = false;
            										}
HXDLIN( 100)										if (_hx_tmp1) {
HXLINE( 100)											int location;
HXDLIN( 100)											if (undoImage->useVirtualPos) {
HXLINE( 100)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 100)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 100)											int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 100)											int this12;
HXDLIN( 100)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)												this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            											}
            											else {
HXLINE( 100)												this12 = this11;
            											}
HXDLIN( 100)											Float a1;
HXDLIN( 100)											int this13 = ((this12 >> 24) & 255);
HXDLIN( 100)											if ((this13 == 0)) {
HXLINE( 100)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float r1;
HXDLIN( 100)											int this14 = ((this12 >> 16) & 255);
HXDLIN( 100)											if ((this14 == 0)) {
HXLINE( 100)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float g1;
HXDLIN( 100)											int this15 = ((this12 >> 8) & 255);
HXDLIN( 100)											if ((this15 == 0)) {
HXLINE( 100)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float b11;
HXDLIN( 100)											int this16 = (this12 & 255);
HXDLIN( 100)											if ((this16 == 0)) {
HXLINE( 100)												b11 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float a2;
HXDLIN( 100)											int this17 = ((col >> 24) & 255);
HXDLIN( 100)											if ((this17 == 0)) {
HXLINE( 100)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float r2;
HXDLIN( 100)											int this18 = ((col >> 16) & 255);
HXDLIN( 100)											if ((this18 == 0)) {
HXLINE( 100)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float g2;
HXDLIN( 100)											int this19 = ((col >> 8) & 255);
HXDLIN( 100)											if ((this19 == 0)) {
HXLINE( 100)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float b21;
HXDLIN( 100)											int this20 = (col & 255);
HXDLIN( 100)											if ((this20 == 0)) {
HXLINE( 100)												b21 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 100)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 100)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 100)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 100)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 100)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 100)											{
HXLINE( 100)												int _hx_tmp2;
HXDLIN( 100)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 100)													_hx_tmp2 = blended;
            												}
HXDLIN( 100)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXLINE( 100)											::Dynamic this21 = undoImage->image;
HXDLIN( 100)											int index2;
HXDLIN( 100)											if (undoImage->useVirtualPos) {
HXLINE( 100)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 100)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 100)											int _hx_tmp3;
HXDLIN( 100)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE( 100)												_hx_tmp3 = c2;
            											}
HXDLIN( 100)											::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            										}
            									}
            									else {
HXLINE( 100)										if (forceClear) {
HXLINE( 100)											::Dynamic this22 = undoImage->image;
HXDLIN( 100)											int x2 = (dx1 - rectLeft);
HXDLIN( 100)											int y2 = (dy1 - rectTop);
HXDLIN( 100)											int index3;
HXDLIN( 100)											if (undoImage->useVirtualPos) {
HXLINE( 100)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE( 100)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN( 100)											::iterMagic::Iimg_obj::set(this22,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 100)			bool found = false;
HXDLIN( 100)			Float min4 = ( (Float)(0) );
HXDLIN( 100)			Float max = ( (Float)(0) );
HXDLIN( 100)			int a5 = 0;
HXDLIN( 100)			int r3 = 0;
HXDLIN( 100)			int g3 = 0;
HXDLIN( 100)			int b4 = 0;
HXDLIN( 100)			{
HXLINE( 100)				int _g_min = xIter3->start;
HXDLIN( 100)				int _g_max = xIter3->max;
HXDLIN( 100)				while((_g_min < _g_max)){
HXLINE( 100)					_g_min = (_g_min + 1);
HXDLIN( 100)					int px = (_g_min - 1);
HXDLIN( 100)					Float pcx = (( (Float)(px) ) - cx);
HXLINE( 812)					found = false;
HXLINE( 100)					{
HXLINE( 100)						int _g_min1 = yIter3->start;
HXDLIN( 100)						int _g_max1 = yIter3->max;
HXDLIN( 100)						while((_g_min1 < _g_max1)){
HXLINE( 100)							_g_min1 = (_g_min1 + 1);
HXDLIN( 100)							int py = (_g_min1 - 1);
HXDLIN( 100)							Float pcy = (( (Float)(py) ) - cy);
HXDLIN( 100)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 100)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 100)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 100)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 100)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 100)							bool _hx_tmp4;
HXDLIN( 100)							bool _hx_tmp5;
HXDLIN( 100)							if ((ratioA >= 0)) {
HXLINE( 100)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXLINE( 100)								_hx_tmp5 = false;
            							}
HXDLIN( 100)							if (_hx_tmp5) {
HXLINE( 100)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXLINE( 100)								_hx_tmp4 = false;
            							}
HXDLIN( 100)							if (_hx_tmp4) {
HXLINE( 100)								int i6 = ::Std_obj::_hx_int(( (Float)(rA) ));
HXDLIN( 100)								if ((i6 > 255)) {
HXLINE(  24)									i6 = 255;
            								}
HXLINE( 100)								if ((i6 < 0)) {
HXLINE(  25)									i6 = 0;
            								}
HXLINE( 821)								r3 = i6;
HXLINE( 100)								int i7 = ::Std_obj::_hx_int(( (Float)(gA) ));
HXDLIN( 100)								if ((i7 > 255)) {
HXLINE(  24)									i7 = 255;
            								}
HXLINE( 100)								if ((i7 < 0)) {
HXLINE(  25)									i7 = 0;
            								}
HXLINE( 822)								g3 = i7;
HXLINE( 100)								int i8 = ::Std_obj::_hx_int(( (Float)(bA) ));
HXDLIN( 100)								if ((i8 > 255)) {
HXLINE(  24)									i8 = 255;
            								}
HXLINE( 100)								if ((i8 < 0)) {
HXLINE(  25)									i8 = 0;
            								}
HXLINE( 823)								b4 = i8;
HXLINE( 100)								bool _hx_tmp6;
HXDLIN( 100)								bool _hx_tmp7;
HXDLIN( 100)								if ((softAB == true)) {
HXLINE( 100)									_hx_tmp7 = (softBC == false);
            								}
            								else {
HXLINE( 100)									_hx_tmp7 = false;
            								}
HXDLIN( 100)								if (_hx_tmp7) {
HXLINE( 100)									_hx_tmp6 = false;
            								}
            								else {
HXLINE( 100)									_hx_tmp6 = false;
            								}
HXDLIN( 100)								if (_hx_tmp6) {
HXLINE( 100)									if ((ratioA < ratioC)) {
HXLINE( 100)										min4 = ratioA;
            									}
            									else {
HXLINE( 100)										min4 = ratioC;
            									}
HXDLIN( 100)									if ((ratioA > ratioB)) {
HXLINE( 100)										max = ratioA;
            									}
            									else {
HXLINE( 100)										max = ratioB;
            									}
HXDLIN( 100)									if (!((max > ratioC))) {
HXLINE( 100)										max = ratioC;
            									}
HXLINE( 829)									max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 100)									if (!((min4 < max))) {
HXLINE( 100)										min4 = ((max + min4) / ( (Float)(2) ));
            									}
HXDLIN( 100)									int i9 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN( 100)									if ((i9 > 255)) {
HXLINE(  24)										i9 = 255;
            									}
HXLINE( 100)									if ((i9 < 0)) {
HXLINE(  25)										i9 = 0;
            									}
HXLINE( 832)									a5 = i9;
HXLINE( 100)									{
HXLINE( 100)										int location1;
HXDLIN( 100)										if (pixelImage->useVirtualPos) {
HXLINE( 100)											location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 100)											location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            										}
HXDLIN( 100)										bool _hx_tmp8;
HXDLIN( 100)										if (pixelImage->transparent) {
HXLINE( 100)											_hx_tmp8 = (a5 < 254);
            										}
            										else {
HXLINE( 100)											_hx_tmp8 = false;
            										}
HXDLIN( 100)										if (_hx_tmp8) {
HXLINE( 100)											int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 100)											int old;
HXDLIN( 100)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)												old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            											}
            											else {
HXLINE( 100)												old = this23;
            											}
HXDLIN( 100)											int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 100)											Float a11;
HXDLIN( 100)											int this24 = ((old >> 24) & 255);
HXDLIN( 100)											if ((this24 == 0)) {
HXLINE( 100)												a11 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float r11;
HXDLIN( 100)											int this25 = ((old >> 16) & 255);
HXDLIN( 100)											if ((this25 == 0)) {
HXLINE( 100)												r11 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float g11;
HXDLIN( 100)											int this26 = ((old >> 8) & 255);
HXDLIN( 100)											if ((this26 == 0)) {
HXLINE( 100)												g11 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float b12;
HXDLIN( 100)											int this27 = (old & 255);
HXDLIN( 100)											if ((this27 == 0)) {
HXLINE( 100)												b12 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float a21;
HXDLIN( 100)											int this28 = ((rhs >> 24) & 255);
HXDLIN( 100)											if ((this28 == 0)) {
HXLINE( 100)												a21 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float r21;
HXDLIN( 100)											int this29 = ((rhs >> 16) & 255);
HXDLIN( 100)											if ((this29 == 0)) {
HXLINE( 100)												r21 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float g21;
HXDLIN( 100)											int this30 = ((rhs >> 8) & 255);
HXDLIN( 100)											if ((this30 == 0)) {
HXLINE( 100)												g21 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float b22;
HXDLIN( 100)											int this31 = (rhs & 255);
HXDLIN( 100)											if ((this31 == 0)) {
HXLINE( 100)												b22 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 100)											int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 100)											int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 100)											int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 100)											int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 100)											int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 100)											{
HXLINE( 100)												int _hx_tmp9;
HXDLIN( 100)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)													_hx_tmp9 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXLINE( 100)													_hx_tmp9 = blended1;
            												}
HXDLIN( 100)												::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp9);
            											}
            										}
            										else {
HXLINE( 100)											int value;
HXDLIN( 100)											if (pixelImage->isLittle) {
HXLINE( 100)												value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            											}
            											else {
HXLINE( 100)												value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            											}
HXDLIN( 100)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            										}
            									}
            								}
HXDLIN( 100)								bool _hx_tmp10;
HXDLIN( 100)								if ((softAB == true)) {
HXLINE( 100)									_hx_tmp10 = (softBC == true);
            								}
            								else {
HXLINE( 100)									_hx_tmp10 = false;
            								}
HXDLIN( 100)								if (_hx_tmp10) {
HXLINE( 100)									if ((ratioB < ratioC)) {
HXLINE( 100)										min4 = ratioB;
            									}
            									else {
HXLINE( 100)										min4 = ratioC;
            									}
HXDLIN( 100)									if ((ratioA > ratioB)) {
HXLINE( 100)										max = ratioA;
            									}
            									else {
HXLINE( 100)										max = ratioB;
            									}
HXDLIN( 100)									if (!((max > ratioC))) {
HXLINE( 100)										max = ratioC;
            									}
HXLINE( 842)									max = ((( (Float)(1) ) - max) / ( (Float)(2) ));
HXLINE( 100)									if (!((min4 < max))) {
HXLINE( 100)										min4 = ((max + min4) / ( (Float)(2) ));
            									}
HXDLIN( 100)									int i10 = ::Std_obj::_hx_int(((( (Float)(aA) ) * soft) * min4));
HXDLIN( 100)									if ((i10 > 255)) {
HXLINE(  24)										i10 = 255;
            									}
HXLINE( 100)									if ((i10 < 0)) {
HXLINE(  25)										i10 = 0;
            									}
HXLINE( 845)									a5 = i10;
HXLINE( 100)									{
HXLINE( 100)										int location2;
HXDLIN( 100)										if (pixelImage->useVirtualPos) {
HXLINE( 100)											location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 100)											location2 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            										}
HXDLIN( 100)										bool _hx_tmp11;
HXDLIN( 100)										if (pixelImage->transparent) {
HXLINE( 100)											_hx_tmp11 = (a5 < 254);
            										}
            										else {
HXLINE( 100)											_hx_tmp11 = false;
            										}
HXDLIN( 100)										if (_hx_tmp11) {
HXLINE( 100)											int this32 = ::iterMagic::Iimg_obj::get(pixelImage->image,location2);
HXDLIN( 100)											int old1;
HXDLIN( 100)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)												old1 = ((((((this32 >> 24) & 255) << 24) | ((this32 & 255) << 16)) | (((this32 >> 8) & 255) << 8)) | ((this32 >> 16) & 255));
            											}
            											else {
HXLINE( 100)												old1 = this32;
            											}
HXDLIN( 100)											int rhs1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 100)											Float a12;
HXDLIN( 100)											int this33 = ((old1 >> 24) & 255);
HXDLIN( 100)											if ((this33 == 0)) {
HXLINE( 100)												a12 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												a12 = (( (Float)(this33) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float r12;
HXDLIN( 100)											int this34 = ((old1 >> 16) & 255);
HXDLIN( 100)											if ((this34 == 0)) {
HXLINE( 100)												r12 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												r12 = (( (Float)(this34) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float g12;
HXDLIN( 100)											int this35 = ((old1 >> 8) & 255);
HXDLIN( 100)											if ((this35 == 0)) {
HXLINE( 100)												g12 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												g12 = (( (Float)(this35) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float b13;
HXDLIN( 100)											int this36 = (old1 & 255);
HXDLIN( 100)											if ((this36 == 0)) {
HXLINE( 100)												b13 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												b13 = (( (Float)(this36) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float a22;
HXDLIN( 100)											int this37 = ((rhs1 >> 24) & 255);
HXDLIN( 100)											if ((this37 == 0)) {
HXLINE( 100)												a22 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												a22 = (( (Float)(this37) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float r22;
HXDLIN( 100)											int this38 = ((rhs1 >> 16) & 255);
HXDLIN( 100)											if ((this38 == 0)) {
HXLINE( 100)												r22 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												r22 = (( (Float)(this38) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float g22;
HXDLIN( 100)											int this39 = ((rhs1 >> 8) & 255);
HXDLIN( 100)											if ((this39 == 0)) {
HXLINE( 100)												g22 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												g22 = (( (Float)(this39) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float b23;
HXDLIN( 100)											int this40 = (rhs1 & 255);
HXDLIN( 100)											if ((this40 == 0)) {
HXLINE( 100)												b23 = ((Float)0.);
            											}
            											else {
HXLINE( 100)												b23 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN( 100)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 100)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 100)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 100)											int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 100)											int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 100)											int blended2 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN( 100)											{
HXLINE( 100)												int _hx_tmp12;
HXDLIN( 100)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 100)													_hx_tmp12 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE( 100)													_hx_tmp12 = blended2;
            												}
HXDLIN( 100)												::iterMagic::Iimg_obj::set(pixelImage->image,location2,_hx_tmp12);
            											}
            										}
            										else {
HXLINE( 100)											int value1;
HXDLIN( 100)											if (pixelImage->isLittle) {
HXLINE( 100)												value1 = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            											}
            											else {
HXLINE( 100)												value1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            											}
HXDLIN( 100)											::iterMagic::Iimg_obj::set(pixelImage->image,location2,value1);
            										}
            									}
            								}
HXLINE( 850)								found = true;
            							}
            							else {
HXLINE( 100)								if (found) {
HXLINE( 100)									goto _hx_goto_86;
            								}
            							}
            						}
            						_hx_goto_86:;
            					}
            				}
            			}
HXDLIN( 100)			if ((hasHit == false)) {
HXLINE( 100)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 100)				if (hasUndo) {
HXLINE( 100)					v2->undoImage = undoImage;
HXDLIN( 100)					v2->undoX = xIter3->start;
HXDLIN( 100)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXLINE( 101)		{
HXLINE( 101)			bool hasUndo1 = true;
HXDLIN( 101)			int aA1 = ((color >> 24) & 255);
HXDLIN( 101)			int rA1 = ((color >> 16) & 255);
HXDLIN( 101)			int gA1 = ((color >> 8) & 255);
HXDLIN( 101)			int bA1 = (color & 255);
HXDLIN( 101)			Float bcx1 = (cx - ax);
HXDLIN( 101)			Float bcy1 = (cy - ay);
HXDLIN( 101)			Float acx1 = (dx - ax);
HXDLIN( 101)			Float acy1 = (dy - ay);
HXDLIN( 101)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 101)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 101)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 101)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 101)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 101)			if ((dx > cx)) {
HXLINE( 101)				if ((dx > ax)) {
HXLINE( 101)					int min5;
HXDLIN( 101)					if ((cx > ax)) {
HXLINE( 101)						min5 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 101)						min5 = ::Math_obj::floor(cx);
            					}
HXDLIN( 101)					int ii_min8 = min5;
HXDLIN( 101)					int ii_max8 = ::Math_obj::ceil(dx);
HXDLIN( 101)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 101)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 101)					int ii_max9 = ::Math_obj::ceil(ax);
HXDLIN( 101)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 101)				if ((cx > ax)) {
HXLINE( 101)					int min6;
HXDLIN( 101)					if ((dx > ax)) {
HXLINE( 101)						min6 = ::Math_obj::floor(ax);
            					}
            					else {
HXLINE( 101)						min6 = ::Math_obj::ceil(dx);
            					}
HXDLIN( 101)					int ii_min10 = min6;
HXDLIN( 101)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 101)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 101)					int ii_min11 = ::Math_obj::floor(dx);
HXDLIN( 101)					int ii_max11 = ::Math_obj::ceil(ax);
HXDLIN( 101)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 101)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 101)			if ((dy > cy)) {
HXLINE( 101)				if ((dy > ay)) {
HXLINE( 101)					int min7;
HXDLIN( 101)					if ((cy > ay)) {
HXLINE( 101)						min7 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 101)						min7 = ::Math_obj::floor(cy);
            					}
HXDLIN( 101)					int ii_min12 = min7;
HXDLIN( 101)					int ii_max12 = ::Math_obj::ceil(dy);
HXDLIN( 101)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 101)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 101)					int ii_max13 = ::Math_obj::ceil(ay);
HXDLIN( 101)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 101)				if ((cy > ay)) {
HXLINE( 101)					int min8;
HXDLIN( 101)					if ((dy > ay)) {
HXLINE( 101)						min8 = ::Math_obj::floor(ay);
            					}
            					else {
HXLINE( 101)						min8 = ::Math_obj::ceil(dy);
            					}
HXDLIN( 101)					int ii_min14 = min8;
HXDLIN( 101)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 101)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 101)					int ii_min15 = ::Math_obj::floor(dy);
HXDLIN( 101)					int ii_max15 = ::Math_obj::ceil(ay);
HXDLIN( 101)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 101)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 101)			if (hasUndo1) {
HXLINE( 101)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 101)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 101)				 ::Dynamic imageType1 = null();
HXDLIN( 101)				 ::pi_xy::ImageStruct this41 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 101)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 101)				::Dynamic undoImage4;
HXDLIN( 101)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 101)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 101)						 ::iterMagic::BytesImg b7 = byt1;
HXDLIN( 101)						{
HXLINE( 101)							b7->width = width1;
HXDLIN( 101)							b7->height = height1;
HXDLIN( 101)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 101)							b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN( 101)							{
HXLINE( 101)								int len2 = b7->length;
HXDLIN( 101)								int w1 = 0;
HXDLIN( 101)								{
HXLINE( 101)									int _g20 = 0;
HXDLIN( 101)									int _g21 = b7->height;
HXDLIN( 101)									while((_g20 < _g21)){
HXLINE( 101)										_g20 = (_g20 + 1);
HXDLIN( 101)										int y3 = (_g20 - 1);
HXDLIN( 101)										{
HXLINE( 101)											int _g22 = 0;
HXDLIN( 101)											int _g23 = b7->width;
HXDLIN( 101)											while((_g22 < _g23)){
HXLINE( 101)												_g22 = (_g22 + 1);
HXDLIN( 101)												int x3 = (_g22 - 1);
HXDLIN( 101)												{
HXLINE( 101)													w1 = (w1 + 1);
HXDLIN( 101)													b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 101)												{
HXLINE( 101)													w1 = (w1 + 1);
HXDLIN( 101)													b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 101)												{
HXLINE( 101)													w1 = (w1 + 1);
HXDLIN( 101)													b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 101)												{
HXLINE( 101)													w1 = (w1 + 1);
HXDLIN( 101)													b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 101)						undoImage4 = b7;
            					}
            					break;
            					case (int)1: {
HXLINE( 101)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 101)						 ::iterMagic::ArrIntImg a8 = arrI1;
HXDLIN( 101)						{
HXLINE( 101)							a8->width = width1;
HXDLIN( 101)							a8->height = height1;
HXDLIN( 101)							a8->data = ::Array_obj< int >::__new(0);
HXDLIN( 101)							a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 101)							{
HXLINE( 101)								int _g24 = 0;
HXDLIN( 101)								int _g25 = a8->length;
HXDLIN( 101)								while((_g24 < _g25)){
HXLINE( 101)									_g24 = (_g24 + 1);
HXDLIN( 101)									int i11 = (_g24 - 1);
HXDLIN( 101)									a8->data[i11] = 0;
            								}
            							}
            						}
HXDLIN( 101)						undoImage4 = a8;
            					}
            					break;
            					case (int)2: {
HXLINE( 101)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 101)						 ::iterMagic::U32ArrImg b8 = u32a1;
HXDLIN( 101)						{
HXLINE( 101)							b8->width = width1;
HXDLIN( 101)							b8->height = height1;
HXDLIN( 101)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 101)							int size1 = (b8->length * 4);
HXDLIN( 101)							b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 101)							{
HXLINE( 101)								int _g26 = 0;
HXDLIN( 101)								int _g27 = b8->length;
HXDLIN( 101)								while((_g26 < _g27)){
HXLINE( 101)									_g26 = (_g26 + 1);
HXDLIN( 101)									int i12 = (_g26 - 1);
HXDLIN( 101)									{
HXLINE( 101)										 ::haxe::io::ArrayBufferViewImpl this42 = b8->data;
HXDLIN( 101)										bool undoImage5;
HXDLIN( 101)										if ((i12 >= 0)) {
HXLINE( 101)											undoImage5 = (i12 < (this42->byteLength >> 2));
            										}
            										else {
HXLINE( 101)											undoImage5 = false;
            										}
HXDLIN( 101)										if (undoImage5) {
HXLINE( 101)											 ::haxe::io::Bytes _this1 = this42->bytes;
HXDLIN( 101)											int pos1 = ((i12 << 2) + this42->byteOffset);
HXDLIN( 101)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 101)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 101)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 101)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 101)						undoImage4 = b8;
            					}
            					break;
            					case (int)3: {
HXLINE( 101)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 101)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 101)						{
HXLINE( 101)							v3->width = width1;
HXDLIN( 101)							v3->height = height1;
HXDLIN( 101)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 101)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 101)							{
HXLINE( 101)								int _g28 = 0;
HXDLIN( 101)								int _g29 = v3->length;
HXDLIN( 101)								while((_g28 < _g29)){
HXLINE( 101)									_g28 = (_g28 + 1);
HXDLIN( 101)									int i13 = (_g28 - 1);
HXDLIN( 101)									v3->data->__unsafe_set(i13,0);
            								}
            							}
            						}
HXDLIN( 101)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 101)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 101)						 ::iterMagic::StackIntImg b9 = sInt1;
HXDLIN( 101)						{
HXLINE( 101)							b9->width = width1;
HXDLIN( 101)							b9->height = height1;
HXDLIN( 101)							b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 101)							b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 101)							{
HXLINE( 101)								int len3 = b9->length;
HXDLIN( 101)								 ::haxe::ds::GenericStack_Int d1 = b9->data;
HXDLIN( 101)								if (::hx::IsNull( d1->head )) {
HXLINE( 101)									int _g30 = 0;
HXDLIN( 101)									int _g31 = len3;
HXDLIN( 101)									while((_g30 < _g31)){
HXLINE( 101)										_g30 = (_g30 + 1);
HXDLIN( 101)										int i14 = (_g30 - 1);
HXDLIN( 101)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 101)									int _g32 = 0;
HXDLIN( 101)									int _g33 = len3;
HXDLIN( 101)									while((_g32 < _g33)){
HXLINE( 101)										_g32 = (_g32 + 1);
HXDLIN( 101)										int i15 = (_g32 - 1);
HXDLIN( 101)										{
HXLINE( 101)											 ::haxe::ds::GenericCell_Int l1 = b9->data->head;
HXDLIN( 101)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 101)											{
HXLINE( 101)												int _g34 = 0;
HXDLIN( 101)												int _g35 = i15;
HXDLIN( 101)												while((_g34 < _g35)){
HXLINE( 101)													_g34 = (_g34 + 1);
HXDLIN( 101)													int i16 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 101)											if (::hx::IsNull( prev1 )) {
HXLINE( 101)												b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 101)												l1 = null();
            											}
            											else {
HXLINE( 101)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 101)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 101)						undoImage4 = b9;
            					}
            					break;
            				}
HXDLIN( 101)				this41->image = undoImage4;
HXDLIN( 101)				this41->width = width1;
HXDLIN( 101)				this41->height = height1;
HXDLIN( 101)				this41->imageType = ( (int)(imageType1) );
HXDLIN( 101)				undoImage3 = this41;
HXDLIN( 101)				{
HXLINE( 101)					int rectLeft1 = xIter31->start;
HXDLIN( 101)					int rectTop1 = yIter31->start;
HXDLIN( 101)					int rectRight1 = xIter31->max;
HXDLIN( 101)					bool forceClear1 = false;
HXDLIN( 101)					{
HXLINE( 101)						int _g36 = rectTop1;
HXDLIN( 101)						int _g37 = yIter31->max;
HXDLIN( 101)						while((_g36 < _g37)){
HXLINE( 101)							_g36 = (_g36 + 1);
HXDLIN( 101)							int dy2 = (_g36 - 1);
HXDLIN( 101)							{
HXLINE( 101)								int _g38 = rectLeft1;
HXDLIN( 101)								int _g39 = rectRight1;
HXDLIN( 101)								while((_g38 < _g39)){
HXLINE( 101)									_g38 = (_g38 + 1);
HXDLIN( 101)									int dx2 = (_g38 - 1);
HXDLIN( 101)									::Dynamic this43 = pixelImage->image;
HXDLIN( 101)									int index4;
HXDLIN( 101)									if (pixelImage->useVirtualPos) {
HXLINE( 101)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 101)										index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN( 101)									int c3 = ::iterMagic::Iimg_obj::get(this43,index4);
HXDLIN( 101)									int col1;
HXDLIN( 101)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 101)										col1 = c3;
            									}
HXDLIN( 101)									bool _hx_tmp13;
HXDLIN( 101)									if (pixelImage->useMask) {
HXLINE( 101)										_hx_tmp13 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 101)										_hx_tmp13 = false;
            									}
HXDLIN( 101)									if (_hx_tmp13) {
HXLINE( 101)										 ::pi_xy::ImageStruct this44 = pixelImage->mask;
HXDLIN( 101)										::Dynamic this45 = this44->image;
HXDLIN( 101)										int index5;
HXDLIN( 101)										if (this44->useVirtualPos) {
HXLINE( 101)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this44->virtualY) * ( (Float)(this44->width) )) + dx2) - this44->virtualX));
            										}
            										else {
HXLINE( 101)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this44->width) + dx2)) ));
            										}
HXDLIN( 101)										int c4 = ::iterMagic::Iimg_obj::get(this45,index5);
HXDLIN( 101)										int v4;
HXDLIN( 101)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)											v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 101)											v4 = c4;
            										}
HXDLIN( 101)										int maskPixel1 = v4;
HXDLIN( 101)										int this46 = col1;
HXDLIN( 101)										if ((maskPixel1 == 0)) {
HXLINE( 101)											col1 = this46;
            										}
            										else {
HXLINE( 101)											Float m01;
HXDLIN( 101)											int this47 = ((maskPixel1 >> 24) & 255);
HXDLIN( 101)											if ((this47 == 0)) {
HXLINE( 101)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												m01 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float m11;
HXDLIN( 101)											int this48 = ((maskPixel1 >> 16) & 255);
HXDLIN( 101)											if ((this48 == 0)) {
HXLINE( 101)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												m11 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float m21;
HXDLIN( 101)											int this49 = ((maskPixel1 >> 8) & 255);
HXDLIN( 101)											if ((this49 == 0)) {
HXLINE( 101)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												m21 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float m31;
HXDLIN( 101)											int this50 = (maskPixel1 & 255);
HXDLIN( 101)											if ((this50 == 0)) {
HXLINE( 101)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												m31 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this46 >> 24) & 255)) )));
HXDLIN( 101)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this46 >> 16) & 255)) )));
HXDLIN( 101)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this46 >> 8) & 255)) )));
HXDLIN( 101)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this46 & 255)) )));
HXDLIN( 101)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 101)									if ((col1 != 0)) {
HXLINE( 101)										int x4 = (dx2 - rectLeft1);
HXDLIN( 101)										int y4 = (dy2 - rectTop1);
HXDLIN( 101)										int c5 = col1;
HXDLIN( 101)										bool _hx_tmp14;
HXDLIN( 101)										if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 101)											_hx_tmp14 = undoImage3->transparent;
            										}
            										else {
HXLINE( 101)											_hx_tmp14 = false;
            										}
HXDLIN( 101)										if (_hx_tmp14) {
HXLINE( 101)											int location3;
HXDLIN( 101)											if (undoImage3->useVirtualPos) {
HXLINE( 101)												location3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 101)												location3 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 101)											int this51 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN( 101)											int this52;
HXDLIN( 101)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)												this52 = ((((((this51 >> 24) & 255) << 24) | ((this51 & 255) << 16)) | (((this51 >> 8) & 255) << 8)) | ((this51 >> 16) & 255));
            											}
            											else {
HXLINE( 101)												this52 = this51;
            											}
HXDLIN( 101)											Float a13;
HXDLIN( 101)											int this53 = ((this52 >> 24) & 255);
HXDLIN( 101)											if ((this53 == 0)) {
HXLINE( 101)												a13 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												a13 = (( (Float)(this53) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float r13;
HXDLIN( 101)											int this54 = ((this52 >> 16) & 255);
HXDLIN( 101)											if ((this54 == 0)) {
HXLINE( 101)												r13 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												r13 = (( (Float)(this54) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float g13;
HXDLIN( 101)											int this55 = ((this52 >> 8) & 255);
HXDLIN( 101)											if ((this55 == 0)) {
HXLINE( 101)												g13 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												g13 = (( (Float)(this55) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float b14;
HXDLIN( 101)											int this56 = (this52 & 255);
HXDLIN( 101)											if ((this56 == 0)) {
HXLINE( 101)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												b14 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float a23;
HXDLIN( 101)											int this57 = ((col1 >> 24) & 255);
HXDLIN( 101)											if ((this57 == 0)) {
HXLINE( 101)												a23 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												a23 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float r23;
HXDLIN( 101)											int this58 = ((col1 >> 16) & 255);
HXDLIN( 101)											if ((this58 == 0)) {
HXLINE( 101)												r23 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												r23 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float g23;
HXDLIN( 101)											int this59 = ((col1 >> 8) & 255);
HXDLIN( 101)											if ((this59 == 0)) {
HXLINE( 101)												g23 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												g23 = (( (Float)(this59) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float b24;
HXDLIN( 101)											int this60 = (col1 & 255);
HXDLIN( 101)											if ((this60 == 0)) {
HXLINE( 101)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												b24 = (( (Float)(this60) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 101)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 101)											int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 101)											int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 101)											int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 101)											int blended3 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 101)											{
HXLINE( 101)												int _hx_tmp15;
HXDLIN( 101)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)													_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE( 101)													_hx_tmp15 = blended3;
            												}
HXDLIN( 101)												::iterMagic::Iimg_obj::set(undoImage3->image,location3,_hx_tmp15);
            											}
            										}
            										else {
HXLINE( 101)											::Dynamic this61 = undoImage3->image;
HXDLIN( 101)											int index6;
HXDLIN( 101)											if (undoImage3->useVirtualPos) {
HXLINE( 101)												index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 101)												index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 101)											int _hx_tmp16;
HXDLIN( 101)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)												_hx_tmp16 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE( 101)												_hx_tmp16 = c5;
            											}
HXDLIN( 101)											::iterMagic::Iimg_obj::set(this61,index6,_hx_tmp16);
            										}
            									}
            									else {
HXLINE( 101)										if (forceClear1) {
HXLINE( 101)											::Dynamic this62 = undoImage3->image;
HXDLIN( 101)											int x5 = (dx2 - rectLeft1);
HXDLIN( 101)											int y5 = (dy2 - rectTop1);
HXDLIN( 101)											int index7;
HXDLIN( 101)											if (undoImage3->useVirtualPos) {
HXLINE( 101)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 101)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN( 101)											::iterMagic::Iimg_obj::set(this62,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 101)			bool found1 = false;
HXDLIN( 101)			Float min9 = ( (Float)(0) );
HXDLIN( 101)			Float max1 = ( (Float)(0) );
HXDLIN( 101)			int a10 = 0;
HXDLIN( 101)			int r7 = 0;
HXDLIN( 101)			int g7 = 0;
HXDLIN( 101)			int b15 = 0;
HXDLIN( 101)			{
HXLINE( 101)				int _g_min2 = xIter31->start;
HXDLIN( 101)				int _g_max2 = xIter31->max;
HXDLIN( 101)				while((_g_min2 < _g_max2)){
HXLINE( 101)					_g_min2 = (_g_min2 + 1);
HXDLIN( 101)					int px1 = (_g_min2 - 1);
HXDLIN( 101)					Float pcx1 = (( (Float)(px1) ) - ax);
HXLINE( 812)					found1 = false;
HXLINE( 101)					{
HXLINE( 101)						int _g_min3 = yIter31->start;
HXDLIN( 101)						int _g_max3 = yIter31->max;
HXDLIN( 101)						while((_g_min3 < _g_max3)){
HXLINE( 101)							_g_min3 = (_g_min3 + 1);
HXDLIN( 101)							int py1 = (_g_min3 - 1);
HXDLIN( 101)							Float pcy1 = (( (Float)(py1) ) - ay);
HXDLIN( 101)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 101)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 101)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 101)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 101)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 101)							bool _hx_tmp17;
HXDLIN( 101)							bool _hx_tmp18;
HXDLIN( 101)							if ((ratioA1 >= 0)) {
HXLINE( 101)								_hx_tmp18 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 101)								_hx_tmp18 = false;
            							}
HXDLIN( 101)							if (_hx_tmp18) {
HXLINE( 101)								_hx_tmp17 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 101)								_hx_tmp17 = false;
            							}
HXDLIN( 101)							if (_hx_tmp17) {
HXLINE( 101)								int i17 = ::Std_obj::_hx_int(( (Float)(rA1) ));
HXDLIN( 101)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE( 101)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE( 821)								r7 = i17;
HXLINE( 101)								int i18 = ::Std_obj::_hx_int(( (Float)(gA1) ));
HXDLIN( 101)								if ((i18 > 255)) {
HXLINE(  24)									i18 = 255;
            								}
HXLINE( 101)								if ((i18 < 0)) {
HXLINE(  25)									i18 = 0;
            								}
HXLINE( 822)								g7 = i18;
HXLINE( 101)								int i19 = ::Std_obj::_hx_int(( (Float)(bA1) ));
HXDLIN( 101)								if ((i19 > 255)) {
HXLINE(  24)									i19 = 255;
            								}
HXLINE( 101)								if ((i19 < 0)) {
HXLINE(  25)									i19 = 0;
            								}
HXLINE( 823)								b15 = i19;
HXLINE( 101)								bool _hx_tmp19;
HXDLIN( 101)								if ((softCD == true)) {
HXLINE( 101)									_hx_tmp19 = (softDA == true);
            								}
            								else {
HXLINE( 101)									_hx_tmp19 = false;
            								}
HXDLIN( 101)								if (_hx_tmp19) {
HXLINE( 101)									if ((ratioA1 < ratioC1)) {
HXLINE( 101)										min9 = ratioA1;
            									}
            									else {
HXLINE( 101)										min9 = ratioC1;
            									}
HXDLIN( 101)									if ((ratioA1 > ratioB1)) {
HXLINE( 101)										max1 = ratioA1;
            									}
            									else {
HXLINE( 101)										max1 = ratioB1;
            									}
HXDLIN( 101)									if (!((max1 > ratioC1))) {
HXLINE( 101)										max1 = ratioC1;
            									}
HXLINE( 829)									max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE( 101)									if (!((min9 < max1))) {
HXLINE( 101)										min9 = ((max1 + min9) / ( (Float)(2) ));
            									}
HXDLIN( 101)									int i20 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN( 101)									if ((i20 > 255)) {
HXLINE(  24)										i20 = 255;
            									}
HXLINE( 101)									if ((i20 < 0)) {
HXLINE(  25)										i20 = 0;
            									}
HXLINE( 832)									a10 = i20;
HXLINE( 101)									{
HXLINE( 101)										int location4;
HXDLIN( 101)										if (pixelImage->useVirtualPos) {
HXLINE( 101)											location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 101)											location4 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            										}
HXDLIN( 101)										bool _hx_tmp20;
HXDLIN( 101)										if (pixelImage->transparent) {
HXLINE( 101)											_hx_tmp20 = (a10 < 254);
            										}
            										else {
HXLINE( 101)											_hx_tmp20 = false;
            										}
HXDLIN( 101)										if (_hx_tmp20) {
HXLINE( 101)											int this63 = ::iterMagic::Iimg_obj::get(pixelImage->image,location4);
HXDLIN( 101)											int old2;
HXDLIN( 101)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)												old2 = ((((((this63 >> 24) & 255) << 24) | ((this63 & 255) << 16)) | (((this63 >> 8) & 255) << 8)) | ((this63 >> 16) & 255));
            											}
            											else {
HXLINE( 101)												old2 = this63;
            											}
HXDLIN( 101)											int rhs2 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 101)											Float a14;
HXDLIN( 101)											int this64 = ((old2 >> 24) & 255);
HXDLIN( 101)											if ((this64 == 0)) {
HXLINE( 101)												a14 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												a14 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float r14;
HXDLIN( 101)											int this65 = ((old2 >> 16) & 255);
HXDLIN( 101)											if ((this65 == 0)) {
HXLINE( 101)												r14 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												r14 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float g14;
HXDLIN( 101)											int this66 = ((old2 >> 8) & 255);
HXDLIN( 101)											if ((this66 == 0)) {
HXLINE( 101)												g14 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												g14 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float b16;
HXDLIN( 101)											int this67 = (old2 & 255);
HXDLIN( 101)											if ((this67 == 0)) {
HXLINE( 101)												b16 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												b16 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float a24;
HXDLIN( 101)											int this68 = ((rhs2 >> 24) & 255);
HXDLIN( 101)											if ((this68 == 0)) {
HXLINE( 101)												a24 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												a24 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float r24;
HXDLIN( 101)											int this69 = ((rhs2 >> 16) & 255);
HXDLIN( 101)											if ((this69 == 0)) {
HXLINE( 101)												r24 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												r24 = (( (Float)(this69) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float g24;
HXDLIN( 101)											int this70 = ((rhs2 >> 8) & 255);
HXDLIN( 101)											if ((this70 == 0)) {
HXLINE( 101)												g24 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												g24 = (( (Float)(this70) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float b25;
HXDLIN( 101)											int this71 = (rhs2 & 255);
HXDLIN( 101)											if ((this71 == 0)) {
HXLINE( 101)												b25 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												b25 = (( (Float)(this71) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 101)											int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 101)											int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 101)											int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a34) + (b25 * a24))));
HXDLIN( 101)											int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 101)											int blended4 = ((((a15 << 24) | (r8 << 16)) | (g8 << 8)) | b17);
HXDLIN( 101)											{
HXLINE( 101)												int _hx_tmp21;
HXDLIN( 101)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)													_hx_tmp21 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE( 101)													_hx_tmp21 = blended4;
            												}
HXDLIN( 101)												::iterMagic::Iimg_obj::set(pixelImage->image,location4,_hx_tmp21);
            											}
            										}
            										else {
HXLINE( 101)											int value2;
HXDLIN( 101)											if (pixelImage->isLittle) {
HXLINE( 101)												value2 = ((((a10 << 24) | (b15 << 16)) | (g7 << 8)) | r7);
            											}
            											else {
HXLINE( 101)												value2 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
            											}
HXDLIN( 101)											::iterMagic::Iimg_obj::set(pixelImage->image,location4,value2);
            										}
            									}
            								}
HXDLIN( 101)								bool _hx_tmp22;
HXDLIN( 101)								bool _hx_tmp23;
HXDLIN( 101)								if ((softCD == true)) {
HXLINE( 101)									_hx_tmp23 = false;
            								}
            								else {
HXLINE( 101)									_hx_tmp23 = false;
            								}
HXDLIN( 101)								if (_hx_tmp23) {
HXLINE( 101)									_hx_tmp22 = (softDA == false);
            								}
            								else {
HXLINE( 101)									_hx_tmp22 = false;
            								}
HXDLIN( 101)								if (_hx_tmp22) {
HXLINE( 101)									if ((ratioB1 < ratioC1)) {
HXLINE( 101)										min9 = ratioB1;
            									}
            									else {
HXLINE( 101)										min9 = ratioC1;
            									}
HXDLIN( 101)									if ((ratioA1 > ratioB1)) {
HXLINE( 101)										max1 = ratioA1;
            									}
            									else {
HXLINE( 101)										max1 = ratioB1;
            									}
HXDLIN( 101)									if (!((max1 > ratioC1))) {
HXLINE( 101)										max1 = ratioC1;
            									}
HXLINE( 842)									max1 = ((( (Float)(1) ) - max1) / ( (Float)(2) ));
HXLINE( 101)									if (!((min9 < max1))) {
HXLINE( 101)										min9 = ((max1 + min9) / ( (Float)(2) ));
            									}
HXDLIN( 101)									int i21 = ::Std_obj::_hx_int(((( (Float)(aA1) ) * soft) * min9));
HXDLIN( 101)									if ((i21 > 255)) {
HXLINE(  24)										i21 = 255;
            									}
HXLINE( 101)									if ((i21 < 0)) {
HXLINE(  25)										i21 = 0;
            									}
HXLINE( 845)									a10 = i21;
HXLINE( 101)									{
HXLINE( 101)										int location5;
HXDLIN( 101)										if (pixelImage->useVirtualPos) {
HXLINE( 101)											location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 101)											location5 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            										}
HXDLIN( 101)										bool _hx_tmp24;
HXDLIN( 101)										if (pixelImage->transparent) {
HXLINE( 101)											_hx_tmp24 = (a10 < 254);
            										}
            										else {
HXLINE( 101)											_hx_tmp24 = false;
            										}
HXDLIN( 101)										if (_hx_tmp24) {
HXLINE( 101)											int this72 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 101)											int old3;
HXDLIN( 101)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)												old3 = ((((((this72 >> 24) & 255) << 24) | ((this72 & 255) << 16)) | (((this72 >> 8) & 255) << 8)) | ((this72 >> 16) & 255));
            											}
            											else {
HXLINE( 101)												old3 = this72;
            											}
HXDLIN( 101)											int rhs3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 101)											Float a16;
HXDLIN( 101)											int this73 = ((old3 >> 24) & 255);
HXDLIN( 101)											if ((this73 == 0)) {
HXLINE( 101)												a16 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												a16 = (( (Float)(this73) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float r15;
HXDLIN( 101)											int this74 = ((old3 >> 16) & 255);
HXDLIN( 101)											if ((this74 == 0)) {
HXLINE( 101)												r15 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												r15 = (( (Float)(this74) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float g15;
HXDLIN( 101)											int this75 = ((old3 >> 8) & 255);
HXDLIN( 101)											if ((this75 == 0)) {
HXLINE( 101)												g15 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												g15 = (( (Float)(this75) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float b18;
HXDLIN( 101)											int this76 = (old3 & 255);
HXDLIN( 101)											if ((this76 == 0)) {
HXLINE( 101)												b18 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												b18 = (( (Float)(this76) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float a25;
HXDLIN( 101)											int this77 = ((rhs3 >> 24) & 255);
HXDLIN( 101)											if ((this77 == 0)) {
HXLINE( 101)												a25 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												a25 = (( (Float)(this77) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float r25;
HXDLIN( 101)											int this78 = ((rhs3 >> 16) & 255);
HXDLIN( 101)											if ((this78 == 0)) {
HXLINE( 101)												r25 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												r25 = (( (Float)(this78) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float g25;
HXDLIN( 101)											int this79 = ((rhs3 >> 8) & 255);
HXDLIN( 101)											if ((this79 == 0)) {
HXLINE( 101)												g25 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												g25 = (( (Float)(this79) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float b26;
HXDLIN( 101)											int this80 = (rhs3 & 255);
HXDLIN( 101)											if ((this80 == 0)) {
HXLINE( 101)												b26 = ((Float)0.);
            											}
            											else {
HXLINE( 101)												b26 = (( (Float)(this80) ) / ( (Float)(255) ));
            											}
HXDLIN( 101)											Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN( 101)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 101)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 101)											int b19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b18 * a35) + (b26 * a25))));
HXDLIN( 101)											int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 101)											int blended5 = ((((a17 << 24) | (r9 << 16)) | (g9 << 8)) | b19);
HXDLIN( 101)											{
HXLINE( 101)												int _hx_tmp25;
HXDLIN( 101)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 101)													_hx_tmp25 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            												}
            												else {
HXLINE( 101)													_hx_tmp25 = blended5;
            												}
HXDLIN( 101)												::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp25);
            											}
            										}
            										else {
HXLINE( 101)											int value3;
HXDLIN( 101)											if (pixelImage->isLittle) {
HXLINE( 101)												value3 = ((((a10 << 24) | (b15 << 16)) | (g7 << 8)) | r7);
            											}
            											else {
HXLINE( 101)												value3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
            											}
HXDLIN( 101)											::iterMagic::Iimg_obj::set(pixelImage->image,location5,value3);
            										}
            									}
            								}
HXLINE( 850)								found1 = true;
            							}
            							else {
HXLINE( 101)								if (found1) {
HXLINE( 101)									goto _hx_goto_98;
            								}
            							}
            						}
            						_hx_goto_98:;
            					}
            				}
            			}
HXDLIN( 101)			if ((hasHit == false)) {
HXLINE( 101)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,dx,dy,cx,cy,ax,ay,true);
HXDLIN( 101)				if (hasUndo1) {
HXLINE( 101)					v5->undoImage = undoImage3;
HXDLIN( 101)					v5->undoX = xIter31->start;
HXDLIN( 101)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXLINE( 104)		{
HXLINE( 104)			bool hasUndo2 = true;
HXDLIN( 104)			int aA2 = ((color >> 24) & 255);
HXDLIN( 104)			int rA2 = ((color >> 16) & 255);
HXDLIN( 104)			int gA2 = ((color >> 8) & 255);
HXDLIN( 104)			int bA2 = (color & 255);
HXDLIN( 104)			Float bcx2 = (bx - dx);
HXDLIN( 104)			Float bcy2 = (by - dy);
HXDLIN( 104)			Float acx2 = (ax - dx);
HXDLIN( 104)			Float acy2 = (ay - dy);
HXDLIN( 104)			Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 104)			Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 104)			Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 104)			Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 104)			 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 104)			if ((ax > bx)) {
HXLINE( 104)				if ((ax > dx)) {
HXLINE( 104)					int min10;
HXDLIN( 104)					if ((bx > dx)) {
HXLINE( 104)						min10 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 104)						min10 = ::Math_obj::floor(bx);
            					}
HXDLIN( 104)					int ii_min16 = min10;
HXDLIN( 104)					int ii_max16 = ::Math_obj::ceil(ax);
HXDLIN( 104)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            				}
            				else {
HXLINE( 104)					int ii_min17 = ::Math_obj::floor(bx);
HXDLIN( 104)					int ii_max17 = ::Math_obj::ceil(dx);
HXDLIN( 104)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            				}
            			}
            			else {
HXLINE( 104)				if ((bx > dx)) {
HXLINE( 104)					int min11;
HXDLIN( 104)					if ((ax > dx)) {
HXLINE( 104)						min11 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 104)						min11 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 104)					int ii_min18 = min11;
HXDLIN( 104)					int ii_max18 = ::Math_obj::ceil(bx);
HXDLIN( 104)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            				}
            				else {
HXLINE( 104)					int ii_min19 = ::Math_obj::floor(ax);
HXDLIN( 104)					int ii_max19 = ::Math_obj::ceil(dx);
HXDLIN( 104)					xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            				}
            			}
HXDLIN( 104)			 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 104)			if ((ay > by)) {
HXLINE( 104)				if ((ay > dy)) {
HXLINE( 104)					int min12;
HXDLIN( 104)					if ((by > dy)) {
HXLINE( 104)						min12 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 104)						min12 = ::Math_obj::floor(by);
            					}
HXDLIN( 104)					int ii_min20 = min12;
HXDLIN( 104)					int ii_max20 = ::Math_obj::ceil(ay);
HXDLIN( 104)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            				}
            				else {
HXLINE( 104)					int ii_min21 = ::Math_obj::floor(by);
HXDLIN( 104)					int ii_max21 = ::Math_obj::ceil(dy);
HXDLIN( 104)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            				}
            			}
            			else {
HXLINE( 104)				if ((by > dy)) {
HXLINE( 104)					int min13;
HXDLIN( 104)					if ((ay > dy)) {
HXLINE( 104)						min13 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 104)						min13 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 104)					int ii_min22 = min13;
HXDLIN( 104)					int ii_max22 = ::Math_obj::ceil(by);
HXDLIN( 104)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            				}
            				else {
HXLINE( 104)					int ii_min23 = ::Math_obj::floor(ay);
HXDLIN( 104)					int ii_max23 = ::Math_obj::ceil(dy);
HXDLIN( 104)					yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            				}
            			}
HXDLIN( 104)			 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 104)			if (hasUndo2) {
HXLINE( 104)				int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 104)				int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 104)				 ::Dynamic imageType2 = null();
HXDLIN( 104)				 ::pi_xy::ImageStruct this81 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 104)				if (::hx::IsNull( imageType2 )) {
HXLINE(  54)					imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 104)				::Dynamic undoImage7;
HXDLIN( 104)				switch((int)(( (int)(imageType2) ))){
            					case (int)0: {
HXLINE( 104)						 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 104)						 ::iterMagic::BytesImg b20 = byt2;
HXDLIN( 104)						{
HXLINE( 104)							b20->width = width2;
HXDLIN( 104)							b20->height = height2;
HXDLIN( 104)							b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 104)							b20->data = ::haxe::io::Bytes_obj::alloc((b20->length * 4));
HXDLIN( 104)							{
HXLINE( 104)								int len4 = b20->length;
HXDLIN( 104)								int w2 = 0;
HXDLIN( 104)								{
HXLINE( 104)									int _g40 = 0;
HXDLIN( 104)									int _g41 = b20->height;
HXDLIN( 104)									while((_g40 < _g41)){
HXLINE( 104)										_g40 = (_g40 + 1);
HXDLIN( 104)										int y6 = (_g40 - 1);
HXDLIN( 104)										{
HXLINE( 104)											int _g42 = 0;
HXDLIN( 104)											int _g43 = b20->width;
HXDLIN( 104)											while((_g42 < _g43)){
HXLINE( 104)												_g42 = (_g42 + 1);
HXDLIN( 104)												int x6 = (_g42 - 1);
HXDLIN( 104)												{
HXLINE( 104)													w2 = (w2 + 1);
HXDLIN( 104)													b20->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 104)												{
HXLINE( 104)													w2 = (w2 + 1);
HXDLIN( 104)													b20->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 104)												{
HXLINE( 104)													w2 = (w2 + 1);
HXDLIN( 104)													b20->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 104)												{
HXLINE( 104)													w2 = (w2 + 1);
HXDLIN( 104)													b20->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 104)						undoImage7 = b20;
            					}
            					break;
            					case (int)1: {
HXLINE( 104)						 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 104)						 ::iterMagic::ArrIntImg a18 = arrI2;
HXDLIN( 104)						{
HXLINE( 104)							a18->width = width2;
HXDLIN( 104)							a18->height = height2;
HXDLIN( 104)							a18->data = ::Array_obj< int >::__new(0);
HXDLIN( 104)							a18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 104)							{
HXLINE( 104)								int _g44 = 0;
HXDLIN( 104)								int _g45 = a18->length;
HXDLIN( 104)								while((_g44 < _g45)){
HXLINE( 104)									_g44 = (_g44 + 1);
HXDLIN( 104)									int i22 = (_g44 - 1);
HXDLIN( 104)									a18->data[i22] = 0;
            								}
            							}
            						}
HXDLIN( 104)						undoImage7 = a18;
            					}
            					break;
            					case (int)2: {
HXLINE( 104)						 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 104)						 ::iterMagic::U32ArrImg b27 = u32a2;
HXDLIN( 104)						{
HXLINE( 104)							b27->width = width2;
HXDLIN( 104)							b27->height = height2;
HXDLIN( 104)							b27->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 104)							int size2 = (b27->length * 4);
HXDLIN( 104)							b27->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 104)							{
HXLINE( 104)								int _g46 = 0;
HXDLIN( 104)								int _g47 = b27->length;
HXDLIN( 104)								while((_g46 < _g47)){
HXLINE( 104)									_g46 = (_g46 + 1);
HXDLIN( 104)									int i23 = (_g46 - 1);
HXDLIN( 104)									{
HXLINE( 104)										 ::haxe::io::ArrayBufferViewImpl this82 = b27->data;
HXDLIN( 104)										bool undoImage8;
HXDLIN( 104)										if ((i23 >= 0)) {
HXLINE( 104)											undoImage8 = (i23 < (this82->byteLength >> 2));
            										}
            										else {
HXLINE( 104)											undoImage8 = false;
            										}
HXDLIN( 104)										if (undoImage8) {
HXLINE( 104)											 ::haxe::io::Bytes _this2 = this82->bytes;
HXDLIN( 104)											int pos2 = ((i23 << 2) + this82->byteOffset);
HXDLIN( 104)											_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 104)											_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 104)											_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 104)											_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 104)						undoImage7 = b27;
            					}
            					break;
            					case (int)3: {
HXLINE( 104)						 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 104)						 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN( 104)						{
HXLINE( 104)							v6->width = width2;
HXDLIN( 104)							v6->height = height2;
HXDLIN( 104)							v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 104)							v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 104)							{
HXLINE( 104)								int _g48 = 0;
HXDLIN( 104)								int _g49 = v6->length;
HXDLIN( 104)								while((_g48 < _g49)){
HXLINE( 104)									_g48 = (_g48 + 1);
HXDLIN( 104)									int i24 = (_g48 - 1);
HXDLIN( 104)									v6->data->__unsafe_set(i24,0);
            								}
            							}
            						}
HXDLIN( 104)						undoImage7 = v6;
            					}
            					break;
            					case (int)4: {
HXLINE( 104)						 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 104)						 ::iterMagic::StackIntImg b28 = sInt2;
HXDLIN( 104)						{
HXLINE( 104)							b28->width = width2;
HXDLIN( 104)							b28->height = height2;
HXDLIN( 104)							b28->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 104)							b28->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 104)							{
HXLINE( 104)								int len5 = b28->length;
HXDLIN( 104)								 ::haxe::ds::GenericStack_Int d2 = b28->data;
HXDLIN( 104)								if (::hx::IsNull( d2->head )) {
HXLINE( 104)									int _g50 = 0;
HXDLIN( 104)									int _g51 = len5;
HXDLIN( 104)									while((_g50 < _g51)){
HXLINE( 104)										_g50 = (_g50 + 1);
HXDLIN( 104)										int i25 = (_g50 - 1);
HXDLIN( 104)										d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            									}
            								}
            								else {
HXLINE( 104)									int _g52 = 0;
HXDLIN( 104)									int _g53 = len5;
HXDLIN( 104)									while((_g52 < _g53)){
HXLINE( 104)										_g52 = (_g52 + 1);
HXDLIN( 104)										int i26 = (_g52 - 1);
HXDLIN( 104)										{
HXLINE( 104)											 ::haxe::ds::GenericCell_Int l2 = b28->data->head;
HXDLIN( 104)											 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 104)											{
HXLINE( 104)												int _g54 = 0;
HXDLIN( 104)												int _g55 = i26;
HXDLIN( 104)												while((_g54 < _g55)){
HXLINE( 104)													_g54 = (_g54 + 1);
HXDLIN( 104)													int i27 = (_g54 - 1);
HXLINE( 345)													prev2 = l2;
HXLINE( 346)													l2 = l2->next;
            												}
            											}
HXLINE( 104)											if (::hx::IsNull( prev2 )) {
HXLINE( 104)												b28->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 104)												l2 = null();
            											}
            											else {
HXLINE( 104)												prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 104)												l2 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 104)						undoImage7 = b28;
            					}
            					break;
            				}
HXDLIN( 104)				this81->image = undoImage7;
HXDLIN( 104)				this81->width = width2;
HXDLIN( 104)				this81->height = height2;
HXDLIN( 104)				this81->imageType = ( (int)(imageType2) );
HXDLIN( 104)				undoImage6 = this81;
HXDLIN( 104)				{
HXLINE( 104)					int rectLeft2 = xIter32->start;
HXDLIN( 104)					int rectTop2 = yIter32->start;
HXDLIN( 104)					int rectRight2 = xIter32->max;
HXDLIN( 104)					bool forceClear2 = false;
HXDLIN( 104)					{
HXLINE( 104)						int _g56 = rectTop2;
HXDLIN( 104)						int _g57 = yIter32->max;
HXDLIN( 104)						while((_g56 < _g57)){
HXLINE( 104)							_g56 = (_g56 + 1);
HXDLIN( 104)							int dy3 = (_g56 - 1);
HXDLIN( 104)							{
HXLINE( 104)								int _g58 = rectLeft2;
HXDLIN( 104)								int _g59 = rectRight2;
HXDLIN( 104)								while((_g58 < _g59)){
HXLINE( 104)									_g58 = (_g58 + 1);
HXDLIN( 104)									int dx3 = (_g58 - 1);
HXDLIN( 104)									::Dynamic this83 = pixelImage->image;
HXDLIN( 104)									int index8;
HXDLIN( 104)									if (pixelImage->useVirtualPos) {
HXLINE( 104)										index8 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx3) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 104)										index8 = ::Std_obj::_hx_int(( (Float)(((dy3 * pixelImage->width) + dx3)) ));
            									}
HXDLIN( 104)									int c6 = ::iterMagic::Iimg_obj::get(this83,index8);
HXDLIN( 104)									int col2;
HXDLIN( 104)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)										col2 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE( 104)										col2 = c6;
            									}
HXDLIN( 104)									bool _hx_tmp26;
HXDLIN( 104)									if (pixelImage->useMask) {
HXLINE( 104)										_hx_tmp26 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 104)										_hx_tmp26 = false;
            									}
HXDLIN( 104)									if (_hx_tmp26) {
HXLINE( 104)										 ::pi_xy::ImageStruct this84 = pixelImage->mask;
HXDLIN( 104)										::Dynamic this85 = this84->image;
HXDLIN( 104)										int index9;
HXDLIN( 104)										if (this84->useVirtualPos) {
HXLINE( 104)											index9 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this84->virtualY) * ( (Float)(this84->width) )) + dx3) - this84->virtualX));
            										}
            										else {
HXLINE( 104)											index9 = ::Std_obj::_hx_int(( (Float)(((dy3 * this84->width) + dx3)) ));
            										}
HXDLIN( 104)										int c7 = ::iterMagic::Iimg_obj::get(this85,index9);
HXDLIN( 104)										int v7;
HXDLIN( 104)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)											v7 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE( 104)											v7 = c7;
            										}
HXDLIN( 104)										int maskPixel2 = v7;
HXDLIN( 104)										int this86 = col2;
HXDLIN( 104)										if ((maskPixel2 == 0)) {
HXLINE( 104)											col2 = this86;
            										}
            										else {
HXLINE( 104)											Float m02;
HXDLIN( 104)											int this87 = ((maskPixel2 >> 24) & 255);
HXDLIN( 104)											if ((this87 == 0)) {
HXLINE( 104)												m02 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												m02 = (( (Float)(this87) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float m12;
HXDLIN( 104)											int this88 = ((maskPixel2 >> 16) & 255);
HXDLIN( 104)											if ((this88 == 0)) {
HXLINE( 104)												m12 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												m12 = (( (Float)(this88) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float m22;
HXDLIN( 104)											int this89 = ((maskPixel2 >> 8) & 255);
HXDLIN( 104)											if ((this89 == 0)) {
HXLINE( 104)												m22 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												m22 = (( (Float)(this89) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float m32;
HXDLIN( 104)											int this90 = (maskPixel2 & 255);
HXDLIN( 104)											if ((this90 == 0)) {
HXLINE( 104)												m32 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												m32 = (( (Float)(this90) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this86 >> 24) & 255)) )));
HXDLIN( 104)											int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this86 >> 16) & 255)) )));
HXDLIN( 104)											int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this86 >> 8) & 255)) )));
HXDLIN( 104)											int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this86 & 255)) )));
HXDLIN( 104)											col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 104)									if ((col2 != 0)) {
HXLINE( 104)										int x7 = (dx3 - rectLeft2);
HXDLIN( 104)										int y7 = (dy3 - rectTop2);
HXDLIN( 104)										int c8 = col2;
HXDLIN( 104)										bool _hx_tmp27;
HXDLIN( 104)										if ((((c8 >> 24) & 255) < 254)) {
HXLINE( 104)											_hx_tmp27 = undoImage6->transparent;
            										}
            										else {
HXLINE( 104)											_hx_tmp27 = false;
            										}
HXDLIN( 104)										if (_hx_tmp27) {
HXLINE( 104)											int location6;
HXDLIN( 104)											if (undoImage6->useVirtualPos) {
HXLINE( 104)												location6 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 104)												location6 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            											}
HXDLIN( 104)											int this91 = ::iterMagic::Iimg_obj::get(undoImage6->image,location6);
HXDLIN( 104)											int this92;
HXDLIN( 104)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)												this92 = ((((((this91 >> 24) & 255) << 24) | ((this91 & 255) << 16)) | (((this91 >> 8) & 255) << 8)) | ((this91 >> 16) & 255));
            											}
            											else {
HXLINE( 104)												this92 = this91;
            											}
HXDLIN( 104)											Float a19;
HXDLIN( 104)											int this93 = ((this92 >> 24) & 255);
HXDLIN( 104)											if ((this93 == 0)) {
HXLINE( 104)												a19 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												a19 = (( (Float)(this93) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float r16;
HXDLIN( 104)											int this94 = ((this92 >> 16) & 255);
HXDLIN( 104)											if ((this94 == 0)) {
HXLINE( 104)												r16 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												r16 = (( (Float)(this94) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float g16;
HXDLIN( 104)											int this95 = ((this92 >> 8) & 255);
HXDLIN( 104)											if ((this95 == 0)) {
HXLINE( 104)												g16 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												g16 = (( (Float)(this95) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float b110;
HXDLIN( 104)											int this96 = (this92 & 255);
HXDLIN( 104)											if ((this96 == 0)) {
HXLINE( 104)												b110 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												b110 = (( (Float)(this96) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float a26;
HXDLIN( 104)											int this97 = ((col2 >> 24) & 255);
HXDLIN( 104)											if ((this97 == 0)) {
HXLINE( 104)												a26 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												a26 = (( (Float)(this97) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float r26;
HXDLIN( 104)											int this98 = ((col2 >> 16) & 255);
HXDLIN( 104)											if ((this98 == 0)) {
HXLINE( 104)												r26 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												r26 = (( (Float)(this98) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float g26;
HXDLIN( 104)											int this99 = ((col2 >> 8) & 255);
HXDLIN( 104)											if ((this99 == 0)) {
HXLINE( 104)												g26 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												g26 = (( (Float)(this99) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float b29;
HXDLIN( 104)											int this100 = (col2 & 255);
HXDLIN( 104)											if ((this100 == 0)) {
HXLINE( 104)												b29 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												b29 = (( (Float)(this100) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float a36 = (a19 * (( (Float)(1) ) - a26));
HXDLIN( 104)											int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 104)											int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 104)											int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b29 * a26))));
HXDLIN( 104)											int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 104)											int blended6 = ((((a20 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN( 104)											{
HXLINE( 104)												int _hx_tmp28;
HXDLIN( 104)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)													_hx_tmp28 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXLINE( 104)													_hx_tmp28 = blended6;
            												}
HXDLIN( 104)												::iterMagic::Iimg_obj::set(undoImage6->image,location6,_hx_tmp28);
            											}
            										}
            										else {
HXLINE( 104)											::Dynamic this101 = undoImage6->image;
HXDLIN( 104)											int index10;
HXDLIN( 104)											if (undoImage6->useVirtualPos) {
HXLINE( 104)												index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x7) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 104)												index10 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage6->width) + x7)) ));
            											}
HXDLIN( 104)											int _hx_tmp29;
HXDLIN( 104)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)												_hx_tmp29 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXLINE( 104)												_hx_tmp29 = c8;
            											}
HXDLIN( 104)											::iterMagic::Iimg_obj::set(this101,index10,_hx_tmp29);
            										}
            									}
            									else {
HXLINE( 104)										if (forceClear2) {
HXLINE( 104)											::Dynamic this102 = undoImage6->image;
HXDLIN( 104)											int x8 = (dx3 - rectLeft2);
HXDLIN( 104)											int y8 = (dy3 - rectTop2);
HXDLIN( 104)											int index11;
HXDLIN( 104)											if (undoImage6->useVirtualPos) {
HXLINE( 104)												index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x8) - undoImage6->virtualX));
            											}
            											else {
HXLINE( 104)												index11 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage6->width) + x8)) ));
            											}
HXDLIN( 104)											::iterMagic::Iimg_obj::set(this102,index11,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 104)			bool found2 = false;
HXDLIN( 104)			Float min14 = ( (Float)(0) );
HXDLIN( 104)			Float max2 = ( (Float)(0) );
HXDLIN( 104)			int a27 = 0;
HXDLIN( 104)			int r17 = 0;
HXDLIN( 104)			int g17 = 0;
HXDLIN( 104)			int b31 = 0;
HXDLIN( 104)			{
HXLINE( 104)				int _g_min4 = xIter32->start;
HXDLIN( 104)				int _g_max4 = xIter32->max;
HXDLIN( 104)				while((_g_min4 < _g_max4)){
HXLINE( 104)					_g_min4 = (_g_min4 + 1);
HXDLIN( 104)					int px2 = (_g_min4 - 1);
HXDLIN( 104)					Float pcx2 = (( (Float)(px2) ) - dx);
HXLINE( 812)					found2 = false;
HXLINE( 104)					{
HXLINE( 104)						int _g_min5 = yIter32->start;
HXDLIN( 104)						int _g_max5 = yIter32->max;
HXDLIN( 104)						while((_g_min5 < _g_max5)){
HXLINE( 104)							_g_min5 = (_g_min5 + 1);
HXDLIN( 104)							int py2 = (_g_min5 - 1);
HXDLIN( 104)							Float pcy2 = (( (Float)(py2) ) - dy);
HXDLIN( 104)							Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 104)							Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 104)							Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 104)							Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 104)							Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 104)							bool _hx_tmp30;
HXDLIN( 104)							bool _hx_tmp31;
HXDLIN( 104)							if ((ratioA2 >= 0)) {
HXLINE( 104)								_hx_tmp31 = (ratioB2 >= 0);
            							}
            							else {
HXLINE( 104)								_hx_tmp31 = false;
            							}
HXDLIN( 104)							if (_hx_tmp31) {
HXLINE( 104)								_hx_tmp30 = (ratioC2 >= 0);
            							}
            							else {
HXLINE( 104)								_hx_tmp30 = false;
            							}
HXDLIN( 104)							if (_hx_tmp30) {
HXLINE( 104)								int i28 = ::Std_obj::_hx_int(( (Float)(rA2) ));
HXDLIN( 104)								if ((i28 > 255)) {
HXLINE(  24)									i28 = 255;
            								}
HXLINE( 104)								if ((i28 < 0)) {
HXLINE(  25)									i28 = 0;
            								}
HXLINE( 821)								r17 = i28;
HXLINE( 104)								int i29 = ::Std_obj::_hx_int(( (Float)(gA2) ));
HXDLIN( 104)								if ((i29 > 255)) {
HXLINE(  24)									i29 = 255;
            								}
HXLINE( 104)								if ((i29 < 0)) {
HXLINE(  25)									i29 = 0;
            								}
HXLINE( 822)								g17 = i29;
HXLINE( 104)								int i30 = ::Std_obj::_hx_int(( (Float)(bA2) ));
HXDLIN( 104)								if ((i30 > 255)) {
HXLINE(  24)									i30 = 255;
            								}
HXLINE( 104)								if ((i30 < 0)) {
HXLINE(  25)									i30 = 0;
            								}
HXLINE( 823)								b31 = i30;
HXLINE( 104)								bool _hx_tmp32;
HXDLIN( 104)								if ((softAB == true)) {
HXLINE( 104)									_hx_tmp32 = (softDA == true);
            								}
            								else {
HXLINE( 104)									_hx_tmp32 = false;
            								}
HXDLIN( 104)								if (_hx_tmp32) {
HXLINE( 104)									if ((ratioA2 < ratioC2)) {
HXLINE( 104)										min14 = ratioA2;
            									}
            									else {
HXLINE( 104)										min14 = ratioC2;
            									}
HXDLIN( 104)									if ((ratioA2 > ratioB2)) {
HXLINE( 104)										max2 = ratioA2;
            									}
            									else {
HXLINE( 104)										max2 = ratioB2;
            									}
HXDLIN( 104)									if (!((max2 > ratioC2))) {
HXLINE( 104)										max2 = ratioC2;
            									}
HXLINE( 829)									max2 = ((( (Float)(1) ) - max2) / ( (Float)(2) ));
HXLINE( 104)									if (!((min14 < max2))) {
HXLINE( 104)										min14 = ((max2 + min14) / ( (Float)(2) ));
            									}
HXDLIN( 104)									int i31 = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min14));
HXDLIN( 104)									if ((i31 > 255)) {
HXLINE(  24)										i31 = 255;
            									}
HXLINE( 104)									if ((i31 < 0)) {
HXLINE(  25)										i31 = 0;
            									}
HXLINE( 832)									a27 = i31;
HXLINE( 104)									{
HXLINE( 104)										int location7;
HXDLIN( 104)										if (pixelImage->useVirtualPos) {
HXLINE( 104)											location7 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 104)											location7 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            										}
HXDLIN( 104)										bool _hx_tmp33;
HXDLIN( 104)										if (pixelImage->transparent) {
HXLINE( 104)											_hx_tmp33 = (a27 < 254);
            										}
            										else {
HXLINE( 104)											_hx_tmp33 = false;
            										}
HXDLIN( 104)										if (_hx_tmp33) {
HXLINE( 104)											int this103 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN( 104)											int old4;
HXDLIN( 104)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)												old4 = ((((((this103 >> 24) & 255) << 24) | ((this103 & 255) << 16)) | (((this103 >> 8) & 255) << 8)) | ((this103 >> 16) & 255));
            											}
            											else {
HXLINE( 104)												old4 = this103;
            											}
HXDLIN( 104)											int rhs4 = ((((a27 << 24) | (r17 << 16)) | (g17 << 8)) | b31);
HXDLIN( 104)											Float a110;
HXDLIN( 104)											int this104 = ((old4 >> 24) & 255);
HXDLIN( 104)											if ((this104 == 0)) {
HXLINE( 104)												a110 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												a110 = (( (Float)(this104) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float r18;
HXDLIN( 104)											int this105 = ((old4 >> 16) & 255);
HXDLIN( 104)											if ((this105 == 0)) {
HXLINE( 104)												r18 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												r18 = (( (Float)(this105) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float g18;
HXDLIN( 104)											int this106 = ((old4 >> 8) & 255);
HXDLIN( 104)											if ((this106 == 0)) {
HXLINE( 104)												g18 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												g18 = (( (Float)(this106) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float b111;
HXDLIN( 104)											int this107 = (old4 & 255);
HXDLIN( 104)											if ((this107 == 0)) {
HXLINE( 104)												b111 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												b111 = (( (Float)(this107) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float a28;
HXDLIN( 104)											int this108 = ((rhs4 >> 24) & 255);
HXDLIN( 104)											if ((this108 == 0)) {
HXLINE( 104)												a28 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												a28 = (( (Float)(this108) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float r27;
HXDLIN( 104)											int this109 = ((rhs4 >> 16) & 255);
HXDLIN( 104)											if ((this109 == 0)) {
HXLINE( 104)												r27 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												r27 = (( (Float)(this109) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float g27;
HXDLIN( 104)											int this110 = ((rhs4 >> 8) & 255);
HXDLIN( 104)											if ((this110 == 0)) {
HXLINE( 104)												g27 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												g27 = (( (Float)(this110) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float b210;
HXDLIN( 104)											int this111 = (rhs4 & 255);
HXDLIN( 104)											if ((this111 == 0)) {
HXLINE( 104)												b210 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												b210 = (( (Float)(this111) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float a37 = (a110 * (( (Float)(1) ) - a28));
HXDLIN( 104)											int r19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a37) + (r27 * a28))));
HXDLIN( 104)											int g19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a37) + (g27 * a28))));
HXDLIN( 104)											int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b210 * a28))));
HXDLIN( 104)											int a29 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a28)));
HXDLIN( 104)											int blended7 = ((((a29 << 24) | (r19 << 16)) | (g19 << 8)) | b32);
HXDLIN( 104)											{
HXLINE( 104)												int _hx_tmp34;
HXDLIN( 104)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)													_hx_tmp34 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            												}
            												else {
HXLINE( 104)													_hx_tmp34 = blended7;
            												}
HXDLIN( 104)												::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp34);
            											}
            										}
            										else {
HXLINE( 104)											int value4;
HXDLIN( 104)											if (pixelImage->isLittle) {
HXLINE( 104)												value4 = ((((a27 << 24) | (b31 << 16)) | (g17 << 8)) | r17);
            											}
            											else {
HXLINE( 104)												value4 = ((((a27 << 24) | (r17 << 16)) | (g17 << 8)) | b31);
            											}
HXDLIN( 104)											::iterMagic::Iimg_obj::set(pixelImage->image,location7,value4);
            										}
            									}
            								}
HXDLIN( 104)								bool _hx_tmp35;
HXDLIN( 104)								bool _hx_tmp36;
HXDLIN( 104)								if ((softAB == true)) {
HXLINE( 104)									_hx_tmp36 = false;
            								}
            								else {
HXLINE( 104)									_hx_tmp36 = false;
            								}
HXDLIN( 104)								if (_hx_tmp36) {
HXLINE( 104)									_hx_tmp35 = (softDA == false);
            								}
            								else {
HXLINE( 104)									_hx_tmp35 = false;
            								}
HXDLIN( 104)								if (_hx_tmp35) {
HXLINE( 104)									if ((ratioB2 < ratioC2)) {
HXLINE( 104)										min14 = ratioB2;
            									}
            									else {
HXLINE( 104)										min14 = ratioC2;
            									}
HXDLIN( 104)									if ((ratioA2 > ratioB2)) {
HXLINE( 104)										max2 = ratioA2;
            									}
            									else {
HXLINE( 104)										max2 = ratioB2;
            									}
HXDLIN( 104)									if (!((max2 > ratioC2))) {
HXLINE( 104)										max2 = ratioC2;
            									}
HXLINE( 842)									max2 = ((( (Float)(1) ) - max2) / ( (Float)(2) ));
HXLINE( 104)									if (!((min14 < max2))) {
HXLINE( 104)										min14 = ((max2 + min14) / ( (Float)(2) ));
            									}
HXDLIN( 104)									int i32 = ::Std_obj::_hx_int(((( (Float)(aA2) ) * soft) * min14));
HXDLIN( 104)									if ((i32 > 255)) {
HXLINE(  24)										i32 = 255;
            									}
HXLINE( 104)									if ((i32 < 0)) {
HXLINE(  25)										i32 = 0;
            									}
HXLINE( 845)									a27 = i32;
HXLINE( 104)									{
HXLINE( 104)										int location8;
HXDLIN( 104)										if (pixelImage->useVirtualPos) {
HXLINE( 104)											location8 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 104)											location8 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            										}
HXDLIN( 104)										bool _hx_tmp37;
HXDLIN( 104)										if (pixelImage->transparent) {
HXLINE( 104)											_hx_tmp37 = (a27 < 254);
            										}
            										else {
HXLINE( 104)											_hx_tmp37 = false;
            										}
HXDLIN( 104)										if (_hx_tmp37) {
HXLINE( 104)											int this112 = ::iterMagic::Iimg_obj::get(pixelImage->image,location8);
HXDLIN( 104)											int old5;
HXDLIN( 104)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)												old5 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            											}
            											else {
HXLINE( 104)												old5 = this112;
            											}
HXDLIN( 104)											int rhs5 = ((((a27 << 24) | (r17 << 16)) | (g17 << 8)) | b31);
HXDLIN( 104)											Float a111;
HXDLIN( 104)											int this113 = ((old5 >> 24) & 255);
HXDLIN( 104)											if ((this113 == 0)) {
HXLINE( 104)												a111 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												a111 = (( (Float)(this113) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float r110;
HXDLIN( 104)											int this114 = ((old5 >> 16) & 255);
HXDLIN( 104)											if ((this114 == 0)) {
HXLINE( 104)												r110 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												r110 = (( (Float)(this114) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float g110;
HXDLIN( 104)											int this115 = ((old5 >> 8) & 255);
HXDLIN( 104)											if ((this115 == 0)) {
HXLINE( 104)												g110 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												g110 = (( (Float)(this115) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float b112;
HXDLIN( 104)											int this116 = (old5 & 255);
HXDLIN( 104)											if ((this116 == 0)) {
HXLINE( 104)												b112 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												b112 = (( (Float)(this116) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float a210;
HXDLIN( 104)											int this117 = ((rhs5 >> 24) & 255);
HXDLIN( 104)											if ((this117 == 0)) {
HXLINE( 104)												a210 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												a210 = (( (Float)(this117) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float r28;
HXDLIN( 104)											int this118 = ((rhs5 >> 16) & 255);
HXDLIN( 104)											if ((this118 == 0)) {
HXLINE( 104)												r28 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												r28 = (( (Float)(this118) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float g28;
HXDLIN( 104)											int this119 = ((rhs5 >> 8) & 255);
HXDLIN( 104)											if ((this119 == 0)) {
HXLINE( 104)												g28 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												g28 = (( (Float)(this119) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float b211;
HXDLIN( 104)											int this120 = (rhs5 & 255);
HXDLIN( 104)											if ((this120 == 0)) {
HXLINE( 104)												b211 = ((Float)0.);
            											}
            											else {
HXLINE( 104)												b211 = (( (Float)(this120) ) / ( (Float)(255) ));
            											}
HXDLIN( 104)											Float a38 = (a111 * (( (Float)(1) ) - a210));
HXDLIN( 104)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a38) + (r28 * a210))));
HXDLIN( 104)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a38) + (g28 * a210))));
HXDLIN( 104)											int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a38) + (b211 * a210))));
HXDLIN( 104)											int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN( 104)											int blended8 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b33);
HXDLIN( 104)											{
HXLINE( 104)												int _hx_tmp38;
HXDLIN( 104)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 104)													_hx_tmp38 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXLINE( 104)													_hx_tmp38 = blended8;
            												}
HXDLIN( 104)												::iterMagic::Iimg_obj::set(pixelImage->image,location8,_hx_tmp38);
            											}
            										}
            										else {
HXLINE( 104)											int value5;
HXDLIN( 104)											if (pixelImage->isLittle) {
HXLINE( 104)												value5 = ((((a27 << 24) | (b31 << 16)) | (g17 << 8)) | r17);
            											}
            											else {
HXLINE( 104)												value5 = ((((a27 << 24) | (r17 << 16)) | (g17 << 8)) | b31);
            											}
HXDLIN( 104)											::iterMagic::Iimg_obj::set(pixelImage->image,location8,value5);
            										}
            									}
            								}
HXLINE( 850)								found2 = true;
            							}
            							else {
HXLINE( 104)								if (found2) {
HXLINE( 104)									goto _hx_goto_110;
            								}
            							}
            						}
            						_hx_goto_110:;
            					}
            				}
            			}
HXDLIN( 104)			if ((hasHit == false)) {
HXLINE( 104)				 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN( 104)				if (hasUndo2) {
HXLINE( 104)					v8->undoImage = undoImage6;
HXDLIN( 104)					v8->undoX = xIter32->start;
HXDLIN( 104)					v8->undoY = yIter32->start;
            				}
            			}
            		}
HXLINE( 105)		{
HXLINE( 105)			bool hasUndo3 = true;
HXDLIN( 105)			int aA3 = ((color >> 24) & 255);
HXDLIN( 105)			int rA3 = ((color >> 16) & 255);
HXDLIN( 105)			int gA3 = ((color >> 8) & 255);
HXDLIN( 105)			int bA3 = (color & 255);
HXDLIN( 105)			Float bcx3 = (cx - dx);
HXDLIN( 105)			Float bcy3 = (cy - dy);
HXDLIN( 105)			Float acx3 = (bx - dx);
HXDLIN( 105)			Float acy3 = (by - dy);
HXDLIN( 105)			Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 105)			Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 105)			Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 105)			Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 105)			 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 105)			if ((bx > cx)) {
HXLINE( 105)				if ((bx > dx)) {
HXLINE( 105)					int min15;
HXDLIN( 105)					if ((cx > dx)) {
HXLINE( 105)						min15 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 105)						min15 = ::Math_obj::floor(cx);
            					}
HXDLIN( 105)					int ii_min24 = min15;
HXDLIN( 105)					int ii_max24 = ::Math_obj::ceil(bx);
HXDLIN( 105)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            				}
            				else {
HXLINE( 105)					int ii_min25 = ::Math_obj::floor(cx);
HXDLIN( 105)					int ii_max25 = ::Math_obj::ceil(dx);
HXDLIN( 105)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            				}
            			}
            			else {
HXLINE( 105)				if ((cx > dx)) {
HXLINE( 105)					int min16;
HXDLIN( 105)					if ((bx > dx)) {
HXLINE( 105)						min16 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 105)						min16 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 105)					int ii_min26 = min16;
HXDLIN( 105)					int ii_max26 = ::Math_obj::ceil(cx);
HXDLIN( 105)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            				}
            				else {
HXLINE( 105)					int ii_min27 = ::Math_obj::floor(bx);
HXDLIN( 105)					int ii_max27 = ::Math_obj::ceil(dx);
HXDLIN( 105)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            				}
            			}
HXDLIN( 105)			 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 105)			if ((by > cy)) {
HXLINE( 105)				if ((by > dy)) {
HXLINE( 105)					int min17;
HXDLIN( 105)					if ((cy > dy)) {
HXLINE( 105)						min17 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 105)						min17 = ::Math_obj::floor(cy);
            					}
HXDLIN( 105)					int ii_min28 = min17;
HXDLIN( 105)					int ii_max28 = ::Math_obj::ceil(by);
HXDLIN( 105)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            				}
            				else {
HXLINE( 105)					int ii_min29 = ::Math_obj::floor(cy);
HXDLIN( 105)					int ii_max29 = ::Math_obj::ceil(dy);
HXDLIN( 105)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            				}
            			}
            			else {
HXLINE( 105)				if ((cy > dy)) {
HXLINE( 105)					int min18;
HXDLIN( 105)					if ((by > dy)) {
HXLINE( 105)						min18 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 105)						min18 = ::Math_obj::ceil(by);
            					}
HXDLIN( 105)					int ii_min30 = min18;
HXDLIN( 105)					int ii_max30 = ::Math_obj::ceil(cy);
HXDLIN( 105)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            				}
            				else {
HXLINE( 105)					int ii_min31 = ::Math_obj::floor(by);
HXDLIN( 105)					int ii_max31 = ::Math_obj::ceil(dy);
HXDLIN( 105)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            				}
            			}
HXDLIN( 105)			 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 105)			if (hasUndo3) {
HXLINE( 105)				int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 105)				int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 105)				 ::Dynamic imageType3 = null();
HXDLIN( 105)				 ::pi_xy::ImageStruct this121 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 105)				if (::hx::IsNull( imageType3 )) {
HXLINE(  54)					imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 105)				::Dynamic undoImage10;
HXDLIN( 105)				switch((int)(( (int)(imageType3) ))){
            					case (int)0: {
HXLINE( 105)						 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 105)						 ::iterMagic::BytesImg b34 = byt3;
HXDLIN( 105)						{
HXLINE( 105)							b34->width = width3;
HXDLIN( 105)							b34->height = height3;
HXDLIN( 105)							b34->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 105)							b34->data = ::haxe::io::Bytes_obj::alloc((b34->length * 4));
HXDLIN( 105)							{
HXLINE( 105)								int len6 = b34->length;
HXDLIN( 105)								int w3 = 0;
HXDLIN( 105)								{
HXLINE( 105)									int _g60 = 0;
HXDLIN( 105)									int _g61 = b34->height;
HXDLIN( 105)									while((_g60 < _g61)){
HXLINE( 105)										_g60 = (_g60 + 1);
HXDLIN( 105)										int y9 = (_g60 - 1);
HXDLIN( 105)										{
HXLINE( 105)											int _g62 = 0;
HXDLIN( 105)											int _g63 = b34->width;
HXDLIN( 105)											while((_g62 < _g63)){
HXLINE( 105)												_g62 = (_g62 + 1);
HXDLIN( 105)												int x9 = (_g62 - 1);
HXDLIN( 105)												{
HXLINE( 105)													w3 = (w3 + 1);
HXDLIN( 105)													b34->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 105)												{
HXLINE( 105)													w3 = (w3 + 1);
HXDLIN( 105)													b34->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 105)												{
HXLINE( 105)													w3 = (w3 + 1);
HXDLIN( 105)													b34->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 105)												{
HXLINE( 105)													w3 = (w3 + 1);
HXDLIN( 105)													b34->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 105)						undoImage10 = b34;
            					}
            					break;
            					case (int)1: {
HXLINE( 105)						 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 105)						 ::iterMagic::ArrIntImg a39 = arrI3;
HXDLIN( 105)						{
HXLINE( 105)							a39->width = width3;
HXDLIN( 105)							a39->height = height3;
HXDLIN( 105)							a39->data = ::Array_obj< int >::__new(0);
HXDLIN( 105)							a39->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 105)							{
HXLINE( 105)								int _g64 = 0;
HXDLIN( 105)								int _g65 = a39->length;
HXDLIN( 105)								while((_g64 < _g65)){
HXLINE( 105)									_g64 = (_g64 + 1);
HXDLIN( 105)									int i33 = (_g64 - 1);
HXDLIN( 105)									a39->data[i33] = 0;
            								}
            							}
            						}
HXDLIN( 105)						undoImage10 = a39;
            					}
            					break;
            					case (int)2: {
HXLINE( 105)						 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 105)						 ::iterMagic::U32ArrImg b35 = u32a3;
HXDLIN( 105)						{
HXLINE( 105)							b35->width = width3;
HXDLIN( 105)							b35->height = height3;
HXDLIN( 105)							b35->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 105)							int size3 = (b35->length * 4);
HXDLIN( 105)							b35->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 105)							{
HXLINE( 105)								int _g66 = 0;
HXDLIN( 105)								int _g67 = b35->length;
HXDLIN( 105)								while((_g66 < _g67)){
HXLINE( 105)									_g66 = (_g66 + 1);
HXDLIN( 105)									int i34 = (_g66 - 1);
HXDLIN( 105)									{
HXLINE( 105)										 ::haxe::io::ArrayBufferViewImpl this122 = b35->data;
HXDLIN( 105)										bool undoImage11;
HXDLIN( 105)										if ((i34 >= 0)) {
HXLINE( 105)											undoImage11 = (i34 < (this122->byteLength >> 2));
            										}
            										else {
HXLINE( 105)											undoImage11 = false;
            										}
HXDLIN( 105)										if (undoImage11) {
HXLINE( 105)											 ::haxe::io::Bytes _this3 = this122->bytes;
HXDLIN( 105)											int pos3 = ((i34 << 2) + this122->byteOffset);
HXDLIN( 105)											_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 105)											_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 105)											_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 105)											_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 105)						undoImage10 = b35;
            					}
            					break;
            					case (int)3: {
HXLINE( 105)						 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 105)						 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN( 105)						{
HXLINE( 105)							v9->width = width3;
HXDLIN( 105)							v9->height = height3;
HXDLIN( 105)							v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 105)							v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN( 105)							{
HXLINE( 105)								int _g68 = 0;
HXDLIN( 105)								int _g69 = v9->length;
HXDLIN( 105)								while((_g68 < _g69)){
HXLINE( 105)									_g68 = (_g68 + 1);
HXDLIN( 105)									int i35 = (_g68 - 1);
HXDLIN( 105)									v9->data->__unsafe_set(i35,0);
            								}
            							}
            						}
HXDLIN( 105)						undoImage10 = v9;
            					}
            					break;
            					case (int)4: {
HXLINE( 105)						 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 105)						 ::iterMagic::StackIntImg b36 = sInt3;
HXDLIN( 105)						{
HXLINE( 105)							b36->width = width3;
HXDLIN( 105)							b36->height = height3;
HXDLIN( 105)							b36->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 105)							b36->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 105)							{
HXLINE( 105)								int len7 = b36->length;
HXDLIN( 105)								 ::haxe::ds::GenericStack_Int d3 = b36->data;
HXDLIN( 105)								if (::hx::IsNull( d3->head )) {
HXLINE( 105)									int _g70 = 0;
HXDLIN( 105)									int _g71 = len7;
HXDLIN( 105)									while((_g70 < _g71)){
HXLINE( 105)										_g70 = (_g70 + 1);
HXDLIN( 105)										int i36 = (_g70 - 1);
HXDLIN( 105)										d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            									}
            								}
            								else {
HXLINE( 105)									int _g72 = 0;
HXDLIN( 105)									int _g73 = len7;
HXDLIN( 105)									while((_g72 < _g73)){
HXLINE( 105)										_g72 = (_g72 + 1);
HXDLIN( 105)										int i37 = (_g72 - 1);
HXDLIN( 105)										{
HXLINE( 105)											 ::haxe::ds::GenericCell_Int l3 = b36->data->head;
HXDLIN( 105)											 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 105)											{
HXLINE( 105)												int _g74 = 0;
HXDLIN( 105)												int _g75 = i37;
HXDLIN( 105)												while((_g74 < _g75)){
HXLINE( 105)													_g74 = (_g74 + 1);
HXDLIN( 105)													int i38 = (_g74 - 1);
HXLINE( 345)													prev3 = l3;
HXLINE( 346)													l3 = l3->next;
            												}
            											}
HXLINE( 105)											if (::hx::IsNull( prev3 )) {
HXLINE( 105)												b36->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 105)												l3 = null();
            											}
            											else {
HXLINE( 105)												prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 105)												l3 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 105)						undoImage10 = b36;
            					}
            					break;
            				}
HXDLIN( 105)				this121->image = undoImage10;
HXDLIN( 105)				this121->width = width3;
HXDLIN( 105)				this121->height = height3;
HXDLIN( 105)				this121->imageType = ( (int)(imageType3) );
HXDLIN( 105)				undoImage9 = this121;
HXDLIN( 105)				{
HXLINE( 105)					int rectLeft3 = xIter33->start;
HXDLIN( 105)					int rectTop3 = yIter33->start;
HXDLIN( 105)					int rectRight3 = xIter33->max;
HXDLIN( 105)					bool forceClear3 = false;
HXDLIN( 105)					{
HXLINE( 105)						int _g76 = rectTop3;
HXDLIN( 105)						int _g77 = yIter33->max;
HXDLIN( 105)						while((_g76 < _g77)){
HXLINE( 105)							_g76 = (_g76 + 1);
HXDLIN( 105)							int dy4 = (_g76 - 1);
HXDLIN( 105)							{
HXLINE( 105)								int _g78 = rectLeft3;
HXDLIN( 105)								int _g79 = rectRight3;
HXDLIN( 105)								while((_g78 < _g79)){
HXLINE( 105)									_g78 = (_g78 + 1);
HXDLIN( 105)									int dx4 = (_g78 - 1);
HXDLIN( 105)									::Dynamic this123 = pixelImage->image;
HXDLIN( 105)									int index12;
HXDLIN( 105)									if (pixelImage->useVirtualPos) {
HXLINE( 105)										index12 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx4) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 105)										index12 = ::Std_obj::_hx_int(( (Float)(((dy4 * pixelImage->width) + dx4)) ));
            									}
HXDLIN( 105)									int c9 = ::iterMagic::Iimg_obj::get(this123,index12);
HXDLIN( 105)									int col3;
HXDLIN( 105)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)										col3 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            									}
            									else {
HXLINE( 105)										col3 = c9;
            									}
HXDLIN( 105)									bool _hx_tmp39;
HXDLIN( 105)									if (pixelImage->useMask) {
HXLINE( 105)										_hx_tmp39 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 105)										_hx_tmp39 = false;
            									}
HXDLIN( 105)									if (_hx_tmp39) {
HXLINE( 105)										 ::pi_xy::ImageStruct this124 = pixelImage->mask;
HXDLIN( 105)										::Dynamic this125 = this124->image;
HXDLIN( 105)										int index13;
HXDLIN( 105)										if (this124->useVirtualPos) {
HXLINE( 105)											index13 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this124->virtualY) * ( (Float)(this124->width) )) + dx4) - this124->virtualX));
            										}
            										else {
HXLINE( 105)											index13 = ::Std_obj::_hx_int(( (Float)(((dy4 * this124->width) + dx4)) ));
            										}
HXDLIN( 105)										int c10 = ::iterMagic::Iimg_obj::get(this125,index13);
HXDLIN( 105)										int v10;
HXDLIN( 105)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)											v10 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXLINE( 105)											v10 = c10;
            										}
HXDLIN( 105)										int maskPixel3 = v10;
HXDLIN( 105)										int this126 = col3;
HXDLIN( 105)										if ((maskPixel3 == 0)) {
HXLINE( 105)											col3 = this126;
            										}
            										else {
HXLINE( 105)											Float m03;
HXDLIN( 105)											int this127 = ((maskPixel3 >> 24) & 255);
HXDLIN( 105)											if ((this127 == 0)) {
HXLINE( 105)												m03 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												m03 = (( (Float)(this127) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float m13;
HXDLIN( 105)											int this128 = ((maskPixel3 >> 16) & 255);
HXDLIN( 105)											if ((this128 == 0)) {
HXLINE( 105)												m13 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												m13 = (( (Float)(this128) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float m23;
HXDLIN( 105)											int this129 = ((maskPixel3 >> 8) & 255);
HXDLIN( 105)											if ((this129 == 0)) {
HXLINE( 105)												m23 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												m23 = (( (Float)(this129) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float m33;
HXDLIN( 105)											int this130 = (maskPixel3 & 255);
HXDLIN( 105)											if ((this130 == 0)) {
HXLINE( 105)												m33 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												m33 = (( (Float)(this130) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this126 >> 24) & 255)) )));
HXDLIN( 105)											int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this126 >> 16) & 255)) )));
HXDLIN( 105)											int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this126 >> 8) & 255)) )));
HXDLIN( 105)											int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this126 & 255)) )));
HXDLIN( 105)											col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 105)									if ((col3 != 0)) {
HXLINE( 105)										int x10 = (dx4 - rectLeft3);
HXDLIN( 105)										int y10 = (dy4 - rectTop3);
HXDLIN( 105)										int c11 = col3;
HXDLIN( 105)										bool _hx_tmp40;
HXDLIN( 105)										if ((((c11 >> 24) & 255) < 254)) {
HXLINE( 105)											_hx_tmp40 = undoImage9->transparent;
            										}
            										else {
HXLINE( 105)											_hx_tmp40 = false;
            										}
HXDLIN( 105)										if (_hx_tmp40) {
HXLINE( 105)											int location9;
HXDLIN( 105)											if (undoImage9->useVirtualPos) {
HXLINE( 105)												location9 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            											}
            											else {
HXLINE( 105)												location9 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            											}
HXDLIN( 105)											int this131 = ::iterMagic::Iimg_obj::get(undoImage9->image,location9);
HXDLIN( 105)											int this132;
HXDLIN( 105)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)												this132 = ((((((this131 >> 24) & 255) << 24) | ((this131 & 255) << 16)) | (((this131 >> 8) & 255) << 8)) | ((this131 >> 16) & 255));
            											}
            											else {
HXLINE( 105)												this132 = this131;
            											}
HXDLIN( 105)											Float a112;
HXDLIN( 105)											int this133 = ((this132 >> 24) & 255);
HXDLIN( 105)											if ((this133 == 0)) {
HXLINE( 105)												a112 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												a112 = (( (Float)(this133) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float r111;
HXDLIN( 105)											int this134 = ((this132 >> 16) & 255);
HXDLIN( 105)											if ((this134 == 0)) {
HXLINE( 105)												r111 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												r111 = (( (Float)(this134) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float g111;
HXDLIN( 105)											int this135 = ((this132 >> 8) & 255);
HXDLIN( 105)											if ((this135 == 0)) {
HXLINE( 105)												g111 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												g111 = (( (Float)(this135) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float b113;
HXDLIN( 105)											int this136 = (this132 & 255);
HXDLIN( 105)											if ((this136 == 0)) {
HXLINE( 105)												b113 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												b113 = (( (Float)(this136) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float a211;
HXDLIN( 105)											int this137 = ((col3 >> 24) & 255);
HXDLIN( 105)											if ((this137 == 0)) {
HXLINE( 105)												a211 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												a211 = (( (Float)(this137) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float r29;
HXDLIN( 105)											int this138 = ((col3 >> 16) & 255);
HXDLIN( 105)											if ((this138 == 0)) {
HXLINE( 105)												r29 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												r29 = (( (Float)(this138) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float g29;
HXDLIN( 105)											int this139 = ((col3 >> 8) & 255);
HXDLIN( 105)											if ((this139 == 0)) {
HXLINE( 105)												g29 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												g29 = (( (Float)(this139) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float b212;
HXDLIN( 105)											int this140 = (col3 & 255);
HXDLIN( 105)											if ((this140 == 0)) {
HXLINE( 105)												b212 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												b212 = (( (Float)(this140) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN( 105)											int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a310) + (r29 * a211))));
HXDLIN( 105)											int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a310) + (g29 * a211))));
HXDLIN( 105)											int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b212 * a211))));
HXDLIN( 105)											int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 105)											int blended9 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b37);
HXDLIN( 105)											{
HXLINE( 105)												int _hx_tmp41;
HXDLIN( 105)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)													_hx_tmp41 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXLINE( 105)													_hx_tmp41 = blended9;
            												}
HXDLIN( 105)												::iterMagic::Iimg_obj::set(undoImage9->image,location9,_hx_tmp41);
            											}
            										}
            										else {
HXLINE( 105)											::Dynamic this141 = undoImage9->image;
HXDLIN( 105)											int index14;
HXDLIN( 105)											if (undoImage9->useVirtualPos) {
HXLINE( 105)												index14 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x10) - undoImage9->virtualX));
            											}
            											else {
HXLINE( 105)												index14 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage9->width) + x10)) ));
            											}
HXDLIN( 105)											int _hx_tmp42;
HXDLIN( 105)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)												_hx_tmp42 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            											}
            											else {
HXLINE( 105)												_hx_tmp42 = c11;
            											}
HXDLIN( 105)											::iterMagic::Iimg_obj::set(this141,index14,_hx_tmp42);
            										}
            									}
            									else {
HXLINE( 105)										if (forceClear3) {
HXLINE( 105)											::Dynamic this142 = undoImage9->image;
HXDLIN( 105)											int x11 = (dx4 - rectLeft3);
HXDLIN( 105)											int y11 = (dy4 - rectTop3);
HXDLIN( 105)											int index15;
HXDLIN( 105)											if (undoImage9->useVirtualPos) {
HXLINE( 105)												index15 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x11) - undoImage9->virtualX));
            											}
            											else {
HXLINE( 105)												index15 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage9->width) + x11)) ));
            											}
HXDLIN( 105)											::iterMagic::Iimg_obj::set(this142,index15,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 105)			bool found3 = false;
HXDLIN( 105)			Float min19 = ( (Float)(0) );
HXDLIN( 105)			Float max3 = ( (Float)(0) );
HXDLIN( 105)			int a41 = 0;
HXDLIN( 105)			int r31 = 0;
HXDLIN( 105)			int g31 = 0;
HXDLIN( 105)			int b38 = 0;
HXDLIN( 105)			{
HXLINE( 105)				int _g_min6 = xIter33->start;
HXDLIN( 105)				int _g_max6 = xIter33->max;
HXDLIN( 105)				while((_g_min6 < _g_max6)){
HXLINE( 105)					_g_min6 = (_g_min6 + 1);
HXDLIN( 105)					int px3 = (_g_min6 - 1);
HXDLIN( 105)					Float pcx3 = (( (Float)(px3) ) - dx);
HXLINE( 812)					found3 = false;
HXLINE( 105)					{
HXLINE( 105)						int _g_min7 = yIter33->start;
HXDLIN( 105)						int _g_max7 = yIter33->max;
HXDLIN( 105)						while((_g_min7 < _g_max7)){
HXLINE( 105)							_g_min7 = (_g_min7 + 1);
HXDLIN( 105)							int py3 = (_g_min7 - 1);
HXDLIN( 105)							Float pcy3 = (( (Float)(py3) ) - dy);
HXDLIN( 105)							Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 105)							Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 105)							Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 105)							Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 105)							Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 105)							bool _hx_tmp43;
HXDLIN( 105)							bool _hx_tmp44;
HXDLIN( 105)							if ((ratioA3 >= 0)) {
HXLINE( 105)								_hx_tmp44 = (ratioB3 >= 0);
            							}
            							else {
HXLINE( 105)								_hx_tmp44 = false;
            							}
HXDLIN( 105)							if (_hx_tmp44) {
HXLINE( 105)								_hx_tmp43 = (ratioC3 >= 0);
            							}
            							else {
HXLINE( 105)								_hx_tmp43 = false;
            							}
HXDLIN( 105)							if (_hx_tmp43) {
HXLINE( 105)								int i39 = ::Std_obj::_hx_int(( (Float)(rA3) ));
HXDLIN( 105)								if ((i39 > 255)) {
HXLINE(  24)									i39 = 255;
            								}
HXLINE( 105)								if ((i39 < 0)) {
HXLINE(  25)									i39 = 0;
            								}
HXLINE( 821)								r31 = i39;
HXLINE( 105)								int i40 = ::Std_obj::_hx_int(( (Float)(gA3) ));
HXDLIN( 105)								if ((i40 > 255)) {
HXLINE(  24)									i40 = 255;
            								}
HXLINE( 105)								if ((i40 < 0)) {
HXLINE(  25)									i40 = 0;
            								}
HXLINE( 822)								g31 = i40;
HXLINE( 105)								int i41 = ::Std_obj::_hx_int(( (Float)(bA3) ));
HXDLIN( 105)								if ((i41 > 255)) {
HXLINE(  24)									i41 = 255;
            								}
HXLINE( 105)								if ((i41 < 0)) {
HXLINE(  25)									i41 = 0;
            								}
HXLINE( 823)								b38 = i41;
HXLINE( 105)								bool _hx_tmp45;
HXDLIN( 105)								bool _hx_tmp46;
HXDLIN( 105)								if ((softBC == true)) {
HXLINE( 105)									_hx_tmp46 = (softCD == false);
            								}
            								else {
HXLINE( 105)									_hx_tmp46 = false;
            								}
HXDLIN( 105)								if (_hx_tmp46) {
HXLINE( 105)									_hx_tmp45 = false;
            								}
            								else {
HXLINE( 105)									_hx_tmp45 = false;
            								}
HXDLIN( 105)								if (_hx_tmp45) {
HXLINE( 105)									if ((ratioA3 < ratioC3)) {
HXLINE( 105)										min19 = ratioA3;
            									}
            									else {
HXLINE( 105)										min19 = ratioC3;
            									}
HXDLIN( 105)									if ((ratioA3 > ratioB3)) {
HXLINE( 105)										max3 = ratioA3;
            									}
            									else {
HXLINE( 105)										max3 = ratioB3;
            									}
HXDLIN( 105)									if (!((max3 > ratioC3))) {
HXLINE( 105)										max3 = ratioC3;
            									}
HXLINE( 829)									max3 = ((( (Float)(1) ) - max3) / ( (Float)(2) ));
HXLINE( 105)									if (!((min19 < max3))) {
HXLINE( 105)										min19 = ((max3 + min19) / ( (Float)(2) ));
            									}
HXDLIN( 105)									int i42 = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft) * min19));
HXDLIN( 105)									if ((i42 > 255)) {
HXLINE(  24)										i42 = 255;
            									}
HXLINE( 105)									if ((i42 < 0)) {
HXLINE(  25)										i42 = 0;
            									}
HXLINE( 832)									a41 = i42;
HXLINE( 105)									{
HXLINE( 105)										int location10;
HXDLIN( 105)										if (pixelImage->useVirtualPos) {
HXLINE( 105)											location10 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 105)											location10 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            										}
HXDLIN( 105)										bool _hx_tmp47;
HXDLIN( 105)										if (pixelImage->transparent) {
HXLINE( 105)											_hx_tmp47 = (a41 < 254);
            										}
            										else {
HXLINE( 105)											_hx_tmp47 = false;
            										}
HXDLIN( 105)										if (_hx_tmp47) {
HXLINE( 105)											int this143 = ::iterMagic::Iimg_obj::get(pixelImage->image,location10);
HXDLIN( 105)											int old6;
HXDLIN( 105)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)												old6 = ((((((this143 >> 24) & 255) << 24) | ((this143 & 255) << 16)) | (((this143 >> 8) & 255) << 8)) | ((this143 >> 16) & 255));
            											}
            											else {
HXLINE( 105)												old6 = this143;
            											}
HXDLIN( 105)											int rhs6 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b38);
HXDLIN( 105)											Float a113;
HXDLIN( 105)											int this144 = ((old6 >> 24) & 255);
HXDLIN( 105)											if ((this144 == 0)) {
HXLINE( 105)												a113 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												a113 = (( (Float)(this144) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float r112;
HXDLIN( 105)											int this145 = ((old6 >> 16) & 255);
HXDLIN( 105)											if ((this145 == 0)) {
HXLINE( 105)												r112 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												r112 = (( (Float)(this145) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float g112;
HXDLIN( 105)											int this146 = ((old6 >> 8) & 255);
HXDLIN( 105)											if ((this146 == 0)) {
HXLINE( 105)												g112 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												g112 = (( (Float)(this146) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float b114;
HXDLIN( 105)											int this147 = (old6 & 255);
HXDLIN( 105)											if ((this147 == 0)) {
HXLINE( 105)												b114 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												b114 = (( (Float)(this147) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float a212;
HXDLIN( 105)											int this148 = ((rhs6 >> 24) & 255);
HXDLIN( 105)											if ((this148 == 0)) {
HXLINE( 105)												a212 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												a212 = (( (Float)(this148) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float r210;
HXDLIN( 105)											int this149 = ((rhs6 >> 16) & 255);
HXDLIN( 105)											if ((this149 == 0)) {
HXLINE( 105)												r210 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												r210 = (( (Float)(this149) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float g210;
HXDLIN( 105)											int this150 = ((rhs6 >> 8) & 255);
HXDLIN( 105)											if ((this150 == 0)) {
HXLINE( 105)												g210 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												g210 = (( (Float)(this150) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float b213;
HXDLIN( 105)											int this151 = (rhs6 & 255);
HXDLIN( 105)											if ((this151 == 0)) {
HXLINE( 105)												b213 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												b213 = (( (Float)(this151) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN( 105)											int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a311) + (r210 * a212))));
HXDLIN( 105)											int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a311) + (g210 * a212))));
HXDLIN( 105)											int b39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b213 * a212))));
HXDLIN( 105)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 105)											int blended10 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b39);
HXDLIN( 105)											{
HXLINE( 105)												int _hx_tmp48;
HXDLIN( 105)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)													_hx_tmp48 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            												}
            												else {
HXLINE( 105)													_hx_tmp48 = blended10;
            												}
HXDLIN( 105)												::iterMagic::Iimg_obj::set(pixelImage->image,location10,_hx_tmp48);
            											}
            										}
            										else {
HXLINE( 105)											int value6;
HXDLIN( 105)											if (pixelImage->isLittle) {
HXLINE( 105)												value6 = ((((a41 << 24) | (b38 << 16)) | (g31 << 8)) | r31);
            											}
            											else {
HXLINE( 105)												value6 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b38);
            											}
HXDLIN( 105)											::iterMagic::Iimg_obj::set(pixelImage->image,location10,value6);
            										}
            									}
            								}
HXDLIN( 105)								bool _hx_tmp49;
HXDLIN( 105)								if ((softBC == true)) {
HXLINE( 105)									_hx_tmp49 = (softCD == true);
            								}
            								else {
HXLINE( 105)									_hx_tmp49 = false;
            								}
HXDLIN( 105)								if (_hx_tmp49) {
HXLINE( 105)									if ((ratioB3 < ratioC3)) {
HXLINE( 105)										min19 = ratioB3;
            									}
            									else {
HXLINE( 105)										min19 = ratioC3;
            									}
HXDLIN( 105)									if ((ratioA3 > ratioB3)) {
HXLINE( 105)										max3 = ratioA3;
            									}
            									else {
HXLINE( 105)										max3 = ratioB3;
            									}
HXDLIN( 105)									if (!((max3 > ratioC3))) {
HXLINE( 105)										max3 = ratioC3;
            									}
HXLINE( 842)									max3 = ((( (Float)(1) ) - max3) / ( (Float)(2) ));
HXLINE( 105)									if (!((min19 < max3))) {
HXLINE( 105)										min19 = ((max3 + min19) / ( (Float)(2) ));
            									}
HXDLIN( 105)									int i43 = ::Std_obj::_hx_int(((( (Float)(aA3) ) * soft) * min19));
HXDLIN( 105)									if ((i43 > 255)) {
HXLINE(  24)										i43 = 255;
            									}
HXLINE( 105)									if ((i43 < 0)) {
HXLINE(  25)										i43 = 0;
            									}
HXLINE( 845)									a41 = i43;
HXLINE( 105)									{
HXLINE( 105)										int location11;
HXDLIN( 105)										if (pixelImage->useVirtualPos) {
HXLINE( 105)											location11 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 105)											location11 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            										}
HXDLIN( 105)										bool _hx_tmp50;
HXDLIN( 105)										if (pixelImage->transparent) {
HXLINE( 105)											_hx_tmp50 = (a41 < 254);
            										}
            										else {
HXLINE( 105)											_hx_tmp50 = false;
            										}
HXDLIN( 105)										if (_hx_tmp50) {
HXLINE( 105)											int this152 = ::iterMagic::Iimg_obj::get(pixelImage->image,location11);
HXDLIN( 105)											int old7;
HXDLIN( 105)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)												old7 = ((((((this152 >> 24) & 255) << 24) | ((this152 & 255) << 16)) | (((this152 >> 8) & 255) << 8)) | ((this152 >> 16) & 255));
            											}
            											else {
HXLINE( 105)												old7 = this152;
            											}
HXDLIN( 105)											int rhs7 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b38);
HXDLIN( 105)											Float a114;
HXDLIN( 105)											int this153 = ((old7 >> 24) & 255);
HXDLIN( 105)											if ((this153 == 0)) {
HXLINE( 105)												a114 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												a114 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float r113;
HXDLIN( 105)											int this154 = ((old7 >> 16) & 255);
HXDLIN( 105)											if ((this154 == 0)) {
HXLINE( 105)												r113 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												r113 = (( (Float)(this154) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float g113;
HXDLIN( 105)											int this155 = ((old7 >> 8) & 255);
HXDLIN( 105)											if ((this155 == 0)) {
HXLINE( 105)												g113 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												g113 = (( (Float)(this155) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float b115;
HXDLIN( 105)											int this156 = (old7 & 255);
HXDLIN( 105)											if ((this156 == 0)) {
HXLINE( 105)												b115 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												b115 = (( (Float)(this156) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float a213;
HXDLIN( 105)											int this157 = ((rhs7 >> 24) & 255);
HXDLIN( 105)											if ((this157 == 0)) {
HXLINE( 105)												a213 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												a213 = (( (Float)(this157) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float r211;
HXDLIN( 105)											int this158 = ((rhs7 >> 16) & 255);
HXDLIN( 105)											if ((this158 == 0)) {
HXLINE( 105)												r211 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												r211 = (( (Float)(this158) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float g211;
HXDLIN( 105)											int this159 = ((rhs7 >> 8) & 255);
HXDLIN( 105)											if ((this159 == 0)) {
HXLINE( 105)												g211 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												g211 = (( (Float)(this159) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float b214;
HXDLIN( 105)											int this160 = (rhs7 & 255);
HXDLIN( 105)											if ((this160 == 0)) {
HXLINE( 105)												b214 = ((Float)0.);
            											}
            											else {
HXLINE( 105)												b214 = (( (Float)(this160) ) / ( (Float)(255) ));
            											}
HXDLIN( 105)											Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN( 105)											int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a312) + (r211 * a213))));
HXDLIN( 105)											int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a312) + (g211 * a213))));
HXDLIN( 105)											int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b214 * a213))));
HXDLIN( 105)											int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 105)											int blended11 = ((((a43 << 24) | (r33 << 16)) | (g33 << 8)) | b40);
HXDLIN( 105)											{
HXLINE( 105)												int _hx_tmp51;
HXDLIN( 105)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 105)													_hx_tmp51 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXLINE( 105)													_hx_tmp51 = blended11;
            												}
HXDLIN( 105)												::iterMagic::Iimg_obj::set(pixelImage->image,location11,_hx_tmp51);
            											}
            										}
            										else {
HXLINE( 105)											int value7;
HXDLIN( 105)											if (pixelImage->isLittle) {
HXLINE( 105)												value7 = ((((a41 << 24) | (b38 << 16)) | (g31 << 8)) | r31);
            											}
            											else {
HXLINE( 105)												value7 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b38);
            											}
HXDLIN( 105)											::iterMagic::Iimg_obj::set(pixelImage->image,location11,value7);
            										}
            									}
            								}
HXLINE( 850)								found3 = true;
            							}
            							else {
HXLINE( 105)								if (found3) {
HXLINE( 105)									goto _hx_goto_122;
            								}
            							}
            						}
            						_hx_goto_122:;
            					}
            				}
            			}
HXDLIN( 105)			if ((hasHit == false)) {
HXLINE( 105)				 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 105)				if (hasUndo3) {
HXLINE( 105)					v11->undoImage = undoImage9;
HXDLIN( 105)					v11->undoX = xIter33->start;
HXDLIN( 105)					v11->undoY = yIter33->start;
            				}
            			}
            		}
HXLINE( 107)		if ((hasHit == true)) {
HXLINE( 108)			 ::pi_xy::algo::HitQuad v12 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE( 109)			return v12;
            		}
            		else {
HXLINE( 111)			return null();
            		}
HXLINE( 107)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC16(QuadPixel_Fields__obj,fillSoftQuadrilateralQuarter,return )

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::tileQuadrilateral( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_122_tileQuadrilateral)
HXLINE( 125)		{
HXLINE( 125)			Float bx1 = bx;
HXDLIN( 125)			Float by1 = by;
HXDLIN( 125)			Float cx1 = dx;
HXDLIN( 125)			Float cy1 = dy;
HXDLIN( 125)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 125)			if (!(adjustWinding)) {
HXLINE( 125)				Float bx_ = bx1;
HXDLIN( 125)				Float by_ = by1;
HXLINE( 187)				bx1 = cx1;
HXLINE( 188)				by1 = cy1;
HXLINE( 189)				cx1 = bx_;
HXLINE( 190)				cy1 = by_;
            			}
HXLINE( 125)			{
HXLINE( 125)				bool hasUndo = false;
HXDLIN( 125)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 125)				Float sx = (cy1 - ay);
HXDLIN( 125)				Float sy = (ax - cx1);
HXDLIN( 125)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 125)				Float tx = (ay - by1);
HXDLIN( 125)				Float ty = (bx1 - ax);
HXDLIN( 125)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 125)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 125)				if ((ax > bx1)) {
HXLINE( 125)					if ((ax > cx1)) {
HXLINE( 125)						int min;
HXDLIN( 125)						if ((bx1 > cx1)) {
HXLINE( 125)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 125)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN( 125)						int ii_min = min;
HXDLIN( 125)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 125)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE( 125)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 125)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 125)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE( 125)					if ((bx1 > cx1)) {
HXLINE( 125)						int min1;
HXDLIN( 125)						if ((ax > cx1)) {
HXLINE( 125)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 125)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 125)						int ii_min2 = min1;
HXDLIN( 125)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 125)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 125)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 125)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 125)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 125)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 125)				if ((ay > by1)) {
HXLINE( 125)					if ((ay > cy1)) {
HXLINE( 125)						int min2;
HXDLIN( 125)						if ((by1 > cy1)) {
HXLINE( 125)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 125)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN( 125)						int ii_min4 = min2;
HXDLIN( 125)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 125)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 125)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 125)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 125)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE( 125)					if ((by1 > cy1)) {
HXLINE( 125)						int min3;
HXDLIN( 125)						if ((ay > cy1)) {
HXLINE( 125)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 125)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 125)						int ii_min6 = min3;
HXDLIN( 125)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 125)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 125)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 125)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 125)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 125)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 125)				if (hasUndo) {
HXLINE( 125)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 125)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 125)					 ::Dynamic imageType = null();
HXDLIN( 125)					 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 125)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 125)					::Dynamic undoImage1;
HXDLIN( 125)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 125)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 125)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 125)							{
HXLINE( 125)								b->width = width;
HXDLIN( 125)								b->height = height;
HXDLIN( 125)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 125)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 125)								{
HXLINE( 125)									int len = b->length;
HXDLIN( 125)									int w = 0;
HXDLIN( 125)									{
HXLINE( 125)										int _g = 0;
HXDLIN( 125)										int _g1 = b->height;
HXDLIN( 125)										while((_g < _g1)){
HXLINE( 125)											_g = (_g + 1);
HXDLIN( 125)											int y = (_g - 1);
HXDLIN( 125)											{
HXLINE( 125)												int _g2 = 0;
HXDLIN( 125)												int _g3 = b->width;
HXDLIN( 125)												while((_g2 < _g3)){
HXLINE( 125)													_g2 = (_g2 + 1);
HXDLIN( 125)													int x = (_g2 - 1);
HXDLIN( 125)													{
HXLINE( 125)														w = (w + 1);
HXDLIN( 125)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 125)													{
HXLINE( 125)														w = (w + 1);
HXDLIN( 125)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 125)													{
HXLINE( 125)														w = (w + 1);
HXDLIN( 125)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 125)													{
HXLINE( 125)														w = (w + 1);
HXDLIN( 125)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 125)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE( 125)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 125)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 125)							{
HXLINE( 125)								a->width = width;
HXDLIN( 125)								a->height = height;
HXDLIN( 125)								a->data = ::Array_obj< int >::__new(0);
HXDLIN( 125)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 125)								{
HXLINE( 125)									int _g4 = 0;
HXDLIN( 125)									int _g5 = a->length;
HXDLIN( 125)									while((_g4 < _g5)){
HXLINE( 125)										_g4 = (_g4 + 1);
HXDLIN( 125)										int i = (_g4 - 1);
HXDLIN( 125)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN( 125)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE( 125)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 125)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 125)							{
HXLINE( 125)								b1->width = width;
HXDLIN( 125)								b1->height = height;
HXDLIN( 125)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 125)								int size = (b1->length * 4);
HXDLIN( 125)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 125)								{
HXLINE( 125)									int _g6 = 0;
HXDLIN( 125)									int _g7 = b1->length;
HXDLIN( 125)									while((_g6 < _g7)){
HXLINE( 125)										_g6 = (_g6 + 1);
HXDLIN( 125)										int i1 = (_g6 - 1);
HXDLIN( 125)										{
HXLINE( 125)											 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 125)											bool undoImage2;
HXDLIN( 125)											if ((i1 >= 0)) {
HXLINE( 125)												undoImage2 = (i1 < (this2->byteLength >> 2));
            											}
            											else {
HXLINE( 125)												undoImage2 = false;
            											}
HXDLIN( 125)											if (undoImage2) {
HXLINE( 125)												 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 125)												int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 125)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 125)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 125)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 125)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 125)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE( 125)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 125)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 125)							{
HXLINE( 125)								v->width = width;
HXDLIN( 125)								v->height = height;
HXDLIN( 125)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 125)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 125)								{
HXLINE( 125)									int _g8 = 0;
HXDLIN( 125)									int _g9 = v->length;
HXDLIN( 125)									while((_g8 < _g9)){
HXLINE( 125)										_g8 = (_g8 + 1);
HXDLIN( 125)										int i2 = (_g8 - 1);
HXDLIN( 125)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN( 125)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 125)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 125)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 125)							{
HXLINE( 125)								b2->width = width;
HXDLIN( 125)								b2->height = height;
HXDLIN( 125)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 125)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 125)								{
HXLINE( 125)									int len1 = b2->length;
HXDLIN( 125)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 125)									if (::hx::IsNull( d->head )) {
HXLINE( 125)										int _g10 = 0;
HXDLIN( 125)										int _g11 = len1;
HXDLIN( 125)										while((_g10 < _g11)){
HXLINE( 125)											_g10 = (_g10 + 1);
HXDLIN( 125)											int i3 = (_g10 - 1);
HXDLIN( 125)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 125)										int _g12 = 0;
HXDLIN( 125)										int _g13 = len1;
HXDLIN( 125)										while((_g12 < _g13)){
HXLINE( 125)											_g12 = (_g12 + 1);
HXDLIN( 125)											int i4 = (_g12 - 1);
HXDLIN( 125)											{
HXLINE( 125)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 125)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 125)												{
HXLINE( 125)													int _g14 = 0;
HXDLIN( 125)													int _g15 = i4;
HXDLIN( 125)													while((_g14 < _g15)){
HXLINE( 125)														_g14 = (_g14 + 1);
HXDLIN( 125)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 125)												if (::hx::IsNull( prev )) {
HXLINE( 125)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 125)													l = null();
            												}
            												else {
HXLINE( 125)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 125)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 125)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 125)					this1->image = undoImage1;
HXDLIN( 125)					this1->width = width;
HXDLIN( 125)					this1->height = height;
HXDLIN( 125)					this1->imageType = ( (int)(imageType) );
HXDLIN( 125)					undoImage = this1;
HXDLIN( 125)					{
HXLINE( 125)						int rectLeft = xIter3->start;
HXDLIN( 125)						int rectTop = yIter3->start;
HXDLIN( 125)						int rectRight = xIter3->max;
HXDLIN( 125)						bool forceClear = false;
HXDLIN( 125)						{
HXLINE( 125)							int _g16 = rectTop;
HXDLIN( 125)							int _g17 = yIter3->max;
HXDLIN( 125)							while((_g16 < _g17)){
HXLINE( 125)								_g16 = (_g16 + 1);
HXDLIN( 125)								int dy1 = (_g16 - 1);
HXDLIN( 125)								{
HXLINE( 125)									int _g18 = rectLeft;
HXDLIN( 125)									int _g19 = rectRight;
HXDLIN( 125)									while((_g18 < _g19)){
HXLINE( 125)										_g18 = (_g18 + 1);
HXDLIN( 125)										int dx1 = (_g18 - 1);
HXDLIN( 125)										::Dynamic this3 = pixelImage->image;
HXDLIN( 125)										int index;
HXDLIN( 125)										if (pixelImage->useVirtualPos) {
HXLINE( 125)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 125)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            										}
HXDLIN( 125)										int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 125)										int col;
HXDLIN( 125)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 125)											col = c;
            										}
HXDLIN( 125)										bool _hx_tmp;
HXDLIN( 125)										if (pixelImage->useMask) {
HXLINE( 125)											_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 125)											_hx_tmp = false;
            										}
HXDLIN( 125)										if (_hx_tmp) {
HXLINE( 125)											 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 125)											::Dynamic this5 = this4->image;
HXDLIN( 125)											int index1;
HXDLIN( 125)											if (this4->useVirtualPos) {
HXLINE( 125)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            											}
            											else {
HXLINE( 125)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            											}
HXDLIN( 125)											int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 125)											int v1;
HXDLIN( 125)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 125)												v1 = c1;
            											}
HXDLIN( 125)											int maskPixel = v1;
HXDLIN( 125)											int this6 = col;
HXDLIN( 125)											if ((maskPixel == 0)) {
HXLINE( 125)												col = this6;
            											}
            											else {
HXLINE( 125)												Float m0;
HXDLIN( 125)												int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 125)												if ((this7 == 0)) {
HXLINE( 125)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float m1;
HXDLIN( 125)												int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 125)												if ((this8 == 0)) {
HXLINE( 125)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float m2;
HXDLIN( 125)												int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 125)												if ((this9 == 0)) {
HXLINE( 125)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float m3;
HXDLIN( 125)												int this10 = (maskPixel & 255);
HXDLIN( 125)												if ((this10 == 0)) {
HXLINE( 125)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 125)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 125)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 125)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 125)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 125)										if ((col != 0)) {
HXLINE( 125)											int x1 = (dx1 - rectLeft);
HXDLIN( 125)											int y1 = (dy1 - rectTop);
HXDLIN( 125)											int c2 = col;
HXDLIN( 125)											bool _hx_tmp1;
HXDLIN( 125)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 125)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE( 125)												_hx_tmp1 = false;
            											}
HXDLIN( 125)											if (_hx_tmp1) {
HXLINE( 125)												int location;
HXDLIN( 125)												if (undoImage->useVirtualPos) {
HXLINE( 125)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 125)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 125)												int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 125)												int this12;
HXDLIN( 125)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)													this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            												}
            												else {
HXLINE( 125)													this12 = this11;
            												}
HXDLIN( 125)												Float a1;
HXDLIN( 125)												int this13 = ((this12 >> 24) & 255);
HXDLIN( 125)												if ((this13 == 0)) {
HXLINE( 125)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float r1;
HXDLIN( 125)												int this14 = ((this12 >> 16) & 255);
HXDLIN( 125)												if ((this14 == 0)) {
HXLINE( 125)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float g1;
HXDLIN( 125)												int this15 = ((this12 >> 8) & 255);
HXDLIN( 125)												if ((this15 == 0)) {
HXLINE( 125)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float b11;
HXDLIN( 125)												int this16 = (this12 & 255);
HXDLIN( 125)												if ((this16 == 0)) {
HXLINE( 125)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float a2;
HXDLIN( 125)												int this17 = ((col >> 24) & 255);
HXDLIN( 125)												if ((this17 == 0)) {
HXLINE( 125)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float r2;
HXDLIN( 125)												int this18 = ((col >> 16) & 255);
HXDLIN( 125)												if ((this18 == 0)) {
HXLINE( 125)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float g2;
HXDLIN( 125)												int this19 = ((col >> 8) & 255);
HXDLIN( 125)												if ((this19 == 0)) {
HXLINE( 125)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float b21;
HXDLIN( 125)												int this20 = (col & 255);
HXDLIN( 125)												if ((this20 == 0)) {
HXLINE( 125)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 125)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 125)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 125)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 125)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 125)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 125)												{
HXLINE( 125)													int _hx_tmp2;
HXDLIN( 125)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 125)														_hx_tmp2 = blended;
            													}
HXDLIN( 125)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE( 125)												::Dynamic this21 = undoImage->image;
HXDLIN( 125)												int index2;
HXDLIN( 125)												if (undoImage->useVirtualPos) {
HXLINE( 125)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 125)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 125)												int _hx_tmp3;
HXDLIN( 125)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 125)													_hx_tmp3 = c2;
            												}
HXDLIN( 125)												::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE( 125)											if (forceClear) {
HXLINE( 125)												::Dynamic this22 = undoImage->image;
HXDLIN( 125)												int x2 = (dx1 - rectLeft);
HXDLIN( 125)												int y2 = (dy1 - rectTop);
HXDLIN( 125)												int index3;
HXDLIN( 125)												if (undoImage->useVirtualPos) {
HXLINE( 125)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 125)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 125)												::iterMagic::Iimg_obj::set(this22,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 125)				bool foundY = false;
HXDLIN( 125)				Float s = ((Float)0.);
HXDLIN( 125)				Float t = ((Float)0.);
HXDLIN( 125)				Float sxx = ((Float)0.);
HXDLIN( 125)				Float txx = ((Float)0.);
HXDLIN( 125)				{
HXLINE( 125)					int _g_min = xIter3->start;
HXDLIN( 125)					int _g_max = xIter3->max;
HXDLIN( 125)					while((_g_min < _g_max)){
HXLINE( 125)						_g_min = (_g_min + 1);
HXDLIN( 125)						int x3 = (_g_min - 1);
HXLINE( 222)						sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)						txx = (tx * ( (Float)(x3) ));
HXLINE( 224)						foundY = false;
HXLINE( 125)						{
HXLINE( 125)							int _g_min1 = yIter3->start;
HXDLIN( 125)							int _g_max1 = yIter3->max;
HXDLIN( 125)							while((_g_min1 < _g_max1)){
HXLINE( 125)								_g_min1 = (_g_min1 + 1);
HXDLIN( 125)								int y3 = (_g_min1 - 1);
HXLINE( 226)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 125)								bool _hx_tmp4;
HXDLIN( 125)								if (!((s <= 0))) {
HXLINE( 125)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXLINE( 125)									_hx_tmp4 = true;
            								}
HXDLIN( 125)								if (_hx_tmp4) {
HXLINE( 125)									if (foundY) {
HXLINE( 125)										goto _hx_goto_135;
            									}
            								}
            								else {
HXLINE( 125)									if (((s + t) < A)) {
HXLINE( 125)										int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 125)										int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 125)										::Dynamic this23 = tileImage->image;
HXDLIN( 125)										int index4;
HXDLIN( 125)										if (tileImage->useVirtualPos) {
HXLINE( 125)											index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            										}
            										else {
HXLINE( 125)											index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            										}
HXDLIN( 125)										int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 125)										int color;
HXDLIN( 125)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)											color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE( 125)											color = c3;
            										}
HXDLIN( 125)										{
HXLINE( 125)											int c4 = color;
HXDLIN( 125)											bool _hx_tmp5;
HXDLIN( 125)											if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 125)												_hx_tmp5 = pixelImage->transparent;
            											}
            											else {
HXLINE( 125)												_hx_tmp5 = false;
            											}
HXDLIN( 125)											if (_hx_tmp5) {
HXLINE( 125)												int location1;
HXDLIN( 125)												if (pixelImage->useVirtualPos) {
HXLINE( 125)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 125)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            												}
HXDLIN( 125)												int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 125)												int this25;
HXDLIN( 125)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)													this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXLINE( 125)													this25 = this24;
            												}
HXDLIN( 125)												Float a11;
HXDLIN( 125)												int this26 = ((this25 >> 24) & 255);
HXDLIN( 125)												if ((this26 == 0)) {
HXLINE( 125)													a11 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float r11;
HXDLIN( 125)												int this27 = ((this25 >> 16) & 255);
HXDLIN( 125)												if ((this27 == 0)) {
HXLINE( 125)													r11 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float g11;
HXDLIN( 125)												int this28 = ((this25 >> 8) & 255);
HXDLIN( 125)												if ((this28 == 0)) {
HXLINE( 125)													g11 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float b12;
HXDLIN( 125)												int this29 = (this25 & 255);
HXDLIN( 125)												if ((this29 == 0)) {
HXLINE( 125)													b12 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float a21;
HXDLIN( 125)												int this30 = ((color >> 24) & 255);
HXDLIN( 125)												if ((this30 == 0)) {
HXLINE( 125)													a21 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float r21;
HXDLIN( 125)												int this31 = ((color >> 16) & 255);
HXDLIN( 125)												if ((this31 == 0)) {
HXLINE( 125)													r21 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float g21;
HXDLIN( 125)												int this32 = ((color >> 8) & 255);
HXDLIN( 125)												if ((this32 == 0)) {
HXLINE( 125)													g21 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float b22;
HXDLIN( 125)												int this33 = (color & 255);
HXDLIN( 125)												if ((this33 == 0)) {
HXLINE( 125)													b22 = ((Float)0.);
            												}
            												else {
HXLINE( 125)													b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN( 125)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 125)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 125)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 125)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 125)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 125)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 125)												{
HXLINE( 125)													int _hx_tmp6;
HXDLIN( 125)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE( 125)														_hx_tmp6 = blended1;
            													}
HXDLIN( 125)													::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXLINE( 125)												::Dynamic this34 = pixelImage->image;
HXDLIN( 125)												int index5;
HXDLIN( 125)												if (pixelImage->useVirtualPos) {
HXLINE( 125)													index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 125)													index5 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            												}
HXDLIN( 125)												int _hx_tmp7;
HXDLIN( 125)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 125)													_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE( 125)													_hx_tmp7 = c4;
            												}
HXDLIN( 125)												::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp7);
            											}
            										}
HXLINE( 236)										foundY = true;
            									}
            									else {
HXLINE( 125)										if (foundY) {
HXLINE( 125)											goto _hx_goto_135;
            										}
            									}
            								}
            							}
            							_hx_goto_135:;
            						}
            					}
            				}
HXDLIN( 125)				if ((hasHit == false)) {
HXLINE( 125)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 125)					if (hasUndo) {
HXLINE( 125)						v2->undoImage = undoImage;
HXDLIN( 125)						v2->undoX = xIter3->start;
HXDLIN( 125)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXLINE( 126)		{
HXLINE( 126)			Float bx2 = cx;
HXDLIN( 126)			Float by2 = cy;
HXDLIN( 126)			Float cx2 = dx;
HXDLIN( 126)			Float cy2 = dy;
HXDLIN( 126)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN( 126)			if (!(adjustWinding1)) {
HXLINE( 126)				Float bx_1 = bx2;
HXDLIN( 126)				Float by_1 = by2;
HXLINE( 187)				bx2 = cx2;
HXLINE( 188)				by2 = cy2;
HXLINE( 189)				cx2 = bx_1;
HXLINE( 190)				cy2 = by_1;
            			}
HXLINE( 126)			{
HXLINE( 126)				bool hasUndo1 = false;
HXDLIN( 126)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN( 126)				Float sx1 = (cy2 - by);
HXDLIN( 126)				Float sy1 = (bx - cx2);
HXDLIN( 126)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN( 126)				Float tx1 = (by - by2);
HXDLIN( 126)				Float ty1 = (bx2 - bx);
HXDLIN( 126)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 126)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 126)				if ((bx > bx2)) {
HXLINE( 126)					if ((bx > cx2)) {
HXLINE( 126)						int min4;
HXDLIN( 126)						if ((bx2 > cx2)) {
HXLINE( 126)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 126)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 126)						int ii_min8 = min4;
HXDLIN( 126)						int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 126)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 126)						int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN( 126)						int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 126)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE( 126)					if ((bx2 > cx2)) {
HXLINE( 126)						int min5;
HXDLIN( 126)						if ((bx > cx2)) {
HXLINE( 126)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE( 126)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN( 126)						int ii_min10 = min5;
HXDLIN( 126)						int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN( 126)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE( 126)						int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 126)						int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 126)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN( 126)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 126)				if ((by > by2)) {
HXLINE( 126)					if ((by > cy2)) {
HXLINE( 126)						int min6;
HXDLIN( 126)						if ((by2 > cy2)) {
HXLINE( 126)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 126)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN( 126)						int ii_min12 = min6;
HXDLIN( 126)						int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 126)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE( 126)						int ii_min13 = ::Math_obj::floor(by2);
HXDLIN( 126)						int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 126)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE( 126)					if ((by2 > cy2)) {
HXLINE( 126)						int min7;
HXDLIN( 126)						if ((by > cy2)) {
HXLINE( 126)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE( 126)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN( 126)						int ii_min14 = min7;
HXDLIN( 126)						int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN( 126)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE( 126)						int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 126)						int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 126)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN( 126)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 126)				if (hasUndo1) {
HXLINE( 126)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 126)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 126)					 ::Dynamic imageType1 = null();
HXDLIN( 126)					 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 126)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 126)					::Dynamic undoImage4;
HXDLIN( 126)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 126)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 126)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 126)							{
HXLINE( 126)								b5->width = width1;
HXDLIN( 126)								b5->height = height1;
HXDLIN( 126)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 126)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 126)								{
HXLINE( 126)									int len2 = b5->length;
HXDLIN( 126)									int w1 = 0;
HXDLIN( 126)									{
HXLINE( 126)										int _g20 = 0;
HXDLIN( 126)										int _g21 = b5->height;
HXDLIN( 126)										while((_g20 < _g21)){
HXLINE( 126)											_g20 = (_g20 + 1);
HXDLIN( 126)											int y5 = (_g20 - 1);
HXDLIN( 126)											{
HXLINE( 126)												int _g22 = 0;
HXDLIN( 126)												int _g23 = b5->width;
HXDLIN( 126)												while((_g22 < _g23)){
HXLINE( 126)													_g22 = (_g22 + 1);
HXDLIN( 126)													int x5 = (_g22 - 1);
HXDLIN( 126)													{
HXLINE( 126)														w1 = (w1 + 1);
HXDLIN( 126)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 126)													{
HXLINE( 126)														w1 = (w1 + 1);
HXDLIN( 126)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 126)													{
HXLINE( 126)														w1 = (w1 + 1);
HXDLIN( 126)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 126)													{
HXLINE( 126)														w1 = (w1 + 1);
HXDLIN( 126)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 126)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXLINE( 126)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 126)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 126)							{
HXLINE( 126)								a6->width = width1;
HXDLIN( 126)								a6->height = height1;
HXDLIN( 126)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 126)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 126)								{
HXLINE( 126)									int _g24 = 0;
HXDLIN( 126)									int _g25 = a6->length;
HXDLIN( 126)									while((_g24 < _g25)){
HXLINE( 126)										_g24 = (_g24 + 1);
HXDLIN( 126)										int i6 = (_g24 - 1);
HXDLIN( 126)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN( 126)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXLINE( 126)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 126)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 126)							{
HXLINE( 126)								b6->width = width1;
HXDLIN( 126)								b6->height = height1;
HXDLIN( 126)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 126)								int size1 = (b6->length * 4);
HXDLIN( 126)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 126)								{
HXLINE( 126)									int _g26 = 0;
HXDLIN( 126)									int _g27 = b6->length;
HXDLIN( 126)									while((_g26 < _g27)){
HXLINE( 126)										_g26 = (_g26 + 1);
HXDLIN( 126)										int i7 = (_g26 - 1);
HXDLIN( 126)										{
HXLINE( 126)											 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN( 126)											bool undoImage5;
HXDLIN( 126)											if ((i7 >= 0)) {
HXLINE( 126)												undoImage5 = (i7 < (this36->byteLength >> 2));
            											}
            											else {
HXLINE( 126)												undoImage5 = false;
            											}
HXDLIN( 126)											if (undoImage5) {
HXLINE( 126)												 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 126)												int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 126)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 126)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 126)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 126)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 126)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXLINE( 126)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 126)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 126)							{
HXLINE( 126)								v3->width = width1;
HXDLIN( 126)								v3->height = height1;
HXDLIN( 126)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 126)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 126)								{
HXLINE( 126)									int _g28 = 0;
HXDLIN( 126)									int _g29 = v3->length;
HXDLIN( 126)									while((_g28 < _g29)){
HXLINE( 126)										_g28 = (_g28 + 1);
HXDLIN( 126)										int i8 = (_g28 - 1);
HXDLIN( 126)										v3->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN( 126)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE( 126)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 126)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 126)							{
HXLINE( 126)								b7->width = width1;
HXDLIN( 126)								b7->height = height1;
HXDLIN( 126)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 126)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 126)								{
HXLINE( 126)									int len3 = b7->length;
HXDLIN( 126)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 126)									if (::hx::IsNull( d1->head )) {
HXLINE( 126)										int _g30 = 0;
HXDLIN( 126)										int _g31 = len3;
HXDLIN( 126)										while((_g30 < _g31)){
HXLINE( 126)											_g30 = (_g30 + 1);
HXDLIN( 126)											int i9 = (_g30 - 1);
HXDLIN( 126)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 126)										int _g32 = 0;
HXDLIN( 126)										int _g33 = len3;
HXDLIN( 126)										while((_g32 < _g33)){
HXLINE( 126)											_g32 = (_g32 + 1);
HXDLIN( 126)											int i10 = (_g32 - 1);
HXDLIN( 126)											{
HXLINE( 126)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 126)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 126)												{
HXLINE( 126)													int _g34 = 0;
HXDLIN( 126)													int _g35 = i10;
HXDLIN( 126)													while((_g34 < _g35)){
HXLINE( 126)														_g34 = (_g34 + 1);
HXDLIN( 126)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 126)												if (::hx::IsNull( prev1 )) {
HXLINE( 126)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 126)													l1 = null();
            												}
            												else {
HXLINE( 126)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 126)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 126)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN( 126)					this35->image = undoImage4;
HXDLIN( 126)					this35->width = width1;
HXDLIN( 126)					this35->height = height1;
HXDLIN( 126)					this35->imageType = ( (int)(imageType1) );
HXDLIN( 126)					undoImage3 = this35;
HXDLIN( 126)					{
HXLINE( 126)						int rectLeft1 = xIter31->start;
HXDLIN( 126)						int rectTop1 = yIter31->start;
HXDLIN( 126)						int rectRight1 = xIter31->max;
HXDLIN( 126)						bool forceClear1 = false;
HXDLIN( 126)						{
HXLINE( 126)							int _g36 = rectTop1;
HXDLIN( 126)							int _g37 = yIter31->max;
HXDLIN( 126)							while((_g36 < _g37)){
HXLINE( 126)								_g36 = (_g36 + 1);
HXDLIN( 126)								int dy2 = (_g36 - 1);
HXDLIN( 126)								{
HXLINE( 126)									int _g38 = rectLeft1;
HXDLIN( 126)									int _g39 = rectRight1;
HXDLIN( 126)									while((_g38 < _g39)){
HXLINE( 126)										_g38 = (_g38 + 1);
HXDLIN( 126)										int dx2 = (_g38 - 1);
HXDLIN( 126)										::Dynamic this37 = pixelImage->image;
HXDLIN( 126)										int index6;
HXDLIN( 126)										if (pixelImage->useVirtualPos) {
HXLINE( 126)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 126)											index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 126)										int c5 = ::iterMagic::Iimg_obj::get(this37,index6);
HXDLIN( 126)										int col1;
HXDLIN( 126)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)											col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 126)											col1 = c5;
            										}
HXDLIN( 126)										bool _hx_tmp8;
HXDLIN( 126)										if (pixelImage->useMask) {
HXLINE( 126)											_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 126)											_hx_tmp8 = false;
            										}
HXDLIN( 126)										if (_hx_tmp8) {
HXLINE( 126)											 ::pi_xy::ImageStruct this38 = pixelImage->mask;
HXDLIN( 126)											::Dynamic this39 = this38->image;
HXDLIN( 126)											int index7;
HXDLIN( 126)											if (this38->useVirtualPos) {
HXLINE( 126)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            											}
            											else {
HXLINE( 126)												index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            											}
HXDLIN( 126)											int c6 = ::iterMagic::Iimg_obj::get(this39,index7);
HXDLIN( 126)											int v4;
HXDLIN( 126)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)												v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 126)												v4 = c6;
            											}
HXDLIN( 126)											int maskPixel1 = v4;
HXDLIN( 126)											int this40 = col1;
HXDLIN( 126)											if ((maskPixel1 == 0)) {
HXLINE( 126)												col1 = this40;
            											}
            											else {
HXLINE( 126)												Float m01;
HXDLIN( 126)												int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 126)												if ((this41 == 0)) {
HXLINE( 126)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float m11;
HXDLIN( 126)												int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 126)												if ((this42 == 0)) {
HXLINE( 126)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float m21;
HXDLIN( 126)												int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 126)												if ((this43 == 0)) {
HXLINE( 126)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float m31;
HXDLIN( 126)												int this44 = (maskPixel1 & 255);
HXDLIN( 126)												if ((this44 == 0)) {
HXLINE( 126)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 126)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 126)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 126)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 126)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 126)										if ((col1 != 0)) {
HXLINE( 126)											int x6 = (dx2 - rectLeft1);
HXDLIN( 126)											int y6 = (dy2 - rectTop1);
HXDLIN( 126)											int c7 = col1;
HXDLIN( 126)											bool _hx_tmp9;
HXDLIN( 126)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 126)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXLINE( 126)												_hx_tmp9 = false;
            											}
HXDLIN( 126)											if (_hx_tmp9) {
HXLINE( 126)												int location2;
HXDLIN( 126)												if (undoImage3->useVirtualPos) {
HXLINE( 126)													location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 126)													location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 126)												int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 126)												int this46;
HXDLIN( 126)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)													this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            												}
            												else {
HXLINE( 126)													this46 = this45;
            												}
HXDLIN( 126)												Float a12;
HXDLIN( 126)												int this47 = ((this46 >> 24) & 255);
HXDLIN( 126)												if ((this47 == 0)) {
HXLINE( 126)													a12 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float r12;
HXDLIN( 126)												int this48 = ((this46 >> 16) & 255);
HXDLIN( 126)												if ((this48 == 0)) {
HXLINE( 126)													r12 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float g12;
HXDLIN( 126)												int this49 = ((this46 >> 8) & 255);
HXDLIN( 126)												if ((this49 == 0)) {
HXLINE( 126)													g12 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float b13;
HXDLIN( 126)												int this50 = (this46 & 255);
HXDLIN( 126)												if ((this50 == 0)) {
HXLINE( 126)													b13 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float a22;
HXDLIN( 126)												int this51 = ((col1 >> 24) & 255);
HXDLIN( 126)												if ((this51 == 0)) {
HXLINE( 126)													a22 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float r22;
HXDLIN( 126)												int this52 = ((col1 >> 16) & 255);
HXDLIN( 126)												if ((this52 == 0)) {
HXLINE( 126)													r22 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float g22;
HXDLIN( 126)												int this53 = ((col1 >> 8) & 255);
HXDLIN( 126)												if ((this53 == 0)) {
HXLINE( 126)													g22 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float b23;
HXDLIN( 126)												int this54 = (col1 & 255);
HXDLIN( 126)												if ((this54 == 0)) {
HXLINE( 126)													b23 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 126)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 126)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 126)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 126)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 126)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 126)												{
HXLINE( 126)													int _hx_tmp10;
HXDLIN( 126)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE( 126)														_hx_tmp10 = blended2;
            													}
HXDLIN( 126)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXLINE( 126)												::Dynamic this55 = undoImage3->image;
HXDLIN( 126)												int index8;
HXDLIN( 126)												if (undoImage3->useVirtualPos) {
HXLINE( 126)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 126)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 126)												int _hx_tmp11;
HXDLIN( 126)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)													_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE( 126)													_hx_tmp11 = c7;
            												}
HXDLIN( 126)												::iterMagic::Iimg_obj::set(this55,index8,_hx_tmp11);
            											}
            										}
            										else {
HXLINE( 126)											if (forceClear1) {
HXLINE( 126)												::Dynamic this56 = undoImage3->image;
HXDLIN( 126)												int x7 = (dx2 - rectLeft1);
HXDLIN( 126)												int y7 = (dy2 - rectTop1);
HXDLIN( 126)												int index9;
HXDLIN( 126)												if (undoImage3->useVirtualPos) {
HXLINE( 126)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 126)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            												}
HXDLIN( 126)												::iterMagic::Iimg_obj::set(this56,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 126)				bool foundY1 = false;
HXDLIN( 126)				Float s1 = ((Float)0.);
HXDLIN( 126)				Float t1 = ((Float)0.);
HXDLIN( 126)				Float sxx1 = ((Float)0.);
HXDLIN( 126)				Float txx1 = ((Float)0.);
HXDLIN( 126)				{
HXLINE( 126)					int _g_min2 = xIter31->start;
HXDLIN( 126)					int _g_max2 = xIter31->max;
HXDLIN( 126)					while((_g_min2 < _g_max2)){
HXLINE( 126)						_g_min2 = (_g_min2 + 1);
HXDLIN( 126)						int x8 = (_g_min2 - 1);
HXLINE( 222)						sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)						txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)						foundY1 = false;
HXLINE( 126)						{
HXLINE( 126)							int _g_min3 = yIter31->start;
HXDLIN( 126)							int _g_max3 = yIter31->max;
HXDLIN( 126)							while((_g_min3 < _g_max3)){
HXLINE( 126)								_g_min3 = (_g_min3 + 1);
HXDLIN( 126)								int y8 = (_g_min3 - 1);
HXLINE( 226)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 126)								bool _hx_tmp12;
HXDLIN( 126)								if (!((s1 <= 0))) {
HXLINE( 126)									_hx_tmp12 = (t1 <= 0);
            								}
            								else {
HXLINE( 126)									_hx_tmp12 = true;
            								}
HXDLIN( 126)								if (_hx_tmp12) {
HXLINE( 126)									if (foundY1) {
HXLINE( 126)										goto _hx_goto_147;
            									}
            								}
            								else {
HXLINE( 126)									if (((s1 + t1) < A1)) {
HXLINE( 126)										int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 126)										int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 126)										::Dynamic this57 = tileImage->image;
HXDLIN( 126)										int index10;
HXDLIN( 126)										if (tileImage->useVirtualPos) {
HXLINE( 126)											index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            										}
            										else {
HXLINE( 126)											index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            										}
HXDLIN( 126)										int c8 = ::iterMagic::Iimg_obj::get(this57,index10);
HXDLIN( 126)										int color1;
HXDLIN( 126)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)											color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE( 126)											color1 = c8;
            										}
HXDLIN( 126)										{
HXLINE( 126)											int c9 = color1;
HXDLIN( 126)											bool _hx_tmp13;
HXDLIN( 126)											if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 126)												_hx_tmp13 = pixelImage->transparent;
            											}
            											else {
HXLINE( 126)												_hx_tmp13 = false;
            											}
HXDLIN( 126)											if (_hx_tmp13) {
HXLINE( 126)												int location3;
HXDLIN( 126)												if (pixelImage->useVirtualPos) {
HXLINE( 126)													location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x8) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 126)													location3 = ::Std_obj::_hx_int(( (Float)(((y8 * pixelImage->width) + x8)) ));
            												}
HXDLIN( 126)												int this58 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 126)												int this59;
HXDLIN( 126)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)													this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            												}
            												else {
HXLINE( 126)													this59 = this58;
            												}
HXDLIN( 126)												Float a13;
HXDLIN( 126)												int this60 = ((this59 >> 24) & 255);
HXDLIN( 126)												if ((this60 == 0)) {
HXLINE( 126)													a13 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float r13;
HXDLIN( 126)												int this61 = ((this59 >> 16) & 255);
HXDLIN( 126)												if ((this61 == 0)) {
HXLINE( 126)													r13 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float g13;
HXDLIN( 126)												int this62 = ((this59 >> 8) & 255);
HXDLIN( 126)												if ((this62 == 0)) {
HXLINE( 126)													g13 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float b14;
HXDLIN( 126)												int this63 = (this59 & 255);
HXDLIN( 126)												if ((this63 == 0)) {
HXLINE( 126)													b14 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													b14 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float a23;
HXDLIN( 126)												int this64 = ((color1 >> 24) & 255);
HXDLIN( 126)												if ((this64 == 0)) {
HXLINE( 126)													a23 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float r23;
HXDLIN( 126)												int this65 = ((color1 >> 16) & 255);
HXDLIN( 126)												if ((this65 == 0)) {
HXLINE( 126)													r23 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float g23;
HXDLIN( 126)												int this66 = ((color1 >> 8) & 255);
HXDLIN( 126)												if ((this66 == 0)) {
HXLINE( 126)													g23 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float b24;
HXDLIN( 126)												int this67 = (color1 & 255);
HXDLIN( 126)												if ((this67 == 0)) {
HXLINE( 126)													b24 = ((Float)0.);
            												}
            												else {
HXLINE( 126)													b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN( 126)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 126)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 126)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 126)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 126)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 126)												int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 126)												{
HXLINE( 126)													int _hx_tmp14;
HXDLIN( 126)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE( 126)														_hx_tmp14 = blended3;
            													}
HXDLIN( 126)													::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXLINE( 126)												::Dynamic this68 = pixelImage->image;
HXDLIN( 126)												int index11;
HXDLIN( 126)												if (pixelImage->useVirtualPos) {
HXLINE( 126)													index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x8) - pixelImage->virtualX));
            												}
            												else {
HXLINE( 126)													index11 = ::Std_obj::_hx_int(( (Float)(((y8 * pixelImage->width) + x8)) ));
            												}
HXDLIN( 126)												int _hx_tmp15;
HXDLIN( 126)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 126)													_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE( 126)													_hx_tmp15 = c9;
            												}
HXDLIN( 126)												::iterMagic::Iimg_obj::set(this68,index11,_hx_tmp15);
            											}
            										}
HXLINE( 236)										foundY1 = true;
            									}
            									else {
HXLINE( 126)										if (foundY1) {
HXLINE( 126)											goto _hx_goto_147;
            										}
            									}
            								}
            							}
            							_hx_goto_147:;
            						}
            					}
            				}
HXDLIN( 126)				if ((hasHit == false)) {
HXLINE( 126)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN( 126)					if (hasUndo1) {
HXLINE( 126)						v5->undoImage = undoImage3;
HXDLIN( 126)						v5->undoX = xIter31->start;
HXDLIN( 126)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXLINE( 127)		if ((hasHit == true)) {
HXLINE( 128)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE( 129)			return v6;
            		}
            		else {
HXLINE( 131)			return null();
            		}
HXLINE( 127)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(QuadPixel_Fields__obj,tileQuadrilateral,return )

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::fillGradQuadrilateral( ::pi_xy::ImageStruct pixelImage,Float ax,Float ay,int colorA,Float bx,Float by,int colorB,Float cx,Float cy,int colorC,Float dx,Float dy,int colorD,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_141_fillGradQuadrilateral)
HXLINE( 144)		{
HXLINE( 144)			bool hasUndo = false;
HXDLIN( 144)			int aA = ((colorB >> 24) & 255);
HXDLIN( 144)			int rA = ((colorB >> 16) & 255);
HXDLIN( 144)			int gA = ((colorB >> 8) & 255);
HXDLIN( 144)			int bA = (colorB & 255);
HXDLIN( 144)			int aB = ((colorA >> 24) & 255);
HXDLIN( 144)			int rB = ((colorA >> 16) & 255);
HXDLIN( 144)			int gB = ((colorA >> 8) & 255);
HXDLIN( 144)			int bB = (colorA & 255);
HXDLIN( 144)			int aC = ((colorD >> 24) & 255);
HXDLIN( 144)			int rC = ((colorD >> 16) & 255);
HXDLIN( 144)			int gC = ((colorD >> 8) & 255);
HXDLIN( 144)			int bC = (colorD & 255);
HXDLIN( 144)			Float bcx = (bx - dx);
HXDLIN( 144)			Float bcy = (by - dy);
HXDLIN( 144)			Float acx = (ax - dx);
HXDLIN( 144)			Float acy = (ay - dy);
HXDLIN( 144)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 144)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 144)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 144)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 144)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 144)			if ((ax > bx)) {
HXLINE( 144)				if ((ax > dx)) {
HXLINE( 144)					int min;
HXDLIN( 144)					if ((bx > dx)) {
HXLINE( 144)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 144)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 144)					int ii_min = min;
HXDLIN( 144)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 144)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE( 144)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 144)					int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 144)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE( 144)				if ((bx > dx)) {
HXLINE( 144)					int min1;
HXDLIN( 144)					if ((ax > dx)) {
HXLINE( 144)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 144)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 144)					int ii_min2 = min1;
HXDLIN( 144)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 144)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE( 144)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 144)					int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 144)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN( 144)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 144)			if ((ay > by)) {
HXLINE( 144)				if ((ay > dy)) {
HXLINE( 144)					int min2;
HXDLIN( 144)					if ((by > dy)) {
HXLINE( 144)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 144)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 144)					int ii_min4 = min2;
HXDLIN( 144)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 144)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE( 144)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 144)					int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 144)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE( 144)				if ((by > dy)) {
HXLINE( 144)					int min3;
HXDLIN( 144)					if ((ay > dy)) {
HXLINE( 144)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 144)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 144)					int ii_min6 = min3;
HXDLIN( 144)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 144)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE( 144)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 144)					int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 144)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN( 144)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 144)			if (hasUndo) {
HXLINE( 144)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 144)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 144)				 ::Dynamic imageType = null();
HXDLIN( 144)				 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 144)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 144)				::Dynamic undoImage1;
HXDLIN( 144)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 144)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 144)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 144)						{
HXLINE( 144)							b->width = width;
HXDLIN( 144)							b->height = height;
HXDLIN( 144)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 144)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 144)							{
HXLINE( 144)								int len = b->length;
HXDLIN( 144)								int w = 0;
HXDLIN( 144)								{
HXLINE( 144)									int _g = 0;
HXDLIN( 144)									int _g1 = b->height;
HXDLIN( 144)									while((_g < _g1)){
HXLINE( 144)										_g = (_g + 1);
HXDLIN( 144)										int y = (_g - 1);
HXDLIN( 144)										{
HXLINE( 144)											int _g2 = 0;
HXDLIN( 144)											int _g3 = b->width;
HXDLIN( 144)											while((_g2 < _g3)){
HXLINE( 144)												_g2 = (_g2 + 1);
HXDLIN( 144)												int x = (_g2 - 1);
HXDLIN( 144)												{
HXLINE( 144)													w = (w + 1);
HXDLIN( 144)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 144)												{
HXLINE( 144)													w = (w + 1);
HXDLIN( 144)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 144)												{
HXLINE( 144)													w = (w + 1);
HXDLIN( 144)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 144)												{
HXLINE( 144)													w = (w + 1);
HXDLIN( 144)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 144)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE( 144)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 144)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 144)						{
HXLINE( 144)							a->width = width;
HXDLIN( 144)							a->height = height;
HXDLIN( 144)							a->data = ::Array_obj< int >::__new(0);
HXDLIN( 144)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 144)							{
HXLINE( 144)								int _g4 = 0;
HXDLIN( 144)								int _g5 = a->length;
HXDLIN( 144)								while((_g4 < _g5)){
HXLINE( 144)									_g4 = (_g4 + 1);
HXDLIN( 144)									int i = (_g4 - 1);
HXDLIN( 144)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 144)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE( 144)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 144)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 144)						{
HXLINE( 144)							b1->width = width;
HXDLIN( 144)							b1->height = height;
HXDLIN( 144)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 144)							int size = (b1->length * 4);
HXDLIN( 144)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 144)							{
HXLINE( 144)								int _g6 = 0;
HXDLIN( 144)								int _g7 = b1->length;
HXDLIN( 144)								while((_g6 < _g7)){
HXLINE( 144)									_g6 = (_g6 + 1);
HXDLIN( 144)									int i1 = (_g6 - 1);
HXDLIN( 144)									{
HXLINE( 144)										 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 144)										bool undoImage2;
HXDLIN( 144)										if ((i1 >= 0)) {
HXLINE( 144)											undoImage2 = (i1 < (this2->byteLength >> 2));
            										}
            										else {
HXLINE( 144)											undoImage2 = false;
            										}
HXDLIN( 144)										if (undoImage2) {
HXLINE( 144)											 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 144)											int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 144)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 144)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 144)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 144)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 144)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE( 144)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 144)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 144)						{
HXLINE( 144)							v->width = width;
HXDLIN( 144)							v->height = height;
HXDLIN( 144)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 144)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 144)							{
HXLINE( 144)								int _g8 = 0;
HXDLIN( 144)								int _g9 = v->length;
HXDLIN( 144)								while((_g8 < _g9)){
HXLINE( 144)									_g8 = (_g8 + 1);
HXDLIN( 144)									int i2 = (_g8 - 1);
HXDLIN( 144)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 144)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 144)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 144)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 144)						{
HXLINE( 144)							b2->width = width;
HXDLIN( 144)							b2->height = height;
HXDLIN( 144)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 144)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 144)							{
HXLINE( 144)								int len1 = b2->length;
HXDLIN( 144)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 144)								if (::hx::IsNull( d->head )) {
HXLINE( 144)									int _g10 = 0;
HXDLIN( 144)									int _g11 = len1;
HXDLIN( 144)									while((_g10 < _g11)){
HXLINE( 144)										_g10 = (_g10 + 1);
HXDLIN( 144)										int i3 = (_g10 - 1);
HXDLIN( 144)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 144)									int _g12 = 0;
HXDLIN( 144)									int _g13 = len1;
HXDLIN( 144)									while((_g12 < _g13)){
HXLINE( 144)										_g12 = (_g12 + 1);
HXDLIN( 144)										int i4 = (_g12 - 1);
HXDLIN( 144)										{
HXLINE( 144)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 144)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 144)											{
HXLINE( 144)												int _g14 = 0;
HXDLIN( 144)												int _g15 = i4;
HXDLIN( 144)												while((_g14 < _g15)){
HXLINE( 144)													_g14 = (_g14 + 1);
HXDLIN( 144)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 144)											if (::hx::IsNull( prev )) {
HXLINE( 144)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 144)												l = null();
            											}
            											else {
HXLINE( 144)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 144)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 144)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 144)				this1->image = undoImage1;
HXDLIN( 144)				this1->width = width;
HXDLIN( 144)				this1->height = height;
HXDLIN( 144)				this1->imageType = ( (int)(imageType) );
HXDLIN( 144)				undoImage = this1;
HXDLIN( 144)				{
HXLINE( 144)					int rectLeft = xIter3->start;
HXDLIN( 144)					int rectTop = yIter3->start;
HXDLIN( 144)					int rectRight = xIter3->max;
HXDLIN( 144)					bool forceClear = false;
HXDLIN( 144)					{
HXLINE( 144)						int _g16 = rectTop;
HXDLIN( 144)						int _g17 = yIter3->max;
HXDLIN( 144)						while((_g16 < _g17)){
HXLINE( 144)							_g16 = (_g16 + 1);
HXDLIN( 144)							int dy1 = (_g16 - 1);
HXDLIN( 144)							{
HXLINE( 144)								int _g18 = rectLeft;
HXDLIN( 144)								int _g19 = rectRight;
HXDLIN( 144)								while((_g18 < _g19)){
HXLINE( 144)									_g18 = (_g18 + 1);
HXDLIN( 144)									int dx1 = (_g18 - 1);
HXDLIN( 144)									::Dynamic this3 = pixelImage->image;
HXDLIN( 144)									int index;
HXDLIN( 144)									if (pixelImage->useVirtualPos) {
HXLINE( 144)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 144)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 144)									int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 144)									int col;
HXDLIN( 144)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 144)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 144)										col = c;
            									}
HXDLIN( 144)									bool _hx_tmp;
HXDLIN( 144)									if (pixelImage->useMask) {
HXLINE( 144)										_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 144)										_hx_tmp = false;
            									}
HXDLIN( 144)									if (_hx_tmp) {
HXLINE( 144)										 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 144)										::Dynamic this5 = this4->image;
HXDLIN( 144)										int index1;
HXDLIN( 144)										if (this4->useVirtualPos) {
HXLINE( 144)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXLINE( 144)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN( 144)										int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 144)										int v1;
HXDLIN( 144)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 144)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE( 144)											v1 = c1;
            										}
HXDLIN( 144)										int maskPixel = v1;
HXDLIN( 144)										int this6 = col;
HXDLIN( 144)										if ((maskPixel == 0)) {
HXLINE( 144)											col = this6;
            										}
            										else {
HXLINE( 144)											Float m0;
HXDLIN( 144)											int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 144)											if ((this7 == 0)) {
HXLINE( 144)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float m1;
HXDLIN( 144)											int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 144)											if ((this8 == 0)) {
HXLINE( 144)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float m2;
HXDLIN( 144)											int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 144)											if ((this9 == 0)) {
HXLINE( 144)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float m3;
HXDLIN( 144)											int this10 = (maskPixel & 255);
HXDLIN( 144)											if ((this10 == 0)) {
HXLINE( 144)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 144)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 144)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 144)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 144)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 144)									if ((col != 0)) {
HXLINE( 144)										int x1 = (dx1 - rectLeft);
HXDLIN( 144)										int y1 = (dy1 - rectTop);
HXDLIN( 144)										int c2 = col;
HXDLIN( 144)										bool _hx_tmp1;
HXDLIN( 144)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 144)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXLINE( 144)											_hx_tmp1 = false;
            										}
HXDLIN( 144)										if (_hx_tmp1) {
HXLINE( 144)											int location;
HXDLIN( 144)											if (undoImage->useVirtualPos) {
HXLINE( 144)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 144)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 144)											int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 144)											int this12;
HXDLIN( 144)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 144)												this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            											}
            											else {
HXLINE( 144)												this12 = this11;
            											}
HXDLIN( 144)											Float a1;
HXDLIN( 144)											int this13 = ((this12 >> 24) & 255);
HXDLIN( 144)											if ((this13 == 0)) {
HXLINE( 144)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float r1;
HXDLIN( 144)											int this14 = ((this12 >> 16) & 255);
HXDLIN( 144)											if ((this14 == 0)) {
HXLINE( 144)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float g1;
HXDLIN( 144)											int this15 = ((this12 >> 8) & 255);
HXDLIN( 144)											if ((this15 == 0)) {
HXLINE( 144)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float b11;
HXDLIN( 144)											int this16 = (this12 & 255);
HXDLIN( 144)											if ((this16 == 0)) {
HXLINE( 144)												b11 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float a2;
HXDLIN( 144)											int this17 = ((col >> 24) & 255);
HXDLIN( 144)											if ((this17 == 0)) {
HXLINE( 144)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float r2;
HXDLIN( 144)											int this18 = ((col >> 16) & 255);
HXDLIN( 144)											if ((this18 == 0)) {
HXLINE( 144)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float g2;
HXDLIN( 144)											int this19 = ((col >> 8) & 255);
HXDLIN( 144)											if ((this19 == 0)) {
HXLINE( 144)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float b21;
HXDLIN( 144)											int this20 = (col & 255);
HXDLIN( 144)											if ((this20 == 0)) {
HXLINE( 144)												b21 = ((Float)0.);
            											}
            											else {
HXLINE( 144)												b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 144)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 144)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 144)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 144)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 144)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 144)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 144)											{
HXLINE( 144)												int _hx_tmp2;
HXDLIN( 144)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 144)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 144)													_hx_tmp2 = blended;
            												}
HXDLIN( 144)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXLINE( 144)											::Dynamic this21 = undoImage->image;
HXDLIN( 144)											int index2;
HXDLIN( 144)											if (undoImage->useVirtualPos) {
HXLINE( 144)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 144)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 144)											int _hx_tmp3;
HXDLIN( 144)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 144)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE( 144)												_hx_tmp3 = c2;
            											}
HXDLIN( 144)											::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            										}
            									}
            									else {
HXLINE( 144)										if (forceClear) {
HXLINE( 144)											::Dynamic this22 = undoImage->image;
HXDLIN( 144)											int x2 = (dx1 - rectLeft);
HXDLIN( 144)											int y2 = (dy1 - rectTop);
HXDLIN( 144)											int index3;
HXDLIN( 144)											if (undoImage->useVirtualPos) {
HXLINE( 144)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE( 144)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN( 144)											::iterMagic::Iimg_obj::set(this22,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 144)			{
HXLINE( 144)				int _g_min = xIter3->start;
HXDLIN( 144)				int _g_max = xIter3->max;
HXDLIN( 144)				while((_g_min < _g_max)){
HXLINE( 144)					_g_min = (_g_min + 1);
HXDLIN( 144)					int px = (_g_min - 1);
HXDLIN( 144)					Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 144)					{
HXLINE( 144)						int _g_min1 = yIter3->start;
HXDLIN( 144)						int _g_max1 = yIter3->max;
HXDLIN( 144)						while((_g_min1 < _g_max1)){
HXLINE( 144)							_g_min1 = (_g_min1 + 1);
HXDLIN( 144)							int py = (_g_min1 - 1);
HXDLIN( 144)							Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 144)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 144)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 144)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 144)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 144)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 144)							bool _hx_tmp4;
HXDLIN( 144)							bool _hx_tmp5;
HXDLIN( 144)							if ((ratioA >= 0)) {
HXLINE( 144)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXLINE( 144)								_hx_tmp5 = false;
            							}
HXDLIN( 144)							if (_hx_tmp5) {
HXLINE( 144)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXLINE( 144)								_hx_tmp4 = false;
            							}
HXDLIN( 144)							if (_hx_tmp4) {
HXLINE( 144)								int i6 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN( 144)								if ((i6 > 255)) {
HXLINE(  24)									i6 = 255;
            								}
HXLINE( 144)								if ((i6 < 0)) {
HXLINE(  25)									i6 = 0;
            								}
HXLINE( 144)								int a5 = i6;
HXDLIN( 144)								int i7 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN( 144)								if ((i7 > 255)) {
HXLINE(  24)									i7 = 255;
            								}
HXLINE( 144)								if ((i7 < 0)) {
HXLINE(  25)									i7 = 0;
            								}
HXLINE( 144)								int r3 = i7;
HXDLIN( 144)								int i8 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN( 144)								if ((i8 > 255)) {
HXLINE(  24)									i8 = 255;
            								}
HXLINE( 144)								if ((i8 < 0)) {
HXLINE(  25)									i8 = 0;
            								}
HXLINE( 144)								int g3 = i8;
HXDLIN( 144)								int i9 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN( 144)								if ((i9 > 255)) {
HXLINE(  24)									i9 = 255;
            								}
HXLINE( 144)								if ((i9 < 0)) {
HXLINE(  25)									i9 = 0;
            								}
HXLINE( 144)								int b4 = i9;
HXDLIN( 144)								{
HXLINE( 144)									int location1;
HXDLIN( 144)									if (pixelImage->useVirtualPos) {
HXLINE( 144)										location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 144)										location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            									}
HXDLIN( 144)									bool _hx_tmp6;
HXDLIN( 144)									if (pixelImage->transparent) {
HXLINE( 144)										_hx_tmp6 = (a5 < 254);
            									}
            									else {
HXLINE( 144)										_hx_tmp6 = false;
            									}
HXDLIN( 144)									if (_hx_tmp6) {
HXLINE( 144)										int this23 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 144)										int old;
HXDLIN( 144)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 144)											old = ((((((this23 >> 24) & 255) << 24) | ((this23 & 255) << 16)) | (((this23 >> 8) & 255) << 8)) | ((this23 >> 16) & 255));
            										}
            										else {
HXLINE( 144)											old = this23;
            										}
HXDLIN( 144)										int rhs = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 144)										Float a11;
HXDLIN( 144)										int this24 = ((old >> 24) & 255);
HXDLIN( 144)										if ((this24 == 0)) {
HXLINE( 144)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 144)											a11 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN( 144)										Float r11;
HXDLIN( 144)										int this25 = ((old >> 16) & 255);
HXDLIN( 144)										if ((this25 == 0)) {
HXLINE( 144)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 144)											r11 = (( (Float)(this25) ) / ( (Float)(255) ));
            										}
HXDLIN( 144)										Float g11;
HXDLIN( 144)										int this26 = ((old >> 8) & 255);
HXDLIN( 144)										if ((this26 == 0)) {
HXLINE( 144)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 144)											g11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 144)										Float b12;
HXDLIN( 144)										int this27 = (old & 255);
HXDLIN( 144)										if ((this27 == 0)) {
HXLINE( 144)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 144)											b12 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 144)										Float a21;
HXDLIN( 144)										int this28 = ((rhs >> 24) & 255);
HXDLIN( 144)										if ((this28 == 0)) {
HXLINE( 144)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 144)											a21 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 144)										Float r21;
HXDLIN( 144)										int this29 = ((rhs >> 16) & 255);
HXDLIN( 144)										if ((this29 == 0)) {
HXLINE( 144)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 144)											r21 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 144)										Float g21;
HXDLIN( 144)										int this30 = ((rhs >> 8) & 255);
HXDLIN( 144)										if ((this30 == 0)) {
HXLINE( 144)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 144)											g21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 144)										Float b22;
HXDLIN( 144)										int this31 = (rhs & 255);
HXDLIN( 144)										if ((this31 == 0)) {
HXLINE( 144)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 144)											b22 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 144)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 144)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 144)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 144)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 144)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 144)										int blended1 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN( 144)										{
HXLINE( 144)											int _hx_tmp7;
HXDLIN( 144)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 144)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 144)												_hx_tmp7 = blended1;
            											}
HXDLIN( 144)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXLINE( 144)										int value;
HXDLIN( 144)										if (pixelImage->isLittle) {
HXLINE( 144)											value = ((((a5 << 24) | (b4 << 16)) | (g3 << 8)) | r3);
            										}
            										else {
HXLINE( 144)											value = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
            										}
HXDLIN( 144)										::iterMagic::Iimg_obj::set(pixelImage->image,location1,value);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 144)			if ((hasHit == false)) {
HXLINE( 144)				 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN( 144)				if (hasUndo) {
HXLINE( 144)					v2->undoImage = undoImage;
HXDLIN( 144)					v2->undoX = xIter3->start;
HXDLIN( 144)					v2->undoY = yIter3->start;
            				}
            			}
            		}
HXLINE( 145)		{
HXLINE( 145)			bool hasHit1 = false;
HXDLIN( 145)			bool hasUndo1 = false;
HXDLIN( 145)			int aA1 = ((colorC >> 24) & 255);
HXDLIN( 145)			int rA1 = ((colorC >> 16) & 255);
HXDLIN( 145)			int gA1 = ((colorC >> 8) & 255);
HXDLIN( 145)			int bA1 = (colorC & 255);
HXDLIN( 145)			int aB1 = ((colorB >> 24) & 255);
HXDLIN( 145)			int rB1 = ((colorB >> 16) & 255);
HXDLIN( 145)			int gB1 = ((colorB >> 8) & 255);
HXDLIN( 145)			int bB1 = (colorB & 255);
HXDLIN( 145)			int aC1 = ((colorD >> 24) & 255);
HXDLIN( 145)			int rC1 = ((colorD >> 16) & 255);
HXDLIN( 145)			int gC1 = ((colorD >> 8) & 255);
HXDLIN( 145)			int bC1 = (colorD & 255);
HXDLIN( 145)			Float bcx1 = (cx - dx);
HXDLIN( 145)			Float bcy1 = (cy - dy);
HXDLIN( 145)			Float acx1 = (bx - dx);
HXDLIN( 145)			Float acy1 = (by - dy);
HXDLIN( 145)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 145)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 145)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 145)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 145)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 145)			if ((bx > cx)) {
HXLINE( 145)				if ((bx > dx)) {
HXLINE( 145)					int min4;
HXDLIN( 145)					if ((cx > dx)) {
HXLINE( 145)						min4 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 145)						min4 = ::Math_obj::floor(cx);
            					}
HXDLIN( 145)					int ii_min8 = min4;
HXDLIN( 145)					int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 145)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 145)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 145)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 145)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 145)				if ((cx > dx)) {
HXLINE( 145)					int min5;
HXDLIN( 145)					if ((bx > dx)) {
HXLINE( 145)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 145)						min5 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 145)					int ii_min10 = min5;
HXDLIN( 145)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 145)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 145)					int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 145)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 145)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 145)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 145)			if ((by > cy)) {
HXLINE( 145)				if ((by > dy)) {
HXLINE( 145)					int min6;
HXDLIN( 145)					if ((cy > dy)) {
HXLINE( 145)						min6 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 145)						min6 = ::Math_obj::floor(cy);
            					}
HXDLIN( 145)					int ii_min12 = min6;
HXDLIN( 145)					int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 145)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 145)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 145)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 145)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 145)				if ((cy > dy)) {
HXLINE( 145)					int min7;
HXDLIN( 145)					if ((by > dy)) {
HXLINE( 145)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 145)						min7 = ::Math_obj::ceil(by);
            					}
HXDLIN( 145)					int ii_min14 = min7;
HXDLIN( 145)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 145)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 145)					int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 145)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 145)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 145)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 145)			if (hasUndo1) {
HXLINE( 145)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 145)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 145)				 ::Dynamic imageType1 = null();
HXDLIN( 145)				 ::pi_xy::ImageStruct this32 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 145)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 145)				::Dynamic undoImage4;
HXDLIN( 145)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 145)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 145)						 ::iterMagic::BytesImg b6 = byt1;
HXDLIN( 145)						{
HXLINE( 145)							b6->width = width1;
HXDLIN( 145)							b6->height = height1;
HXDLIN( 145)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 145)							b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN( 145)							{
HXLINE( 145)								int len2 = b6->length;
HXDLIN( 145)								int w1 = 0;
HXDLIN( 145)								{
HXLINE( 145)									int _g20 = 0;
HXDLIN( 145)									int _g21 = b6->height;
HXDLIN( 145)									while((_g20 < _g21)){
HXLINE( 145)										_g20 = (_g20 + 1);
HXDLIN( 145)										int y3 = (_g20 - 1);
HXDLIN( 145)										{
HXLINE( 145)											int _g22 = 0;
HXDLIN( 145)											int _g23 = b6->width;
HXDLIN( 145)											while((_g22 < _g23)){
HXLINE( 145)												_g22 = (_g22 + 1);
HXDLIN( 145)												int x3 = (_g22 - 1);
HXDLIN( 145)												{
HXLINE( 145)													w1 = (w1 + 1);
HXDLIN( 145)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 145)												{
HXLINE( 145)													w1 = (w1 + 1);
HXDLIN( 145)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 145)												{
HXLINE( 145)													w1 = (w1 + 1);
HXDLIN( 145)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 145)												{
HXLINE( 145)													w1 = (w1 + 1);
HXDLIN( 145)													b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 145)						undoImage4 = b6;
            					}
            					break;
            					case (int)1: {
HXLINE( 145)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 145)						 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN( 145)						{
HXLINE( 145)							a7->width = width1;
HXDLIN( 145)							a7->height = height1;
HXDLIN( 145)							a7->data = ::Array_obj< int >::__new(0);
HXDLIN( 145)							a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 145)							{
HXLINE( 145)								int _g24 = 0;
HXDLIN( 145)								int _g25 = a7->length;
HXDLIN( 145)								while((_g24 < _g25)){
HXLINE( 145)									_g24 = (_g24 + 1);
HXDLIN( 145)									int i10 = (_g24 - 1);
HXDLIN( 145)									a7->data[i10] = 0;
            								}
            							}
            						}
HXDLIN( 145)						undoImage4 = a7;
            					}
            					break;
            					case (int)2: {
HXLINE( 145)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 145)						 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN( 145)						{
HXLINE( 145)							b7->width = width1;
HXDLIN( 145)							b7->height = height1;
HXDLIN( 145)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 145)							int size1 = (b7->length * 4);
HXDLIN( 145)							b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 145)							{
HXLINE( 145)								int _g26 = 0;
HXDLIN( 145)								int _g27 = b7->length;
HXDLIN( 145)								while((_g26 < _g27)){
HXLINE( 145)									_g26 = (_g26 + 1);
HXDLIN( 145)									int i11 = (_g26 - 1);
HXDLIN( 145)									{
HXLINE( 145)										 ::haxe::io::ArrayBufferViewImpl this33 = b7->data;
HXDLIN( 145)										bool undoImage5;
HXDLIN( 145)										if ((i11 >= 0)) {
HXLINE( 145)											undoImage5 = (i11 < (this33->byteLength >> 2));
            										}
            										else {
HXLINE( 145)											undoImage5 = false;
            										}
HXDLIN( 145)										if (undoImage5) {
HXLINE( 145)											 ::haxe::io::Bytes _this1 = this33->bytes;
HXDLIN( 145)											int pos1 = ((i11 << 2) + this33->byteOffset);
HXDLIN( 145)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 145)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 145)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 145)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 145)						undoImage4 = b7;
            					}
            					break;
            					case (int)3: {
HXLINE( 145)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 145)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 145)						{
HXLINE( 145)							v3->width = width1;
HXDLIN( 145)							v3->height = height1;
HXDLIN( 145)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 145)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 145)							{
HXLINE( 145)								int _g28 = 0;
HXDLIN( 145)								int _g29 = v3->length;
HXDLIN( 145)								while((_g28 < _g29)){
HXLINE( 145)									_g28 = (_g28 + 1);
HXDLIN( 145)									int i12 = (_g28 - 1);
HXDLIN( 145)									v3->data->__unsafe_set(i12,0);
            								}
            							}
            						}
HXDLIN( 145)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE( 145)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 145)						 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN( 145)						{
HXLINE( 145)							b8->width = width1;
HXDLIN( 145)							b8->height = height1;
HXDLIN( 145)							b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 145)							b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 145)							{
HXLINE( 145)								int len3 = b8->length;
HXDLIN( 145)								 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN( 145)								if (::hx::IsNull( d1->head )) {
HXLINE( 145)									int _g30 = 0;
HXDLIN( 145)									int _g31 = len3;
HXDLIN( 145)									while((_g30 < _g31)){
HXLINE( 145)										_g30 = (_g30 + 1);
HXDLIN( 145)										int i13 = (_g30 - 1);
HXDLIN( 145)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 145)									int _g32 = 0;
HXDLIN( 145)									int _g33 = len3;
HXDLIN( 145)									while((_g32 < _g33)){
HXLINE( 145)										_g32 = (_g32 + 1);
HXDLIN( 145)										int i14 = (_g32 - 1);
HXDLIN( 145)										{
HXLINE( 145)											 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN( 145)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 145)											{
HXLINE( 145)												int _g34 = 0;
HXDLIN( 145)												int _g35 = i14;
HXDLIN( 145)												while((_g34 < _g35)){
HXLINE( 145)													_g34 = (_g34 + 1);
HXDLIN( 145)													int i15 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 145)											if (::hx::IsNull( prev1 )) {
HXLINE( 145)												b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 145)												l1 = null();
            											}
            											else {
HXLINE( 145)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 145)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 145)						undoImage4 = b8;
            					}
            					break;
            				}
HXDLIN( 145)				this32->image = undoImage4;
HXDLIN( 145)				this32->width = width1;
HXDLIN( 145)				this32->height = height1;
HXDLIN( 145)				this32->imageType = ( (int)(imageType1) );
HXDLIN( 145)				undoImage3 = this32;
HXDLIN( 145)				{
HXLINE( 145)					int rectLeft1 = xIter31->start;
HXDLIN( 145)					int rectTop1 = yIter31->start;
HXDLIN( 145)					int rectRight1 = xIter31->max;
HXDLIN( 145)					bool forceClear1 = false;
HXDLIN( 145)					{
HXLINE( 145)						int _g36 = rectTop1;
HXDLIN( 145)						int _g37 = yIter31->max;
HXDLIN( 145)						while((_g36 < _g37)){
HXLINE( 145)							_g36 = (_g36 + 1);
HXDLIN( 145)							int dy2 = (_g36 - 1);
HXDLIN( 145)							{
HXLINE( 145)								int _g38 = rectLeft1;
HXDLIN( 145)								int _g39 = rectRight1;
HXDLIN( 145)								while((_g38 < _g39)){
HXLINE( 145)									_g38 = (_g38 + 1);
HXDLIN( 145)									int dx2 = (_g38 - 1);
HXDLIN( 145)									::Dynamic this34 = pixelImage->image;
HXDLIN( 145)									int index4;
HXDLIN( 145)									if (pixelImage->useVirtualPos) {
HXLINE( 145)										index4 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 145)										index4 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN( 145)									int c3 = ::iterMagic::Iimg_obj::get(this34,index4);
HXDLIN( 145)									int col1;
HXDLIN( 145)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 145)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 145)										col1 = c3;
            									}
HXDLIN( 145)									bool _hx_tmp8;
HXDLIN( 145)									if (pixelImage->useMask) {
HXLINE( 145)										_hx_tmp8 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 145)										_hx_tmp8 = false;
            									}
HXDLIN( 145)									if (_hx_tmp8) {
HXLINE( 145)										 ::pi_xy::ImageStruct this35 = pixelImage->mask;
HXDLIN( 145)										::Dynamic this36 = this35->image;
HXDLIN( 145)										int index5;
HXDLIN( 145)										if (this35->useVirtualPos) {
HXLINE( 145)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx2) - this35->virtualX));
            										}
            										else {
HXLINE( 145)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this35->width) + dx2)) ));
            										}
HXDLIN( 145)										int c4 = ::iterMagic::Iimg_obj::get(this36,index5);
HXDLIN( 145)										int v4;
HXDLIN( 145)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 145)											v4 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 145)											v4 = c4;
            										}
HXDLIN( 145)										int maskPixel1 = v4;
HXDLIN( 145)										int this37 = col1;
HXDLIN( 145)										if ((maskPixel1 == 0)) {
HXLINE( 145)											col1 = this37;
            										}
            										else {
HXLINE( 145)											Float m01;
HXDLIN( 145)											int this38 = ((maskPixel1 >> 24) & 255);
HXDLIN( 145)											if ((this38 == 0)) {
HXLINE( 145)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												m01 = (( (Float)(this38) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float m11;
HXDLIN( 145)											int this39 = ((maskPixel1 >> 16) & 255);
HXDLIN( 145)											if ((this39 == 0)) {
HXLINE( 145)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												m11 = (( (Float)(this39) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float m21;
HXDLIN( 145)											int this40 = ((maskPixel1 >> 8) & 255);
HXDLIN( 145)											if ((this40 == 0)) {
HXLINE( 145)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												m21 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float m31;
HXDLIN( 145)											int this41 = (maskPixel1 & 255);
HXDLIN( 145)											if ((this41 == 0)) {
HXLINE( 145)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												m31 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this37 >> 24) & 255)) )));
HXDLIN( 145)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this37 >> 16) & 255)) )));
HXDLIN( 145)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this37 >> 8) & 255)) )));
HXDLIN( 145)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this37 & 255)) )));
HXDLIN( 145)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 145)									if ((col1 != 0)) {
HXLINE( 145)										int x4 = (dx2 - rectLeft1);
HXDLIN( 145)										int y4 = (dy2 - rectTop1);
HXDLIN( 145)										int c5 = col1;
HXDLIN( 145)										bool _hx_tmp9;
HXDLIN( 145)										if ((((c5 >> 24) & 255) < 254)) {
HXLINE( 145)											_hx_tmp9 = undoImage3->transparent;
            										}
            										else {
HXLINE( 145)											_hx_tmp9 = false;
            										}
HXDLIN( 145)										if (_hx_tmp9) {
HXLINE( 145)											int location2;
HXDLIN( 145)											if (undoImage3->useVirtualPos) {
HXLINE( 145)												location2 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 145)												location2 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 145)											int this42 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 145)											int this43;
HXDLIN( 145)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 145)												this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            											}
            											else {
HXLINE( 145)												this43 = this42;
            											}
HXDLIN( 145)											Float a12;
HXDLIN( 145)											int this44 = ((this43 >> 24) & 255);
HXDLIN( 145)											if ((this44 == 0)) {
HXLINE( 145)												a12 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float r12;
HXDLIN( 145)											int this45 = ((this43 >> 16) & 255);
HXDLIN( 145)											if ((this45 == 0)) {
HXLINE( 145)												r12 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float g12;
HXDLIN( 145)											int this46 = ((this43 >> 8) & 255);
HXDLIN( 145)											if ((this46 == 0)) {
HXLINE( 145)												g12 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float b13;
HXDLIN( 145)											int this47 = (this43 & 255);
HXDLIN( 145)											if ((this47 == 0)) {
HXLINE( 145)												b13 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float a22;
HXDLIN( 145)											int this48 = ((col1 >> 24) & 255);
HXDLIN( 145)											if ((this48 == 0)) {
HXLINE( 145)												a22 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float r22;
HXDLIN( 145)											int this49 = ((col1 >> 16) & 255);
HXDLIN( 145)											if ((this49 == 0)) {
HXLINE( 145)												r22 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float g22;
HXDLIN( 145)											int this50 = ((col1 >> 8) & 255);
HXDLIN( 145)											if ((this50 == 0)) {
HXLINE( 145)												g22 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float b23;
HXDLIN( 145)											int this51 = (col1 & 255);
HXDLIN( 145)											if ((this51 == 0)) {
HXLINE( 145)												b23 = ((Float)0.);
            											}
            											else {
HXLINE( 145)												b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN( 145)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 145)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 145)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 145)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 145)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 145)											int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 145)											{
HXLINE( 145)												int _hx_tmp10;
HXDLIN( 145)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 145)													_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE( 145)													_hx_tmp10 = blended2;
            												}
HXDLIN( 145)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            											}
            										}
            										else {
HXLINE( 145)											::Dynamic this52 = undoImage3->image;
HXDLIN( 145)											int index6;
HXDLIN( 145)											if (undoImage3->useVirtualPos) {
HXLINE( 145)												index6 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x4) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 145)												index6 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage3->width) + x4)) ));
            											}
HXDLIN( 145)											int _hx_tmp11;
HXDLIN( 145)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 145)												_hx_tmp11 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE( 145)												_hx_tmp11 = c5;
            											}
HXDLIN( 145)											::iterMagic::Iimg_obj::set(this52,index6,_hx_tmp11);
            										}
            									}
            									else {
HXLINE( 145)										if (forceClear1) {
HXLINE( 145)											::Dynamic this53 = undoImage3->image;
HXDLIN( 145)											int x5 = (dx2 - rectLeft1);
HXDLIN( 145)											int y5 = (dy2 - rectTop1);
HXDLIN( 145)											int index7;
HXDLIN( 145)											if (undoImage3->useVirtualPos) {
HXLINE( 145)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 145)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN( 145)											::iterMagic::Iimg_obj::set(this53,index7,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 145)			{
HXLINE( 145)				int _g_min2 = xIter31->start;
HXDLIN( 145)				int _g_max2 = xIter31->max;
HXDLIN( 145)				while((_g_min2 < _g_max2)){
HXLINE( 145)					_g_min2 = (_g_min2 + 1);
HXDLIN( 145)					int px1 = (_g_min2 - 1);
HXDLIN( 145)					Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN( 145)					{
HXLINE( 145)						int _g_min3 = yIter31->start;
HXDLIN( 145)						int _g_max3 = yIter31->max;
HXDLIN( 145)						while((_g_min3 < _g_max3)){
HXLINE( 145)							_g_min3 = (_g_min3 + 1);
HXDLIN( 145)							int py1 = (_g_min3 - 1);
HXDLIN( 145)							Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN( 145)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 145)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 145)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 145)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 145)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 145)							bool _hx_tmp12;
HXDLIN( 145)							bool _hx_tmp13;
HXDLIN( 145)							if ((ratioA1 >= 0)) {
HXLINE( 145)								_hx_tmp13 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 145)								_hx_tmp13 = false;
            							}
HXDLIN( 145)							if (_hx_tmp13) {
HXLINE( 145)								_hx_tmp12 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 145)								_hx_tmp12 = false;
            							}
HXDLIN( 145)							if (_hx_tmp12) {
HXLINE( 145)								int i16 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN( 145)								if ((i16 > 255)) {
HXLINE(  24)									i16 = 255;
            								}
HXLINE( 145)								if ((i16 < 0)) {
HXLINE(  25)									i16 = 0;
            								}
HXLINE( 145)								int a9 = i16;
HXDLIN( 145)								int i17 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN( 145)								if ((i17 > 255)) {
HXLINE(  24)									i17 = 255;
            								}
HXLINE( 145)								if ((i17 < 0)) {
HXLINE(  25)									i17 = 0;
            								}
HXLINE( 145)								int r6 = i17;
HXDLIN( 145)								int i18 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN( 145)								if ((i18 > 255)) {
HXLINE(  24)									i18 = 255;
            								}
HXLINE( 145)								if ((i18 < 0)) {
HXLINE(  25)									i18 = 0;
            								}
HXLINE( 145)								int g6 = i18;
HXDLIN( 145)								int i19 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN( 145)								if ((i19 > 255)) {
HXLINE(  24)									i19 = 255;
            								}
HXLINE( 145)								if ((i19 < 0)) {
HXLINE(  25)									i19 = 0;
            								}
HXLINE( 145)								int b10 = i19;
HXDLIN( 145)								{
HXLINE( 145)									int location3;
HXDLIN( 145)									if (pixelImage->useVirtualPos) {
HXLINE( 145)										location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 145)										location3 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            									}
HXDLIN( 145)									bool _hx_tmp14;
HXDLIN( 145)									if (pixelImage->transparent) {
HXLINE( 145)										_hx_tmp14 = (a9 < 254);
            									}
            									else {
HXLINE( 145)										_hx_tmp14 = false;
            									}
HXDLIN( 145)									if (_hx_tmp14) {
HXLINE( 145)										int this54 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 145)										int old1;
HXDLIN( 145)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 145)											old1 = ((((((this54 >> 24) & 255) << 24) | ((this54 & 255) << 16)) | (((this54 >> 8) & 255) << 8)) | ((this54 >> 16) & 255));
            										}
            										else {
HXLINE( 145)											old1 = this54;
            										}
HXDLIN( 145)										int rhs1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN( 145)										Float a13;
HXDLIN( 145)										int this55 = ((old1 >> 24) & 255);
HXDLIN( 145)										if ((this55 == 0)) {
HXLINE( 145)											a13 = ((Float)0.);
            										}
            										else {
HXLINE( 145)											a13 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 145)										Float r13;
HXDLIN( 145)										int this56 = ((old1 >> 16) & 255);
HXDLIN( 145)										if ((this56 == 0)) {
HXLINE( 145)											r13 = ((Float)0.);
            										}
            										else {
HXLINE( 145)											r13 = (( (Float)(this56) ) / ( (Float)(255) ));
            										}
HXDLIN( 145)										Float g13;
HXDLIN( 145)										int this57 = ((old1 >> 8) & 255);
HXDLIN( 145)										if ((this57 == 0)) {
HXLINE( 145)											g13 = ((Float)0.);
            										}
            										else {
HXLINE( 145)											g13 = (( (Float)(this57) ) / ( (Float)(255) ));
            										}
HXDLIN( 145)										Float b14;
HXDLIN( 145)										int this58 = (old1 & 255);
HXDLIN( 145)										if ((this58 == 0)) {
HXLINE( 145)											b14 = ((Float)0.);
            										}
            										else {
HXLINE( 145)											b14 = (( (Float)(this58) ) / ( (Float)(255) ));
            										}
HXDLIN( 145)										Float a23;
HXDLIN( 145)										int this59 = ((rhs1 >> 24) & 255);
HXDLIN( 145)										if ((this59 == 0)) {
HXLINE( 145)											a23 = ((Float)0.);
            										}
            										else {
HXLINE( 145)											a23 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 145)										Float r23;
HXDLIN( 145)										int this60 = ((rhs1 >> 16) & 255);
HXDLIN( 145)										if ((this60 == 0)) {
HXLINE( 145)											r23 = ((Float)0.);
            										}
            										else {
HXLINE( 145)											r23 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 145)										Float g23;
HXDLIN( 145)										int this61 = ((rhs1 >> 8) & 255);
HXDLIN( 145)										if ((this61 == 0)) {
HXLINE( 145)											g23 = ((Float)0.);
            										}
            										else {
HXLINE( 145)											g23 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 145)										Float b24;
HXDLIN( 145)										int this62 = (rhs1 & 255);
HXDLIN( 145)										if ((this62 == 0)) {
HXLINE( 145)											b24 = ((Float)0.);
            										}
            										else {
HXLINE( 145)											b24 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 145)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 145)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 145)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 145)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 145)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 145)										int blended3 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b15);
HXDLIN( 145)										{
HXLINE( 145)											int _hx_tmp15;
HXDLIN( 145)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 145)												_hx_tmp15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE( 145)												_hx_tmp15 = blended3;
            											}
HXDLIN( 145)											::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp15);
            										}
            									}
            									else {
HXLINE( 145)										int value1;
HXDLIN( 145)										if (pixelImage->isLittle) {
HXLINE( 145)											value1 = ((((a9 << 24) | (b10 << 16)) | (g6 << 8)) | r6);
            										}
            										else {
HXLINE( 145)											value1 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
            										}
HXDLIN( 145)										::iterMagic::Iimg_obj::set(pixelImage->image,location3,value1);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 145)			if ((hasHit1 == false)) {
HXLINE( 145)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 145)				if (hasUndo1) {
HXLINE( 145)					v5->undoImage = undoImage3;
HXDLIN( 145)					v5->undoX = xIter31->start;
HXDLIN( 145)					v5->undoY = yIter31->start;
            				}
            			}
            		}
HXLINE( 146)		if ((hasHit == true)) {
HXLINE( 147)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE( 148)			return v6;
            		}
            		else {
HXLINE( 150)			return null();
            		}
HXLINE( 146)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC14(QuadPixel_Fields__obj,fillGradQuadrilateral,return )

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::imgQuadrilateralFudge( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_161_imgQuadrilateralFudge)
HXLINE( 162)		{
HXLINE( 162)			bool hasUndo = false;
HXDLIN( 162)			{
HXLINE( 162)				Float au = ((Float)1.);
HXDLIN( 162)				Float av = ((Float)0.);
HXDLIN( 162)				Float bu = ((Float)0.);
HXDLIN( 162)				Float bv = ((Float)0.);
HXDLIN( 162)				Float temp = au;
HXLINE( 422)				au = bu;
HXLINE( 423)				bu = temp;
HXLINE( 424)				temp = av;
HXLINE( 425)				av = bv;
HXLINE( 426)				bv = temp;
HXLINE( 162)				Float bcx = (bx - cx);
HXDLIN( 162)				Float bcy = (by - cy);
HXDLIN( 162)				Float acx = (ax - cx);
HXDLIN( 162)				Float acy = (ay - cy);
HXDLIN( 162)				Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 162)				Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 162)				Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 162)				Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 162)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 162)				if ((ax > bx)) {
HXLINE( 162)					if ((ax > cx)) {
HXLINE( 162)						int min;
HXDLIN( 162)						if ((bx > cx)) {
HXLINE( 162)							min = ::Math_obj::floor(cx);
            						}
            						else {
HXLINE( 162)							min = ::Math_obj::floor(bx);
            						}
HXDLIN( 162)						int ii_min = min;
HXDLIN( 162)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 162)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE( 162)						int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 162)						int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN( 162)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE( 162)					if ((bx > cx)) {
HXLINE( 162)						int min1;
HXDLIN( 162)						if ((ax > cx)) {
HXLINE( 162)							min1 = ::Math_obj::floor(cx);
            						}
            						else {
HXLINE( 162)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 162)						int ii_min2 = min1;
HXDLIN( 162)						int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 162)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 162)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 162)						int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN( 162)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 162)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 162)				if ((ay > by)) {
HXLINE( 162)					if ((ay > cy)) {
HXLINE( 162)						int min2;
HXDLIN( 162)						if ((by > cy)) {
HXLINE( 162)							min2 = ::Math_obj::floor(cy);
            						}
            						else {
HXLINE( 162)							min2 = ::Math_obj::floor(by);
            						}
HXDLIN( 162)						int ii_min4 = min2;
HXDLIN( 162)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 162)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 162)						int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 162)						int ii_max5 = ::Math_obj::ceil(cy);
HXDLIN( 162)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE( 162)					if ((by > cy)) {
HXLINE( 162)						int min3;
HXDLIN( 162)						if ((ay > cy)) {
HXLINE( 162)							min3 = ::Math_obj::floor(cy);
            						}
            						else {
HXLINE( 162)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 162)						int ii_min6 = min3;
HXDLIN( 162)						int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 162)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 162)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 162)						int ii_max7 = ::Math_obj::ceil(cy);
HXDLIN( 162)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 162)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 162)				if (hasUndo) {
HXLINE( 162)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 162)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 162)					 ::Dynamic imageType = null();
HXDLIN( 162)					 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 162)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 162)					::Dynamic undoImage1;
HXDLIN( 162)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 162)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 162)							{
HXLINE( 162)								b->width = width;
HXDLIN( 162)								b->height = height;
HXDLIN( 162)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 162)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 162)								{
HXLINE( 162)									int len = b->length;
HXDLIN( 162)									int w = 0;
HXDLIN( 162)									{
HXLINE( 162)										int _g = 0;
HXDLIN( 162)										int _g1 = b->height;
HXDLIN( 162)										while((_g < _g1)){
HXLINE( 162)											_g = (_g + 1);
HXDLIN( 162)											int y = (_g - 1);
HXDLIN( 162)											{
HXLINE( 162)												int _g2 = 0;
HXDLIN( 162)												int _g3 = b->width;
HXDLIN( 162)												while((_g2 < _g3)){
HXLINE( 162)													_g2 = (_g2 + 1);
HXDLIN( 162)													int x = (_g2 - 1);
HXDLIN( 162)													{
HXLINE( 162)														w = (w + 1);
HXDLIN( 162)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 162)													{
HXLINE( 162)														w = (w + 1);
HXDLIN( 162)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 162)													{
HXLINE( 162)														w = (w + 1);
HXDLIN( 162)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 162)													{
HXLINE( 162)														w = (w + 1);
HXDLIN( 162)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE( 162)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 162)							{
HXLINE( 162)								a->width = width;
HXDLIN( 162)								a->height = height;
HXDLIN( 162)								a->data = ::Array_obj< int >::__new(0);
HXDLIN( 162)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 162)								{
HXLINE( 162)									int _g4 = 0;
HXDLIN( 162)									int _g5 = a->length;
HXDLIN( 162)									while((_g4 < _g5)){
HXLINE( 162)										_g4 = (_g4 + 1);
HXDLIN( 162)										int i = (_g4 - 1);
HXDLIN( 162)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN( 162)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE( 162)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 162)							{
HXLINE( 162)								b1->width = width;
HXDLIN( 162)								b1->height = height;
HXDLIN( 162)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 162)								int size = (b1->length * 4);
HXDLIN( 162)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 162)								{
HXLINE( 162)									int _g6 = 0;
HXDLIN( 162)									int _g7 = b1->length;
HXDLIN( 162)									while((_g6 < _g7)){
HXLINE( 162)										_g6 = (_g6 + 1);
HXDLIN( 162)										int i1 = (_g6 - 1);
HXDLIN( 162)										{
HXLINE( 162)											 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 162)											bool undoImage2;
HXDLIN( 162)											if ((i1 >= 0)) {
HXLINE( 162)												undoImage2 = (i1 < (this2->byteLength >> 2));
            											}
            											else {
HXLINE( 162)												undoImage2 = false;
            											}
HXDLIN( 162)											if (undoImage2) {
HXLINE( 162)												 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 162)												int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 162)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 162)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 162)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 162)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE( 162)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 162)							{
HXLINE( 162)								v->width = width;
HXDLIN( 162)								v->height = height;
HXDLIN( 162)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 162)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 162)								{
HXLINE( 162)									int _g8 = 0;
HXDLIN( 162)									int _g9 = v->length;
HXDLIN( 162)									while((_g8 < _g9)){
HXLINE( 162)										_g8 = (_g8 + 1);
HXDLIN( 162)										int i2 = (_g8 - 1);
HXDLIN( 162)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN( 162)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 162)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 162)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 162)							{
HXLINE( 162)								b2->width = width;
HXDLIN( 162)								b2->height = height;
HXDLIN( 162)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 162)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 162)								{
HXLINE( 162)									int len1 = b2->length;
HXDLIN( 162)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 162)									if (::hx::IsNull( d->head )) {
HXLINE( 162)										int _g10 = 0;
HXDLIN( 162)										int _g11 = len1;
HXDLIN( 162)										while((_g10 < _g11)){
HXLINE( 162)											_g10 = (_g10 + 1);
HXDLIN( 162)											int i3 = (_g10 - 1);
HXDLIN( 162)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 162)										int _g12 = 0;
HXDLIN( 162)										int _g13 = len1;
HXDLIN( 162)										while((_g12 < _g13)){
HXLINE( 162)											_g12 = (_g12 + 1);
HXDLIN( 162)											int i4 = (_g12 - 1);
HXDLIN( 162)											{
HXLINE( 162)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 162)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 162)												{
HXLINE( 162)													int _g14 = 0;
HXDLIN( 162)													int _g15 = i4;
HXDLIN( 162)													while((_g14 < _g15)){
HXLINE( 162)														_g14 = (_g14 + 1);
HXDLIN( 162)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 162)												if (::hx::IsNull( prev )) {
HXLINE( 162)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 162)													l = null();
            												}
            												else {
HXLINE( 162)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 162)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 162)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 162)					this1->image = undoImage1;
HXDLIN( 162)					this1->width = width;
HXDLIN( 162)					this1->height = height;
HXDLIN( 162)					this1->imageType = ( (int)(imageType) );
HXDLIN( 162)					undoImage = this1;
HXDLIN( 162)					{
HXLINE( 162)						int rectLeft = xIter3->start;
HXDLIN( 162)						int rectTop = yIter3->start;
HXDLIN( 162)						int rectRight = xIter3->max;
HXDLIN( 162)						bool forceClear = false;
HXDLIN( 162)						{
HXLINE( 162)							int _g16 = rectTop;
HXDLIN( 162)							int _g17 = yIter3->max;
HXDLIN( 162)							while((_g16 < _g17)){
HXLINE( 162)								_g16 = (_g16 + 1);
HXDLIN( 162)								int dy1 = (_g16 - 1);
HXDLIN( 162)								{
HXLINE( 162)									int _g18 = rectLeft;
HXDLIN( 162)									int _g19 = rectRight;
HXDLIN( 162)									while((_g18 < _g19)){
HXLINE( 162)										_g18 = (_g18 + 1);
HXDLIN( 162)										int dx1 = (_g18 - 1);
HXDLIN( 162)										::Dynamic this3 = pixelImage->image;
HXDLIN( 162)										int index;
HXDLIN( 162)										if (pixelImage->useVirtualPos) {
HXLINE( 162)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 162)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            										}
HXDLIN( 162)										int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 162)										int col;
HXDLIN( 162)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 162)											col = c;
            										}
HXDLIN( 162)										bool _hx_tmp;
HXDLIN( 162)										if (pixelImage->useMask) {
HXLINE( 162)											_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 162)											_hx_tmp = false;
            										}
HXDLIN( 162)										if (_hx_tmp) {
HXLINE( 162)											 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 162)											::Dynamic this5 = this4->image;
HXDLIN( 162)											int index1;
HXDLIN( 162)											if (this4->useVirtualPos) {
HXLINE( 162)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            											}
            											else {
HXLINE( 162)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            											}
HXDLIN( 162)											int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 162)											int v1;
HXDLIN( 162)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 162)												v1 = c1;
            											}
HXDLIN( 162)											int maskPixel = v1;
HXDLIN( 162)											int this6 = col;
HXDLIN( 162)											if ((maskPixel == 0)) {
HXLINE( 162)												col = this6;
            											}
            											else {
HXLINE( 162)												Float m0;
HXDLIN( 162)												int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 162)												if ((this7 == 0)) {
HXLINE( 162)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float m1;
HXDLIN( 162)												int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 162)												if ((this8 == 0)) {
HXLINE( 162)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float m2;
HXDLIN( 162)												int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 162)												if ((this9 == 0)) {
HXLINE( 162)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float m3;
HXDLIN( 162)												int this10 = (maskPixel & 255);
HXDLIN( 162)												if ((this10 == 0)) {
HXLINE( 162)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 162)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 162)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 162)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 162)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 162)										if ((col != 0)) {
HXLINE( 162)											int x1 = (dx1 - rectLeft);
HXDLIN( 162)											int y1 = (dy1 - rectTop);
HXDLIN( 162)											int c2 = col;
HXDLIN( 162)											bool _hx_tmp1;
HXDLIN( 162)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 162)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE( 162)												_hx_tmp1 = false;
            											}
HXDLIN( 162)											if (_hx_tmp1) {
HXLINE( 162)												int location;
HXDLIN( 162)												if (undoImage->useVirtualPos) {
HXLINE( 162)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 162)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 162)												int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 162)												int this12;
HXDLIN( 162)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)													this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            												}
            												else {
HXLINE( 162)													this12 = this11;
            												}
HXDLIN( 162)												Float a1;
HXDLIN( 162)												int this13 = ((this12 >> 24) & 255);
HXDLIN( 162)												if ((this13 == 0)) {
HXLINE( 162)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float r1;
HXDLIN( 162)												int this14 = ((this12 >> 16) & 255);
HXDLIN( 162)												if ((this14 == 0)) {
HXLINE( 162)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float g1;
HXDLIN( 162)												int this15 = ((this12 >> 8) & 255);
HXDLIN( 162)												if ((this15 == 0)) {
HXLINE( 162)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float b11;
HXDLIN( 162)												int this16 = (this12 & 255);
HXDLIN( 162)												if ((this16 == 0)) {
HXLINE( 162)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float a2;
HXDLIN( 162)												int this17 = ((col >> 24) & 255);
HXDLIN( 162)												if ((this17 == 0)) {
HXLINE( 162)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float r2;
HXDLIN( 162)												int this18 = ((col >> 16) & 255);
HXDLIN( 162)												if ((this18 == 0)) {
HXLINE( 162)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float g2;
HXDLIN( 162)												int this19 = ((col >> 8) & 255);
HXDLIN( 162)												if ((this19 == 0)) {
HXLINE( 162)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float b21;
HXDLIN( 162)												int this20 = (col & 255);
HXDLIN( 162)												if ((this20 == 0)) {
HXLINE( 162)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 162)													b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 162)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 162)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 162)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 162)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 162)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 162)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 162)												{
HXLINE( 162)													int _hx_tmp2;
HXDLIN( 162)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 162)														_hx_tmp2 = blended;
            													}
HXDLIN( 162)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE( 162)												::Dynamic this21 = undoImage->image;
HXDLIN( 162)												int index2;
HXDLIN( 162)												if (undoImage->useVirtualPos) {
HXLINE( 162)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 162)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 162)												int _hx_tmp3;
HXDLIN( 162)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 162)													_hx_tmp3 = c2;
            												}
HXDLIN( 162)												::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE( 162)											if (forceClear) {
HXLINE( 162)												::Dynamic this22 = undoImage->image;
HXDLIN( 162)												int x2 = (dx1 - rectLeft);
HXDLIN( 162)												int y2 = (dy1 - rectTop);
HXDLIN( 162)												int index3;
HXDLIN( 162)												if (undoImage->useVirtualPos) {
HXLINE( 162)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 162)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 162)												::iterMagic::Iimg_obj::set(this22,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 162)				{
HXLINE( 162)					int _g_min = xIter3->start;
HXDLIN( 162)					int _g_max = xIter3->max;
HXDLIN( 162)					while((_g_min < _g_max)){
HXLINE( 162)						_g_min = (_g_min + 1);
HXDLIN( 162)						int px = (_g_min - 1);
HXDLIN( 162)						Float pcx = (( (Float)(px) ) - cx);
HXDLIN( 162)						{
HXLINE( 162)							int _g_min1 = yIter3->start;
HXDLIN( 162)							int _g_max1 = yIter3->max;
HXDLIN( 162)							while((_g_min1 < _g_max1)){
HXLINE( 162)								_g_min1 = (_g_min1 + 1);
HXDLIN( 162)								int py = (_g_min1 - 1);
HXDLIN( 162)								Float pcy = (( (Float)(py) ) - cy);
HXDLIN( 162)								Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 162)								Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 162)								Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 162)								Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 162)								Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 162)								bool _hx_tmp4;
HXDLIN( 162)								bool _hx_tmp5;
HXDLIN( 162)								if ((ratioA >= 0)) {
HXLINE( 162)									_hx_tmp5 = (ratioB >= 0);
            								}
            								else {
HXLINE( 162)									_hx_tmp5 = false;
            								}
HXDLIN( 162)								if (_hx_tmp5) {
HXLINE( 162)									_hx_tmp4 = (ratioC >= 0);
            								}
            								else {
HXLINE( 162)									_hx_tmp4 = false;
            								}
HXDLIN( 162)								if (_hx_tmp4) {
HXLINE( 162)									Float u = (((au * ratioA) + (bu * ratioB)) + ratioC);
HXDLIN( 162)									Float v2 = (((av * ratioA) + (bv * ratioB)) + ratioC);
HXDLIN( 162)									int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXDLIN( 162)									int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXDLIN( 162)									::Dynamic this23 = texture->image;
HXDLIN( 162)									int index4;
HXDLIN( 162)									if (texture->useVirtualPos) {
HXLINE( 162)										index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            									}
            									else {
HXLINE( 162)										index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            									}
HXDLIN( 162)									int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 162)									int col1;
HXDLIN( 162)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 162)										col1 = c3;
            									}
HXDLIN( 162)									{
HXLINE( 162)										int c4 = col1;
HXDLIN( 162)										bool _hx_tmp6;
HXDLIN( 162)										if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 162)											_hx_tmp6 = pixelImage->transparent;
            										}
            										else {
HXLINE( 162)											_hx_tmp6 = false;
            										}
HXDLIN( 162)										if (_hx_tmp6) {
HXLINE( 162)											int location1;
HXDLIN( 162)											if (pixelImage->useVirtualPos) {
HXLINE( 162)												location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 162)												location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            											}
HXDLIN( 162)											int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 162)											int this25;
HXDLIN( 162)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)												this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            											}
            											else {
HXLINE( 162)												this25 = this24;
            											}
HXDLIN( 162)											Float a11;
HXDLIN( 162)											int this26 = ((this25 >> 24) & 255);
HXDLIN( 162)											if ((this26 == 0)) {
HXLINE( 162)												a11 = ((Float)0.);
            											}
            											else {
HXLINE( 162)												a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            											}
HXDLIN( 162)											Float r11;
HXDLIN( 162)											int this27 = ((this25 >> 16) & 255);
HXDLIN( 162)											if ((this27 == 0)) {
HXLINE( 162)												r11 = ((Float)0.);
            											}
            											else {
HXLINE( 162)												r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            											}
HXDLIN( 162)											Float g11;
HXDLIN( 162)											int this28 = ((this25 >> 8) & 255);
HXDLIN( 162)											if ((this28 == 0)) {
HXLINE( 162)												g11 = ((Float)0.);
            											}
            											else {
HXLINE( 162)												g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            											}
HXDLIN( 162)											Float b12;
HXDLIN( 162)											int this29 = (this25 & 255);
HXDLIN( 162)											if ((this29 == 0)) {
HXLINE( 162)												b12 = ((Float)0.);
            											}
            											else {
HXLINE( 162)												b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            											}
HXDLIN( 162)											Float a21;
HXDLIN( 162)											int this30 = ((col1 >> 24) & 255);
HXDLIN( 162)											if ((this30 == 0)) {
HXLINE( 162)												a21 = ((Float)0.);
            											}
            											else {
HXLINE( 162)												a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN( 162)											Float r21;
HXDLIN( 162)											int this31 = ((col1 >> 16) & 255);
HXDLIN( 162)											if ((this31 == 0)) {
HXLINE( 162)												r21 = ((Float)0.);
            											}
            											else {
HXLINE( 162)												r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN( 162)											Float g21;
HXDLIN( 162)											int this32 = ((col1 >> 8) & 255);
HXDLIN( 162)											if ((this32 == 0)) {
HXLINE( 162)												g21 = ((Float)0.);
            											}
            											else {
HXLINE( 162)												g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            											}
HXDLIN( 162)											Float b22;
HXDLIN( 162)											int this33 = (col1 & 255);
HXDLIN( 162)											if ((this33 == 0)) {
HXLINE( 162)												b22 = ((Float)0.);
            											}
            											else {
HXLINE( 162)												b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            											}
HXDLIN( 162)											Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 162)											int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 162)											int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 162)											int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 162)											int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 162)											int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 162)											{
HXLINE( 162)												int _hx_tmp7;
HXDLIN( 162)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)													_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXLINE( 162)													_hx_tmp7 = blended1;
            												}
HXDLIN( 162)												::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            											}
            										}
            										else {
HXLINE( 162)											::Dynamic this34 = pixelImage->image;
HXDLIN( 162)											int index5;
HXDLIN( 162)											if (pixelImage->useVirtualPos) {
HXLINE( 162)												index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 162)												index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            											}
HXDLIN( 162)											int _hx_tmp8;
HXDLIN( 162)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 162)												_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXLINE( 162)												_hx_tmp8 = c4;
            											}
HXDLIN( 162)											::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 162)				if ((hasHit == false)) {
HXLINE( 162)					 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,true);
HXDLIN( 162)					if (hasUndo) {
HXLINE( 162)						v3->undoImage = undoImage;
HXDLIN( 162)						v3->undoX = xIter3->start;
HXDLIN( 162)						v3->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXLINE( 163)		{
HXLINE( 163)			bool hasUndo1 = false;
HXDLIN( 163)			{
HXLINE( 163)				Float au1 = ((Float)1.);
HXDLIN( 163)				Float av1 = ((Float)1.);
HXDLIN( 163)				Float bu1 = ((Float)0.);
HXDLIN( 163)				Float bv1 = ((Float)1.);
HXDLIN( 163)				Float temp1 = au1;
HXLINE( 422)				au1 = bu1;
HXLINE( 423)				bu1 = temp1;
HXLINE( 424)				temp1 = av1;
HXLINE( 425)				av1 = bv1;
HXLINE( 426)				bv1 = temp1;
HXLINE( 163)				Float bcx1 = (cx - ax);
HXDLIN( 163)				Float bcy1 = (cy - ay);
HXDLIN( 163)				Float acx1 = (dx - ax);
HXDLIN( 163)				Float acy1 = (dy - ay);
HXDLIN( 163)				Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 163)				Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 163)				Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 163)				Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 163)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 163)				if ((dx > cx)) {
HXLINE( 163)					if ((dx > ax)) {
HXLINE( 163)						int min4;
HXDLIN( 163)						if ((cx > ax)) {
HXLINE( 163)							min4 = ::Math_obj::floor(ax);
            						}
            						else {
HXLINE( 163)							min4 = ::Math_obj::floor(cx);
            						}
HXDLIN( 163)						int ii_min8 = min4;
HXDLIN( 163)						int ii_max8 = ::Math_obj::ceil(dx);
HXDLIN( 163)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 163)						int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 163)						int ii_max9 = ::Math_obj::ceil(ax);
HXDLIN( 163)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE( 163)					if ((cx > ax)) {
HXLINE( 163)						int min5;
HXDLIN( 163)						if ((dx > ax)) {
HXLINE( 163)							min5 = ::Math_obj::floor(ax);
            						}
            						else {
HXLINE( 163)							min5 = ::Math_obj::ceil(dx);
            						}
HXDLIN( 163)						int ii_min10 = min5;
HXDLIN( 163)						int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 163)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE( 163)						int ii_min11 = ::Math_obj::floor(dx);
HXDLIN( 163)						int ii_max11 = ::Math_obj::ceil(ax);
HXDLIN( 163)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN( 163)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 163)				if ((dy > cy)) {
HXLINE( 163)					if ((dy > ay)) {
HXLINE( 163)						int min6;
HXDLIN( 163)						if ((cy > ay)) {
HXLINE( 163)							min6 = ::Math_obj::floor(ay);
            						}
            						else {
HXLINE( 163)							min6 = ::Math_obj::floor(cy);
            						}
HXDLIN( 163)						int ii_min12 = min6;
HXDLIN( 163)						int ii_max12 = ::Math_obj::ceil(dy);
HXDLIN( 163)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE( 163)						int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 163)						int ii_max13 = ::Math_obj::ceil(ay);
HXDLIN( 163)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE( 163)					if ((cy > ay)) {
HXLINE( 163)						int min7;
HXDLIN( 163)						if ((dy > ay)) {
HXLINE( 163)							min7 = ::Math_obj::floor(ay);
            						}
            						else {
HXLINE( 163)							min7 = ::Math_obj::ceil(dy);
            						}
HXDLIN( 163)						int ii_min14 = min7;
HXDLIN( 163)						int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 163)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE( 163)						int ii_min15 = ::Math_obj::floor(dy);
HXDLIN( 163)						int ii_max15 = ::Math_obj::ceil(ay);
HXDLIN( 163)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN( 163)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 163)				if (hasUndo1) {
HXLINE( 163)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 163)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 163)					 ::Dynamic imageType1 = null();
HXDLIN( 163)					 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 163)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 163)					::Dynamic undoImage4;
HXDLIN( 163)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 163)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 163)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 163)							{
HXLINE( 163)								b5->width = width1;
HXDLIN( 163)								b5->height = height1;
HXDLIN( 163)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 163)								{
HXLINE( 163)									int len2 = b5->length;
HXDLIN( 163)									int w1 = 0;
HXDLIN( 163)									{
HXLINE( 163)										int _g20 = 0;
HXDLIN( 163)										int _g21 = b5->height;
HXDLIN( 163)										while((_g20 < _g21)){
HXLINE( 163)											_g20 = (_g20 + 1);
HXDLIN( 163)											int y4 = (_g20 - 1);
HXDLIN( 163)											{
HXLINE( 163)												int _g22 = 0;
HXDLIN( 163)												int _g23 = b5->width;
HXDLIN( 163)												while((_g22 < _g23)){
HXLINE( 163)													_g22 = (_g22 + 1);
HXDLIN( 163)													int x4 = (_g22 - 1);
HXDLIN( 163)													{
HXLINE( 163)														w1 = (w1 + 1);
HXDLIN( 163)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 163)													{
HXLINE( 163)														w1 = (w1 + 1);
HXDLIN( 163)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 163)													{
HXLINE( 163)														w1 = (w1 + 1);
HXDLIN( 163)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 163)													{
HXLINE( 163)														w1 = (w1 + 1);
HXDLIN( 163)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 163)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXLINE( 163)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 163)							{
HXLINE( 163)								a6->width = width1;
HXDLIN( 163)								a6->height = height1;
HXDLIN( 163)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 163)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)								{
HXLINE( 163)									int _g24 = 0;
HXDLIN( 163)									int _g25 = a6->length;
HXDLIN( 163)									while((_g24 < _g25)){
HXLINE( 163)										_g24 = (_g24 + 1);
HXDLIN( 163)										int i6 = (_g24 - 1);
HXDLIN( 163)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN( 163)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXLINE( 163)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 163)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 163)							{
HXLINE( 163)								b6->width = width1;
HXDLIN( 163)								b6->height = height1;
HXDLIN( 163)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)								int size1 = (b6->length * 4);
HXDLIN( 163)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 163)								{
HXLINE( 163)									int _g26 = 0;
HXDLIN( 163)									int _g27 = b6->length;
HXDLIN( 163)									while((_g26 < _g27)){
HXLINE( 163)										_g26 = (_g26 + 1);
HXDLIN( 163)										int i7 = (_g26 - 1);
HXDLIN( 163)										{
HXLINE( 163)											 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN( 163)											bool undoImage5;
HXDLIN( 163)											if ((i7 >= 0)) {
HXLINE( 163)												undoImage5 = (i7 < (this36->byteLength >> 2));
            											}
            											else {
HXLINE( 163)												undoImage5 = false;
            											}
HXDLIN( 163)											if (undoImage5) {
HXLINE( 163)												 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 163)												int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 163)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 163)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 163)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 163)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 163)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXLINE( 163)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)							 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 163)							{
HXLINE( 163)								v4->width = width1;
HXDLIN( 163)								v4->height = height1;
HXDLIN( 163)								v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)								v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 163)								{
HXLINE( 163)									int _g28 = 0;
HXDLIN( 163)									int _g29 = v4->length;
HXDLIN( 163)									while((_g28 < _g29)){
HXLINE( 163)										_g28 = (_g28 + 1);
HXDLIN( 163)										int i8 = (_g28 - 1);
HXDLIN( 163)										v4->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN( 163)							undoImage4 = v4;
            						}
            						break;
            						case (int)4: {
HXLINE( 163)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 163)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 163)							{
HXLINE( 163)								b7->width = width1;
HXDLIN( 163)								b7->height = height1;
HXDLIN( 163)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 163)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 163)								{
HXLINE( 163)									int len3 = b7->length;
HXDLIN( 163)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 163)									if (::hx::IsNull( d1->head )) {
HXLINE( 163)										int _g30 = 0;
HXDLIN( 163)										int _g31 = len3;
HXDLIN( 163)										while((_g30 < _g31)){
HXLINE( 163)											_g30 = (_g30 + 1);
HXDLIN( 163)											int i9 = (_g30 - 1);
HXDLIN( 163)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 163)										int _g32 = 0;
HXDLIN( 163)										int _g33 = len3;
HXDLIN( 163)										while((_g32 < _g33)){
HXLINE( 163)											_g32 = (_g32 + 1);
HXDLIN( 163)											int i10 = (_g32 - 1);
HXDLIN( 163)											{
HXLINE( 163)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 163)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 163)												{
HXLINE( 163)													int _g34 = 0;
HXDLIN( 163)													int _g35 = i10;
HXDLIN( 163)													while((_g34 < _g35)){
HXLINE( 163)														_g34 = (_g34 + 1);
HXDLIN( 163)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 163)												if (::hx::IsNull( prev1 )) {
HXLINE( 163)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 163)													l1 = null();
            												}
            												else {
HXLINE( 163)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 163)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 163)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN( 163)					this35->image = undoImage4;
HXDLIN( 163)					this35->width = width1;
HXDLIN( 163)					this35->height = height1;
HXDLIN( 163)					this35->imageType = ( (int)(imageType1) );
HXDLIN( 163)					undoImage3 = this35;
HXDLIN( 163)					{
HXLINE( 163)						int rectLeft1 = xIter31->start;
HXDLIN( 163)						int rectTop1 = yIter31->start;
HXDLIN( 163)						int rectRight1 = xIter31->max;
HXDLIN( 163)						bool forceClear1 = false;
HXDLIN( 163)						{
HXLINE( 163)							int _g36 = rectTop1;
HXDLIN( 163)							int _g37 = yIter31->max;
HXDLIN( 163)							while((_g36 < _g37)){
HXLINE( 163)								_g36 = (_g36 + 1);
HXDLIN( 163)								int dy2 = (_g36 - 1);
HXDLIN( 163)								{
HXLINE( 163)									int _g38 = rectLeft1;
HXDLIN( 163)									int _g39 = rectRight1;
HXDLIN( 163)									while((_g38 < _g39)){
HXLINE( 163)										_g38 = (_g38 + 1);
HXDLIN( 163)										int dx2 = (_g38 - 1);
HXDLIN( 163)										::Dynamic this37 = pixelImage->image;
HXDLIN( 163)										int index6;
HXDLIN( 163)										if (pixelImage->useVirtualPos) {
HXLINE( 163)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 163)											index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 163)										int c5 = ::iterMagic::Iimg_obj::get(this37,index6);
HXDLIN( 163)										int col2;
HXDLIN( 163)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)											col2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 163)											col2 = c5;
            										}
HXDLIN( 163)										bool _hx_tmp9;
HXDLIN( 163)										if (pixelImage->useMask) {
HXLINE( 163)											_hx_tmp9 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 163)											_hx_tmp9 = false;
            										}
HXDLIN( 163)										if (_hx_tmp9) {
HXLINE( 163)											 ::pi_xy::ImageStruct this38 = pixelImage->mask;
HXDLIN( 163)											::Dynamic this39 = this38->image;
HXDLIN( 163)											int index7;
HXDLIN( 163)											if (this38->useVirtualPos) {
HXLINE( 163)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            											}
            											else {
HXLINE( 163)												index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            											}
HXDLIN( 163)											int c6 = ::iterMagic::Iimg_obj::get(this39,index7);
HXDLIN( 163)											int v5;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												v5 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												v5 = c6;
            											}
HXDLIN( 163)											int maskPixel1 = v5;
HXDLIN( 163)											int this40 = col2;
HXDLIN( 163)											if ((maskPixel1 == 0)) {
HXLINE( 163)												col2 = this40;
            											}
            											else {
HXLINE( 163)												Float m01;
HXDLIN( 163)												int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 163)												if ((this41 == 0)) {
HXLINE( 163)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float m11;
HXDLIN( 163)												int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 163)												if ((this42 == 0)) {
HXLINE( 163)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float m21;
HXDLIN( 163)												int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 163)												if ((this43 == 0)) {
HXLINE( 163)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float m31;
HXDLIN( 163)												int this44 = (maskPixel1 & 255);
HXDLIN( 163)												if ((this44 == 0)) {
HXLINE( 163)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 163)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 163)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 163)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 163)												col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 163)										if ((col2 != 0)) {
HXLINE( 163)											int x5 = (dx2 - rectLeft1);
HXDLIN( 163)											int y5 = (dy2 - rectTop1);
HXDLIN( 163)											int c7 = col2;
HXDLIN( 163)											bool _hx_tmp10;
HXDLIN( 163)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 163)												_hx_tmp10 = undoImage3->transparent;
            											}
            											else {
HXLINE( 163)												_hx_tmp10 = false;
            											}
HXDLIN( 163)											if (_hx_tmp10) {
HXLINE( 163)												int location2;
HXDLIN( 163)												if (undoImage3->useVirtualPos) {
HXLINE( 163)													location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 163)													location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 163)												int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 163)												int this46;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													this46 = this45;
            												}
HXDLIN( 163)												Float a12;
HXDLIN( 163)												int this47 = ((this46 >> 24) & 255);
HXDLIN( 163)												if ((this47 == 0)) {
HXLINE( 163)													a12 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float r12;
HXDLIN( 163)												int this48 = ((this46 >> 16) & 255);
HXDLIN( 163)												if ((this48 == 0)) {
HXLINE( 163)													r12 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float g12;
HXDLIN( 163)												int this49 = ((this46 >> 8) & 255);
HXDLIN( 163)												if ((this49 == 0)) {
HXLINE( 163)													g12 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float b13;
HXDLIN( 163)												int this50 = (this46 & 255);
HXDLIN( 163)												if ((this50 == 0)) {
HXLINE( 163)													b13 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float a22;
HXDLIN( 163)												int this51 = ((col2 >> 24) & 255);
HXDLIN( 163)												if ((this51 == 0)) {
HXLINE( 163)													a22 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float r22;
HXDLIN( 163)												int this52 = ((col2 >> 16) & 255);
HXDLIN( 163)												if ((this52 == 0)) {
HXLINE( 163)													r22 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float g22;
HXDLIN( 163)												int this53 = ((col2 >> 8) & 255);
HXDLIN( 163)												if ((this53 == 0)) {
HXLINE( 163)													g22 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float b23;
HXDLIN( 163)												int this54 = (col2 & 255);
HXDLIN( 163)												if ((this54 == 0)) {
HXLINE( 163)													b23 = ((Float)0.);
            												}
            												else {
HXLINE( 163)													b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN( 163)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 163)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 163)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 163)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 163)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 163)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 163)												{
HXLINE( 163)													int _hx_tmp11;
HXDLIN( 163)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)														_hx_tmp11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE( 163)														_hx_tmp11 = blended2;
            													}
HXDLIN( 163)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp11);
            												}
            											}
            											else {
HXLINE( 163)												::Dynamic this55 = undoImage3->image;
HXDLIN( 163)												int index8;
HXDLIN( 163)												if (undoImage3->useVirtualPos) {
HXLINE( 163)													index8 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 163)													index8 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 163)												int _hx_tmp12;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp12 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp12 = c7;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(this55,index8,_hx_tmp12);
            											}
            										}
            										else {
HXLINE( 163)											if (forceClear1) {
HXLINE( 163)												::Dynamic this56 = undoImage3->image;
HXDLIN( 163)												int x6 = (dx2 - rectLeft1);
HXDLIN( 163)												int y6 = (dy2 - rectTop1);
HXDLIN( 163)												int index9;
HXDLIN( 163)												if (undoImage3->useVirtualPos) {
HXLINE( 163)													index9 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 163)													index9 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(this56,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 163)				{
HXLINE( 163)					int _g_min2 = xIter31->start;
HXDLIN( 163)					int _g_max2 = xIter31->max;
HXDLIN( 163)					while((_g_min2 < _g_max2)){
HXLINE( 163)						_g_min2 = (_g_min2 + 1);
HXDLIN( 163)						int px1 = (_g_min2 - 1);
HXDLIN( 163)						Float pcx1 = (( (Float)(px1) ) - ax);
HXDLIN( 163)						{
HXLINE( 163)							int _g_min3 = yIter31->start;
HXDLIN( 163)							int _g_max3 = yIter31->max;
HXDLIN( 163)							while((_g_min3 < _g_max3)){
HXLINE( 163)								_g_min3 = (_g_min3 + 1);
HXDLIN( 163)								int py1 = (_g_min3 - 1);
HXDLIN( 163)								Float pcy1 = (( (Float)(py1) ) - ay);
HXDLIN( 163)								Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 163)								Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 163)								Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 163)								Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 163)								Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 163)								bool _hx_tmp13;
HXDLIN( 163)								bool _hx_tmp14;
HXDLIN( 163)								if ((ratioA1 >= 0)) {
HXLINE( 163)									_hx_tmp14 = (ratioB1 >= 0);
            								}
            								else {
HXLINE( 163)									_hx_tmp14 = false;
            								}
HXDLIN( 163)								if (_hx_tmp14) {
HXLINE( 163)									_hx_tmp13 = (ratioC1 >= 0);
            								}
            								else {
HXLINE( 163)									_hx_tmp13 = false;
            								}
HXDLIN( 163)								if (_hx_tmp13) {
HXLINE( 163)									Float u1 = (((au1 * ratioA1) + (bu1 * ratioB1)) + (((Float)0.) * ratioC1));
HXDLIN( 163)									Float v6 = (((av1 * ratioA1) + (bv1 * ratioB1)) + (((Float)0.) * ratioC1));
HXDLIN( 163)									int x7 = ::Std_obj::_hx_int(((u1 * win->width) + win->x));
HXDLIN( 163)									int y7 = ::Std_obj::_hx_int(((v6 * win->height) + win->y));
HXDLIN( 163)									::Dynamic this57 = texture->image;
HXDLIN( 163)									int index10;
HXDLIN( 163)									if (texture->useVirtualPos) {
HXLINE( 163)										index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - texture->virtualY) * ( (Float)(texture->width) )) + x7) - texture->virtualX));
            									}
            									else {
HXLINE( 163)										index10 = ::Std_obj::_hx_int(( (Float)(((y7 * texture->width) + x7)) ));
            									}
HXDLIN( 163)									int c8 = ::iterMagic::Iimg_obj::get(this57,index10);
HXDLIN( 163)									int col3;
HXDLIN( 163)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)										col3 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXLINE( 163)										col3 = c8;
            									}
HXDLIN( 163)									{
HXLINE( 163)										int c9 = col3;
HXDLIN( 163)										bool _hx_tmp15;
HXDLIN( 163)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 163)											_hx_tmp15 = pixelImage->transparent;
            										}
            										else {
HXLINE( 163)											_hx_tmp15 = false;
            										}
HXDLIN( 163)										if (_hx_tmp15) {
HXLINE( 163)											int location3;
HXDLIN( 163)											if (pixelImage->useVirtualPos) {
HXLINE( 163)												location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 163)												location3 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            											}
HXDLIN( 163)											int this58 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 163)											int this59;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												this59 = this58;
            											}
HXDLIN( 163)											Float a13;
HXDLIN( 163)											int this60 = ((this59 >> 24) & 255);
HXDLIN( 163)											if ((this60 == 0)) {
HXLINE( 163)												a13 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r13;
HXDLIN( 163)											int this61 = ((this59 >> 16) & 255);
HXDLIN( 163)											if ((this61 == 0)) {
HXLINE( 163)												r13 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g13;
HXDLIN( 163)											int this62 = ((this59 >> 8) & 255);
HXDLIN( 163)											if ((this62 == 0)) {
HXLINE( 163)												g13 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b14;
HXDLIN( 163)											int this63 = (this59 & 255);
HXDLIN( 163)											if ((this63 == 0)) {
HXLINE( 163)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b14 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a23;
HXDLIN( 163)											int this64 = ((col3 >> 24) & 255);
HXDLIN( 163)											if ((this64 == 0)) {
HXLINE( 163)												a23 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float r23;
HXDLIN( 163)											int this65 = ((col3 >> 16) & 255);
HXDLIN( 163)											if ((this65 == 0)) {
HXLINE( 163)												r23 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float g23;
HXDLIN( 163)											int this66 = ((col3 >> 8) & 255);
HXDLIN( 163)											if ((this66 == 0)) {
HXLINE( 163)												g23 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float b24;
HXDLIN( 163)											int this67 = (col3 & 255);
HXDLIN( 163)											if ((this67 == 0)) {
HXLINE( 163)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 163)												b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 163)											Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 163)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 163)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 163)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 163)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 163)											int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 163)											{
HXLINE( 163)												int _hx_tmp16;
HXDLIN( 163)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)													_hx_tmp16 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE( 163)													_hx_tmp16 = blended3;
            												}
HXDLIN( 163)												::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp16);
            											}
            										}
            										else {
HXLINE( 163)											::Dynamic this68 = pixelImage->image;
HXDLIN( 163)											int index11;
HXDLIN( 163)											if (pixelImage->useVirtualPos) {
HXLINE( 163)												index11 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 163)												index11 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            											}
HXDLIN( 163)											int _hx_tmp17;
HXDLIN( 163)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 163)												_hx_tmp17 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE( 163)												_hx_tmp17 = c9;
            											}
HXDLIN( 163)											::iterMagic::Iimg_obj::set(this68,index11,_hx_tmp17);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 163)				if ((hasHit == false)) {
HXLINE( 163)					 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,dx,dy,cx,cy,ax,ay,true);
HXDLIN( 163)					if (hasUndo1) {
HXLINE( 163)						v7->undoImage = undoImage3;
HXDLIN( 163)						v7->undoX = xIter31->start;
HXDLIN( 163)						v7->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXLINE( 164)		if ((hasHit == true)) {
HXLINE( 165)			 ::pi_xy::algo::HitQuad v8 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE( 166)			return v8;
            		}
            		else {
HXLINE( 168)			return null();
            		}
HXLINE( 164)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(QuadPixel_Fields__obj,imgQuadrilateralFudge,return )

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::imgQuadrilateral( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,::hx::Null< Float >  __o_au,::hx::Null< Float >  __o_av,::hx::Null< Float >  __o_bu,::hx::Null< Float >  __o_bv,::hx::Null< Float >  __o_cu,::hx::Null< Float >  __o_cv,::hx::Null< Float >  __o_du,::hx::Null< Float >  __o_dv,::hx::Null< bool >  __o_hasHit){
            		Float au = __o_au.Default(((Float)0.));
            		Float av = __o_av.Default(((Float)0.));
            		Float bu = __o_bu.Default(((Float)1.));
            		Float bv = __o_bv.Default(((Float)0.));
            		Float cu = __o_cu.Default(((Float)1.));
            		Float cv = __o_cv.Default(((Float)1.));
            		Float du = __o_du.Default(((Float)0.));
            		Float dv = __o_dv.Default(((Float)1.));
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_183_imgQuadrilateral)
HXLINE( 186)		{
HXLINE( 186)			Float au1 = au;
HXDLIN( 186)			Float av1 = av;
HXDLIN( 186)			Float bu1 = bu;
HXDLIN( 186)			Float bv1 = bv;
HXDLIN( 186)			bool hasUndo = false;
HXDLIN( 186)			Float temp = au1;
HXLINE( 422)			au1 = bu1;
HXLINE( 423)			bu1 = temp;
HXLINE( 424)			temp = av1;
HXLINE( 425)			av1 = bv1;
HXLINE( 426)			bv1 = temp;
HXLINE( 186)			Float bcx = (bx - dx);
HXDLIN( 186)			Float bcy = (by - dy);
HXDLIN( 186)			Float acx = (ax - dx);
HXDLIN( 186)			Float acy = (ay - dy);
HXDLIN( 186)			Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 186)			Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 186)			Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 186)			Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 186)			 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 186)			if ((ax > bx)) {
HXLINE( 186)				if ((ax > dx)) {
HXLINE( 186)					int min;
HXDLIN( 186)					if ((bx > dx)) {
HXLINE( 186)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 186)						min = ::Math_obj::floor(bx);
            					}
HXDLIN( 186)					int ii_min = min;
HXDLIN( 186)					int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 186)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            				}
            				else {
HXLINE( 186)					int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 186)					int ii_max1 = ::Math_obj::ceil(dx);
HXDLIN( 186)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            				}
            			}
            			else {
HXLINE( 186)				if ((bx > dx)) {
HXLINE( 186)					int min1;
HXDLIN( 186)					if ((ax > dx)) {
HXLINE( 186)						min1 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 186)						min1 = ::Math_obj::ceil(ax);
            					}
HXDLIN( 186)					int ii_min2 = min1;
HXDLIN( 186)					int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 186)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            				}
            				else {
HXLINE( 186)					int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 186)					int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN( 186)					xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            				}
            			}
HXDLIN( 186)			 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 186)			if ((ay > by)) {
HXLINE( 186)				if ((ay > dy)) {
HXLINE( 186)					int min2;
HXDLIN( 186)					if ((by > dy)) {
HXLINE( 186)						min2 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 186)						min2 = ::Math_obj::floor(by);
            					}
HXDLIN( 186)					int ii_min4 = min2;
HXDLIN( 186)					int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 186)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            				}
            				else {
HXLINE( 186)					int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 186)					int ii_max5 = ::Math_obj::ceil(dy);
HXDLIN( 186)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            				}
            			}
            			else {
HXLINE( 186)				if ((by > dy)) {
HXLINE( 186)					int min3;
HXDLIN( 186)					if ((ay > dy)) {
HXLINE( 186)						min3 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 186)						min3 = ::Math_obj::ceil(ay);
            					}
HXDLIN( 186)					int ii_min6 = min3;
HXDLIN( 186)					int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 186)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            				}
            				else {
HXLINE( 186)					int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 186)					int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN( 186)					yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            				}
            			}
HXDLIN( 186)			 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 186)			if (hasUndo) {
HXLINE( 186)				int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 186)				int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 186)				 ::Dynamic imageType = null();
HXDLIN( 186)				 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 186)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 186)				::Dynamic undoImage1;
HXDLIN( 186)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 186)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 186)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 186)						{
HXLINE( 186)							b->width = width;
HXDLIN( 186)							b->height = height;
HXDLIN( 186)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 186)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 186)							{
HXLINE( 186)								int len = b->length;
HXDLIN( 186)								int w = 0;
HXDLIN( 186)								{
HXLINE( 186)									int _g = 0;
HXDLIN( 186)									int _g1 = b->height;
HXDLIN( 186)									while((_g < _g1)){
HXLINE( 186)										_g = (_g + 1);
HXDLIN( 186)										int y = (_g - 1);
HXDLIN( 186)										{
HXLINE( 186)											int _g2 = 0;
HXDLIN( 186)											int _g3 = b->width;
HXDLIN( 186)											while((_g2 < _g3)){
HXLINE( 186)												_g2 = (_g2 + 1);
HXDLIN( 186)												int x = (_g2 - 1);
HXDLIN( 186)												{
HXLINE( 186)													w = (w + 1);
HXDLIN( 186)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 186)												{
HXLINE( 186)													w = (w + 1);
HXDLIN( 186)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 186)												{
HXLINE( 186)													w = (w + 1);
HXDLIN( 186)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 186)												{
HXLINE( 186)													w = (w + 1);
HXDLIN( 186)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 186)						undoImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE( 186)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 186)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 186)						{
HXLINE( 186)							a->width = width;
HXDLIN( 186)							a->height = height;
HXDLIN( 186)							a->data = ::Array_obj< int >::__new(0);
HXDLIN( 186)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 186)							{
HXLINE( 186)								int _g4 = 0;
HXDLIN( 186)								int _g5 = a->length;
HXDLIN( 186)								while((_g4 < _g5)){
HXLINE( 186)									_g4 = (_g4 + 1);
HXDLIN( 186)									int i = (_g4 - 1);
HXDLIN( 186)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 186)						undoImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE( 186)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 186)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 186)						{
HXLINE( 186)							b1->width = width;
HXDLIN( 186)							b1->height = height;
HXDLIN( 186)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 186)							int size = (b1->length * 4);
HXDLIN( 186)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 186)							{
HXLINE( 186)								int _g6 = 0;
HXDLIN( 186)								int _g7 = b1->length;
HXDLIN( 186)								while((_g6 < _g7)){
HXLINE( 186)									_g6 = (_g6 + 1);
HXDLIN( 186)									int i1 = (_g6 - 1);
HXDLIN( 186)									{
HXLINE( 186)										 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 186)										bool undoImage2;
HXDLIN( 186)										if ((i1 >= 0)) {
HXLINE( 186)											undoImage2 = (i1 < (this2->byteLength >> 2));
            										}
            										else {
HXLINE( 186)											undoImage2 = false;
            										}
HXDLIN( 186)										if (undoImage2) {
HXLINE( 186)											 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 186)											int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 186)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 186)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 186)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 186)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 186)						undoImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE( 186)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 186)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 186)						{
HXLINE( 186)							v->width = width;
HXDLIN( 186)							v->height = height;
HXDLIN( 186)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 186)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 186)							{
HXLINE( 186)								int _g8 = 0;
HXDLIN( 186)								int _g9 = v->length;
HXDLIN( 186)								while((_g8 < _g9)){
HXLINE( 186)									_g8 = (_g8 + 1);
HXDLIN( 186)									int i2 = (_g8 - 1);
HXDLIN( 186)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 186)						undoImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 186)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 186)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 186)						{
HXLINE( 186)							b2->width = width;
HXDLIN( 186)							b2->height = height;
HXDLIN( 186)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 186)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 186)							{
HXLINE( 186)								int len1 = b2->length;
HXDLIN( 186)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 186)								if (::hx::IsNull( d->head )) {
HXLINE( 186)									int _g10 = 0;
HXDLIN( 186)									int _g11 = len1;
HXDLIN( 186)									while((_g10 < _g11)){
HXLINE( 186)										_g10 = (_g10 + 1);
HXDLIN( 186)										int i3 = (_g10 - 1);
HXDLIN( 186)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 186)									int _g12 = 0;
HXDLIN( 186)									int _g13 = len1;
HXDLIN( 186)									while((_g12 < _g13)){
HXLINE( 186)										_g12 = (_g12 + 1);
HXDLIN( 186)										int i4 = (_g12 - 1);
HXDLIN( 186)										{
HXLINE( 186)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 186)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 186)											{
HXLINE( 186)												int _g14 = 0;
HXDLIN( 186)												int _g15 = i4;
HXDLIN( 186)												while((_g14 < _g15)){
HXLINE( 186)													_g14 = (_g14 + 1);
HXDLIN( 186)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 186)											if (::hx::IsNull( prev )) {
HXLINE( 186)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 186)												l = null();
            											}
            											else {
HXLINE( 186)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 186)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 186)						undoImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 186)				this1->image = undoImage1;
HXDLIN( 186)				this1->width = width;
HXDLIN( 186)				this1->height = height;
HXDLIN( 186)				this1->imageType = ( (int)(imageType) );
HXDLIN( 186)				undoImage = this1;
HXDLIN( 186)				{
HXLINE( 186)					int rectLeft = xIter3->start;
HXDLIN( 186)					int rectTop = yIter3->start;
HXDLIN( 186)					int rectRight = xIter3->max;
HXDLIN( 186)					bool forceClear = false;
HXDLIN( 186)					{
HXLINE( 186)						int _g16 = rectTop;
HXDLIN( 186)						int _g17 = yIter3->max;
HXDLIN( 186)						while((_g16 < _g17)){
HXLINE( 186)							_g16 = (_g16 + 1);
HXDLIN( 186)							int dy1 = (_g16 - 1);
HXDLIN( 186)							{
HXLINE( 186)								int _g18 = rectLeft;
HXDLIN( 186)								int _g19 = rectRight;
HXDLIN( 186)								while((_g18 < _g19)){
HXLINE( 186)									_g18 = (_g18 + 1);
HXDLIN( 186)									int dx1 = (_g18 - 1);
HXDLIN( 186)									::Dynamic this3 = pixelImage->image;
HXDLIN( 186)									int index;
HXDLIN( 186)									if (pixelImage->useVirtualPos) {
HXLINE( 186)										index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 186)										index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            									}
HXDLIN( 186)									int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 186)									int col;
HXDLIN( 186)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)										col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            									}
            									else {
HXLINE( 186)										col = c;
            									}
HXDLIN( 186)									bool _hx_tmp;
HXDLIN( 186)									if (pixelImage->useMask) {
HXLINE( 186)										_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 186)										_hx_tmp = false;
            									}
HXDLIN( 186)									if (_hx_tmp) {
HXLINE( 186)										 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 186)										::Dynamic this5 = this4->image;
HXDLIN( 186)										int index1;
HXDLIN( 186)										if (this4->useVirtualPos) {
HXLINE( 186)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXLINE( 186)											index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN( 186)										int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 186)										int v1;
HXDLIN( 186)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)											v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE( 186)											v1 = c1;
            										}
HXDLIN( 186)										int maskPixel = v1;
HXDLIN( 186)										int this6 = col;
HXDLIN( 186)										if ((maskPixel == 0)) {
HXLINE( 186)											col = this6;
            										}
            										else {
HXLINE( 186)											Float m0;
HXDLIN( 186)											int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 186)											if ((this7 == 0)) {
HXLINE( 186)												m0 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float m1;
HXDLIN( 186)											int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 186)											if ((this8 == 0)) {
HXLINE( 186)												m1 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float m2;
HXDLIN( 186)											int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 186)											if ((this9 == 0)) {
HXLINE( 186)												m2 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float m3;
HXDLIN( 186)											int this10 = (maskPixel & 255);
HXDLIN( 186)											if ((this10 == 0)) {
HXLINE( 186)												m3 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 186)											int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 186)											int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 186)											int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 186)											col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 186)									if ((col != 0)) {
HXLINE( 186)										int x1 = (dx1 - rectLeft);
HXDLIN( 186)										int y1 = (dy1 - rectTop);
HXDLIN( 186)										int c2 = col;
HXDLIN( 186)										bool _hx_tmp1;
HXDLIN( 186)										if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 186)											_hx_tmp1 = undoImage->transparent;
            										}
            										else {
HXLINE( 186)											_hx_tmp1 = false;
            										}
HXDLIN( 186)										if (_hx_tmp1) {
HXLINE( 186)											int location;
HXDLIN( 186)											if (undoImage->useVirtualPos) {
HXLINE( 186)												location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 186)												location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 186)											int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 186)											int this12;
HXDLIN( 186)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)												this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            											}
            											else {
HXLINE( 186)												this12 = this11;
            											}
HXDLIN( 186)											Float a1;
HXDLIN( 186)											int this13 = ((this12 >> 24) & 255);
HXDLIN( 186)											if ((this13 == 0)) {
HXLINE( 186)												a1 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float r1;
HXDLIN( 186)											int this14 = ((this12 >> 16) & 255);
HXDLIN( 186)											if ((this14 == 0)) {
HXLINE( 186)												r1 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float g1;
HXDLIN( 186)											int this15 = ((this12 >> 8) & 255);
HXDLIN( 186)											if ((this15 == 0)) {
HXLINE( 186)												g1 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float b11;
HXDLIN( 186)											int this16 = (this12 & 255);
HXDLIN( 186)											if ((this16 == 0)) {
HXLINE( 186)												b11 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float a2;
HXDLIN( 186)											int this17 = ((col >> 24) & 255);
HXDLIN( 186)											if ((this17 == 0)) {
HXLINE( 186)												a2 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float r2;
HXDLIN( 186)											int this18 = ((col >> 16) & 255);
HXDLIN( 186)											if ((this18 == 0)) {
HXLINE( 186)												r2 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float g2;
HXDLIN( 186)											int this19 = ((col >> 8) & 255);
HXDLIN( 186)											if ((this19 == 0)) {
HXLINE( 186)												g2 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float b21;
HXDLIN( 186)											int this20 = (col & 255);
HXDLIN( 186)											if ((this20 == 0)) {
HXLINE( 186)												b21 = ((Float)0.);
            											}
            											else {
HXLINE( 186)												b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            											}
HXDLIN( 186)											Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 186)											int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 186)											int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 186)											int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 186)											int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 186)											int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 186)											{
HXLINE( 186)												int _hx_tmp2;
HXDLIN( 186)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)													_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            												}
            												else {
HXLINE( 186)													_hx_tmp2 = blended;
            												}
HXDLIN( 186)												::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            											}
            										}
            										else {
HXLINE( 186)											::Dynamic this21 = undoImage->image;
HXDLIN( 186)											int index2;
HXDLIN( 186)											if (undoImage->useVirtualPos) {
HXLINE( 186)												index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            											}
            											else {
HXLINE( 186)												index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            											}
HXDLIN( 186)											int _hx_tmp3;
HXDLIN( 186)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)												_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE( 186)												_hx_tmp3 = c2;
            											}
HXDLIN( 186)											::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            										}
            									}
            									else {
HXLINE( 186)										if (forceClear) {
HXLINE( 186)											::Dynamic this22 = undoImage->image;
HXDLIN( 186)											int x2 = (dx1 - rectLeft);
HXDLIN( 186)											int y2 = (dy1 - rectTop);
HXDLIN( 186)											int index3;
HXDLIN( 186)											if (undoImage->useVirtualPos) {
HXLINE( 186)												index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            											}
            											else {
HXLINE( 186)												index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            											}
HXDLIN( 186)											::iterMagic::Iimg_obj::set(this22,index3,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 186)			{
HXLINE( 186)				int _g_min = xIter3->start;
HXDLIN( 186)				int _g_max = xIter3->max;
HXDLIN( 186)				while((_g_min < _g_max)){
HXLINE( 186)					_g_min = (_g_min + 1);
HXDLIN( 186)					int px = (_g_min - 1);
HXDLIN( 186)					Float pcx = (( (Float)(px) ) - dx);
HXDLIN( 186)					{
HXLINE( 186)						int _g_min1 = yIter3->start;
HXDLIN( 186)						int _g_max1 = yIter3->max;
HXDLIN( 186)						while((_g_min1 < _g_max1)){
HXLINE( 186)							_g_min1 = (_g_min1 + 1);
HXDLIN( 186)							int py = (_g_min1 - 1);
HXDLIN( 186)							Float pcy = (( (Float)(py) ) - dy);
HXDLIN( 186)							Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 186)							Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 186)							Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 186)							Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 186)							Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 186)							bool _hx_tmp4;
HXDLIN( 186)							bool _hx_tmp5;
HXDLIN( 186)							if ((ratioA >= 0)) {
HXLINE( 186)								_hx_tmp5 = (ratioB >= 0);
            							}
            							else {
HXLINE( 186)								_hx_tmp5 = false;
            							}
HXDLIN( 186)							if (_hx_tmp5) {
HXLINE( 186)								_hx_tmp4 = (ratioC >= 0);
            							}
            							else {
HXLINE( 186)								_hx_tmp4 = false;
            							}
HXDLIN( 186)							if (_hx_tmp4) {
HXLINE( 186)								Float u = (((au1 * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN( 186)								Float v2 = (((av1 * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN( 186)								int x3 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXDLIN( 186)								int y3 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXDLIN( 186)								::Dynamic this23 = texture->image;
HXDLIN( 186)								int index4;
HXDLIN( 186)								if (texture->useVirtualPos) {
HXLINE( 186)									index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - texture->virtualY) * ( (Float)(texture->width) )) + x3) - texture->virtualX));
            								}
            								else {
HXLINE( 186)									index4 = ::Std_obj::_hx_int(( (Float)(((y3 * texture->width) + x3)) ));
            								}
HXDLIN( 186)								int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 186)								int col1;
HXDLIN( 186)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)									col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 186)									col1 = c3;
            								}
HXDLIN( 186)								{
HXLINE( 186)									int c4 = col1;
HXDLIN( 186)									bool _hx_tmp6;
HXDLIN( 186)									if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 186)										_hx_tmp6 = pixelImage->transparent;
            									}
            									else {
HXLINE( 186)										_hx_tmp6 = false;
            									}
HXDLIN( 186)									if (_hx_tmp6) {
HXLINE( 186)										int location1;
HXDLIN( 186)										if (pixelImage->useVirtualPos) {
HXLINE( 186)											location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 186)											location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            										}
HXDLIN( 186)										int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 186)										int this25;
HXDLIN( 186)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXLINE( 186)											this25 = this24;
            										}
HXDLIN( 186)										Float a11;
HXDLIN( 186)										int this26 = ((this25 >> 24) & 255);
HXDLIN( 186)										if ((this26 == 0)) {
HXLINE( 186)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 186)											a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 186)										Float r11;
HXDLIN( 186)										int this27 = ((this25 >> 16) & 255);
HXDLIN( 186)										if ((this27 == 0)) {
HXLINE( 186)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 186)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 186)										Float g11;
HXDLIN( 186)										int this28 = ((this25 >> 8) & 255);
HXDLIN( 186)										if ((this28 == 0)) {
HXLINE( 186)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 186)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 186)										Float b12;
HXDLIN( 186)										int this29 = (this25 & 255);
HXDLIN( 186)										if ((this29 == 0)) {
HXLINE( 186)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 186)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 186)										Float a21;
HXDLIN( 186)										int this30 = ((col1 >> 24) & 255);
HXDLIN( 186)										if ((this30 == 0)) {
HXLINE( 186)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 186)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 186)										Float r21;
HXDLIN( 186)										int this31 = ((col1 >> 16) & 255);
HXDLIN( 186)										if ((this31 == 0)) {
HXLINE( 186)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 186)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 186)										Float g21;
HXDLIN( 186)										int this32 = ((col1 >> 8) & 255);
HXDLIN( 186)										if ((this32 == 0)) {
HXLINE( 186)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 186)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 186)										Float b22;
HXDLIN( 186)										int this33 = (col1 & 255);
HXDLIN( 186)										if ((this33 == 0)) {
HXLINE( 186)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 186)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 186)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 186)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 186)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 186)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 186)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 186)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 186)										{
HXLINE( 186)											int _hx_tmp7;
HXDLIN( 186)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 186)												_hx_tmp7 = blended1;
            											}
HXDLIN( 186)											::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXLINE( 186)										::Dynamic this34 = pixelImage->image;
HXDLIN( 186)										int index5;
HXDLIN( 186)										if (pixelImage->useVirtualPos) {
HXLINE( 186)											index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 186)											index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            										}
HXDLIN( 186)										int _hx_tmp8;
HXDLIN( 186)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 186)											_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 186)											_hx_tmp8 = c4;
            										}
HXDLIN( 186)										::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 186)			if ((hasHit == false)) {
HXLINE( 186)				 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN( 186)				if (hasUndo) {
HXLINE( 186)					v3->undoImage = undoImage;
HXDLIN( 186)					v3->undoX = xIter3->start;
HXDLIN( 186)					v3->undoY = yIter3->start;
            				}
            			}
            		}
HXLINE( 187)		{
HXLINE( 187)			Float au2 = bu;
HXDLIN( 187)			Float av2 = bv;
HXDLIN( 187)			Float bu2 = cu;
HXDLIN( 187)			Float bv2 = cv;
HXDLIN( 187)			bool hasUndo1 = false;
HXDLIN( 187)			Float temp1 = au2;
HXLINE( 422)			au2 = bu2;
HXLINE( 423)			bu2 = temp1;
HXLINE( 424)			temp1 = av2;
HXLINE( 425)			av2 = bv2;
HXLINE( 426)			bv2 = temp1;
HXLINE( 187)			Float bcx1 = (cx - dx);
HXDLIN( 187)			Float bcy1 = (cy - dy);
HXDLIN( 187)			Float acx1 = (bx - dx);
HXDLIN( 187)			Float acy1 = (by - dy);
HXDLIN( 187)			Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 187)			Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 187)			Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 187)			Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 187)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 187)			if ((bx > cx)) {
HXLINE( 187)				if ((bx > dx)) {
HXLINE( 187)					int min4;
HXDLIN( 187)					if ((cx > dx)) {
HXLINE( 187)						min4 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 187)						min4 = ::Math_obj::floor(cx);
            					}
HXDLIN( 187)					int ii_min8 = min4;
HXDLIN( 187)					int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN( 187)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE( 187)					int ii_min9 = ::Math_obj::floor(cx);
HXDLIN( 187)					int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN( 187)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE( 187)				if ((cx > dx)) {
HXLINE( 187)					int min5;
HXDLIN( 187)					if ((bx > dx)) {
HXLINE( 187)						min5 = ::Math_obj::floor(dx);
            					}
            					else {
HXLINE( 187)						min5 = ::Math_obj::ceil(bx);
            					}
HXDLIN( 187)					int ii_min10 = min5;
HXDLIN( 187)					int ii_max10 = ::Math_obj::ceil(cx);
HXDLIN( 187)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE( 187)					int ii_min11 = ::Math_obj::floor(bx);
HXDLIN( 187)					int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN( 187)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 187)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 187)			if ((by > cy)) {
HXLINE( 187)				if ((by > dy)) {
HXLINE( 187)					int min6;
HXDLIN( 187)					if ((cy > dy)) {
HXLINE( 187)						min6 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 187)						min6 = ::Math_obj::floor(cy);
            					}
HXDLIN( 187)					int ii_min12 = min6;
HXDLIN( 187)					int ii_max12 = ::Math_obj::ceil(by);
HXDLIN( 187)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE( 187)					int ii_min13 = ::Math_obj::floor(cy);
HXDLIN( 187)					int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN( 187)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE( 187)				if ((cy > dy)) {
HXLINE( 187)					int min7;
HXDLIN( 187)					if ((by > dy)) {
HXLINE( 187)						min7 = ::Math_obj::floor(dy);
            					}
            					else {
HXLINE( 187)						min7 = ::Math_obj::ceil(by);
            					}
HXDLIN( 187)					int ii_min14 = min7;
HXDLIN( 187)					int ii_max14 = ::Math_obj::ceil(cy);
HXDLIN( 187)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE( 187)					int ii_min15 = ::Math_obj::floor(by);
HXDLIN( 187)					int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN( 187)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN( 187)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 187)			if (hasUndo1) {
HXLINE( 187)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 187)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 187)				 ::Dynamic imageType1 = null();
HXDLIN( 187)				 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 187)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 187)				::Dynamic undoImage4;
HXDLIN( 187)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 187)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 187)						 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 187)						{
HXLINE( 187)							b5->width = width1;
HXDLIN( 187)							b5->height = height1;
HXDLIN( 187)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)							b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 187)							{
HXLINE( 187)								int len2 = b5->length;
HXDLIN( 187)								int w1 = 0;
HXDLIN( 187)								{
HXLINE( 187)									int _g20 = 0;
HXDLIN( 187)									int _g21 = b5->height;
HXDLIN( 187)									while((_g20 < _g21)){
HXLINE( 187)										_g20 = (_g20 + 1);
HXDLIN( 187)										int y4 = (_g20 - 1);
HXDLIN( 187)										{
HXLINE( 187)											int _g22 = 0;
HXDLIN( 187)											int _g23 = b5->width;
HXDLIN( 187)											while((_g22 < _g23)){
HXLINE( 187)												_g22 = (_g22 + 1);
HXDLIN( 187)												int x4 = (_g22 - 1);
HXDLIN( 187)												{
HXLINE( 187)													w1 = (w1 + 1);
HXDLIN( 187)													b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 187)												{
HXLINE( 187)													w1 = (w1 + 1);
HXDLIN( 187)													b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 187)												{
HXLINE( 187)													w1 = (w1 + 1);
HXDLIN( 187)													b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 187)												{
HXLINE( 187)													w1 = (w1 + 1);
HXDLIN( 187)													b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 187)						undoImage4 = b5;
            					}
            					break;
            					case (int)1: {
HXLINE( 187)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)						 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 187)						{
HXLINE( 187)							a6->width = width1;
HXDLIN( 187)							a6->height = height1;
HXDLIN( 187)							a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 187)							a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)							{
HXLINE( 187)								int _g24 = 0;
HXDLIN( 187)								int _g25 = a6->length;
HXDLIN( 187)								while((_g24 < _g25)){
HXLINE( 187)									_g24 = (_g24 + 1);
HXDLIN( 187)									int i6 = (_g24 - 1);
HXDLIN( 187)									a6->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 187)						undoImage4 = a6;
            					}
            					break;
            					case (int)2: {
HXLINE( 187)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 187)						 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 187)						{
HXLINE( 187)							b6->width = width1;
HXDLIN( 187)							b6->height = height1;
HXDLIN( 187)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)							int size1 = (b6->length * 4);
HXDLIN( 187)							b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 187)							{
HXLINE( 187)								int _g26 = 0;
HXDLIN( 187)								int _g27 = b6->length;
HXDLIN( 187)								while((_g26 < _g27)){
HXLINE( 187)									_g26 = (_g26 + 1);
HXDLIN( 187)									int i7 = (_g26 - 1);
HXDLIN( 187)									{
HXLINE( 187)										 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN( 187)										bool undoImage5;
HXDLIN( 187)										if ((i7 >= 0)) {
HXLINE( 187)											undoImage5 = (i7 < (this36->byteLength >> 2));
            										}
            										else {
HXLINE( 187)											undoImage5 = false;
            										}
HXDLIN( 187)										if (undoImage5) {
HXLINE( 187)											 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 187)											int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 187)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 187)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 187)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 187)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 187)						undoImage4 = b6;
            					}
            					break;
            					case (int)3: {
HXLINE( 187)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)						 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 187)						{
HXLINE( 187)							v4->width = width1;
HXDLIN( 187)							v4->height = height1;
HXDLIN( 187)							v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)							v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 187)							{
HXLINE( 187)								int _g28 = 0;
HXDLIN( 187)								int _g29 = v4->length;
HXDLIN( 187)								while((_g28 < _g29)){
HXLINE( 187)									_g28 = (_g28 + 1);
HXDLIN( 187)									int i8 = (_g28 - 1);
HXDLIN( 187)									v4->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 187)						undoImage4 = v4;
            					}
            					break;
            					case (int)4: {
HXLINE( 187)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)						 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 187)						{
HXLINE( 187)							b7->width = width1;
HXDLIN( 187)							b7->height = height1;
HXDLIN( 187)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)							b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 187)							{
HXLINE( 187)								int len3 = b7->length;
HXDLIN( 187)								 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 187)								if (::hx::IsNull( d1->head )) {
HXLINE( 187)									int _g30 = 0;
HXDLIN( 187)									int _g31 = len3;
HXDLIN( 187)									while((_g30 < _g31)){
HXLINE( 187)										_g30 = (_g30 + 1);
HXDLIN( 187)										int i9 = (_g30 - 1);
HXDLIN( 187)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 187)									int _g32 = 0;
HXDLIN( 187)									int _g33 = len3;
HXDLIN( 187)									while((_g32 < _g33)){
HXLINE( 187)										_g32 = (_g32 + 1);
HXDLIN( 187)										int i10 = (_g32 - 1);
HXDLIN( 187)										{
HXLINE( 187)											 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 187)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 187)											{
HXLINE( 187)												int _g34 = 0;
HXDLIN( 187)												int _g35 = i10;
HXDLIN( 187)												while((_g34 < _g35)){
HXLINE( 187)													_g34 = (_g34 + 1);
HXDLIN( 187)													int i11 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 187)											if (::hx::IsNull( prev1 )) {
HXLINE( 187)												b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 187)												l1 = null();
            											}
            											else {
HXLINE( 187)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 187)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 187)						undoImage4 = b7;
            					}
            					break;
            				}
HXDLIN( 187)				this35->image = undoImage4;
HXDLIN( 187)				this35->width = width1;
HXDLIN( 187)				this35->height = height1;
HXDLIN( 187)				this35->imageType = ( (int)(imageType1) );
HXDLIN( 187)				undoImage3 = this35;
HXDLIN( 187)				{
HXLINE( 187)					int rectLeft1 = xIter31->start;
HXDLIN( 187)					int rectTop1 = yIter31->start;
HXDLIN( 187)					int rectRight1 = xIter31->max;
HXDLIN( 187)					bool forceClear1 = false;
HXDLIN( 187)					{
HXLINE( 187)						int _g36 = rectTop1;
HXDLIN( 187)						int _g37 = yIter31->max;
HXDLIN( 187)						while((_g36 < _g37)){
HXLINE( 187)							_g36 = (_g36 + 1);
HXDLIN( 187)							int dy2 = (_g36 - 1);
HXDLIN( 187)							{
HXLINE( 187)								int _g38 = rectLeft1;
HXDLIN( 187)								int _g39 = rectRight1;
HXDLIN( 187)								while((_g38 < _g39)){
HXLINE( 187)									_g38 = (_g38 + 1);
HXDLIN( 187)									int dx2 = (_g38 - 1);
HXDLIN( 187)									::Dynamic this37 = pixelImage->image;
HXDLIN( 187)									int index6;
HXDLIN( 187)									if (pixelImage->useVirtualPos) {
HXLINE( 187)										index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            									}
            									else {
HXLINE( 187)										index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            									}
HXDLIN( 187)									int c5 = ::iterMagic::Iimg_obj::get(this37,index6);
HXDLIN( 187)									int col2;
HXDLIN( 187)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)										col2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            									}
            									else {
HXLINE( 187)										col2 = c5;
            									}
HXDLIN( 187)									bool _hx_tmp9;
HXDLIN( 187)									if (pixelImage->useMask) {
HXLINE( 187)										_hx_tmp9 = ::hx::IsNotNull( pixelImage->mask );
            									}
            									else {
HXLINE( 187)										_hx_tmp9 = false;
            									}
HXDLIN( 187)									if (_hx_tmp9) {
HXLINE( 187)										 ::pi_xy::ImageStruct this38 = pixelImage->mask;
HXDLIN( 187)										::Dynamic this39 = this38->image;
HXDLIN( 187)										int index7;
HXDLIN( 187)										if (this38->useVirtualPos) {
HXLINE( 187)											index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            										}
            										else {
HXLINE( 187)											index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            										}
HXDLIN( 187)										int c6 = ::iterMagic::Iimg_obj::get(this39,index7);
HXDLIN( 187)										int v5;
HXDLIN( 187)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)											v5 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXLINE( 187)											v5 = c6;
            										}
HXDLIN( 187)										int maskPixel1 = v5;
HXDLIN( 187)										int this40 = col2;
HXDLIN( 187)										if ((maskPixel1 == 0)) {
HXLINE( 187)											col2 = this40;
            										}
            										else {
HXLINE( 187)											Float m01;
HXDLIN( 187)											int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 187)											if ((this41 == 0)) {
HXLINE( 187)												m01 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float m11;
HXDLIN( 187)											int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 187)											if ((this42 == 0)) {
HXLINE( 187)												m11 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float m21;
HXDLIN( 187)											int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 187)											if ((this43 == 0)) {
HXLINE( 187)												m21 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float m31;
HXDLIN( 187)											int this44 = (maskPixel1 & 255);
HXDLIN( 187)											if ((this44 == 0)) {
HXLINE( 187)												m31 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 187)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 187)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 187)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 187)											col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 187)									if ((col2 != 0)) {
HXLINE( 187)										int x5 = (dx2 - rectLeft1);
HXDLIN( 187)										int y5 = (dy2 - rectTop1);
HXDLIN( 187)										int c7 = col2;
HXDLIN( 187)										bool _hx_tmp10;
HXDLIN( 187)										if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 187)											_hx_tmp10 = undoImage3->transparent;
            										}
            										else {
HXLINE( 187)											_hx_tmp10 = false;
            										}
HXDLIN( 187)										if (_hx_tmp10) {
HXLINE( 187)											int location2;
HXDLIN( 187)											if (undoImage3->useVirtualPos) {
HXLINE( 187)												location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 187)												location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN( 187)											int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 187)											int this46;
HXDLIN( 187)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)												this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            											}
            											else {
HXLINE( 187)												this46 = this45;
            											}
HXDLIN( 187)											Float a12;
HXDLIN( 187)											int this47 = ((this46 >> 24) & 255);
HXDLIN( 187)											if ((this47 == 0)) {
HXLINE( 187)												a12 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float r12;
HXDLIN( 187)											int this48 = ((this46 >> 16) & 255);
HXDLIN( 187)											if ((this48 == 0)) {
HXLINE( 187)												r12 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float g12;
HXDLIN( 187)											int this49 = ((this46 >> 8) & 255);
HXDLIN( 187)											if ((this49 == 0)) {
HXLINE( 187)												g12 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float b13;
HXDLIN( 187)											int this50 = (this46 & 255);
HXDLIN( 187)											if ((this50 == 0)) {
HXLINE( 187)												b13 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float a22;
HXDLIN( 187)											int this51 = ((col2 >> 24) & 255);
HXDLIN( 187)											if ((this51 == 0)) {
HXLINE( 187)												a22 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float r22;
HXDLIN( 187)											int this52 = ((col2 >> 16) & 255);
HXDLIN( 187)											if ((this52 == 0)) {
HXLINE( 187)												r22 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float g22;
HXDLIN( 187)											int this53 = ((col2 >> 8) & 255);
HXDLIN( 187)											if ((this53 == 0)) {
HXLINE( 187)												g22 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float b23;
HXDLIN( 187)											int this54 = (col2 & 255);
HXDLIN( 187)											if ((this54 == 0)) {
HXLINE( 187)												b23 = ((Float)0.);
            											}
            											else {
HXLINE( 187)												b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            											}
HXDLIN( 187)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 187)											int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 187)											int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 187)											int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 187)											int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 187)											int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 187)											{
HXLINE( 187)												int _hx_tmp11;
HXDLIN( 187)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)													_hx_tmp11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE( 187)													_hx_tmp11 = blended2;
            												}
HXDLIN( 187)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp11);
            											}
            										}
            										else {
HXLINE( 187)											::Dynamic this55 = undoImage3->image;
HXDLIN( 187)											int index8;
HXDLIN( 187)											if (undoImage3->useVirtualPos) {
HXLINE( 187)												index8 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 187)												index8 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN( 187)											int _hx_tmp12;
HXDLIN( 187)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)												_hx_tmp12 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            											}
            											else {
HXLINE( 187)												_hx_tmp12 = c7;
            											}
HXDLIN( 187)											::iterMagic::Iimg_obj::set(this55,index8,_hx_tmp12);
            										}
            									}
            									else {
HXLINE( 187)										if (forceClear1) {
HXLINE( 187)											::Dynamic this56 = undoImage3->image;
HXDLIN( 187)											int x6 = (dx2 - rectLeft1);
HXDLIN( 187)											int y6 = (dy2 - rectTop1);
HXDLIN( 187)											int index9;
HXDLIN( 187)											if (undoImage3->useVirtualPos) {
HXLINE( 187)												index9 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            											}
            											else {
HXLINE( 187)												index9 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            											}
HXDLIN( 187)											::iterMagic::Iimg_obj::set(this56,index9,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 187)			{
HXLINE( 187)				int _g_min2 = xIter31->start;
HXDLIN( 187)				int _g_max2 = xIter31->max;
HXDLIN( 187)				while((_g_min2 < _g_max2)){
HXLINE( 187)					_g_min2 = (_g_min2 + 1);
HXDLIN( 187)					int px1 = (_g_min2 - 1);
HXDLIN( 187)					Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN( 187)					{
HXLINE( 187)						int _g_min3 = yIter31->start;
HXDLIN( 187)						int _g_max3 = yIter31->max;
HXDLIN( 187)						while((_g_min3 < _g_max3)){
HXLINE( 187)							_g_min3 = (_g_min3 + 1);
HXDLIN( 187)							int py1 = (_g_min3 - 1);
HXDLIN( 187)							Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN( 187)							Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 187)							Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 187)							Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 187)							Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 187)							Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 187)							bool _hx_tmp13;
HXDLIN( 187)							bool _hx_tmp14;
HXDLIN( 187)							if ((ratioA1 >= 0)) {
HXLINE( 187)								_hx_tmp14 = (ratioB1 >= 0);
            							}
            							else {
HXLINE( 187)								_hx_tmp14 = false;
            							}
HXDLIN( 187)							if (_hx_tmp14) {
HXLINE( 187)								_hx_tmp13 = (ratioC1 >= 0);
            							}
            							else {
HXLINE( 187)								_hx_tmp13 = false;
            							}
HXDLIN( 187)							if (_hx_tmp13) {
HXLINE( 187)								Float u1 = (((au2 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN( 187)								Float v6 = (((av2 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN( 187)								int x7 = ::Std_obj::_hx_int(((u1 * win->width) + win->x));
HXDLIN( 187)								int y7 = ::Std_obj::_hx_int(((v6 * win->height) + win->y));
HXDLIN( 187)								::Dynamic this57 = texture->image;
HXDLIN( 187)								int index10;
HXDLIN( 187)								if (texture->useVirtualPos) {
HXLINE( 187)									index10 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - texture->virtualY) * ( (Float)(texture->width) )) + x7) - texture->virtualX));
            								}
            								else {
HXLINE( 187)									index10 = ::Std_obj::_hx_int(( (Float)(((y7 * texture->width) + x7)) ));
            								}
HXDLIN( 187)								int c8 = ::iterMagic::Iimg_obj::get(this57,index10);
HXDLIN( 187)								int col3;
HXDLIN( 187)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)									col3 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            								}
            								else {
HXLINE( 187)									col3 = c8;
            								}
HXDLIN( 187)								{
HXLINE( 187)									int c9 = col3;
HXDLIN( 187)									bool _hx_tmp15;
HXDLIN( 187)									if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 187)										_hx_tmp15 = pixelImage->transparent;
            									}
            									else {
HXLINE( 187)										_hx_tmp15 = false;
            									}
HXDLIN( 187)									if (_hx_tmp15) {
HXLINE( 187)										int location3;
HXDLIN( 187)										if (pixelImage->useVirtualPos) {
HXLINE( 187)											location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 187)											location3 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            										}
HXDLIN( 187)										int this58 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 187)										int this59;
HXDLIN( 187)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)											this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            										}
            										else {
HXLINE( 187)											this59 = this58;
            										}
HXDLIN( 187)										Float a13;
HXDLIN( 187)										int this60 = ((this59 >> 24) & 255);
HXDLIN( 187)										if ((this60 == 0)) {
HXLINE( 187)											a13 = ((Float)0.);
            										}
            										else {
HXLINE( 187)											a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 187)										Float r13;
HXDLIN( 187)										int this61 = ((this59 >> 16) & 255);
HXDLIN( 187)										if ((this61 == 0)) {
HXLINE( 187)											r13 = ((Float)0.);
            										}
            										else {
HXLINE( 187)											r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 187)										Float g13;
HXDLIN( 187)										int this62 = ((this59 >> 8) & 255);
HXDLIN( 187)										if ((this62 == 0)) {
HXLINE( 187)											g13 = ((Float)0.);
            										}
            										else {
HXLINE( 187)											g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 187)										Float b14;
HXDLIN( 187)										int this63 = (this59 & 255);
HXDLIN( 187)										if ((this63 == 0)) {
HXLINE( 187)											b14 = ((Float)0.);
            										}
            										else {
HXLINE( 187)											b14 = (( (Float)(this63) ) / ( (Float)(255) ));
            										}
HXDLIN( 187)										Float a23;
HXDLIN( 187)										int this64 = ((col3 >> 24) & 255);
HXDLIN( 187)										if ((this64 == 0)) {
HXLINE( 187)											a23 = ((Float)0.);
            										}
            										else {
HXLINE( 187)											a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            										}
HXDLIN( 187)										Float r23;
HXDLIN( 187)										int this65 = ((col3 >> 16) & 255);
HXDLIN( 187)										if ((this65 == 0)) {
HXLINE( 187)											r23 = ((Float)0.);
            										}
            										else {
HXLINE( 187)											r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            										}
HXDLIN( 187)										Float g23;
HXDLIN( 187)										int this66 = ((col3 >> 8) & 255);
HXDLIN( 187)										if ((this66 == 0)) {
HXLINE( 187)											g23 = ((Float)0.);
            										}
            										else {
HXLINE( 187)											g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 187)										Float b24;
HXDLIN( 187)										int this67 = (col3 & 255);
HXDLIN( 187)										if ((this67 == 0)) {
HXLINE( 187)											b24 = ((Float)0.);
            										}
            										else {
HXLINE( 187)											b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 187)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 187)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 187)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 187)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 187)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 187)										int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 187)										{
HXLINE( 187)											int _hx_tmp16;
HXDLIN( 187)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)												_hx_tmp16 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE( 187)												_hx_tmp16 = blended3;
            											}
HXDLIN( 187)											::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp16);
            										}
            									}
            									else {
HXLINE( 187)										::Dynamic this68 = pixelImage->image;
HXDLIN( 187)										int index11;
HXDLIN( 187)										if (pixelImage->useVirtualPos) {
HXLINE( 187)											index11 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 187)											index11 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            										}
HXDLIN( 187)										int _hx_tmp17;
HXDLIN( 187)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 187)											_hx_tmp17 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            										}
            										else {
HXLINE( 187)											_hx_tmp17 = c9;
            										}
HXDLIN( 187)										::iterMagic::Iimg_obj::set(this68,index11,_hx_tmp17);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 187)			if ((hasHit == false)) {
HXLINE( 187)				 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN( 187)				if (hasUndo1) {
HXLINE( 187)					v7->undoImage = undoImage3;
HXDLIN( 187)					v7->undoX = xIter31->start;
HXDLIN( 187)					v7->undoY = yIter31->start;
            				}
            			}
            		}
HXLINE( 188)		if ((hasHit == true)) {
HXLINE( 189)			 ::pi_xy::algo::HitQuad v8 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE( 190)			return v8;
            		}
            		else {
HXLINE( 192)			return null();
            		}
HXLINE( 188)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC20(QuadPixel_Fields__obj,imgQuadrilateral,return )

 ::pi_xy::algo::HitQuad QuadPixel_Fields__obj::imageNineSlice( ::pi_xy::ImageStruct pixelImage, ::pi_xy::ImageStruct texture, ::pi_xy::algo::RectangleWindow win,Float x,Float y,Float wid,Float hi,Float left,Float top,Float fat,Float tall,Float widNew,Float hiNew,Float leftNew,Float topNew,Float fatNew,Float tallNew,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_da603ae7b1d3a0e2_206_imageNineSlice)
HXLINE( 210)		Float ax = x;
HXLINE( 211)		Float ay = y;
HXLINE( 212)		Float bx = (ax + widNew);
HXLINE( 213)		Float by = y;
HXLINE( 214)		Float cx = bx;
HXLINE( 215)		Float cy = (ay + hiNew);
HXLINE( 216)		Float dx = x;
HXLINE( 217)		Float dy = cx;
HXLINE( 219)		Float rightW = ((widNew - leftNew) - fatNew);
HXLINE( 220)		Float bottomH = ((hiNew - topNew) - tallNew);
HXLINE( 221)		Float leftX = (x + leftNew);
HXLINE( 222)		Float topY = (y + topNew);
HXLINE( 223)		Float rightX = ((x + leftNew) + fatNew);
HXLINE( 224)		Float bottomY = ((y + topNew) + tallNew);
HXLINE( 225)		Float au = ((Float)0.);
HXLINE( 226)		Float av = ((Float)0.);
HXLINE( 227)		Float bu = ((Float)0.);
HXLINE( 228)		Float cv = ((Float)0.);
HXLINE( 229)		Float sw = (( (Float)(1) ) / (wid + 1));
HXLINE( 230)		Float sh = (( (Float)(1) ) / (hi + 1));
HXLINE( 236)		bu = (left * sw);
HXLINE( 237)		cv = (top * sh);
HXLINE( 238)		{
HXLINE( 238)			{
HXLINE( 238)				Float au1 = ((Float)0.);
HXDLIN( 238)				Float av1 = ((Float)0.);
HXDLIN( 238)				Float bu1 = bu;
HXDLIN( 238)				Float bv = ((Float)0.);
HXDLIN( 238)				bool hasUndo = false;
HXDLIN( 238)				Float temp = au1;
HXLINE( 422)				au1 = bu1;
HXLINE( 423)				bu1 = temp;
HXLINE( 424)				temp = av1;
HXLINE( 425)				av1 = bv;
HXLINE( 426)				bv = temp;
HXLINE( 238)				Float bcx = (leftX - x);
HXDLIN( 238)				Float bcy = (y - topY);
HXDLIN( 238)				Float acx = (x - x);
HXDLIN( 238)				Float acy = (y - topY);
HXDLIN( 238)				Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 238)				Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 238)				Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 238)				Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 238)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 238)				if ((x > leftX)) {
HXLINE( 238)					if ((x > x)) {
HXLINE( 238)						int min;
HXDLIN( 238)						if ((leftX > x)) {
HXLINE( 238)							min = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 238)							min = ::Math_obj::floor(leftX);
            						}
HXDLIN( 238)						int ii_min = min;
HXDLIN( 238)						int ii_max = ::Math_obj::ceil(x);
HXDLIN( 238)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE( 238)						int ii_min1 = ::Math_obj::floor(leftX);
HXDLIN( 238)						int ii_max1 = ::Math_obj::ceil(x);
HXDLIN( 238)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE( 238)					if ((leftX > x)) {
HXLINE( 238)						int min1;
HXDLIN( 238)						if ((x > x)) {
HXLINE( 238)							min1 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 238)							min1 = ::Math_obj::ceil(x);
            						}
HXDLIN( 238)						int ii_min2 = min1;
HXDLIN( 238)						int ii_max2 = ::Math_obj::ceil(leftX);
HXDLIN( 238)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 238)						int ii_min3 = ::Math_obj::floor(x);
HXDLIN( 238)						int ii_max3 = ::Math_obj::ceil(x);
HXDLIN( 238)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 238)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 238)				if ((y > y)) {
HXLINE( 238)					if ((y > topY)) {
HXLINE( 238)						int min2;
HXDLIN( 238)						if ((y > topY)) {
HXLINE( 238)							min2 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 238)							min2 = ::Math_obj::floor(y);
            						}
HXDLIN( 238)						int ii_min4 = min2;
HXDLIN( 238)						int ii_max4 = ::Math_obj::ceil(y);
HXDLIN( 238)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 238)						int ii_min5 = ::Math_obj::floor(y);
HXDLIN( 238)						int ii_max5 = ::Math_obj::ceil(topY);
HXDLIN( 238)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE( 238)					if ((y > topY)) {
HXLINE( 238)						int min3;
HXDLIN( 238)						if ((y > topY)) {
HXLINE( 238)							min3 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 238)							min3 = ::Math_obj::ceil(y);
            						}
HXDLIN( 238)						int ii_min6 = min3;
HXDLIN( 238)						int ii_max6 = ::Math_obj::ceil(y);
HXDLIN( 238)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 238)						int ii_min7 = ::Math_obj::floor(y);
HXDLIN( 238)						int ii_max7 = ::Math_obj::ceil(topY);
HXDLIN( 238)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 238)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 238)				if (hasUndo) {
HXLINE( 238)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 238)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 238)					 ::Dynamic imageType = null();
HXDLIN( 238)					 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 238)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 238)					::Dynamic undoImage1;
HXDLIN( 238)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 238)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 238)							{
HXLINE( 238)								b->width = width;
HXDLIN( 238)								b->height = height;
HXDLIN( 238)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 238)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 238)								{
HXLINE( 238)									int len = b->length;
HXDLIN( 238)									int w = 0;
HXDLIN( 238)									{
HXLINE( 238)										int _g = 0;
HXDLIN( 238)										int _g1 = b->height;
HXDLIN( 238)										while((_g < _g1)){
HXLINE( 238)											_g = (_g + 1);
HXDLIN( 238)											int y1 = (_g - 1);
HXDLIN( 238)											{
HXLINE( 238)												int _g2 = 0;
HXDLIN( 238)												int _g3 = b->width;
HXDLIN( 238)												while((_g2 < _g3)){
HXLINE( 238)													_g2 = (_g2 + 1);
HXDLIN( 238)													int x1 = (_g2 - 1);
HXDLIN( 238)													{
HXLINE( 238)														w = (w + 1);
HXDLIN( 238)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 238)													{
HXLINE( 238)														w = (w + 1);
HXDLIN( 238)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 238)													{
HXLINE( 238)														w = (w + 1);
HXDLIN( 238)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 238)													{
HXLINE( 238)														w = (w + 1);
HXDLIN( 238)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 238)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE( 238)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 238)							{
HXLINE( 238)								a->width = width;
HXDLIN( 238)								a->height = height;
HXDLIN( 238)								a->data = ::Array_obj< int >::__new(0);
HXDLIN( 238)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 238)								{
HXLINE( 238)									int _g4 = 0;
HXDLIN( 238)									int _g5 = a->length;
HXDLIN( 238)									while((_g4 < _g5)){
HXLINE( 238)										_g4 = (_g4 + 1);
HXDLIN( 238)										int i = (_g4 - 1);
HXDLIN( 238)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN( 238)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE( 238)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 238)							{
HXLINE( 238)								b1->width = width;
HXDLIN( 238)								b1->height = height;
HXDLIN( 238)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 238)								int size = (b1->length * 4);
HXDLIN( 238)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 238)								{
HXLINE( 238)									int _g6 = 0;
HXDLIN( 238)									int _g7 = b1->length;
HXDLIN( 238)									while((_g6 < _g7)){
HXLINE( 238)										_g6 = (_g6 + 1);
HXDLIN( 238)										int i1 = (_g6 - 1);
HXDLIN( 238)										{
HXLINE( 238)											 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN( 238)											bool undoImage2;
HXDLIN( 238)											if ((i1 >= 0)) {
HXLINE( 238)												undoImage2 = (i1 < (this2->byteLength >> 2));
            											}
            											else {
HXLINE( 238)												undoImage2 = false;
            											}
HXDLIN( 238)											if (undoImage2) {
HXLINE( 238)												 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN( 238)												int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN( 238)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 238)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 238)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 238)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 238)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE( 238)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 238)							{
HXLINE( 238)								v->width = width;
HXDLIN( 238)								v->height = height;
HXDLIN( 238)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 238)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 238)								{
HXLINE( 238)									int _g8 = 0;
HXDLIN( 238)									int _g9 = v->length;
HXDLIN( 238)									while((_g8 < _g9)){
HXLINE( 238)										_g8 = (_g8 + 1);
HXDLIN( 238)										int i2 = (_g8 - 1);
HXDLIN( 238)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN( 238)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 238)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 238)							{
HXLINE( 238)								b2->width = width;
HXDLIN( 238)								b2->height = height;
HXDLIN( 238)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 238)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 238)								{
HXLINE( 238)									int len1 = b2->length;
HXDLIN( 238)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 238)									if (::hx::IsNull( d->head )) {
HXLINE( 238)										int _g10 = 0;
HXDLIN( 238)										int _g11 = len1;
HXDLIN( 238)										while((_g10 < _g11)){
HXLINE( 238)											_g10 = (_g10 + 1);
HXDLIN( 238)											int i3 = (_g10 - 1);
HXDLIN( 238)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 238)										int _g12 = 0;
HXDLIN( 238)										int _g13 = len1;
HXDLIN( 238)										while((_g12 < _g13)){
HXLINE( 238)											_g12 = (_g12 + 1);
HXDLIN( 238)											int i4 = (_g12 - 1);
HXDLIN( 238)											{
HXLINE( 238)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 238)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 238)												{
HXLINE( 238)													int _g14 = 0;
HXDLIN( 238)													int _g15 = i4;
HXDLIN( 238)													while((_g14 < _g15)){
HXLINE( 238)														_g14 = (_g14 + 1);
HXDLIN( 238)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 238)												if (::hx::IsNull( prev )) {
HXLINE( 238)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 238)													l = null();
            												}
            												else {
HXLINE( 238)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 238)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 238)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 238)					this1->image = undoImage1;
HXDLIN( 238)					this1->width = width;
HXDLIN( 238)					this1->height = height;
HXDLIN( 238)					this1->imageType = ( (int)(imageType) );
HXDLIN( 238)					undoImage = this1;
HXDLIN( 238)					{
HXLINE( 238)						int rectLeft = xIter3->start;
HXDLIN( 238)						int rectTop = yIter3->start;
HXDLIN( 238)						int rectRight = xIter3->max;
HXDLIN( 238)						bool forceClear = false;
HXDLIN( 238)						{
HXLINE( 238)							int _g16 = rectTop;
HXDLIN( 238)							int _g17 = yIter3->max;
HXDLIN( 238)							while((_g16 < _g17)){
HXLINE( 238)								_g16 = (_g16 + 1);
HXDLIN( 238)								int dy1 = (_g16 - 1);
HXDLIN( 238)								{
HXLINE( 238)									int _g18 = rectLeft;
HXDLIN( 238)									int _g19 = rectRight;
HXDLIN( 238)									while((_g18 < _g19)){
HXLINE( 238)										_g18 = (_g18 + 1);
HXDLIN( 238)										int dx1 = (_g18 - 1);
HXDLIN( 238)										::Dynamic this3 = pixelImage->image;
HXDLIN( 238)										int index;
HXDLIN( 238)										if (pixelImage->useVirtualPos) {
HXLINE( 238)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx1) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 238)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * pixelImage->width) + dx1)) ));
            										}
HXDLIN( 238)										int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN( 238)										int col;
HXDLIN( 238)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 238)											col = c;
            										}
HXDLIN( 238)										bool _hx_tmp;
HXDLIN( 238)										if (pixelImage->useMask) {
HXLINE( 238)											_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 238)											_hx_tmp = false;
            										}
HXDLIN( 238)										if (_hx_tmp) {
HXLINE( 238)											 ::pi_xy::ImageStruct this4 = pixelImage->mask;
HXDLIN( 238)											::Dynamic this5 = this4->image;
HXDLIN( 238)											int index1;
HXDLIN( 238)											if (this4->useVirtualPos) {
HXLINE( 238)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            											}
            											else {
HXLINE( 238)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            											}
HXDLIN( 238)											int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN( 238)											int v1;
HXDLIN( 238)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 238)												v1 = c1;
            											}
HXDLIN( 238)											int maskPixel = v1;
HXDLIN( 238)											int this6 = col;
HXDLIN( 238)											if ((maskPixel == 0)) {
HXLINE( 238)												col = this6;
            											}
            											else {
HXLINE( 238)												Float m0;
HXDLIN( 238)												int this7 = ((maskPixel >> 24) & 255);
HXDLIN( 238)												if ((this7 == 0)) {
HXLINE( 238)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float m1;
HXDLIN( 238)												int this8 = ((maskPixel >> 16) & 255);
HXDLIN( 238)												if ((this8 == 0)) {
HXLINE( 238)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float m2;
HXDLIN( 238)												int this9 = ((maskPixel >> 8) & 255);
HXDLIN( 238)												if ((this9 == 0)) {
HXLINE( 238)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float m3;
HXDLIN( 238)												int this10 = (maskPixel & 255);
HXDLIN( 238)												if ((this10 == 0)) {
HXLINE( 238)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN( 238)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN( 238)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN( 238)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN( 238)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 238)										if ((col != 0)) {
HXLINE( 238)											int x2 = (dx1 - rectLeft);
HXDLIN( 238)											int y2 = (dy1 - rectTop);
HXDLIN( 238)											int c2 = col;
HXDLIN( 238)											bool _hx_tmp1;
HXDLIN( 238)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 238)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE( 238)												_hx_tmp1 = false;
            											}
HXDLIN( 238)											if (_hx_tmp1) {
HXLINE( 238)												int location;
HXDLIN( 238)												if (undoImage->useVirtualPos) {
HXLINE( 238)													location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 238)													location = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 238)												int this11 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 238)												int this12;
HXDLIN( 238)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)													this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            												}
            												else {
HXLINE( 238)													this12 = this11;
            												}
HXDLIN( 238)												Float a1;
HXDLIN( 238)												int this13 = ((this12 >> 24) & 255);
HXDLIN( 238)												if ((this13 == 0)) {
HXLINE( 238)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float r1;
HXDLIN( 238)												int this14 = ((this12 >> 16) & 255);
HXDLIN( 238)												if ((this14 == 0)) {
HXLINE( 238)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float g1;
HXDLIN( 238)												int this15 = ((this12 >> 8) & 255);
HXDLIN( 238)												if ((this15 == 0)) {
HXLINE( 238)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float b11;
HXDLIN( 238)												int this16 = (this12 & 255);
HXDLIN( 238)												if ((this16 == 0)) {
HXLINE( 238)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float a2;
HXDLIN( 238)												int this17 = ((col >> 24) & 255);
HXDLIN( 238)												if ((this17 == 0)) {
HXLINE( 238)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float r2;
HXDLIN( 238)												int this18 = ((col >> 16) & 255);
HXDLIN( 238)												if ((this18 == 0)) {
HXLINE( 238)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float g2;
HXDLIN( 238)												int this19 = ((col >> 8) & 255);
HXDLIN( 238)												if ((this19 == 0)) {
HXLINE( 238)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float b21;
HXDLIN( 238)												int this20 = (col & 255);
HXDLIN( 238)												if ((this20 == 0)) {
HXLINE( 238)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 238)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 238)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 238)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 238)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 238)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 238)												{
HXLINE( 238)													int _hx_tmp2;
HXDLIN( 238)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 238)														_hx_tmp2 = blended;
            													}
HXDLIN( 238)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE( 238)												::Dynamic this21 = undoImage->image;
HXDLIN( 238)												int index2;
HXDLIN( 238)												if (undoImage->useVirtualPos) {
HXLINE( 238)													index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 238)													index2 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 238)												int _hx_tmp3;
HXDLIN( 238)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 238)													_hx_tmp3 = c2;
            												}
HXDLIN( 238)												::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE( 238)											if (forceClear) {
HXLINE( 238)												::Dynamic this22 = undoImage->image;
HXDLIN( 238)												int x3 = (dx1 - rectLeft);
HXDLIN( 238)												int y3 = (dy1 - rectTop);
HXDLIN( 238)												int index3;
HXDLIN( 238)												if (undoImage->useVirtualPos) {
HXLINE( 238)													index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            												}
            												else {
HXLINE( 238)													index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            												}
HXDLIN( 238)												::iterMagic::Iimg_obj::set(this22,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 238)				{
HXLINE( 238)					int _g_min = xIter3->start;
HXDLIN( 238)					int _g_max = xIter3->max;
HXDLIN( 238)					while((_g_min < _g_max)){
HXLINE( 238)						_g_min = (_g_min + 1);
HXDLIN( 238)						int px = (_g_min - 1);
HXDLIN( 238)						Float pcx = (( (Float)(px) ) - x);
HXDLIN( 238)						{
HXLINE( 238)							int _g_min1 = yIter3->start;
HXDLIN( 238)							int _g_max1 = yIter3->max;
HXDLIN( 238)							while((_g_min1 < _g_max1)){
HXLINE( 238)								_g_min1 = (_g_min1 + 1);
HXDLIN( 238)								int py = (_g_min1 - 1);
HXDLIN( 238)								Float pcy = (( (Float)(py) ) - topY);
HXDLIN( 238)								Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 238)								Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 238)								Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 238)								Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 238)								Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 238)								bool _hx_tmp4;
HXDLIN( 238)								bool _hx_tmp5;
HXDLIN( 238)								if ((ratioA >= 0)) {
HXLINE( 238)									_hx_tmp5 = (ratioB >= 0);
            								}
            								else {
HXLINE( 238)									_hx_tmp5 = false;
            								}
HXDLIN( 238)								if (_hx_tmp5) {
HXLINE( 238)									_hx_tmp4 = (ratioC >= 0);
            								}
            								else {
HXLINE( 238)									_hx_tmp4 = false;
            								}
HXDLIN( 238)								if (_hx_tmp4) {
HXLINE( 238)									Float u = (((au1 * ratioA) + (bu1 * ratioB)) + (((Float)0.) * ratioC));
HXDLIN( 238)									Float v2 = (((av1 * ratioA) + (bv * ratioB)) + (cv * ratioC));
HXDLIN( 238)									int x4 = ::Std_obj::_hx_int(((u * win->width) + win->x));
HXDLIN( 238)									int y4 = ::Std_obj::_hx_int(((v2 * win->height) + win->y));
HXDLIN( 238)									::Dynamic this23 = texture->image;
HXDLIN( 238)									int index4;
HXDLIN( 238)									if (texture->useVirtualPos) {
HXLINE( 238)										index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - texture->virtualY) * ( (Float)(texture->width) )) + x4) - texture->virtualX));
            									}
            									else {
HXLINE( 238)										index4 = ::Std_obj::_hx_int(( (Float)(((y4 * texture->width) + x4)) ));
            									}
HXDLIN( 238)									int c3 = ::iterMagic::Iimg_obj::get(this23,index4);
HXDLIN( 238)									int col1;
HXDLIN( 238)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXLINE( 238)										col1 = c3;
            									}
HXDLIN( 238)									{
HXLINE( 238)										int c4 = col1;
HXDLIN( 238)										bool _hx_tmp6;
HXDLIN( 238)										if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 238)											_hx_tmp6 = pixelImage->transparent;
            										}
            										else {
HXLINE( 238)											_hx_tmp6 = false;
            										}
HXDLIN( 238)										if (_hx_tmp6) {
HXLINE( 238)											int location1;
HXDLIN( 238)											if (pixelImage->useVirtualPos) {
HXLINE( 238)												location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 238)												location1 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            											}
HXDLIN( 238)											int this24 = ::iterMagic::Iimg_obj::get(pixelImage->image,location1);
HXDLIN( 238)											int this25;
HXDLIN( 238)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)												this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            											}
            											else {
HXLINE( 238)												this25 = this24;
            											}
HXDLIN( 238)											Float a11;
HXDLIN( 238)											int this26 = ((this25 >> 24) & 255);
HXDLIN( 238)											if ((this26 == 0)) {
HXLINE( 238)												a11 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float r11;
HXDLIN( 238)											int this27 = ((this25 >> 16) & 255);
HXDLIN( 238)											if ((this27 == 0)) {
HXLINE( 238)												r11 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float g11;
HXDLIN( 238)											int this28 = ((this25 >> 8) & 255);
HXDLIN( 238)											if ((this28 == 0)) {
HXLINE( 238)												g11 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float b12;
HXDLIN( 238)											int this29 = (this25 & 255);
HXDLIN( 238)											if ((this29 == 0)) {
HXLINE( 238)												b12 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float a21;
HXDLIN( 238)											int this30 = ((col1 >> 24) & 255);
HXDLIN( 238)											if ((this30 == 0)) {
HXLINE( 238)												a21 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float r21;
HXDLIN( 238)											int this31 = ((col1 >> 16) & 255);
HXDLIN( 238)											if ((this31 == 0)) {
HXLINE( 238)												r21 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float g21;
HXDLIN( 238)											int this32 = ((col1 >> 8) & 255);
HXDLIN( 238)											if ((this32 == 0)) {
HXLINE( 238)												g21 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float b22;
HXDLIN( 238)											int this33 = (col1 & 255);
HXDLIN( 238)											if ((this33 == 0)) {
HXLINE( 238)												b22 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 238)											int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 238)											int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 238)											int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 238)											int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 238)											int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 238)											{
HXLINE( 238)												int _hx_tmp7;
HXDLIN( 238)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)													_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXLINE( 238)													_hx_tmp7 = blended1;
            												}
HXDLIN( 238)												::iterMagic::Iimg_obj::set(pixelImage->image,location1,_hx_tmp7);
            											}
            										}
            										else {
HXLINE( 238)											::Dynamic this34 = pixelImage->image;
HXDLIN( 238)											int index5;
HXDLIN( 238)											if (pixelImage->useVirtualPos) {
HXLINE( 238)												index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 238)												index5 = ::Std_obj::_hx_int(( (Float)(((py * pixelImage->width) + px)) ));
            											}
HXDLIN( 238)											int _hx_tmp8;
HXDLIN( 238)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)												_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXLINE( 238)												_hx_tmp8 = c4;
            											}
HXDLIN( 238)											::iterMagic::Iimg_obj::set(this34,index5,_hx_tmp8);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 238)				if ((hasHit == false)) {
HXLINE( 238)					 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x,y,leftX,y,x,topY,true);
HXDLIN( 238)					if (hasUndo) {
HXLINE( 238)						v3->undoImage = undoImage;
HXDLIN( 238)						v3->undoX = xIter3->start;
HXDLIN( 238)						v3->undoY = yIter3->start;
            					}
            				}
            			}
HXDLIN( 238)			{
HXLINE( 238)				Float au2 = bu;
HXDLIN( 238)				Float av2 = ((Float)0.);
HXDLIN( 238)				Float bu2 = bu;
HXDLIN( 238)				Float bv1 = cv;
HXDLIN( 238)				bool hasUndo1 = false;
HXDLIN( 238)				Float temp1 = au2;
HXLINE( 422)				au2 = bu2;
HXLINE( 423)				bu2 = temp1;
HXLINE( 424)				temp1 = av2;
HXLINE( 425)				av2 = bv1;
HXLINE( 426)				bv1 = temp1;
HXLINE( 238)				Float bcx1 = (leftX - x);
HXDLIN( 238)				Float bcy1 = (topY - topY);
HXDLIN( 238)				Float acx1 = (leftX - x);
HXDLIN( 238)				Float acy1 = (y - topY);
HXDLIN( 238)				Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 238)				Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 238)				Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 238)				Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 238)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 238)				if ((leftX > leftX)) {
HXLINE( 238)					if ((leftX > x)) {
HXLINE( 238)						int min4;
HXDLIN( 238)						if ((leftX > x)) {
HXLINE( 238)							min4 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 238)							min4 = ::Math_obj::floor(leftX);
            						}
HXDLIN( 238)						int ii_min8 = min4;
HXDLIN( 238)						int ii_max8 = ::Math_obj::ceil(leftX);
HXDLIN( 238)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE( 238)						int ii_min9 = ::Math_obj::floor(leftX);
HXDLIN( 238)						int ii_max9 = ::Math_obj::ceil(x);
HXDLIN( 238)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE( 238)					if ((leftX > x)) {
HXLINE( 238)						int min5;
HXDLIN( 238)						if ((leftX > x)) {
HXLINE( 238)							min5 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 238)							min5 = ::Math_obj::ceil(leftX);
            						}
HXDLIN( 238)						int ii_min10 = min5;
HXDLIN( 238)						int ii_max10 = ::Math_obj::ceil(leftX);
HXDLIN( 238)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE( 238)						int ii_min11 = ::Math_obj::floor(leftX);
HXDLIN( 238)						int ii_max11 = ::Math_obj::ceil(x);
HXDLIN( 238)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN( 238)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 238)				if ((y > topY)) {
HXLINE( 238)					if ((y > topY)) {
HXLINE( 238)						int min6;
HXDLIN( 238)						if ((topY > topY)) {
HXLINE( 238)							min6 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 238)							min6 = ::Math_obj::floor(topY);
            						}
HXDLIN( 238)						int ii_min12 = min6;
HXDLIN( 238)						int ii_max12 = ::Math_obj::ceil(y);
HXDLIN( 238)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE( 238)						int ii_min13 = ::Math_obj::floor(topY);
HXDLIN( 238)						int ii_max13 = ::Math_obj::ceil(topY);
HXDLIN( 238)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE( 238)					if ((topY > topY)) {
HXLINE( 238)						int min7;
HXDLIN( 238)						if ((y > topY)) {
HXLINE( 238)							min7 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 238)							min7 = ::Math_obj::ceil(y);
            						}
HXDLIN( 238)						int ii_min14 = min7;
HXDLIN( 238)						int ii_max14 = ::Math_obj::ceil(topY);
HXDLIN( 238)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE( 238)						int ii_min15 = ::Math_obj::floor(y);
HXDLIN( 238)						int ii_max15 = ::Math_obj::ceil(topY);
HXDLIN( 238)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN( 238)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 238)				if (hasUndo1) {
HXLINE( 238)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 238)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 238)					 ::Dynamic imageType1 = null();
HXDLIN( 238)					 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 238)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 238)					::Dynamic undoImage4;
HXDLIN( 238)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE( 238)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 238)							{
HXLINE( 238)								b5->width = width1;
HXDLIN( 238)								b5->height = height1;
HXDLIN( 238)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 238)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 238)								{
HXLINE( 238)									int len2 = b5->length;
HXDLIN( 238)									int w1 = 0;
HXDLIN( 238)									{
HXLINE( 238)										int _g20 = 0;
HXDLIN( 238)										int _g21 = b5->height;
HXDLIN( 238)										while((_g20 < _g21)){
HXLINE( 238)											_g20 = (_g20 + 1);
HXDLIN( 238)											int y5 = (_g20 - 1);
HXDLIN( 238)											{
HXLINE( 238)												int _g22 = 0;
HXDLIN( 238)												int _g23 = b5->width;
HXDLIN( 238)												while((_g22 < _g23)){
HXLINE( 238)													_g22 = (_g22 + 1);
HXDLIN( 238)													int x5 = (_g22 - 1);
HXDLIN( 238)													{
HXLINE( 238)														w1 = (w1 + 1);
HXDLIN( 238)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 238)													{
HXLINE( 238)														w1 = (w1 + 1);
HXDLIN( 238)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 238)													{
HXLINE( 238)														w1 = (w1 + 1);
HXDLIN( 238)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 238)													{
HXLINE( 238)														w1 = (w1 + 1);
HXDLIN( 238)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 238)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXLINE( 238)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 238)							{
HXLINE( 238)								a6->width = width1;
HXDLIN( 238)								a6->height = height1;
HXDLIN( 238)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 238)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 238)								{
HXLINE( 238)									int _g24 = 0;
HXDLIN( 238)									int _g25 = a6->length;
HXDLIN( 238)									while((_g24 < _g25)){
HXLINE( 238)										_g24 = (_g24 + 1);
HXDLIN( 238)										int i6 = (_g24 - 1);
HXDLIN( 238)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN( 238)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXLINE( 238)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 238)							{
HXLINE( 238)								b6->width = width1;
HXDLIN( 238)								b6->height = height1;
HXDLIN( 238)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 238)								int size1 = (b6->length * 4);
HXDLIN( 238)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 238)								{
HXLINE( 238)									int _g26 = 0;
HXDLIN( 238)									int _g27 = b6->length;
HXDLIN( 238)									while((_g26 < _g27)){
HXLINE( 238)										_g26 = (_g26 + 1);
HXDLIN( 238)										int i7 = (_g26 - 1);
HXDLIN( 238)										{
HXLINE( 238)											 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN( 238)											bool undoImage5;
HXDLIN( 238)											if ((i7 >= 0)) {
HXLINE( 238)												undoImage5 = (i7 < (this36->byteLength >> 2));
            											}
            											else {
HXLINE( 238)												undoImage5 = false;
            											}
HXDLIN( 238)											if (undoImage5) {
HXLINE( 238)												 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 238)												int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 238)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 238)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 238)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 238)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 238)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXLINE( 238)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 238)							{
HXLINE( 238)								v4->width = width1;
HXDLIN( 238)								v4->height = height1;
HXDLIN( 238)								v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 238)								v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 238)								{
HXLINE( 238)									int _g28 = 0;
HXDLIN( 238)									int _g29 = v4->length;
HXDLIN( 238)									while((_g28 < _g29)){
HXLINE( 238)										_g28 = (_g28 + 1);
HXDLIN( 238)										int i8 = (_g28 - 1);
HXDLIN( 238)										v4->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN( 238)							undoImage4 = v4;
            						}
            						break;
            						case (int)4: {
HXLINE( 238)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 238)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 238)							{
HXLINE( 238)								b7->width = width1;
HXDLIN( 238)								b7->height = height1;
HXDLIN( 238)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 238)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 238)								{
HXLINE( 238)									int len3 = b7->length;
HXDLIN( 238)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 238)									if (::hx::IsNull( d1->head )) {
HXLINE( 238)										int _g30 = 0;
HXDLIN( 238)										int _g31 = len3;
HXDLIN( 238)										while((_g30 < _g31)){
HXLINE( 238)											_g30 = (_g30 + 1);
HXDLIN( 238)											int i9 = (_g30 - 1);
HXDLIN( 238)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE( 238)										int _g32 = 0;
HXDLIN( 238)										int _g33 = len3;
HXDLIN( 238)										while((_g32 < _g33)){
HXLINE( 238)											_g32 = (_g32 + 1);
HXDLIN( 238)											int i10 = (_g32 - 1);
HXDLIN( 238)											{
HXLINE( 238)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 238)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 238)												{
HXLINE( 238)													int _g34 = 0;
HXDLIN( 238)													int _g35 = i10;
HXDLIN( 238)													while((_g34 < _g35)){
HXLINE( 238)														_g34 = (_g34 + 1);
HXDLIN( 238)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 238)												if (::hx::IsNull( prev1 )) {
HXLINE( 238)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 238)													l1 = null();
            												}
            												else {
HXLINE( 238)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 238)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 238)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN( 238)					this35->image = undoImage4;
HXDLIN( 238)					this35->width = width1;
HXDLIN( 238)					this35->height = height1;
HXDLIN( 238)					this35->imageType = ( (int)(imageType1) );
HXDLIN( 238)					undoImage3 = this35;
HXDLIN( 238)					{
HXLINE( 238)						int rectLeft1 = xIter31->start;
HXDLIN( 238)						int rectTop1 = yIter31->start;
HXDLIN( 238)						int rectRight1 = xIter31->max;
HXDLIN( 238)						bool forceClear1 = false;
HXDLIN( 238)						{
HXLINE( 238)							int _g36 = rectTop1;
HXDLIN( 238)							int _g37 = yIter31->max;
HXDLIN( 238)							while((_g36 < _g37)){
HXLINE( 238)								_g36 = (_g36 + 1);
HXDLIN( 238)								int dy2 = (_g36 - 1);
HXDLIN( 238)								{
HXLINE( 238)									int _g38 = rectLeft1;
HXDLIN( 238)									int _g39 = rectRight1;
HXDLIN( 238)									while((_g38 < _g39)){
HXLINE( 238)										_g38 = (_g38 + 1);
HXDLIN( 238)										int dx2 = (_g38 - 1);
HXDLIN( 238)										::Dynamic this37 = pixelImage->image;
HXDLIN( 238)										int index6;
HXDLIN( 238)										if (pixelImage->useVirtualPos) {
HXLINE( 238)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx2) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 238)											index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelImage->width) + dx2)) ));
            										}
HXDLIN( 238)										int c5 = ::iterMagic::Iimg_obj::get(this37,index6);
HXDLIN( 238)										int col2;
HXDLIN( 238)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)											col2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE( 238)											col2 = c5;
            										}
HXDLIN( 238)										bool _hx_tmp9;
HXDLIN( 238)										if (pixelImage->useMask) {
HXLINE( 238)											_hx_tmp9 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 238)											_hx_tmp9 = false;
            										}
HXDLIN( 238)										if (_hx_tmp9) {
HXLINE( 238)											 ::pi_xy::ImageStruct this38 = pixelImage->mask;
HXDLIN( 238)											::Dynamic this39 = this38->image;
HXDLIN( 238)											int index7;
HXDLIN( 238)											if (this38->useVirtualPos) {
HXLINE( 238)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            											}
            											else {
HXLINE( 238)												index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            											}
HXDLIN( 238)											int c6 = ::iterMagic::Iimg_obj::get(this39,index7);
HXDLIN( 238)											int v5;
HXDLIN( 238)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)												v5 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE( 238)												v5 = c6;
            											}
HXDLIN( 238)											int maskPixel1 = v5;
HXDLIN( 238)											int this40 = col2;
HXDLIN( 238)											if ((maskPixel1 == 0)) {
HXLINE( 238)												col2 = this40;
            											}
            											else {
HXLINE( 238)												Float m01;
HXDLIN( 238)												int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 238)												if ((this41 == 0)) {
HXLINE( 238)													m01 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float m11;
HXDLIN( 238)												int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 238)												if ((this42 == 0)) {
HXLINE( 238)													m11 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float m21;
HXDLIN( 238)												int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 238)												if ((this43 == 0)) {
HXLINE( 238)													m21 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float m31;
HXDLIN( 238)												int this44 = (maskPixel1 & 255);
HXDLIN( 238)												if ((this44 == 0)) {
HXLINE( 238)													m31 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 238)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 238)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 238)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 238)												col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 238)										if ((col2 != 0)) {
HXLINE( 238)											int x6 = (dx2 - rectLeft1);
HXDLIN( 238)											int y6 = (dy2 - rectTop1);
HXDLIN( 238)											int c7 = col2;
HXDLIN( 238)											bool _hx_tmp10;
HXDLIN( 238)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 238)												_hx_tmp10 = undoImage3->transparent;
            											}
            											else {
HXLINE( 238)												_hx_tmp10 = false;
            											}
HXDLIN( 238)											if (_hx_tmp10) {
HXLINE( 238)												int location2;
HXDLIN( 238)												if (undoImage3->useVirtualPos) {
HXLINE( 238)													location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 238)													location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 238)												int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 238)												int this46;
HXDLIN( 238)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)													this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            												}
            												else {
HXLINE( 238)													this46 = this45;
            												}
HXDLIN( 238)												Float a12;
HXDLIN( 238)												int this47 = ((this46 >> 24) & 255);
HXDLIN( 238)												if ((this47 == 0)) {
HXLINE( 238)													a12 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float r12;
HXDLIN( 238)												int this48 = ((this46 >> 16) & 255);
HXDLIN( 238)												if ((this48 == 0)) {
HXLINE( 238)													r12 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float g12;
HXDLIN( 238)												int this49 = ((this46 >> 8) & 255);
HXDLIN( 238)												if ((this49 == 0)) {
HXLINE( 238)													g12 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float b13;
HXDLIN( 238)												int this50 = (this46 & 255);
HXDLIN( 238)												if ((this50 == 0)) {
HXLINE( 238)													b13 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float a22;
HXDLIN( 238)												int this51 = ((col2 >> 24) & 255);
HXDLIN( 238)												if ((this51 == 0)) {
HXLINE( 238)													a22 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float r22;
HXDLIN( 238)												int this52 = ((col2 >> 16) & 255);
HXDLIN( 238)												if ((this52 == 0)) {
HXLINE( 238)													r22 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float g22;
HXDLIN( 238)												int this53 = ((col2 >> 8) & 255);
HXDLIN( 238)												if ((this53 == 0)) {
HXLINE( 238)													g22 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float b23;
HXDLIN( 238)												int this54 = (col2 & 255);
HXDLIN( 238)												if ((this54 == 0)) {
HXLINE( 238)													b23 = ((Float)0.);
            												}
            												else {
HXLINE( 238)													b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN( 238)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 238)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 238)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 238)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 238)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 238)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 238)												{
HXLINE( 238)													int _hx_tmp11;
HXDLIN( 238)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)														_hx_tmp11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE( 238)														_hx_tmp11 = blended2;
            													}
HXDLIN( 238)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp11);
            												}
            											}
            											else {
HXLINE( 238)												::Dynamic this55 = undoImage3->image;
HXDLIN( 238)												int index8;
HXDLIN( 238)												if (undoImage3->useVirtualPos) {
HXLINE( 238)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 238)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 238)												int _hx_tmp12;
HXDLIN( 238)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)													_hx_tmp12 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE( 238)													_hx_tmp12 = c7;
            												}
HXDLIN( 238)												::iterMagic::Iimg_obj::set(this55,index8,_hx_tmp12);
            											}
            										}
            										else {
HXLINE( 238)											if (forceClear1) {
HXLINE( 238)												::Dynamic this56 = undoImage3->image;
HXDLIN( 238)												int x7 = (dx2 - rectLeft1);
HXDLIN( 238)												int y7 = (dy2 - rectTop1);
HXDLIN( 238)												int index9;
HXDLIN( 238)												if (undoImage3->useVirtualPos) {
HXLINE( 238)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            												}
            												else {
HXLINE( 238)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            												}
HXDLIN( 238)												::iterMagic::Iimg_obj::set(this56,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 238)				{
HXLINE( 238)					int _g_min2 = xIter31->start;
HXDLIN( 238)					int _g_max2 = xIter31->max;
HXDLIN( 238)					while((_g_min2 < _g_max2)){
HXLINE( 238)						_g_min2 = (_g_min2 + 1);
HXDLIN( 238)						int px1 = (_g_min2 - 1);
HXDLIN( 238)						Float pcx1 = (( (Float)(px1) ) - x);
HXDLIN( 238)						{
HXLINE( 238)							int _g_min3 = yIter31->start;
HXDLIN( 238)							int _g_max3 = yIter31->max;
HXDLIN( 238)							while((_g_min3 < _g_max3)){
HXLINE( 238)								_g_min3 = (_g_min3 + 1);
HXDLIN( 238)								int py1 = (_g_min3 - 1);
HXDLIN( 238)								Float pcy1 = (( (Float)(py1) ) - topY);
HXDLIN( 238)								Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 238)								Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 238)								Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 238)								Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 238)								Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 238)								bool _hx_tmp13;
HXDLIN( 238)								bool _hx_tmp14;
HXDLIN( 238)								if ((ratioA1 >= 0)) {
HXLINE( 238)									_hx_tmp14 = (ratioB1 >= 0);
            								}
            								else {
HXLINE( 238)									_hx_tmp14 = false;
            								}
HXDLIN( 238)								if (_hx_tmp14) {
HXLINE( 238)									_hx_tmp13 = (ratioC1 >= 0);
            								}
            								else {
HXLINE( 238)									_hx_tmp13 = false;
            								}
HXDLIN( 238)								if (_hx_tmp13) {
HXLINE( 238)									Float u1 = (((au2 * ratioA1) + (bu2 * ratioB1)) + (((Float)0.) * ratioC1));
HXDLIN( 238)									Float v6 = (((av2 * ratioA1) + (bv1 * ratioB1)) + (cv * ratioC1));
HXDLIN( 238)									int x8 = ::Std_obj::_hx_int(((u1 * win->width) + win->x));
HXDLIN( 238)									int y8 = ::Std_obj::_hx_int(((v6 * win->height) + win->y));
HXDLIN( 238)									::Dynamic this57 = texture->image;
HXDLIN( 238)									int index10;
HXDLIN( 238)									if (texture->useVirtualPos) {
HXLINE( 238)										index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - texture->virtualY) * ( (Float)(texture->width) )) + x8) - texture->virtualX));
            									}
            									else {
HXLINE( 238)										index10 = ::Std_obj::_hx_int(( (Float)(((y8 * texture->width) + x8)) ));
            									}
HXDLIN( 238)									int c8 = ::iterMagic::Iimg_obj::get(this57,index10);
HXDLIN( 238)									int col3;
HXDLIN( 238)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)										col3 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            									}
            									else {
HXLINE( 238)										col3 = c8;
            									}
HXDLIN( 238)									{
HXLINE( 238)										int c9 = col3;
HXDLIN( 238)										bool _hx_tmp15;
HXDLIN( 238)										if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 238)											_hx_tmp15 = pixelImage->transparent;
            										}
            										else {
HXLINE( 238)											_hx_tmp15 = false;
            										}
HXDLIN( 238)										if (_hx_tmp15) {
HXLINE( 238)											int location3;
HXDLIN( 238)											if (pixelImage->useVirtualPos) {
HXLINE( 238)												location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 238)												location3 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            											}
HXDLIN( 238)											int this58 = ::iterMagic::Iimg_obj::get(pixelImage->image,location3);
HXDLIN( 238)											int this59;
HXDLIN( 238)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)												this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            											}
            											else {
HXLINE( 238)												this59 = this58;
            											}
HXDLIN( 238)											Float a13;
HXDLIN( 238)											int this60 = ((this59 >> 24) & 255);
HXDLIN( 238)											if ((this60 == 0)) {
HXLINE( 238)												a13 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float r13;
HXDLIN( 238)											int this61 = ((this59 >> 16) & 255);
HXDLIN( 238)											if ((this61 == 0)) {
HXLINE( 238)												r13 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float g13;
HXDLIN( 238)											int this62 = ((this59 >> 8) & 255);
HXDLIN( 238)											if ((this62 == 0)) {
HXLINE( 238)												g13 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float b14;
HXDLIN( 238)											int this63 = (this59 & 255);
HXDLIN( 238)											if ((this63 == 0)) {
HXLINE( 238)												b14 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												b14 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float a23;
HXDLIN( 238)											int this64 = ((col3 >> 24) & 255);
HXDLIN( 238)											if ((this64 == 0)) {
HXLINE( 238)												a23 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float r23;
HXDLIN( 238)											int this65 = ((col3 >> 16) & 255);
HXDLIN( 238)											if ((this65 == 0)) {
HXLINE( 238)												r23 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float g23;
HXDLIN( 238)											int this66 = ((col3 >> 8) & 255);
HXDLIN( 238)											if ((this66 == 0)) {
HXLINE( 238)												g23 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float b24;
HXDLIN( 238)											int this67 = (col3 & 255);
HXDLIN( 238)											if ((this67 == 0)) {
HXLINE( 238)												b24 = ((Float)0.);
            											}
            											else {
HXLINE( 238)												b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN( 238)											Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 238)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 238)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 238)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 238)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 238)											int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 238)											{
HXLINE( 238)												int _hx_tmp16;
HXDLIN( 238)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)													_hx_tmp16 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE( 238)													_hx_tmp16 = blended3;
            												}
HXDLIN( 238)												::iterMagic::Iimg_obj::set(pixelImage->image,location3,_hx_tmp16);
            											}
            										}
            										else {
HXLINE( 238)											::Dynamic this68 = pixelImage->image;
HXDLIN( 238)											int index11;
HXDLIN( 238)											if (pixelImage->useVirtualPos) {
HXLINE( 238)												index11 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px1) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 238)												index11 = ::Std_obj::_hx_int(( (Float)(((py1 * pixelImage->width) + px1)) ));
            											}
HXDLIN( 238)											int _hx_tmp17;
HXDLIN( 238)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 238)												_hx_tmp17 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE( 238)												_hx_tmp17 = c9;
            											}
HXDLIN( 238)											::iterMagic::Iimg_obj::set(this68,index11,_hx_tmp17);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 238)				if ((hasHit == false)) {
HXLINE( 238)					 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,y,leftX,topY,x,topY,true);
HXDLIN( 238)					if (hasUndo1) {
HXLINE( 238)						v7->undoImage = undoImage3;
HXDLIN( 238)						v7->undoX = xIter31->start;
HXDLIN( 238)						v7->undoY = yIter31->start;
            					}
            				}
            			}
HXDLIN( 238)			if ((hasHit == true)) {
HXLINE( 238)				 ::pi_xy::algo::HitQuad v8 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x,y,leftX,y,leftX,topY,x,topY,true);
            			}
            		}
HXLINE( 243)		au = bu;
HXLINE( 244)		bu = ((left + fat) * sw);
HXLINE( 245)		{
HXLINE( 245)			{
HXLINE( 245)				Float au3 = au;
HXDLIN( 245)				Float av3 = ((Float)0.);
HXDLIN( 245)				Float bu3 = bu;
HXDLIN( 245)				Float bv2 = ((Float)0.);
HXDLIN( 245)				bool hasUndo2 = false;
HXDLIN( 245)				Float temp2 = au3;
HXLINE( 422)				au3 = bu3;
HXLINE( 423)				bu3 = temp2;
HXLINE( 424)				temp2 = av3;
HXLINE( 425)				av3 = bv2;
HXLINE( 426)				bv2 = temp2;
HXLINE( 245)				Float bcx2 = (rightX - leftX);
HXDLIN( 245)				Float bcy2 = (y - topY);
HXDLIN( 245)				Float acx2 = (leftX - leftX);
HXDLIN( 245)				Float acy2 = (y - topY);
HXDLIN( 245)				Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN( 245)				Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN( 245)				Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN( 245)				Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN( 245)				 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 245)				if ((leftX > rightX)) {
HXLINE( 245)					if ((leftX > leftX)) {
HXLINE( 245)						int min8;
HXDLIN( 245)						if ((rightX > leftX)) {
HXLINE( 245)							min8 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 245)							min8 = ::Math_obj::floor(rightX);
            						}
HXDLIN( 245)						int ii_min16 = min8;
HXDLIN( 245)						int ii_max16 = ::Math_obj::ceil(leftX);
HXDLIN( 245)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            					}
            					else {
HXLINE( 245)						int ii_min17 = ::Math_obj::floor(rightX);
HXDLIN( 245)						int ii_max17 = ::Math_obj::ceil(leftX);
HXDLIN( 245)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            					}
            				}
            				else {
HXLINE( 245)					if ((rightX > leftX)) {
HXLINE( 245)						int min9;
HXDLIN( 245)						if ((leftX > leftX)) {
HXLINE( 245)							min9 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 245)							min9 = ::Math_obj::ceil(leftX);
            						}
HXDLIN( 245)						int ii_min18 = min9;
HXDLIN( 245)						int ii_max18 = ::Math_obj::ceil(rightX);
HXDLIN( 245)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXLINE( 245)						int ii_min19 = ::Math_obj::floor(leftX);
HXDLIN( 245)						int ii_max19 = ::Math_obj::ceil(leftX);
HXDLIN( 245)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
HXDLIN( 245)				 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 245)				if ((y > y)) {
HXLINE( 245)					if ((y > topY)) {
HXLINE( 245)						int min10;
HXDLIN( 245)						if ((y > topY)) {
HXLINE( 245)							min10 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 245)							min10 = ::Math_obj::floor(y);
            						}
HXDLIN( 245)						int ii_min20 = min10;
HXDLIN( 245)						int ii_max20 = ::Math_obj::ceil(y);
HXDLIN( 245)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXLINE( 245)						int ii_min21 = ::Math_obj::floor(y);
HXDLIN( 245)						int ii_max21 = ::Math_obj::ceil(topY);
HXDLIN( 245)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
            				else {
HXLINE( 245)					if ((y > topY)) {
HXLINE( 245)						int min11;
HXDLIN( 245)						if ((y > topY)) {
HXLINE( 245)							min11 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 245)							min11 = ::Math_obj::ceil(y);
            						}
HXDLIN( 245)						int ii_min22 = min11;
HXDLIN( 245)						int ii_max22 = ::Math_obj::ceil(y);
HXDLIN( 245)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXLINE( 245)						int ii_min23 = ::Math_obj::floor(y);
HXDLIN( 245)						int ii_max23 = ::Math_obj::ceil(topY);
HXDLIN( 245)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
HXDLIN( 245)				 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 245)				if (hasUndo2) {
HXLINE( 245)					int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 245)					int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 245)					 ::Dynamic imageType2 = null();
HXDLIN( 245)					 ::pi_xy::ImageStruct this69 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 245)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 245)					::Dynamic undoImage7;
HXDLIN( 245)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXLINE( 245)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::BytesImg b10 = byt2;
HXDLIN( 245)							{
HXLINE( 245)								b10->width = width2;
HXDLIN( 245)								b10->height = height2;
HXDLIN( 245)								b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 245)								b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN( 245)								{
HXLINE( 245)									int len4 = b10->length;
HXDLIN( 245)									int w2 = 0;
HXDLIN( 245)									{
HXLINE( 245)										int _g40 = 0;
HXDLIN( 245)										int _g41 = b10->height;
HXDLIN( 245)										while((_g40 < _g41)){
HXLINE( 245)											_g40 = (_g40 + 1);
HXDLIN( 245)											int y9 = (_g40 - 1);
HXDLIN( 245)											{
HXLINE( 245)												int _g42 = 0;
HXDLIN( 245)												int _g43 = b10->width;
HXDLIN( 245)												while((_g42 < _g43)){
HXLINE( 245)													_g42 = (_g42 + 1);
HXDLIN( 245)													int x9 = (_g42 - 1);
HXDLIN( 245)													{
HXLINE( 245)														w2 = (w2 + 1);
HXDLIN( 245)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 245)													{
HXLINE( 245)														w2 = (w2 + 1);
HXDLIN( 245)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 245)													{
HXLINE( 245)														w2 = (w2 + 1);
HXDLIN( 245)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 245)													{
HXLINE( 245)														w2 = (w2 + 1);
HXDLIN( 245)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 245)							undoImage7 = b10;
            						}
            						break;
            						case (int)1: {
HXLINE( 245)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::ArrIntImg a9 = arrI2;
HXDLIN( 245)							{
HXLINE( 245)								a9->width = width2;
HXDLIN( 245)								a9->height = height2;
HXDLIN( 245)								a9->data = ::Array_obj< int >::__new(0);
HXDLIN( 245)								a9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 245)								{
HXLINE( 245)									int _g44 = 0;
HXDLIN( 245)									int _g45 = a9->length;
HXDLIN( 245)									while((_g44 < _g45)){
HXLINE( 245)										_g44 = (_g44 + 1);
HXDLIN( 245)										int i12 = (_g44 - 1);
HXDLIN( 245)										a9->data[i12] = 0;
            									}
            								}
            							}
HXDLIN( 245)							undoImage7 = a9;
            						}
            						break;
            						case (int)2: {
HXLINE( 245)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::U32ArrImg b15 = u32a2;
HXDLIN( 245)							{
HXLINE( 245)								b15->width = width2;
HXDLIN( 245)								b15->height = height2;
HXDLIN( 245)								b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 245)								int size2 = (b15->length * 4);
HXDLIN( 245)								b15->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 245)								{
HXLINE( 245)									int _g46 = 0;
HXDLIN( 245)									int _g47 = b15->length;
HXDLIN( 245)									while((_g46 < _g47)){
HXLINE( 245)										_g46 = (_g46 + 1);
HXDLIN( 245)										int i13 = (_g46 - 1);
HXDLIN( 245)										{
HXLINE( 245)											 ::haxe::io::ArrayBufferViewImpl this70 = b15->data;
HXDLIN( 245)											bool undoImage8;
HXDLIN( 245)											if ((i13 >= 0)) {
HXLINE( 245)												undoImage8 = (i13 < (this70->byteLength >> 2));
            											}
            											else {
HXLINE( 245)												undoImage8 = false;
            											}
HXDLIN( 245)											if (undoImage8) {
HXLINE( 245)												 ::haxe::io::Bytes _this2 = this70->bytes;
HXDLIN( 245)												int pos2 = ((i13 << 2) + this70->byteOffset);
HXDLIN( 245)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 245)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 245)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 245)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 245)							undoImage7 = b15;
            						}
            						break;
            						case (int)3: {
HXLINE( 245)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::VecIntImg v9 = vec2;
HXDLIN( 245)							{
HXLINE( 245)								v9->width = width2;
HXDLIN( 245)								v9->height = height2;
HXDLIN( 245)								v9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 245)								v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN( 245)								{
HXLINE( 245)									int _g48 = 0;
HXDLIN( 245)									int _g49 = v9->length;
HXDLIN( 245)									while((_g48 < _g49)){
HXLINE( 245)										_g48 = (_g48 + 1);
HXDLIN( 245)										int i14 = (_g48 - 1);
HXDLIN( 245)										v9->data->__unsafe_set(i14,0);
            									}
            								}
            							}
HXDLIN( 245)							undoImage7 = v9;
            						}
            						break;
            						case (int)4: {
HXLINE( 245)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::StackIntImg b16 = sInt2;
HXDLIN( 245)							{
HXLINE( 245)								b16->width = width2;
HXDLIN( 245)								b16->height = height2;
HXDLIN( 245)								b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 245)								b16->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 245)								{
HXLINE( 245)									int len5 = b16->length;
HXDLIN( 245)									 ::haxe::ds::GenericStack_Int d2 = b16->data;
HXDLIN( 245)									if (::hx::IsNull( d2->head )) {
HXLINE( 245)										int _g50 = 0;
HXDLIN( 245)										int _g51 = len5;
HXDLIN( 245)										while((_g50 < _g51)){
HXLINE( 245)											_g50 = (_g50 + 1);
HXDLIN( 245)											int i15 = (_g50 - 1);
HXDLIN( 245)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXLINE( 245)										int _g52 = 0;
HXDLIN( 245)										int _g53 = len5;
HXDLIN( 245)										while((_g52 < _g53)){
HXLINE( 245)											_g52 = (_g52 + 1);
HXDLIN( 245)											int i16 = (_g52 - 1);
HXDLIN( 245)											{
HXLINE( 245)												 ::haxe::ds::GenericCell_Int l2 = b16->data->head;
HXDLIN( 245)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 245)												{
HXLINE( 245)													int _g54 = 0;
HXDLIN( 245)													int _g55 = i16;
HXDLIN( 245)													while((_g54 < _g55)){
HXLINE( 245)														_g54 = (_g54 + 1);
HXDLIN( 245)														int i17 = (_g54 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE( 245)												if (::hx::IsNull( prev2 )) {
HXLINE( 245)													b16->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 245)													l2 = null();
            												}
            												else {
HXLINE( 245)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 245)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 245)							undoImage7 = b16;
            						}
            						break;
            					}
HXDLIN( 245)					this69->image = undoImage7;
HXDLIN( 245)					this69->width = width2;
HXDLIN( 245)					this69->height = height2;
HXDLIN( 245)					this69->imageType = ( (int)(imageType2) );
HXDLIN( 245)					undoImage6 = this69;
HXDLIN( 245)					{
HXLINE( 245)						int rectLeft2 = xIter32->start;
HXDLIN( 245)						int rectTop2 = yIter32->start;
HXDLIN( 245)						int rectRight2 = xIter32->max;
HXDLIN( 245)						bool forceClear2 = false;
HXDLIN( 245)						{
HXLINE( 245)							int _g56 = rectTop2;
HXDLIN( 245)							int _g57 = yIter32->max;
HXDLIN( 245)							while((_g56 < _g57)){
HXLINE( 245)								_g56 = (_g56 + 1);
HXDLIN( 245)								int dy3 = (_g56 - 1);
HXDLIN( 245)								{
HXLINE( 245)									int _g58 = rectLeft2;
HXDLIN( 245)									int _g59 = rectRight2;
HXDLIN( 245)									while((_g58 < _g59)){
HXLINE( 245)										_g58 = (_g58 + 1);
HXDLIN( 245)										int dx3 = (_g58 - 1);
HXDLIN( 245)										::Dynamic this71 = pixelImage->image;
HXDLIN( 245)										int index12;
HXDLIN( 245)										if (pixelImage->useVirtualPos) {
HXLINE( 245)											index12 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx3) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 245)											index12 = ::Std_obj::_hx_int(( (Float)(((dy3 * pixelImage->width) + dx3)) ));
            										}
HXDLIN( 245)										int c10 = ::iterMagic::Iimg_obj::get(this71,index12);
HXDLIN( 245)										int col4;
HXDLIN( 245)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)											col4 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            										}
            										else {
HXLINE( 245)											col4 = c10;
            										}
HXDLIN( 245)										bool _hx_tmp18;
HXDLIN( 245)										if (pixelImage->useMask) {
HXLINE( 245)											_hx_tmp18 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 245)											_hx_tmp18 = false;
            										}
HXDLIN( 245)										if (_hx_tmp18) {
HXLINE( 245)											 ::pi_xy::ImageStruct this72 = pixelImage->mask;
HXDLIN( 245)											::Dynamic this73 = this72->image;
HXDLIN( 245)											int index13;
HXDLIN( 245)											if (this72->useVirtualPos) {
HXLINE( 245)												index13 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this72->virtualY) * ( (Float)(this72->width) )) + dx3) - this72->virtualX));
            											}
            											else {
HXLINE( 245)												index13 = ::Std_obj::_hx_int(( (Float)(((dy3 * this72->width) + dx3)) ));
            											}
HXDLIN( 245)											int c11 = ::iterMagic::Iimg_obj::get(this73,index13);
HXDLIN( 245)											int v10;
HXDLIN( 245)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)												v10 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            											}
            											else {
HXLINE( 245)												v10 = c11;
            											}
HXDLIN( 245)											int maskPixel2 = v10;
HXDLIN( 245)											int this74 = col4;
HXDLIN( 245)											if ((maskPixel2 == 0)) {
HXLINE( 245)												col4 = this74;
            											}
            											else {
HXLINE( 245)												Float m02;
HXDLIN( 245)												int this75 = ((maskPixel2 >> 24) & 255);
HXDLIN( 245)												if ((this75 == 0)) {
HXLINE( 245)													m02 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													m02 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float m12;
HXDLIN( 245)												int this76 = ((maskPixel2 >> 16) & 255);
HXDLIN( 245)												if ((this76 == 0)) {
HXLINE( 245)													m12 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													m12 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float m22;
HXDLIN( 245)												int this77 = ((maskPixel2 >> 8) & 255);
HXDLIN( 245)												if ((this77 == 0)) {
HXLINE( 245)													m22 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													m22 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float m32;
HXDLIN( 245)												int this78 = (maskPixel2 & 255);
HXDLIN( 245)												if ((this78 == 0)) {
HXLINE( 245)													m32 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													m32 = (( (Float)(this78) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this74 >> 24) & 255)) )));
HXDLIN( 245)												int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this74 >> 16) & 255)) )));
HXDLIN( 245)												int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this74 >> 8) & 255)) )));
HXDLIN( 245)												int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this74 & 255)) )));
HXDLIN( 245)												col4 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 245)										if ((col4 != 0)) {
HXLINE( 245)											int x10 = (dx3 - rectLeft2);
HXDLIN( 245)											int y10 = (dy3 - rectTop2);
HXDLIN( 245)											int c12 = col4;
HXDLIN( 245)											bool _hx_tmp19;
HXDLIN( 245)											if ((((c12 >> 24) & 255) < 254)) {
HXLINE( 245)												_hx_tmp19 = undoImage6->transparent;
            											}
            											else {
HXLINE( 245)												_hx_tmp19 = false;
            											}
HXDLIN( 245)											if (_hx_tmp19) {
HXLINE( 245)												int location4;
HXDLIN( 245)												if (undoImage6->useVirtualPos) {
HXLINE( 245)													location4 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            												}
            												else {
HXLINE( 245)													location4 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            												}
HXDLIN( 245)												int this79 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 245)												int this80;
HXDLIN( 245)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)													this80 = ((((((this79 >> 24) & 255) << 24) | ((this79 & 255) << 16)) | (((this79 >> 8) & 255) << 8)) | ((this79 >> 16) & 255));
            												}
            												else {
HXLINE( 245)													this80 = this79;
            												}
HXDLIN( 245)												Float a14;
HXDLIN( 245)												int this81 = ((this80 >> 24) & 255);
HXDLIN( 245)												if ((this81 == 0)) {
HXLINE( 245)													a14 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													a14 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float r14;
HXDLIN( 245)												int this82 = ((this80 >> 16) & 255);
HXDLIN( 245)												if ((this82 == 0)) {
HXLINE( 245)													r14 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													r14 = (( (Float)(this82) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float g14;
HXDLIN( 245)												int this83 = ((this80 >> 8) & 255);
HXDLIN( 245)												if ((this83 == 0)) {
HXLINE( 245)													g14 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													g14 = (( (Float)(this83) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float b17;
HXDLIN( 245)												int this84 = (this80 & 255);
HXDLIN( 245)												if ((this84 == 0)) {
HXLINE( 245)													b17 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													b17 = (( (Float)(this84) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float a24;
HXDLIN( 245)												int this85 = ((col4 >> 24) & 255);
HXDLIN( 245)												if ((this85 == 0)) {
HXLINE( 245)													a24 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													a24 = (( (Float)(this85) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float r24;
HXDLIN( 245)												int this86 = ((col4 >> 16) & 255);
HXDLIN( 245)												if ((this86 == 0)) {
HXLINE( 245)													r24 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													r24 = (( (Float)(this86) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float g24;
HXDLIN( 245)												int this87 = ((col4 >> 8) & 255);
HXDLIN( 245)												if ((this87 == 0)) {
HXLINE( 245)													g24 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													g24 = (( (Float)(this87) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float b25;
HXDLIN( 245)												int this88 = (col4 & 255);
HXDLIN( 245)												if ((this88 == 0)) {
HXLINE( 245)													b25 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													b25 = (( (Float)(this88) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 245)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 245)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 245)												int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a34) + (b25 * a24))));
HXDLIN( 245)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 245)												int blended4 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b18);
HXDLIN( 245)												{
HXLINE( 245)													int _hx_tmp20;
HXDLIN( 245)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)														_hx_tmp20 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXLINE( 245)														_hx_tmp20 = blended4;
            													}
HXDLIN( 245)													::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp20);
            												}
            											}
            											else {
HXLINE( 245)												::Dynamic this89 = undoImage6->image;
HXDLIN( 245)												int index14;
HXDLIN( 245)												if (undoImage6->useVirtualPos) {
HXLINE( 245)													index14 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            												}
            												else {
HXLINE( 245)													index14 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            												}
HXDLIN( 245)												int _hx_tmp21;
HXDLIN( 245)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)													_hx_tmp21 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            												}
            												else {
HXLINE( 245)													_hx_tmp21 = c12;
            												}
HXDLIN( 245)												::iterMagic::Iimg_obj::set(this89,index14,_hx_tmp21);
            											}
            										}
            										else {
HXLINE( 245)											if (forceClear2) {
HXLINE( 245)												::Dynamic this90 = undoImage6->image;
HXDLIN( 245)												int x11 = (dx3 - rectLeft2);
HXDLIN( 245)												int y11 = (dy3 - rectTop2);
HXDLIN( 245)												int index15;
HXDLIN( 245)												if (undoImage6->useVirtualPos) {
HXLINE( 245)													index15 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            												}
            												else {
HXLINE( 245)													index15 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x11)) ));
            												}
HXDLIN( 245)												::iterMagic::Iimg_obj::set(this90,index15,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 245)				{
HXLINE( 245)					int _g_min4 = xIter32->start;
HXDLIN( 245)					int _g_max4 = xIter32->max;
HXDLIN( 245)					while((_g_min4 < _g_max4)){
HXLINE( 245)						_g_min4 = (_g_min4 + 1);
HXDLIN( 245)						int px2 = (_g_min4 - 1);
HXDLIN( 245)						Float pcx2 = (( (Float)(px2) ) - leftX);
HXDLIN( 245)						{
HXLINE( 245)							int _g_min5 = yIter32->start;
HXDLIN( 245)							int _g_max5 = yIter32->max;
HXDLIN( 245)							while((_g_min5 < _g_max5)){
HXLINE( 245)								_g_min5 = (_g_min5 + 1);
HXDLIN( 245)								int py2 = (_g_min5 - 1);
HXDLIN( 245)								Float pcy2 = (( (Float)(py2) ) - topY);
HXDLIN( 245)								Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN( 245)								Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN( 245)								Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN( 245)								Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN( 245)								Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN( 245)								bool _hx_tmp22;
HXDLIN( 245)								bool _hx_tmp23;
HXDLIN( 245)								if ((ratioA2 >= 0)) {
HXLINE( 245)									_hx_tmp23 = (ratioB2 >= 0);
            								}
            								else {
HXLINE( 245)									_hx_tmp23 = false;
            								}
HXDLIN( 245)								if (_hx_tmp23) {
HXLINE( 245)									_hx_tmp22 = (ratioC2 >= 0);
            								}
            								else {
HXLINE( 245)									_hx_tmp22 = false;
            								}
HXDLIN( 245)								if (_hx_tmp22) {
HXLINE( 245)									Float u2 = (((au3 * ratioA2) + (bu3 * ratioB2)) + (au * ratioC2));
HXDLIN( 245)									Float v11 = (((av3 * ratioA2) + (bv2 * ratioB2)) + (cv * ratioC2));
HXDLIN( 245)									int x12 = ::Std_obj::_hx_int(((u2 * win->width) + win->x));
HXDLIN( 245)									int y12 = ::Std_obj::_hx_int(((v11 * win->height) + win->y));
HXDLIN( 245)									::Dynamic this91 = texture->image;
HXDLIN( 245)									int index16;
HXDLIN( 245)									if (texture->useVirtualPos) {
HXLINE( 245)										index16 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - texture->virtualY) * ( (Float)(texture->width) )) + x12) - texture->virtualX));
            									}
            									else {
HXLINE( 245)										index16 = ::Std_obj::_hx_int(( (Float)(((y12 * texture->width) + x12)) ));
            									}
HXDLIN( 245)									int c13 = ::iterMagic::Iimg_obj::get(this91,index16);
HXDLIN( 245)									int col5;
HXDLIN( 245)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)										col5 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            									}
            									else {
HXLINE( 245)										col5 = c13;
            									}
HXDLIN( 245)									{
HXLINE( 245)										int c14 = col5;
HXDLIN( 245)										bool _hx_tmp24;
HXDLIN( 245)										if ((((c14 >> 24) & 255) < 254)) {
HXLINE( 245)											_hx_tmp24 = pixelImage->transparent;
            										}
            										else {
HXLINE( 245)											_hx_tmp24 = false;
            										}
HXDLIN( 245)										if (_hx_tmp24) {
HXLINE( 245)											int location5;
HXDLIN( 245)											if (pixelImage->useVirtualPos) {
HXLINE( 245)												location5 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 245)												location5 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            											}
HXDLIN( 245)											int this92 = ::iterMagic::Iimg_obj::get(pixelImage->image,location5);
HXDLIN( 245)											int this93;
HXDLIN( 245)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)												this93 = ((((((this92 >> 24) & 255) << 24) | ((this92 & 255) << 16)) | (((this92 >> 8) & 255) << 8)) | ((this92 >> 16) & 255));
            											}
            											else {
HXLINE( 245)												this93 = this92;
            											}
HXDLIN( 245)											Float a15;
HXDLIN( 245)											int this94 = ((this93 >> 24) & 255);
HXDLIN( 245)											if ((this94 == 0)) {
HXLINE( 245)												a15 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												a15 = (( (Float)(this94) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float r15;
HXDLIN( 245)											int this95 = ((this93 >> 16) & 255);
HXDLIN( 245)											if ((this95 == 0)) {
HXLINE( 245)												r15 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												r15 = (( (Float)(this95) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float g15;
HXDLIN( 245)											int this96 = ((this93 >> 8) & 255);
HXDLIN( 245)											if ((this96 == 0)) {
HXLINE( 245)												g15 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												g15 = (( (Float)(this96) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float b19;
HXDLIN( 245)											int this97 = (this93 & 255);
HXDLIN( 245)											if ((this97 == 0)) {
HXLINE( 245)												b19 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												b19 = (( (Float)(this97) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float a25;
HXDLIN( 245)											int this98 = ((col5 >> 24) & 255);
HXDLIN( 245)											if ((this98 == 0)) {
HXLINE( 245)												a25 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												a25 = (( (Float)(this98) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float r25;
HXDLIN( 245)											int this99 = ((col5 >> 16) & 255);
HXDLIN( 245)											if ((this99 == 0)) {
HXLINE( 245)												r25 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												r25 = (( (Float)(this99) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float g25;
HXDLIN( 245)											int this100 = ((col5 >> 8) & 255);
HXDLIN( 245)											if ((this100 == 0)) {
HXLINE( 245)												g25 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												g25 = (( (Float)(this100) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float b26;
HXDLIN( 245)											int this101 = (col5 & 255);
HXDLIN( 245)											if ((this101 == 0)) {
HXLINE( 245)												b26 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												b26 = (( (Float)(this101) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 245)											int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 245)											int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 245)											int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a35) + (b26 * a25))));
HXDLIN( 245)											int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 245)											int blended5 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b20);
HXDLIN( 245)											{
HXLINE( 245)												int _hx_tmp25;
HXDLIN( 245)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)													_hx_tmp25 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            												}
            												else {
HXLINE( 245)													_hx_tmp25 = blended5;
            												}
HXDLIN( 245)												::iterMagic::Iimg_obj::set(pixelImage->image,location5,_hx_tmp25);
            											}
            										}
            										else {
HXLINE( 245)											::Dynamic this102 = pixelImage->image;
HXDLIN( 245)											int index17;
HXDLIN( 245)											if (pixelImage->useVirtualPos) {
HXLINE( 245)												index17 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px2) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 245)												index17 = ::Std_obj::_hx_int(( (Float)(((py2 * pixelImage->width) + px2)) ));
            											}
HXDLIN( 245)											int _hx_tmp26;
HXDLIN( 245)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)												_hx_tmp26 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            											}
            											else {
HXLINE( 245)												_hx_tmp26 = c14;
            											}
HXDLIN( 245)											::iterMagic::Iimg_obj::set(this102,index17,_hx_tmp26);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 245)				if ((hasHit == false)) {
HXLINE( 245)					 ::pi_xy::algo::HitTri v12 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,y,rightX,y,leftX,topY,true);
HXDLIN( 245)					if (hasUndo2) {
HXLINE( 245)						v12->undoImage = undoImage6;
HXDLIN( 245)						v12->undoX = xIter32->start;
HXDLIN( 245)						v12->undoY = yIter32->start;
            					}
            				}
            			}
HXDLIN( 245)			{
HXLINE( 245)				Float au4 = bu;
HXDLIN( 245)				Float av4 = ((Float)0.);
HXDLIN( 245)				Float bu4 = bu;
HXDLIN( 245)				Float bv3 = cv;
HXDLIN( 245)				bool hasUndo3 = false;
HXDLIN( 245)				Float temp3 = au4;
HXLINE( 422)				au4 = bu4;
HXLINE( 423)				bu4 = temp3;
HXLINE( 424)				temp3 = av4;
HXLINE( 425)				av4 = bv3;
HXLINE( 426)				bv3 = temp3;
HXLINE( 245)				Float bcx3 = (rightX - leftX);
HXDLIN( 245)				Float bcy3 = (topY - topY);
HXDLIN( 245)				Float acx3 = (rightX - leftX);
HXDLIN( 245)				Float acy3 = (y - topY);
HXDLIN( 245)				Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN( 245)				Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN( 245)				Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN( 245)				Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN( 245)				 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 245)				if ((rightX > rightX)) {
HXLINE( 245)					if ((rightX > leftX)) {
HXLINE( 245)						int min12;
HXDLIN( 245)						if ((rightX > leftX)) {
HXLINE( 245)							min12 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 245)							min12 = ::Math_obj::floor(rightX);
            						}
HXDLIN( 245)						int ii_min24 = min12;
HXDLIN( 245)						int ii_max24 = ::Math_obj::ceil(rightX);
HXDLIN( 245)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            					}
            					else {
HXLINE( 245)						int ii_min25 = ::Math_obj::floor(rightX);
HXDLIN( 245)						int ii_max25 = ::Math_obj::ceil(leftX);
HXDLIN( 245)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            					}
            				}
            				else {
HXLINE( 245)					if ((rightX > leftX)) {
HXLINE( 245)						int min13;
HXDLIN( 245)						if ((rightX > leftX)) {
HXLINE( 245)							min13 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 245)							min13 = ::Math_obj::ceil(rightX);
            						}
HXDLIN( 245)						int ii_min26 = min13;
HXDLIN( 245)						int ii_max26 = ::Math_obj::ceil(rightX);
HXDLIN( 245)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            					}
            					else {
HXLINE( 245)						int ii_min27 = ::Math_obj::floor(rightX);
HXDLIN( 245)						int ii_max27 = ::Math_obj::ceil(leftX);
HXDLIN( 245)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            					}
            				}
HXDLIN( 245)				 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 245)				if ((y > topY)) {
HXLINE( 245)					if ((y > topY)) {
HXLINE( 245)						int min14;
HXDLIN( 245)						if ((topY > topY)) {
HXLINE( 245)							min14 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 245)							min14 = ::Math_obj::floor(topY);
            						}
HXDLIN( 245)						int ii_min28 = min14;
HXDLIN( 245)						int ii_max28 = ::Math_obj::ceil(y);
HXDLIN( 245)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            					}
            					else {
HXLINE( 245)						int ii_min29 = ::Math_obj::floor(topY);
HXDLIN( 245)						int ii_max29 = ::Math_obj::ceil(topY);
HXDLIN( 245)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            					}
            				}
            				else {
HXLINE( 245)					if ((topY > topY)) {
HXLINE( 245)						int min15;
HXDLIN( 245)						if ((y > topY)) {
HXLINE( 245)							min15 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 245)							min15 = ::Math_obj::ceil(y);
            						}
HXDLIN( 245)						int ii_min30 = min15;
HXDLIN( 245)						int ii_max30 = ::Math_obj::ceil(topY);
HXDLIN( 245)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            					}
            					else {
HXLINE( 245)						int ii_min31 = ::Math_obj::floor(y);
HXDLIN( 245)						int ii_max31 = ::Math_obj::ceil(topY);
HXDLIN( 245)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            					}
            				}
HXDLIN( 245)				 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 245)				if (hasUndo3) {
HXLINE( 245)					int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 245)					int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 245)					 ::Dynamic imageType3 = null();
HXDLIN( 245)					 ::pi_xy::ImageStruct this103 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 245)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 245)					::Dynamic undoImage10;
HXDLIN( 245)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXLINE( 245)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::BytesImg b27 = byt3;
HXDLIN( 245)							{
HXLINE( 245)								b27->width = width3;
HXDLIN( 245)								b27->height = height3;
HXDLIN( 245)								b27->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 245)								b27->data = ::haxe::io::Bytes_obj::alloc((b27->length * 4));
HXDLIN( 245)								{
HXLINE( 245)									int len6 = b27->length;
HXDLIN( 245)									int w3 = 0;
HXDLIN( 245)									{
HXLINE( 245)										int _g60 = 0;
HXDLIN( 245)										int _g61 = b27->height;
HXDLIN( 245)										while((_g60 < _g61)){
HXLINE( 245)											_g60 = (_g60 + 1);
HXDLIN( 245)											int y13 = (_g60 - 1);
HXDLIN( 245)											{
HXLINE( 245)												int _g62 = 0;
HXDLIN( 245)												int _g63 = b27->width;
HXDLIN( 245)												while((_g62 < _g63)){
HXLINE( 245)													_g62 = (_g62 + 1);
HXDLIN( 245)													int x13 = (_g62 - 1);
HXDLIN( 245)													{
HXLINE( 245)														w3 = (w3 + 1);
HXDLIN( 245)														b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 245)													{
HXLINE( 245)														w3 = (w3 + 1);
HXDLIN( 245)														b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 245)													{
HXLINE( 245)														w3 = (w3 + 1);
HXDLIN( 245)														b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 245)													{
HXLINE( 245)														w3 = (w3 + 1);
HXDLIN( 245)														b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 245)							undoImage10 = b27;
            						}
            						break;
            						case (int)1: {
HXLINE( 245)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::ArrIntImg a17 = arrI3;
HXDLIN( 245)							{
HXLINE( 245)								a17->width = width3;
HXDLIN( 245)								a17->height = height3;
HXDLIN( 245)								a17->data = ::Array_obj< int >::__new(0);
HXDLIN( 245)								a17->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 245)								{
HXLINE( 245)									int _g64 = 0;
HXDLIN( 245)									int _g65 = a17->length;
HXDLIN( 245)									while((_g64 < _g65)){
HXLINE( 245)										_g64 = (_g64 + 1);
HXDLIN( 245)										int i18 = (_g64 - 1);
HXDLIN( 245)										a17->data[i18] = 0;
            									}
            								}
            							}
HXDLIN( 245)							undoImage10 = a17;
            						}
            						break;
            						case (int)2: {
HXLINE( 245)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::U32ArrImg b28 = u32a3;
HXDLIN( 245)							{
HXLINE( 245)								b28->width = width3;
HXDLIN( 245)								b28->height = height3;
HXDLIN( 245)								b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 245)								int size3 = (b28->length * 4);
HXDLIN( 245)								b28->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 245)								{
HXLINE( 245)									int _g66 = 0;
HXDLIN( 245)									int _g67 = b28->length;
HXDLIN( 245)									while((_g66 < _g67)){
HXLINE( 245)										_g66 = (_g66 + 1);
HXDLIN( 245)										int i19 = (_g66 - 1);
HXDLIN( 245)										{
HXLINE( 245)											 ::haxe::io::ArrayBufferViewImpl this104 = b28->data;
HXDLIN( 245)											bool undoImage11;
HXDLIN( 245)											if ((i19 >= 0)) {
HXLINE( 245)												undoImage11 = (i19 < (this104->byteLength >> 2));
            											}
            											else {
HXLINE( 245)												undoImage11 = false;
            											}
HXDLIN( 245)											if (undoImage11) {
HXLINE( 245)												 ::haxe::io::Bytes _this3 = this104->bytes;
HXDLIN( 245)												int pos3 = ((i19 << 2) + this104->byteOffset);
HXDLIN( 245)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 245)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 245)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 245)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 245)							undoImage10 = b28;
            						}
            						break;
            						case (int)3: {
HXLINE( 245)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::VecIntImg v13 = vec3;
HXDLIN( 245)							{
HXLINE( 245)								v13->width = width3;
HXDLIN( 245)								v13->height = height3;
HXDLIN( 245)								v13->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 245)								v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN( 245)								{
HXLINE( 245)									int _g68 = 0;
HXDLIN( 245)									int _g69 = v13->length;
HXDLIN( 245)									while((_g68 < _g69)){
HXLINE( 245)										_g68 = (_g68 + 1);
HXDLIN( 245)										int i20 = (_g68 - 1);
HXDLIN( 245)										v13->data->__unsafe_set(i20,0);
            									}
            								}
            							}
HXDLIN( 245)							undoImage10 = v13;
            						}
            						break;
            						case (int)4: {
HXLINE( 245)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 245)							 ::iterMagic::StackIntImg b29 = sInt3;
HXDLIN( 245)							{
HXLINE( 245)								b29->width = width3;
HXDLIN( 245)								b29->height = height3;
HXDLIN( 245)								b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 245)								b29->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 245)								{
HXLINE( 245)									int len7 = b29->length;
HXDLIN( 245)									 ::haxe::ds::GenericStack_Int d3 = b29->data;
HXDLIN( 245)									if (::hx::IsNull( d3->head )) {
HXLINE( 245)										int _g70 = 0;
HXDLIN( 245)										int _g71 = len7;
HXDLIN( 245)										while((_g70 < _g71)){
HXLINE( 245)											_g70 = (_g70 + 1);
HXDLIN( 245)											int i21 = (_g70 - 1);
HXDLIN( 245)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXLINE( 245)										int _g72 = 0;
HXDLIN( 245)										int _g73 = len7;
HXDLIN( 245)										while((_g72 < _g73)){
HXLINE( 245)											_g72 = (_g72 + 1);
HXDLIN( 245)											int i22 = (_g72 - 1);
HXDLIN( 245)											{
HXLINE( 245)												 ::haxe::ds::GenericCell_Int l3 = b29->data->head;
HXDLIN( 245)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 245)												{
HXLINE( 245)													int _g74 = 0;
HXDLIN( 245)													int _g75 = i22;
HXDLIN( 245)													while((_g74 < _g75)){
HXLINE( 245)														_g74 = (_g74 + 1);
HXDLIN( 245)														int i23 = (_g74 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE( 245)												if (::hx::IsNull( prev3 )) {
HXLINE( 245)													b29->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 245)													l3 = null();
            												}
            												else {
HXLINE( 245)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 245)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 245)							undoImage10 = b29;
            						}
            						break;
            					}
HXDLIN( 245)					this103->image = undoImage10;
HXDLIN( 245)					this103->width = width3;
HXDLIN( 245)					this103->height = height3;
HXDLIN( 245)					this103->imageType = ( (int)(imageType3) );
HXDLIN( 245)					undoImage9 = this103;
HXDLIN( 245)					{
HXLINE( 245)						int rectLeft3 = xIter33->start;
HXDLIN( 245)						int rectTop3 = yIter33->start;
HXDLIN( 245)						int rectRight3 = xIter33->max;
HXDLIN( 245)						bool forceClear3 = false;
HXDLIN( 245)						{
HXLINE( 245)							int _g76 = rectTop3;
HXDLIN( 245)							int _g77 = yIter33->max;
HXDLIN( 245)							while((_g76 < _g77)){
HXLINE( 245)								_g76 = (_g76 + 1);
HXDLIN( 245)								int dy4 = (_g76 - 1);
HXDLIN( 245)								{
HXLINE( 245)									int _g78 = rectLeft3;
HXDLIN( 245)									int _g79 = rectRight3;
HXDLIN( 245)									while((_g78 < _g79)){
HXLINE( 245)										_g78 = (_g78 + 1);
HXDLIN( 245)										int dx4 = (_g78 - 1);
HXDLIN( 245)										::Dynamic this105 = pixelImage->image;
HXDLIN( 245)										int index18;
HXDLIN( 245)										if (pixelImage->useVirtualPos) {
HXLINE( 245)											index18 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx4) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 245)											index18 = ::Std_obj::_hx_int(( (Float)(((dy4 * pixelImage->width) + dx4)) ));
            										}
HXDLIN( 245)										int c15 = ::iterMagic::Iimg_obj::get(this105,index18);
HXDLIN( 245)										int col6;
HXDLIN( 245)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)											col6 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXLINE( 245)											col6 = c15;
            										}
HXDLIN( 245)										bool _hx_tmp27;
HXDLIN( 245)										if (pixelImage->useMask) {
HXLINE( 245)											_hx_tmp27 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 245)											_hx_tmp27 = false;
            										}
HXDLIN( 245)										if (_hx_tmp27) {
HXLINE( 245)											 ::pi_xy::ImageStruct this106 = pixelImage->mask;
HXDLIN( 245)											::Dynamic this107 = this106->image;
HXDLIN( 245)											int index19;
HXDLIN( 245)											if (this106->useVirtualPos) {
HXLINE( 245)												index19 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this106->virtualY) * ( (Float)(this106->width) )) + dx4) - this106->virtualX));
            											}
            											else {
HXLINE( 245)												index19 = ::Std_obj::_hx_int(( (Float)(((dy4 * this106->width) + dx4)) ));
            											}
HXDLIN( 245)											int c16 = ::iterMagic::Iimg_obj::get(this107,index19);
HXDLIN( 245)											int v14;
HXDLIN( 245)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)												v14 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            											}
            											else {
HXLINE( 245)												v14 = c16;
            											}
HXDLIN( 245)											int maskPixel3 = v14;
HXDLIN( 245)											int this108 = col6;
HXDLIN( 245)											if ((maskPixel3 == 0)) {
HXLINE( 245)												col6 = this108;
            											}
            											else {
HXLINE( 245)												Float m03;
HXDLIN( 245)												int this109 = ((maskPixel3 >> 24) & 255);
HXDLIN( 245)												if ((this109 == 0)) {
HXLINE( 245)													m03 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													m03 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float m13;
HXDLIN( 245)												int this110 = ((maskPixel3 >> 16) & 255);
HXDLIN( 245)												if ((this110 == 0)) {
HXLINE( 245)													m13 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													m13 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float m23;
HXDLIN( 245)												int this111 = ((maskPixel3 >> 8) & 255);
HXDLIN( 245)												if ((this111 == 0)) {
HXLINE( 245)													m23 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													m23 = (( (Float)(this111) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float m33;
HXDLIN( 245)												int this112 = (maskPixel3 & 255);
HXDLIN( 245)												if ((this112 == 0)) {
HXLINE( 245)													m33 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													m33 = (( (Float)(this112) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this108 >> 24) & 255)) )));
HXDLIN( 245)												int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this108 >> 16) & 255)) )));
HXDLIN( 245)												int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this108 >> 8) & 255)) )));
HXDLIN( 245)												int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this108 & 255)) )));
HXDLIN( 245)												col6 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 245)										if ((col6 != 0)) {
HXLINE( 245)											int x14 = (dx4 - rectLeft3);
HXDLIN( 245)											int y14 = (dy4 - rectTop3);
HXDLIN( 245)											int c17 = col6;
HXDLIN( 245)											bool _hx_tmp28;
HXDLIN( 245)											if ((((c17 >> 24) & 255) < 254)) {
HXLINE( 245)												_hx_tmp28 = undoImage9->transparent;
            											}
            											else {
HXLINE( 245)												_hx_tmp28 = false;
            											}
HXDLIN( 245)											if (_hx_tmp28) {
HXLINE( 245)												int location6;
HXDLIN( 245)												if (undoImage9->useVirtualPos) {
HXLINE( 245)													location6 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 245)													location6 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            												}
HXDLIN( 245)												int this113 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 245)												int this114;
HXDLIN( 245)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)													this114 = ((((((this113 >> 24) & 255) << 24) | ((this113 & 255) << 16)) | (((this113 >> 8) & 255) << 8)) | ((this113 >> 16) & 255));
            												}
            												else {
HXLINE( 245)													this114 = this113;
            												}
HXDLIN( 245)												Float a18;
HXDLIN( 245)												int this115 = ((this114 >> 24) & 255);
HXDLIN( 245)												if ((this115 == 0)) {
HXLINE( 245)													a18 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													a18 = (( (Float)(this115) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float r16;
HXDLIN( 245)												int this116 = ((this114 >> 16) & 255);
HXDLIN( 245)												if ((this116 == 0)) {
HXLINE( 245)													r16 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													r16 = (( (Float)(this116) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float g16;
HXDLIN( 245)												int this117 = ((this114 >> 8) & 255);
HXDLIN( 245)												if ((this117 == 0)) {
HXLINE( 245)													g16 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													g16 = (( (Float)(this117) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float b110;
HXDLIN( 245)												int this118 = (this114 & 255);
HXDLIN( 245)												if ((this118 == 0)) {
HXLINE( 245)													b110 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													b110 = (( (Float)(this118) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float a26;
HXDLIN( 245)												int this119 = ((col6 >> 24) & 255);
HXDLIN( 245)												if ((this119 == 0)) {
HXLINE( 245)													a26 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													a26 = (( (Float)(this119) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float r26;
HXDLIN( 245)												int this120 = ((col6 >> 16) & 255);
HXDLIN( 245)												if ((this120 == 0)) {
HXLINE( 245)													r26 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													r26 = (( (Float)(this120) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float g26;
HXDLIN( 245)												int this121 = ((col6 >> 8) & 255);
HXDLIN( 245)												if ((this121 == 0)) {
HXLINE( 245)													g26 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													g26 = (( (Float)(this121) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float b210;
HXDLIN( 245)												int this122 = (col6 & 255);
HXDLIN( 245)												if ((this122 == 0)) {
HXLINE( 245)													b210 = ((Float)0.);
            												}
            												else {
HXLINE( 245)													b210 = (( (Float)(this122) ) / ( (Float)(255) ));
            												}
HXDLIN( 245)												Float a36 = (a18 * (( (Float)(1) ) - a26));
HXDLIN( 245)												int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 245)												int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 245)												int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b210 * a26))));
HXDLIN( 245)												int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 245)												int blended6 = ((((a19 << 24) | (r8 << 16)) | (g8 << 8)) | b30);
HXDLIN( 245)												{
HXLINE( 245)													int _hx_tmp29;
HXDLIN( 245)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)														_hx_tmp29 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXLINE( 245)														_hx_tmp29 = blended6;
            													}
HXDLIN( 245)													::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp29);
            												}
            											}
            											else {
HXLINE( 245)												::Dynamic this123 = undoImage9->image;
HXDLIN( 245)												int index20;
HXDLIN( 245)												if (undoImage9->useVirtualPos) {
HXLINE( 245)													index20 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 245)													index20 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            												}
HXDLIN( 245)												int _hx_tmp30;
HXDLIN( 245)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)													_hx_tmp30 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            												}
            												else {
HXLINE( 245)													_hx_tmp30 = c17;
            												}
HXDLIN( 245)												::iterMagic::Iimg_obj::set(this123,index20,_hx_tmp30);
            											}
            										}
            										else {
HXLINE( 245)											if (forceClear3) {
HXLINE( 245)												::Dynamic this124 = undoImage9->image;
HXDLIN( 245)												int x15 = (dx4 - rectLeft3);
HXDLIN( 245)												int y15 = (dy4 - rectTop3);
HXDLIN( 245)												int index21;
HXDLIN( 245)												if (undoImage9->useVirtualPos) {
HXLINE( 245)													index21 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            												}
            												else {
HXLINE( 245)													index21 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x15)) ));
            												}
HXDLIN( 245)												::iterMagic::Iimg_obj::set(this124,index21,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 245)				{
HXLINE( 245)					int _g_min6 = xIter33->start;
HXDLIN( 245)					int _g_max6 = xIter33->max;
HXDLIN( 245)					while((_g_min6 < _g_max6)){
HXLINE( 245)						_g_min6 = (_g_min6 + 1);
HXDLIN( 245)						int px3 = (_g_min6 - 1);
HXDLIN( 245)						Float pcx3 = (( (Float)(px3) ) - leftX);
HXDLIN( 245)						{
HXLINE( 245)							int _g_min7 = yIter33->start;
HXDLIN( 245)							int _g_max7 = yIter33->max;
HXDLIN( 245)							while((_g_min7 < _g_max7)){
HXLINE( 245)								_g_min7 = (_g_min7 + 1);
HXDLIN( 245)								int py3 = (_g_min7 - 1);
HXDLIN( 245)								Float pcy3 = (( (Float)(py3) ) - topY);
HXDLIN( 245)								Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN( 245)								Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN( 245)								Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN( 245)								Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN( 245)								Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN( 245)								bool _hx_tmp31;
HXDLIN( 245)								bool _hx_tmp32;
HXDLIN( 245)								if ((ratioA3 >= 0)) {
HXLINE( 245)									_hx_tmp32 = (ratioB3 >= 0);
            								}
            								else {
HXLINE( 245)									_hx_tmp32 = false;
            								}
HXDLIN( 245)								if (_hx_tmp32) {
HXLINE( 245)									_hx_tmp31 = (ratioC3 >= 0);
            								}
            								else {
HXLINE( 245)									_hx_tmp31 = false;
            								}
HXDLIN( 245)								if (_hx_tmp31) {
HXLINE( 245)									Float u3 = (((au4 * ratioA3) + (bu4 * ratioB3)) + (au * ratioC3));
HXDLIN( 245)									Float v15 = (((av4 * ratioA3) + (bv3 * ratioB3)) + (cv * ratioC3));
HXDLIN( 245)									int x16 = ::Std_obj::_hx_int(((u3 * win->width) + win->x));
HXDLIN( 245)									int y16 = ::Std_obj::_hx_int(((v15 * win->height) + win->y));
HXDLIN( 245)									::Dynamic this125 = texture->image;
HXDLIN( 245)									int index22;
HXDLIN( 245)									if (texture->useVirtualPos) {
HXLINE( 245)										index22 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - texture->virtualY) * ( (Float)(texture->width) )) + x16) - texture->virtualX));
            									}
            									else {
HXLINE( 245)										index22 = ::Std_obj::_hx_int(( (Float)(((y16 * texture->width) + x16)) ));
            									}
HXDLIN( 245)									int c18 = ::iterMagic::Iimg_obj::get(this125,index22);
HXDLIN( 245)									int col7;
HXDLIN( 245)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)										col7 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            									}
            									else {
HXLINE( 245)										col7 = c18;
            									}
HXDLIN( 245)									{
HXLINE( 245)										int c19 = col7;
HXDLIN( 245)										bool _hx_tmp33;
HXDLIN( 245)										if ((((c19 >> 24) & 255) < 254)) {
HXLINE( 245)											_hx_tmp33 = pixelImage->transparent;
            										}
            										else {
HXLINE( 245)											_hx_tmp33 = false;
            										}
HXDLIN( 245)										if (_hx_tmp33) {
HXLINE( 245)											int location7;
HXDLIN( 245)											if (pixelImage->useVirtualPos) {
HXLINE( 245)												location7 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 245)												location7 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            											}
HXDLIN( 245)											int this126 = ::iterMagic::Iimg_obj::get(pixelImage->image,location7);
HXDLIN( 245)											int this127;
HXDLIN( 245)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)												this127 = ((((((this126 >> 24) & 255) << 24) | ((this126 & 255) << 16)) | (((this126 >> 8) & 255) << 8)) | ((this126 >> 16) & 255));
            											}
            											else {
HXLINE( 245)												this127 = this126;
            											}
HXDLIN( 245)											Float a110;
HXDLIN( 245)											int this128 = ((this127 >> 24) & 255);
HXDLIN( 245)											if ((this128 == 0)) {
HXLINE( 245)												a110 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												a110 = (( (Float)(this128) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float r17;
HXDLIN( 245)											int this129 = ((this127 >> 16) & 255);
HXDLIN( 245)											if ((this129 == 0)) {
HXLINE( 245)												r17 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												r17 = (( (Float)(this129) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float g17;
HXDLIN( 245)											int this130 = ((this127 >> 8) & 255);
HXDLIN( 245)											if ((this130 == 0)) {
HXLINE( 245)												g17 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												g17 = (( (Float)(this130) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float b111;
HXDLIN( 245)											int this131 = (this127 & 255);
HXDLIN( 245)											if ((this131 == 0)) {
HXLINE( 245)												b111 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												b111 = (( (Float)(this131) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float a27;
HXDLIN( 245)											int this132 = ((col7 >> 24) & 255);
HXDLIN( 245)											if ((this132 == 0)) {
HXLINE( 245)												a27 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												a27 = (( (Float)(this132) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float r27;
HXDLIN( 245)											int this133 = ((col7 >> 16) & 255);
HXDLIN( 245)											if ((this133 == 0)) {
HXLINE( 245)												r27 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												r27 = (( (Float)(this133) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float g27;
HXDLIN( 245)											int this134 = ((col7 >> 8) & 255);
HXDLIN( 245)											if ((this134 == 0)) {
HXLINE( 245)												g27 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												g27 = (( (Float)(this134) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float b211;
HXDLIN( 245)											int this135 = (col7 & 255);
HXDLIN( 245)											if ((this135 == 0)) {
HXLINE( 245)												b211 = ((Float)0.);
            											}
            											else {
HXLINE( 245)												b211 = (( (Float)(this135) ) / ( (Float)(255) ));
            											}
HXDLIN( 245)											Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN( 245)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 245)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 245)											int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b211 * a27))));
HXDLIN( 245)											int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 245)											int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b31);
HXDLIN( 245)											{
HXLINE( 245)												int _hx_tmp34;
HXDLIN( 245)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)													_hx_tmp34 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            												}
            												else {
HXLINE( 245)													_hx_tmp34 = blended7;
            												}
HXDLIN( 245)												::iterMagic::Iimg_obj::set(pixelImage->image,location7,_hx_tmp34);
            											}
            										}
            										else {
HXLINE( 245)											::Dynamic this136 = pixelImage->image;
HXDLIN( 245)											int index23;
HXDLIN( 245)											if (pixelImage->useVirtualPos) {
HXLINE( 245)												index23 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px3) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 245)												index23 = ::Std_obj::_hx_int(( (Float)(((py3 * pixelImage->width) + px3)) ));
            											}
HXDLIN( 245)											int _hx_tmp35;
HXDLIN( 245)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 245)												_hx_tmp35 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            											}
            											else {
HXLINE( 245)												_hx_tmp35 = c19;
            											}
HXDLIN( 245)											::iterMagic::Iimg_obj::set(this136,index23,_hx_tmp35);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 245)				if ((hasHit == false)) {
HXLINE( 245)					 ::pi_xy::algo::HitTri v16 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,y,rightX,topY,leftX,topY,true);
HXDLIN( 245)					if (hasUndo3) {
HXLINE( 245)						v16->undoImage = undoImage9;
HXDLIN( 245)						v16->undoX = xIter33->start;
HXDLIN( 245)						v16->undoY = yIter33->start;
            					}
            				}
            			}
HXDLIN( 245)			if ((hasHit == true)) {
HXLINE( 245)				 ::pi_xy::algo::HitQuad v17 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,leftX,y,rightX,y,rightX,topY,leftX,topY,true);
            			}
            		}
HXLINE( 250)		au = bu;
HXLINE( 251)		bu = ((Float)1.);
HXLINE( 252)		{
HXLINE( 252)			Float bx1 = (x + widNew);
HXDLIN( 252)			Float cx1 = (x + widNew);
HXDLIN( 252)			{
HXLINE( 252)				Float au5 = au;
HXDLIN( 252)				Float av5 = ((Float)0.);
HXDLIN( 252)				Float bu5 = bu;
HXDLIN( 252)				Float bv4 = ( (Float)(0) );
HXDLIN( 252)				bool hasUndo4 = false;
HXDLIN( 252)				Float temp4 = au5;
HXLINE( 422)				au5 = bu5;
HXLINE( 423)				bu5 = temp4;
HXLINE( 424)				temp4 = av5;
HXLINE( 425)				av5 = bv4;
HXLINE( 426)				bv4 = temp4;
HXLINE( 252)				Float bcx4 = (bx1 - rightX);
HXDLIN( 252)				Float bcy4 = (y - topY);
HXDLIN( 252)				Float acx4 = (rightX - rightX);
HXDLIN( 252)				Float acy4 = (y - topY);
HXDLIN( 252)				Float dot114 = ((bcx4 * bcx4) + (bcy4 * bcy4));
HXDLIN( 252)				Float dot124 = ((bcx4 * acx4) + (bcy4 * acy4));
HXDLIN( 252)				Float dot224 = ((acx4 * acx4) + (acy4 * acy4));
HXDLIN( 252)				Float denom14 = (( (Float)(1) ) / ((dot114 * dot224) - (dot124 * dot124)));
HXDLIN( 252)				 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 252)				if ((rightX > bx1)) {
HXLINE( 252)					if ((rightX > rightX)) {
HXLINE( 252)						int min16;
HXDLIN( 252)						if ((bx1 > rightX)) {
HXLINE( 252)							min16 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 252)							min16 = ::Math_obj::floor(bx1);
            						}
HXDLIN( 252)						int ii_min32 = min16;
HXDLIN( 252)						int ii_max32 = ::Math_obj::ceil(rightX);
HXDLIN( 252)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            					}
            					else {
HXLINE( 252)						int ii_min33 = ::Math_obj::floor(bx1);
HXDLIN( 252)						int ii_max33 = ::Math_obj::ceil(rightX);
HXDLIN( 252)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            					}
            				}
            				else {
HXLINE( 252)					if ((bx1 > rightX)) {
HXLINE( 252)						int min17;
HXDLIN( 252)						if ((rightX > rightX)) {
HXLINE( 252)							min17 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 252)							min17 = ::Math_obj::ceil(rightX);
            						}
HXDLIN( 252)						int ii_min34 = min17;
HXDLIN( 252)						int ii_max34 = ::Math_obj::ceil(bx1);
HXDLIN( 252)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            					}
            					else {
HXLINE( 252)						int ii_min35 = ::Math_obj::floor(rightX);
HXDLIN( 252)						int ii_max35 = ::Math_obj::ceil(rightX);
HXDLIN( 252)						xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            					}
            				}
HXDLIN( 252)				 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 252)				if ((y > y)) {
HXLINE( 252)					if ((y > topY)) {
HXLINE( 252)						int min18;
HXDLIN( 252)						if ((y > topY)) {
HXLINE( 252)							min18 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 252)							min18 = ::Math_obj::floor(y);
            						}
HXDLIN( 252)						int ii_min36 = min18;
HXDLIN( 252)						int ii_max36 = ::Math_obj::ceil(y);
HXDLIN( 252)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            					}
            					else {
HXLINE( 252)						int ii_min37 = ::Math_obj::floor(y);
HXDLIN( 252)						int ii_max37 = ::Math_obj::ceil(topY);
HXDLIN( 252)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            					}
            				}
            				else {
HXLINE( 252)					if ((y > topY)) {
HXLINE( 252)						int min19;
HXDLIN( 252)						if ((y > topY)) {
HXLINE( 252)							min19 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 252)							min19 = ::Math_obj::ceil(y);
            						}
HXDLIN( 252)						int ii_min38 = min19;
HXDLIN( 252)						int ii_max38 = ::Math_obj::ceil(y);
HXDLIN( 252)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            					}
            					else {
HXLINE( 252)						int ii_min39 = ::Math_obj::floor(y);
HXDLIN( 252)						int ii_max39 = ::Math_obj::ceil(topY);
HXDLIN( 252)						yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            					}
            				}
HXDLIN( 252)				 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 252)				if (hasUndo4) {
HXLINE( 252)					int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 252)					int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 252)					 ::Dynamic imageType4 = null();
HXDLIN( 252)					 ::pi_xy::ImageStruct this137 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 252)					if (::hx::IsNull( imageType4 )) {
HXLINE(  54)						imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 252)					::Dynamic undoImage13;
HXDLIN( 252)					switch((int)(( (int)(imageType4) ))){
            						case (int)0: {
HXLINE( 252)							 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::BytesImg b32 = byt4;
HXDLIN( 252)							{
HXLINE( 252)								b32->width = width4;
HXDLIN( 252)								b32->height = height4;
HXDLIN( 252)								b32->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 252)								b32->data = ::haxe::io::Bytes_obj::alloc((b32->length * 4));
HXDLIN( 252)								{
HXLINE( 252)									int len8 = b32->length;
HXDLIN( 252)									int w4 = 0;
HXDLIN( 252)									{
HXLINE( 252)										int _g80 = 0;
HXDLIN( 252)										int _g81 = b32->height;
HXDLIN( 252)										while((_g80 < _g81)){
HXLINE( 252)											_g80 = (_g80 + 1);
HXDLIN( 252)											int y17 = (_g80 - 1);
HXDLIN( 252)											{
HXLINE( 252)												int _g82 = 0;
HXDLIN( 252)												int _g83 = b32->width;
HXDLIN( 252)												while((_g82 < _g83)){
HXLINE( 252)													_g82 = (_g82 + 1);
HXDLIN( 252)													int x17 = (_g82 - 1);
HXDLIN( 252)													{
HXLINE( 252)														w4 = (w4 + 1);
HXDLIN( 252)														b32->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 252)													{
HXLINE( 252)														w4 = (w4 + 1);
HXDLIN( 252)														b32->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 252)													{
HXLINE( 252)														w4 = (w4 + 1);
HXDLIN( 252)														b32->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 252)													{
HXLINE( 252)														w4 = (w4 + 1);
HXDLIN( 252)														b32->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 252)							undoImage13 = b32;
            						}
            						break;
            						case (int)1: {
HXLINE( 252)							 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::ArrIntImg a28 = arrI4;
HXDLIN( 252)							{
HXLINE( 252)								a28->width = width4;
HXDLIN( 252)								a28->height = height4;
HXDLIN( 252)								a28->data = ::Array_obj< int >::__new(0);
HXDLIN( 252)								a28->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 252)								{
HXLINE( 252)									int _g84 = 0;
HXDLIN( 252)									int _g85 = a28->length;
HXDLIN( 252)									while((_g84 < _g85)){
HXLINE( 252)										_g84 = (_g84 + 1);
HXDLIN( 252)										int i24 = (_g84 - 1);
HXDLIN( 252)										a28->data[i24] = 0;
            									}
            								}
            							}
HXDLIN( 252)							undoImage13 = a28;
            						}
            						break;
            						case (int)2: {
HXLINE( 252)							 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::U32ArrImg b33 = u32a4;
HXDLIN( 252)							{
HXLINE( 252)								b33->width = width4;
HXDLIN( 252)								b33->height = height4;
HXDLIN( 252)								b33->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 252)								int size4 = (b33->length * 4);
HXDLIN( 252)								b33->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 252)								{
HXLINE( 252)									int _g86 = 0;
HXDLIN( 252)									int _g87 = b33->length;
HXDLIN( 252)									while((_g86 < _g87)){
HXLINE( 252)										_g86 = (_g86 + 1);
HXDLIN( 252)										int i25 = (_g86 - 1);
HXDLIN( 252)										{
HXLINE( 252)											 ::haxe::io::ArrayBufferViewImpl this138 = b33->data;
HXDLIN( 252)											bool undoImage14;
HXDLIN( 252)											if ((i25 >= 0)) {
HXLINE( 252)												undoImage14 = (i25 < (this138->byteLength >> 2));
            											}
            											else {
HXLINE( 252)												undoImage14 = false;
            											}
HXDLIN( 252)											if (undoImage14) {
HXLINE( 252)												 ::haxe::io::Bytes _this4 = this138->bytes;
HXDLIN( 252)												int pos4 = ((i25 << 2) + this138->byteOffset);
HXDLIN( 252)												_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 252)												_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 252)												_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 252)												_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 252)							undoImage13 = b33;
            						}
            						break;
            						case (int)3: {
HXLINE( 252)							 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::VecIntImg v18 = vec4;
HXDLIN( 252)							{
HXLINE( 252)								v18->width = width4;
HXDLIN( 252)								v18->height = height4;
HXDLIN( 252)								v18->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 252)								v18->data = ::Array_obj< int >::__new(v18->length);
HXDLIN( 252)								{
HXLINE( 252)									int _g88 = 0;
HXDLIN( 252)									int _g89 = v18->length;
HXDLIN( 252)									while((_g88 < _g89)){
HXLINE( 252)										_g88 = (_g88 + 1);
HXDLIN( 252)										int i26 = (_g88 - 1);
HXDLIN( 252)										v18->data->__unsafe_set(i26,0);
            									}
            								}
            							}
HXDLIN( 252)							undoImage13 = v18;
            						}
            						break;
            						case (int)4: {
HXLINE( 252)							 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::StackIntImg b34 = sInt4;
HXDLIN( 252)							{
HXLINE( 252)								b34->width = width4;
HXDLIN( 252)								b34->height = height4;
HXDLIN( 252)								b34->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 252)								b34->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 252)								{
HXLINE( 252)									int len9 = b34->length;
HXDLIN( 252)									 ::haxe::ds::GenericStack_Int d4 = b34->data;
HXDLIN( 252)									if (::hx::IsNull( d4->head )) {
HXLINE( 252)										int _g90 = 0;
HXDLIN( 252)										int _g91 = len9;
HXDLIN( 252)										while((_g90 < _g91)){
HXLINE( 252)											_g90 = (_g90 + 1);
HXDLIN( 252)											int i27 = (_g90 - 1);
HXDLIN( 252)											d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            										}
            									}
            									else {
HXLINE( 252)										int _g92 = 0;
HXDLIN( 252)										int _g93 = len9;
HXDLIN( 252)										while((_g92 < _g93)){
HXLINE( 252)											_g92 = (_g92 + 1);
HXDLIN( 252)											int i28 = (_g92 - 1);
HXDLIN( 252)											{
HXLINE( 252)												 ::haxe::ds::GenericCell_Int l4 = b34->data->head;
HXDLIN( 252)												 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 252)												{
HXLINE( 252)													int _g94 = 0;
HXDLIN( 252)													int _g95 = i28;
HXDLIN( 252)													while((_g94 < _g95)){
HXLINE( 252)														_g94 = (_g94 + 1);
HXDLIN( 252)														int i29 = (_g94 - 1);
HXLINE( 345)														prev4 = l4;
HXLINE( 346)														l4 = l4->next;
            													}
            												}
HXLINE( 252)												if (::hx::IsNull( prev4 )) {
HXLINE( 252)													b34->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 252)													l4 = null();
            												}
            												else {
HXLINE( 252)													prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 252)													l4 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 252)							undoImage13 = b34;
            						}
            						break;
            					}
HXDLIN( 252)					this137->image = undoImage13;
HXDLIN( 252)					this137->width = width4;
HXDLIN( 252)					this137->height = height4;
HXDLIN( 252)					this137->imageType = ( (int)(imageType4) );
HXDLIN( 252)					undoImage12 = this137;
HXDLIN( 252)					{
HXLINE( 252)						int rectLeft4 = xIter34->start;
HXDLIN( 252)						int rectTop4 = yIter34->start;
HXDLIN( 252)						int rectRight4 = xIter34->max;
HXDLIN( 252)						bool forceClear4 = false;
HXDLIN( 252)						{
HXLINE( 252)							int _g96 = rectTop4;
HXDLIN( 252)							int _g97 = yIter34->max;
HXDLIN( 252)							while((_g96 < _g97)){
HXLINE( 252)								_g96 = (_g96 + 1);
HXDLIN( 252)								int dy5 = (_g96 - 1);
HXDLIN( 252)								{
HXLINE( 252)									int _g98 = rectLeft4;
HXDLIN( 252)									int _g99 = rectRight4;
HXDLIN( 252)									while((_g98 < _g99)){
HXLINE( 252)										_g98 = (_g98 + 1);
HXDLIN( 252)										int dx5 = (_g98 - 1);
HXDLIN( 252)										::Dynamic this139 = pixelImage->image;
HXDLIN( 252)										int index24;
HXDLIN( 252)										if (pixelImage->useVirtualPos) {
HXLINE( 252)											index24 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx5) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 252)											index24 = ::Std_obj::_hx_int(( (Float)(((dy5 * pixelImage->width) + dx5)) ));
            										}
HXDLIN( 252)										int c20 = ::iterMagic::Iimg_obj::get(this139,index24);
HXDLIN( 252)										int col8;
HXDLIN( 252)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)											col8 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            										}
            										else {
HXLINE( 252)											col8 = c20;
            										}
HXDLIN( 252)										bool _hx_tmp36;
HXDLIN( 252)										if (pixelImage->useMask) {
HXLINE( 252)											_hx_tmp36 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 252)											_hx_tmp36 = false;
            										}
HXDLIN( 252)										if (_hx_tmp36) {
HXLINE( 252)											 ::pi_xy::ImageStruct this140 = pixelImage->mask;
HXDLIN( 252)											::Dynamic this141 = this140->image;
HXDLIN( 252)											int index25;
HXDLIN( 252)											if (this140->useVirtualPos) {
HXLINE( 252)												index25 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this140->virtualY) * ( (Float)(this140->width) )) + dx5) - this140->virtualX));
            											}
            											else {
HXLINE( 252)												index25 = ::Std_obj::_hx_int(( (Float)(((dy5 * this140->width) + dx5)) ));
            											}
HXDLIN( 252)											int c21 = ::iterMagic::Iimg_obj::get(this141,index25);
HXDLIN( 252)											int v19;
HXDLIN( 252)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)												v19 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            											}
            											else {
HXLINE( 252)												v19 = c21;
            											}
HXDLIN( 252)											int maskPixel4 = v19;
HXDLIN( 252)											int this142 = col8;
HXDLIN( 252)											if ((maskPixel4 == 0)) {
HXLINE( 252)												col8 = this142;
            											}
            											else {
HXLINE( 252)												Float m04;
HXDLIN( 252)												int this143 = ((maskPixel4 >> 24) & 255);
HXDLIN( 252)												if ((this143 == 0)) {
HXLINE( 252)													m04 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													m04 = (( (Float)(this143) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float m14;
HXDLIN( 252)												int this144 = ((maskPixel4 >> 16) & 255);
HXDLIN( 252)												if ((this144 == 0)) {
HXLINE( 252)													m14 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													m14 = (( (Float)(this144) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float m24;
HXDLIN( 252)												int this145 = ((maskPixel4 >> 8) & 255);
HXDLIN( 252)												if ((this145 == 0)) {
HXLINE( 252)													m24 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													m24 = (( (Float)(this145) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float m34;
HXDLIN( 252)												int this146 = (maskPixel4 & 255);
HXDLIN( 252)												if ((this146 == 0)) {
HXLINE( 252)													m34 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													m34 = (( (Float)(this146) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this142 >> 24) & 255)) )));
HXDLIN( 252)												int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this142 >> 16) & 255)) )));
HXDLIN( 252)												int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this142 >> 8) & 255)) )));
HXDLIN( 252)												int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this142 & 255)) )));
HXDLIN( 252)												col8 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 252)										if ((col8 != 0)) {
HXLINE( 252)											int x18 = (dx5 - rectLeft4);
HXDLIN( 252)											int y18 = (dy5 - rectTop4);
HXDLIN( 252)											int c22 = col8;
HXDLIN( 252)											bool _hx_tmp37;
HXDLIN( 252)											if ((((c22 >> 24) & 255) < 254)) {
HXLINE( 252)												_hx_tmp37 = undoImage12->transparent;
            											}
            											else {
HXLINE( 252)												_hx_tmp37 = false;
            											}
HXDLIN( 252)											if (_hx_tmp37) {
HXLINE( 252)												int location8;
HXDLIN( 252)												if (undoImage12->useVirtualPos) {
HXLINE( 252)													location8 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x18) - undoImage12->virtualX));
            												}
            												else {
HXLINE( 252)													location8 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage12->width) + x18)) ));
            												}
HXDLIN( 252)												int this147 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 252)												int this148;
HXDLIN( 252)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)													this148 = ((((((this147 >> 24) & 255) << 24) | ((this147 & 255) << 16)) | (((this147 >> 8) & 255) << 8)) | ((this147 >> 16) & 255));
            												}
            												else {
HXLINE( 252)													this148 = this147;
            												}
HXDLIN( 252)												Float a111;
HXDLIN( 252)												int this149 = ((this148 >> 24) & 255);
HXDLIN( 252)												if ((this149 == 0)) {
HXLINE( 252)													a111 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													a111 = (( (Float)(this149) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float r18;
HXDLIN( 252)												int this150 = ((this148 >> 16) & 255);
HXDLIN( 252)												if ((this150 == 0)) {
HXLINE( 252)													r18 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													r18 = (( (Float)(this150) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float g18;
HXDLIN( 252)												int this151 = ((this148 >> 8) & 255);
HXDLIN( 252)												if ((this151 == 0)) {
HXLINE( 252)													g18 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													g18 = (( (Float)(this151) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float b112;
HXDLIN( 252)												int this152 = (this148 & 255);
HXDLIN( 252)												if ((this152 == 0)) {
HXLINE( 252)													b112 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													b112 = (( (Float)(this152) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float a29;
HXDLIN( 252)												int this153 = ((col8 >> 24) & 255);
HXDLIN( 252)												if ((this153 == 0)) {
HXLINE( 252)													a29 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													a29 = (( (Float)(this153) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float r28;
HXDLIN( 252)												int this154 = ((col8 >> 16) & 255);
HXDLIN( 252)												if ((this154 == 0)) {
HXLINE( 252)													r28 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													r28 = (( (Float)(this154) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float g28;
HXDLIN( 252)												int this155 = ((col8 >> 8) & 255);
HXDLIN( 252)												if ((this155 == 0)) {
HXLINE( 252)													g28 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													g28 = (( (Float)(this155) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float b212;
HXDLIN( 252)												int this156 = (col8 & 255);
HXDLIN( 252)												if ((this156 == 0)) {
HXLINE( 252)													b212 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													b212 = (( (Float)(this156) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float a38 = (a111 * (( (Float)(1) ) - a29));
HXDLIN( 252)												int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a29))));
HXDLIN( 252)												int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a29))));
HXDLIN( 252)												int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a38) + (b212 * a29))));
HXDLIN( 252)												int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a29)));
HXDLIN( 252)												int blended8 = ((((a30 << 24) | (r10 << 16)) | (g10 << 8)) | b35);
HXDLIN( 252)												{
HXLINE( 252)													int _hx_tmp38;
HXDLIN( 252)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)														_hx_tmp38 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            													}
            													else {
HXLINE( 252)														_hx_tmp38 = blended8;
            													}
HXDLIN( 252)													::iterMagic::Iimg_obj::set(undoImage12->image,location8,_hx_tmp38);
            												}
            											}
            											else {
HXLINE( 252)												::Dynamic this157 = undoImage12->image;
HXDLIN( 252)												int index26;
HXDLIN( 252)												if (undoImage12->useVirtualPos) {
HXLINE( 252)													index26 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x18) - undoImage12->virtualX));
            												}
            												else {
HXLINE( 252)													index26 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage12->width) + x18)) ));
            												}
HXDLIN( 252)												int _hx_tmp39;
HXDLIN( 252)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)													_hx_tmp39 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            												}
            												else {
HXLINE( 252)													_hx_tmp39 = c22;
            												}
HXDLIN( 252)												::iterMagic::Iimg_obj::set(this157,index26,_hx_tmp39);
            											}
            										}
            										else {
HXLINE( 252)											if (forceClear4) {
HXLINE( 252)												::Dynamic this158 = undoImage12->image;
HXDLIN( 252)												int x19 = (dx5 - rectLeft4);
HXDLIN( 252)												int y19 = (dy5 - rectTop4);
HXDLIN( 252)												int index27;
HXDLIN( 252)												if (undoImage12->useVirtualPos) {
HXLINE( 252)													index27 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x19) - undoImage12->virtualX));
            												}
            												else {
HXLINE( 252)													index27 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage12->width) + x19)) ));
            												}
HXDLIN( 252)												::iterMagic::Iimg_obj::set(this158,index27,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 252)				{
HXLINE( 252)					int _g_min8 = xIter34->start;
HXDLIN( 252)					int _g_max8 = xIter34->max;
HXDLIN( 252)					while((_g_min8 < _g_max8)){
HXLINE( 252)						_g_min8 = (_g_min8 + 1);
HXDLIN( 252)						int px4 = (_g_min8 - 1);
HXDLIN( 252)						Float pcx4 = (( (Float)(px4) ) - rightX);
HXDLIN( 252)						{
HXLINE( 252)							int _g_min9 = yIter34->start;
HXDLIN( 252)							int _g_max9 = yIter34->max;
HXDLIN( 252)							while((_g_min9 < _g_max9)){
HXLINE( 252)								_g_min9 = (_g_min9 + 1);
HXDLIN( 252)								int py4 = (_g_min9 - 1);
HXDLIN( 252)								Float pcy4 = (( (Float)(py4) ) - topY);
HXDLIN( 252)								Float dot314 = ((pcx4 * bcx4) + (pcy4 * bcy4));
HXDLIN( 252)								Float dot324 = ((pcx4 * acx4) + (pcy4 * acy4));
HXDLIN( 252)								Float ratioA4 = (((dot224 * dot314) - (dot124 * dot324)) * denom14);
HXDLIN( 252)								Float ratioB4 = (((dot114 * dot324) - (dot124 * dot314)) * denom14);
HXDLIN( 252)								Float ratioC4 = ((((Float)1.0) - ratioB4) - ratioA4);
HXDLIN( 252)								bool _hx_tmp40;
HXDLIN( 252)								bool _hx_tmp41;
HXDLIN( 252)								if ((ratioA4 >= 0)) {
HXLINE( 252)									_hx_tmp41 = (ratioB4 >= 0);
            								}
            								else {
HXLINE( 252)									_hx_tmp41 = false;
            								}
HXDLIN( 252)								if (_hx_tmp41) {
HXLINE( 252)									_hx_tmp40 = (ratioC4 >= 0);
            								}
            								else {
HXLINE( 252)									_hx_tmp40 = false;
            								}
HXDLIN( 252)								if (_hx_tmp40) {
HXLINE( 252)									Float u4 = (((au5 * ratioA4) + (bu5 * ratioB4)) + (au * ratioC4));
HXDLIN( 252)									Float v20 = (((av5 * ratioA4) + (bv4 * ratioB4)) + (cv * ratioC4));
HXDLIN( 252)									int x20 = ::Std_obj::_hx_int(((u4 * win->width) + win->x));
HXDLIN( 252)									int y20 = ::Std_obj::_hx_int(((v20 * win->height) + win->y));
HXDLIN( 252)									::Dynamic this159 = texture->image;
HXDLIN( 252)									int index28;
HXDLIN( 252)									if (texture->useVirtualPos) {
HXLINE( 252)										index28 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - texture->virtualY) * ( (Float)(texture->width) )) + x20) - texture->virtualX));
            									}
            									else {
HXLINE( 252)										index28 = ::Std_obj::_hx_int(( (Float)(((y20 * texture->width) + x20)) ));
            									}
HXDLIN( 252)									int c23 = ::iterMagic::Iimg_obj::get(this159,index28);
HXDLIN( 252)									int col9;
HXDLIN( 252)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)										col9 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            									}
            									else {
HXLINE( 252)										col9 = c23;
            									}
HXDLIN( 252)									{
HXLINE( 252)										int c24 = col9;
HXDLIN( 252)										bool _hx_tmp42;
HXDLIN( 252)										if ((((c24 >> 24) & 255) < 254)) {
HXLINE( 252)											_hx_tmp42 = pixelImage->transparent;
            										}
            										else {
HXLINE( 252)											_hx_tmp42 = false;
            										}
HXDLIN( 252)										if (_hx_tmp42) {
HXLINE( 252)											int location9;
HXDLIN( 252)											if (pixelImage->useVirtualPos) {
HXLINE( 252)												location9 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px4) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 252)												location9 = ::Std_obj::_hx_int(( (Float)(((py4 * pixelImage->width) + px4)) ));
            											}
HXDLIN( 252)											int this160 = ::iterMagic::Iimg_obj::get(pixelImage->image,location9);
HXDLIN( 252)											int this161;
HXDLIN( 252)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)												this161 = ((((((this160 >> 24) & 255) << 24) | ((this160 & 255) << 16)) | (((this160 >> 8) & 255) << 8)) | ((this160 >> 16) & 255));
            											}
            											else {
HXLINE( 252)												this161 = this160;
            											}
HXDLIN( 252)											Float a112;
HXDLIN( 252)											int this162 = ((this161 >> 24) & 255);
HXDLIN( 252)											if ((this162 == 0)) {
HXLINE( 252)												a112 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												a112 = (( (Float)(this162) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float r19;
HXDLIN( 252)											int this163 = ((this161 >> 16) & 255);
HXDLIN( 252)											if ((this163 == 0)) {
HXLINE( 252)												r19 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												r19 = (( (Float)(this163) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float g19;
HXDLIN( 252)											int this164 = ((this161 >> 8) & 255);
HXDLIN( 252)											if ((this164 == 0)) {
HXLINE( 252)												g19 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												g19 = (( (Float)(this164) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float b113;
HXDLIN( 252)											int this165 = (this161 & 255);
HXDLIN( 252)											if ((this165 == 0)) {
HXLINE( 252)												b113 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												b113 = (( (Float)(this165) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float a210;
HXDLIN( 252)											int this166 = ((col9 >> 24) & 255);
HXDLIN( 252)											if ((this166 == 0)) {
HXLINE( 252)												a210 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												a210 = (( (Float)(this166) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float r29;
HXDLIN( 252)											int this167 = ((col9 >> 16) & 255);
HXDLIN( 252)											if ((this167 == 0)) {
HXLINE( 252)												r29 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												r29 = (( (Float)(this167) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float g29;
HXDLIN( 252)											int this168 = ((col9 >> 8) & 255);
HXDLIN( 252)											if ((this168 == 0)) {
HXLINE( 252)												g29 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												g29 = (( (Float)(this168) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float b213;
HXDLIN( 252)											int this169 = (col9 & 255);
HXDLIN( 252)											if ((this169 == 0)) {
HXLINE( 252)												b213 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												b213 = (( (Float)(this169) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float a39 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 252)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN( 252)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN( 252)											int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a39) + (b213 * a210))));
HXDLIN( 252)											int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN( 252)											int blended9 = ((((a40 << 24) | (r20 << 16)) | (g20 << 8)) | b36);
HXDLIN( 252)											{
HXLINE( 252)												int _hx_tmp43;
HXDLIN( 252)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)													_hx_tmp43 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXLINE( 252)													_hx_tmp43 = blended9;
            												}
HXDLIN( 252)												::iterMagic::Iimg_obj::set(pixelImage->image,location9,_hx_tmp43);
            											}
            										}
            										else {
HXLINE( 252)											::Dynamic this170 = pixelImage->image;
HXDLIN( 252)											int index29;
HXDLIN( 252)											if (pixelImage->useVirtualPos) {
HXLINE( 252)												index29 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px4) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 252)												index29 = ::Std_obj::_hx_int(( (Float)(((py4 * pixelImage->width) + px4)) ));
            											}
HXDLIN( 252)											int _hx_tmp44;
HXDLIN( 252)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)												_hx_tmp44 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            											}
            											else {
HXLINE( 252)												_hx_tmp44 = c24;
            											}
HXDLIN( 252)											::iterMagic::Iimg_obj::set(this170,index29,_hx_tmp44);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 252)				if ((hasHit == false)) {
HXLINE( 252)					 ::pi_xy::algo::HitTri v21 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,y,bx1,y,rightX,topY,true);
HXDLIN( 252)					if (hasUndo4) {
HXLINE( 252)						v21->undoImage = undoImage12;
HXDLIN( 252)						v21->undoX = xIter34->start;
HXDLIN( 252)						v21->undoY = yIter34->start;
            					}
            				}
            			}
HXDLIN( 252)			{
HXLINE( 252)				Float au6 = bu;
HXDLIN( 252)				Float av6 = ( (Float)(0) );
HXDLIN( 252)				Float bu6 = bu;
HXDLIN( 252)				Float bv5 = cv;
HXDLIN( 252)				bool hasUndo5 = false;
HXDLIN( 252)				Float temp5 = au6;
HXLINE( 422)				au6 = bu6;
HXLINE( 423)				bu6 = temp5;
HXLINE( 424)				temp5 = av6;
HXLINE( 425)				av6 = bv5;
HXLINE( 426)				bv5 = temp5;
HXLINE( 252)				Float bcx5 = (cx1 - rightX);
HXDLIN( 252)				Float bcy5 = (topY - topY);
HXDLIN( 252)				Float acx5 = (bx1 - rightX);
HXDLIN( 252)				Float acy5 = (y - topY);
HXDLIN( 252)				Float dot115 = ((bcx5 * bcx5) + (bcy5 * bcy5));
HXDLIN( 252)				Float dot125 = ((bcx5 * acx5) + (bcy5 * acy5));
HXDLIN( 252)				Float dot225 = ((acx5 * acx5) + (acy5 * acy5));
HXDLIN( 252)				Float denom15 = (( (Float)(1) ) / ((dot115 * dot225) - (dot125 * dot125)));
HXDLIN( 252)				 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 252)				if ((bx1 > cx1)) {
HXLINE( 252)					if ((bx1 > rightX)) {
HXLINE( 252)						int min20;
HXDLIN( 252)						if ((cx1 > rightX)) {
HXLINE( 252)							min20 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 252)							min20 = ::Math_obj::floor(cx1);
            						}
HXDLIN( 252)						int ii_min40 = min20;
HXDLIN( 252)						int ii_max40 = ::Math_obj::ceil(bx1);
HXDLIN( 252)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            					}
            					else {
HXLINE( 252)						int ii_min41 = ::Math_obj::floor(cx1);
HXDLIN( 252)						int ii_max41 = ::Math_obj::ceil(rightX);
HXDLIN( 252)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            					}
            				}
            				else {
HXLINE( 252)					if ((cx1 > rightX)) {
HXLINE( 252)						int min21;
HXDLIN( 252)						if ((bx1 > rightX)) {
HXLINE( 252)							min21 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 252)							min21 = ::Math_obj::ceil(bx1);
            						}
HXDLIN( 252)						int ii_min42 = min21;
HXDLIN( 252)						int ii_max42 = ::Math_obj::ceil(cx1);
HXDLIN( 252)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            					}
            					else {
HXLINE( 252)						int ii_min43 = ::Math_obj::floor(bx1);
HXDLIN( 252)						int ii_max43 = ::Math_obj::ceil(rightX);
HXDLIN( 252)						xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            					}
            				}
HXDLIN( 252)				 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 252)				if ((y > topY)) {
HXLINE( 252)					if ((y > topY)) {
HXLINE( 252)						int min22;
HXDLIN( 252)						if ((topY > topY)) {
HXLINE( 252)							min22 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 252)							min22 = ::Math_obj::floor(topY);
            						}
HXDLIN( 252)						int ii_min44 = min22;
HXDLIN( 252)						int ii_max44 = ::Math_obj::ceil(y);
HXDLIN( 252)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            					}
            					else {
HXLINE( 252)						int ii_min45 = ::Math_obj::floor(topY);
HXDLIN( 252)						int ii_max45 = ::Math_obj::ceil(topY);
HXDLIN( 252)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            					}
            				}
            				else {
HXLINE( 252)					if ((topY > topY)) {
HXLINE( 252)						int min23;
HXDLIN( 252)						if ((y > topY)) {
HXLINE( 252)							min23 = ::Math_obj::floor(topY);
            						}
            						else {
HXLINE( 252)							min23 = ::Math_obj::ceil(y);
            						}
HXDLIN( 252)						int ii_min46 = min23;
HXDLIN( 252)						int ii_max46 = ::Math_obj::ceil(topY);
HXDLIN( 252)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            					}
            					else {
HXLINE( 252)						int ii_min47 = ::Math_obj::floor(y);
HXDLIN( 252)						int ii_max47 = ::Math_obj::ceil(topY);
HXDLIN( 252)						yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            					}
            				}
HXDLIN( 252)				 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 252)				if (hasUndo5) {
HXLINE( 252)					int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 252)					int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 252)					 ::Dynamic imageType5 = null();
HXDLIN( 252)					 ::pi_xy::ImageStruct this171 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 252)					if (::hx::IsNull( imageType5 )) {
HXLINE(  54)						imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 252)					::Dynamic undoImage16;
HXDLIN( 252)					switch((int)(( (int)(imageType5) ))){
            						case (int)0: {
HXLINE( 252)							 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::BytesImg b37 = byt5;
HXDLIN( 252)							{
HXLINE( 252)								b37->width = width5;
HXDLIN( 252)								b37->height = height5;
HXDLIN( 252)								b37->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 252)								b37->data = ::haxe::io::Bytes_obj::alloc((b37->length * 4));
HXDLIN( 252)								{
HXLINE( 252)									int len10 = b37->length;
HXDLIN( 252)									int w5 = 0;
HXDLIN( 252)									{
HXLINE( 252)										int _g100 = 0;
HXDLIN( 252)										int _g101 = b37->height;
HXDLIN( 252)										while((_g100 < _g101)){
HXLINE( 252)											_g100 = (_g100 + 1);
HXDLIN( 252)											int y21 = (_g100 - 1);
HXDLIN( 252)											{
HXLINE( 252)												int _g102 = 0;
HXDLIN( 252)												int _g103 = b37->width;
HXDLIN( 252)												while((_g102 < _g103)){
HXLINE( 252)													_g102 = (_g102 + 1);
HXDLIN( 252)													int x21 = (_g102 - 1);
HXDLIN( 252)													{
HXLINE( 252)														w5 = (w5 + 1);
HXDLIN( 252)														b37->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 252)													{
HXLINE( 252)														w5 = (w5 + 1);
HXDLIN( 252)														b37->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 252)													{
HXLINE( 252)														w5 = (w5 + 1);
HXDLIN( 252)														b37->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 252)													{
HXLINE( 252)														w5 = (w5 + 1);
HXDLIN( 252)														b37->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 252)							undoImage16 = b37;
            						}
            						break;
            						case (int)1: {
HXLINE( 252)							 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::ArrIntImg a41 = arrI5;
HXDLIN( 252)							{
HXLINE( 252)								a41->width = width5;
HXDLIN( 252)								a41->height = height5;
HXDLIN( 252)								a41->data = ::Array_obj< int >::__new(0);
HXDLIN( 252)								a41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 252)								{
HXLINE( 252)									int _g104 = 0;
HXDLIN( 252)									int _g105 = a41->length;
HXDLIN( 252)									while((_g104 < _g105)){
HXLINE( 252)										_g104 = (_g104 + 1);
HXDLIN( 252)										int i30 = (_g104 - 1);
HXDLIN( 252)										a41->data[i30] = 0;
            									}
            								}
            							}
HXDLIN( 252)							undoImage16 = a41;
            						}
            						break;
            						case (int)2: {
HXLINE( 252)							 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::U32ArrImg b38 = u32a5;
HXDLIN( 252)							{
HXLINE( 252)								b38->width = width5;
HXDLIN( 252)								b38->height = height5;
HXDLIN( 252)								b38->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 252)								int size5 = (b38->length * 4);
HXDLIN( 252)								b38->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 252)								{
HXLINE( 252)									int _g106 = 0;
HXDLIN( 252)									int _g107 = b38->length;
HXDLIN( 252)									while((_g106 < _g107)){
HXLINE( 252)										_g106 = (_g106 + 1);
HXDLIN( 252)										int i31 = (_g106 - 1);
HXDLIN( 252)										{
HXLINE( 252)											 ::haxe::io::ArrayBufferViewImpl this172 = b38->data;
HXDLIN( 252)											bool undoImage17;
HXDLIN( 252)											if ((i31 >= 0)) {
HXLINE( 252)												undoImage17 = (i31 < (this172->byteLength >> 2));
            											}
            											else {
HXLINE( 252)												undoImage17 = false;
            											}
HXDLIN( 252)											if (undoImage17) {
HXLINE( 252)												 ::haxe::io::Bytes _this5 = this172->bytes;
HXDLIN( 252)												int pos5 = ((i31 << 2) + this172->byteOffset);
HXDLIN( 252)												_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 252)												_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 252)												_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 252)												_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 252)							undoImage16 = b38;
            						}
            						break;
            						case (int)3: {
HXLINE( 252)							 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::VecIntImg v22 = vec5;
HXDLIN( 252)							{
HXLINE( 252)								v22->width = width5;
HXDLIN( 252)								v22->height = height5;
HXDLIN( 252)								v22->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 252)								v22->data = ::Array_obj< int >::__new(v22->length);
HXDLIN( 252)								{
HXLINE( 252)									int _g108 = 0;
HXDLIN( 252)									int _g109 = v22->length;
HXDLIN( 252)									while((_g108 < _g109)){
HXLINE( 252)										_g108 = (_g108 + 1);
HXDLIN( 252)										int i32 = (_g108 - 1);
HXDLIN( 252)										v22->data->__unsafe_set(i32,0);
            									}
            								}
            							}
HXDLIN( 252)							undoImage16 = v22;
            						}
            						break;
            						case (int)4: {
HXLINE( 252)							 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 252)							 ::iterMagic::StackIntImg b39 = sInt5;
HXDLIN( 252)							{
HXLINE( 252)								b39->width = width5;
HXDLIN( 252)								b39->height = height5;
HXDLIN( 252)								b39->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 252)								b39->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 252)								{
HXLINE( 252)									int len11 = b39->length;
HXDLIN( 252)									 ::haxe::ds::GenericStack_Int d5 = b39->data;
HXDLIN( 252)									if (::hx::IsNull( d5->head )) {
HXLINE( 252)										int _g110 = 0;
HXDLIN( 252)										int _g111 = len11;
HXDLIN( 252)										while((_g110 < _g111)){
HXLINE( 252)											_g110 = (_g110 + 1);
HXDLIN( 252)											int i33 = (_g110 - 1);
HXDLIN( 252)											d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            										}
            									}
            									else {
HXLINE( 252)										int _g112 = 0;
HXDLIN( 252)										int _g113 = len11;
HXDLIN( 252)										while((_g112 < _g113)){
HXLINE( 252)											_g112 = (_g112 + 1);
HXDLIN( 252)											int i34 = (_g112 - 1);
HXDLIN( 252)											{
HXLINE( 252)												 ::haxe::ds::GenericCell_Int l5 = b39->data->head;
HXDLIN( 252)												 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 252)												{
HXLINE( 252)													int _g114 = 0;
HXDLIN( 252)													int _g115 = i34;
HXDLIN( 252)													while((_g114 < _g115)){
HXLINE( 252)														_g114 = (_g114 + 1);
HXDLIN( 252)														int i35 = (_g114 - 1);
HXLINE( 345)														prev5 = l5;
HXLINE( 346)														l5 = l5->next;
            													}
            												}
HXLINE( 252)												if (::hx::IsNull( prev5 )) {
HXLINE( 252)													b39->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 252)													l5 = null();
            												}
            												else {
HXLINE( 252)													prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 252)													l5 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 252)							undoImage16 = b39;
            						}
            						break;
            					}
HXDLIN( 252)					this171->image = undoImage16;
HXDLIN( 252)					this171->width = width5;
HXDLIN( 252)					this171->height = height5;
HXDLIN( 252)					this171->imageType = ( (int)(imageType5) );
HXDLIN( 252)					undoImage15 = this171;
HXDLIN( 252)					{
HXLINE( 252)						int rectLeft5 = xIter35->start;
HXDLIN( 252)						int rectTop5 = yIter35->start;
HXDLIN( 252)						int rectRight5 = xIter35->max;
HXDLIN( 252)						bool forceClear5 = false;
HXDLIN( 252)						{
HXLINE( 252)							int _g116 = rectTop5;
HXDLIN( 252)							int _g117 = yIter35->max;
HXDLIN( 252)							while((_g116 < _g117)){
HXLINE( 252)								_g116 = (_g116 + 1);
HXDLIN( 252)								int dy6 = (_g116 - 1);
HXDLIN( 252)								{
HXLINE( 252)									int _g118 = rectLeft5;
HXDLIN( 252)									int _g119 = rectRight5;
HXDLIN( 252)									while((_g118 < _g119)){
HXLINE( 252)										_g118 = (_g118 + 1);
HXDLIN( 252)										int dx6 = (_g118 - 1);
HXDLIN( 252)										::Dynamic this173 = pixelImage->image;
HXDLIN( 252)										int index30;
HXDLIN( 252)										if (pixelImage->useVirtualPos) {
HXLINE( 252)											index30 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx6) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 252)											index30 = ::Std_obj::_hx_int(( (Float)(((dy6 * pixelImage->width) + dx6)) ));
            										}
HXDLIN( 252)										int c25 = ::iterMagic::Iimg_obj::get(this173,index30);
HXDLIN( 252)										int col10;
HXDLIN( 252)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)											col10 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXLINE( 252)											col10 = c25;
            										}
HXDLIN( 252)										bool _hx_tmp45;
HXDLIN( 252)										if (pixelImage->useMask) {
HXLINE( 252)											_hx_tmp45 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 252)											_hx_tmp45 = false;
            										}
HXDLIN( 252)										if (_hx_tmp45) {
HXLINE( 252)											 ::pi_xy::ImageStruct this174 = pixelImage->mask;
HXDLIN( 252)											::Dynamic this175 = this174->image;
HXDLIN( 252)											int index31;
HXDLIN( 252)											if (this174->useVirtualPos) {
HXLINE( 252)												index31 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this174->virtualY) * ( (Float)(this174->width) )) + dx6) - this174->virtualX));
            											}
            											else {
HXLINE( 252)												index31 = ::Std_obj::_hx_int(( (Float)(((dy6 * this174->width) + dx6)) ));
            											}
HXDLIN( 252)											int c26 = ::iterMagic::Iimg_obj::get(this175,index31);
HXDLIN( 252)											int v23;
HXDLIN( 252)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)												v23 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            											}
            											else {
HXLINE( 252)												v23 = c26;
            											}
HXDLIN( 252)											int maskPixel5 = v23;
HXDLIN( 252)											int this176 = col10;
HXDLIN( 252)											if ((maskPixel5 == 0)) {
HXLINE( 252)												col10 = this176;
            											}
            											else {
HXLINE( 252)												Float m05;
HXDLIN( 252)												int this177 = ((maskPixel5 >> 24) & 255);
HXDLIN( 252)												if ((this177 == 0)) {
HXLINE( 252)													m05 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													m05 = (( (Float)(this177) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float m15;
HXDLIN( 252)												int this178 = ((maskPixel5 >> 16) & 255);
HXDLIN( 252)												if ((this178 == 0)) {
HXLINE( 252)													m15 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													m15 = (( (Float)(this178) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float m25;
HXDLIN( 252)												int this179 = ((maskPixel5 >> 8) & 255);
HXDLIN( 252)												if ((this179 == 0)) {
HXLINE( 252)													m25 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													m25 = (( (Float)(this179) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float m35;
HXDLIN( 252)												int this180 = (maskPixel5 & 255);
HXDLIN( 252)												if ((this180 == 0)) {
HXLINE( 252)													m35 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													m35 = (( (Float)(this180) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this176 >> 24) & 255)) )));
HXDLIN( 252)												int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this176 >> 16) & 255)) )));
HXDLIN( 252)												int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this176 >> 8) & 255)) )));
HXDLIN( 252)												int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this176 & 255)) )));
HXDLIN( 252)												col10 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 252)										if ((col10 != 0)) {
HXLINE( 252)											int x22 = (dx6 - rectLeft5);
HXDLIN( 252)											int y22 = (dy6 - rectTop5);
HXDLIN( 252)											int c27 = col10;
HXDLIN( 252)											bool _hx_tmp46;
HXDLIN( 252)											if ((((c27 >> 24) & 255) < 254)) {
HXLINE( 252)												_hx_tmp46 = undoImage15->transparent;
            											}
            											else {
HXLINE( 252)												_hx_tmp46 = false;
            											}
HXDLIN( 252)											if (_hx_tmp46) {
HXLINE( 252)												int location10;
HXDLIN( 252)												if (undoImage15->useVirtualPos) {
HXLINE( 252)													location10 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x22) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 252)													location10 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage15->width) + x22)) ));
            												}
HXDLIN( 252)												int this181 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 252)												int this182;
HXDLIN( 252)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)													this182 = ((((((this181 >> 24) & 255) << 24) | ((this181 & 255) << 16)) | (((this181 >> 8) & 255) << 8)) | ((this181 >> 16) & 255));
            												}
            												else {
HXLINE( 252)													this182 = this181;
            												}
HXDLIN( 252)												Float a113;
HXDLIN( 252)												int this183 = ((this182 >> 24) & 255);
HXDLIN( 252)												if ((this183 == 0)) {
HXLINE( 252)													a113 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													a113 = (( (Float)(this183) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float r110;
HXDLIN( 252)												int this184 = ((this182 >> 16) & 255);
HXDLIN( 252)												if ((this184 == 0)) {
HXLINE( 252)													r110 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													r110 = (( (Float)(this184) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float g110;
HXDLIN( 252)												int this185 = ((this182 >> 8) & 255);
HXDLIN( 252)												if ((this185 == 0)) {
HXLINE( 252)													g110 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													g110 = (( (Float)(this185) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float b114;
HXDLIN( 252)												int this186 = (this182 & 255);
HXDLIN( 252)												if ((this186 == 0)) {
HXLINE( 252)													b114 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													b114 = (( (Float)(this186) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float a211;
HXDLIN( 252)												int this187 = ((col10 >> 24) & 255);
HXDLIN( 252)												if ((this187 == 0)) {
HXLINE( 252)													a211 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													a211 = (( (Float)(this187) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float r210;
HXDLIN( 252)												int this188 = ((col10 >> 16) & 255);
HXDLIN( 252)												if ((this188 == 0)) {
HXLINE( 252)													r210 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													r210 = (( (Float)(this188) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float g210;
HXDLIN( 252)												int this189 = ((col10 >> 8) & 255);
HXDLIN( 252)												if ((this189 == 0)) {
HXLINE( 252)													g210 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													g210 = (( (Float)(this189) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float b214;
HXDLIN( 252)												int this190 = (col10 & 255);
HXDLIN( 252)												if ((this190 == 0)) {
HXLINE( 252)													b214 = ((Float)0.);
            												}
            												else {
HXLINE( 252)													b214 = (( (Float)(this190) ) / ( (Float)(255) ));
            												}
HXDLIN( 252)												Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 252)												int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN( 252)												int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN( 252)												int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b214 * a211))));
HXDLIN( 252)												int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 252)												int blended10 = ((((a42 << 24) | (r30 << 16)) | (g30 << 8)) | b40);
HXDLIN( 252)												{
HXLINE( 252)													int _hx_tmp47;
HXDLIN( 252)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)														_hx_tmp47 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            													}
            													else {
HXLINE( 252)														_hx_tmp47 = blended10;
            													}
HXDLIN( 252)													::iterMagic::Iimg_obj::set(undoImage15->image,location10,_hx_tmp47);
            												}
            											}
            											else {
HXLINE( 252)												::Dynamic this191 = undoImage15->image;
HXDLIN( 252)												int index32;
HXDLIN( 252)												if (undoImage15->useVirtualPos) {
HXLINE( 252)													index32 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x22) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 252)													index32 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage15->width) + x22)) ));
            												}
HXDLIN( 252)												int _hx_tmp48;
HXDLIN( 252)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)													_hx_tmp48 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            												}
            												else {
HXLINE( 252)													_hx_tmp48 = c27;
            												}
HXDLIN( 252)												::iterMagic::Iimg_obj::set(this191,index32,_hx_tmp48);
            											}
            										}
            										else {
HXLINE( 252)											if (forceClear5) {
HXLINE( 252)												::Dynamic this192 = undoImage15->image;
HXDLIN( 252)												int x23 = (dx6 - rectLeft5);
HXDLIN( 252)												int y23 = (dy6 - rectTop5);
HXDLIN( 252)												int index33;
HXDLIN( 252)												if (undoImage15->useVirtualPos) {
HXLINE( 252)													index33 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x23) - undoImage15->virtualX));
            												}
            												else {
HXLINE( 252)													index33 = ::Std_obj::_hx_int(( (Float)(((y23 * undoImage15->width) + x23)) ));
            												}
HXDLIN( 252)												::iterMagic::Iimg_obj::set(this192,index33,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 252)				{
HXLINE( 252)					int _g_min10 = xIter35->start;
HXDLIN( 252)					int _g_max10 = xIter35->max;
HXDLIN( 252)					while((_g_min10 < _g_max10)){
HXLINE( 252)						_g_min10 = (_g_min10 + 1);
HXDLIN( 252)						int px5 = (_g_min10 - 1);
HXDLIN( 252)						Float pcx5 = (( (Float)(px5) ) - rightX);
HXDLIN( 252)						{
HXLINE( 252)							int _g_min11 = yIter35->start;
HXDLIN( 252)							int _g_max11 = yIter35->max;
HXDLIN( 252)							while((_g_min11 < _g_max11)){
HXLINE( 252)								_g_min11 = (_g_min11 + 1);
HXDLIN( 252)								int py5 = (_g_min11 - 1);
HXDLIN( 252)								Float pcy5 = (( (Float)(py5) ) - topY);
HXDLIN( 252)								Float dot315 = ((pcx5 * bcx5) + (pcy5 * bcy5));
HXDLIN( 252)								Float dot325 = ((pcx5 * acx5) + (pcy5 * acy5));
HXDLIN( 252)								Float ratioA5 = (((dot225 * dot315) - (dot125 * dot325)) * denom15);
HXDLIN( 252)								Float ratioB5 = (((dot115 * dot325) - (dot125 * dot315)) * denom15);
HXDLIN( 252)								Float ratioC5 = ((((Float)1.0) - ratioB5) - ratioA5);
HXDLIN( 252)								bool _hx_tmp49;
HXDLIN( 252)								bool _hx_tmp50;
HXDLIN( 252)								if ((ratioA5 >= 0)) {
HXLINE( 252)									_hx_tmp50 = (ratioB5 >= 0);
            								}
            								else {
HXLINE( 252)									_hx_tmp50 = false;
            								}
HXDLIN( 252)								if (_hx_tmp50) {
HXLINE( 252)									_hx_tmp49 = (ratioC5 >= 0);
            								}
            								else {
HXLINE( 252)									_hx_tmp49 = false;
            								}
HXDLIN( 252)								if (_hx_tmp49) {
HXLINE( 252)									Float u5 = (((au6 * ratioA5) + (bu6 * ratioB5)) + (au * ratioC5));
HXDLIN( 252)									Float v24 = (((av6 * ratioA5) + (bv5 * ratioB5)) + (cv * ratioC5));
HXDLIN( 252)									int x24 = ::Std_obj::_hx_int(((u5 * win->width) + win->x));
HXDLIN( 252)									int y24 = ::Std_obj::_hx_int(((v24 * win->height) + win->y));
HXDLIN( 252)									::Dynamic this193 = texture->image;
HXDLIN( 252)									int index34;
HXDLIN( 252)									if (texture->useVirtualPos) {
HXLINE( 252)										index34 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - texture->virtualY) * ( (Float)(texture->width) )) + x24) - texture->virtualX));
            									}
            									else {
HXLINE( 252)										index34 = ::Std_obj::_hx_int(( (Float)(((y24 * texture->width) + x24)) ));
            									}
HXDLIN( 252)									int c28 = ::iterMagic::Iimg_obj::get(this193,index34);
HXDLIN( 252)									int col11;
HXDLIN( 252)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)										col11 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            									}
            									else {
HXLINE( 252)										col11 = c28;
            									}
HXDLIN( 252)									{
HXLINE( 252)										int c29 = col11;
HXDLIN( 252)										bool _hx_tmp51;
HXDLIN( 252)										if ((((c29 >> 24) & 255) < 254)) {
HXLINE( 252)											_hx_tmp51 = pixelImage->transparent;
            										}
            										else {
HXLINE( 252)											_hx_tmp51 = false;
            										}
HXDLIN( 252)										if (_hx_tmp51) {
HXLINE( 252)											int location11;
HXDLIN( 252)											if (pixelImage->useVirtualPos) {
HXLINE( 252)												location11 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px5) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 252)												location11 = ::Std_obj::_hx_int(( (Float)(((py5 * pixelImage->width) + px5)) ));
            											}
HXDLIN( 252)											int this194 = ::iterMagic::Iimg_obj::get(pixelImage->image,location11);
HXDLIN( 252)											int this195;
HXDLIN( 252)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)												this195 = ((((((this194 >> 24) & 255) << 24) | ((this194 & 255) << 16)) | (((this194 >> 8) & 255) << 8)) | ((this194 >> 16) & 255));
            											}
            											else {
HXLINE( 252)												this195 = this194;
            											}
HXDLIN( 252)											Float a114;
HXDLIN( 252)											int this196 = ((this195 >> 24) & 255);
HXDLIN( 252)											if ((this196 == 0)) {
HXLINE( 252)												a114 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												a114 = (( (Float)(this196) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float r111;
HXDLIN( 252)											int this197 = ((this195 >> 16) & 255);
HXDLIN( 252)											if ((this197 == 0)) {
HXLINE( 252)												r111 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												r111 = (( (Float)(this197) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float g111;
HXDLIN( 252)											int this198 = ((this195 >> 8) & 255);
HXDLIN( 252)											if ((this198 == 0)) {
HXLINE( 252)												g111 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												g111 = (( (Float)(this198) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float b115;
HXDLIN( 252)											int this199 = (this195 & 255);
HXDLIN( 252)											if ((this199 == 0)) {
HXLINE( 252)												b115 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												b115 = (( (Float)(this199) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float a212;
HXDLIN( 252)											int this200 = ((col11 >> 24) & 255);
HXDLIN( 252)											if ((this200 == 0)) {
HXLINE( 252)												a212 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												a212 = (( (Float)(this200) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float r211;
HXDLIN( 252)											int this201 = ((col11 >> 16) & 255);
HXDLIN( 252)											if ((this201 == 0)) {
HXLINE( 252)												r211 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												r211 = (( (Float)(this201) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float g211;
HXDLIN( 252)											int this202 = ((col11 >> 8) & 255);
HXDLIN( 252)											if ((this202 == 0)) {
HXLINE( 252)												g211 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												g211 = (( (Float)(this202) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float b215;
HXDLIN( 252)											int this203 = (col11 & 255);
HXDLIN( 252)											if ((this203 == 0)) {
HXLINE( 252)												b215 = ((Float)0.);
            											}
            											else {
HXLINE( 252)												b215 = (( (Float)(this203) ) / ( (Float)(255) ));
            											}
HXDLIN( 252)											Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 252)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN( 252)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN( 252)											int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b215 * a212))));
HXDLIN( 252)											int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 252)											int blended11 = ((((a43 << 24) | (r31 << 16)) | (g31 << 8)) | b41);
HXDLIN( 252)											{
HXLINE( 252)												int _hx_tmp52;
HXDLIN( 252)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)													_hx_tmp52 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXLINE( 252)													_hx_tmp52 = blended11;
            												}
HXDLIN( 252)												::iterMagic::Iimg_obj::set(pixelImage->image,location11,_hx_tmp52);
            											}
            										}
            										else {
HXLINE( 252)											::Dynamic this204 = pixelImage->image;
HXDLIN( 252)											int index35;
HXDLIN( 252)											if (pixelImage->useVirtualPos) {
HXLINE( 252)												index35 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px5) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 252)												index35 = ::Std_obj::_hx_int(( (Float)(((py5 * pixelImage->width) + px5)) ));
            											}
HXDLIN( 252)											int _hx_tmp53;
HXDLIN( 252)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 252)												_hx_tmp53 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            											}
            											else {
HXLINE( 252)												_hx_tmp53 = c29;
            											}
HXDLIN( 252)											::iterMagic::Iimg_obj::set(this204,index35,_hx_tmp53);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 252)				if ((hasHit == false)) {
HXLINE( 252)					 ::pi_xy::algo::HitTri v25 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx1,y,cx1,topY,rightX,topY,true);
HXDLIN( 252)					if (hasUndo5) {
HXLINE( 252)						v25->undoImage = undoImage15;
HXDLIN( 252)						v25->undoX = xIter35->start;
HXDLIN( 252)						v25->undoY = yIter35->start;
            					}
            				}
            			}
HXDLIN( 252)			if ((hasHit == true)) {
HXLINE( 252)				 ::pi_xy::algo::HitQuad v26 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,rightX,y,bx1,y,cx1,topY,rightX,topY,true);
            			}
            		}
HXLINE( 258)		av = (top * sh);
HXLINE( 259)		bu = (left * sw);
HXLINE( 260)		cv = ((top + tall) * sh);
HXLINE( 261)		{
HXLINE( 261)			Float ay1 = (topY - ( (Float)(1) ));
HXDLIN( 261)			Float by1 = (topY - ( (Float)(1) ));
HXDLIN( 261)			Float cy1 = (bottomY + 1);
HXDLIN( 261)			{
HXLINE( 261)				Float au7 = ((Float)0.);
HXDLIN( 261)				Float av7 = av;
HXDLIN( 261)				Float bu7 = bu;
HXDLIN( 261)				Float bv6 = av;
HXDLIN( 261)				bool hasUndo6 = false;
HXDLIN( 261)				Float temp6 = au7;
HXLINE( 422)				au7 = bu7;
HXLINE( 423)				bu7 = temp6;
HXLINE( 424)				temp6 = av7;
HXLINE( 425)				av7 = bv6;
HXLINE( 426)				bv6 = temp6;
HXLINE( 261)				Float bcx6 = (leftX - x);
HXDLIN( 261)				Float bcy6 = (by1 - bottomY);
HXDLIN( 261)				Float acx6 = (x - x);
HXDLIN( 261)				Float acy6 = (ay1 - bottomY);
HXDLIN( 261)				Float dot116 = ((bcx6 * bcx6) + (bcy6 * bcy6));
HXDLIN( 261)				Float dot126 = ((bcx6 * acx6) + (bcy6 * acy6));
HXDLIN( 261)				Float dot226 = ((acx6 * acx6) + (acy6 * acy6));
HXDLIN( 261)				Float denom16 = (( (Float)(1) ) / ((dot116 * dot226) - (dot126 * dot126)));
HXDLIN( 261)				 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 261)				if ((x > leftX)) {
HXLINE( 261)					if ((x > x)) {
HXLINE( 261)						int min24;
HXDLIN( 261)						if ((leftX > x)) {
HXLINE( 261)							min24 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 261)							min24 = ::Math_obj::floor(leftX);
            						}
HXDLIN( 261)						int ii_min48 = min24;
HXDLIN( 261)						int ii_max48 = ::Math_obj::ceil(x);
HXDLIN( 261)						xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            					}
            					else {
HXLINE( 261)						int ii_min49 = ::Math_obj::floor(leftX);
HXDLIN( 261)						int ii_max49 = ::Math_obj::ceil(x);
HXDLIN( 261)						xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            					}
            				}
            				else {
HXLINE( 261)					if ((leftX > x)) {
HXLINE( 261)						int min25;
HXDLIN( 261)						if ((x > x)) {
HXLINE( 261)							min25 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 261)							min25 = ::Math_obj::ceil(x);
            						}
HXDLIN( 261)						int ii_min50 = min25;
HXDLIN( 261)						int ii_max50 = ::Math_obj::ceil(leftX);
HXDLIN( 261)						xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            					}
            					else {
HXLINE( 261)						int ii_min51 = ::Math_obj::floor(x);
HXDLIN( 261)						int ii_max51 = ::Math_obj::ceil(x);
HXDLIN( 261)						xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            					}
            				}
HXDLIN( 261)				 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 261)				if ((ay1 > by1)) {
HXLINE( 261)					if ((ay1 > bottomY)) {
HXLINE( 261)						int min26;
HXDLIN( 261)						if ((by1 > bottomY)) {
HXLINE( 261)							min26 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 261)							min26 = ::Math_obj::floor(by1);
            						}
HXDLIN( 261)						int ii_min52 = min26;
HXDLIN( 261)						int ii_max52 = ::Math_obj::ceil(ay1);
HXDLIN( 261)						yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            					}
            					else {
HXLINE( 261)						int ii_min53 = ::Math_obj::floor(by1);
HXDLIN( 261)						int ii_max53 = ::Math_obj::ceil(bottomY);
HXDLIN( 261)						yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            					}
            				}
            				else {
HXLINE( 261)					if ((by1 > bottomY)) {
HXLINE( 261)						int min27;
HXDLIN( 261)						if ((ay1 > bottomY)) {
HXLINE( 261)							min27 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 261)							min27 = ::Math_obj::ceil(ay1);
            						}
HXDLIN( 261)						int ii_min54 = min27;
HXDLIN( 261)						int ii_max54 = ::Math_obj::ceil(by1);
HXDLIN( 261)						yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            					}
            					else {
HXLINE( 261)						int ii_min55 = ::Math_obj::floor(ay1);
HXDLIN( 261)						int ii_max55 = ::Math_obj::ceil(bottomY);
HXDLIN( 261)						yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            					}
            				}
HXDLIN( 261)				 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 261)				if (hasUndo6) {
HXLINE( 261)					int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 261)					int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 261)					 ::Dynamic imageType6 = null();
HXDLIN( 261)					 ::pi_xy::ImageStruct this205 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 261)					if (::hx::IsNull( imageType6 )) {
HXLINE(  54)						imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 261)					::Dynamic undoImage19;
HXDLIN( 261)					switch((int)(( (int)(imageType6) ))){
            						case (int)0: {
HXLINE( 261)							 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::BytesImg b42 = byt6;
HXDLIN( 261)							{
HXLINE( 261)								b42->width = width6;
HXDLIN( 261)								b42->height = height6;
HXDLIN( 261)								b42->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 261)								b42->data = ::haxe::io::Bytes_obj::alloc((b42->length * 4));
HXDLIN( 261)								{
HXLINE( 261)									int len12 = b42->length;
HXDLIN( 261)									int w6 = 0;
HXDLIN( 261)									{
HXLINE( 261)										int _g120 = 0;
HXDLIN( 261)										int _g121 = b42->height;
HXDLIN( 261)										while((_g120 < _g121)){
HXLINE( 261)											_g120 = (_g120 + 1);
HXDLIN( 261)											int y25 = (_g120 - 1);
HXDLIN( 261)											{
HXLINE( 261)												int _g122 = 0;
HXDLIN( 261)												int _g123 = b42->width;
HXDLIN( 261)												while((_g122 < _g123)){
HXLINE( 261)													_g122 = (_g122 + 1);
HXDLIN( 261)													int x25 = (_g122 - 1);
HXDLIN( 261)													{
HXLINE( 261)														w6 = (w6 + 1);
HXDLIN( 261)														b42->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w6 = (w6 + 1);
HXDLIN( 261)														b42->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w6 = (w6 + 1);
HXDLIN( 261)														b42->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w6 = (w6 + 1);
HXDLIN( 261)														b42->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage19 = b42;
            						}
            						break;
            						case (int)1: {
HXLINE( 261)							 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::ArrIntImg a44 = arrI6;
HXDLIN( 261)							{
HXLINE( 261)								a44->width = width6;
HXDLIN( 261)								a44->height = height6;
HXDLIN( 261)								a44->data = ::Array_obj< int >::__new(0);
HXDLIN( 261)								a44->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 261)								{
HXLINE( 261)									int _g124 = 0;
HXDLIN( 261)									int _g125 = a44->length;
HXDLIN( 261)									while((_g124 < _g125)){
HXLINE( 261)										_g124 = (_g124 + 1);
HXDLIN( 261)										int i36 = (_g124 - 1);
HXDLIN( 261)										a44->data[i36] = 0;
            									}
            								}
            							}
HXDLIN( 261)							undoImage19 = a44;
            						}
            						break;
            						case (int)2: {
HXLINE( 261)							 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::U32ArrImg b43 = u32a6;
HXDLIN( 261)							{
HXLINE( 261)								b43->width = width6;
HXDLIN( 261)								b43->height = height6;
HXDLIN( 261)								b43->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 261)								int size6 = (b43->length * 4);
HXDLIN( 261)								b43->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 261)								{
HXLINE( 261)									int _g126 = 0;
HXDLIN( 261)									int _g127 = b43->length;
HXDLIN( 261)									while((_g126 < _g127)){
HXLINE( 261)										_g126 = (_g126 + 1);
HXDLIN( 261)										int i37 = (_g126 - 1);
HXDLIN( 261)										{
HXLINE( 261)											 ::haxe::io::ArrayBufferViewImpl this206 = b43->data;
HXDLIN( 261)											bool undoImage20;
HXDLIN( 261)											if ((i37 >= 0)) {
HXLINE( 261)												undoImage20 = (i37 < (this206->byteLength >> 2));
            											}
            											else {
HXLINE( 261)												undoImage20 = false;
            											}
HXDLIN( 261)											if (undoImage20) {
HXLINE( 261)												 ::haxe::io::Bytes _this6 = this206->bytes;
HXDLIN( 261)												int pos6 = ((i37 << 2) + this206->byteOffset);
HXDLIN( 261)												_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 261)												_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 261)												_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 261)												_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage19 = b43;
            						}
            						break;
            						case (int)3: {
HXLINE( 261)							 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::VecIntImg v27 = vec6;
HXDLIN( 261)							{
HXLINE( 261)								v27->width = width6;
HXDLIN( 261)								v27->height = height6;
HXDLIN( 261)								v27->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 261)								v27->data = ::Array_obj< int >::__new(v27->length);
HXDLIN( 261)								{
HXLINE( 261)									int _g128 = 0;
HXDLIN( 261)									int _g129 = v27->length;
HXDLIN( 261)									while((_g128 < _g129)){
HXLINE( 261)										_g128 = (_g128 + 1);
HXDLIN( 261)										int i38 = (_g128 - 1);
HXDLIN( 261)										v27->data->__unsafe_set(i38,0);
            									}
            								}
            							}
HXDLIN( 261)							undoImage19 = v27;
            						}
            						break;
            						case (int)4: {
HXLINE( 261)							 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::StackIntImg b44 = sInt6;
HXDLIN( 261)							{
HXLINE( 261)								b44->width = width6;
HXDLIN( 261)								b44->height = height6;
HXDLIN( 261)								b44->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 261)								b44->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 261)								{
HXLINE( 261)									int len13 = b44->length;
HXDLIN( 261)									 ::haxe::ds::GenericStack_Int d6 = b44->data;
HXDLIN( 261)									if (::hx::IsNull( d6->head )) {
HXLINE( 261)										int _g130 = 0;
HXDLIN( 261)										int _g131 = len13;
HXDLIN( 261)										while((_g130 < _g131)){
HXLINE( 261)											_g130 = (_g130 + 1);
HXDLIN( 261)											int i39 = (_g130 - 1);
HXDLIN( 261)											d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            										}
            									}
            									else {
HXLINE( 261)										int _g132 = 0;
HXDLIN( 261)										int _g133 = len13;
HXDLIN( 261)										while((_g132 < _g133)){
HXLINE( 261)											_g132 = (_g132 + 1);
HXDLIN( 261)											int i40 = (_g132 - 1);
HXDLIN( 261)											{
HXLINE( 261)												 ::haxe::ds::GenericCell_Int l6 = b44->data->head;
HXDLIN( 261)												 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 261)												{
HXLINE( 261)													int _g134 = 0;
HXDLIN( 261)													int _g135 = i40;
HXDLIN( 261)													while((_g134 < _g135)){
HXLINE( 261)														_g134 = (_g134 + 1);
HXDLIN( 261)														int i41 = (_g134 - 1);
HXLINE( 345)														prev6 = l6;
HXLINE( 346)														l6 = l6->next;
            													}
            												}
HXLINE( 261)												if (::hx::IsNull( prev6 )) {
HXLINE( 261)													b44->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 261)													l6 = null();
            												}
            												else {
HXLINE( 261)													prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 261)													l6 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage19 = b44;
            						}
            						break;
            					}
HXDLIN( 261)					this205->image = undoImage19;
HXDLIN( 261)					this205->width = width6;
HXDLIN( 261)					this205->height = height6;
HXDLIN( 261)					this205->imageType = ( (int)(imageType6) );
HXDLIN( 261)					undoImage18 = this205;
HXDLIN( 261)					{
HXLINE( 261)						int rectLeft6 = xIter36->start;
HXDLIN( 261)						int rectTop6 = yIter36->start;
HXDLIN( 261)						int rectRight6 = xIter36->max;
HXDLIN( 261)						bool forceClear6 = false;
HXDLIN( 261)						{
HXLINE( 261)							int _g136 = rectTop6;
HXDLIN( 261)							int _g137 = yIter36->max;
HXDLIN( 261)							while((_g136 < _g137)){
HXLINE( 261)								_g136 = (_g136 + 1);
HXDLIN( 261)								int dy7 = (_g136 - 1);
HXDLIN( 261)								{
HXLINE( 261)									int _g138 = rectLeft6;
HXDLIN( 261)									int _g139 = rectRight6;
HXDLIN( 261)									while((_g138 < _g139)){
HXLINE( 261)										_g138 = (_g138 + 1);
HXDLIN( 261)										int dx7 = (_g138 - 1);
HXDLIN( 261)										::Dynamic this207 = pixelImage->image;
HXDLIN( 261)										int index36;
HXDLIN( 261)										if (pixelImage->useVirtualPos) {
HXLINE( 261)											index36 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx7) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 261)											index36 = ::Std_obj::_hx_int(( (Float)(((dy7 * pixelImage->width) + dx7)) ));
            										}
HXDLIN( 261)										int c30 = ::iterMagic::Iimg_obj::get(this207,index36);
HXDLIN( 261)										int col12;
HXDLIN( 261)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)											col12 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            										}
            										else {
HXLINE( 261)											col12 = c30;
            										}
HXDLIN( 261)										bool _hx_tmp54;
HXDLIN( 261)										if (pixelImage->useMask) {
HXLINE( 261)											_hx_tmp54 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 261)											_hx_tmp54 = false;
            										}
HXDLIN( 261)										if (_hx_tmp54) {
HXLINE( 261)											 ::pi_xy::ImageStruct this208 = pixelImage->mask;
HXDLIN( 261)											::Dynamic this209 = this208->image;
HXDLIN( 261)											int index37;
HXDLIN( 261)											if (this208->useVirtualPos) {
HXLINE( 261)												index37 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this208->virtualY) * ( (Float)(this208->width) )) + dx7) - this208->virtualX));
            											}
            											else {
HXLINE( 261)												index37 = ::Std_obj::_hx_int(( (Float)(((dy7 * this208->width) + dx7)) ));
            											}
HXDLIN( 261)											int c31 = ::iterMagic::Iimg_obj::get(this209,index37);
HXDLIN( 261)											int v28;
HXDLIN( 261)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)												v28 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            											}
            											else {
HXLINE( 261)												v28 = c31;
            											}
HXDLIN( 261)											int maskPixel6 = v28;
HXDLIN( 261)											int this210 = col12;
HXDLIN( 261)											if ((maskPixel6 == 0)) {
HXLINE( 261)												col12 = this210;
            											}
            											else {
HXLINE( 261)												Float m06;
HXDLIN( 261)												int this211 = ((maskPixel6 >> 24) & 255);
HXDLIN( 261)												if ((this211 == 0)) {
HXLINE( 261)													m06 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m06 = (( (Float)(this211) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m16;
HXDLIN( 261)												int this212 = ((maskPixel6 >> 16) & 255);
HXDLIN( 261)												if ((this212 == 0)) {
HXLINE( 261)													m16 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m16 = (( (Float)(this212) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m26;
HXDLIN( 261)												int this213 = ((maskPixel6 >> 8) & 255);
HXDLIN( 261)												if ((this213 == 0)) {
HXLINE( 261)													m26 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m26 = (( (Float)(this213) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m36;
HXDLIN( 261)												int this214 = (maskPixel6 & 255);
HXDLIN( 261)												if ((this214 == 0)) {
HXLINE( 261)													m36 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m36 = (( (Float)(this214) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this210 >> 24) & 255)) )));
HXDLIN( 261)												int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this210 >> 16) & 255)) )));
HXDLIN( 261)												int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this210 >> 8) & 255)) )));
HXDLIN( 261)												int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this210 & 255)) )));
HXDLIN( 261)												col12 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 261)										if ((col12 != 0)) {
HXLINE( 261)											int x26 = (dx7 - rectLeft6);
HXDLIN( 261)											int y26 = (dy7 - rectTop6);
HXDLIN( 261)											int c32 = col12;
HXDLIN( 261)											bool _hx_tmp55;
HXDLIN( 261)											if ((((c32 >> 24) & 255) < 254)) {
HXLINE( 261)												_hx_tmp55 = undoImage18->transparent;
            											}
            											else {
HXLINE( 261)												_hx_tmp55 = false;
            											}
HXDLIN( 261)											if (_hx_tmp55) {
HXLINE( 261)												int location12;
HXDLIN( 261)												if (undoImage18->useVirtualPos) {
HXLINE( 261)													location12 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x26) - undoImage18->virtualX));
            												}
            												else {
HXLINE( 261)													location12 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage18->width) + x26)) ));
            												}
HXDLIN( 261)												int this215 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 261)												int this216;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													this216 = ((((((this215 >> 24) & 255) << 24) | ((this215 & 255) << 16)) | (((this215 >> 8) & 255) << 8)) | ((this215 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													this216 = this215;
            												}
HXDLIN( 261)												Float a115;
HXDLIN( 261)												int this217 = ((this216 >> 24) & 255);
HXDLIN( 261)												if ((this217 == 0)) {
HXLINE( 261)													a115 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a115 = (( (Float)(this217) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r112;
HXDLIN( 261)												int this218 = ((this216 >> 16) & 255);
HXDLIN( 261)												if ((this218 == 0)) {
HXLINE( 261)													r112 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r112 = (( (Float)(this218) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g112;
HXDLIN( 261)												int this219 = ((this216 >> 8) & 255);
HXDLIN( 261)												if ((this219 == 0)) {
HXLINE( 261)													g112 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g112 = (( (Float)(this219) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b116;
HXDLIN( 261)												int this220 = (this216 & 255);
HXDLIN( 261)												if ((this220 == 0)) {
HXLINE( 261)													b116 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b116 = (( (Float)(this220) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a213;
HXDLIN( 261)												int this221 = ((col12 >> 24) & 255);
HXDLIN( 261)												if ((this221 == 0)) {
HXLINE( 261)													a213 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a213 = (( (Float)(this221) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r212;
HXDLIN( 261)												int this222 = ((col12 >> 16) & 255);
HXDLIN( 261)												if ((this222 == 0)) {
HXLINE( 261)													r212 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r212 = (( (Float)(this222) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g212;
HXDLIN( 261)												int this223 = ((col12 >> 8) & 255);
HXDLIN( 261)												if ((this223 == 0)) {
HXLINE( 261)													g212 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g212 = (( (Float)(this223) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b216;
HXDLIN( 261)												int this224 = (col12 & 255);
HXDLIN( 261)												if ((this224 == 0)) {
HXLINE( 261)													b216 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b216 = (( (Float)(this224) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 261)												int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN( 261)												int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN( 261)												int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b216 * a213))));
HXDLIN( 261)												int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 261)												int blended12 = ((((a45 << 24) | (r32 << 16)) | (g32 << 8)) | b45);
HXDLIN( 261)												{
HXLINE( 261)													int _hx_tmp56;
HXDLIN( 261)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)														_hx_tmp56 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            													}
            													else {
HXLINE( 261)														_hx_tmp56 = blended12;
            													}
HXDLIN( 261)													::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp56);
            												}
            											}
            											else {
HXLINE( 261)												::Dynamic this225 = undoImage18->image;
HXDLIN( 261)												int index38;
HXDLIN( 261)												if (undoImage18->useVirtualPos) {
HXLINE( 261)													index38 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x26) - undoImage18->virtualX));
            												}
            												else {
HXLINE( 261)													index38 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage18->width) + x26)) ));
            												}
HXDLIN( 261)												int _hx_tmp57;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													_hx_tmp57 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													_hx_tmp57 = c32;
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this225,index38,_hx_tmp57);
            											}
            										}
            										else {
HXLINE( 261)											if (forceClear6) {
HXLINE( 261)												::Dynamic this226 = undoImage18->image;
HXDLIN( 261)												int x27 = (dx7 - rectLeft6);
HXDLIN( 261)												int y27 = (dy7 - rectTop6);
HXDLIN( 261)												int index39;
HXDLIN( 261)												if (undoImage18->useVirtualPos) {
HXLINE( 261)													index39 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x27) - undoImage18->virtualX));
            												}
            												else {
HXLINE( 261)													index39 = ::Std_obj::_hx_int(( (Float)(((y27 * undoImage18->width) + x27)) ));
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this226,index39,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 261)				{
HXLINE( 261)					int _g_min12 = xIter36->start;
HXDLIN( 261)					int _g_max12 = xIter36->max;
HXDLIN( 261)					while((_g_min12 < _g_max12)){
HXLINE( 261)						_g_min12 = (_g_min12 + 1);
HXDLIN( 261)						int px6 = (_g_min12 - 1);
HXDLIN( 261)						Float pcx6 = (( (Float)(px6) ) - x);
HXDLIN( 261)						{
HXLINE( 261)							int _g_min13 = yIter36->start;
HXDLIN( 261)							int _g_max13 = yIter36->max;
HXDLIN( 261)							while((_g_min13 < _g_max13)){
HXLINE( 261)								_g_min13 = (_g_min13 + 1);
HXDLIN( 261)								int py6 = (_g_min13 - 1);
HXDLIN( 261)								Float pcy6 = (( (Float)(py6) ) - bottomY);
HXDLIN( 261)								Float dot316 = ((pcx6 * bcx6) + (pcy6 * bcy6));
HXDLIN( 261)								Float dot326 = ((pcx6 * acx6) + (pcy6 * acy6));
HXDLIN( 261)								Float ratioA6 = (((dot226 * dot316) - (dot126 * dot326)) * denom16);
HXDLIN( 261)								Float ratioB6 = (((dot116 * dot326) - (dot126 * dot316)) * denom16);
HXDLIN( 261)								Float ratioC6 = ((((Float)1.0) - ratioB6) - ratioA6);
HXDLIN( 261)								bool _hx_tmp58;
HXDLIN( 261)								bool _hx_tmp59;
HXDLIN( 261)								if ((ratioA6 >= 0)) {
HXLINE( 261)									_hx_tmp59 = (ratioB6 >= 0);
            								}
            								else {
HXLINE( 261)									_hx_tmp59 = false;
            								}
HXDLIN( 261)								if (_hx_tmp59) {
HXLINE( 261)									_hx_tmp58 = (ratioC6 >= 0);
            								}
            								else {
HXLINE( 261)									_hx_tmp58 = false;
            								}
HXDLIN( 261)								if (_hx_tmp58) {
HXLINE( 261)									Float u6 = (((au7 * ratioA6) + (bu7 * ratioB6)) + (((Float)0.) * ratioC6));
HXDLIN( 261)									Float v29 = (((av7 * ratioA6) + (bv6 * ratioB6)) + (cv * ratioC6));
HXDLIN( 261)									int x28 = ::Std_obj::_hx_int(((u6 * win->width) + win->x));
HXDLIN( 261)									int y28 = ::Std_obj::_hx_int(((v29 * win->height) + win->y));
HXDLIN( 261)									::Dynamic this227 = texture->image;
HXDLIN( 261)									int index40;
HXDLIN( 261)									if (texture->useVirtualPos) {
HXLINE( 261)										index40 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - texture->virtualY) * ( (Float)(texture->width) )) + x28) - texture->virtualX));
            									}
            									else {
HXLINE( 261)										index40 = ::Std_obj::_hx_int(( (Float)(((y28 * texture->width) + x28)) ));
            									}
HXDLIN( 261)									int c33 = ::iterMagic::Iimg_obj::get(this227,index40);
HXDLIN( 261)									int col13;
HXDLIN( 261)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)										col13 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            									}
            									else {
HXLINE( 261)										col13 = c33;
            									}
HXDLIN( 261)									{
HXLINE( 261)										int c34 = col13;
HXDLIN( 261)										bool _hx_tmp60;
HXDLIN( 261)										if ((((c34 >> 24) & 255) < 254)) {
HXLINE( 261)											_hx_tmp60 = pixelImage->transparent;
            										}
            										else {
HXLINE( 261)											_hx_tmp60 = false;
            										}
HXDLIN( 261)										if (_hx_tmp60) {
HXLINE( 261)											int location13;
HXDLIN( 261)											if (pixelImage->useVirtualPos) {
HXLINE( 261)												location13 = ::Std_obj::_hx_int(((((( (Float)(py6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px6) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 261)												location13 = ::Std_obj::_hx_int(( (Float)(((py6 * pixelImage->width) + px6)) ));
            											}
HXDLIN( 261)											int this228 = ::iterMagic::Iimg_obj::get(pixelImage->image,location13);
HXDLIN( 261)											int this229;
HXDLIN( 261)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)												this229 = ((((((this228 >> 24) & 255) << 24) | ((this228 & 255) << 16)) | (((this228 >> 8) & 255) << 8)) | ((this228 >> 16) & 255));
            											}
            											else {
HXLINE( 261)												this229 = this228;
            											}
HXDLIN( 261)											Float a116;
HXDLIN( 261)											int this230 = ((this229 >> 24) & 255);
HXDLIN( 261)											if ((this230 == 0)) {
HXLINE( 261)												a116 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												a116 = (( (Float)(this230) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float r113;
HXDLIN( 261)											int this231 = ((this229 >> 16) & 255);
HXDLIN( 261)											if ((this231 == 0)) {
HXLINE( 261)												r113 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												r113 = (( (Float)(this231) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float g113;
HXDLIN( 261)											int this232 = ((this229 >> 8) & 255);
HXDLIN( 261)											if ((this232 == 0)) {
HXLINE( 261)												g113 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												g113 = (( (Float)(this232) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float b117;
HXDLIN( 261)											int this233 = (this229 & 255);
HXDLIN( 261)											if ((this233 == 0)) {
HXLINE( 261)												b117 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												b117 = (( (Float)(this233) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float a214;
HXDLIN( 261)											int this234 = ((col13 >> 24) & 255);
HXDLIN( 261)											if ((this234 == 0)) {
HXLINE( 261)												a214 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												a214 = (( (Float)(this234) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float r213;
HXDLIN( 261)											int this235 = ((col13 >> 16) & 255);
HXDLIN( 261)											if ((this235 == 0)) {
HXLINE( 261)												r213 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												r213 = (( (Float)(this235) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float g213;
HXDLIN( 261)											int this236 = ((col13 >> 8) & 255);
HXDLIN( 261)											if ((this236 == 0)) {
HXLINE( 261)												g213 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												g213 = (( (Float)(this236) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float b217;
HXDLIN( 261)											int this237 = (col13 & 255);
HXDLIN( 261)											if ((this237 == 0)) {
HXLINE( 261)												b217 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												b217 = (( (Float)(this237) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN( 261)											int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN( 261)											int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN( 261)											int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b217 * a214))));
HXDLIN( 261)											int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 261)											int blended13 = ((((a46 << 24) | (r33 << 16)) | (g33 << 8)) | b46);
HXDLIN( 261)											{
HXLINE( 261)												int _hx_tmp61;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													_hx_tmp61 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													_hx_tmp61 = blended13;
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(pixelImage->image,location13,_hx_tmp61);
            											}
            										}
            										else {
HXLINE( 261)											::Dynamic this238 = pixelImage->image;
HXDLIN( 261)											int index41;
HXDLIN( 261)											if (pixelImage->useVirtualPos) {
HXLINE( 261)												index41 = ::Std_obj::_hx_int(((((( (Float)(py6) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px6) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 261)												index41 = ::Std_obj::_hx_int(( (Float)(((py6 * pixelImage->width) + px6)) ));
            											}
HXDLIN( 261)											int _hx_tmp62;
HXDLIN( 261)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)												_hx_tmp62 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            											}
            											else {
HXLINE( 261)												_hx_tmp62 = c34;
            											}
HXDLIN( 261)											::iterMagic::Iimg_obj::set(this238,index41,_hx_tmp62);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 261)				if ((hasHit == false)) {
HXLINE( 261)					 ::pi_xy::algo::HitTri v30 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x,ay1,leftX,by1,x,bottomY,true);
HXDLIN( 261)					if (hasUndo6) {
HXLINE( 261)						v30->undoImage = undoImage18;
HXDLIN( 261)						v30->undoX = xIter36->start;
HXDLIN( 261)						v30->undoY = yIter36->start;
            					}
            				}
            			}
HXDLIN( 261)			{
HXLINE( 261)				Float au8 = bu;
HXDLIN( 261)				Float av8 = av;
HXDLIN( 261)				Float bu8 = bu;
HXDLIN( 261)				Float bv7 = cv;
HXDLIN( 261)				bool hasUndo7 = false;
HXDLIN( 261)				Float temp7 = au8;
HXLINE( 422)				au8 = bu8;
HXLINE( 423)				bu8 = temp7;
HXLINE( 424)				temp7 = av8;
HXLINE( 425)				av8 = bv7;
HXLINE( 426)				bv7 = temp7;
HXLINE( 261)				Float bcx7 = (leftX - x);
HXDLIN( 261)				Float bcy7 = (cy1 - bottomY);
HXDLIN( 261)				Float acx7 = (leftX - x);
HXDLIN( 261)				Float acy7 = (by1 - bottomY);
HXDLIN( 261)				Float dot117 = ((bcx7 * bcx7) + (bcy7 * bcy7));
HXDLIN( 261)				Float dot127 = ((bcx7 * acx7) + (bcy7 * acy7));
HXDLIN( 261)				Float dot227 = ((acx7 * acx7) + (acy7 * acy7));
HXDLIN( 261)				Float denom17 = (( (Float)(1) ) / ((dot117 * dot227) - (dot127 * dot127)));
HXDLIN( 261)				 ::pi_xy::iter::IntIterStart xIter37;
HXDLIN( 261)				if ((leftX > leftX)) {
HXLINE( 261)					if ((leftX > x)) {
HXLINE( 261)						int min28;
HXDLIN( 261)						if ((leftX > x)) {
HXLINE( 261)							min28 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 261)							min28 = ::Math_obj::floor(leftX);
            						}
HXDLIN( 261)						int ii_min56 = min28;
HXDLIN( 261)						int ii_max56 = ::Math_obj::ceil(leftX);
HXDLIN( 261)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            					}
            					else {
HXLINE( 261)						int ii_min57 = ::Math_obj::floor(leftX);
HXDLIN( 261)						int ii_max57 = ::Math_obj::ceil(x);
HXDLIN( 261)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            					}
            				}
            				else {
HXLINE( 261)					if ((leftX > x)) {
HXLINE( 261)						int min29;
HXDLIN( 261)						if ((leftX > x)) {
HXLINE( 261)							min29 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 261)							min29 = ::Math_obj::ceil(leftX);
            						}
HXDLIN( 261)						int ii_min58 = min29;
HXDLIN( 261)						int ii_max58 = ::Math_obj::ceil(leftX);
HXDLIN( 261)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            					}
            					else {
HXLINE( 261)						int ii_min59 = ::Math_obj::floor(leftX);
HXDLIN( 261)						int ii_max59 = ::Math_obj::ceil(x);
HXDLIN( 261)						xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            					}
            				}
HXDLIN( 261)				 ::pi_xy::iter::IntIterStart yIter37;
HXDLIN( 261)				if ((by1 > cy1)) {
HXLINE( 261)					if ((by1 > bottomY)) {
HXLINE( 261)						int min30;
HXDLIN( 261)						if ((cy1 > bottomY)) {
HXLINE( 261)							min30 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 261)							min30 = ::Math_obj::floor(cy1);
            						}
HXDLIN( 261)						int ii_min60 = min30;
HXDLIN( 261)						int ii_max60 = ::Math_obj::ceil(by1);
HXDLIN( 261)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            					}
            					else {
HXLINE( 261)						int ii_min61 = ::Math_obj::floor(cy1);
HXDLIN( 261)						int ii_max61 = ::Math_obj::ceil(bottomY);
HXDLIN( 261)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            					}
            				}
            				else {
HXLINE( 261)					if ((cy1 > bottomY)) {
HXLINE( 261)						int min31;
HXDLIN( 261)						if ((by1 > bottomY)) {
HXLINE( 261)							min31 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 261)							min31 = ::Math_obj::ceil(by1);
            						}
HXDLIN( 261)						int ii_min62 = min31;
HXDLIN( 261)						int ii_max62 = ::Math_obj::ceil(cy1);
HXDLIN( 261)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            					}
            					else {
HXLINE( 261)						int ii_min63 = ::Math_obj::floor(by1);
HXDLIN( 261)						int ii_max63 = ::Math_obj::ceil(bottomY);
HXDLIN( 261)						yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            					}
            				}
HXDLIN( 261)				 ::pi_xy::ImageStruct undoImage21 = null();
HXDLIN( 261)				if (hasUndo7) {
HXLINE( 261)					int width7 = ((xIter37->max - xIter37->start) + 1);
HXDLIN( 261)					int height7 = ((yIter37->max - yIter37->start) + 1);
HXDLIN( 261)					 ::Dynamic imageType7 = null();
HXDLIN( 261)					 ::pi_xy::ImageStruct this239 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 261)					if (::hx::IsNull( imageType7 )) {
HXLINE(  54)						imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 261)					::Dynamic undoImage22;
HXDLIN( 261)					switch((int)(( (int)(imageType7) ))){
            						case (int)0: {
HXLINE( 261)							 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::BytesImg b47 = byt7;
HXDLIN( 261)							{
HXLINE( 261)								b47->width = width7;
HXDLIN( 261)								b47->height = height7;
HXDLIN( 261)								b47->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 261)								b47->data = ::haxe::io::Bytes_obj::alloc((b47->length * 4));
HXDLIN( 261)								{
HXLINE( 261)									int len14 = b47->length;
HXDLIN( 261)									int w7 = 0;
HXDLIN( 261)									{
HXLINE( 261)										int _g140 = 0;
HXDLIN( 261)										int _g141 = b47->height;
HXDLIN( 261)										while((_g140 < _g141)){
HXLINE( 261)											_g140 = (_g140 + 1);
HXDLIN( 261)											int y29 = (_g140 - 1);
HXDLIN( 261)											{
HXLINE( 261)												int _g142 = 0;
HXDLIN( 261)												int _g143 = b47->width;
HXDLIN( 261)												while((_g142 < _g143)){
HXLINE( 261)													_g142 = (_g142 + 1);
HXDLIN( 261)													int x29 = (_g142 - 1);
HXDLIN( 261)													{
HXLINE( 261)														w7 = (w7 + 1);
HXDLIN( 261)														b47->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w7 = (w7 + 1);
HXDLIN( 261)														b47->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w7 = (w7 + 1);
HXDLIN( 261)														b47->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 261)													{
HXLINE( 261)														w7 = (w7 + 1);
HXDLIN( 261)														b47->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage22 = b47;
            						}
            						break;
            						case (int)1: {
HXLINE( 261)							 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::ArrIntImg a47 = arrI7;
HXDLIN( 261)							{
HXLINE( 261)								a47->width = width7;
HXDLIN( 261)								a47->height = height7;
HXDLIN( 261)								a47->data = ::Array_obj< int >::__new(0);
HXDLIN( 261)								a47->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 261)								{
HXLINE( 261)									int _g144 = 0;
HXDLIN( 261)									int _g145 = a47->length;
HXDLIN( 261)									while((_g144 < _g145)){
HXLINE( 261)										_g144 = (_g144 + 1);
HXDLIN( 261)										int i42 = (_g144 - 1);
HXDLIN( 261)										a47->data[i42] = 0;
            									}
            								}
            							}
HXDLIN( 261)							undoImage22 = a47;
            						}
            						break;
            						case (int)2: {
HXLINE( 261)							 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::U32ArrImg b48 = u32a7;
HXDLIN( 261)							{
HXLINE( 261)								b48->width = width7;
HXDLIN( 261)								b48->height = height7;
HXDLIN( 261)								b48->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 261)								int size7 = (b48->length * 4);
HXDLIN( 261)								b48->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN( 261)								{
HXLINE( 261)									int _g146 = 0;
HXDLIN( 261)									int _g147 = b48->length;
HXDLIN( 261)									while((_g146 < _g147)){
HXLINE( 261)										_g146 = (_g146 + 1);
HXDLIN( 261)										int i43 = (_g146 - 1);
HXDLIN( 261)										{
HXLINE( 261)											 ::haxe::io::ArrayBufferViewImpl this240 = b48->data;
HXDLIN( 261)											bool undoImage23;
HXDLIN( 261)											if ((i43 >= 0)) {
HXLINE( 261)												undoImage23 = (i43 < (this240->byteLength >> 2));
            											}
            											else {
HXLINE( 261)												undoImage23 = false;
            											}
HXDLIN( 261)											if (undoImage23) {
HXLINE( 261)												 ::haxe::io::Bytes _this7 = this240->bytes;
HXDLIN( 261)												int pos7 = ((i43 << 2) + this240->byteOffset);
HXDLIN( 261)												_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN( 261)												_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN( 261)												_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN( 261)												_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage22 = b48;
            						}
            						break;
            						case (int)3: {
HXLINE( 261)							 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::VecIntImg v31 = vec7;
HXDLIN( 261)							{
HXLINE( 261)								v31->width = width7;
HXDLIN( 261)								v31->height = height7;
HXDLIN( 261)								v31->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 261)								v31->data = ::Array_obj< int >::__new(v31->length);
HXDLIN( 261)								{
HXLINE( 261)									int _g148 = 0;
HXDLIN( 261)									int _g149 = v31->length;
HXDLIN( 261)									while((_g148 < _g149)){
HXLINE( 261)										_g148 = (_g148 + 1);
HXDLIN( 261)										int i44 = (_g148 - 1);
HXDLIN( 261)										v31->data->__unsafe_set(i44,0);
            									}
            								}
            							}
HXDLIN( 261)							undoImage22 = v31;
            						}
            						break;
            						case (int)4: {
HXLINE( 261)							 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)							 ::iterMagic::StackIntImg b49 = sInt7;
HXDLIN( 261)							{
HXLINE( 261)								b49->width = width7;
HXDLIN( 261)								b49->height = height7;
HXDLIN( 261)								b49->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN( 261)								b49->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 261)								{
HXLINE( 261)									int len15 = b49->length;
HXDLIN( 261)									 ::haxe::ds::GenericStack_Int d7 = b49->data;
HXDLIN( 261)									if (::hx::IsNull( d7->head )) {
HXLINE( 261)										int _g150 = 0;
HXDLIN( 261)										int _g151 = len15;
HXDLIN( 261)										while((_g150 < _g151)){
HXLINE( 261)											_g150 = (_g150 + 1);
HXDLIN( 261)											int i45 = (_g150 - 1);
HXDLIN( 261)											d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            										}
            									}
            									else {
HXLINE( 261)										int _g152 = 0;
HXDLIN( 261)										int _g153 = len15;
HXDLIN( 261)										while((_g152 < _g153)){
HXLINE( 261)											_g152 = (_g152 + 1);
HXDLIN( 261)											int i46 = (_g152 - 1);
HXDLIN( 261)											{
HXLINE( 261)												 ::haxe::ds::GenericCell_Int l7 = b49->data->head;
HXDLIN( 261)												 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN( 261)												{
HXLINE( 261)													int _g154 = 0;
HXDLIN( 261)													int _g155 = i46;
HXDLIN( 261)													while((_g154 < _g155)){
HXLINE( 261)														_g154 = (_g154 + 1);
HXDLIN( 261)														int i47 = (_g154 - 1);
HXLINE( 345)														prev7 = l7;
HXLINE( 346)														l7 = l7->next;
            													}
            												}
HXLINE( 261)												if (::hx::IsNull( prev7 )) {
HXLINE( 261)													b49->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 261)													l7 = null();
            												}
            												else {
HXLINE( 261)													prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN( 261)													l7 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 261)							undoImage22 = b49;
            						}
            						break;
            					}
HXDLIN( 261)					this239->image = undoImage22;
HXDLIN( 261)					this239->width = width7;
HXDLIN( 261)					this239->height = height7;
HXDLIN( 261)					this239->imageType = ( (int)(imageType7) );
HXDLIN( 261)					undoImage21 = this239;
HXDLIN( 261)					{
HXLINE( 261)						int rectLeft7 = xIter37->start;
HXDLIN( 261)						int rectTop7 = yIter37->start;
HXDLIN( 261)						int rectRight7 = xIter37->max;
HXDLIN( 261)						bool forceClear7 = false;
HXDLIN( 261)						{
HXLINE( 261)							int _g156 = rectTop7;
HXDLIN( 261)							int _g157 = yIter37->max;
HXDLIN( 261)							while((_g156 < _g157)){
HXLINE( 261)								_g156 = (_g156 + 1);
HXDLIN( 261)								int dy8 = (_g156 - 1);
HXDLIN( 261)								{
HXLINE( 261)									int _g158 = rectLeft7;
HXDLIN( 261)									int _g159 = rectRight7;
HXDLIN( 261)									while((_g158 < _g159)){
HXLINE( 261)										_g158 = (_g158 + 1);
HXDLIN( 261)										int dx8 = (_g158 - 1);
HXDLIN( 261)										::Dynamic this241 = pixelImage->image;
HXDLIN( 261)										int index42;
HXDLIN( 261)										if (pixelImage->useVirtualPos) {
HXLINE( 261)											index42 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx8) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 261)											index42 = ::Std_obj::_hx_int(( (Float)(((dy8 * pixelImage->width) + dx8)) ));
            										}
HXDLIN( 261)										int c35 = ::iterMagic::Iimg_obj::get(this241,index42);
HXDLIN( 261)										int col14;
HXDLIN( 261)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)											col14 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXLINE( 261)											col14 = c35;
            										}
HXDLIN( 261)										bool _hx_tmp63;
HXDLIN( 261)										if (pixelImage->useMask) {
HXLINE( 261)											_hx_tmp63 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 261)											_hx_tmp63 = false;
            										}
HXDLIN( 261)										if (_hx_tmp63) {
HXLINE( 261)											 ::pi_xy::ImageStruct this242 = pixelImage->mask;
HXDLIN( 261)											::Dynamic this243 = this242->image;
HXDLIN( 261)											int index43;
HXDLIN( 261)											if (this242->useVirtualPos) {
HXLINE( 261)												index43 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this242->virtualY) * ( (Float)(this242->width) )) + dx8) - this242->virtualX));
            											}
            											else {
HXLINE( 261)												index43 = ::Std_obj::_hx_int(( (Float)(((dy8 * this242->width) + dx8)) ));
            											}
HXDLIN( 261)											int c36 = ::iterMagic::Iimg_obj::get(this243,index43);
HXDLIN( 261)											int v32;
HXDLIN( 261)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)												v32 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            											}
            											else {
HXLINE( 261)												v32 = c36;
            											}
HXDLIN( 261)											int maskPixel7 = v32;
HXDLIN( 261)											int this244 = col14;
HXDLIN( 261)											if ((maskPixel7 == 0)) {
HXLINE( 261)												col14 = this244;
            											}
            											else {
HXLINE( 261)												Float m07;
HXDLIN( 261)												int this245 = ((maskPixel7 >> 24) & 255);
HXDLIN( 261)												if ((this245 == 0)) {
HXLINE( 261)													m07 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m07 = (( (Float)(this245) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m17;
HXDLIN( 261)												int this246 = ((maskPixel7 >> 16) & 255);
HXDLIN( 261)												if ((this246 == 0)) {
HXLINE( 261)													m17 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m17 = (( (Float)(this246) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m27;
HXDLIN( 261)												int this247 = ((maskPixel7 >> 8) & 255);
HXDLIN( 261)												if ((this247 == 0)) {
HXLINE( 261)													m27 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m27 = (( (Float)(this247) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float m37;
HXDLIN( 261)												int this248 = (maskPixel7 & 255);
HXDLIN( 261)												if ((this248 == 0)) {
HXLINE( 261)													m37 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													m37 = (( (Float)(this248) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this244 >> 24) & 255)) )));
HXDLIN( 261)												int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this244 >> 16) & 255)) )));
HXDLIN( 261)												int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this244 >> 8) & 255)) )));
HXDLIN( 261)												int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this244 & 255)) )));
HXDLIN( 261)												col14 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 261)										if ((col14 != 0)) {
HXLINE( 261)											int x30 = (dx8 - rectLeft7);
HXDLIN( 261)											int y30 = (dy8 - rectTop7);
HXDLIN( 261)											int c37 = col14;
HXDLIN( 261)											bool _hx_tmp64;
HXDLIN( 261)											if ((((c37 >> 24) & 255) < 254)) {
HXLINE( 261)												_hx_tmp64 = undoImage21->transparent;
            											}
            											else {
HXLINE( 261)												_hx_tmp64 = false;
            											}
HXDLIN( 261)											if (_hx_tmp64) {
HXLINE( 261)												int location14;
HXDLIN( 261)												if (undoImage21->useVirtualPos) {
HXLINE( 261)													location14 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x30) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 261)													location14 = ::Std_obj::_hx_int(( (Float)(((y30 * undoImage21->width) + x30)) ));
            												}
HXDLIN( 261)												int this249 = ::iterMagic::Iimg_obj::get(undoImage21->image,location14);
HXDLIN( 261)												int this250;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													this250 = ((((((this249 >> 24) & 255) << 24) | ((this249 & 255) << 16)) | (((this249 >> 8) & 255) << 8)) | ((this249 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													this250 = this249;
            												}
HXDLIN( 261)												Float a117;
HXDLIN( 261)												int this251 = ((this250 >> 24) & 255);
HXDLIN( 261)												if ((this251 == 0)) {
HXLINE( 261)													a117 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a117 = (( (Float)(this251) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r114;
HXDLIN( 261)												int this252 = ((this250 >> 16) & 255);
HXDLIN( 261)												if ((this252 == 0)) {
HXLINE( 261)													r114 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r114 = (( (Float)(this252) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g114;
HXDLIN( 261)												int this253 = ((this250 >> 8) & 255);
HXDLIN( 261)												if ((this253 == 0)) {
HXLINE( 261)													g114 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g114 = (( (Float)(this253) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b118;
HXDLIN( 261)												int this254 = (this250 & 255);
HXDLIN( 261)												if ((this254 == 0)) {
HXLINE( 261)													b118 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b118 = (( (Float)(this254) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a215;
HXDLIN( 261)												int this255 = ((col14 >> 24) & 255);
HXDLIN( 261)												if ((this255 == 0)) {
HXLINE( 261)													a215 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													a215 = (( (Float)(this255) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float r214;
HXDLIN( 261)												int this256 = ((col14 >> 16) & 255);
HXDLIN( 261)												if ((this256 == 0)) {
HXLINE( 261)													r214 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													r214 = (( (Float)(this256) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float g214;
HXDLIN( 261)												int this257 = ((col14 >> 8) & 255);
HXDLIN( 261)												if ((this257 == 0)) {
HXLINE( 261)													g214 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													g214 = (( (Float)(this257) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float b218;
HXDLIN( 261)												int this258 = (col14 & 255);
HXDLIN( 261)												if ((this258 == 0)) {
HXLINE( 261)													b218 = ((Float)0.);
            												}
            												else {
HXLINE( 261)													b218 = (( (Float)(this258) ) / ( (Float)(255) ));
            												}
HXDLIN( 261)												Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN( 261)												int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN( 261)												int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN( 261)												int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b218 * a215))));
HXDLIN( 261)												int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 261)												int blended14 = ((((a48 << 24) | (r34 << 16)) | (g34 << 8)) | b50);
HXDLIN( 261)												{
HXLINE( 261)													int _hx_tmp65;
HXDLIN( 261)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)														_hx_tmp65 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            													}
            													else {
HXLINE( 261)														_hx_tmp65 = blended14;
            													}
HXDLIN( 261)													::iterMagic::Iimg_obj::set(undoImage21->image,location14,_hx_tmp65);
            												}
            											}
            											else {
HXLINE( 261)												::Dynamic this259 = undoImage21->image;
HXDLIN( 261)												int index44;
HXDLIN( 261)												if (undoImage21->useVirtualPos) {
HXLINE( 261)													index44 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x30) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 261)													index44 = ::Std_obj::_hx_int(( (Float)(((y30 * undoImage21->width) + x30)) ));
            												}
HXDLIN( 261)												int _hx_tmp66;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													_hx_tmp66 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													_hx_tmp66 = c37;
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this259,index44,_hx_tmp66);
            											}
            										}
            										else {
HXLINE( 261)											if (forceClear7) {
HXLINE( 261)												::Dynamic this260 = undoImage21->image;
HXDLIN( 261)												int x31 = (dx8 - rectLeft7);
HXDLIN( 261)												int y31 = (dy8 - rectTop7);
HXDLIN( 261)												int index45;
HXDLIN( 261)												if (undoImage21->useVirtualPos) {
HXLINE( 261)													index45 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x31) - undoImage21->virtualX));
            												}
            												else {
HXLINE( 261)													index45 = ::Std_obj::_hx_int(( (Float)(((y31 * undoImage21->width) + x31)) ));
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(this260,index45,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 261)				{
HXLINE( 261)					int _g_min14 = xIter37->start;
HXDLIN( 261)					int _g_max14 = xIter37->max;
HXDLIN( 261)					while((_g_min14 < _g_max14)){
HXLINE( 261)						_g_min14 = (_g_min14 + 1);
HXDLIN( 261)						int px7 = (_g_min14 - 1);
HXDLIN( 261)						Float pcx7 = (( (Float)(px7) ) - x);
HXDLIN( 261)						{
HXLINE( 261)							int _g_min15 = yIter37->start;
HXDLIN( 261)							int _g_max15 = yIter37->max;
HXDLIN( 261)							while((_g_min15 < _g_max15)){
HXLINE( 261)								_g_min15 = (_g_min15 + 1);
HXDLIN( 261)								int py7 = (_g_min15 - 1);
HXDLIN( 261)								Float pcy7 = (( (Float)(py7) ) - bottomY);
HXDLIN( 261)								Float dot317 = ((pcx7 * bcx7) + (pcy7 * bcy7));
HXDLIN( 261)								Float dot327 = ((pcx7 * acx7) + (pcy7 * acy7));
HXDLIN( 261)								Float ratioA7 = (((dot227 * dot317) - (dot127 * dot327)) * denom17);
HXDLIN( 261)								Float ratioB7 = (((dot117 * dot327) - (dot127 * dot317)) * denom17);
HXDLIN( 261)								Float ratioC7 = ((((Float)1.0) - ratioB7) - ratioA7);
HXDLIN( 261)								bool _hx_tmp67;
HXDLIN( 261)								bool _hx_tmp68;
HXDLIN( 261)								if ((ratioA7 >= 0)) {
HXLINE( 261)									_hx_tmp68 = (ratioB7 >= 0);
            								}
            								else {
HXLINE( 261)									_hx_tmp68 = false;
            								}
HXDLIN( 261)								if (_hx_tmp68) {
HXLINE( 261)									_hx_tmp67 = (ratioC7 >= 0);
            								}
            								else {
HXLINE( 261)									_hx_tmp67 = false;
            								}
HXDLIN( 261)								if (_hx_tmp67) {
HXLINE( 261)									Float u7 = (((au8 * ratioA7) + (bu8 * ratioB7)) + (((Float)0.) * ratioC7));
HXDLIN( 261)									Float v33 = (((av8 * ratioA7) + (bv7 * ratioB7)) + (cv * ratioC7));
HXDLIN( 261)									int x32 = ::Std_obj::_hx_int(((u7 * win->width) + win->x));
HXDLIN( 261)									int y32 = ::Std_obj::_hx_int(((v33 * win->height) + win->y));
HXDLIN( 261)									::Dynamic this261 = texture->image;
HXDLIN( 261)									int index46;
HXDLIN( 261)									if (texture->useVirtualPos) {
HXLINE( 261)										index46 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - texture->virtualY) * ( (Float)(texture->width) )) + x32) - texture->virtualX));
            									}
            									else {
HXLINE( 261)										index46 = ::Std_obj::_hx_int(( (Float)(((y32 * texture->width) + x32)) ));
            									}
HXDLIN( 261)									int c38 = ::iterMagic::Iimg_obj::get(this261,index46);
HXDLIN( 261)									int col15;
HXDLIN( 261)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)										col15 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            									}
            									else {
HXLINE( 261)										col15 = c38;
            									}
HXDLIN( 261)									{
HXLINE( 261)										int c39 = col15;
HXDLIN( 261)										bool _hx_tmp69;
HXDLIN( 261)										if ((((c39 >> 24) & 255) < 254)) {
HXLINE( 261)											_hx_tmp69 = pixelImage->transparent;
            										}
            										else {
HXLINE( 261)											_hx_tmp69 = false;
            										}
HXDLIN( 261)										if (_hx_tmp69) {
HXLINE( 261)											int location15;
HXDLIN( 261)											if (pixelImage->useVirtualPos) {
HXLINE( 261)												location15 = ::Std_obj::_hx_int(((((( (Float)(py7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px7) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 261)												location15 = ::Std_obj::_hx_int(( (Float)(((py7 * pixelImage->width) + px7)) ));
            											}
HXDLIN( 261)											int this262 = ::iterMagic::Iimg_obj::get(pixelImage->image,location15);
HXDLIN( 261)											int this263;
HXDLIN( 261)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)												this263 = ((((((this262 >> 24) & 255) << 24) | ((this262 & 255) << 16)) | (((this262 >> 8) & 255) << 8)) | ((this262 >> 16) & 255));
            											}
            											else {
HXLINE( 261)												this263 = this262;
            											}
HXDLIN( 261)											Float a118;
HXDLIN( 261)											int this264 = ((this263 >> 24) & 255);
HXDLIN( 261)											if ((this264 == 0)) {
HXLINE( 261)												a118 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												a118 = (( (Float)(this264) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float r115;
HXDLIN( 261)											int this265 = ((this263 >> 16) & 255);
HXDLIN( 261)											if ((this265 == 0)) {
HXLINE( 261)												r115 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												r115 = (( (Float)(this265) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float g115;
HXDLIN( 261)											int this266 = ((this263 >> 8) & 255);
HXDLIN( 261)											if ((this266 == 0)) {
HXLINE( 261)												g115 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												g115 = (( (Float)(this266) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float b119;
HXDLIN( 261)											int this267 = (this263 & 255);
HXDLIN( 261)											if ((this267 == 0)) {
HXLINE( 261)												b119 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												b119 = (( (Float)(this267) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float a216;
HXDLIN( 261)											int this268 = ((col15 >> 24) & 255);
HXDLIN( 261)											if ((this268 == 0)) {
HXLINE( 261)												a216 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												a216 = (( (Float)(this268) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float r215;
HXDLIN( 261)											int this269 = ((col15 >> 16) & 255);
HXDLIN( 261)											if ((this269 == 0)) {
HXLINE( 261)												r215 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												r215 = (( (Float)(this269) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float g215;
HXDLIN( 261)											int this270 = ((col15 >> 8) & 255);
HXDLIN( 261)											if ((this270 == 0)) {
HXLINE( 261)												g215 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												g215 = (( (Float)(this270) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float b219;
HXDLIN( 261)											int this271 = (col15 & 255);
HXDLIN( 261)											if ((this271 == 0)) {
HXLINE( 261)												b219 = ((Float)0.);
            											}
            											else {
HXLINE( 261)												b219 = (( (Float)(this271) ) / ( (Float)(255) ));
            											}
HXDLIN( 261)											Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN( 261)											int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN( 261)											int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN( 261)											int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a315) + (b219 * a216))));
HXDLIN( 261)											int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 261)											int blended15 = ((((a49 << 24) | (r35 << 16)) | (g35 << 8)) | b51);
HXDLIN( 261)											{
HXLINE( 261)												int _hx_tmp70;
HXDLIN( 261)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)													_hx_tmp70 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            												}
            												else {
HXLINE( 261)													_hx_tmp70 = blended15;
            												}
HXDLIN( 261)												::iterMagic::Iimg_obj::set(pixelImage->image,location15,_hx_tmp70);
            											}
            										}
            										else {
HXLINE( 261)											::Dynamic this272 = pixelImage->image;
HXDLIN( 261)											int index47;
HXDLIN( 261)											if (pixelImage->useVirtualPos) {
HXLINE( 261)												index47 = ::Std_obj::_hx_int(((((( (Float)(py7) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px7) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 261)												index47 = ::Std_obj::_hx_int(( (Float)(((py7 * pixelImage->width) + px7)) ));
            											}
HXDLIN( 261)											int _hx_tmp71;
HXDLIN( 261)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 261)												_hx_tmp71 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            											}
            											else {
HXLINE( 261)												_hx_tmp71 = c39;
            											}
HXDLIN( 261)											::iterMagic::Iimg_obj::set(this272,index47,_hx_tmp71);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 261)				if ((hasHit == false)) {
HXLINE( 261)					 ::pi_xy::algo::HitTri v34 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,by1,leftX,cy1,x,bottomY,true);
HXDLIN( 261)					if (hasUndo7) {
HXLINE( 261)						v34->undoImage = undoImage21;
HXDLIN( 261)						v34->undoX = xIter37->start;
HXDLIN( 261)						v34->undoY = yIter37->start;
            					}
            				}
            			}
HXDLIN( 261)			if ((hasHit == true)) {
HXLINE( 261)				 ::pi_xy::algo::HitQuad v35 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x,ay1,leftX,by1,leftX,cy1,x,bottomY,true);
            			}
            		}
HXLINE( 266)		au = bu;
HXLINE( 267)		bu = ((left + fat) * sw);
HXLINE( 268)		{
HXLINE( 268)			Float ay2 = (topY - ( (Float)(1) ));
HXDLIN( 268)			Float by2 = (topY - ( (Float)(1) ));
HXDLIN( 268)			Float cy2 = (bottomY + 1);
HXDLIN( 268)			{
HXLINE( 268)				Float au9 = au;
HXDLIN( 268)				Float av9 = av;
HXDLIN( 268)				Float bu9 = bu;
HXDLIN( 268)				Float bv8 = av;
HXDLIN( 268)				bool hasUndo8 = false;
HXDLIN( 268)				Float temp8 = au9;
HXLINE( 422)				au9 = bu9;
HXLINE( 423)				bu9 = temp8;
HXLINE( 424)				temp8 = av9;
HXLINE( 425)				av9 = bv8;
HXLINE( 426)				bv8 = temp8;
HXLINE( 268)				Float bcx8 = (rightX - leftX);
HXDLIN( 268)				Float bcy8 = (by2 - bottomY);
HXDLIN( 268)				Float acx8 = (leftX - leftX);
HXDLIN( 268)				Float acy8 = (ay2 - bottomY);
HXDLIN( 268)				Float dot118 = ((bcx8 * bcx8) + (bcy8 * bcy8));
HXDLIN( 268)				Float dot128 = ((bcx8 * acx8) + (bcy8 * acy8));
HXDLIN( 268)				Float dot228 = ((acx8 * acx8) + (acy8 * acy8));
HXDLIN( 268)				Float denom18 = (( (Float)(1) ) / ((dot118 * dot228) - (dot128 * dot128)));
HXDLIN( 268)				 ::pi_xy::iter::IntIterStart xIter38;
HXDLIN( 268)				if ((leftX > rightX)) {
HXLINE( 268)					if ((leftX > leftX)) {
HXLINE( 268)						int min32;
HXDLIN( 268)						if ((rightX > leftX)) {
HXLINE( 268)							min32 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 268)							min32 = ::Math_obj::floor(rightX);
            						}
HXDLIN( 268)						int ii_min64 = min32;
HXDLIN( 268)						int ii_max64 = ::Math_obj::ceil(leftX);
HXDLIN( 268)						xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            					}
            					else {
HXLINE( 268)						int ii_min65 = ::Math_obj::floor(rightX);
HXDLIN( 268)						int ii_max65 = ::Math_obj::ceil(leftX);
HXDLIN( 268)						xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            					}
            				}
            				else {
HXLINE( 268)					if ((rightX > leftX)) {
HXLINE( 268)						int min33;
HXDLIN( 268)						if ((leftX > leftX)) {
HXLINE( 268)							min33 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 268)							min33 = ::Math_obj::ceil(leftX);
            						}
HXDLIN( 268)						int ii_min66 = min33;
HXDLIN( 268)						int ii_max66 = ::Math_obj::ceil(rightX);
HXDLIN( 268)						xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            					}
            					else {
HXLINE( 268)						int ii_min67 = ::Math_obj::floor(leftX);
HXDLIN( 268)						int ii_max67 = ::Math_obj::ceil(leftX);
HXDLIN( 268)						xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            					}
            				}
HXDLIN( 268)				 ::pi_xy::iter::IntIterStart yIter38;
HXDLIN( 268)				if ((ay2 > by2)) {
HXLINE( 268)					if ((ay2 > bottomY)) {
HXLINE( 268)						int min34;
HXDLIN( 268)						if ((by2 > bottomY)) {
HXLINE( 268)							min34 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 268)							min34 = ::Math_obj::floor(by2);
            						}
HXDLIN( 268)						int ii_min68 = min34;
HXDLIN( 268)						int ii_max68 = ::Math_obj::ceil(ay2);
HXDLIN( 268)						yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            					}
            					else {
HXLINE( 268)						int ii_min69 = ::Math_obj::floor(by2);
HXDLIN( 268)						int ii_max69 = ::Math_obj::ceil(bottomY);
HXDLIN( 268)						yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            					}
            				}
            				else {
HXLINE( 268)					if ((by2 > bottomY)) {
HXLINE( 268)						int min35;
HXDLIN( 268)						if ((ay2 > bottomY)) {
HXLINE( 268)							min35 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 268)							min35 = ::Math_obj::ceil(ay2);
            						}
HXDLIN( 268)						int ii_min70 = min35;
HXDLIN( 268)						int ii_max70 = ::Math_obj::ceil(by2);
HXDLIN( 268)						yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            					}
            					else {
HXLINE( 268)						int ii_min71 = ::Math_obj::floor(ay2);
HXDLIN( 268)						int ii_max71 = ::Math_obj::ceil(bottomY);
HXDLIN( 268)						yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            					}
            				}
HXDLIN( 268)				 ::pi_xy::ImageStruct undoImage24 = null();
HXDLIN( 268)				if (hasUndo8) {
HXLINE( 268)					int width8 = ((xIter38->max - xIter38->start) + 1);
HXDLIN( 268)					int height8 = ((yIter38->max - yIter38->start) + 1);
HXDLIN( 268)					 ::Dynamic imageType8 = null();
HXDLIN( 268)					 ::pi_xy::ImageStruct this273 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 268)					if (::hx::IsNull( imageType8 )) {
HXLINE(  54)						imageType8 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 268)					::Dynamic undoImage25;
HXDLIN( 268)					switch((int)(( (int)(imageType8) ))){
            						case (int)0: {
HXLINE( 268)							 ::iterMagic::BytesImg byt8 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::BytesImg b52 = byt8;
HXDLIN( 268)							{
HXLINE( 268)								b52->width = width8;
HXDLIN( 268)								b52->height = height8;
HXDLIN( 268)								b52->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 268)								b52->data = ::haxe::io::Bytes_obj::alloc((b52->length * 4));
HXDLIN( 268)								{
HXLINE( 268)									int len16 = b52->length;
HXDLIN( 268)									int w8 = 0;
HXDLIN( 268)									{
HXLINE( 268)										int _g160 = 0;
HXDLIN( 268)										int _g161 = b52->height;
HXDLIN( 268)										while((_g160 < _g161)){
HXLINE( 268)											_g160 = (_g160 + 1);
HXDLIN( 268)											int y33 = (_g160 - 1);
HXDLIN( 268)											{
HXLINE( 268)												int _g162 = 0;
HXDLIN( 268)												int _g163 = b52->width;
HXDLIN( 268)												while((_g162 < _g163)){
HXLINE( 268)													_g162 = (_g162 + 1);
HXDLIN( 268)													int x33 = (_g162 - 1);
HXDLIN( 268)													{
HXLINE( 268)														w8 = (w8 + 1);
HXDLIN( 268)														b52->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 268)													{
HXLINE( 268)														w8 = (w8 + 1);
HXDLIN( 268)														b52->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 268)													{
HXLINE( 268)														w8 = (w8 + 1);
HXDLIN( 268)														b52->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 268)													{
HXLINE( 268)														w8 = (w8 + 1);
HXDLIN( 268)														b52->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 268)							undoImage25 = b52;
            						}
            						break;
            						case (int)1: {
HXLINE( 268)							 ::iterMagic::ArrIntImg arrI8 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::ArrIntImg a50 = arrI8;
HXDLIN( 268)							{
HXLINE( 268)								a50->width = width8;
HXDLIN( 268)								a50->height = height8;
HXDLIN( 268)								a50->data = ::Array_obj< int >::__new(0);
HXDLIN( 268)								a50->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 268)								{
HXLINE( 268)									int _g164 = 0;
HXDLIN( 268)									int _g165 = a50->length;
HXDLIN( 268)									while((_g164 < _g165)){
HXLINE( 268)										_g164 = (_g164 + 1);
HXDLIN( 268)										int i48 = (_g164 - 1);
HXDLIN( 268)										a50->data[i48] = 0;
            									}
            								}
            							}
HXDLIN( 268)							undoImage25 = a50;
            						}
            						break;
            						case (int)2: {
HXLINE( 268)							 ::iterMagic::U32ArrImg u32a8 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::U32ArrImg b53 = u32a8;
HXDLIN( 268)							{
HXLINE( 268)								b53->width = width8;
HXDLIN( 268)								b53->height = height8;
HXDLIN( 268)								b53->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 268)								int size8 = (b53->length * 4);
HXDLIN( 268)								b53->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size8),0,size8);
HXDLIN( 268)								{
HXLINE( 268)									int _g166 = 0;
HXDLIN( 268)									int _g167 = b53->length;
HXDLIN( 268)									while((_g166 < _g167)){
HXLINE( 268)										_g166 = (_g166 + 1);
HXDLIN( 268)										int i49 = (_g166 - 1);
HXDLIN( 268)										{
HXLINE( 268)											 ::haxe::io::ArrayBufferViewImpl this274 = b53->data;
HXDLIN( 268)											bool undoImage26;
HXDLIN( 268)											if ((i49 >= 0)) {
HXLINE( 268)												undoImage26 = (i49 < (this274->byteLength >> 2));
            											}
            											else {
HXLINE( 268)												undoImage26 = false;
            											}
HXDLIN( 268)											if (undoImage26) {
HXLINE( 268)												 ::haxe::io::Bytes _this8 = this274->bytes;
HXDLIN( 268)												int pos8 = ((i49 << 2) + this274->byteOffset);
HXDLIN( 268)												_this8->b[pos8] = ( (unsigned char)(0) );
HXDLIN( 268)												_this8->b[(pos8 + 1)] = ( (unsigned char)(0) );
HXDLIN( 268)												_this8->b[(pos8 + 2)] = ( (unsigned char)(0) );
HXDLIN( 268)												_this8->b[(pos8 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 268)							undoImage25 = b53;
            						}
            						break;
            						case (int)3: {
HXLINE( 268)							 ::iterMagic::VecIntImg vec8 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::VecIntImg v36 = vec8;
HXDLIN( 268)							{
HXLINE( 268)								v36->width = width8;
HXDLIN( 268)								v36->height = height8;
HXDLIN( 268)								v36->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 268)								v36->data = ::Array_obj< int >::__new(v36->length);
HXDLIN( 268)								{
HXLINE( 268)									int _g168 = 0;
HXDLIN( 268)									int _g169 = v36->length;
HXDLIN( 268)									while((_g168 < _g169)){
HXLINE( 268)										_g168 = (_g168 + 1);
HXDLIN( 268)										int i50 = (_g168 - 1);
HXDLIN( 268)										v36->data->__unsafe_set(i50,0);
            									}
            								}
            							}
HXDLIN( 268)							undoImage25 = v36;
            						}
            						break;
            						case (int)4: {
HXLINE( 268)							 ::iterMagic::StackIntImg sInt8 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::StackIntImg b54 = sInt8;
HXDLIN( 268)							{
HXLINE( 268)								b54->width = width8;
HXDLIN( 268)								b54->height = height8;
HXDLIN( 268)								b54->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN( 268)								b54->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 268)								{
HXLINE( 268)									int len17 = b54->length;
HXDLIN( 268)									 ::haxe::ds::GenericStack_Int d8 = b54->data;
HXDLIN( 268)									if (::hx::IsNull( d8->head )) {
HXLINE( 268)										int _g170 = 0;
HXDLIN( 268)										int _g171 = len17;
HXDLIN( 268)										while((_g170 < _g171)){
HXLINE( 268)											_g170 = (_g170 + 1);
HXDLIN( 268)											int i51 = (_g170 - 1);
HXDLIN( 268)											d8->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d8->head);
            										}
            									}
            									else {
HXLINE( 268)										int _g172 = 0;
HXDLIN( 268)										int _g173 = len17;
HXDLIN( 268)										while((_g172 < _g173)){
HXLINE( 268)											_g172 = (_g172 + 1);
HXDLIN( 268)											int i52 = (_g172 - 1);
HXDLIN( 268)											{
HXLINE( 268)												 ::haxe::ds::GenericCell_Int l8 = b54->data->head;
HXDLIN( 268)												 ::haxe::ds::GenericCell_Int prev8 = null();
HXDLIN( 268)												{
HXLINE( 268)													int _g174 = 0;
HXDLIN( 268)													int _g175 = i52;
HXDLIN( 268)													while((_g174 < _g175)){
HXLINE( 268)														_g174 = (_g174 + 1);
HXDLIN( 268)														int i53 = (_g174 - 1);
HXLINE( 345)														prev8 = l8;
HXLINE( 346)														l8 = l8->next;
            													}
            												}
HXLINE( 268)												if (::hx::IsNull( prev8 )) {
HXLINE( 268)													b54->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 268)													l8 = null();
            												}
            												else {
HXLINE( 268)													prev8->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN( 268)													l8 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 268)							undoImage25 = b54;
            						}
            						break;
            					}
HXDLIN( 268)					this273->image = undoImage25;
HXDLIN( 268)					this273->width = width8;
HXDLIN( 268)					this273->height = height8;
HXDLIN( 268)					this273->imageType = ( (int)(imageType8) );
HXDLIN( 268)					undoImage24 = this273;
HXDLIN( 268)					{
HXLINE( 268)						int rectLeft8 = xIter38->start;
HXDLIN( 268)						int rectTop8 = yIter38->start;
HXDLIN( 268)						int rectRight8 = xIter38->max;
HXDLIN( 268)						bool forceClear8 = false;
HXDLIN( 268)						{
HXLINE( 268)							int _g176 = rectTop8;
HXDLIN( 268)							int _g177 = yIter38->max;
HXDLIN( 268)							while((_g176 < _g177)){
HXLINE( 268)								_g176 = (_g176 + 1);
HXDLIN( 268)								int dy9 = (_g176 - 1);
HXDLIN( 268)								{
HXLINE( 268)									int _g178 = rectLeft8;
HXDLIN( 268)									int _g179 = rectRight8;
HXDLIN( 268)									while((_g178 < _g179)){
HXLINE( 268)										_g178 = (_g178 + 1);
HXDLIN( 268)										int dx9 = (_g178 - 1);
HXDLIN( 268)										::Dynamic this275 = pixelImage->image;
HXDLIN( 268)										int index48;
HXDLIN( 268)										if (pixelImage->useVirtualPos) {
HXLINE( 268)											index48 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx9) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 268)											index48 = ::Std_obj::_hx_int(( (Float)(((dy9 * pixelImage->width) + dx9)) ));
            										}
HXDLIN( 268)										int c40 = ::iterMagic::Iimg_obj::get(this275,index48);
HXDLIN( 268)										int col16;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)											col16 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            										}
            										else {
HXLINE( 268)											col16 = c40;
            										}
HXDLIN( 268)										bool _hx_tmp72;
HXDLIN( 268)										if (pixelImage->useMask) {
HXLINE( 268)											_hx_tmp72 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 268)											_hx_tmp72 = false;
            										}
HXDLIN( 268)										if (_hx_tmp72) {
HXLINE( 268)											 ::pi_xy::ImageStruct this276 = pixelImage->mask;
HXDLIN( 268)											::Dynamic this277 = this276->image;
HXDLIN( 268)											int index49;
HXDLIN( 268)											if (this276->useVirtualPos) {
HXLINE( 268)												index49 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this276->virtualY) * ( (Float)(this276->width) )) + dx9) - this276->virtualX));
            											}
            											else {
HXLINE( 268)												index49 = ::Std_obj::_hx_int(( (Float)(((dy9 * this276->width) + dx9)) ));
            											}
HXDLIN( 268)											int c41 = ::iterMagic::Iimg_obj::get(this277,index49);
HXDLIN( 268)											int v37;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)												v37 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            											}
            											else {
HXLINE( 268)												v37 = c41;
            											}
HXDLIN( 268)											int maskPixel8 = v37;
HXDLIN( 268)											int this278 = col16;
HXDLIN( 268)											if ((maskPixel8 == 0)) {
HXLINE( 268)												col16 = this278;
            											}
            											else {
HXLINE( 268)												Float m08;
HXDLIN( 268)												int this279 = ((maskPixel8 >> 24) & 255);
HXDLIN( 268)												if ((this279 == 0)) {
HXLINE( 268)													m08 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													m08 = (( (Float)(this279) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float m18;
HXDLIN( 268)												int this280 = ((maskPixel8 >> 16) & 255);
HXDLIN( 268)												if ((this280 == 0)) {
HXLINE( 268)													m18 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													m18 = (( (Float)(this280) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float m28;
HXDLIN( 268)												int this281 = ((maskPixel8 >> 8) & 255);
HXDLIN( 268)												if ((this281 == 0)) {
HXLINE( 268)													m28 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													m28 = (( (Float)(this281) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float m38;
HXDLIN( 268)												int this282 = (maskPixel8 & 255);
HXDLIN( 268)												if ((this282 == 0)) {
HXLINE( 268)													m38 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													m38 = (( (Float)(this282) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												int ch08 = ::Std_obj::_hx_int(((((Float)1.) - m08) * ( (Float)(((this278 >> 24) & 255)) )));
HXDLIN( 268)												int ch18 = ::Std_obj::_hx_int(((((Float)1.) - m18) * ( (Float)(((this278 >> 16) & 255)) )));
HXDLIN( 268)												int ch28 = ::Std_obj::_hx_int(((((Float)1.) - m28) * ( (Float)(((this278 >> 8) & 255)) )));
HXDLIN( 268)												int ch38 = ::Std_obj::_hx_int(((((Float)1.) - m38) * ( (Float)((this278 & 255)) )));
HXDLIN( 268)												col16 = ((((::Math_obj::round((( (Float)(ch08) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch18) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch28) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch38) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 268)										if ((col16 != 0)) {
HXLINE( 268)											int x34 = (dx9 - rectLeft8);
HXDLIN( 268)											int y34 = (dy9 - rectTop8);
HXDLIN( 268)											int c42 = col16;
HXDLIN( 268)											bool _hx_tmp73;
HXDLIN( 268)											if ((((c42 >> 24) & 255) < 254)) {
HXLINE( 268)												_hx_tmp73 = undoImage24->transparent;
            											}
            											else {
HXLINE( 268)												_hx_tmp73 = false;
            											}
HXDLIN( 268)											if (_hx_tmp73) {
HXLINE( 268)												int location16;
HXDLIN( 268)												if (undoImage24->useVirtualPos) {
HXLINE( 268)													location16 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x34) - undoImage24->virtualX));
            												}
            												else {
HXLINE( 268)													location16 = ::Std_obj::_hx_int(( (Float)(((y34 * undoImage24->width) + x34)) ));
            												}
HXDLIN( 268)												int this283 = ::iterMagic::Iimg_obj::get(undoImage24->image,location16);
HXDLIN( 268)												int this284;
HXDLIN( 268)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)													this284 = ((((((this283 >> 24) & 255) << 24) | ((this283 & 255) << 16)) | (((this283 >> 8) & 255) << 8)) | ((this283 >> 16) & 255));
            												}
            												else {
HXLINE( 268)													this284 = this283;
            												}
HXDLIN( 268)												Float a119;
HXDLIN( 268)												int this285 = ((this284 >> 24) & 255);
HXDLIN( 268)												if ((this285 == 0)) {
HXLINE( 268)													a119 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													a119 = (( (Float)(this285) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float r116;
HXDLIN( 268)												int this286 = ((this284 >> 16) & 255);
HXDLIN( 268)												if ((this286 == 0)) {
HXLINE( 268)													r116 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													r116 = (( (Float)(this286) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float g116;
HXDLIN( 268)												int this287 = ((this284 >> 8) & 255);
HXDLIN( 268)												if ((this287 == 0)) {
HXLINE( 268)													g116 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													g116 = (( (Float)(this287) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float b120;
HXDLIN( 268)												int this288 = (this284 & 255);
HXDLIN( 268)												if ((this288 == 0)) {
HXLINE( 268)													b120 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													b120 = (( (Float)(this288) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float a217;
HXDLIN( 268)												int this289 = ((col16 >> 24) & 255);
HXDLIN( 268)												if ((this289 == 0)) {
HXLINE( 268)													a217 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													a217 = (( (Float)(this289) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float r216;
HXDLIN( 268)												int this290 = ((col16 >> 16) & 255);
HXDLIN( 268)												if ((this290 == 0)) {
HXLINE( 268)													r216 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													r216 = (( (Float)(this290) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float g216;
HXDLIN( 268)												int this291 = ((col16 >> 8) & 255);
HXDLIN( 268)												if ((this291 == 0)) {
HXLINE( 268)													g216 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													g216 = (( (Float)(this291) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float b220;
HXDLIN( 268)												int this292 = (col16 & 255);
HXDLIN( 268)												if ((this292 == 0)) {
HXLINE( 268)													b220 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													b220 = (( (Float)(this292) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float a316 = (a119 * (( (Float)(1) ) - a217));
HXDLIN( 268)												int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN( 268)												int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN( 268)												int b55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a316) + (b220 * a217))));
HXDLIN( 268)												int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN( 268)												int blended16 = ((((a51 << 24) | (r36 << 16)) | (g36 << 8)) | b55);
HXDLIN( 268)												{
HXLINE( 268)													int _hx_tmp74;
HXDLIN( 268)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)														_hx_tmp74 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            													}
            													else {
HXLINE( 268)														_hx_tmp74 = blended16;
            													}
HXDLIN( 268)													::iterMagic::Iimg_obj::set(undoImage24->image,location16,_hx_tmp74);
            												}
            											}
            											else {
HXLINE( 268)												::Dynamic this293 = undoImage24->image;
HXDLIN( 268)												int index50;
HXDLIN( 268)												if (undoImage24->useVirtualPos) {
HXLINE( 268)													index50 = ::Std_obj::_hx_int(((((( (Float)(y34) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x34) - undoImage24->virtualX));
            												}
            												else {
HXLINE( 268)													index50 = ::Std_obj::_hx_int(( (Float)(((y34 * undoImage24->width) + x34)) ));
            												}
HXDLIN( 268)												int _hx_tmp75;
HXDLIN( 268)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)													_hx_tmp75 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            												}
            												else {
HXLINE( 268)													_hx_tmp75 = c42;
            												}
HXDLIN( 268)												::iterMagic::Iimg_obj::set(this293,index50,_hx_tmp75);
            											}
            										}
            										else {
HXLINE( 268)											if (forceClear8) {
HXLINE( 268)												::Dynamic this294 = undoImage24->image;
HXDLIN( 268)												int x35 = (dx9 - rectLeft8);
HXDLIN( 268)												int y35 = (dy9 - rectTop8);
HXDLIN( 268)												int index51;
HXDLIN( 268)												if (undoImage24->useVirtualPos) {
HXLINE( 268)													index51 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x35) - undoImage24->virtualX));
            												}
            												else {
HXLINE( 268)													index51 = ::Std_obj::_hx_int(( (Float)(((y35 * undoImage24->width) + x35)) ));
            												}
HXDLIN( 268)												::iterMagic::Iimg_obj::set(this294,index51,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 268)				{
HXLINE( 268)					int _g_min16 = xIter38->start;
HXDLIN( 268)					int _g_max16 = xIter38->max;
HXDLIN( 268)					while((_g_min16 < _g_max16)){
HXLINE( 268)						_g_min16 = (_g_min16 + 1);
HXDLIN( 268)						int px8 = (_g_min16 - 1);
HXDLIN( 268)						Float pcx8 = (( (Float)(px8) ) - leftX);
HXDLIN( 268)						{
HXLINE( 268)							int _g_min17 = yIter38->start;
HXDLIN( 268)							int _g_max17 = yIter38->max;
HXDLIN( 268)							while((_g_min17 < _g_max17)){
HXLINE( 268)								_g_min17 = (_g_min17 + 1);
HXDLIN( 268)								int py8 = (_g_min17 - 1);
HXDLIN( 268)								Float pcy8 = (( (Float)(py8) ) - bottomY);
HXDLIN( 268)								Float dot318 = ((pcx8 * bcx8) + (pcy8 * bcy8));
HXDLIN( 268)								Float dot328 = ((pcx8 * acx8) + (pcy8 * acy8));
HXDLIN( 268)								Float ratioA8 = (((dot228 * dot318) - (dot128 * dot328)) * denom18);
HXDLIN( 268)								Float ratioB8 = (((dot118 * dot328) - (dot128 * dot318)) * denom18);
HXDLIN( 268)								Float ratioC8 = ((((Float)1.0) - ratioB8) - ratioA8);
HXDLIN( 268)								bool _hx_tmp76;
HXDLIN( 268)								bool _hx_tmp77;
HXDLIN( 268)								if ((ratioA8 >= 0)) {
HXLINE( 268)									_hx_tmp77 = (ratioB8 >= 0);
            								}
            								else {
HXLINE( 268)									_hx_tmp77 = false;
            								}
HXDLIN( 268)								if (_hx_tmp77) {
HXLINE( 268)									_hx_tmp76 = (ratioC8 >= 0);
            								}
            								else {
HXLINE( 268)									_hx_tmp76 = false;
            								}
HXDLIN( 268)								if (_hx_tmp76) {
HXLINE( 268)									Float u8 = (((au9 * ratioA8) + (bu9 * ratioB8)) + (au * ratioC8));
HXDLIN( 268)									Float v38 = (((av9 * ratioA8) + (bv8 * ratioB8)) + (cv * ratioC8));
HXDLIN( 268)									int x36 = ::Std_obj::_hx_int(((u8 * win->width) + win->x));
HXDLIN( 268)									int y36 = ::Std_obj::_hx_int(((v38 * win->height) + win->y));
HXDLIN( 268)									::Dynamic this295 = texture->image;
HXDLIN( 268)									int index52;
HXDLIN( 268)									if (texture->useVirtualPos) {
HXLINE( 268)										index52 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - texture->virtualY) * ( (Float)(texture->width) )) + x36) - texture->virtualX));
            									}
            									else {
HXLINE( 268)										index52 = ::Std_obj::_hx_int(( (Float)(((y36 * texture->width) + x36)) ));
            									}
HXDLIN( 268)									int c43 = ::iterMagic::Iimg_obj::get(this295,index52);
HXDLIN( 268)									int col17;
HXDLIN( 268)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)										col17 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            									}
            									else {
HXLINE( 268)										col17 = c43;
            									}
HXDLIN( 268)									{
HXLINE( 268)										int c44 = col17;
HXDLIN( 268)										bool _hx_tmp78;
HXDLIN( 268)										if ((((c44 >> 24) & 255) < 254)) {
HXLINE( 268)											_hx_tmp78 = pixelImage->transparent;
            										}
            										else {
HXLINE( 268)											_hx_tmp78 = false;
            										}
HXDLIN( 268)										if (_hx_tmp78) {
HXLINE( 268)											int location17;
HXDLIN( 268)											if (pixelImage->useVirtualPos) {
HXLINE( 268)												location17 = ::Std_obj::_hx_int(((((( (Float)(py8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px8) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 268)												location17 = ::Std_obj::_hx_int(( (Float)(((py8 * pixelImage->width) + px8)) ));
            											}
HXDLIN( 268)											int this296 = ::iterMagic::Iimg_obj::get(pixelImage->image,location17);
HXDLIN( 268)											int this297;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)												this297 = ((((((this296 >> 24) & 255) << 24) | ((this296 & 255) << 16)) | (((this296 >> 8) & 255) << 8)) | ((this296 >> 16) & 255));
            											}
            											else {
HXLINE( 268)												this297 = this296;
            											}
HXDLIN( 268)											Float a120;
HXDLIN( 268)											int this298 = ((this297 >> 24) & 255);
HXDLIN( 268)											if ((this298 == 0)) {
HXLINE( 268)												a120 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												a120 = (( (Float)(this298) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float r117;
HXDLIN( 268)											int this299 = ((this297 >> 16) & 255);
HXDLIN( 268)											if ((this299 == 0)) {
HXLINE( 268)												r117 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												r117 = (( (Float)(this299) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float g117;
HXDLIN( 268)											int this300 = ((this297 >> 8) & 255);
HXDLIN( 268)											if ((this300 == 0)) {
HXLINE( 268)												g117 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												g117 = (( (Float)(this300) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float b121;
HXDLIN( 268)											int this301 = (this297 & 255);
HXDLIN( 268)											if ((this301 == 0)) {
HXLINE( 268)												b121 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												b121 = (( (Float)(this301) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float a218;
HXDLIN( 268)											int this302 = ((col17 >> 24) & 255);
HXDLIN( 268)											if ((this302 == 0)) {
HXLINE( 268)												a218 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												a218 = (( (Float)(this302) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float r217;
HXDLIN( 268)											int this303 = ((col17 >> 16) & 255);
HXDLIN( 268)											if ((this303 == 0)) {
HXLINE( 268)												r217 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												r217 = (( (Float)(this303) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float g217;
HXDLIN( 268)											int this304 = ((col17 >> 8) & 255);
HXDLIN( 268)											if ((this304 == 0)) {
HXLINE( 268)												g217 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												g217 = (( (Float)(this304) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float b221;
HXDLIN( 268)											int this305 = (col17 & 255);
HXDLIN( 268)											if ((this305 == 0)) {
HXLINE( 268)												b221 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												b221 = (( (Float)(this305) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float a317 = (a120 * (( (Float)(1) ) - a218));
HXDLIN( 268)											int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a218))));
HXDLIN( 268)											int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a218))));
HXDLIN( 268)											int b56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a317) + (b221 * a218))));
HXDLIN( 268)											int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a218)));
HXDLIN( 268)											int blended17 = ((((a52 << 24) | (r37 << 16)) | (g37 << 8)) | b56);
HXDLIN( 268)											{
HXLINE( 268)												int _hx_tmp79;
HXDLIN( 268)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)													_hx_tmp79 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            												}
            												else {
HXLINE( 268)													_hx_tmp79 = blended17;
            												}
HXDLIN( 268)												::iterMagic::Iimg_obj::set(pixelImage->image,location17,_hx_tmp79);
            											}
            										}
            										else {
HXLINE( 268)											::Dynamic this306 = pixelImage->image;
HXDLIN( 268)											int index53;
HXDLIN( 268)											if (pixelImage->useVirtualPos) {
HXLINE( 268)												index53 = ::Std_obj::_hx_int(((((( (Float)(py8) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px8) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 268)												index53 = ::Std_obj::_hx_int(( (Float)(((py8 * pixelImage->width) + px8)) ));
            											}
HXDLIN( 268)											int _hx_tmp80;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)												_hx_tmp80 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            											}
            											else {
HXLINE( 268)												_hx_tmp80 = c44;
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(this306,index53,_hx_tmp80);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 268)				if ((hasHit == false)) {
HXLINE( 268)					 ::pi_xy::algo::HitTri v39 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,ay2,rightX,by2,leftX,bottomY,true);
HXDLIN( 268)					if (hasUndo8) {
HXLINE( 268)						v39->undoImage = undoImage24;
HXDLIN( 268)						v39->undoX = xIter38->start;
HXDLIN( 268)						v39->undoY = yIter38->start;
            					}
            				}
            			}
HXDLIN( 268)			{
HXLINE( 268)				Float au10 = bu;
HXDLIN( 268)				Float av10 = av;
HXDLIN( 268)				Float bu10 = bu;
HXDLIN( 268)				Float bv9 = cv;
HXDLIN( 268)				bool hasUndo9 = false;
HXDLIN( 268)				Float temp9 = au10;
HXLINE( 422)				au10 = bu10;
HXLINE( 423)				bu10 = temp9;
HXLINE( 424)				temp9 = av10;
HXLINE( 425)				av10 = bv9;
HXLINE( 426)				bv9 = temp9;
HXLINE( 268)				Float bcx9 = (rightX - leftX);
HXDLIN( 268)				Float bcy9 = (cy2 - bottomY);
HXDLIN( 268)				Float acx9 = (rightX - leftX);
HXDLIN( 268)				Float acy9 = (by2 - bottomY);
HXDLIN( 268)				Float dot119 = ((bcx9 * bcx9) + (bcy9 * bcy9));
HXDLIN( 268)				Float dot129 = ((bcx9 * acx9) + (bcy9 * acy9));
HXDLIN( 268)				Float dot229 = ((acx9 * acx9) + (acy9 * acy9));
HXDLIN( 268)				Float denom19 = (( (Float)(1) ) / ((dot119 * dot229) - (dot129 * dot129)));
HXDLIN( 268)				 ::pi_xy::iter::IntIterStart xIter39;
HXDLIN( 268)				if ((rightX > rightX)) {
HXLINE( 268)					if ((rightX > leftX)) {
HXLINE( 268)						int min36;
HXDLIN( 268)						if ((rightX > leftX)) {
HXLINE( 268)							min36 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 268)							min36 = ::Math_obj::floor(rightX);
            						}
HXDLIN( 268)						int ii_min72 = min36;
HXDLIN( 268)						int ii_max72 = ::Math_obj::ceil(rightX);
HXDLIN( 268)						xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            					}
            					else {
HXLINE( 268)						int ii_min73 = ::Math_obj::floor(rightX);
HXDLIN( 268)						int ii_max73 = ::Math_obj::ceil(leftX);
HXDLIN( 268)						xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            					}
            				}
            				else {
HXLINE( 268)					if ((rightX > leftX)) {
HXLINE( 268)						int min37;
HXDLIN( 268)						if ((rightX > leftX)) {
HXLINE( 268)							min37 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 268)							min37 = ::Math_obj::ceil(rightX);
            						}
HXDLIN( 268)						int ii_min74 = min37;
HXDLIN( 268)						int ii_max74 = ::Math_obj::ceil(rightX);
HXDLIN( 268)						xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min74,ii_max74);
            					}
            					else {
HXLINE( 268)						int ii_min75 = ::Math_obj::floor(rightX);
HXDLIN( 268)						int ii_max75 = ::Math_obj::ceil(leftX);
HXDLIN( 268)						xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min75,ii_max75);
            					}
            				}
HXDLIN( 268)				 ::pi_xy::iter::IntIterStart yIter39;
HXDLIN( 268)				if ((by2 > cy2)) {
HXLINE( 268)					if ((by2 > bottomY)) {
HXLINE( 268)						int min38;
HXDLIN( 268)						if ((cy2 > bottomY)) {
HXLINE( 268)							min38 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 268)							min38 = ::Math_obj::floor(cy2);
            						}
HXDLIN( 268)						int ii_min76 = min38;
HXDLIN( 268)						int ii_max76 = ::Math_obj::ceil(by2);
HXDLIN( 268)						yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min76,ii_max76);
            					}
            					else {
HXLINE( 268)						int ii_min77 = ::Math_obj::floor(cy2);
HXDLIN( 268)						int ii_max77 = ::Math_obj::ceil(bottomY);
HXDLIN( 268)						yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min77,ii_max77);
            					}
            				}
            				else {
HXLINE( 268)					if ((cy2 > bottomY)) {
HXLINE( 268)						int min39;
HXDLIN( 268)						if ((by2 > bottomY)) {
HXLINE( 268)							min39 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 268)							min39 = ::Math_obj::ceil(by2);
            						}
HXDLIN( 268)						int ii_min78 = min39;
HXDLIN( 268)						int ii_max78 = ::Math_obj::ceil(cy2);
HXDLIN( 268)						yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min78,ii_max78);
            					}
            					else {
HXLINE( 268)						int ii_min79 = ::Math_obj::floor(by2);
HXDLIN( 268)						int ii_max79 = ::Math_obj::ceil(bottomY);
HXDLIN( 268)						yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min79,ii_max79);
            					}
            				}
HXDLIN( 268)				 ::pi_xy::ImageStruct undoImage27 = null();
HXDLIN( 268)				if (hasUndo9) {
HXLINE( 268)					int width9 = ((xIter39->max - xIter39->start) + 1);
HXDLIN( 268)					int height9 = ((yIter39->max - yIter39->start) + 1);
HXDLIN( 268)					 ::Dynamic imageType9 = null();
HXDLIN( 268)					 ::pi_xy::ImageStruct this307 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 268)					if (::hx::IsNull( imageType9 )) {
HXLINE(  54)						imageType9 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 268)					::Dynamic undoImage28;
HXDLIN( 268)					switch((int)(( (int)(imageType9) ))){
            						case (int)0: {
HXLINE( 268)							 ::iterMagic::BytesImg byt9 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::BytesImg b57 = byt9;
HXDLIN( 268)							{
HXLINE( 268)								b57->width = width9;
HXDLIN( 268)								b57->height = height9;
HXDLIN( 268)								b57->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 268)								b57->data = ::haxe::io::Bytes_obj::alloc((b57->length * 4));
HXDLIN( 268)								{
HXLINE( 268)									int len18 = b57->length;
HXDLIN( 268)									int w9 = 0;
HXDLIN( 268)									{
HXLINE( 268)										int _g180 = 0;
HXDLIN( 268)										int _g181 = b57->height;
HXDLIN( 268)										while((_g180 < _g181)){
HXLINE( 268)											_g180 = (_g180 + 1);
HXDLIN( 268)											int y37 = (_g180 - 1);
HXDLIN( 268)											{
HXLINE( 268)												int _g182 = 0;
HXDLIN( 268)												int _g183 = b57->width;
HXDLIN( 268)												while((_g182 < _g183)){
HXLINE( 268)													_g182 = (_g182 + 1);
HXDLIN( 268)													int x37 = (_g182 - 1);
HXDLIN( 268)													{
HXLINE( 268)														w9 = (w9 + 1);
HXDLIN( 268)														b57->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 268)													{
HXLINE( 268)														w9 = (w9 + 1);
HXDLIN( 268)														b57->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 268)													{
HXLINE( 268)														w9 = (w9 + 1);
HXDLIN( 268)														b57->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 268)													{
HXLINE( 268)														w9 = (w9 + 1);
HXDLIN( 268)														b57->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 268)							undoImage28 = b57;
            						}
            						break;
            						case (int)1: {
HXLINE( 268)							 ::iterMagic::ArrIntImg arrI9 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::ArrIntImg a53 = arrI9;
HXDLIN( 268)							{
HXLINE( 268)								a53->width = width9;
HXDLIN( 268)								a53->height = height9;
HXDLIN( 268)								a53->data = ::Array_obj< int >::__new(0);
HXDLIN( 268)								a53->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 268)								{
HXLINE( 268)									int _g184 = 0;
HXDLIN( 268)									int _g185 = a53->length;
HXDLIN( 268)									while((_g184 < _g185)){
HXLINE( 268)										_g184 = (_g184 + 1);
HXDLIN( 268)										int i54 = (_g184 - 1);
HXDLIN( 268)										a53->data[i54] = 0;
            									}
            								}
            							}
HXDLIN( 268)							undoImage28 = a53;
            						}
            						break;
            						case (int)2: {
HXLINE( 268)							 ::iterMagic::U32ArrImg u32a9 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::U32ArrImg b58 = u32a9;
HXDLIN( 268)							{
HXLINE( 268)								b58->width = width9;
HXDLIN( 268)								b58->height = height9;
HXDLIN( 268)								b58->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 268)								int size9 = (b58->length * 4);
HXDLIN( 268)								b58->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size9),0,size9);
HXDLIN( 268)								{
HXLINE( 268)									int _g186 = 0;
HXDLIN( 268)									int _g187 = b58->length;
HXDLIN( 268)									while((_g186 < _g187)){
HXLINE( 268)										_g186 = (_g186 + 1);
HXDLIN( 268)										int i55 = (_g186 - 1);
HXDLIN( 268)										{
HXLINE( 268)											 ::haxe::io::ArrayBufferViewImpl this308 = b58->data;
HXDLIN( 268)											bool undoImage29;
HXDLIN( 268)											if ((i55 >= 0)) {
HXLINE( 268)												undoImage29 = (i55 < (this308->byteLength >> 2));
            											}
            											else {
HXLINE( 268)												undoImage29 = false;
            											}
HXDLIN( 268)											if (undoImage29) {
HXLINE( 268)												 ::haxe::io::Bytes _this9 = this308->bytes;
HXDLIN( 268)												int pos9 = ((i55 << 2) + this308->byteOffset);
HXDLIN( 268)												_this9->b[pos9] = ( (unsigned char)(0) );
HXDLIN( 268)												_this9->b[(pos9 + 1)] = ( (unsigned char)(0) );
HXDLIN( 268)												_this9->b[(pos9 + 2)] = ( (unsigned char)(0) );
HXDLIN( 268)												_this9->b[(pos9 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 268)							undoImage28 = b58;
            						}
            						break;
            						case (int)3: {
HXLINE( 268)							 ::iterMagic::VecIntImg vec9 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::VecIntImg v40 = vec9;
HXDLIN( 268)							{
HXLINE( 268)								v40->width = width9;
HXDLIN( 268)								v40->height = height9;
HXDLIN( 268)								v40->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 268)								v40->data = ::Array_obj< int >::__new(v40->length);
HXDLIN( 268)								{
HXLINE( 268)									int _g188 = 0;
HXDLIN( 268)									int _g189 = v40->length;
HXDLIN( 268)									while((_g188 < _g189)){
HXLINE( 268)										_g188 = (_g188 + 1);
HXDLIN( 268)										int i56 = (_g188 - 1);
HXDLIN( 268)										v40->data->__unsafe_set(i56,0);
            									}
            								}
            							}
HXDLIN( 268)							undoImage28 = v40;
            						}
            						break;
            						case (int)4: {
HXLINE( 268)							 ::iterMagic::StackIntImg sInt9 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 268)							 ::iterMagic::StackIntImg b59 = sInt9;
HXDLIN( 268)							{
HXLINE( 268)								b59->width = width9;
HXDLIN( 268)								b59->height = height9;
HXDLIN( 268)								b59->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN( 268)								b59->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 268)								{
HXLINE( 268)									int len19 = b59->length;
HXDLIN( 268)									 ::haxe::ds::GenericStack_Int d9 = b59->data;
HXDLIN( 268)									if (::hx::IsNull( d9->head )) {
HXLINE( 268)										int _g190 = 0;
HXDLIN( 268)										int _g191 = len19;
HXDLIN( 268)										while((_g190 < _g191)){
HXLINE( 268)											_g190 = (_g190 + 1);
HXDLIN( 268)											int i57 = (_g190 - 1);
HXDLIN( 268)											d9->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d9->head);
            										}
            									}
            									else {
HXLINE( 268)										int _g192 = 0;
HXDLIN( 268)										int _g193 = len19;
HXDLIN( 268)										while((_g192 < _g193)){
HXLINE( 268)											_g192 = (_g192 + 1);
HXDLIN( 268)											int i58 = (_g192 - 1);
HXDLIN( 268)											{
HXLINE( 268)												 ::haxe::ds::GenericCell_Int l9 = b59->data->head;
HXDLIN( 268)												 ::haxe::ds::GenericCell_Int prev9 = null();
HXDLIN( 268)												{
HXLINE( 268)													int _g194 = 0;
HXDLIN( 268)													int _g195 = i58;
HXDLIN( 268)													while((_g194 < _g195)){
HXLINE( 268)														_g194 = (_g194 + 1);
HXDLIN( 268)														int i59 = (_g194 - 1);
HXLINE( 345)														prev9 = l9;
HXLINE( 346)														l9 = l9->next;
            													}
            												}
HXLINE( 268)												if (::hx::IsNull( prev9 )) {
HXLINE( 268)													b59->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l9->next);
HXDLIN( 268)													l9 = null();
            												}
            												else {
HXLINE( 268)													prev9->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l9->next);
HXDLIN( 268)													l9 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 268)							undoImage28 = b59;
            						}
            						break;
            					}
HXDLIN( 268)					this307->image = undoImage28;
HXDLIN( 268)					this307->width = width9;
HXDLIN( 268)					this307->height = height9;
HXDLIN( 268)					this307->imageType = ( (int)(imageType9) );
HXDLIN( 268)					undoImage27 = this307;
HXDLIN( 268)					{
HXLINE( 268)						int rectLeft9 = xIter39->start;
HXDLIN( 268)						int rectTop9 = yIter39->start;
HXDLIN( 268)						int rectRight9 = xIter39->max;
HXDLIN( 268)						bool forceClear9 = false;
HXDLIN( 268)						{
HXLINE( 268)							int _g196 = rectTop9;
HXDLIN( 268)							int _g197 = yIter39->max;
HXDLIN( 268)							while((_g196 < _g197)){
HXLINE( 268)								_g196 = (_g196 + 1);
HXDLIN( 268)								int dy10 = (_g196 - 1);
HXDLIN( 268)								{
HXLINE( 268)									int _g198 = rectLeft9;
HXDLIN( 268)									int _g199 = rectRight9;
HXDLIN( 268)									while((_g198 < _g199)){
HXLINE( 268)										_g198 = (_g198 + 1);
HXDLIN( 268)										int dx10 = (_g198 - 1);
HXDLIN( 268)										::Dynamic this309 = pixelImage->image;
HXDLIN( 268)										int index54;
HXDLIN( 268)										if (pixelImage->useVirtualPos) {
HXLINE( 268)											index54 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx10) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 268)											index54 = ::Std_obj::_hx_int(( (Float)(((dy10 * pixelImage->width) + dx10)) ));
            										}
HXDLIN( 268)										int c45 = ::iterMagic::Iimg_obj::get(this309,index54);
HXDLIN( 268)										int col18;
HXDLIN( 268)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)											col18 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            										}
            										else {
HXLINE( 268)											col18 = c45;
            										}
HXDLIN( 268)										bool _hx_tmp81;
HXDLIN( 268)										if (pixelImage->useMask) {
HXLINE( 268)											_hx_tmp81 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 268)											_hx_tmp81 = false;
            										}
HXDLIN( 268)										if (_hx_tmp81) {
HXLINE( 268)											 ::pi_xy::ImageStruct this310 = pixelImage->mask;
HXDLIN( 268)											::Dynamic this311 = this310->image;
HXDLIN( 268)											int index55;
HXDLIN( 268)											if (this310->useVirtualPos) {
HXLINE( 268)												index55 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - this310->virtualY) * ( (Float)(this310->width) )) + dx10) - this310->virtualX));
            											}
            											else {
HXLINE( 268)												index55 = ::Std_obj::_hx_int(( (Float)(((dy10 * this310->width) + dx10)) ));
            											}
HXDLIN( 268)											int c46 = ::iterMagic::Iimg_obj::get(this311,index55);
HXDLIN( 268)											int v41;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)												v41 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            											}
            											else {
HXLINE( 268)												v41 = c46;
            											}
HXDLIN( 268)											int maskPixel9 = v41;
HXDLIN( 268)											int this312 = col18;
HXDLIN( 268)											if ((maskPixel9 == 0)) {
HXLINE( 268)												col18 = this312;
            											}
            											else {
HXLINE( 268)												Float m09;
HXDLIN( 268)												int this313 = ((maskPixel9 >> 24) & 255);
HXDLIN( 268)												if ((this313 == 0)) {
HXLINE( 268)													m09 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													m09 = (( (Float)(this313) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float m19;
HXDLIN( 268)												int this314 = ((maskPixel9 >> 16) & 255);
HXDLIN( 268)												if ((this314 == 0)) {
HXLINE( 268)													m19 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													m19 = (( (Float)(this314) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float m29;
HXDLIN( 268)												int this315 = ((maskPixel9 >> 8) & 255);
HXDLIN( 268)												if ((this315 == 0)) {
HXLINE( 268)													m29 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													m29 = (( (Float)(this315) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float m39;
HXDLIN( 268)												int this316 = (maskPixel9 & 255);
HXDLIN( 268)												if ((this316 == 0)) {
HXLINE( 268)													m39 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													m39 = (( (Float)(this316) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												int ch09 = ::Std_obj::_hx_int(((((Float)1.) - m09) * ( (Float)(((this312 >> 24) & 255)) )));
HXDLIN( 268)												int ch19 = ::Std_obj::_hx_int(((((Float)1.) - m19) * ( (Float)(((this312 >> 16) & 255)) )));
HXDLIN( 268)												int ch29 = ::Std_obj::_hx_int(((((Float)1.) - m29) * ( (Float)(((this312 >> 8) & 255)) )));
HXDLIN( 268)												int ch39 = ::Std_obj::_hx_int(((((Float)1.) - m39) * ( (Float)((this312 & 255)) )));
HXDLIN( 268)												col18 = ((((::Math_obj::round((( (Float)(ch09) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch19) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch29) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch39) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 268)										if ((col18 != 0)) {
HXLINE( 268)											int x38 = (dx10 - rectLeft9);
HXDLIN( 268)											int y38 = (dy10 - rectTop9);
HXDLIN( 268)											int c47 = col18;
HXDLIN( 268)											bool _hx_tmp82;
HXDLIN( 268)											if ((((c47 >> 24) & 255) < 254)) {
HXLINE( 268)												_hx_tmp82 = undoImage27->transparent;
            											}
            											else {
HXLINE( 268)												_hx_tmp82 = false;
            											}
HXDLIN( 268)											if (_hx_tmp82) {
HXLINE( 268)												int location18;
HXDLIN( 268)												if (undoImage27->useVirtualPos) {
HXLINE( 268)													location18 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x38) - undoImage27->virtualX));
            												}
            												else {
HXLINE( 268)													location18 = ::Std_obj::_hx_int(( (Float)(((y38 * undoImage27->width) + x38)) ));
            												}
HXDLIN( 268)												int this317 = ::iterMagic::Iimg_obj::get(undoImage27->image,location18);
HXDLIN( 268)												int this318;
HXDLIN( 268)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)													this318 = ((((((this317 >> 24) & 255) << 24) | ((this317 & 255) << 16)) | (((this317 >> 8) & 255) << 8)) | ((this317 >> 16) & 255));
            												}
            												else {
HXLINE( 268)													this318 = this317;
            												}
HXDLIN( 268)												Float a121;
HXDLIN( 268)												int this319 = ((this318 >> 24) & 255);
HXDLIN( 268)												if ((this319 == 0)) {
HXLINE( 268)													a121 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													a121 = (( (Float)(this319) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float r118;
HXDLIN( 268)												int this320 = ((this318 >> 16) & 255);
HXDLIN( 268)												if ((this320 == 0)) {
HXLINE( 268)													r118 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													r118 = (( (Float)(this320) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float g118;
HXDLIN( 268)												int this321 = ((this318 >> 8) & 255);
HXDLIN( 268)												if ((this321 == 0)) {
HXLINE( 268)													g118 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													g118 = (( (Float)(this321) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float b122;
HXDLIN( 268)												int this322 = (this318 & 255);
HXDLIN( 268)												if ((this322 == 0)) {
HXLINE( 268)													b122 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													b122 = (( (Float)(this322) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float a219;
HXDLIN( 268)												int this323 = ((col18 >> 24) & 255);
HXDLIN( 268)												if ((this323 == 0)) {
HXLINE( 268)													a219 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													a219 = (( (Float)(this323) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float r218;
HXDLIN( 268)												int this324 = ((col18 >> 16) & 255);
HXDLIN( 268)												if ((this324 == 0)) {
HXLINE( 268)													r218 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													r218 = (( (Float)(this324) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float g218;
HXDLIN( 268)												int this325 = ((col18 >> 8) & 255);
HXDLIN( 268)												if ((this325 == 0)) {
HXLINE( 268)													g218 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													g218 = (( (Float)(this325) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float b222;
HXDLIN( 268)												int this326 = (col18 & 255);
HXDLIN( 268)												if ((this326 == 0)) {
HXLINE( 268)													b222 = ((Float)0.);
            												}
            												else {
HXLINE( 268)													b222 = (( (Float)(this326) ) / ( (Float)(255) ));
            												}
HXDLIN( 268)												Float a318 = (a121 * (( (Float)(1) ) - a219));
HXDLIN( 268)												int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a219))));
HXDLIN( 268)												int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a219))));
HXDLIN( 268)												int b60 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a318) + (b222 * a219))));
HXDLIN( 268)												int a54 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a219)));
HXDLIN( 268)												int blended18 = ((((a54 << 24) | (r38 << 16)) | (g38 << 8)) | b60);
HXDLIN( 268)												{
HXLINE( 268)													int _hx_tmp83;
HXDLIN( 268)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)														_hx_tmp83 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            													}
            													else {
HXLINE( 268)														_hx_tmp83 = blended18;
            													}
HXDLIN( 268)													::iterMagic::Iimg_obj::set(undoImage27->image,location18,_hx_tmp83);
            												}
            											}
            											else {
HXLINE( 268)												::Dynamic this327 = undoImage27->image;
HXDLIN( 268)												int index56;
HXDLIN( 268)												if (undoImage27->useVirtualPos) {
HXLINE( 268)													index56 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x38) - undoImage27->virtualX));
            												}
            												else {
HXLINE( 268)													index56 = ::Std_obj::_hx_int(( (Float)(((y38 * undoImage27->width) + x38)) ));
            												}
HXDLIN( 268)												int _hx_tmp84;
HXDLIN( 268)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)													_hx_tmp84 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            												}
            												else {
HXLINE( 268)													_hx_tmp84 = c47;
            												}
HXDLIN( 268)												::iterMagic::Iimg_obj::set(this327,index56,_hx_tmp84);
            											}
            										}
            										else {
HXLINE( 268)											if (forceClear9) {
HXLINE( 268)												::Dynamic this328 = undoImage27->image;
HXDLIN( 268)												int x39 = (dx10 - rectLeft9);
HXDLIN( 268)												int y39 = (dy10 - rectTop9);
HXDLIN( 268)												int index57;
HXDLIN( 268)												if (undoImage27->useVirtualPos) {
HXLINE( 268)													index57 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x39) - undoImage27->virtualX));
            												}
            												else {
HXLINE( 268)													index57 = ::Std_obj::_hx_int(( (Float)(((y39 * undoImage27->width) + x39)) ));
            												}
HXDLIN( 268)												::iterMagic::Iimg_obj::set(this328,index57,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 268)				{
HXLINE( 268)					int _g_min18 = xIter39->start;
HXDLIN( 268)					int _g_max18 = xIter39->max;
HXDLIN( 268)					while((_g_min18 < _g_max18)){
HXLINE( 268)						_g_min18 = (_g_min18 + 1);
HXDLIN( 268)						int px9 = (_g_min18 - 1);
HXDLIN( 268)						Float pcx9 = (( (Float)(px9) ) - leftX);
HXDLIN( 268)						{
HXLINE( 268)							int _g_min19 = yIter39->start;
HXDLIN( 268)							int _g_max19 = yIter39->max;
HXDLIN( 268)							while((_g_min19 < _g_max19)){
HXLINE( 268)								_g_min19 = (_g_min19 + 1);
HXDLIN( 268)								int py9 = (_g_min19 - 1);
HXDLIN( 268)								Float pcy9 = (( (Float)(py9) ) - bottomY);
HXDLIN( 268)								Float dot319 = ((pcx9 * bcx9) + (pcy9 * bcy9));
HXDLIN( 268)								Float dot329 = ((pcx9 * acx9) + (pcy9 * acy9));
HXDLIN( 268)								Float ratioA9 = (((dot229 * dot319) - (dot129 * dot329)) * denom19);
HXDLIN( 268)								Float ratioB9 = (((dot119 * dot329) - (dot129 * dot319)) * denom19);
HXDLIN( 268)								Float ratioC9 = ((((Float)1.0) - ratioB9) - ratioA9);
HXDLIN( 268)								bool _hx_tmp85;
HXDLIN( 268)								bool _hx_tmp86;
HXDLIN( 268)								if ((ratioA9 >= 0)) {
HXLINE( 268)									_hx_tmp86 = (ratioB9 >= 0);
            								}
            								else {
HXLINE( 268)									_hx_tmp86 = false;
            								}
HXDLIN( 268)								if (_hx_tmp86) {
HXLINE( 268)									_hx_tmp85 = (ratioC9 >= 0);
            								}
            								else {
HXLINE( 268)									_hx_tmp85 = false;
            								}
HXDLIN( 268)								if (_hx_tmp85) {
HXLINE( 268)									Float u9 = (((au10 * ratioA9) + (bu10 * ratioB9)) + (au * ratioC9));
HXDLIN( 268)									Float v42 = (((av10 * ratioA9) + (bv9 * ratioB9)) + (cv * ratioC9));
HXDLIN( 268)									int x40 = ::Std_obj::_hx_int(((u9 * win->width) + win->x));
HXDLIN( 268)									int y40 = ::Std_obj::_hx_int(((v42 * win->height) + win->y));
HXDLIN( 268)									::Dynamic this329 = texture->image;
HXDLIN( 268)									int index58;
HXDLIN( 268)									if (texture->useVirtualPos) {
HXLINE( 268)										index58 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - texture->virtualY) * ( (Float)(texture->width) )) + x40) - texture->virtualX));
            									}
            									else {
HXLINE( 268)										index58 = ::Std_obj::_hx_int(( (Float)(((y40 * texture->width) + x40)) ));
            									}
HXDLIN( 268)									int c48 = ::iterMagic::Iimg_obj::get(this329,index58);
HXDLIN( 268)									int col19;
HXDLIN( 268)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)										col19 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            									}
            									else {
HXLINE( 268)										col19 = c48;
            									}
HXDLIN( 268)									{
HXLINE( 268)										int c49 = col19;
HXDLIN( 268)										bool _hx_tmp87;
HXDLIN( 268)										if ((((c49 >> 24) & 255) < 254)) {
HXLINE( 268)											_hx_tmp87 = pixelImage->transparent;
            										}
            										else {
HXLINE( 268)											_hx_tmp87 = false;
            										}
HXDLIN( 268)										if (_hx_tmp87) {
HXLINE( 268)											int location19;
HXDLIN( 268)											if (pixelImage->useVirtualPos) {
HXLINE( 268)												location19 = ::Std_obj::_hx_int(((((( (Float)(py9) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px9) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 268)												location19 = ::Std_obj::_hx_int(( (Float)(((py9 * pixelImage->width) + px9)) ));
            											}
HXDLIN( 268)											int this330 = ::iterMagic::Iimg_obj::get(pixelImage->image,location19);
HXDLIN( 268)											int this331;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)												this331 = ((((((this330 >> 24) & 255) << 24) | ((this330 & 255) << 16)) | (((this330 >> 8) & 255) << 8)) | ((this330 >> 16) & 255));
            											}
            											else {
HXLINE( 268)												this331 = this330;
            											}
HXDLIN( 268)											Float a122;
HXDLIN( 268)											int this332 = ((this331 >> 24) & 255);
HXDLIN( 268)											if ((this332 == 0)) {
HXLINE( 268)												a122 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												a122 = (( (Float)(this332) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float r119;
HXDLIN( 268)											int this333 = ((this331 >> 16) & 255);
HXDLIN( 268)											if ((this333 == 0)) {
HXLINE( 268)												r119 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												r119 = (( (Float)(this333) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float g119;
HXDLIN( 268)											int this334 = ((this331 >> 8) & 255);
HXDLIN( 268)											if ((this334 == 0)) {
HXLINE( 268)												g119 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												g119 = (( (Float)(this334) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float b123;
HXDLIN( 268)											int this335 = (this331 & 255);
HXDLIN( 268)											if ((this335 == 0)) {
HXLINE( 268)												b123 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												b123 = (( (Float)(this335) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float a220;
HXDLIN( 268)											int this336 = ((col19 >> 24) & 255);
HXDLIN( 268)											if ((this336 == 0)) {
HXLINE( 268)												a220 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												a220 = (( (Float)(this336) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float r219;
HXDLIN( 268)											int this337 = ((col19 >> 16) & 255);
HXDLIN( 268)											if ((this337 == 0)) {
HXLINE( 268)												r219 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												r219 = (( (Float)(this337) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float g219;
HXDLIN( 268)											int this338 = ((col19 >> 8) & 255);
HXDLIN( 268)											if ((this338 == 0)) {
HXLINE( 268)												g219 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												g219 = (( (Float)(this338) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float b223;
HXDLIN( 268)											int this339 = (col19 & 255);
HXDLIN( 268)											if ((this339 == 0)) {
HXLINE( 268)												b223 = ((Float)0.);
            											}
            											else {
HXLINE( 268)												b223 = (( (Float)(this339) ) / ( (Float)(255) ));
            											}
HXDLIN( 268)											Float a319 = (a122 * (( (Float)(1) ) - a220));
HXDLIN( 268)											int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a220))));
HXDLIN( 268)											int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a220))));
HXDLIN( 268)											int b61 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a319) + (b223 * a220))));
HXDLIN( 268)											int a55 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a220)));
HXDLIN( 268)											int blended19 = ((((a55 << 24) | (r39 << 16)) | (g39 << 8)) | b61);
HXDLIN( 268)											{
HXLINE( 268)												int _hx_tmp88;
HXDLIN( 268)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)													_hx_tmp88 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            												}
            												else {
HXLINE( 268)													_hx_tmp88 = blended19;
            												}
HXDLIN( 268)												::iterMagic::Iimg_obj::set(pixelImage->image,location19,_hx_tmp88);
            											}
            										}
            										else {
HXLINE( 268)											::Dynamic this340 = pixelImage->image;
HXDLIN( 268)											int index59;
HXDLIN( 268)											if (pixelImage->useVirtualPos) {
HXLINE( 268)												index59 = ::Std_obj::_hx_int(((((( (Float)(py9) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px9) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 268)												index59 = ::Std_obj::_hx_int(( (Float)(((py9 * pixelImage->width) + px9)) ));
            											}
HXDLIN( 268)											int _hx_tmp89;
HXDLIN( 268)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 268)												_hx_tmp89 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            											}
            											else {
HXLINE( 268)												_hx_tmp89 = c49;
            											}
HXDLIN( 268)											::iterMagic::Iimg_obj::set(this340,index59,_hx_tmp89);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 268)				if ((hasHit == false)) {
HXLINE( 268)					 ::pi_xy::algo::HitTri v43 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,by2,rightX,cy2,leftX,bottomY,true);
HXDLIN( 268)					if (hasUndo9) {
HXLINE( 268)						v43->undoImage = undoImage27;
HXDLIN( 268)						v43->undoX = xIter39->start;
HXDLIN( 268)						v43->undoY = yIter39->start;
            					}
            				}
            			}
HXDLIN( 268)			if ((hasHit == true)) {
HXLINE( 268)				 ::pi_xy::algo::HitQuad v44 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,leftX,ay2,rightX,by2,rightX,cy2,leftX,bottomY,true);
            			}
            		}
HXLINE( 273)		au = bu;
HXLINE( 274)		bu = ((Float)1.);
HXLINE( 275)		{
HXLINE( 275)			Float ay3 = (topY - ( (Float)(1) ));
HXDLIN( 275)			Float bx2 = (x + widNew);
HXDLIN( 275)			Float by3 = (topY - ( (Float)(1) ));
HXDLIN( 275)			Float cx2 = (x + widNew);
HXDLIN( 275)			Float cy3 = (bottomY + 1);
HXDLIN( 275)			{
HXLINE( 275)				Float au11 = au;
HXDLIN( 275)				Float av11 = av;
HXDLIN( 275)				Float bu11 = bu;
HXDLIN( 275)				Float bv10 = av;
HXDLIN( 275)				bool hasUndo10 = false;
HXDLIN( 275)				Float temp10 = au11;
HXLINE( 422)				au11 = bu11;
HXLINE( 423)				bu11 = temp10;
HXLINE( 424)				temp10 = av11;
HXLINE( 425)				av11 = bv10;
HXLINE( 426)				bv10 = temp10;
HXLINE( 275)				Float bcx10 = (bx2 - rightX);
HXDLIN( 275)				Float bcy10 = (by3 - bottomY);
HXDLIN( 275)				Float acx10 = (rightX - rightX);
HXDLIN( 275)				Float acy10 = (ay3 - bottomY);
HXDLIN( 275)				Float dot1110 = ((bcx10 * bcx10) + (bcy10 * bcy10));
HXDLIN( 275)				Float dot1210 = ((bcx10 * acx10) + (bcy10 * acy10));
HXDLIN( 275)				Float dot2210 = ((acx10 * acx10) + (acy10 * acy10));
HXDLIN( 275)				Float denom110 = (( (Float)(1) ) / ((dot1110 * dot2210) - (dot1210 * dot1210)));
HXDLIN( 275)				 ::pi_xy::iter::IntIterStart xIter310;
HXDLIN( 275)				if ((rightX > bx2)) {
HXLINE( 275)					if ((rightX > rightX)) {
HXLINE( 275)						int min40;
HXDLIN( 275)						if ((bx2 > rightX)) {
HXLINE( 275)							min40 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 275)							min40 = ::Math_obj::floor(bx2);
            						}
HXDLIN( 275)						int ii_min80 = min40;
HXDLIN( 275)						int ii_max80 = ::Math_obj::ceil(rightX);
HXDLIN( 275)						xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min80,ii_max80);
            					}
            					else {
HXLINE( 275)						int ii_min81 = ::Math_obj::floor(bx2);
HXDLIN( 275)						int ii_max81 = ::Math_obj::ceil(rightX);
HXDLIN( 275)						xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min81,ii_max81);
            					}
            				}
            				else {
HXLINE( 275)					if ((bx2 > rightX)) {
HXLINE( 275)						int min41;
HXDLIN( 275)						if ((rightX > rightX)) {
HXLINE( 275)							min41 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 275)							min41 = ::Math_obj::ceil(rightX);
            						}
HXDLIN( 275)						int ii_min82 = min41;
HXDLIN( 275)						int ii_max82 = ::Math_obj::ceil(bx2);
HXDLIN( 275)						xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min82,ii_max82);
            					}
            					else {
HXLINE( 275)						int ii_min83 = ::Math_obj::floor(rightX);
HXDLIN( 275)						int ii_max83 = ::Math_obj::ceil(rightX);
HXDLIN( 275)						xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min83,ii_max83);
            					}
            				}
HXDLIN( 275)				 ::pi_xy::iter::IntIterStart yIter310;
HXDLIN( 275)				if ((ay3 > by3)) {
HXLINE( 275)					if ((ay3 > bottomY)) {
HXLINE( 275)						int min42;
HXDLIN( 275)						if ((by3 > bottomY)) {
HXLINE( 275)							min42 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 275)							min42 = ::Math_obj::floor(by3);
            						}
HXDLIN( 275)						int ii_min84 = min42;
HXDLIN( 275)						int ii_max84 = ::Math_obj::ceil(ay3);
HXDLIN( 275)						yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min84,ii_max84);
            					}
            					else {
HXLINE( 275)						int ii_min85 = ::Math_obj::floor(by3);
HXDLIN( 275)						int ii_max85 = ::Math_obj::ceil(bottomY);
HXDLIN( 275)						yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min85,ii_max85);
            					}
            				}
            				else {
HXLINE( 275)					if ((by3 > bottomY)) {
HXLINE( 275)						int min43;
HXDLIN( 275)						if ((ay3 > bottomY)) {
HXLINE( 275)							min43 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 275)							min43 = ::Math_obj::ceil(ay3);
            						}
HXDLIN( 275)						int ii_min86 = min43;
HXDLIN( 275)						int ii_max86 = ::Math_obj::ceil(by3);
HXDLIN( 275)						yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min86,ii_max86);
            					}
            					else {
HXLINE( 275)						int ii_min87 = ::Math_obj::floor(ay3);
HXDLIN( 275)						int ii_max87 = ::Math_obj::ceil(bottomY);
HXDLIN( 275)						yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min87,ii_max87);
            					}
            				}
HXDLIN( 275)				 ::pi_xy::ImageStruct undoImage30 = null();
HXDLIN( 275)				if (hasUndo10) {
HXLINE( 275)					int width10 = ((xIter310->max - xIter310->start) + 1);
HXDLIN( 275)					int height10 = ((yIter310->max - yIter310->start) + 1);
HXDLIN( 275)					 ::Dynamic imageType10 = null();
HXDLIN( 275)					 ::pi_xy::ImageStruct this341 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 275)					if (::hx::IsNull( imageType10 )) {
HXLINE(  54)						imageType10 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 275)					::Dynamic undoImage31;
HXDLIN( 275)					switch((int)(( (int)(imageType10) ))){
            						case (int)0: {
HXLINE( 275)							 ::iterMagic::BytesImg byt10 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::BytesImg b62 = byt10;
HXDLIN( 275)							{
HXLINE( 275)								b62->width = width10;
HXDLIN( 275)								b62->height = height10;
HXDLIN( 275)								b62->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 275)								b62->data = ::haxe::io::Bytes_obj::alloc((b62->length * 4));
HXDLIN( 275)								{
HXLINE( 275)									int len20 = b62->length;
HXDLIN( 275)									int w10 = 0;
HXDLIN( 275)									{
HXLINE( 275)										int _g200 = 0;
HXDLIN( 275)										int _g201 = b62->height;
HXDLIN( 275)										while((_g200 < _g201)){
HXLINE( 275)											_g200 = (_g200 + 1);
HXDLIN( 275)											int y41 = (_g200 - 1);
HXDLIN( 275)											{
HXLINE( 275)												int _g202 = 0;
HXDLIN( 275)												int _g203 = b62->width;
HXDLIN( 275)												while((_g202 < _g203)){
HXLINE( 275)													_g202 = (_g202 + 1);
HXDLIN( 275)													int x41 = (_g202 - 1);
HXDLIN( 275)													{
HXLINE( 275)														w10 = (w10 + 1);
HXDLIN( 275)														b62->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 275)													{
HXLINE( 275)														w10 = (w10 + 1);
HXDLIN( 275)														b62->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 275)													{
HXLINE( 275)														w10 = (w10 + 1);
HXDLIN( 275)														b62->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 275)													{
HXLINE( 275)														w10 = (w10 + 1);
HXDLIN( 275)														b62->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 275)							undoImage31 = b62;
            						}
            						break;
            						case (int)1: {
HXLINE( 275)							 ::iterMagic::ArrIntImg arrI10 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::ArrIntImg a56 = arrI10;
HXDLIN( 275)							{
HXLINE( 275)								a56->width = width10;
HXDLIN( 275)								a56->height = height10;
HXDLIN( 275)								a56->data = ::Array_obj< int >::__new(0);
HXDLIN( 275)								a56->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 275)								{
HXLINE( 275)									int _g204 = 0;
HXDLIN( 275)									int _g205 = a56->length;
HXDLIN( 275)									while((_g204 < _g205)){
HXLINE( 275)										_g204 = (_g204 + 1);
HXDLIN( 275)										int i60 = (_g204 - 1);
HXDLIN( 275)										a56->data[i60] = 0;
            									}
            								}
            							}
HXDLIN( 275)							undoImage31 = a56;
            						}
            						break;
            						case (int)2: {
HXLINE( 275)							 ::iterMagic::U32ArrImg u32a10 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::U32ArrImg b63 = u32a10;
HXDLIN( 275)							{
HXLINE( 275)								b63->width = width10;
HXDLIN( 275)								b63->height = height10;
HXDLIN( 275)								b63->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 275)								int size10 = (b63->length * 4);
HXDLIN( 275)								b63->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size10),0,size10);
HXDLIN( 275)								{
HXLINE( 275)									int _g206 = 0;
HXDLIN( 275)									int _g207 = b63->length;
HXDLIN( 275)									while((_g206 < _g207)){
HXLINE( 275)										_g206 = (_g206 + 1);
HXDLIN( 275)										int i61 = (_g206 - 1);
HXDLIN( 275)										{
HXLINE( 275)											 ::haxe::io::ArrayBufferViewImpl this342 = b63->data;
HXDLIN( 275)											bool undoImage32;
HXDLIN( 275)											if ((i61 >= 0)) {
HXLINE( 275)												undoImage32 = (i61 < (this342->byteLength >> 2));
            											}
            											else {
HXLINE( 275)												undoImage32 = false;
            											}
HXDLIN( 275)											if (undoImage32) {
HXLINE( 275)												 ::haxe::io::Bytes _this10 = this342->bytes;
HXDLIN( 275)												int pos10 = ((i61 << 2) + this342->byteOffset);
HXDLIN( 275)												_this10->b[pos10] = ( (unsigned char)(0) );
HXDLIN( 275)												_this10->b[(pos10 + 1)] = ( (unsigned char)(0) );
HXDLIN( 275)												_this10->b[(pos10 + 2)] = ( (unsigned char)(0) );
HXDLIN( 275)												_this10->b[(pos10 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 275)							undoImage31 = b63;
            						}
            						break;
            						case (int)3: {
HXLINE( 275)							 ::iterMagic::VecIntImg vec10 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::VecIntImg v45 = vec10;
HXDLIN( 275)							{
HXLINE( 275)								v45->width = width10;
HXDLIN( 275)								v45->height = height10;
HXDLIN( 275)								v45->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 275)								v45->data = ::Array_obj< int >::__new(v45->length);
HXDLIN( 275)								{
HXLINE( 275)									int _g208 = 0;
HXDLIN( 275)									int _g209 = v45->length;
HXDLIN( 275)									while((_g208 < _g209)){
HXLINE( 275)										_g208 = (_g208 + 1);
HXDLIN( 275)										int i62 = (_g208 - 1);
HXDLIN( 275)										v45->data->__unsafe_set(i62,0);
            									}
            								}
            							}
HXDLIN( 275)							undoImage31 = v45;
            						}
            						break;
            						case (int)4: {
HXLINE( 275)							 ::iterMagic::StackIntImg sInt10 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::StackIntImg b64 = sInt10;
HXDLIN( 275)							{
HXLINE( 275)								b64->width = width10;
HXDLIN( 275)								b64->height = height10;
HXDLIN( 275)								b64->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN( 275)								b64->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 275)								{
HXLINE( 275)									int len21 = b64->length;
HXDLIN( 275)									 ::haxe::ds::GenericStack_Int d10 = b64->data;
HXDLIN( 275)									if (::hx::IsNull( d10->head )) {
HXLINE( 275)										int _g210 = 0;
HXDLIN( 275)										int _g211 = len21;
HXDLIN( 275)										while((_g210 < _g211)){
HXLINE( 275)											_g210 = (_g210 + 1);
HXDLIN( 275)											int i63 = (_g210 - 1);
HXDLIN( 275)											d10->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d10->head);
            										}
            									}
            									else {
HXLINE( 275)										int _g212 = 0;
HXDLIN( 275)										int _g213 = len21;
HXDLIN( 275)										while((_g212 < _g213)){
HXLINE( 275)											_g212 = (_g212 + 1);
HXDLIN( 275)											int i64 = (_g212 - 1);
HXDLIN( 275)											{
HXLINE( 275)												 ::haxe::ds::GenericCell_Int l10 = b64->data->head;
HXDLIN( 275)												 ::haxe::ds::GenericCell_Int prev10 = null();
HXDLIN( 275)												{
HXLINE( 275)													int _g214 = 0;
HXDLIN( 275)													int _g215 = i64;
HXDLIN( 275)													while((_g214 < _g215)){
HXLINE( 275)														_g214 = (_g214 + 1);
HXDLIN( 275)														int i65 = (_g214 - 1);
HXLINE( 345)														prev10 = l10;
HXLINE( 346)														l10 = l10->next;
            													}
            												}
HXLINE( 275)												if (::hx::IsNull( prev10 )) {
HXLINE( 275)													b64->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l10->next);
HXDLIN( 275)													l10 = null();
            												}
            												else {
HXLINE( 275)													prev10->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l10->next);
HXDLIN( 275)													l10 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 275)							undoImage31 = b64;
            						}
            						break;
            					}
HXDLIN( 275)					this341->image = undoImage31;
HXDLIN( 275)					this341->width = width10;
HXDLIN( 275)					this341->height = height10;
HXDLIN( 275)					this341->imageType = ( (int)(imageType10) );
HXDLIN( 275)					undoImage30 = this341;
HXDLIN( 275)					{
HXLINE( 275)						int rectLeft10 = xIter310->start;
HXDLIN( 275)						int rectTop10 = yIter310->start;
HXDLIN( 275)						int rectRight10 = xIter310->max;
HXDLIN( 275)						bool forceClear10 = false;
HXDLIN( 275)						{
HXLINE( 275)							int _g216 = rectTop10;
HXDLIN( 275)							int _g217 = yIter310->max;
HXDLIN( 275)							while((_g216 < _g217)){
HXLINE( 275)								_g216 = (_g216 + 1);
HXDLIN( 275)								int dy11 = (_g216 - 1);
HXDLIN( 275)								{
HXLINE( 275)									int _g218 = rectLeft10;
HXDLIN( 275)									int _g219 = rectRight10;
HXDLIN( 275)									while((_g218 < _g219)){
HXLINE( 275)										_g218 = (_g218 + 1);
HXDLIN( 275)										int dx11 = (_g218 - 1);
HXDLIN( 275)										::Dynamic this343 = pixelImage->image;
HXDLIN( 275)										int index60;
HXDLIN( 275)										if (pixelImage->useVirtualPos) {
HXLINE( 275)											index60 = ::Std_obj::_hx_int(((((( (Float)(dy11) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx11) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 275)											index60 = ::Std_obj::_hx_int(( (Float)(((dy11 * pixelImage->width) + dx11)) ));
            										}
HXDLIN( 275)										int c50 = ::iterMagic::Iimg_obj::get(this343,index60);
HXDLIN( 275)										int col20;
HXDLIN( 275)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)											col20 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            										}
            										else {
HXLINE( 275)											col20 = c50;
            										}
HXDLIN( 275)										bool _hx_tmp90;
HXDLIN( 275)										if (pixelImage->useMask) {
HXLINE( 275)											_hx_tmp90 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 275)											_hx_tmp90 = false;
            										}
HXDLIN( 275)										if (_hx_tmp90) {
HXLINE( 275)											 ::pi_xy::ImageStruct this344 = pixelImage->mask;
HXDLIN( 275)											::Dynamic this345 = this344->image;
HXDLIN( 275)											int index61;
HXDLIN( 275)											if (this344->useVirtualPos) {
HXLINE( 275)												index61 = ::Std_obj::_hx_int(((((( (Float)(dy11) ) - this344->virtualY) * ( (Float)(this344->width) )) + dx11) - this344->virtualX));
            											}
            											else {
HXLINE( 275)												index61 = ::Std_obj::_hx_int(( (Float)(((dy11 * this344->width) + dx11)) ));
            											}
HXDLIN( 275)											int c51 = ::iterMagic::Iimg_obj::get(this345,index61);
HXDLIN( 275)											int v46;
HXDLIN( 275)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)												v46 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            											}
            											else {
HXLINE( 275)												v46 = c51;
            											}
HXDLIN( 275)											int maskPixel10 = v46;
HXDLIN( 275)											int this346 = col20;
HXDLIN( 275)											if ((maskPixel10 == 0)) {
HXLINE( 275)												col20 = this346;
            											}
            											else {
HXLINE( 275)												Float m010;
HXDLIN( 275)												int this347 = ((maskPixel10 >> 24) & 255);
HXDLIN( 275)												if ((this347 == 0)) {
HXLINE( 275)													m010 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													m010 = (( (Float)(this347) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float m110;
HXDLIN( 275)												int this348 = ((maskPixel10 >> 16) & 255);
HXDLIN( 275)												if ((this348 == 0)) {
HXLINE( 275)													m110 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													m110 = (( (Float)(this348) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float m210;
HXDLIN( 275)												int this349 = ((maskPixel10 >> 8) & 255);
HXDLIN( 275)												if ((this349 == 0)) {
HXLINE( 275)													m210 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													m210 = (( (Float)(this349) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float m310;
HXDLIN( 275)												int this350 = (maskPixel10 & 255);
HXDLIN( 275)												if ((this350 == 0)) {
HXLINE( 275)													m310 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													m310 = (( (Float)(this350) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												int ch010 = ::Std_obj::_hx_int(((((Float)1.) - m010) * ( (Float)(((this346 >> 24) & 255)) )));
HXDLIN( 275)												int ch110 = ::Std_obj::_hx_int(((((Float)1.) - m110) * ( (Float)(((this346 >> 16) & 255)) )));
HXDLIN( 275)												int ch210 = ::Std_obj::_hx_int(((((Float)1.) - m210) * ( (Float)(((this346 >> 8) & 255)) )));
HXDLIN( 275)												int ch310 = ::Std_obj::_hx_int(((((Float)1.) - m310) * ( (Float)((this346 & 255)) )));
HXDLIN( 275)												col20 = ((((::Math_obj::round((( (Float)(ch010) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch110) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch210) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch310) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 275)										if ((col20 != 0)) {
HXLINE( 275)											int x42 = (dx11 - rectLeft10);
HXDLIN( 275)											int y42 = (dy11 - rectTop10);
HXDLIN( 275)											int c52 = col20;
HXDLIN( 275)											bool _hx_tmp91;
HXDLIN( 275)											if ((((c52 >> 24) & 255) < 254)) {
HXLINE( 275)												_hx_tmp91 = undoImage30->transparent;
            											}
            											else {
HXLINE( 275)												_hx_tmp91 = false;
            											}
HXDLIN( 275)											if (_hx_tmp91) {
HXLINE( 275)												int location20;
HXDLIN( 275)												if (undoImage30->useVirtualPos) {
HXLINE( 275)													location20 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x42) - undoImage30->virtualX));
            												}
            												else {
HXLINE( 275)													location20 = ::Std_obj::_hx_int(( (Float)(((y42 * undoImage30->width) + x42)) ));
            												}
HXDLIN( 275)												int this351 = ::iterMagic::Iimg_obj::get(undoImage30->image,location20);
HXDLIN( 275)												int this352;
HXDLIN( 275)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)													this352 = ((((((this351 >> 24) & 255) << 24) | ((this351 & 255) << 16)) | (((this351 >> 8) & 255) << 8)) | ((this351 >> 16) & 255));
            												}
            												else {
HXLINE( 275)													this352 = this351;
            												}
HXDLIN( 275)												Float a123;
HXDLIN( 275)												int this353 = ((this352 >> 24) & 255);
HXDLIN( 275)												if ((this353 == 0)) {
HXLINE( 275)													a123 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													a123 = (( (Float)(this353) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float r120;
HXDLIN( 275)												int this354 = ((this352 >> 16) & 255);
HXDLIN( 275)												if ((this354 == 0)) {
HXLINE( 275)													r120 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													r120 = (( (Float)(this354) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float g120;
HXDLIN( 275)												int this355 = ((this352 >> 8) & 255);
HXDLIN( 275)												if ((this355 == 0)) {
HXLINE( 275)													g120 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													g120 = (( (Float)(this355) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float b124;
HXDLIN( 275)												int this356 = (this352 & 255);
HXDLIN( 275)												if ((this356 == 0)) {
HXLINE( 275)													b124 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													b124 = (( (Float)(this356) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float a221;
HXDLIN( 275)												int this357 = ((col20 >> 24) & 255);
HXDLIN( 275)												if ((this357 == 0)) {
HXLINE( 275)													a221 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													a221 = (( (Float)(this357) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float r220;
HXDLIN( 275)												int this358 = ((col20 >> 16) & 255);
HXDLIN( 275)												if ((this358 == 0)) {
HXLINE( 275)													r220 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													r220 = (( (Float)(this358) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float g220;
HXDLIN( 275)												int this359 = ((col20 >> 8) & 255);
HXDLIN( 275)												if ((this359 == 0)) {
HXLINE( 275)													g220 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													g220 = (( (Float)(this359) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float b224;
HXDLIN( 275)												int this360 = (col20 & 255);
HXDLIN( 275)												if ((this360 == 0)) {
HXLINE( 275)													b224 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													b224 = (( (Float)(this360) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float a320 = (a123 * (( (Float)(1) ) - a221));
HXDLIN( 275)												int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a221))));
HXDLIN( 275)												int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a221))));
HXDLIN( 275)												int b65 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a320) + (b224 * a221))));
HXDLIN( 275)												int a57 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a221)));
HXDLIN( 275)												int blended20 = ((((a57 << 24) | (r40 << 16)) | (g40 << 8)) | b65);
HXDLIN( 275)												{
HXLINE( 275)													int _hx_tmp92;
HXDLIN( 275)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)														_hx_tmp92 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            													}
            													else {
HXLINE( 275)														_hx_tmp92 = blended20;
            													}
HXDLIN( 275)													::iterMagic::Iimg_obj::set(undoImage30->image,location20,_hx_tmp92);
            												}
            											}
            											else {
HXLINE( 275)												::Dynamic this361 = undoImage30->image;
HXDLIN( 275)												int index62;
HXDLIN( 275)												if (undoImage30->useVirtualPos) {
HXLINE( 275)													index62 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x42) - undoImage30->virtualX));
            												}
            												else {
HXLINE( 275)													index62 = ::Std_obj::_hx_int(( (Float)(((y42 * undoImage30->width) + x42)) ));
            												}
HXDLIN( 275)												int _hx_tmp93;
HXDLIN( 275)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)													_hx_tmp93 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            												}
            												else {
HXLINE( 275)													_hx_tmp93 = c52;
            												}
HXDLIN( 275)												::iterMagic::Iimg_obj::set(this361,index62,_hx_tmp93);
            											}
            										}
            										else {
HXLINE( 275)											if (forceClear10) {
HXLINE( 275)												::Dynamic this362 = undoImage30->image;
HXDLIN( 275)												int x43 = (dx11 - rectLeft10);
HXDLIN( 275)												int y43 = (dy11 - rectTop10);
HXDLIN( 275)												int index63;
HXDLIN( 275)												if (undoImage30->useVirtualPos) {
HXLINE( 275)													index63 = ::Std_obj::_hx_int(((((( (Float)(y43) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x43) - undoImage30->virtualX));
            												}
            												else {
HXLINE( 275)													index63 = ::Std_obj::_hx_int(( (Float)(((y43 * undoImage30->width) + x43)) ));
            												}
HXDLIN( 275)												::iterMagic::Iimg_obj::set(this362,index63,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 275)				{
HXLINE( 275)					int _g_min20 = xIter310->start;
HXDLIN( 275)					int _g_max20 = xIter310->max;
HXDLIN( 275)					while((_g_min20 < _g_max20)){
HXLINE( 275)						_g_min20 = (_g_min20 + 1);
HXDLIN( 275)						int px10 = (_g_min20 - 1);
HXDLIN( 275)						Float pcx10 = (( (Float)(px10) ) - rightX);
HXDLIN( 275)						{
HXLINE( 275)							int _g_min21 = yIter310->start;
HXDLIN( 275)							int _g_max21 = yIter310->max;
HXDLIN( 275)							while((_g_min21 < _g_max21)){
HXLINE( 275)								_g_min21 = (_g_min21 + 1);
HXDLIN( 275)								int py10 = (_g_min21 - 1);
HXDLIN( 275)								Float pcy10 = (( (Float)(py10) ) - bottomY);
HXDLIN( 275)								Float dot3110 = ((pcx10 * bcx10) + (pcy10 * bcy10));
HXDLIN( 275)								Float dot3210 = ((pcx10 * acx10) + (pcy10 * acy10));
HXDLIN( 275)								Float ratioA10 = (((dot2210 * dot3110) - (dot1210 * dot3210)) * denom110);
HXDLIN( 275)								Float ratioB10 = (((dot1110 * dot3210) - (dot1210 * dot3110)) * denom110);
HXDLIN( 275)								Float ratioC10 = ((((Float)1.0) - ratioB10) - ratioA10);
HXDLIN( 275)								bool _hx_tmp94;
HXDLIN( 275)								bool _hx_tmp95;
HXDLIN( 275)								if ((ratioA10 >= 0)) {
HXLINE( 275)									_hx_tmp95 = (ratioB10 >= 0);
            								}
            								else {
HXLINE( 275)									_hx_tmp95 = false;
            								}
HXDLIN( 275)								if (_hx_tmp95) {
HXLINE( 275)									_hx_tmp94 = (ratioC10 >= 0);
            								}
            								else {
HXLINE( 275)									_hx_tmp94 = false;
            								}
HXDLIN( 275)								if (_hx_tmp94) {
HXLINE( 275)									Float u10 = (((au11 * ratioA10) + (bu11 * ratioB10)) + (au * ratioC10));
HXDLIN( 275)									Float v47 = (((av11 * ratioA10) + (bv10 * ratioB10)) + (cv * ratioC10));
HXDLIN( 275)									int x44 = ::Std_obj::_hx_int(((u10 * win->width) + win->x));
HXDLIN( 275)									int y44 = ::Std_obj::_hx_int(((v47 * win->height) + win->y));
HXDLIN( 275)									::Dynamic this363 = texture->image;
HXDLIN( 275)									int index64;
HXDLIN( 275)									if (texture->useVirtualPos) {
HXLINE( 275)										index64 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - texture->virtualY) * ( (Float)(texture->width) )) + x44) - texture->virtualX));
            									}
            									else {
HXLINE( 275)										index64 = ::Std_obj::_hx_int(( (Float)(((y44 * texture->width) + x44)) ));
            									}
HXDLIN( 275)									int c53 = ::iterMagic::Iimg_obj::get(this363,index64);
HXDLIN( 275)									int col21;
HXDLIN( 275)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)										col21 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            									}
            									else {
HXLINE( 275)										col21 = c53;
            									}
HXDLIN( 275)									{
HXLINE( 275)										int c54 = col21;
HXDLIN( 275)										bool _hx_tmp96;
HXDLIN( 275)										if ((((c54 >> 24) & 255) < 254)) {
HXLINE( 275)											_hx_tmp96 = pixelImage->transparent;
            										}
            										else {
HXLINE( 275)											_hx_tmp96 = false;
            										}
HXDLIN( 275)										if (_hx_tmp96) {
HXLINE( 275)											int location21;
HXDLIN( 275)											if (pixelImage->useVirtualPos) {
HXLINE( 275)												location21 = ::Std_obj::_hx_int(((((( (Float)(py10) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px10) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 275)												location21 = ::Std_obj::_hx_int(( (Float)(((py10 * pixelImage->width) + px10)) ));
            											}
HXDLIN( 275)											int this364 = ::iterMagic::Iimg_obj::get(pixelImage->image,location21);
HXDLIN( 275)											int this365;
HXDLIN( 275)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)												this365 = ((((((this364 >> 24) & 255) << 24) | ((this364 & 255) << 16)) | (((this364 >> 8) & 255) << 8)) | ((this364 >> 16) & 255));
            											}
            											else {
HXLINE( 275)												this365 = this364;
            											}
HXDLIN( 275)											Float a124;
HXDLIN( 275)											int this366 = ((this365 >> 24) & 255);
HXDLIN( 275)											if ((this366 == 0)) {
HXLINE( 275)												a124 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												a124 = (( (Float)(this366) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float r121;
HXDLIN( 275)											int this367 = ((this365 >> 16) & 255);
HXDLIN( 275)											if ((this367 == 0)) {
HXLINE( 275)												r121 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												r121 = (( (Float)(this367) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float g121;
HXDLIN( 275)											int this368 = ((this365 >> 8) & 255);
HXDLIN( 275)											if ((this368 == 0)) {
HXLINE( 275)												g121 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												g121 = (( (Float)(this368) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float b125;
HXDLIN( 275)											int this369 = (this365 & 255);
HXDLIN( 275)											if ((this369 == 0)) {
HXLINE( 275)												b125 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												b125 = (( (Float)(this369) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float a222;
HXDLIN( 275)											int this370 = ((col21 >> 24) & 255);
HXDLIN( 275)											if ((this370 == 0)) {
HXLINE( 275)												a222 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												a222 = (( (Float)(this370) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float r221;
HXDLIN( 275)											int this371 = ((col21 >> 16) & 255);
HXDLIN( 275)											if ((this371 == 0)) {
HXLINE( 275)												r221 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												r221 = (( (Float)(this371) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float g221;
HXDLIN( 275)											int this372 = ((col21 >> 8) & 255);
HXDLIN( 275)											if ((this372 == 0)) {
HXLINE( 275)												g221 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												g221 = (( (Float)(this372) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float b225;
HXDLIN( 275)											int this373 = (col21 & 255);
HXDLIN( 275)											if ((this373 == 0)) {
HXLINE( 275)												b225 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												b225 = (( (Float)(this373) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float a321 = (a124 * (( (Float)(1) ) - a222));
HXDLIN( 275)											int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a222))));
HXDLIN( 275)											int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a222))));
HXDLIN( 275)											int b66 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a321) + (b225 * a222))));
HXDLIN( 275)											int a58 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a222)));
HXDLIN( 275)											int blended21 = ((((a58 << 24) | (r41 << 16)) | (g41 << 8)) | b66);
HXDLIN( 275)											{
HXLINE( 275)												int _hx_tmp97;
HXDLIN( 275)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)													_hx_tmp97 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            												}
            												else {
HXLINE( 275)													_hx_tmp97 = blended21;
            												}
HXDLIN( 275)												::iterMagic::Iimg_obj::set(pixelImage->image,location21,_hx_tmp97);
            											}
            										}
            										else {
HXLINE( 275)											::Dynamic this374 = pixelImage->image;
HXDLIN( 275)											int index65;
HXDLIN( 275)											if (pixelImage->useVirtualPos) {
HXLINE( 275)												index65 = ::Std_obj::_hx_int(((((( (Float)(py10) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px10) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 275)												index65 = ::Std_obj::_hx_int(( (Float)(((py10 * pixelImage->width) + px10)) ));
            											}
HXDLIN( 275)											int _hx_tmp98;
HXDLIN( 275)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)												_hx_tmp98 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            											}
            											else {
HXLINE( 275)												_hx_tmp98 = c54;
            											}
HXDLIN( 275)											::iterMagic::Iimg_obj::set(this374,index65,_hx_tmp98);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 275)				if ((hasHit == false)) {
HXLINE( 275)					 ::pi_xy::algo::HitTri v48 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,ay3,bx2,by3,rightX,bottomY,true);
HXDLIN( 275)					if (hasUndo10) {
HXLINE( 275)						v48->undoImage = undoImage30;
HXDLIN( 275)						v48->undoX = xIter310->start;
HXDLIN( 275)						v48->undoY = yIter310->start;
            					}
            				}
            			}
HXDLIN( 275)			{
HXLINE( 275)				Float au12 = bu;
HXDLIN( 275)				Float av12 = av;
HXDLIN( 275)				Float bu12 = bu;
HXDLIN( 275)				Float bv11 = cv;
HXDLIN( 275)				bool hasUndo11 = false;
HXDLIN( 275)				Float temp11 = au12;
HXLINE( 422)				au12 = bu12;
HXLINE( 423)				bu12 = temp11;
HXLINE( 424)				temp11 = av12;
HXLINE( 425)				av12 = bv11;
HXLINE( 426)				bv11 = temp11;
HXLINE( 275)				Float bcx11 = (cx2 - rightX);
HXDLIN( 275)				Float bcy11 = (cy3 - bottomY);
HXDLIN( 275)				Float acx11 = (bx2 - rightX);
HXDLIN( 275)				Float acy11 = (by3 - bottomY);
HXDLIN( 275)				Float dot1111 = ((bcx11 * bcx11) + (bcy11 * bcy11));
HXDLIN( 275)				Float dot1211 = ((bcx11 * acx11) + (bcy11 * acy11));
HXDLIN( 275)				Float dot2211 = ((acx11 * acx11) + (acy11 * acy11));
HXDLIN( 275)				Float denom111 = (( (Float)(1) ) / ((dot1111 * dot2211) - (dot1211 * dot1211)));
HXDLIN( 275)				 ::pi_xy::iter::IntIterStart xIter311;
HXDLIN( 275)				if ((bx2 > cx2)) {
HXLINE( 275)					if ((bx2 > rightX)) {
HXLINE( 275)						int min44;
HXDLIN( 275)						if ((cx2 > rightX)) {
HXLINE( 275)							min44 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 275)							min44 = ::Math_obj::floor(cx2);
            						}
HXDLIN( 275)						int ii_min88 = min44;
HXDLIN( 275)						int ii_max88 = ::Math_obj::ceil(bx2);
HXDLIN( 275)						xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min88,ii_max88);
            					}
            					else {
HXLINE( 275)						int ii_min89 = ::Math_obj::floor(cx2);
HXDLIN( 275)						int ii_max89 = ::Math_obj::ceil(rightX);
HXDLIN( 275)						xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min89,ii_max89);
            					}
            				}
            				else {
HXLINE( 275)					if ((cx2 > rightX)) {
HXLINE( 275)						int min45;
HXDLIN( 275)						if ((bx2 > rightX)) {
HXLINE( 275)							min45 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 275)							min45 = ::Math_obj::ceil(bx2);
            						}
HXDLIN( 275)						int ii_min90 = min45;
HXDLIN( 275)						int ii_max90 = ::Math_obj::ceil(cx2);
HXDLIN( 275)						xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min90,ii_max90);
            					}
            					else {
HXLINE( 275)						int ii_min91 = ::Math_obj::floor(bx2);
HXDLIN( 275)						int ii_max91 = ::Math_obj::ceil(rightX);
HXDLIN( 275)						xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min91,ii_max91);
            					}
            				}
HXDLIN( 275)				 ::pi_xy::iter::IntIterStart yIter311;
HXDLIN( 275)				if ((by3 > cy3)) {
HXLINE( 275)					if ((by3 > bottomY)) {
HXLINE( 275)						int min46;
HXDLIN( 275)						if ((cy3 > bottomY)) {
HXLINE( 275)							min46 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 275)							min46 = ::Math_obj::floor(cy3);
            						}
HXDLIN( 275)						int ii_min92 = min46;
HXDLIN( 275)						int ii_max92 = ::Math_obj::ceil(by3);
HXDLIN( 275)						yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min92,ii_max92);
            					}
            					else {
HXLINE( 275)						int ii_min93 = ::Math_obj::floor(cy3);
HXDLIN( 275)						int ii_max93 = ::Math_obj::ceil(bottomY);
HXDLIN( 275)						yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min93,ii_max93);
            					}
            				}
            				else {
HXLINE( 275)					if ((cy3 > bottomY)) {
HXLINE( 275)						int min47;
HXDLIN( 275)						if ((by3 > bottomY)) {
HXLINE( 275)							min47 = ::Math_obj::floor(bottomY);
            						}
            						else {
HXLINE( 275)							min47 = ::Math_obj::ceil(by3);
            						}
HXDLIN( 275)						int ii_min94 = min47;
HXDLIN( 275)						int ii_max94 = ::Math_obj::ceil(cy3);
HXDLIN( 275)						yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min94,ii_max94);
            					}
            					else {
HXLINE( 275)						int ii_min95 = ::Math_obj::floor(by3);
HXDLIN( 275)						int ii_max95 = ::Math_obj::ceil(bottomY);
HXDLIN( 275)						yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min95,ii_max95);
            					}
            				}
HXDLIN( 275)				 ::pi_xy::ImageStruct undoImage33 = null();
HXDLIN( 275)				if (hasUndo11) {
HXLINE( 275)					int width11 = ((xIter311->max - xIter311->start) + 1);
HXDLIN( 275)					int height11 = ((yIter311->max - yIter311->start) + 1);
HXDLIN( 275)					 ::Dynamic imageType11 = null();
HXDLIN( 275)					 ::pi_xy::ImageStruct this375 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 275)					if (::hx::IsNull( imageType11 )) {
HXLINE(  54)						imageType11 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 275)					::Dynamic undoImage34;
HXDLIN( 275)					switch((int)(( (int)(imageType11) ))){
            						case (int)0: {
HXLINE( 275)							 ::iterMagic::BytesImg byt11 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::BytesImg b67 = byt11;
HXDLIN( 275)							{
HXLINE( 275)								b67->width = width11;
HXDLIN( 275)								b67->height = height11;
HXDLIN( 275)								b67->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 275)								b67->data = ::haxe::io::Bytes_obj::alloc((b67->length * 4));
HXDLIN( 275)								{
HXLINE( 275)									int len22 = b67->length;
HXDLIN( 275)									int w11 = 0;
HXDLIN( 275)									{
HXLINE( 275)										int _g220 = 0;
HXDLIN( 275)										int _g221 = b67->height;
HXDLIN( 275)										while((_g220 < _g221)){
HXLINE( 275)											_g220 = (_g220 + 1);
HXDLIN( 275)											int y45 = (_g220 - 1);
HXDLIN( 275)											{
HXLINE( 275)												int _g222 = 0;
HXDLIN( 275)												int _g223 = b67->width;
HXDLIN( 275)												while((_g222 < _g223)){
HXLINE( 275)													_g222 = (_g222 + 1);
HXDLIN( 275)													int x45 = (_g222 - 1);
HXDLIN( 275)													{
HXLINE( 275)														w11 = (w11 + 1);
HXDLIN( 275)														b67->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 275)													{
HXLINE( 275)														w11 = (w11 + 1);
HXDLIN( 275)														b67->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 275)													{
HXLINE( 275)														w11 = (w11 + 1);
HXDLIN( 275)														b67->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 275)													{
HXLINE( 275)														w11 = (w11 + 1);
HXDLIN( 275)														b67->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 275)							undoImage34 = b67;
            						}
            						break;
            						case (int)1: {
HXLINE( 275)							 ::iterMagic::ArrIntImg arrI11 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::ArrIntImg a59 = arrI11;
HXDLIN( 275)							{
HXLINE( 275)								a59->width = width11;
HXDLIN( 275)								a59->height = height11;
HXDLIN( 275)								a59->data = ::Array_obj< int >::__new(0);
HXDLIN( 275)								a59->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 275)								{
HXLINE( 275)									int _g224 = 0;
HXDLIN( 275)									int _g225 = a59->length;
HXDLIN( 275)									while((_g224 < _g225)){
HXLINE( 275)										_g224 = (_g224 + 1);
HXDLIN( 275)										int i66 = (_g224 - 1);
HXDLIN( 275)										a59->data[i66] = 0;
            									}
            								}
            							}
HXDLIN( 275)							undoImage34 = a59;
            						}
            						break;
            						case (int)2: {
HXLINE( 275)							 ::iterMagic::U32ArrImg u32a11 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::U32ArrImg b68 = u32a11;
HXDLIN( 275)							{
HXLINE( 275)								b68->width = width11;
HXDLIN( 275)								b68->height = height11;
HXDLIN( 275)								b68->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 275)								int size11 = (b68->length * 4);
HXDLIN( 275)								b68->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size11),0,size11);
HXDLIN( 275)								{
HXLINE( 275)									int _g226 = 0;
HXDLIN( 275)									int _g227 = b68->length;
HXDLIN( 275)									while((_g226 < _g227)){
HXLINE( 275)										_g226 = (_g226 + 1);
HXDLIN( 275)										int i67 = (_g226 - 1);
HXDLIN( 275)										{
HXLINE( 275)											 ::haxe::io::ArrayBufferViewImpl this376 = b68->data;
HXDLIN( 275)											bool undoImage35;
HXDLIN( 275)											if ((i67 >= 0)) {
HXLINE( 275)												undoImage35 = (i67 < (this376->byteLength >> 2));
            											}
            											else {
HXLINE( 275)												undoImage35 = false;
            											}
HXDLIN( 275)											if (undoImage35) {
HXLINE( 275)												 ::haxe::io::Bytes _this11 = this376->bytes;
HXDLIN( 275)												int pos11 = ((i67 << 2) + this376->byteOffset);
HXDLIN( 275)												_this11->b[pos11] = ( (unsigned char)(0) );
HXDLIN( 275)												_this11->b[(pos11 + 1)] = ( (unsigned char)(0) );
HXDLIN( 275)												_this11->b[(pos11 + 2)] = ( (unsigned char)(0) );
HXDLIN( 275)												_this11->b[(pos11 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 275)							undoImage34 = b68;
            						}
            						break;
            						case (int)3: {
HXLINE( 275)							 ::iterMagic::VecIntImg vec11 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::VecIntImg v49 = vec11;
HXDLIN( 275)							{
HXLINE( 275)								v49->width = width11;
HXDLIN( 275)								v49->height = height11;
HXDLIN( 275)								v49->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 275)								v49->data = ::Array_obj< int >::__new(v49->length);
HXDLIN( 275)								{
HXLINE( 275)									int _g228 = 0;
HXDLIN( 275)									int _g229 = v49->length;
HXDLIN( 275)									while((_g228 < _g229)){
HXLINE( 275)										_g228 = (_g228 + 1);
HXDLIN( 275)										int i68 = (_g228 - 1);
HXDLIN( 275)										v49->data->__unsafe_set(i68,0);
            									}
            								}
            							}
HXDLIN( 275)							undoImage34 = v49;
            						}
            						break;
            						case (int)4: {
HXLINE( 275)							 ::iterMagic::StackIntImg sInt11 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 275)							 ::iterMagic::StackIntImg b69 = sInt11;
HXDLIN( 275)							{
HXLINE( 275)								b69->width = width11;
HXDLIN( 275)								b69->height = height11;
HXDLIN( 275)								b69->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN( 275)								b69->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 275)								{
HXLINE( 275)									int len23 = b69->length;
HXDLIN( 275)									 ::haxe::ds::GenericStack_Int d11 = b69->data;
HXDLIN( 275)									if (::hx::IsNull( d11->head )) {
HXLINE( 275)										int _g230 = 0;
HXDLIN( 275)										int _g231 = len23;
HXDLIN( 275)										while((_g230 < _g231)){
HXLINE( 275)											_g230 = (_g230 + 1);
HXDLIN( 275)											int i69 = (_g230 - 1);
HXDLIN( 275)											d11->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d11->head);
            										}
            									}
            									else {
HXLINE( 275)										int _g232 = 0;
HXDLIN( 275)										int _g233 = len23;
HXDLIN( 275)										while((_g232 < _g233)){
HXLINE( 275)											_g232 = (_g232 + 1);
HXDLIN( 275)											int i70 = (_g232 - 1);
HXDLIN( 275)											{
HXLINE( 275)												 ::haxe::ds::GenericCell_Int l11 = b69->data->head;
HXDLIN( 275)												 ::haxe::ds::GenericCell_Int prev11 = null();
HXDLIN( 275)												{
HXLINE( 275)													int _g234 = 0;
HXDLIN( 275)													int _g235 = i70;
HXDLIN( 275)													while((_g234 < _g235)){
HXLINE( 275)														_g234 = (_g234 + 1);
HXDLIN( 275)														int i71 = (_g234 - 1);
HXLINE( 345)														prev11 = l11;
HXLINE( 346)														l11 = l11->next;
            													}
            												}
HXLINE( 275)												if (::hx::IsNull( prev11 )) {
HXLINE( 275)													b69->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l11->next);
HXDLIN( 275)													l11 = null();
            												}
            												else {
HXLINE( 275)													prev11->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l11->next);
HXDLIN( 275)													l11 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 275)							undoImage34 = b69;
            						}
            						break;
            					}
HXDLIN( 275)					this375->image = undoImage34;
HXDLIN( 275)					this375->width = width11;
HXDLIN( 275)					this375->height = height11;
HXDLIN( 275)					this375->imageType = ( (int)(imageType11) );
HXDLIN( 275)					undoImage33 = this375;
HXDLIN( 275)					{
HXLINE( 275)						int rectLeft11 = xIter311->start;
HXDLIN( 275)						int rectTop11 = yIter311->start;
HXDLIN( 275)						int rectRight11 = xIter311->max;
HXDLIN( 275)						bool forceClear11 = false;
HXDLIN( 275)						{
HXLINE( 275)							int _g236 = rectTop11;
HXDLIN( 275)							int _g237 = yIter311->max;
HXDLIN( 275)							while((_g236 < _g237)){
HXLINE( 275)								_g236 = (_g236 + 1);
HXDLIN( 275)								int dy12 = (_g236 - 1);
HXDLIN( 275)								{
HXLINE( 275)									int _g238 = rectLeft11;
HXDLIN( 275)									int _g239 = rectRight11;
HXDLIN( 275)									while((_g238 < _g239)){
HXLINE( 275)										_g238 = (_g238 + 1);
HXDLIN( 275)										int dx12 = (_g238 - 1);
HXDLIN( 275)										::Dynamic this377 = pixelImage->image;
HXDLIN( 275)										int index66;
HXDLIN( 275)										if (pixelImage->useVirtualPos) {
HXLINE( 275)											index66 = ::Std_obj::_hx_int(((((( (Float)(dy12) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx12) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 275)											index66 = ::Std_obj::_hx_int(( (Float)(((dy12 * pixelImage->width) + dx12)) ));
            										}
HXDLIN( 275)										int c55 = ::iterMagic::Iimg_obj::get(this377,index66);
HXDLIN( 275)										int col22;
HXDLIN( 275)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)											col22 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            										}
            										else {
HXLINE( 275)											col22 = c55;
            										}
HXDLIN( 275)										bool _hx_tmp99;
HXDLIN( 275)										if (pixelImage->useMask) {
HXLINE( 275)											_hx_tmp99 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 275)											_hx_tmp99 = false;
            										}
HXDLIN( 275)										if (_hx_tmp99) {
HXLINE( 275)											 ::pi_xy::ImageStruct this378 = pixelImage->mask;
HXDLIN( 275)											::Dynamic this379 = this378->image;
HXDLIN( 275)											int index67;
HXDLIN( 275)											if (this378->useVirtualPos) {
HXLINE( 275)												index67 = ::Std_obj::_hx_int(((((( (Float)(dy12) ) - this378->virtualY) * ( (Float)(this378->width) )) + dx12) - this378->virtualX));
            											}
            											else {
HXLINE( 275)												index67 = ::Std_obj::_hx_int(( (Float)(((dy12 * this378->width) + dx12)) ));
            											}
HXDLIN( 275)											int c56 = ::iterMagic::Iimg_obj::get(this379,index67);
HXDLIN( 275)											int v50;
HXDLIN( 275)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)												v50 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            											}
            											else {
HXLINE( 275)												v50 = c56;
            											}
HXDLIN( 275)											int maskPixel11 = v50;
HXDLIN( 275)											int this380 = col22;
HXDLIN( 275)											if ((maskPixel11 == 0)) {
HXLINE( 275)												col22 = this380;
            											}
            											else {
HXLINE( 275)												Float m011;
HXDLIN( 275)												int this381 = ((maskPixel11 >> 24) & 255);
HXDLIN( 275)												if ((this381 == 0)) {
HXLINE( 275)													m011 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													m011 = (( (Float)(this381) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float m111;
HXDLIN( 275)												int this382 = ((maskPixel11 >> 16) & 255);
HXDLIN( 275)												if ((this382 == 0)) {
HXLINE( 275)													m111 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													m111 = (( (Float)(this382) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float m211;
HXDLIN( 275)												int this383 = ((maskPixel11 >> 8) & 255);
HXDLIN( 275)												if ((this383 == 0)) {
HXLINE( 275)													m211 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													m211 = (( (Float)(this383) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float m311;
HXDLIN( 275)												int this384 = (maskPixel11 & 255);
HXDLIN( 275)												if ((this384 == 0)) {
HXLINE( 275)													m311 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													m311 = (( (Float)(this384) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												int ch011 = ::Std_obj::_hx_int(((((Float)1.) - m011) * ( (Float)(((this380 >> 24) & 255)) )));
HXDLIN( 275)												int ch111 = ::Std_obj::_hx_int(((((Float)1.) - m111) * ( (Float)(((this380 >> 16) & 255)) )));
HXDLIN( 275)												int ch211 = ::Std_obj::_hx_int(((((Float)1.) - m211) * ( (Float)(((this380 >> 8) & 255)) )));
HXDLIN( 275)												int ch311 = ::Std_obj::_hx_int(((((Float)1.) - m311) * ( (Float)((this380 & 255)) )));
HXDLIN( 275)												col22 = ((((::Math_obj::round((( (Float)(ch011) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch111) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch211) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch311) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 275)										if ((col22 != 0)) {
HXLINE( 275)											int x46 = (dx12 - rectLeft11);
HXDLIN( 275)											int y46 = (dy12 - rectTop11);
HXDLIN( 275)											int c57 = col22;
HXDLIN( 275)											bool _hx_tmp100;
HXDLIN( 275)											if ((((c57 >> 24) & 255) < 254)) {
HXLINE( 275)												_hx_tmp100 = undoImage33->transparent;
            											}
            											else {
HXLINE( 275)												_hx_tmp100 = false;
            											}
HXDLIN( 275)											if (_hx_tmp100) {
HXLINE( 275)												int location22;
HXDLIN( 275)												if (undoImage33->useVirtualPos) {
HXLINE( 275)													location22 = ::Std_obj::_hx_int(((((( (Float)(y46) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x46) - undoImage33->virtualX));
            												}
            												else {
HXLINE( 275)													location22 = ::Std_obj::_hx_int(( (Float)(((y46 * undoImage33->width) + x46)) ));
            												}
HXDLIN( 275)												int this385 = ::iterMagic::Iimg_obj::get(undoImage33->image,location22);
HXDLIN( 275)												int this386;
HXDLIN( 275)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)													this386 = ((((((this385 >> 24) & 255) << 24) | ((this385 & 255) << 16)) | (((this385 >> 8) & 255) << 8)) | ((this385 >> 16) & 255));
            												}
            												else {
HXLINE( 275)													this386 = this385;
            												}
HXDLIN( 275)												Float a125;
HXDLIN( 275)												int this387 = ((this386 >> 24) & 255);
HXDLIN( 275)												if ((this387 == 0)) {
HXLINE( 275)													a125 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													a125 = (( (Float)(this387) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float r122;
HXDLIN( 275)												int this388 = ((this386 >> 16) & 255);
HXDLIN( 275)												if ((this388 == 0)) {
HXLINE( 275)													r122 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													r122 = (( (Float)(this388) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float g122;
HXDLIN( 275)												int this389 = ((this386 >> 8) & 255);
HXDLIN( 275)												if ((this389 == 0)) {
HXLINE( 275)													g122 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													g122 = (( (Float)(this389) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float b126;
HXDLIN( 275)												int this390 = (this386 & 255);
HXDLIN( 275)												if ((this390 == 0)) {
HXLINE( 275)													b126 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													b126 = (( (Float)(this390) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float a223;
HXDLIN( 275)												int this391 = ((col22 >> 24) & 255);
HXDLIN( 275)												if ((this391 == 0)) {
HXLINE( 275)													a223 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													a223 = (( (Float)(this391) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float r222;
HXDLIN( 275)												int this392 = ((col22 >> 16) & 255);
HXDLIN( 275)												if ((this392 == 0)) {
HXLINE( 275)													r222 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													r222 = (( (Float)(this392) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float g222;
HXDLIN( 275)												int this393 = ((col22 >> 8) & 255);
HXDLIN( 275)												if ((this393 == 0)) {
HXLINE( 275)													g222 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													g222 = (( (Float)(this393) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float b226;
HXDLIN( 275)												int this394 = (col22 & 255);
HXDLIN( 275)												if ((this394 == 0)) {
HXLINE( 275)													b226 = ((Float)0.);
            												}
            												else {
HXLINE( 275)													b226 = (( (Float)(this394) ) / ( (Float)(255) ));
            												}
HXDLIN( 275)												Float a322 = (a125 * (( (Float)(1) ) - a223));
HXDLIN( 275)												int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a223))));
HXDLIN( 275)												int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a223))));
HXDLIN( 275)												int b70 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a322) + (b226 * a223))));
HXDLIN( 275)												int a60 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a223)));
HXDLIN( 275)												int blended22 = ((((a60 << 24) | (r42 << 16)) | (g42 << 8)) | b70);
HXDLIN( 275)												{
HXLINE( 275)													int _hx_tmp101;
HXDLIN( 275)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)														_hx_tmp101 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            													}
            													else {
HXLINE( 275)														_hx_tmp101 = blended22;
            													}
HXDLIN( 275)													::iterMagic::Iimg_obj::set(undoImage33->image,location22,_hx_tmp101);
            												}
            											}
            											else {
HXLINE( 275)												::Dynamic this395 = undoImage33->image;
HXDLIN( 275)												int index68;
HXDLIN( 275)												if (undoImage33->useVirtualPos) {
HXLINE( 275)													index68 = ::Std_obj::_hx_int(((((( (Float)(y46) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x46) - undoImage33->virtualX));
            												}
            												else {
HXLINE( 275)													index68 = ::Std_obj::_hx_int(( (Float)(((y46 * undoImage33->width) + x46)) ));
            												}
HXDLIN( 275)												int _hx_tmp102;
HXDLIN( 275)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)													_hx_tmp102 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            												}
            												else {
HXLINE( 275)													_hx_tmp102 = c57;
            												}
HXDLIN( 275)												::iterMagic::Iimg_obj::set(this395,index68,_hx_tmp102);
            											}
            										}
            										else {
HXLINE( 275)											if (forceClear11) {
HXLINE( 275)												::Dynamic this396 = undoImage33->image;
HXDLIN( 275)												int x47 = (dx12 - rectLeft11);
HXDLIN( 275)												int y47 = (dy12 - rectTop11);
HXDLIN( 275)												int index69;
HXDLIN( 275)												if (undoImage33->useVirtualPos) {
HXLINE( 275)													index69 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x47) - undoImage33->virtualX));
            												}
            												else {
HXLINE( 275)													index69 = ::Std_obj::_hx_int(( (Float)(((y47 * undoImage33->width) + x47)) ));
            												}
HXDLIN( 275)												::iterMagic::Iimg_obj::set(this396,index69,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 275)				{
HXLINE( 275)					int _g_min22 = xIter311->start;
HXDLIN( 275)					int _g_max22 = xIter311->max;
HXDLIN( 275)					while((_g_min22 < _g_max22)){
HXLINE( 275)						_g_min22 = (_g_min22 + 1);
HXDLIN( 275)						int px11 = (_g_min22 - 1);
HXDLIN( 275)						Float pcx11 = (( (Float)(px11) ) - rightX);
HXDLIN( 275)						{
HXLINE( 275)							int _g_min23 = yIter311->start;
HXDLIN( 275)							int _g_max23 = yIter311->max;
HXDLIN( 275)							while((_g_min23 < _g_max23)){
HXLINE( 275)								_g_min23 = (_g_min23 + 1);
HXDLIN( 275)								int py11 = (_g_min23 - 1);
HXDLIN( 275)								Float pcy11 = (( (Float)(py11) ) - bottomY);
HXDLIN( 275)								Float dot3111 = ((pcx11 * bcx11) + (pcy11 * bcy11));
HXDLIN( 275)								Float dot3211 = ((pcx11 * acx11) + (pcy11 * acy11));
HXDLIN( 275)								Float ratioA11 = (((dot2211 * dot3111) - (dot1211 * dot3211)) * denom111);
HXDLIN( 275)								Float ratioB11 = (((dot1111 * dot3211) - (dot1211 * dot3111)) * denom111);
HXDLIN( 275)								Float ratioC11 = ((((Float)1.0) - ratioB11) - ratioA11);
HXDLIN( 275)								bool _hx_tmp103;
HXDLIN( 275)								bool _hx_tmp104;
HXDLIN( 275)								if ((ratioA11 >= 0)) {
HXLINE( 275)									_hx_tmp104 = (ratioB11 >= 0);
            								}
            								else {
HXLINE( 275)									_hx_tmp104 = false;
            								}
HXDLIN( 275)								if (_hx_tmp104) {
HXLINE( 275)									_hx_tmp103 = (ratioC11 >= 0);
            								}
            								else {
HXLINE( 275)									_hx_tmp103 = false;
            								}
HXDLIN( 275)								if (_hx_tmp103) {
HXLINE( 275)									Float u11 = (((au12 * ratioA11) + (bu12 * ratioB11)) + (au * ratioC11));
HXDLIN( 275)									Float v51 = (((av12 * ratioA11) + (bv11 * ratioB11)) + (cv * ratioC11));
HXDLIN( 275)									int x48 = ::Std_obj::_hx_int(((u11 * win->width) + win->x));
HXDLIN( 275)									int y48 = ::Std_obj::_hx_int(((v51 * win->height) + win->y));
HXDLIN( 275)									::Dynamic this397 = texture->image;
HXDLIN( 275)									int index70;
HXDLIN( 275)									if (texture->useVirtualPos) {
HXLINE( 275)										index70 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - texture->virtualY) * ( (Float)(texture->width) )) + x48) - texture->virtualX));
            									}
            									else {
HXLINE( 275)										index70 = ::Std_obj::_hx_int(( (Float)(((y48 * texture->width) + x48)) ));
            									}
HXDLIN( 275)									int c58 = ::iterMagic::Iimg_obj::get(this397,index70);
HXDLIN( 275)									int col23;
HXDLIN( 275)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)										col23 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            									}
            									else {
HXLINE( 275)										col23 = c58;
            									}
HXDLIN( 275)									{
HXLINE( 275)										int c59 = col23;
HXDLIN( 275)										bool _hx_tmp105;
HXDLIN( 275)										if ((((c59 >> 24) & 255) < 254)) {
HXLINE( 275)											_hx_tmp105 = pixelImage->transparent;
            										}
            										else {
HXLINE( 275)											_hx_tmp105 = false;
            										}
HXDLIN( 275)										if (_hx_tmp105) {
HXLINE( 275)											int location23;
HXDLIN( 275)											if (pixelImage->useVirtualPos) {
HXLINE( 275)												location23 = ::Std_obj::_hx_int(((((( (Float)(py11) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px11) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 275)												location23 = ::Std_obj::_hx_int(( (Float)(((py11 * pixelImage->width) + px11)) ));
            											}
HXDLIN( 275)											int this398 = ::iterMagic::Iimg_obj::get(pixelImage->image,location23);
HXDLIN( 275)											int this399;
HXDLIN( 275)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)												this399 = ((((((this398 >> 24) & 255) << 24) | ((this398 & 255) << 16)) | (((this398 >> 8) & 255) << 8)) | ((this398 >> 16) & 255));
            											}
            											else {
HXLINE( 275)												this399 = this398;
            											}
HXDLIN( 275)											Float a126;
HXDLIN( 275)											int this400 = ((this399 >> 24) & 255);
HXDLIN( 275)											if ((this400 == 0)) {
HXLINE( 275)												a126 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												a126 = (( (Float)(this400) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float r123;
HXDLIN( 275)											int this401 = ((this399 >> 16) & 255);
HXDLIN( 275)											if ((this401 == 0)) {
HXLINE( 275)												r123 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												r123 = (( (Float)(this401) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float g123;
HXDLIN( 275)											int this402 = ((this399 >> 8) & 255);
HXDLIN( 275)											if ((this402 == 0)) {
HXLINE( 275)												g123 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												g123 = (( (Float)(this402) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float b127;
HXDLIN( 275)											int this403 = (this399 & 255);
HXDLIN( 275)											if ((this403 == 0)) {
HXLINE( 275)												b127 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												b127 = (( (Float)(this403) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float a224;
HXDLIN( 275)											int this404 = ((col23 >> 24) & 255);
HXDLIN( 275)											if ((this404 == 0)) {
HXLINE( 275)												a224 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												a224 = (( (Float)(this404) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float r223;
HXDLIN( 275)											int this405 = ((col23 >> 16) & 255);
HXDLIN( 275)											if ((this405 == 0)) {
HXLINE( 275)												r223 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												r223 = (( (Float)(this405) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float g223;
HXDLIN( 275)											int this406 = ((col23 >> 8) & 255);
HXDLIN( 275)											if ((this406 == 0)) {
HXLINE( 275)												g223 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												g223 = (( (Float)(this406) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float b227;
HXDLIN( 275)											int this407 = (col23 & 255);
HXDLIN( 275)											if ((this407 == 0)) {
HXLINE( 275)												b227 = ((Float)0.);
            											}
            											else {
HXLINE( 275)												b227 = (( (Float)(this407) ) / ( (Float)(255) ));
            											}
HXDLIN( 275)											Float a323 = (a126 * (( (Float)(1) ) - a224));
HXDLIN( 275)											int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a224))));
HXDLIN( 275)											int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a224))));
HXDLIN( 275)											int b71 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b127 * a323) + (b227 * a224))));
HXDLIN( 275)											int a61 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a224)));
HXDLIN( 275)											int blended23 = ((((a61 << 24) | (r43 << 16)) | (g43 << 8)) | b71);
HXDLIN( 275)											{
HXLINE( 275)												int _hx_tmp106;
HXDLIN( 275)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)													_hx_tmp106 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            												}
            												else {
HXLINE( 275)													_hx_tmp106 = blended23;
            												}
HXDLIN( 275)												::iterMagic::Iimg_obj::set(pixelImage->image,location23,_hx_tmp106);
            											}
            										}
            										else {
HXLINE( 275)											::Dynamic this408 = pixelImage->image;
HXDLIN( 275)											int index71;
HXDLIN( 275)											if (pixelImage->useVirtualPos) {
HXLINE( 275)												index71 = ::Std_obj::_hx_int(((((( (Float)(py11) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px11) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 275)												index71 = ::Std_obj::_hx_int(( (Float)(((py11 * pixelImage->width) + px11)) ));
            											}
HXDLIN( 275)											int _hx_tmp107;
HXDLIN( 275)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 275)												_hx_tmp107 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            											}
            											else {
HXLINE( 275)												_hx_tmp107 = c59;
            											}
HXDLIN( 275)											::iterMagic::Iimg_obj::set(this408,index71,_hx_tmp107);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 275)				if ((hasHit == false)) {
HXLINE( 275)					 ::pi_xy::algo::HitTri v52 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx2,by3,cx2,cy3,rightX,bottomY,true);
HXDLIN( 275)					if (hasUndo11) {
HXLINE( 275)						v52->undoImage = undoImage33;
HXDLIN( 275)						v52->undoX = xIter311->start;
HXDLIN( 275)						v52->undoY = yIter311->start;
            					}
            				}
            			}
HXDLIN( 275)			if ((hasHit == true)) {
HXLINE( 275)				 ::pi_xy::algo::HitQuad v53 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,rightX,ay3,bx2,by3,cx2,cy3,rightX,bottomY,true);
            			}
            		}
HXLINE( 281)		av = ((top + tall) * sh);
HXLINE( 282)		bu = (left * sw);
HXLINE( 283)		cv = ((Float)1.);
HXLINE( 284)		{
HXLINE( 284)			Float cy4 = (y + hiNew);
HXDLIN( 284)			Float dy13 = (y + hiNew);
HXDLIN( 284)			{
HXLINE( 284)				Float au13 = ((Float)0.);
HXDLIN( 284)				Float av13 = av;
HXDLIN( 284)				Float bu13 = bu;
HXDLIN( 284)				Float bv12 = av;
HXDLIN( 284)				bool hasUndo12 = false;
HXDLIN( 284)				Float temp12 = au13;
HXLINE( 422)				au13 = bu13;
HXLINE( 423)				bu13 = temp12;
HXLINE( 424)				temp12 = av13;
HXLINE( 425)				av13 = bv12;
HXLINE( 426)				bv12 = temp12;
HXLINE( 284)				Float bcx12 = (leftX - x);
HXDLIN( 284)				Float bcy12 = (bottomY - dy13);
HXDLIN( 284)				Float acx12 = (x - x);
HXDLIN( 284)				Float acy12 = (bottomY - dy13);
HXDLIN( 284)				Float dot1112 = ((bcx12 * bcx12) + (bcy12 * bcy12));
HXDLIN( 284)				Float dot1212 = ((bcx12 * acx12) + (bcy12 * acy12));
HXDLIN( 284)				Float dot2212 = ((acx12 * acx12) + (acy12 * acy12));
HXDLIN( 284)				Float denom112 = (( (Float)(1) ) / ((dot1112 * dot2212) - (dot1212 * dot1212)));
HXDLIN( 284)				 ::pi_xy::iter::IntIterStart xIter312;
HXDLIN( 284)				if ((x > leftX)) {
HXLINE( 284)					if ((x > x)) {
HXLINE( 284)						int min48;
HXDLIN( 284)						if ((leftX > x)) {
HXLINE( 284)							min48 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 284)							min48 = ::Math_obj::floor(leftX);
            						}
HXDLIN( 284)						int ii_min96 = min48;
HXDLIN( 284)						int ii_max96 = ::Math_obj::ceil(x);
HXDLIN( 284)						xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min96,ii_max96);
            					}
            					else {
HXLINE( 284)						int ii_min97 = ::Math_obj::floor(leftX);
HXDLIN( 284)						int ii_max97 = ::Math_obj::ceil(x);
HXDLIN( 284)						xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min97,ii_max97);
            					}
            				}
            				else {
HXLINE( 284)					if ((leftX > x)) {
HXLINE( 284)						int min49;
HXDLIN( 284)						if ((x > x)) {
HXLINE( 284)							min49 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 284)							min49 = ::Math_obj::ceil(x);
            						}
HXDLIN( 284)						int ii_min98 = min49;
HXDLIN( 284)						int ii_max98 = ::Math_obj::ceil(leftX);
HXDLIN( 284)						xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min98,ii_max98);
            					}
            					else {
HXLINE( 284)						int ii_min99 = ::Math_obj::floor(x);
HXDLIN( 284)						int ii_max99 = ::Math_obj::ceil(x);
HXDLIN( 284)						xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min99,ii_max99);
            					}
            				}
HXDLIN( 284)				 ::pi_xy::iter::IntIterStart yIter312;
HXDLIN( 284)				if ((bottomY > bottomY)) {
HXLINE( 284)					if ((bottomY > dy13)) {
HXLINE( 284)						int min50;
HXDLIN( 284)						if ((bottomY > dy13)) {
HXLINE( 284)							min50 = ::Math_obj::floor(dy13);
            						}
            						else {
HXLINE( 284)							min50 = ::Math_obj::floor(bottomY);
            						}
HXDLIN( 284)						int ii_min100 = min50;
HXDLIN( 284)						int ii_max100 = ::Math_obj::ceil(bottomY);
HXDLIN( 284)						yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min100,ii_max100);
            					}
            					else {
HXLINE( 284)						int ii_min101 = ::Math_obj::floor(bottomY);
HXDLIN( 284)						int ii_max101 = ::Math_obj::ceil(dy13);
HXDLIN( 284)						yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min101,ii_max101);
            					}
            				}
            				else {
HXLINE( 284)					if ((bottomY > dy13)) {
HXLINE( 284)						int min51;
HXDLIN( 284)						if ((bottomY > dy13)) {
HXLINE( 284)							min51 = ::Math_obj::floor(dy13);
            						}
            						else {
HXLINE( 284)							min51 = ::Math_obj::ceil(bottomY);
            						}
HXDLIN( 284)						int ii_min102 = min51;
HXDLIN( 284)						int ii_max102 = ::Math_obj::ceil(bottomY);
HXDLIN( 284)						yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min102,ii_max102);
            					}
            					else {
HXLINE( 284)						int ii_min103 = ::Math_obj::floor(bottomY);
HXDLIN( 284)						int ii_max103 = ::Math_obj::ceil(dy13);
HXDLIN( 284)						yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min103,ii_max103);
            					}
            				}
HXDLIN( 284)				 ::pi_xy::ImageStruct undoImage36 = null();
HXDLIN( 284)				if (hasUndo12) {
HXLINE( 284)					int width12 = ((xIter312->max - xIter312->start) + 1);
HXDLIN( 284)					int height12 = ((yIter312->max - yIter312->start) + 1);
HXDLIN( 284)					 ::Dynamic imageType12 = null();
HXDLIN( 284)					 ::pi_xy::ImageStruct this409 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 284)					if (::hx::IsNull( imageType12 )) {
HXLINE(  54)						imageType12 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 284)					::Dynamic undoImage37;
HXDLIN( 284)					switch((int)(( (int)(imageType12) ))){
            						case (int)0: {
HXLINE( 284)							 ::iterMagic::BytesImg byt12 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::BytesImg b72 = byt12;
HXDLIN( 284)							{
HXLINE( 284)								b72->width = width12;
HXDLIN( 284)								b72->height = height12;
HXDLIN( 284)								b72->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 284)								b72->data = ::haxe::io::Bytes_obj::alloc((b72->length * 4));
HXDLIN( 284)								{
HXLINE( 284)									int len24 = b72->length;
HXDLIN( 284)									int w12 = 0;
HXDLIN( 284)									{
HXLINE( 284)										int _g240 = 0;
HXDLIN( 284)										int _g241 = b72->height;
HXDLIN( 284)										while((_g240 < _g241)){
HXLINE( 284)											_g240 = (_g240 + 1);
HXDLIN( 284)											int y49 = (_g240 - 1);
HXDLIN( 284)											{
HXLINE( 284)												int _g242 = 0;
HXDLIN( 284)												int _g243 = b72->width;
HXDLIN( 284)												while((_g242 < _g243)){
HXLINE( 284)													_g242 = (_g242 + 1);
HXDLIN( 284)													int x49 = (_g242 - 1);
HXDLIN( 284)													{
HXLINE( 284)														w12 = (w12 + 1);
HXDLIN( 284)														b72->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 284)													{
HXLINE( 284)														w12 = (w12 + 1);
HXDLIN( 284)														b72->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 284)													{
HXLINE( 284)														w12 = (w12 + 1);
HXDLIN( 284)														b72->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 284)													{
HXLINE( 284)														w12 = (w12 + 1);
HXDLIN( 284)														b72->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 284)							undoImage37 = b72;
            						}
            						break;
            						case (int)1: {
HXLINE( 284)							 ::iterMagic::ArrIntImg arrI12 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::ArrIntImg a62 = arrI12;
HXDLIN( 284)							{
HXLINE( 284)								a62->width = width12;
HXDLIN( 284)								a62->height = height12;
HXDLIN( 284)								a62->data = ::Array_obj< int >::__new(0);
HXDLIN( 284)								a62->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 284)								{
HXLINE( 284)									int _g244 = 0;
HXDLIN( 284)									int _g245 = a62->length;
HXDLIN( 284)									while((_g244 < _g245)){
HXLINE( 284)										_g244 = (_g244 + 1);
HXDLIN( 284)										int i72 = (_g244 - 1);
HXDLIN( 284)										a62->data[i72] = 0;
            									}
            								}
            							}
HXDLIN( 284)							undoImage37 = a62;
            						}
            						break;
            						case (int)2: {
HXLINE( 284)							 ::iterMagic::U32ArrImg u32a12 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::U32ArrImg b73 = u32a12;
HXDLIN( 284)							{
HXLINE( 284)								b73->width = width12;
HXDLIN( 284)								b73->height = height12;
HXDLIN( 284)								b73->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 284)								int size12 = (b73->length * 4);
HXDLIN( 284)								b73->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size12),0,size12);
HXDLIN( 284)								{
HXLINE( 284)									int _g246 = 0;
HXDLIN( 284)									int _g247 = b73->length;
HXDLIN( 284)									while((_g246 < _g247)){
HXLINE( 284)										_g246 = (_g246 + 1);
HXDLIN( 284)										int i73 = (_g246 - 1);
HXDLIN( 284)										{
HXLINE( 284)											 ::haxe::io::ArrayBufferViewImpl this410 = b73->data;
HXDLIN( 284)											bool undoImage38;
HXDLIN( 284)											if ((i73 >= 0)) {
HXLINE( 284)												undoImage38 = (i73 < (this410->byteLength >> 2));
            											}
            											else {
HXLINE( 284)												undoImage38 = false;
            											}
HXDLIN( 284)											if (undoImage38) {
HXLINE( 284)												 ::haxe::io::Bytes _this12 = this410->bytes;
HXDLIN( 284)												int pos12 = ((i73 << 2) + this410->byteOffset);
HXDLIN( 284)												_this12->b[pos12] = ( (unsigned char)(0) );
HXDLIN( 284)												_this12->b[(pos12 + 1)] = ( (unsigned char)(0) );
HXDLIN( 284)												_this12->b[(pos12 + 2)] = ( (unsigned char)(0) );
HXDLIN( 284)												_this12->b[(pos12 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 284)							undoImage37 = b73;
            						}
            						break;
            						case (int)3: {
HXLINE( 284)							 ::iterMagic::VecIntImg vec12 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::VecIntImg v54 = vec12;
HXDLIN( 284)							{
HXLINE( 284)								v54->width = width12;
HXDLIN( 284)								v54->height = height12;
HXDLIN( 284)								v54->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 284)								v54->data = ::Array_obj< int >::__new(v54->length);
HXDLIN( 284)								{
HXLINE( 284)									int _g248 = 0;
HXDLIN( 284)									int _g249 = v54->length;
HXDLIN( 284)									while((_g248 < _g249)){
HXLINE( 284)										_g248 = (_g248 + 1);
HXDLIN( 284)										int i74 = (_g248 - 1);
HXDLIN( 284)										v54->data->__unsafe_set(i74,0);
            									}
            								}
            							}
HXDLIN( 284)							undoImage37 = v54;
            						}
            						break;
            						case (int)4: {
HXLINE( 284)							 ::iterMagic::StackIntImg sInt12 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::StackIntImg b74 = sInt12;
HXDLIN( 284)							{
HXLINE( 284)								b74->width = width12;
HXDLIN( 284)								b74->height = height12;
HXDLIN( 284)								b74->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN( 284)								b74->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 284)								{
HXLINE( 284)									int len25 = b74->length;
HXDLIN( 284)									 ::haxe::ds::GenericStack_Int d12 = b74->data;
HXDLIN( 284)									if (::hx::IsNull( d12->head )) {
HXLINE( 284)										int _g250 = 0;
HXDLIN( 284)										int _g251 = len25;
HXDLIN( 284)										while((_g250 < _g251)){
HXLINE( 284)											_g250 = (_g250 + 1);
HXDLIN( 284)											int i75 = (_g250 - 1);
HXDLIN( 284)											d12->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d12->head);
            										}
            									}
            									else {
HXLINE( 284)										int _g252 = 0;
HXDLIN( 284)										int _g253 = len25;
HXDLIN( 284)										while((_g252 < _g253)){
HXLINE( 284)											_g252 = (_g252 + 1);
HXDLIN( 284)											int i76 = (_g252 - 1);
HXDLIN( 284)											{
HXLINE( 284)												 ::haxe::ds::GenericCell_Int l12 = b74->data->head;
HXDLIN( 284)												 ::haxe::ds::GenericCell_Int prev12 = null();
HXDLIN( 284)												{
HXLINE( 284)													int _g254 = 0;
HXDLIN( 284)													int _g255 = i76;
HXDLIN( 284)													while((_g254 < _g255)){
HXLINE( 284)														_g254 = (_g254 + 1);
HXDLIN( 284)														int i77 = (_g254 - 1);
HXLINE( 345)														prev12 = l12;
HXLINE( 346)														l12 = l12->next;
            													}
            												}
HXLINE( 284)												if (::hx::IsNull( prev12 )) {
HXLINE( 284)													b74->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l12->next);
HXDLIN( 284)													l12 = null();
            												}
            												else {
HXLINE( 284)													prev12->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l12->next);
HXDLIN( 284)													l12 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 284)							undoImage37 = b74;
            						}
            						break;
            					}
HXDLIN( 284)					this409->image = undoImage37;
HXDLIN( 284)					this409->width = width12;
HXDLIN( 284)					this409->height = height12;
HXDLIN( 284)					this409->imageType = ( (int)(imageType12) );
HXDLIN( 284)					undoImage36 = this409;
HXDLIN( 284)					{
HXLINE( 284)						int rectLeft12 = xIter312->start;
HXDLIN( 284)						int rectTop12 = yIter312->start;
HXDLIN( 284)						int rectRight12 = xIter312->max;
HXDLIN( 284)						bool forceClear12 = false;
HXDLIN( 284)						{
HXLINE( 284)							int _g256 = rectTop12;
HXDLIN( 284)							int _g257 = yIter312->max;
HXDLIN( 284)							while((_g256 < _g257)){
HXLINE( 284)								_g256 = (_g256 + 1);
HXDLIN( 284)								int dy14 = (_g256 - 1);
HXDLIN( 284)								{
HXLINE( 284)									int _g258 = rectLeft12;
HXDLIN( 284)									int _g259 = rectRight12;
HXDLIN( 284)									while((_g258 < _g259)){
HXLINE( 284)										_g258 = (_g258 + 1);
HXDLIN( 284)										int dx13 = (_g258 - 1);
HXDLIN( 284)										::Dynamic this411 = pixelImage->image;
HXDLIN( 284)										int index72;
HXDLIN( 284)										if (pixelImage->useVirtualPos) {
HXLINE( 284)											index72 = ::Std_obj::_hx_int(((((( (Float)(dy14) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx13) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 284)											index72 = ::Std_obj::_hx_int(( (Float)(((dy14 * pixelImage->width) + dx13)) ));
            										}
HXDLIN( 284)										int c60 = ::iterMagic::Iimg_obj::get(this411,index72);
HXDLIN( 284)										int col24;
HXDLIN( 284)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)											col24 = ((((((c60 >> 24) & 255) << 24) | ((c60 & 255) << 16)) | (((c60 >> 8) & 255) << 8)) | ((c60 >> 16) & 255));
            										}
            										else {
HXLINE( 284)											col24 = c60;
            										}
HXDLIN( 284)										bool _hx_tmp108;
HXDLIN( 284)										if (pixelImage->useMask) {
HXLINE( 284)											_hx_tmp108 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 284)											_hx_tmp108 = false;
            										}
HXDLIN( 284)										if (_hx_tmp108) {
HXLINE( 284)											 ::pi_xy::ImageStruct this412 = pixelImage->mask;
HXDLIN( 284)											::Dynamic this413 = this412->image;
HXDLIN( 284)											int index73;
HXDLIN( 284)											if (this412->useVirtualPos) {
HXLINE( 284)												index73 = ::Std_obj::_hx_int(((((( (Float)(dy14) ) - this412->virtualY) * ( (Float)(this412->width) )) + dx13) - this412->virtualX));
            											}
            											else {
HXLINE( 284)												index73 = ::Std_obj::_hx_int(( (Float)(((dy14 * this412->width) + dx13)) ));
            											}
HXDLIN( 284)											int c61 = ::iterMagic::Iimg_obj::get(this413,index73);
HXDLIN( 284)											int v55;
HXDLIN( 284)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)												v55 = ((((((c61 >> 24) & 255) << 24) | ((c61 & 255) << 16)) | (((c61 >> 8) & 255) << 8)) | ((c61 >> 16) & 255));
            											}
            											else {
HXLINE( 284)												v55 = c61;
            											}
HXDLIN( 284)											int maskPixel12 = v55;
HXDLIN( 284)											int this414 = col24;
HXDLIN( 284)											if ((maskPixel12 == 0)) {
HXLINE( 284)												col24 = this414;
            											}
            											else {
HXLINE( 284)												Float m012;
HXDLIN( 284)												int this415 = ((maskPixel12 >> 24) & 255);
HXDLIN( 284)												if ((this415 == 0)) {
HXLINE( 284)													m012 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													m012 = (( (Float)(this415) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float m112;
HXDLIN( 284)												int this416 = ((maskPixel12 >> 16) & 255);
HXDLIN( 284)												if ((this416 == 0)) {
HXLINE( 284)													m112 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													m112 = (( (Float)(this416) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float m212;
HXDLIN( 284)												int this417 = ((maskPixel12 >> 8) & 255);
HXDLIN( 284)												if ((this417 == 0)) {
HXLINE( 284)													m212 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													m212 = (( (Float)(this417) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float m312;
HXDLIN( 284)												int this418 = (maskPixel12 & 255);
HXDLIN( 284)												if ((this418 == 0)) {
HXLINE( 284)													m312 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													m312 = (( (Float)(this418) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												int ch012 = ::Std_obj::_hx_int(((((Float)1.) - m012) * ( (Float)(((this414 >> 24) & 255)) )));
HXDLIN( 284)												int ch112 = ::Std_obj::_hx_int(((((Float)1.) - m112) * ( (Float)(((this414 >> 16) & 255)) )));
HXDLIN( 284)												int ch212 = ::Std_obj::_hx_int(((((Float)1.) - m212) * ( (Float)(((this414 >> 8) & 255)) )));
HXDLIN( 284)												int ch312 = ::Std_obj::_hx_int(((((Float)1.) - m312) * ( (Float)((this414 & 255)) )));
HXDLIN( 284)												col24 = ((((::Math_obj::round((( (Float)(ch012) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch112) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch212) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch312) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 284)										if ((col24 != 0)) {
HXLINE( 284)											int x50 = (dx13 - rectLeft12);
HXDLIN( 284)											int y50 = (dy14 - rectTop12);
HXDLIN( 284)											int c62 = col24;
HXDLIN( 284)											bool _hx_tmp109;
HXDLIN( 284)											if ((((c62 >> 24) & 255) < 254)) {
HXLINE( 284)												_hx_tmp109 = undoImage36->transparent;
            											}
            											else {
HXLINE( 284)												_hx_tmp109 = false;
            											}
HXDLIN( 284)											if (_hx_tmp109) {
HXLINE( 284)												int location24;
HXDLIN( 284)												if (undoImage36->useVirtualPos) {
HXLINE( 284)													location24 = ::Std_obj::_hx_int(((((( (Float)(y50) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x50) - undoImage36->virtualX));
            												}
            												else {
HXLINE( 284)													location24 = ::Std_obj::_hx_int(( (Float)(((y50 * undoImage36->width) + x50)) ));
            												}
HXDLIN( 284)												int this419 = ::iterMagic::Iimg_obj::get(undoImage36->image,location24);
HXDLIN( 284)												int this420;
HXDLIN( 284)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)													this420 = ((((((this419 >> 24) & 255) << 24) | ((this419 & 255) << 16)) | (((this419 >> 8) & 255) << 8)) | ((this419 >> 16) & 255));
            												}
            												else {
HXLINE( 284)													this420 = this419;
            												}
HXDLIN( 284)												Float a127;
HXDLIN( 284)												int this421 = ((this420 >> 24) & 255);
HXDLIN( 284)												if ((this421 == 0)) {
HXLINE( 284)													a127 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													a127 = (( (Float)(this421) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float r124;
HXDLIN( 284)												int this422 = ((this420 >> 16) & 255);
HXDLIN( 284)												if ((this422 == 0)) {
HXLINE( 284)													r124 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													r124 = (( (Float)(this422) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float g124;
HXDLIN( 284)												int this423 = ((this420 >> 8) & 255);
HXDLIN( 284)												if ((this423 == 0)) {
HXLINE( 284)													g124 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													g124 = (( (Float)(this423) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float b128;
HXDLIN( 284)												int this424 = (this420 & 255);
HXDLIN( 284)												if ((this424 == 0)) {
HXLINE( 284)													b128 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													b128 = (( (Float)(this424) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float a225;
HXDLIN( 284)												int this425 = ((col24 >> 24) & 255);
HXDLIN( 284)												if ((this425 == 0)) {
HXLINE( 284)													a225 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													a225 = (( (Float)(this425) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float r224;
HXDLIN( 284)												int this426 = ((col24 >> 16) & 255);
HXDLIN( 284)												if ((this426 == 0)) {
HXLINE( 284)													r224 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													r224 = (( (Float)(this426) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float g224;
HXDLIN( 284)												int this427 = ((col24 >> 8) & 255);
HXDLIN( 284)												if ((this427 == 0)) {
HXLINE( 284)													g224 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													g224 = (( (Float)(this427) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float b228;
HXDLIN( 284)												int this428 = (col24 & 255);
HXDLIN( 284)												if ((this428 == 0)) {
HXLINE( 284)													b228 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													b228 = (( (Float)(this428) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float a324 = (a127 * (( (Float)(1) ) - a225));
HXDLIN( 284)												int r44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r124 * a324) + (r224 * a225))));
HXDLIN( 284)												int g44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g124 * a324) + (g224 * a225))));
HXDLIN( 284)												int b75 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b128 * a324) + (b228 * a225))));
HXDLIN( 284)												int a63 = ::Std_obj::_hx_int((( (Float)(255) ) * (a324 + a225)));
HXDLIN( 284)												int blended24 = ((((a63 << 24) | (r44 << 16)) | (g44 << 8)) | b75);
HXDLIN( 284)												{
HXLINE( 284)													int _hx_tmp110;
HXDLIN( 284)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)														_hx_tmp110 = ((((((blended24 >> 24) & 255) << 24) | ((blended24 & 255) << 16)) | (((blended24 >> 8) & 255) << 8)) | ((blended24 >> 16) & 255));
            													}
            													else {
HXLINE( 284)														_hx_tmp110 = blended24;
            													}
HXDLIN( 284)													::iterMagic::Iimg_obj::set(undoImage36->image,location24,_hx_tmp110);
            												}
            											}
            											else {
HXLINE( 284)												::Dynamic this429 = undoImage36->image;
HXDLIN( 284)												int index74;
HXDLIN( 284)												if (undoImage36->useVirtualPos) {
HXLINE( 284)													index74 = ::Std_obj::_hx_int(((((( (Float)(y50) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x50) - undoImage36->virtualX));
            												}
            												else {
HXLINE( 284)													index74 = ::Std_obj::_hx_int(( (Float)(((y50 * undoImage36->width) + x50)) ));
            												}
HXDLIN( 284)												int _hx_tmp111;
HXDLIN( 284)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)													_hx_tmp111 = ((((((c62 >> 24) & 255) << 24) | ((c62 & 255) << 16)) | (((c62 >> 8) & 255) << 8)) | ((c62 >> 16) & 255));
            												}
            												else {
HXLINE( 284)													_hx_tmp111 = c62;
            												}
HXDLIN( 284)												::iterMagic::Iimg_obj::set(this429,index74,_hx_tmp111);
            											}
            										}
            										else {
HXLINE( 284)											if (forceClear12) {
HXLINE( 284)												::Dynamic this430 = undoImage36->image;
HXDLIN( 284)												int x51 = (dx13 - rectLeft12);
HXDLIN( 284)												int y51 = (dy14 - rectTop12);
HXDLIN( 284)												int index75;
HXDLIN( 284)												if (undoImage36->useVirtualPos) {
HXLINE( 284)													index75 = ::Std_obj::_hx_int(((((( (Float)(y51) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x51) - undoImage36->virtualX));
            												}
            												else {
HXLINE( 284)													index75 = ::Std_obj::_hx_int(( (Float)(((y51 * undoImage36->width) + x51)) ));
            												}
HXDLIN( 284)												::iterMagic::Iimg_obj::set(this430,index75,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 284)				{
HXLINE( 284)					int _g_min24 = xIter312->start;
HXDLIN( 284)					int _g_max24 = xIter312->max;
HXDLIN( 284)					while((_g_min24 < _g_max24)){
HXLINE( 284)						_g_min24 = (_g_min24 + 1);
HXDLIN( 284)						int px12 = (_g_min24 - 1);
HXDLIN( 284)						Float pcx12 = (( (Float)(px12) ) - x);
HXDLIN( 284)						{
HXLINE( 284)							int _g_min25 = yIter312->start;
HXDLIN( 284)							int _g_max25 = yIter312->max;
HXDLIN( 284)							while((_g_min25 < _g_max25)){
HXLINE( 284)								_g_min25 = (_g_min25 + 1);
HXDLIN( 284)								int py12 = (_g_min25 - 1);
HXDLIN( 284)								Float pcy12 = (( (Float)(py12) ) - dy13);
HXDLIN( 284)								Float dot3112 = ((pcx12 * bcx12) + (pcy12 * bcy12));
HXDLIN( 284)								Float dot3212 = ((pcx12 * acx12) + (pcy12 * acy12));
HXDLIN( 284)								Float ratioA12 = (((dot2212 * dot3112) - (dot1212 * dot3212)) * denom112);
HXDLIN( 284)								Float ratioB12 = (((dot1112 * dot3212) - (dot1212 * dot3112)) * denom112);
HXDLIN( 284)								Float ratioC12 = ((((Float)1.0) - ratioB12) - ratioA12);
HXDLIN( 284)								bool _hx_tmp112;
HXDLIN( 284)								bool _hx_tmp113;
HXDLIN( 284)								if ((ratioA12 >= 0)) {
HXLINE( 284)									_hx_tmp113 = (ratioB12 >= 0);
            								}
            								else {
HXLINE( 284)									_hx_tmp113 = false;
            								}
HXDLIN( 284)								if (_hx_tmp113) {
HXLINE( 284)									_hx_tmp112 = (ratioC12 >= 0);
            								}
            								else {
HXLINE( 284)									_hx_tmp112 = false;
            								}
HXDLIN( 284)								if (_hx_tmp112) {
HXLINE( 284)									Float u12 = (((au13 * ratioA12) + (bu13 * ratioB12)) + (((Float)0.) * ratioC12));
HXDLIN( 284)									Float v56 = (((av13 * ratioA12) + (bv12 * ratioB12)) + (cv * ratioC12));
HXDLIN( 284)									int x52 = ::Std_obj::_hx_int(((u12 * win->width) + win->x));
HXDLIN( 284)									int y52 = ::Std_obj::_hx_int(((v56 * win->height) + win->y));
HXDLIN( 284)									::Dynamic this431 = texture->image;
HXDLIN( 284)									int index76;
HXDLIN( 284)									if (texture->useVirtualPos) {
HXLINE( 284)										index76 = ::Std_obj::_hx_int(((((( (Float)(y52) ) - texture->virtualY) * ( (Float)(texture->width) )) + x52) - texture->virtualX));
            									}
            									else {
HXLINE( 284)										index76 = ::Std_obj::_hx_int(( (Float)(((y52 * texture->width) + x52)) ));
            									}
HXDLIN( 284)									int c63 = ::iterMagic::Iimg_obj::get(this431,index76);
HXDLIN( 284)									int col25;
HXDLIN( 284)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)										col25 = ((((((c63 >> 24) & 255) << 24) | ((c63 & 255) << 16)) | (((c63 >> 8) & 255) << 8)) | ((c63 >> 16) & 255));
            									}
            									else {
HXLINE( 284)										col25 = c63;
            									}
HXDLIN( 284)									{
HXLINE( 284)										int c64 = col25;
HXDLIN( 284)										bool _hx_tmp114;
HXDLIN( 284)										if ((((c64 >> 24) & 255) < 254)) {
HXLINE( 284)											_hx_tmp114 = pixelImage->transparent;
            										}
            										else {
HXLINE( 284)											_hx_tmp114 = false;
            										}
HXDLIN( 284)										if (_hx_tmp114) {
HXLINE( 284)											int location25;
HXDLIN( 284)											if (pixelImage->useVirtualPos) {
HXLINE( 284)												location25 = ::Std_obj::_hx_int(((((( (Float)(py12) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px12) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 284)												location25 = ::Std_obj::_hx_int(( (Float)(((py12 * pixelImage->width) + px12)) ));
            											}
HXDLIN( 284)											int this432 = ::iterMagic::Iimg_obj::get(pixelImage->image,location25);
HXDLIN( 284)											int this433;
HXDLIN( 284)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)												this433 = ((((((this432 >> 24) & 255) << 24) | ((this432 & 255) << 16)) | (((this432 >> 8) & 255) << 8)) | ((this432 >> 16) & 255));
            											}
            											else {
HXLINE( 284)												this433 = this432;
            											}
HXDLIN( 284)											Float a128;
HXDLIN( 284)											int this434 = ((this433 >> 24) & 255);
HXDLIN( 284)											if ((this434 == 0)) {
HXLINE( 284)												a128 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												a128 = (( (Float)(this434) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float r125;
HXDLIN( 284)											int this435 = ((this433 >> 16) & 255);
HXDLIN( 284)											if ((this435 == 0)) {
HXLINE( 284)												r125 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												r125 = (( (Float)(this435) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float g125;
HXDLIN( 284)											int this436 = ((this433 >> 8) & 255);
HXDLIN( 284)											if ((this436 == 0)) {
HXLINE( 284)												g125 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												g125 = (( (Float)(this436) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float b129;
HXDLIN( 284)											int this437 = (this433 & 255);
HXDLIN( 284)											if ((this437 == 0)) {
HXLINE( 284)												b129 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												b129 = (( (Float)(this437) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float a226;
HXDLIN( 284)											int this438 = ((col25 >> 24) & 255);
HXDLIN( 284)											if ((this438 == 0)) {
HXLINE( 284)												a226 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												a226 = (( (Float)(this438) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float r225;
HXDLIN( 284)											int this439 = ((col25 >> 16) & 255);
HXDLIN( 284)											if ((this439 == 0)) {
HXLINE( 284)												r225 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												r225 = (( (Float)(this439) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float g225;
HXDLIN( 284)											int this440 = ((col25 >> 8) & 255);
HXDLIN( 284)											if ((this440 == 0)) {
HXLINE( 284)												g225 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												g225 = (( (Float)(this440) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float b229;
HXDLIN( 284)											int this441 = (col25 & 255);
HXDLIN( 284)											if ((this441 == 0)) {
HXLINE( 284)												b229 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												b229 = (( (Float)(this441) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float a325 = (a128 * (( (Float)(1) ) - a226));
HXDLIN( 284)											int r45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r125 * a325) + (r225 * a226))));
HXDLIN( 284)											int g45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g125 * a325) + (g225 * a226))));
HXDLIN( 284)											int b76 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b129 * a325) + (b229 * a226))));
HXDLIN( 284)											int a64 = ::Std_obj::_hx_int((( (Float)(255) ) * (a325 + a226)));
HXDLIN( 284)											int blended25 = ((((a64 << 24) | (r45 << 16)) | (g45 << 8)) | b76);
HXDLIN( 284)											{
HXLINE( 284)												int _hx_tmp115;
HXDLIN( 284)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)													_hx_tmp115 = ((((((blended25 >> 24) & 255) << 24) | ((blended25 & 255) << 16)) | (((blended25 >> 8) & 255) << 8)) | ((blended25 >> 16) & 255));
            												}
            												else {
HXLINE( 284)													_hx_tmp115 = blended25;
            												}
HXDLIN( 284)												::iterMagic::Iimg_obj::set(pixelImage->image,location25,_hx_tmp115);
            											}
            										}
            										else {
HXLINE( 284)											::Dynamic this442 = pixelImage->image;
HXDLIN( 284)											int index77;
HXDLIN( 284)											if (pixelImage->useVirtualPos) {
HXLINE( 284)												index77 = ::Std_obj::_hx_int(((((( (Float)(py12) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px12) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 284)												index77 = ::Std_obj::_hx_int(( (Float)(((py12 * pixelImage->width) + px12)) ));
            											}
HXDLIN( 284)											int _hx_tmp116;
HXDLIN( 284)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)												_hx_tmp116 = ((((((c64 >> 24) & 255) << 24) | ((c64 & 255) << 16)) | (((c64 >> 8) & 255) << 8)) | ((c64 >> 16) & 255));
            											}
            											else {
HXLINE( 284)												_hx_tmp116 = c64;
            											}
HXDLIN( 284)											::iterMagic::Iimg_obj::set(this442,index77,_hx_tmp116);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 284)				if ((hasHit == false)) {
HXLINE( 284)					 ::pi_xy::algo::HitTri v57 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x,bottomY,leftX,bottomY,x,dy13,true);
HXDLIN( 284)					if (hasUndo12) {
HXLINE( 284)						v57->undoImage = undoImage36;
HXDLIN( 284)						v57->undoX = xIter312->start;
HXDLIN( 284)						v57->undoY = yIter312->start;
            					}
            				}
            			}
HXDLIN( 284)			{
HXLINE( 284)				Float au14 = bu;
HXDLIN( 284)				Float av14 = av;
HXDLIN( 284)				Float bu14 = bu;
HXDLIN( 284)				Float bv13 = cv;
HXDLIN( 284)				bool hasUndo13 = false;
HXDLIN( 284)				Float temp13 = au14;
HXLINE( 422)				au14 = bu14;
HXLINE( 423)				bu14 = temp13;
HXLINE( 424)				temp13 = av14;
HXLINE( 425)				av14 = bv13;
HXLINE( 426)				bv13 = temp13;
HXLINE( 284)				Float bcx13 = (leftX - x);
HXDLIN( 284)				Float bcy13 = (cy4 - dy13);
HXDLIN( 284)				Float acx13 = (leftX - x);
HXDLIN( 284)				Float acy13 = (bottomY - dy13);
HXDLIN( 284)				Float dot1113 = ((bcx13 * bcx13) + (bcy13 * bcy13));
HXDLIN( 284)				Float dot1213 = ((bcx13 * acx13) + (bcy13 * acy13));
HXDLIN( 284)				Float dot2213 = ((acx13 * acx13) + (acy13 * acy13));
HXDLIN( 284)				Float denom113 = (( (Float)(1) ) / ((dot1113 * dot2213) - (dot1213 * dot1213)));
HXDLIN( 284)				 ::pi_xy::iter::IntIterStart xIter313;
HXDLIN( 284)				if ((leftX > leftX)) {
HXLINE( 284)					if ((leftX > x)) {
HXLINE( 284)						int min52;
HXDLIN( 284)						if ((leftX > x)) {
HXLINE( 284)							min52 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 284)							min52 = ::Math_obj::floor(leftX);
            						}
HXDLIN( 284)						int ii_min104 = min52;
HXDLIN( 284)						int ii_max104 = ::Math_obj::ceil(leftX);
HXDLIN( 284)						xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min104,ii_max104);
            					}
            					else {
HXLINE( 284)						int ii_min105 = ::Math_obj::floor(leftX);
HXDLIN( 284)						int ii_max105 = ::Math_obj::ceil(x);
HXDLIN( 284)						xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min105,ii_max105);
            					}
            				}
            				else {
HXLINE( 284)					if ((leftX > x)) {
HXLINE( 284)						int min53;
HXDLIN( 284)						if ((leftX > x)) {
HXLINE( 284)							min53 = ::Math_obj::floor(x);
            						}
            						else {
HXLINE( 284)							min53 = ::Math_obj::ceil(leftX);
            						}
HXDLIN( 284)						int ii_min106 = min53;
HXDLIN( 284)						int ii_max106 = ::Math_obj::ceil(leftX);
HXDLIN( 284)						xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min106,ii_max106);
            					}
            					else {
HXLINE( 284)						int ii_min107 = ::Math_obj::floor(leftX);
HXDLIN( 284)						int ii_max107 = ::Math_obj::ceil(x);
HXDLIN( 284)						xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min107,ii_max107);
            					}
            				}
HXDLIN( 284)				 ::pi_xy::iter::IntIterStart yIter313;
HXDLIN( 284)				if ((bottomY > cy4)) {
HXLINE( 284)					if ((bottomY > dy13)) {
HXLINE( 284)						int min54;
HXDLIN( 284)						if ((cy4 > dy13)) {
HXLINE( 284)							min54 = ::Math_obj::floor(dy13);
            						}
            						else {
HXLINE( 284)							min54 = ::Math_obj::floor(cy4);
            						}
HXDLIN( 284)						int ii_min108 = min54;
HXDLIN( 284)						int ii_max108 = ::Math_obj::ceil(bottomY);
HXDLIN( 284)						yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min108,ii_max108);
            					}
            					else {
HXLINE( 284)						int ii_min109 = ::Math_obj::floor(cy4);
HXDLIN( 284)						int ii_max109 = ::Math_obj::ceil(dy13);
HXDLIN( 284)						yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min109,ii_max109);
            					}
            				}
            				else {
HXLINE( 284)					if ((cy4 > dy13)) {
HXLINE( 284)						int min55;
HXDLIN( 284)						if ((bottomY > dy13)) {
HXLINE( 284)							min55 = ::Math_obj::floor(dy13);
            						}
            						else {
HXLINE( 284)							min55 = ::Math_obj::ceil(bottomY);
            						}
HXDLIN( 284)						int ii_min110 = min55;
HXDLIN( 284)						int ii_max110 = ::Math_obj::ceil(cy4);
HXDLIN( 284)						yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min110,ii_max110);
            					}
            					else {
HXLINE( 284)						int ii_min111 = ::Math_obj::floor(bottomY);
HXDLIN( 284)						int ii_max111 = ::Math_obj::ceil(dy13);
HXDLIN( 284)						yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min111,ii_max111);
            					}
            				}
HXDLIN( 284)				 ::pi_xy::ImageStruct undoImage39 = null();
HXDLIN( 284)				if (hasUndo13) {
HXLINE( 284)					int width13 = ((xIter313->max - xIter313->start) + 1);
HXDLIN( 284)					int height13 = ((yIter313->max - yIter313->start) + 1);
HXDLIN( 284)					 ::Dynamic imageType13 = null();
HXDLIN( 284)					 ::pi_xy::ImageStruct this443 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 284)					if (::hx::IsNull( imageType13 )) {
HXLINE(  54)						imageType13 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 284)					::Dynamic undoImage40;
HXDLIN( 284)					switch((int)(( (int)(imageType13) ))){
            						case (int)0: {
HXLINE( 284)							 ::iterMagic::BytesImg byt13 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::BytesImg b77 = byt13;
HXDLIN( 284)							{
HXLINE( 284)								b77->width = width13;
HXDLIN( 284)								b77->height = height13;
HXDLIN( 284)								b77->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 284)								b77->data = ::haxe::io::Bytes_obj::alloc((b77->length * 4));
HXDLIN( 284)								{
HXLINE( 284)									int len26 = b77->length;
HXDLIN( 284)									int w13 = 0;
HXDLIN( 284)									{
HXLINE( 284)										int _g260 = 0;
HXDLIN( 284)										int _g261 = b77->height;
HXDLIN( 284)										while((_g260 < _g261)){
HXLINE( 284)											_g260 = (_g260 + 1);
HXDLIN( 284)											int y53 = (_g260 - 1);
HXDLIN( 284)											{
HXLINE( 284)												int _g262 = 0;
HXDLIN( 284)												int _g263 = b77->width;
HXDLIN( 284)												while((_g262 < _g263)){
HXLINE( 284)													_g262 = (_g262 + 1);
HXDLIN( 284)													int x53 = (_g262 - 1);
HXDLIN( 284)													{
HXLINE( 284)														w13 = (w13 + 1);
HXDLIN( 284)														b77->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 284)													{
HXLINE( 284)														w13 = (w13 + 1);
HXDLIN( 284)														b77->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 284)													{
HXLINE( 284)														w13 = (w13 + 1);
HXDLIN( 284)														b77->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 284)													{
HXLINE( 284)														w13 = (w13 + 1);
HXDLIN( 284)														b77->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 284)							undoImage40 = b77;
            						}
            						break;
            						case (int)1: {
HXLINE( 284)							 ::iterMagic::ArrIntImg arrI13 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::ArrIntImg a65 = arrI13;
HXDLIN( 284)							{
HXLINE( 284)								a65->width = width13;
HXDLIN( 284)								a65->height = height13;
HXDLIN( 284)								a65->data = ::Array_obj< int >::__new(0);
HXDLIN( 284)								a65->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 284)								{
HXLINE( 284)									int _g264 = 0;
HXDLIN( 284)									int _g265 = a65->length;
HXDLIN( 284)									while((_g264 < _g265)){
HXLINE( 284)										_g264 = (_g264 + 1);
HXDLIN( 284)										int i78 = (_g264 - 1);
HXDLIN( 284)										a65->data[i78] = 0;
            									}
            								}
            							}
HXDLIN( 284)							undoImage40 = a65;
            						}
            						break;
            						case (int)2: {
HXLINE( 284)							 ::iterMagic::U32ArrImg u32a13 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::U32ArrImg b78 = u32a13;
HXDLIN( 284)							{
HXLINE( 284)								b78->width = width13;
HXDLIN( 284)								b78->height = height13;
HXDLIN( 284)								b78->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 284)								int size13 = (b78->length * 4);
HXDLIN( 284)								b78->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size13),0,size13);
HXDLIN( 284)								{
HXLINE( 284)									int _g266 = 0;
HXDLIN( 284)									int _g267 = b78->length;
HXDLIN( 284)									while((_g266 < _g267)){
HXLINE( 284)										_g266 = (_g266 + 1);
HXDLIN( 284)										int i79 = (_g266 - 1);
HXDLIN( 284)										{
HXLINE( 284)											 ::haxe::io::ArrayBufferViewImpl this444 = b78->data;
HXDLIN( 284)											bool undoImage41;
HXDLIN( 284)											if ((i79 >= 0)) {
HXLINE( 284)												undoImage41 = (i79 < (this444->byteLength >> 2));
            											}
            											else {
HXLINE( 284)												undoImage41 = false;
            											}
HXDLIN( 284)											if (undoImage41) {
HXLINE( 284)												 ::haxe::io::Bytes _this13 = this444->bytes;
HXDLIN( 284)												int pos13 = ((i79 << 2) + this444->byteOffset);
HXDLIN( 284)												_this13->b[pos13] = ( (unsigned char)(0) );
HXDLIN( 284)												_this13->b[(pos13 + 1)] = ( (unsigned char)(0) );
HXDLIN( 284)												_this13->b[(pos13 + 2)] = ( (unsigned char)(0) );
HXDLIN( 284)												_this13->b[(pos13 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 284)							undoImage40 = b78;
            						}
            						break;
            						case (int)3: {
HXLINE( 284)							 ::iterMagic::VecIntImg vec13 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::VecIntImg v58 = vec13;
HXDLIN( 284)							{
HXLINE( 284)								v58->width = width13;
HXDLIN( 284)								v58->height = height13;
HXDLIN( 284)								v58->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 284)								v58->data = ::Array_obj< int >::__new(v58->length);
HXDLIN( 284)								{
HXLINE( 284)									int _g268 = 0;
HXDLIN( 284)									int _g269 = v58->length;
HXDLIN( 284)									while((_g268 < _g269)){
HXLINE( 284)										_g268 = (_g268 + 1);
HXDLIN( 284)										int i80 = (_g268 - 1);
HXDLIN( 284)										v58->data->__unsafe_set(i80,0);
            									}
            								}
            							}
HXDLIN( 284)							undoImage40 = v58;
            						}
            						break;
            						case (int)4: {
HXLINE( 284)							 ::iterMagic::StackIntImg sInt13 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 284)							 ::iterMagic::StackIntImg b79 = sInt13;
HXDLIN( 284)							{
HXLINE( 284)								b79->width = width13;
HXDLIN( 284)								b79->height = height13;
HXDLIN( 284)								b79->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN( 284)								b79->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 284)								{
HXLINE( 284)									int len27 = b79->length;
HXDLIN( 284)									 ::haxe::ds::GenericStack_Int d13 = b79->data;
HXDLIN( 284)									if (::hx::IsNull( d13->head )) {
HXLINE( 284)										int _g270 = 0;
HXDLIN( 284)										int _g271 = len27;
HXDLIN( 284)										while((_g270 < _g271)){
HXLINE( 284)											_g270 = (_g270 + 1);
HXDLIN( 284)											int i81 = (_g270 - 1);
HXDLIN( 284)											d13->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d13->head);
            										}
            									}
            									else {
HXLINE( 284)										int _g272 = 0;
HXDLIN( 284)										int _g273 = len27;
HXDLIN( 284)										while((_g272 < _g273)){
HXLINE( 284)											_g272 = (_g272 + 1);
HXDLIN( 284)											int i82 = (_g272 - 1);
HXDLIN( 284)											{
HXLINE( 284)												 ::haxe::ds::GenericCell_Int l13 = b79->data->head;
HXDLIN( 284)												 ::haxe::ds::GenericCell_Int prev13 = null();
HXDLIN( 284)												{
HXLINE( 284)													int _g274 = 0;
HXDLIN( 284)													int _g275 = i82;
HXDLIN( 284)													while((_g274 < _g275)){
HXLINE( 284)														_g274 = (_g274 + 1);
HXDLIN( 284)														int i83 = (_g274 - 1);
HXLINE( 345)														prev13 = l13;
HXLINE( 346)														l13 = l13->next;
            													}
            												}
HXLINE( 284)												if (::hx::IsNull( prev13 )) {
HXLINE( 284)													b79->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l13->next);
HXDLIN( 284)													l13 = null();
            												}
            												else {
HXLINE( 284)													prev13->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l13->next);
HXDLIN( 284)													l13 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 284)							undoImage40 = b79;
            						}
            						break;
            					}
HXDLIN( 284)					this443->image = undoImage40;
HXDLIN( 284)					this443->width = width13;
HXDLIN( 284)					this443->height = height13;
HXDLIN( 284)					this443->imageType = ( (int)(imageType13) );
HXDLIN( 284)					undoImage39 = this443;
HXDLIN( 284)					{
HXLINE( 284)						int rectLeft13 = xIter313->start;
HXDLIN( 284)						int rectTop13 = yIter313->start;
HXDLIN( 284)						int rectRight13 = xIter313->max;
HXDLIN( 284)						bool forceClear13 = false;
HXDLIN( 284)						{
HXLINE( 284)							int _g276 = rectTop13;
HXDLIN( 284)							int _g277 = yIter313->max;
HXDLIN( 284)							while((_g276 < _g277)){
HXLINE( 284)								_g276 = (_g276 + 1);
HXDLIN( 284)								int dy15 = (_g276 - 1);
HXDLIN( 284)								{
HXLINE( 284)									int _g278 = rectLeft13;
HXDLIN( 284)									int _g279 = rectRight13;
HXDLIN( 284)									while((_g278 < _g279)){
HXLINE( 284)										_g278 = (_g278 + 1);
HXDLIN( 284)										int dx14 = (_g278 - 1);
HXDLIN( 284)										::Dynamic this445 = pixelImage->image;
HXDLIN( 284)										int index78;
HXDLIN( 284)										if (pixelImage->useVirtualPos) {
HXLINE( 284)											index78 = ::Std_obj::_hx_int(((((( (Float)(dy15) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx14) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 284)											index78 = ::Std_obj::_hx_int(( (Float)(((dy15 * pixelImage->width) + dx14)) ));
            										}
HXDLIN( 284)										int c65 = ::iterMagic::Iimg_obj::get(this445,index78);
HXDLIN( 284)										int col26;
HXDLIN( 284)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)											col26 = ((((((c65 >> 24) & 255) << 24) | ((c65 & 255) << 16)) | (((c65 >> 8) & 255) << 8)) | ((c65 >> 16) & 255));
            										}
            										else {
HXLINE( 284)											col26 = c65;
            										}
HXDLIN( 284)										bool _hx_tmp117;
HXDLIN( 284)										if (pixelImage->useMask) {
HXLINE( 284)											_hx_tmp117 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 284)											_hx_tmp117 = false;
            										}
HXDLIN( 284)										if (_hx_tmp117) {
HXLINE( 284)											 ::pi_xy::ImageStruct this446 = pixelImage->mask;
HXDLIN( 284)											::Dynamic this447 = this446->image;
HXDLIN( 284)											int index79;
HXDLIN( 284)											if (this446->useVirtualPos) {
HXLINE( 284)												index79 = ::Std_obj::_hx_int(((((( (Float)(dy15) ) - this446->virtualY) * ( (Float)(this446->width) )) + dx14) - this446->virtualX));
            											}
            											else {
HXLINE( 284)												index79 = ::Std_obj::_hx_int(( (Float)(((dy15 * this446->width) + dx14)) ));
            											}
HXDLIN( 284)											int c66 = ::iterMagic::Iimg_obj::get(this447,index79);
HXDLIN( 284)											int v59;
HXDLIN( 284)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)												v59 = ((((((c66 >> 24) & 255) << 24) | ((c66 & 255) << 16)) | (((c66 >> 8) & 255) << 8)) | ((c66 >> 16) & 255));
            											}
            											else {
HXLINE( 284)												v59 = c66;
            											}
HXDLIN( 284)											int maskPixel13 = v59;
HXDLIN( 284)											int this448 = col26;
HXDLIN( 284)											if ((maskPixel13 == 0)) {
HXLINE( 284)												col26 = this448;
            											}
            											else {
HXLINE( 284)												Float m013;
HXDLIN( 284)												int this449 = ((maskPixel13 >> 24) & 255);
HXDLIN( 284)												if ((this449 == 0)) {
HXLINE( 284)													m013 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													m013 = (( (Float)(this449) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float m113;
HXDLIN( 284)												int this450 = ((maskPixel13 >> 16) & 255);
HXDLIN( 284)												if ((this450 == 0)) {
HXLINE( 284)													m113 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													m113 = (( (Float)(this450) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float m213;
HXDLIN( 284)												int this451 = ((maskPixel13 >> 8) & 255);
HXDLIN( 284)												if ((this451 == 0)) {
HXLINE( 284)													m213 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													m213 = (( (Float)(this451) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float m313;
HXDLIN( 284)												int this452 = (maskPixel13 & 255);
HXDLIN( 284)												if ((this452 == 0)) {
HXLINE( 284)													m313 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													m313 = (( (Float)(this452) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												int ch013 = ::Std_obj::_hx_int(((((Float)1.) - m013) * ( (Float)(((this448 >> 24) & 255)) )));
HXDLIN( 284)												int ch113 = ::Std_obj::_hx_int(((((Float)1.) - m113) * ( (Float)(((this448 >> 16) & 255)) )));
HXDLIN( 284)												int ch213 = ::Std_obj::_hx_int(((((Float)1.) - m213) * ( (Float)(((this448 >> 8) & 255)) )));
HXDLIN( 284)												int ch313 = ::Std_obj::_hx_int(((((Float)1.) - m313) * ( (Float)((this448 & 255)) )));
HXDLIN( 284)												col26 = ((((::Math_obj::round((( (Float)(ch013) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch113) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch213) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch313) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 284)										if ((col26 != 0)) {
HXLINE( 284)											int x54 = (dx14 - rectLeft13);
HXDLIN( 284)											int y54 = (dy15 - rectTop13);
HXDLIN( 284)											int c67 = col26;
HXDLIN( 284)											bool _hx_tmp118;
HXDLIN( 284)											if ((((c67 >> 24) & 255) < 254)) {
HXLINE( 284)												_hx_tmp118 = undoImage39->transparent;
            											}
            											else {
HXLINE( 284)												_hx_tmp118 = false;
            											}
HXDLIN( 284)											if (_hx_tmp118) {
HXLINE( 284)												int location26;
HXDLIN( 284)												if (undoImage39->useVirtualPos) {
HXLINE( 284)													location26 = ::Std_obj::_hx_int(((((( (Float)(y54) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x54) - undoImage39->virtualX));
            												}
            												else {
HXLINE( 284)													location26 = ::Std_obj::_hx_int(( (Float)(((y54 * undoImage39->width) + x54)) ));
            												}
HXDLIN( 284)												int this453 = ::iterMagic::Iimg_obj::get(undoImage39->image,location26);
HXDLIN( 284)												int this454;
HXDLIN( 284)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)													this454 = ((((((this453 >> 24) & 255) << 24) | ((this453 & 255) << 16)) | (((this453 >> 8) & 255) << 8)) | ((this453 >> 16) & 255));
            												}
            												else {
HXLINE( 284)													this454 = this453;
            												}
HXDLIN( 284)												Float a129;
HXDLIN( 284)												int this455 = ((this454 >> 24) & 255);
HXDLIN( 284)												if ((this455 == 0)) {
HXLINE( 284)													a129 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													a129 = (( (Float)(this455) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float r126;
HXDLIN( 284)												int this456 = ((this454 >> 16) & 255);
HXDLIN( 284)												if ((this456 == 0)) {
HXLINE( 284)													r126 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													r126 = (( (Float)(this456) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float g126;
HXDLIN( 284)												int this457 = ((this454 >> 8) & 255);
HXDLIN( 284)												if ((this457 == 0)) {
HXLINE( 284)													g126 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													g126 = (( (Float)(this457) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float b130;
HXDLIN( 284)												int this458 = (this454 & 255);
HXDLIN( 284)												if ((this458 == 0)) {
HXLINE( 284)													b130 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													b130 = (( (Float)(this458) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float a227;
HXDLIN( 284)												int this459 = ((col26 >> 24) & 255);
HXDLIN( 284)												if ((this459 == 0)) {
HXLINE( 284)													a227 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													a227 = (( (Float)(this459) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float r226;
HXDLIN( 284)												int this460 = ((col26 >> 16) & 255);
HXDLIN( 284)												if ((this460 == 0)) {
HXLINE( 284)													r226 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													r226 = (( (Float)(this460) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float g226;
HXDLIN( 284)												int this461 = ((col26 >> 8) & 255);
HXDLIN( 284)												if ((this461 == 0)) {
HXLINE( 284)													g226 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													g226 = (( (Float)(this461) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float b230;
HXDLIN( 284)												int this462 = (col26 & 255);
HXDLIN( 284)												if ((this462 == 0)) {
HXLINE( 284)													b230 = ((Float)0.);
            												}
            												else {
HXLINE( 284)													b230 = (( (Float)(this462) ) / ( (Float)(255) ));
            												}
HXDLIN( 284)												Float a326 = (a129 * (( (Float)(1) ) - a227));
HXDLIN( 284)												int r46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r126 * a326) + (r226 * a227))));
HXDLIN( 284)												int g46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g126 * a326) + (g226 * a227))));
HXDLIN( 284)												int b80 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b130 * a326) + (b230 * a227))));
HXDLIN( 284)												int a66 = ::Std_obj::_hx_int((( (Float)(255) ) * (a326 + a227)));
HXDLIN( 284)												int blended26 = ((((a66 << 24) | (r46 << 16)) | (g46 << 8)) | b80);
HXDLIN( 284)												{
HXLINE( 284)													int _hx_tmp119;
HXDLIN( 284)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)														_hx_tmp119 = ((((((blended26 >> 24) & 255) << 24) | ((blended26 & 255) << 16)) | (((blended26 >> 8) & 255) << 8)) | ((blended26 >> 16) & 255));
            													}
            													else {
HXLINE( 284)														_hx_tmp119 = blended26;
            													}
HXDLIN( 284)													::iterMagic::Iimg_obj::set(undoImage39->image,location26,_hx_tmp119);
            												}
            											}
            											else {
HXLINE( 284)												::Dynamic this463 = undoImage39->image;
HXDLIN( 284)												int index80;
HXDLIN( 284)												if (undoImage39->useVirtualPos) {
HXLINE( 284)													index80 = ::Std_obj::_hx_int(((((( (Float)(y54) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x54) - undoImage39->virtualX));
            												}
            												else {
HXLINE( 284)													index80 = ::Std_obj::_hx_int(( (Float)(((y54 * undoImage39->width) + x54)) ));
            												}
HXDLIN( 284)												int _hx_tmp120;
HXDLIN( 284)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)													_hx_tmp120 = ((((((c67 >> 24) & 255) << 24) | ((c67 & 255) << 16)) | (((c67 >> 8) & 255) << 8)) | ((c67 >> 16) & 255));
            												}
            												else {
HXLINE( 284)													_hx_tmp120 = c67;
            												}
HXDLIN( 284)												::iterMagic::Iimg_obj::set(this463,index80,_hx_tmp120);
            											}
            										}
            										else {
HXLINE( 284)											if (forceClear13) {
HXLINE( 284)												::Dynamic this464 = undoImage39->image;
HXDLIN( 284)												int x55 = (dx14 - rectLeft13);
HXDLIN( 284)												int y55 = (dy15 - rectTop13);
HXDLIN( 284)												int index81;
HXDLIN( 284)												if (undoImage39->useVirtualPos) {
HXLINE( 284)													index81 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x55) - undoImage39->virtualX));
            												}
            												else {
HXLINE( 284)													index81 = ::Std_obj::_hx_int(( (Float)(((y55 * undoImage39->width) + x55)) ));
            												}
HXDLIN( 284)												::iterMagic::Iimg_obj::set(this464,index81,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 284)				{
HXLINE( 284)					int _g_min26 = xIter313->start;
HXDLIN( 284)					int _g_max26 = xIter313->max;
HXDLIN( 284)					while((_g_min26 < _g_max26)){
HXLINE( 284)						_g_min26 = (_g_min26 + 1);
HXDLIN( 284)						int px13 = (_g_min26 - 1);
HXDLIN( 284)						Float pcx13 = (( (Float)(px13) ) - x);
HXDLIN( 284)						{
HXLINE( 284)							int _g_min27 = yIter313->start;
HXDLIN( 284)							int _g_max27 = yIter313->max;
HXDLIN( 284)							while((_g_min27 < _g_max27)){
HXLINE( 284)								_g_min27 = (_g_min27 + 1);
HXDLIN( 284)								int py13 = (_g_min27 - 1);
HXDLIN( 284)								Float pcy13 = (( (Float)(py13) ) - dy13);
HXDLIN( 284)								Float dot3113 = ((pcx13 * bcx13) + (pcy13 * bcy13));
HXDLIN( 284)								Float dot3213 = ((pcx13 * acx13) + (pcy13 * acy13));
HXDLIN( 284)								Float ratioA13 = (((dot2213 * dot3113) - (dot1213 * dot3213)) * denom113);
HXDLIN( 284)								Float ratioB13 = (((dot1113 * dot3213) - (dot1213 * dot3113)) * denom113);
HXDLIN( 284)								Float ratioC13 = ((((Float)1.0) - ratioB13) - ratioA13);
HXDLIN( 284)								bool _hx_tmp121;
HXDLIN( 284)								bool _hx_tmp122;
HXDLIN( 284)								if ((ratioA13 >= 0)) {
HXLINE( 284)									_hx_tmp122 = (ratioB13 >= 0);
            								}
            								else {
HXLINE( 284)									_hx_tmp122 = false;
            								}
HXDLIN( 284)								if (_hx_tmp122) {
HXLINE( 284)									_hx_tmp121 = (ratioC13 >= 0);
            								}
            								else {
HXLINE( 284)									_hx_tmp121 = false;
            								}
HXDLIN( 284)								if (_hx_tmp121) {
HXLINE( 284)									Float u13 = (((au14 * ratioA13) + (bu14 * ratioB13)) + (((Float)0.) * ratioC13));
HXDLIN( 284)									Float v60 = (((av14 * ratioA13) + (bv13 * ratioB13)) + (cv * ratioC13));
HXDLIN( 284)									int x56 = ::Std_obj::_hx_int(((u13 * win->width) + win->x));
HXDLIN( 284)									int y56 = ::Std_obj::_hx_int(((v60 * win->height) + win->y));
HXDLIN( 284)									::Dynamic this465 = texture->image;
HXDLIN( 284)									int index82;
HXDLIN( 284)									if (texture->useVirtualPos) {
HXLINE( 284)										index82 = ::Std_obj::_hx_int(((((( (Float)(y56) ) - texture->virtualY) * ( (Float)(texture->width) )) + x56) - texture->virtualX));
            									}
            									else {
HXLINE( 284)										index82 = ::Std_obj::_hx_int(( (Float)(((y56 * texture->width) + x56)) ));
            									}
HXDLIN( 284)									int c68 = ::iterMagic::Iimg_obj::get(this465,index82);
HXDLIN( 284)									int col27;
HXDLIN( 284)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)										col27 = ((((((c68 >> 24) & 255) << 24) | ((c68 & 255) << 16)) | (((c68 >> 8) & 255) << 8)) | ((c68 >> 16) & 255));
            									}
            									else {
HXLINE( 284)										col27 = c68;
            									}
HXDLIN( 284)									{
HXLINE( 284)										int c69 = col27;
HXDLIN( 284)										bool _hx_tmp123;
HXDLIN( 284)										if ((((c69 >> 24) & 255) < 254)) {
HXLINE( 284)											_hx_tmp123 = pixelImage->transparent;
            										}
            										else {
HXLINE( 284)											_hx_tmp123 = false;
            										}
HXDLIN( 284)										if (_hx_tmp123) {
HXLINE( 284)											int location27;
HXDLIN( 284)											if (pixelImage->useVirtualPos) {
HXLINE( 284)												location27 = ::Std_obj::_hx_int(((((( (Float)(py13) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px13) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 284)												location27 = ::Std_obj::_hx_int(( (Float)(((py13 * pixelImage->width) + px13)) ));
            											}
HXDLIN( 284)											int this466 = ::iterMagic::Iimg_obj::get(pixelImage->image,location27);
HXDLIN( 284)											int this467;
HXDLIN( 284)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)												this467 = ((((((this466 >> 24) & 255) << 24) | ((this466 & 255) << 16)) | (((this466 >> 8) & 255) << 8)) | ((this466 >> 16) & 255));
            											}
            											else {
HXLINE( 284)												this467 = this466;
            											}
HXDLIN( 284)											Float a130;
HXDLIN( 284)											int this468 = ((this467 >> 24) & 255);
HXDLIN( 284)											if ((this468 == 0)) {
HXLINE( 284)												a130 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												a130 = (( (Float)(this468) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float r127;
HXDLIN( 284)											int this469 = ((this467 >> 16) & 255);
HXDLIN( 284)											if ((this469 == 0)) {
HXLINE( 284)												r127 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												r127 = (( (Float)(this469) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float g127;
HXDLIN( 284)											int this470 = ((this467 >> 8) & 255);
HXDLIN( 284)											if ((this470 == 0)) {
HXLINE( 284)												g127 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												g127 = (( (Float)(this470) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float b131;
HXDLIN( 284)											int this471 = (this467 & 255);
HXDLIN( 284)											if ((this471 == 0)) {
HXLINE( 284)												b131 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												b131 = (( (Float)(this471) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float a228;
HXDLIN( 284)											int this472 = ((col27 >> 24) & 255);
HXDLIN( 284)											if ((this472 == 0)) {
HXLINE( 284)												a228 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												a228 = (( (Float)(this472) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float r227;
HXDLIN( 284)											int this473 = ((col27 >> 16) & 255);
HXDLIN( 284)											if ((this473 == 0)) {
HXLINE( 284)												r227 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												r227 = (( (Float)(this473) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float g227;
HXDLIN( 284)											int this474 = ((col27 >> 8) & 255);
HXDLIN( 284)											if ((this474 == 0)) {
HXLINE( 284)												g227 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												g227 = (( (Float)(this474) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float b231;
HXDLIN( 284)											int this475 = (col27 & 255);
HXDLIN( 284)											if ((this475 == 0)) {
HXLINE( 284)												b231 = ((Float)0.);
            											}
            											else {
HXLINE( 284)												b231 = (( (Float)(this475) ) / ( (Float)(255) ));
            											}
HXDLIN( 284)											Float a327 = (a130 * (( (Float)(1) ) - a228));
HXDLIN( 284)											int r47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r127 * a327) + (r227 * a228))));
HXDLIN( 284)											int g47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g127 * a327) + (g227 * a228))));
HXDLIN( 284)											int b81 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b131 * a327) + (b231 * a228))));
HXDLIN( 284)											int a67 = ::Std_obj::_hx_int((( (Float)(255) ) * (a327 + a228)));
HXDLIN( 284)											int blended27 = ((((a67 << 24) | (r47 << 16)) | (g47 << 8)) | b81);
HXDLIN( 284)											{
HXLINE( 284)												int _hx_tmp124;
HXDLIN( 284)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)													_hx_tmp124 = ((((((blended27 >> 24) & 255) << 24) | ((blended27 & 255) << 16)) | (((blended27 >> 8) & 255) << 8)) | ((blended27 >> 16) & 255));
            												}
            												else {
HXLINE( 284)													_hx_tmp124 = blended27;
            												}
HXDLIN( 284)												::iterMagic::Iimg_obj::set(pixelImage->image,location27,_hx_tmp124);
            											}
            										}
            										else {
HXLINE( 284)											::Dynamic this476 = pixelImage->image;
HXDLIN( 284)											int index83;
HXDLIN( 284)											if (pixelImage->useVirtualPos) {
HXLINE( 284)												index83 = ::Std_obj::_hx_int(((((( (Float)(py13) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px13) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 284)												index83 = ::Std_obj::_hx_int(( (Float)(((py13 * pixelImage->width) + px13)) ));
            											}
HXDLIN( 284)											int _hx_tmp125;
HXDLIN( 284)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 284)												_hx_tmp125 = ((((((c69 >> 24) & 255) << 24) | ((c69 & 255) << 16)) | (((c69 >> 8) & 255) << 8)) | ((c69 >> 16) & 255));
            											}
            											else {
HXLINE( 284)												_hx_tmp125 = c69;
            											}
HXDLIN( 284)											::iterMagic::Iimg_obj::set(this476,index83,_hx_tmp125);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 284)				if ((hasHit == false)) {
HXLINE( 284)					 ::pi_xy::algo::HitTri v61 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,bottomY,leftX,cy4,x,dy13,true);
HXDLIN( 284)					if (hasUndo13) {
HXLINE( 284)						v61->undoImage = undoImage39;
HXDLIN( 284)						v61->undoX = xIter313->start;
HXDLIN( 284)						v61->undoY = yIter313->start;
            					}
            				}
            			}
HXDLIN( 284)			if ((hasHit == true)) {
HXLINE( 284)				 ::pi_xy::algo::HitQuad v62 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x,bottomY,leftX,bottomY,leftX,cy4,x,dy13,true);
            			}
            		}
HXLINE( 289)		au = bu;
HXLINE( 290)		bu = ((left + fat) * sw);
HXLINE( 291)		{
HXLINE( 291)			Float cy5 = (y + hiNew);
HXDLIN( 291)			Float dy16 = (y + hiNew);
HXDLIN( 291)			{
HXLINE( 291)				Float au15 = au;
HXDLIN( 291)				Float av15 = av;
HXDLIN( 291)				Float bu15 = bu;
HXDLIN( 291)				Float bv14 = av;
HXDLIN( 291)				bool hasUndo14 = false;
HXDLIN( 291)				Float temp14 = au15;
HXLINE( 422)				au15 = bu15;
HXLINE( 423)				bu15 = temp14;
HXLINE( 424)				temp14 = av15;
HXLINE( 425)				av15 = bv14;
HXLINE( 426)				bv14 = temp14;
HXLINE( 291)				Float bcx14 = (rightX - leftX);
HXDLIN( 291)				Float bcy14 = (bottomY - dy16);
HXDLIN( 291)				Float acx14 = (leftX - leftX);
HXDLIN( 291)				Float acy14 = (bottomY - dy16);
HXDLIN( 291)				Float dot1114 = ((bcx14 * bcx14) + (bcy14 * bcy14));
HXDLIN( 291)				Float dot1214 = ((bcx14 * acx14) + (bcy14 * acy14));
HXDLIN( 291)				Float dot2214 = ((acx14 * acx14) + (acy14 * acy14));
HXDLIN( 291)				Float denom114 = (( (Float)(1) ) / ((dot1114 * dot2214) - (dot1214 * dot1214)));
HXDLIN( 291)				 ::pi_xy::iter::IntIterStart xIter314;
HXDLIN( 291)				if ((leftX > rightX)) {
HXLINE( 291)					if ((leftX > leftX)) {
HXLINE( 291)						int min56;
HXDLIN( 291)						if ((rightX > leftX)) {
HXLINE( 291)							min56 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 291)							min56 = ::Math_obj::floor(rightX);
            						}
HXDLIN( 291)						int ii_min112 = min56;
HXDLIN( 291)						int ii_max112 = ::Math_obj::ceil(leftX);
HXDLIN( 291)						xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min112,ii_max112);
            					}
            					else {
HXLINE( 291)						int ii_min113 = ::Math_obj::floor(rightX);
HXDLIN( 291)						int ii_max113 = ::Math_obj::ceil(leftX);
HXDLIN( 291)						xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min113,ii_max113);
            					}
            				}
            				else {
HXLINE( 291)					if ((rightX > leftX)) {
HXLINE( 291)						int min57;
HXDLIN( 291)						if ((leftX > leftX)) {
HXLINE( 291)							min57 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 291)							min57 = ::Math_obj::ceil(leftX);
            						}
HXDLIN( 291)						int ii_min114 = min57;
HXDLIN( 291)						int ii_max114 = ::Math_obj::ceil(rightX);
HXDLIN( 291)						xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min114,ii_max114);
            					}
            					else {
HXLINE( 291)						int ii_min115 = ::Math_obj::floor(leftX);
HXDLIN( 291)						int ii_max115 = ::Math_obj::ceil(leftX);
HXDLIN( 291)						xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min115,ii_max115);
            					}
            				}
HXDLIN( 291)				 ::pi_xy::iter::IntIterStart yIter314;
HXDLIN( 291)				if ((bottomY > bottomY)) {
HXLINE( 291)					if ((bottomY > dy16)) {
HXLINE( 291)						int min58;
HXDLIN( 291)						if ((bottomY > dy16)) {
HXLINE( 291)							min58 = ::Math_obj::floor(dy16);
            						}
            						else {
HXLINE( 291)							min58 = ::Math_obj::floor(bottomY);
            						}
HXDLIN( 291)						int ii_min116 = min58;
HXDLIN( 291)						int ii_max116 = ::Math_obj::ceil(bottomY);
HXDLIN( 291)						yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min116,ii_max116);
            					}
            					else {
HXLINE( 291)						int ii_min117 = ::Math_obj::floor(bottomY);
HXDLIN( 291)						int ii_max117 = ::Math_obj::ceil(dy16);
HXDLIN( 291)						yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min117,ii_max117);
            					}
            				}
            				else {
HXLINE( 291)					if ((bottomY > dy16)) {
HXLINE( 291)						int min59;
HXDLIN( 291)						if ((bottomY > dy16)) {
HXLINE( 291)							min59 = ::Math_obj::floor(dy16);
            						}
            						else {
HXLINE( 291)							min59 = ::Math_obj::ceil(bottomY);
            						}
HXDLIN( 291)						int ii_min118 = min59;
HXDLIN( 291)						int ii_max118 = ::Math_obj::ceil(bottomY);
HXDLIN( 291)						yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min118,ii_max118);
            					}
            					else {
HXLINE( 291)						int ii_min119 = ::Math_obj::floor(bottomY);
HXDLIN( 291)						int ii_max119 = ::Math_obj::ceil(dy16);
HXDLIN( 291)						yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min119,ii_max119);
            					}
            				}
HXDLIN( 291)				 ::pi_xy::ImageStruct undoImage42 = null();
HXDLIN( 291)				if (hasUndo14) {
HXLINE( 291)					int width14 = ((xIter314->max - xIter314->start) + 1);
HXDLIN( 291)					int height14 = ((yIter314->max - yIter314->start) + 1);
HXDLIN( 291)					 ::Dynamic imageType14 = null();
HXDLIN( 291)					 ::pi_xy::ImageStruct this477 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 291)					if (::hx::IsNull( imageType14 )) {
HXLINE(  54)						imageType14 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 291)					::Dynamic undoImage43;
HXDLIN( 291)					switch((int)(( (int)(imageType14) ))){
            						case (int)0: {
HXLINE( 291)							 ::iterMagic::BytesImg byt14 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::BytesImg b82 = byt14;
HXDLIN( 291)							{
HXLINE( 291)								b82->width = width14;
HXDLIN( 291)								b82->height = height14;
HXDLIN( 291)								b82->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 291)								b82->data = ::haxe::io::Bytes_obj::alloc((b82->length * 4));
HXDLIN( 291)								{
HXLINE( 291)									int len28 = b82->length;
HXDLIN( 291)									int w14 = 0;
HXDLIN( 291)									{
HXLINE( 291)										int _g280 = 0;
HXDLIN( 291)										int _g281 = b82->height;
HXDLIN( 291)										while((_g280 < _g281)){
HXLINE( 291)											_g280 = (_g280 + 1);
HXDLIN( 291)											int y57 = (_g280 - 1);
HXDLIN( 291)											{
HXLINE( 291)												int _g282 = 0;
HXDLIN( 291)												int _g283 = b82->width;
HXDLIN( 291)												while((_g282 < _g283)){
HXLINE( 291)													_g282 = (_g282 + 1);
HXDLIN( 291)													int x57 = (_g282 - 1);
HXDLIN( 291)													{
HXLINE( 291)														w14 = (w14 + 1);
HXDLIN( 291)														b82->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 291)													{
HXLINE( 291)														w14 = (w14 + 1);
HXDLIN( 291)														b82->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 291)													{
HXLINE( 291)														w14 = (w14 + 1);
HXDLIN( 291)														b82->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 291)													{
HXLINE( 291)														w14 = (w14 + 1);
HXDLIN( 291)														b82->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 291)							undoImage43 = b82;
            						}
            						break;
            						case (int)1: {
HXLINE( 291)							 ::iterMagic::ArrIntImg arrI14 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::ArrIntImg a68 = arrI14;
HXDLIN( 291)							{
HXLINE( 291)								a68->width = width14;
HXDLIN( 291)								a68->height = height14;
HXDLIN( 291)								a68->data = ::Array_obj< int >::__new(0);
HXDLIN( 291)								a68->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 291)								{
HXLINE( 291)									int _g284 = 0;
HXDLIN( 291)									int _g285 = a68->length;
HXDLIN( 291)									while((_g284 < _g285)){
HXLINE( 291)										_g284 = (_g284 + 1);
HXDLIN( 291)										int i84 = (_g284 - 1);
HXDLIN( 291)										a68->data[i84] = 0;
            									}
            								}
            							}
HXDLIN( 291)							undoImage43 = a68;
            						}
            						break;
            						case (int)2: {
HXLINE( 291)							 ::iterMagic::U32ArrImg u32a14 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::U32ArrImg b83 = u32a14;
HXDLIN( 291)							{
HXLINE( 291)								b83->width = width14;
HXDLIN( 291)								b83->height = height14;
HXDLIN( 291)								b83->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 291)								int size14 = (b83->length * 4);
HXDLIN( 291)								b83->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size14),0,size14);
HXDLIN( 291)								{
HXLINE( 291)									int _g286 = 0;
HXDLIN( 291)									int _g287 = b83->length;
HXDLIN( 291)									while((_g286 < _g287)){
HXLINE( 291)										_g286 = (_g286 + 1);
HXDLIN( 291)										int i85 = (_g286 - 1);
HXDLIN( 291)										{
HXLINE( 291)											 ::haxe::io::ArrayBufferViewImpl this478 = b83->data;
HXDLIN( 291)											bool undoImage44;
HXDLIN( 291)											if ((i85 >= 0)) {
HXLINE( 291)												undoImage44 = (i85 < (this478->byteLength >> 2));
            											}
            											else {
HXLINE( 291)												undoImage44 = false;
            											}
HXDLIN( 291)											if (undoImage44) {
HXLINE( 291)												 ::haxe::io::Bytes _this14 = this478->bytes;
HXDLIN( 291)												int pos14 = ((i85 << 2) + this478->byteOffset);
HXDLIN( 291)												_this14->b[pos14] = ( (unsigned char)(0) );
HXDLIN( 291)												_this14->b[(pos14 + 1)] = ( (unsigned char)(0) );
HXDLIN( 291)												_this14->b[(pos14 + 2)] = ( (unsigned char)(0) );
HXDLIN( 291)												_this14->b[(pos14 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 291)							undoImage43 = b83;
            						}
            						break;
            						case (int)3: {
HXLINE( 291)							 ::iterMagic::VecIntImg vec14 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::VecIntImg v63 = vec14;
HXDLIN( 291)							{
HXLINE( 291)								v63->width = width14;
HXDLIN( 291)								v63->height = height14;
HXDLIN( 291)								v63->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 291)								v63->data = ::Array_obj< int >::__new(v63->length);
HXDLIN( 291)								{
HXLINE( 291)									int _g288 = 0;
HXDLIN( 291)									int _g289 = v63->length;
HXDLIN( 291)									while((_g288 < _g289)){
HXLINE( 291)										_g288 = (_g288 + 1);
HXDLIN( 291)										int i86 = (_g288 - 1);
HXDLIN( 291)										v63->data->__unsafe_set(i86,0);
            									}
            								}
            							}
HXDLIN( 291)							undoImage43 = v63;
            						}
            						break;
            						case (int)4: {
HXLINE( 291)							 ::iterMagic::StackIntImg sInt14 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::StackIntImg b84 = sInt14;
HXDLIN( 291)							{
HXLINE( 291)								b84->width = width14;
HXDLIN( 291)								b84->height = height14;
HXDLIN( 291)								b84->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN( 291)								b84->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 291)								{
HXLINE( 291)									int len29 = b84->length;
HXDLIN( 291)									 ::haxe::ds::GenericStack_Int d14 = b84->data;
HXDLIN( 291)									if (::hx::IsNull( d14->head )) {
HXLINE( 291)										int _g290 = 0;
HXDLIN( 291)										int _g291 = len29;
HXDLIN( 291)										while((_g290 < _g291)){
HXLINE( 291)											_g290 = (_g290 + 1);
HXDLIN( 291)											int i87 = (_g290 - 1);
HXDLIN( 291)											d14->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d14->head);
            										}
            									}
            									else {
HXLINE( 291)										int _g292 = 0;
HXDLIN( 291)										int _g293 = len29;
HXDLIN( 291)										while((_g292 < _g293)){
HXLINE( 291)											_g292 = (_g292 + 1);
HXDLIN( 291)											int i88 = (_g292 - 1);
HXDLIN( 291)											{
HXLINE( 291)												 ::haxe::ds::GenericCell_Int l14 = b84->data->head;
HXDLIN( 291)												 ::haxe::ds::GenericCell_Int prev14 = null();
HXDLIN( 291)												{
HXLINE( 291)													int _g294 = 0;
HXDLIN( 291)													int _g295 = i88;
HXDLIN( 291)													while((_g294 < _g295)){
HXLINE( 291)														_g294 = (_g294 + 1);
HXDLIN( 291)														int i89 = (_g294 - 1);
HXLINE( 345)														prev14 = l14;
HXLINE( 346)														l14 = l14->next;
            													}
            												}
HXLINE( 291)												if (::hx::IsNull( prev14 )) {
HXLINE( 291)													b84->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l14->next);
HXDLIN( 291)													l14 = null();
            												}
            												else {
HXLINE( 291)													prev14->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l14->next);
HXDLIN( 291)													l14 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 291)							undoImage43 = b84;
            						}
            						break;
            					}
HXDLIN( 291)					this477->image = undoImage43;
HXDLIN( 291)					this477->width = width14;
HXDLIN( 291)					this477->height = height14;
HXDLIN( 291)					this477->imageType = ( (int)(imageType14) );
HXDLIN( 291)					undoImage42 = this477;
HXDLIN( 291)					{
HXLINE( 291)						int rectLeft14 = xIter314->start;
HXDLIN( 291)						int rectTop14 = yIter314->start;
HXDLIN( 291)						int rectRight14 = xIter314->max;
HXDLIN( 291)						bool forceClear14 = false;
HXDLIN( 291)						{
HXLINE( 291)							int _g296 = rectTop14;
HXDLIN( 291)							int _g297 = yIter314->max;
HXDLIN( 291)							while((_g296 < _g297)){
HXLINE( 291)								_g296 = (_g296 + 1);
HXDLIN( 291)								int dy17 = (_g296 - 1);
HXDLIN( 291)								{
HXLINE( 291)									int _g298 = rectLeft14;
HXDLIN( 291)									int _g299 = rectRight14;
HXDLIN( 291)									while((_g298 < _g299)){
HXLINE( 291)										_g298 = (_g298 + 1);
HXDLIN( 291)										int dx15 = (_g298 - 1);
HXDLIN( 291)										::Dynamic this479 = pixelImage->image;
HXDLIN( 291)										int index84;
HXDLIN( 291)										if (pixelImage->useVirtualPos) {
HXLINE( 291)											index84 = ::Std_obj::_hx_int(((((( (Float)(dy17) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx15) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 291)											index84 = ::Std_obj::_hx_int(( (Float)(((dy17 * pixelImage->width) + dx15)) ));
            										}
HXDLIN( 291)										int c70 = ::iterMagic::Iimg_obj::get(this479,index84);
HXDLIN( 291)										int col28;
HXDLIN( 291)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)											col28 = ((((((c70 >> 24) & 255) << 24) | ((c70 & 255) << 16)) | (((c70 >> 8) & 255) << 8)) | ((c70 >> 16) & 255));
            										}
            										else {
HXLINE( 291)											col28 = c70;
            										}
HXDLIN( 291)										bool _hx_tmp126;
HXDLIN( 291)										if (pixelImage->useMask) {
HXLINE( 291)											_hx_tmp126 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 291)											_hx_tmp126 = false;
            										}
HXDLIN( 291)										if (_hx_tmp126) {
HXLINE( 291)											 ::pi_xy::ImageStruct this480 = pixelImage->mask;
HXDLIN( 291)											::Dynamic this481 = this480->image;
HXDLIN( 291)											int index85;
HXDLIN( 291)											if (this480->useVirtualPos) {
HXLINE( 291)												index85 = ::Std_obj::_hx_int(((((( (Float)(dy17) ) - this480->virtualY) * ( (Float)(this480->width) )) + dx15) - this480->virtualX));
            											}
            											else {
HXLINE( 291)												index85 = ::Std_obj::_hx_int(( (Float)(((dy17 * this480->width) + dx15)) ));
            											}
HXDLIN( 291)											int c71 = ::iterMagic::Iimg_obj::get(this481,index85);
HXDLIN( 291)											int v64;
HXDLIN( 291)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)												v64 = ((((((c71 >> 24) & 255) << 24) | ((c71 & 255) << 16)) | (((c71 >> 8) & 255) << 8)) | ((c71 >> 16) & 255));
            											}
            											else {
HXLINE( 291)												v64 = c71;
            											}
HXDLIN( 291)											int maskPixel14 = v64;
HXDLIN( 291)											int this482 = col28;
HXDLIN( 291)											if ((maskPixel14 == 0)) {
HXLINE( 291)												col28 = this482;
            											}
            											else {
HXLINE( 291)												Float m014;
HXDLIN( 291)												int this483 = ((maskPixel14 >> 24) & 255);
HXDLIN( 291)												if ((this483 == 0)) {
HXLINE( 291)													m014 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													m014 = (( (Float)(this483) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float m114;
HXDLIN( 291)												int this484 = ((maskPixel14 >> 16) & 255);
HXDLIN( 291)												if ((this484 == 0)) {
HXLINE( 291)													m114 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													m114 = (( (Float)(this484) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float m214;
HXDLIN( 291)												int this485 = ((maskPixel14 >> 8) & 255);
HXDLIN( 291)												if ((this485 == 0)) {
HXLINE( 291)													m214 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													m214 = (( (Float)(this485) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float m314;
HXDLIN( 291)												int this486 = (maskPixel14 & 255);
HXDLIN( 291)												if ((this486 == 0)) {
HXLINE( 291)													m314 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													m314 = (( (Float)(this486) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												int ch014 = ::Std_obj::_hx_int(((((Float)1.) - m014) * ( (Float)(((this482 >> 24) & 255)) )));
HXDLIN( 291)												int ch114 = ::Std_obj::_hx_int(((((Float)1.) - m114) * ( (Float)(((this482 >> 16) & 255)) )));
HXDLIN( 291)												int ch214 = ::Std_obj::_hx_int(((((Float)1.) - m214) * ( (Float)(((this482 >> 8) & 255)) )));
HXDLIN( 291)												int ch314 = ::Std_obj::_hx_int(((((Float)1.) - m314) * ( (Float)((this482 & 255)) )));
HXDLIN( 291)												col28 = ((((::Math_obj::round((( (Float)(ch014) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch114) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch214) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch314) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 291)										if ((col28 != 0)) {
HXLINE( 291)											int x58 = (dx15 - rectLeft14);
HXDLIN( 291)											int y58 = (dy17 - rectTop14);
HXDLIN( 291)											int c72 = col28;
HXDLIN( 291)											bool _hx_tmp127;
HXDLIN( 291)											if ((((c72 >> 24) & 255) < 254)) {
HXLINE( 291)												_hx_tmp127 = undoImage42->transparent;
            											}
            											else {
HXLINE( 291)												_hx_tmp127 = false;
            											}
HXDLIN( 291)											if (_hx_tmp127) {
HXLINE( 291)												int location28;
HXDLIN( 291)												if (undoImage42->useVirtualPos) {
HXLINE( 291)													location28 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x58) - undoImage42->virtualX));
            												}
            												else {
HXLINE( 291)													location28 = ::Std_obj::_hx_int(( (Float)(((y58 * undoImage42->width) + x58)) ));
            												}
HXDLIN( 291)												int this487 = ::iterMagic::Iimg_obj::get(undoImage42->image,location28);
HXDLIN( 291)												int this488;
HXDLIN( 291)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)													this488 = ((((((this487 >> 24) & 255) << 24) | ((this487 & 255) << 16)) | (((this487 >> 8) & 255) << 8)) | ((this487 >> 16) & 255));
            												}
            												else {
HXLINE( 291)													this488 = this487;
            												}
HXDLIN( 291)												Float a131;
HXDLIN( 291)												int this489 = ((this488 >> 24) & 255);
HXDLIN( 291)												if ((this489 == 0)) {
HXLINE( 291)													a131 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													a131 = (( (Float)(this489) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float r128;
HXDLIN( 291)												int this490 = ((this488 >> 16) & 255);
HXDLIN( 291)												if ((this490 == 0)) {
HXLINE( 291)													r128 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													r128 = (( (Float)(this490) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float g128;
HXDLIN( 291)												int this491 = ((this488 >> 8) & 255);
HXDLIN( 291)												if ((this491 == 0)) {
HXLINE( 291)													g128 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													g128 = (( (Float)(this491) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float b132;
HXDLIN( 291)												int this492 = (this488 & 255);
HXDLIN( 291)												if ((this492 == 0)) {
HXLINE( 291)													b132 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													b132 = (( (Float)(this492) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float a229;
HXDLIN( 291)												int this493 = ((col28 >> 24) & 255);
HXDLIN( 291)												if ((this493 == 0)) {
HXLINE( 291)													a229 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													a229 = (( (Float)(this493) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float r228;
HXDLIN( 291)												int this494 = ((col28 >> 16) & 255);
HXDLIN( 291)												if ((this494 == 0)) {
HXLINE( 291)													r228 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													r228 = (( (Float)(this494) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float g228;
HXDLIN( 291)												int this495 = ((col28 >> 8) & 255);
HXDLIN( 291)												if ((this495 == 0)) {
HXLINE( 291)													g228 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													g228 = (( (Float)(this495) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float b232;
HXDLIN( 291)												int this496 = (col28 & 255);
HXDLIN( 291)												if ((this496 == 0)) {
HXLINE( 291)													b232 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													b232 = (( (Float)(this496) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float a328 = (a131 * (( (Float)(1) ) - a229));
HXDLIN( 291)												int r48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r128 * a328) + (r228 * a229))));
HXDLIN( 291)												int g48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g128 * a328) + (g228 * a229))));
HXDLIN( 291)												int b85 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b132 * a328) + (b232 * a229))));
HXDLIN( 291)												int a69 = ::Std_obj::_hx_int((( (Float)(255) ) * (a328 + a229)));
HXDLIN( 291)												int blended28 = ((((a69 << 24) | (r48 << 16)) | (g48 << 8)) | b85);
HXDLIN( 291)												{
HXLINE( 291)													int _hx_tmp128;
HXDLIN( 291)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)														_hx_tmp128 = ((((((blended28 >> 24) & 255) << 24) | ((blended28 & 255) << 16)) | (((blended28 >> 8) & 255) << 8)) | ((blended28 >> 16) & 255));
            													}
            													else {
HXLINE( 291)														_hx_tmp128 = blended28;
            													}
HXDLIN( 291)													::iterMagic::Iimg_obj::set(undoImage42->image,location28,_hx_tmp128);
            												}
            											}
            											else {
HXLINE( 291)												::Dynamic this497 = undoImage42->image;
HXDLIN( 291)												int index86;
HXDLIN( 291)												if (undoImage42->useVirtualPos) {
HXLINE( 291)													index86 = ::Std_obj::_hx_int(((((( (Float)(y58) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x58) - undoImage42->virtualX));
            												}
            												else {
HXLINE( 291)													index86 = ::Std_obj::_hx_int(( (Float)(((y58 * undoImage42->width) + x58)) ));
            												}
HXDLIN( 291)												int _hx_tmp129;
HXDLIN( 291)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)													_hx_tmp129 = ((((((c72 >> 24) & 255) << 24) | ((c72 & 255) << 16)) | (((c72 >> 8) & 255) << 8)) | ((c72 >> 16) & 255));
            												}
            												else {
HXLINE( 291)													_hx_tmp129 = c72;
            												}
HXDLIN( 291)												::iterMagic::Iimg_obj::set(this497,index86,_hx_tmp129);
            											}
            										}
            										else {
HXLINE( 291)											if (forceClear14) {
HXLINE( 291)												::Dynamic this498 = undoImage42->image;
HXDLIN( 291)												int x59 = (dx15 - rectLeft14);
HXDLIN( 291)												int y59 = (dy17 - rectTop14);
HXDLIN( 291)												int index87;
HXDLIN( 291)												if (undoImage42->useVirtualPos) {
HXLINE( 291)													index87 = ::Std_obj::_hx_int(((((( (Float)(y59) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x59) - undoImage42->virtualX));
            												}
            												else {
HXLINE( 291)													index87 = ::Std_obj::_hx_int(( (Float)(((y59 * undoImage42->width) + x59)) ));
            												}
HXDLIN( 291)												::iterMagic::Iimg_obj::set(this498,index87,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 291)				{
HXLINE( 291)					int _g_min28 = xIter314->start;
HXDLIN( 291)					int _g_max28 = xIter314->max;
HXDLIN( 291)					while((_g_min28 < _g_max28)){
HXLINE( 291)						_g_min28 = (_g_min28 + 1);
HXDLIN( 291)						int px14 = (_g_min28 - 1);
HXDLIN( 291)						Float pcx14 = (( (Float)(px14) ) - leftX);
HXDLIN( 291)						{
HXLINE( 291)							int _g_min29 = yIter314->start;
HXDLIN( 291)							int _g_max29 = yIter314->max;
HXDLIN( 291)							while((_g_min29 < _g_max29)){
HXLINE( 291)								_g_min29 = (_g_min29 + 1);
HXDLIN( 291)								int py14 = (_g_min29 - 1);
HXDLIN( 291)								Float pcy14 = (( (Float)(py14) ) - dy16);
HXDLIN( 291)								Float dot3114 = ((pcx14 * bcx14) + (pcy14 * bcy14));
HXDLIN( 291)								Float dot3214 = ((pcx14 * acx14) + (pcy14 * acy14));
HXDLIN( 291)								Float ratioA14 = (((dot2214 * dot3114) - (dot1214 * dot3214)) * denom114);
HXDLIN( 291)								Float ratioB14 = (((dot1114 * dot3214) - (dot1214 * dot3114)) * denom114);
HXDLIN( 291)								Float ratioC14 = ((((Float)1.0) - ratioB14) - ratioA14);
HXDLIN( 291)								bool _hx_tmp130;
HXDLIN( 291)								bool _hx_tmp131;
HXDLIN( 291)								if ((ratioA14 >= 0)) {
HXLINE( 291)									_hx_tmp131 = (ratioB14 >= 0);
            								}
            								else {
HXLINE( 291)									_hx_tmp131 = false;
            								}
HXDLIN( 291)								if (_hx_tmp131) {
HXLINE( 291)									_hx_tmp130 = (ratioC14 >= 0);
            								}
            								else {
HXLINE( 291)									_hx_tmp130 = false;
            								}
HXDLIN( 291)								if (_hx_tmp130) {
HXLINE( 291)									Float u14 = (((au15 * ratioA14) + (bu15 * ratioB14)) + (au * ratioC14));
HXDLIN( 291)									Float v65 = (((av15 * ratioA14) + (bv14 * ratioB14)) + (cv * ratioC14));
HXDLIN( 291)									int x60 = ::Std_obj::_hx_int(((u14 * win->width) + win->x));
HXDLIN( 291)									int y60 = ::Std_obj::_hx_int(((v65 * win->height) + win->y));
HXDLIN( 291)									::Dynamic this499 = texture->image;
HXDLIN( 291)									int index88;
HXDLIN( 291)									if (texture->useVirtualPos) {
HXLINE( 291)										index88 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - texture->virtualY) * ( (Float)(texture->width) )) + x60) - texture->virtualX));
            									}
            									else {
HXLINE( 291)										index88 = ::Std_obj::_hx_int(( (Float)(((y60 * texture->width) + x60)) ));
            									}
HXDLIN( 291)									int c73 = ::iterMagic::Iimg_obj::get(this499,index88);
HXDLIN( 291)									int col29;
HXDLIN( 291)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)										col29 = ((((((c73 >> 24) & 255) << 24) | ((c73 & 255) << 16)) | (((c73 >> 8) & 255) << 8)) | ((c73 >> 16) & 255));
            									}
            									else {
HXLINE( 291)										col29 = c73;
            									}
HXDLIN( 291)									{
HXLINE( 291)										int c74 = col29;
HXDLIN( 291)										bool _hx_tmp132;
HXDLIN( 291)										if ((((c74 >> 24) & 255) < 254)) {
HXLINE( 291)											_hx_tmp132 = pixelImage->transparent;
            										}
            										else {
HXLINE( 291)											_hx_tmp132 = false;
            										}
HXDLIN( 291)										if (_hx_tmp132) {
HXLINE( 291)											int location29;
HXDLIN( 291)											if (pixelImage->useVirtualPos) {
HXLINE( 291)												location29 = ::Std_obj::_hx_int(((((( (Float)(py14) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px14) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 291)												location29 = ::Std_obj::_hx_int(( (Float)(((py14 * pixelImage->width) + px14)) ));
            											}
HXDLIN( 291)											int this500 = ::iterMagic::Iimg_obj::get(pixelImage->image,location29);
HXDLIN( 291)											int this501;
HXDLIN( 291)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)												this501 = ((((((this500 >> 24) & 255) << 24) | ((this500 & 255) << 16)) | (((this500 >> 8) & 255) << 8)) | ((this500 >> 16) & 255));
            											}
            											else {
HXLINE( 291)												this501 = this500;
            											}
HXDLIN( 291)											Float a132;
HXDLIN( 291)											int this502 = ((this501 >> 24) & 255);
HXDLIN( 291)											if ((this502 == 0)) {
HXLINE( 291)												a132 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												a132 = (( (Float)(this502) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float r129;
HXDLIN( 291)											int this503 = ((this501 >> 16) & 255);
HXDLIN( 291)											if ((this503 == 0)) {
HXLINE( 291)												r129 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												r129 = (( (Float)(this503) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float g129;
HXDLIN( 291)											int this504 = ((this501 >> 8) & 255);
HXDLIN( 291)											if ((this504 == 0)) {
HXLINE( 291)												g129 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												g129 = (( (Float)(this504) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float b133;
HXDLIN( 291)											int this505 = (this501 & 255);
HXDLIN( 291)											if ((this505 == 0)) {
HXLINE( 291)												b133 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												b133 = (( (Float)(this505) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float a230;
HXDLIN( 291)											int this506 = ((col29 >> 24) & 255);
HXDLIN( 291)											if ((this506 == 0)) {
HXLINE( 291)												a230 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												a230 = (( (Float)(this506) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float r229;
HXDLIN( 291)											int this507 = ((col29 >> 16) & 255);
HXDLIN( 291)											if ((this507 == 0)) {
HXLINE( 291)												r229 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												r229 = (( (Float)(this507) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float g229;
HXDLIN( 291)											int this508 = ((col29 >> 8) & 255);
HXDLIN( 291)											if ((this508 == 0)) {
HXLINE( 291)												g229 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												g229 = (( (Float)(this508) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float b233;
HXDLIN( 291)											int this509 = (col29 & 255);
HXDLIN( 291)											if ((this509 == 0)) {
HXLINE( 291)												b233 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												b233 = (( (Float)(this509) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float a329 = (a132 * (( (Float)(1) ) - a230));
HXDLIN( 291)											int r49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r129 * a329) + (r229 * a230))));
HXDLIN( 291)											int g49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g129 * a329) + (g229 * a230))));
HXDLIN( 291)											int b86 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b133 * a329) + (b233 * a230))));
HXDLIN( 291)											int a70 = ::Std_obj::_hx_int((( (Float)(255) ) * (a329 + a230)));
HXDLIN( 291)											int blended29 = ((((a70 << 24) | (r49 << 16)) | (g49 << 8)) | b86);
HXDLIN( 291)											{
HXLINE( 291)												int _hx_tmp133;
HXDLIN( 291)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)													_hx_tmp133 = ((((((blended29 >> 24) & 255) << 24) | ((blended29 & 255) << 16)) | (((blended29 >> 8) & 255) << 8)) | ((blended29 >> 16) & 255));
            												}
            												else {
HXLINE( 291)													_hx_tmp133 = blended29;
            												}
HXDLIN( 291)												::iterMagic::Iimg_obj::set(pixelImage->image,location29,_hx_tmp133);
            											}
            										}
            										else {
HXLINE( 291)											::Dynamic this510 = pixelImage->image;
HXDLIN( 291)											int index89;
HXDLIN( 291)											if (pixelImage->useVirtualPos) {
HXLINE( 291)												index89 = ::Std_obj::_hx_int(((((( (Float)(py14) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px14) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 291)												index89 = ::Std_obj::_hx_int(( (Float)(((py14 * pixelImage->width) + px14)) ));
            											}
HXDLIN( 291)											int _hx_tmp134;
HXDLIN( 291)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)												_hx_tmp134 = ((((((c74 >> 24) & 255) << 24) | ((c74 & 255) << 16)) | (((c74 >> 8) & 255) << 8)) | ((c74 >> 16) & 255));
            											}
            											else {
HXLINE( 291)												_hx_tmp134 = c74;
            											}
HXDLIN( 291)											::iterMagic::Iimg_obj::set(this510,index89,_hx_tmp134);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 291)				if ((hasHit == false)) {
HXLINE( 291)					 ::pi_xy::algo::HitTri v66 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,bottomY,rightX,bottomY,leftX,dy16,true);
HXDLIN( 291)					if (hasUndo14) {
HXLINE( 291)						v66->undoImage = undoImage42;
HXDLIN( 291)						v66->undoX = xIter314->start;
HXDLIN( 291)						v66->undoY = yIter314->start;
            					}
            				}
            			}
HXDLIN( 291)			{
HXLINE( 291)				Float au16 = bu;
HXDLIN( 291)				Float av16 = av;
HXDLIN( 291)				Float bu16 = bu;
HXDLIN( 291)				Float bv15 = cv;
HXDLIN( 291)				bool hasUndo15 = false;
HXDLIN( 291)				Float temp15 = au16;
HXLINE( 422)				au16 = bu16;
HXLINE( 423)				bu16 = temp15;
HXLINE( 424)				temp15 = av16;
HXLINE( 425)				av16 = bv15;
HXLINE( 426)				bv15 = temp15;
HXLINE( 291)				Float bcx15 = (rightX - leftX);
HXDLIN( 291)				Float bcy15 = (cy5 - dy16);
HXDLIN( 291)				Float acx15 = (rightX - leftX);
HXDLIN( 291)				Float acy15 = (bottomY - dy16);
HXDLIN( 291)				Float dot1115 = ((bcx15 * bcx15) + (bcy15 * bcy15));
HXDLIN( 291)				Float dot1215 = ((bcx15 * acx15) + (bcy15 * acy15));
HXDLIN( 291)				Float dot2215 = ((acx15 * acx15) + (acy15 * acy15));
HXDLIN( 291)				Float denom115 = (( (Float)(1) ) / ((dot1115 * dot2215) - (dot1215 * dot1215)));
HXDLIN( 291)				 ::pi_xy::iter::IntIterStart xIter315;
HXDLIN( 291)				if ((rightX > rightX)) {
HXLINE( 291)					if ((rightX > leftX)) {
HXLINE( 291)						int min60;
HXDLIN( 291)						if ((rightX > leftX)) {
HXLINE( 291)							min60 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 291)							min60 = ::Math_obj::floor(rightX);
            						}
HXDLIN( 291)						int ii_min120 = min60;
HXDLIN( 291)						int ii_max120 = ::Math_obj::ceil(rightX);
HXDLIN( 291)						xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min120,ii_max120);
            					}
            					else {
HXLINE( 291)						int ii_min121 = ::Math_obj::floor(rightX);
HXDLIN( 291)						int ii_max121 = ::Math_obj::ceil(leftX);
HXDLIN( 291)						xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min121,ii_max121);
            					}
            				}
            				else {
HXLINE( 291)					if ((rightX > leftX)) {
HXLINE( 291)						int min61;
HXDLIN( 291)						if ((rightX > leftX)) {
HXLINE( 291)							min61 = ::Math_obj::floor(leftX);
            						}
            						else {
HXLINE( 291)							min61 = ::Math_obj::ceil(rightX);
            						}
HXDLIN( 291)						int ii_min122 = min61;
HXDLIN( 291)						int ii_max122 = ::Math_obj::ceil(rightX);
HXDLIN( 291)						xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min122,ii_max122);
            					}
            					else {
HXLINE( 291)						int ii_min123 = ::Math_obj::floor(rightX);
HXDLIN( 291)						int ii_max123 = ::Math_obj::ceil(leftX);
HXDLIN( 291)						xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min123,ii_max123);
            					}
            				}
HXDLIN( 291)				 ::pi_xy::iter::IntIterStart yIter315;
HXDLIN( 291)				if ((bottomY > cy5)) {
HXLINE( 291)					if ((bottomY > dy16)) {
HXLINE( 291)						int min62;
HXDLIN( 291)						if ((cy5 > dy16)) {
HXLINE( 291)							min62 = ::Math_obj::floor(dy16);
            						}
            						else {
HXLINE( 291)							min62 = ::Math_obj::floor(cy5);
            						}
HXDLIN( 291)						int ii_min124 = min62;
HXDLIN( 291)						int ii_max124 = ::Math_obj::ceil(bottomY);
HXDLIN( 291)						yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min124,ii_max124);
            					}
            					else {
HXLINE( 291)						int ii_min125 = ::Math_obj::floor(cy5);
HXDLIN( 291)						int ii_max125 = ::Math_obj::ceil(dy16);
HXDLIN( 291)						yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min125,ii_max125);
            					}
            				}
            				else {
HXLINE( 291)					if ((cy5 > dy16)) {
HXLINE( 291)						int min63;
HXDLIN( 291)						if ((bottomY > dy16)) {
HXLINE( 291)							min63 = ::Math_obj::floor(dy16);
            						}
            						else {
HXLINE( 291)							min63 = ::Math_obj::ceil(bottomY);
            						}
HXDLIN( 291)						int ii_min126 = min63;
HXDLIN( 291)						int ii_max126 = ::Math_obj::ceil(cy5);
HXDLIN( 291)						yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min126,ii_max126);
            					}
            					else {
HXLINE( 291)						int ii_min127 = ::Math_obj::floor(bottomY);
HXDLIN( 291)						int ii_max127 = ::Math_obj::ceil(dy16);
HXDLIN( 291)						yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min127,ii_max127);
            					}
            				}
HXDLIN( 291)				 ::pi_xy::ImageStruct undoImage45 = null();
HXDLIN( 291)				if (hasUndo15) {
HXLINE( 291)					int width15 = ((xIter315->max - xIter315->start) + 1);
HXDLIN( 291)					int height15 = ((yIter315->max - yIter315->start) + 1);
HXDLIN( 291)					 ::Dynamic imageType15 = null();
HXDLIN( 291)					 ::pi_xy::ImageStruct this511 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 291)					if (::hx::IsNull( imageType15 )) {
HXLINE(  54)						imageType15 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 291)					::Dynamic undoImage46;
HXDLIN( 291)					switch((int)(( (int)(imageType15) ))){
            						case (int)0: {
HXLINE( 291)							 ::iterMagic::BytesImg byt15 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::BytesImg b87 = byt15;
HXDLIN( 291)							{
HXLINE( 291)								b87->width = width15;
HXDLIN( 291)								b87->height = height15;
HXDLIN( 291)								b87->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 291)								b87->data = ::haxe::io::Bytes_obj::alloc((b87->length * 4));
HXDLIN( 291)								{
HXLINE( 291)									int len30 = b87->length;
HXDLIN( 291)									int w15 = 0;
HXDLIN( 291)									{
HXLINE( 291)										int _g300 = 0;
HXDLIN( 291)										int _g301 = b87->height;
HXDLIN( 291)										while((_g300 < _g301)){
HXLINE( 291)											_g300 = (_g300 + 1);
HXDLIN( 291)											int y61 = (_g300 - 1);
HXDLIN( 291)											{
HXLINE( 291)												int _g302 = 0;
HXDLIN( 291)												int _g303 = b87->width;
HXDLIN( 291)												while((_g302 < _g303)){
HXLINE( 291)													_g302 = (_g302 + 1);
HXDLIN( 291)													int x61 = (_g302 - 1);
HXDLIN( 291)													{
HXLINE( 291)														w15 = (w15 + 1);
HXDLIN( 291)														b87->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 291)													{
HXLINE( 291)														w15 = (w15 + 1);
HXDLIN( 291)														b87->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 291)													{
HXLINE( 291)														w15 = (w15 + 1);
HXDLIN( 291)														b87->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 291)													{
HXLINE( 291)														w15 = (w15 + 1);
HXDLIN( 291)														b87->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 291)							undoImage46 = b87;
            						}
            						break;
            						case (int)1: {
HXLINE( 291)							 ::iterMagic::ArrIntImg arrI15 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::ArrIntImg a71 = arrI15;
HXDLIN( 291)							{
HXLINE( 291)								a71->width = width15;
HXDLIN( 291)								a71->height = height15;
HXDLIN( 291)								a71->data = ::Array_obj< int >::__new(0);
HXDLIN( 291)								a71->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 291)								{
HXLINE( 291)									int _g304 = 0;
HXDLIN( 291)									int _g305 = a71->length;
HXDLIN( 291)									while((_g304 < _g305)){
HXLINE( 291)										_g304 = (_g304 + 1);
HXDLIN( 291)										int i90 = (_g304 - 1);
HXDLIN( 291)										a71->data[i90] = 0;
            									}
            								}
            							}
HXDLIN( 291)							undoImage46 = a71;
            						}
            						break;
            						case (int)2: {
HXLINE( 291)							 ::iterMagic::U32ArrImg u32a15 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::U32ArrImg b88 = u32a15;
HXDLIN( 291)							{
HXLINE( 291)								b88->width = width15;
HXDLIN( 291)								b88->height = height15;
HXDLIN( 291)								b88->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 291)								int size15 = (b88->length * 4);
HXDLIN( 291)								b88->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size15),0,size15);
HXDLIN( 291)								{
HXLINE( 291)									int _g306 = 0;
HXDLIN( 291)									int _g307 = b88->length;
HXDLIN( 291)									while((_g306 < _g307)){
HXLINE( 291)										_g306 = (_g306 + 1);
HXDLIN( 291)										int i91 = (_g306 - 1);
HXDLIN( 291)										{
HXLINE( 291)											 ::haxe::io::ArrayBufferViewImpl this512 = b88->data;
HXDLIN( 291)											bool undoImage47;
HXDLIN( 291)											if ((i91 >= 0)) {
HXLINE( 291)												undoImage47 = (i91 < (this512->byteLength >> 2));
            											}
            											else {
HXLINE( 291)												undoImage47 = false;
            											}
HXDLIN( 291)											if (undoImage47) {
HXLINE( 291)												 ::haxe::io::Bytes _this15 = this512->bytes;
HXDLIN( 291)												int pos15 = ((i91 << 2) + this512->byteOffset);
HXDLIN( 291)												_this15->b[pos15] = ( (unsigned char)(0) );
HXDLIN( 291)												_this15->b[(pos15 + 1)] = ( (unsigned char)(0) );
HXDLIN( 291)												_this15->b[(pos15 + 2)] = ( (unsigned char)(0) );
HXDLIN( 291)												_this15->b[(pos15 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 291)							undoImage46 = b88;
            						}
            						break;
            						case (int)3: {
HXLINE( 291)							 ::iterMagic::VecIntImg vec15 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::VecIntImg v67 = vec15;
HXDLIN( 291)							{
HXLINE( 291)								v67->width = width15;
HXDLIN( 291)								v67->height = height15;
HXDLIN( 291)								v67->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 291)								v67->data = ::Array_obj< int >::__new(v67->length);
HXDLIN( 291)								{
HXLINE( 291)									int _g308 = 0;
HXDLIN( 291)									int _g309 = v67->length;
HXDLIN( 291)									while((_g308 < _g309)){
HXLINE( 291)										_g308 = (_g308 + 1);
HXDLIN( 291)										int i92 = (_g308 - 1);
HXDLIN( 291)										v67->data->__unsafe_set(i92,0);
            									}
            								}
            							}
HXDLIN( 291)							undoImage46 = v67;
            						}
            						break;
            						case (int)4: {
HXLINE( 291)							 ::iterMagic::StackIntImg sInt15 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 291)							 ::iterMagic::StackIntImg b89 = sInt15;
HXDLIN( 291)							{
HXLINE( 291)								b89->width = width15;
HXDLIN( 291)								b89->height = height15;
HXDLIN( 291)								b89->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN( 291)								b89->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 291)								{
HXLINE( 291)									int len31 = b89->length;
HXDLIN( 291)									 ::haxe::ds::GenericStack_Int d15 = b89->data;
HXDLIN( 291)									if (::hx::IsNull( d15->head )) {
HXLINE( 291)										int _g310 = 0;
HXDLIN( 291)										int _g311 = len31;
HXDLIN( 291)										while((_g310 < _g311)){
HXLINE( 291)											_g310 = (_g310 + 1);
HXDLIN( 291)											int i93 = (_g310 - 1);
HXDLIN( 291)											d15->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d15->head);
            										}
            									}
            									else {
HXLINE( 291)										int _g312 = 0;
HXDLIN( 291)										int _g313 = len31;
HXDLIN( 291)										while((_g312 < _g313)){
HXLINE( 291)											_g312 = (_g312 + 1);
HXDLIN( 291)											int i94 = (_g312 - 1);
HXDLIN( 291)											{
HXLINE( 291)												 ::haxe::ds::GenericCell_Int l15 = b89->data->head;
HXDLIN( 291)												 ::haxe::ds::GenericCell_Int prev15 = null();
HXDLIN( 291)												{
HXLINE( 291)													int _g314 = 0;
HXDLIN( 291)													int _g315 = i94;
HXDLIN( 291)													while((_g314 < _g315)){
HXLINE( 291)														_g314 = (_g314 + 1);
HXDLIN( 291)														int i95 = (_g314 - 1);
HXLINE( 345)														prev15 = l15;
HXLINE( 346)														l15 = l15->next;
            													}
            												}
HXLINE( 291)												if (::hx::IsNull( prev15 )) {
HXLINE( 291)													b89->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l15->next);
HXDLIN( 291)													l15 = null();
            												}
            												else {
HXLINE( 291)													prev15->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l15->next);
HXDLIN( 291)													l15 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 291)							undoImage46 = b89;
            						}
            						break;
            					}
HXDLIN( 291)					this511->image = undoImage46;
HXDLIN( 291)					this511->width = width15;
HXDLIN( 291)					this511->height = height15;
HXDLIN( 291)					this511->imageType = ( (int)(imageType15) );
HXDLIN( 291)					undoImage45 = this511;
HXDLIN( 291)					{
HXLINE( 291)						int rectLeft15 = xIter315->start;
HXDLIN( 291)						int rectTop15 = yIter315->start;
HXDLIN( 291)						int rectRight15 = xIter315->max;
HXDLIN( 291)						bool forceClear15 = false;
HXDLIN( 291)						{
HXLINE( 291)							int _g316 = rectTop15;
HXDLIN( 291)							int _g317 = yIter315->max;
HXDLIN( 291)							while((_g316 < _g317)){
HXLINE( 291)								_g316 = (_g316 + 1);
HXDLIN( 291)								int dy18 = (_g316 - 1);
HXDLIN( 291)								{
HXLINE( 291)									int _g318 = rectLeft15;
HXDLIN( 291)									int _g319 = rectRight15;
HXDLIN( 291)									while((_g318 < _g319)){
HXLINE( 291)										_g318 = (_g318 + 1);
HXDLIN( 291)										int dx16 = (_g318 - 1);
HXDLIN( 291)										::Dynamic this513 = pixelImage->image;
HXDLIN( 291)										int index90;
HXDLIN( 291)										if (pixelImage->useVirtualPos) {
HXLINE( 291)											index90 = ::Std_obj::_hx_int(((((( (Float)(dy18) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx16) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 291)											index90 = ::Std_obj::_hx_int(( (Float)(((dy18 * pixelImage->width) + dx16)) ));
            										}
HXDLIN( 291)										int c75 = ::iterMagic::Iimg_obj::get(this513,index90);
HXDLIN( 291)										int col30;
HXDLIN( 291)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)											col30 = ((((((c75 >> 24) & 255) << 24) | ((c75 & 255) << 16)) | (((c75 >> 8) & 255) << 8)) | ((c75 >> 16) & 255));
            										}
            										else {
HXLINE( 291)											col30 = c75;
            										}
HXDLIN( 291)										bool _hx_tmp135;
HXDLIN( 291)										if (pixelImage->useMask) {
HXLINE( 291)											_hx_tmp135 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 291)											_hx_tmp135 = false;
            										}
HXDLIN( 291)										if (_hx_tmp135) {
HXLINE( 291)											 ::pi_xy::ImageStruct this514 = pixelImage->mask;
HXDLIN( 291)											::Dynamic this515 = this514->image;
HXDLIN( 291)											int index91;
HXDLIN( 291)											if (this514->useVirtualPos) {
HXLINE( 291)												index91 = ::Std_obj::_hx_int(((((( (Float)(dy18) ) - this514->virtualY) * ( (Float)(this514->width) )) + dx16) - this514->virtualX));
            											}
            											else {
HXLINE( 291)												index91 = ::Std_obj::_hx_int(( (Float)(((dy18 * this514->width) + dx16)) ));
            											}
HXDLIN( 291)											int c76 = ::iterMagic::Iimg_obj::get(this515,index91);
HXDLIN( 291)											int v68;
HXDLIN( 291)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)												v68 = ((((((c76 >> 24) & 255) << 24) | ((c76 & 255) << 16)) | (((c76 >> 8) & 255) << 8)) | ((c76 >> 16) & 255));
            											}
            											else {
HXLINE( 291)												v68 = c76;
            											}
HXDLIN( 291)											int maskPixel15 = v68;
HXDLIN( 291)											int this516 = col30;
HXDLIN( 291)											if ((maskPixel15 == 0)) {
HXLINE( 291)												col30 = this516;
            											}
            											else {
HXLINE( 291)												Float m015;
HXDLIN( 291)												int this517 = ((maskPixel15 >> 24) & 255);
HXDLIN( 291)												if ((this517 == 0)) {
HXLINE( 291)													m015 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													m015 = (( (Float)(this517) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float m115;
HXDLIN( 291)												int this518 = ((maskPixel15 >> 16) & 255);
HXDLIN( 291)												if ((this518 == 0)) {
HXLINE( 291)													m115 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													m115 = (( (Float)(this518) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float m215;
HXDLIN( 291)												int this519 = ((maskPixel15 >> 8) & 255);
HXDLIN( 291)												if ((this519 == 0)) {
HXLINE( 291)													m215 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													m215 = (( (Float)(this519) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float m315;
HXDLIN( 291)												int this520 = (maskPixel15 & 255);
HXDLIN( 291)												if ((this520 == 0)) {
HXLINE( 291)													m315 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													m315 = (( (Float)(this520) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												int ch015 = ::Std_obj::_hx_int(((((Float)1.) - m015) * ( (Float)(((this516 >> 24) & 255)) )));
HXDLIN( 291)												int ch115 = ::Std_obj::_hx_int(((((Float)1.) - m115) * ( (Float)(((this516 >> 16) & 255)) )));
HXDLIN( 291)												int ch215 = ::Std_obj::_hx_int(((((Float)1.) - m215) * ( (Float)(((this516 >> 8) & 255)) )));
HXDLIN( 291)												int ch315 = ::Std_obj::_hx_int(((((Float)1.) - m315) * ( (Float)((this516 & 255)) )));
HXDLIN( 291)												col30 = ((((::Math_obj::round((( (Float)(ch015) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch115) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch215) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch315) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 291)										if ((col30 != 0)) {
HXLINE( 291)											int x62 = (dx16 - rectLeft15);
HXDLIN( 291)											int y62 = (dy18 - rectTop15);
HXDLIN( 291)											int c77 = col30;
HXDLIN( 291)											bool _hx_tmp136;
HXDLIN( 291)											if ((((c77 >> 24) & 255) < 254)) {
HXLINE( 291)												_hx_tmp136 = undoImage45->transparent;
            											}
            											else {
HXLINE( 291)												_hx_tmp136 = false;
            											}
HXDLIN( 291)											if (_hx_tmp136) {
HXLINE( 291)												int location30;
HXDLIN( 291)												if (undoImage45->useVirtualPos) {
HXLINE( 291)													location30 = ::Std_obj::_hx_int(((((( (Float)(y62) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x62) - undoImage45->virtualX));
            												}
            												else {
HXLINE( 291)													location30 = ::Std_obj::_hx_int(( (Float)(((y62 * undoImage45->width) + x62)) ));
            												}
HXDLIN( 291)												int this521 = ::iterMagic::Iimg_obj::get(undoImage45->image,location30);
HXDLIN( 291)												int this522;
HXDLIN( 291)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)													this522 = ((((((this521 >> 24) & 255) << 24) | ((this521 & 255) << 16)) | (((this521 >> 8) & 255) << 8)) | ((this521 >> 16) & 255));
            												}
            												else {
HXLINE( 291)													this522 = this521;
            												}
HXDLIN( 291)												Float a133;
HXDLIN( 291)												int this523 = ((this522 >> 24) & 255);
HXDLIN( 291)												if ((this523 == 0)) {
HXLINE( 291)													a133 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													a133 = (( (Float)(this523) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float r130;
HXDLIN( 291)												int this524 = ((this522 >> 16) & 255);
HXDLIN( 291)												if ((this524 == 0)) {
HXLINE( 291)													r130 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													r130 = (( (Float)(this524) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float g130;
HXDLIN( 291)												int this525 = ((this522 >> 8) & 255);
HXDLIN( 291)												if ((this525 == 0)) {
HXLINE( 291)													g130 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													g130 = (( (Float)(this525) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float b134;
HXDLIN( 291)												int this526 = (this522 & 255);
HXDLIN( 291)												if ((this526 == 0)) {
HXLINE( 291)													b134 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													b134 = (( (Float)(this526) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float a231;
HXDLIN( 291)												int this527 = ((col30 >> 24) & 255);
HXDLIN( 291)												if ((this527 == 0)) {
HXLINE( 291)													a231 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													a231 = (( (Float)(this527) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float r230;
HXDLIN( 291)												int this528 = ((col30 >> 16) & 255);
HXDLIN( 291)												if ((this528 == 0)) {
HXLINE( 291)													r230 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													r230 = (( (Float)(this528) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float g230;
HXDLIN( 291)												int this529 = ((col30 >> 8) & 255);
HXDLIN( 291)												if ((this529 == 0)) {
HXLINE( 291)													g230 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													g230 = (( (Float)(this529) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float b234;
HXDLIN( 291)												int this530 = (col30 & 255);
HXDLIN( 291)												if ((this530 == 0)) {
HXLINE( 291)													b234 = ((Float)0.);
            												}
            												else {
HXLINE( 291)													b234 = (( (Float)(this530) ) / ( (Float)(255) ));
            												}
HXDLIN( 291)												Float a330 = (a133 * (( (Float)(1) ) - a231));
HXDLIN( 291)												int r50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r130 * a330) + (r230 * a231))));
HXDLIN( 291)												int g50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g130 * a330) + (g230 * a231))));
HXDLIN( 291)												int b90 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b134 * a330) + (b234 * a231))));
HXDLIN( 291)												int a72 = ::Std_obj::_hx_int((( (Float)(255) ) * (a330 + a231)));
HXDLIN( 291)												int blended30 = ((((a72 << 24) | (r50 << 16)) | (g50 << 8)) | b90);
HXDLIN( 291)												{
HXLINE( 291)													int _hx_tmp137;
HXDLIN( 291)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)														_hx_tmp137 = ((((((blended30 >> 24) & 255) << 24) | ((blended30 & 255) << 16)) | (((blended30 >> 8) & 255) << 8)) | ((blended30 >> 16) & 255));
            													}
            													else {
HXLINE( 291)														_hx_tmp137 = blended30;
            													}
HXDLIN( 291)													::iterMagic::Iimg_obj::set(undoImage45->image,location30,_hx_tmp137);
            												}
            											}
            											else {
HXLINE( 291)												::Dynamic this531 = undoImage45->image;
HXDLIN( 291)												int index92;
HXDLIN( 291)												if (undoImage45->useVirtualPos) {
HXLINE( 291)													index92 = ::Std_obj::_hx_int(((((( (Float)(y62) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x62) - undoImage45->virtualX));
            												}
            												else {
HXLINE( 291)													index92 = ::Std_obj::_hx_int(( (Float)(((y62 * undoImage45->width) + x62)) ));
            												}
HXDLIN( 291)												int _hx_tmp138;
HXDLIN( 291)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)													_hx_tmp138 = ((((((c77 >> 24) & 255) << 24) | ((c77 & 255) << 16)) | (((c77 >> 8) & 255) << 8)) | ((c77 >> 16) & 255));
            												}
            												else {
HXLINE( 291)													_hx_tmp138 = c77;
            												}
HXDLIN( 291)												::iterMagic::Iimg_obj::set(this531,index92,_hx_tmp138);
            											}
            										}
            										else {
HXLINE( 291)											if (forceClear15) {
HXLINE( 291)												::Dynamic this532 = undoImage45->image;
HXDLIN( 291)												int x63 = (dx16 - rectLeft15);
HXDLIN( 291)												int y63 = (dy18 - rectTop15);
HXDLIN( 291)												int index93;
HXDLIN( 291)												if (undoImage45->useVirtualPos) {
HXLINE( 291)													index93 = ::Std_obj::_hx_int(((((( (Float)(y63) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x63) - undoImage45->virtualX));
            												}
            												else {
HXLINE( 291)													index93 = ::Std_obj::_hx_int(( (Float)(((y63 * undoImage45->width) + x63)) ));
            												}
HXDLIN( 291)												::iterMagic::Iimg_obj::set(this532,index93,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 291)				{
HXLINE( 291)					int _g_min30 = xIter315->start;
HXDLIN( 291)					int _g_max30 = xIter315->max;
HXDLIN( 291)					while((_g_min30 < _g_max30)){
HXLINE( 291)						_g_min30 = (_g_min30 + 1);
HXDLIN( 291)						int px15 = (_g_min30 - 1);
HXDLIN( 291)						Float pcx15 = (( (Float)(px15) ) - leftX);
HXDLIN( 291)						{
HXLINE( 291)							int _g_min31 = yIter315->start;
HXDLIN( 291)							int _g_max31 = yIter315->max;
HXDLIN( 291)							while((_g_min31 < _g_max31)){
HXLINE( 291)								_g_min31 = (_g_min31 + 1);
HXDLIN( 291)								int py15 = (_g_min31 - 1);
HXDLIN( 291)								Float pcy15 = (( (Float)(py15) ) - dy16);
HXDLIN( 291)								Float dot3115 = ((pcx15 * bcx15) + (pcy15 * bcy15));
HXDLIN( 291)								Float dot3215 = ((pcx15 * acx15) + (pcy15 * acy15));
HXDLIN( 291)								Float ratioA15 = (((dot2215 * dot3115) - (dot1215 * dot3215)) * denom115);
HXDLIN( 291)								Float ratioB15 = (((dot1115 * dot3215) - (dot1215 * dot3115)) * denom115);
HXDLIN( 291)								Float ratioC15 = ((((Float)1.0) - ratioB15) - ratioA15);
HXDLIN( 291)								bool _hx_tmp139;
HXDLIN( 291)								bool _hx_tmp140;
HXDLIN( 291)								if ((ratioA15 >= 0)) {
HXLINE( 291)									_hx_tmp140 = (ratioB15 >= 0);
            								}
            								else {
HXLINE( 291)									_hx_tmp140 = false;
            								}
HXDLIN( 291)								if (_hx_tmp140) {
HXLINE( 291)									_hx_tmp139 = (ratioC15 >= 0);
            								}
            								else {
HXLINE( 291)									_hx_tmp139 = false;
            								}
HXDLIN( 291)								if (_hx_tmp139) {
HXLINE( 291)									Float u15 = (((au16 * ratioA15) + (bu16 * ratioB15)) + (au * ratioC15));
HXDLIN( 291)									Float v69 = (((av16 * ratioA15) + (bv15 * ratioB15)) + (cv * ratioC15));
HXDLIN( 291)									int x64 = ::Std_obj::_hx_int(((u15 * win->width) + win->x));
HXDLIN( 291)									int y64 = ::Std_obj::_hx_int(((v69 * win->height) + win->y));
HXDLIN( 291)									::Dynamic this533 = texture->image;
HXDLIN( 291)									int index94;
HXDLIN( 291)									if (texture->useVirtualPos) {
HXLINE( 291)										index94 = ::Std_obj::_hx_int(((((( (Float)(y64) ) - texture->virtualY) * ( (Float)(texture->width) )) + x64) - texture->virtualX));
            									}
            									else {
HXLINE( 291)										index94 = ::Std_obj::_hx_int(( (Float)(((y64 * texture->width) + x64)) ));
            									}
HXDLIN( 291)									int c78 = ::iterMagic::Iimg_obj::get(this533,index94);
HXDLIN( 291)									int col31;
HXDLIN( 291)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)										col31 = ((((((c78 >> 24) & 255) << 24) | ((c78 & 255) << 16)) | (((c78 >> 8) & 255) << 8)) | ((c78 >> 16) & 255));
            									}
            									else {
HXLINE( 291)										col31 = c78;
            									}
HXDLIN( 291)									{
HXLINE( 291)										int c79 = col31;
HXDLIN( 291)										bool _hx_tmp141;
HXDLIN( 291)										if ((((c79 >> 24) & 255) < 254)) {
HXLINE( 291)											_hx_tmp141 = pixelImage->transparent;
            										}
            										else {
HXLINE( 291)											_hx_tmp141 = false;
            										}
HXDLIN( 291)										if (_hx_tmp141) {
HXLINE( 291)											int location31;
HXDLIN( 291)											if (pixelImage->useVirtualPos) {
HXLINE( 291)												location31 = ::Std_obj::_hx_int(((((( (Float)(py15) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px15) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 291)												location31 = ::Std_obj::_hx_int(( (Float)(((py15 * pixelImage->width) + px15)) ));
            											}
HXDLIN( 291)											int this534 = ::iterMagic::Iimg_obj::get(pixelImage->image,location31);
HXDLIN( 291)											int this535;
HXDLIN( 291)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)												this535 = ((((((this534 >> 24) & 255) << 24) | ((this534 & 255) << 16)) | (((this534 >> 8) & 255) << 8)) | ((this534 >> 16) & 255));
            											}
            											else {
HXLINE( 291)												this535 = this534;
            											}
HXDLIN( 291)											Float a134;
HXDLIN( 291)											int this536 = ((this535 >> 24) & 255);
HXDLIN( 291)											if ((this536 == 0)) {
HXLINE( 291)												a134 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												a134 = (( (Float)(this536) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float r131;
HXDLIN( 291)											int this537 = ((this535 >> 16) & 255);
HXDLIN( 291)											if ((this537 == 0)) {
HXLINE( 291)												r131 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												r131 = (( (Float)(this537) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float g131;
HXDLIN( 291)											int this538 = ((this535 >> 8) & 255);
HXDLIN( 291)											if ((this538 == 0)) {
HXLINE( 291)												g131 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												g131 = (( (Float)(this538) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float b135;
HXDLIN( 291)											int this539 = (this535 & 255);
HXDLIN( 291)											if ((this539 == 0)) {
HXLINE( 291)												b135 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												b135 = (( (Float)(this539) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float a232;
HXDLIN( 291)											int this540 = ((col31 >> 24) & 255);
HXDLIN( 291)											if ((this540 == 0)) {
HXLINE( 291)												a232 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												a232 = (( (Float)(this540) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float r231;
HXDLIN( 291)											int this541 = ((col31 >> 16) & 255);
HXDLIN( 291)											if ((this541 == 0)) {
HXLINE( 291)												r231 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												r231 = (( (Float)(this541) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float g231;
HXDLIN( 291)											int this542 = ((col31 >> 8) & 255);
HXDLIN( 291)											if ((this542 == 0)) {
HXLINE( 291)												g231 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												g231 = (( (Float)(this542) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float b235;
HXDLIN( 291)											int this543 = (col31 & 255);
HXDLIN( 291)											if ((this543 == 0)) {
HXLINE( 291)												b235 = ((Float)0.);
            											}
            											else {
HXLINE( 291)												b235 = (( (Float)(this543) ) / ( (Float)(255) ));
            											}
HXDLIN( 291)											Float a331 = (a134 * (( (Float)(1) ) - a232));
HXDLIN( 291)											int r51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r131 * a331) + (r231 * a232))));
HXDLIN( 291)											int g51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g131 * a331) + (g231 * a232))));
HXDLIN( 291)											int b91 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b135 * a331) + (b235 * a232))));
HXDLIN( 291)											int a73 = ::Std_obj::_hx_int((( (Float)(255) ) * (a331 + a232)));
HXDLIN( 291)											int blended31 = ((((a73 << 24) | (r51 << 16)) | (g51 << 8)) | b91);
HXDLIN( 291)											{
HXLINE( 291)												int _hx_tmp142;
HXDLIN( 291)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)													_hx_tmp142 = ((((((blended31 >> 24) & 255) << 24) | ((blended31 & 255) << 16)) | (((blended31 >> 8) & 255) << 8)) | ((blended31 >> 16) & 255));
            												}
            												else {
HXLINE( 291)													_hx_tmp142 = blended31;
            												}
HXDLIN( 291)												::iterMagic::Iimg_obj::set(pixelImage->image,location31,_hx_tmp142);
            											}
            										}
            										else {
HXLINE( 291)											::Dynamic this544 = pixelImage->image;
HXDLIN( 291)											int index95;
HXDLIN( 291)											if (pixelImage->useVirtualPos) {
HXLINE( 291)												index95 = ::Std_obj::_hx_int(((((( (Float)(py15) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px15) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 291)												index95 = ::Std_obj::_hx_int(( (Float)(((py15 * pixelImage->width) + px15)) ));
            											}
HXDLIN( 291)											int _hx_tmp143;
HXDLIN( 291)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 291)												_hx_tmp143 = ((((((c79 >> 24) & 255) << 24) | ((c79 & 255) << 16)) | (((c79 >> 8) & 255) << 8)) | ((c79 >> 16) & 255));
            											}
            											else {
HXLINE( 291)												_hx_tmp143 = c79;
            											}
HXDLIN( 291)											::iterMagic::Iimg_obj::set(this544,index95,_hx_tmp143);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 291)				if ((hasHit == false)) {
HXLINE( 291)					 ::pi_xy::algo::HitTri v70 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,bottomY,rightX,cy5,leftX,dy16,true);
HXDLIN( 291)					if (hasUndo15) {
HXLINE( 291)						v70->undoImage = undoImage45;
HXDLIN( 291)						v70->undoX = xIter315->start;
HXDLIN( 291)						v70->undoY = yIter315->start;
            					}
            				}
            			}
HXDLIN( 291)			if ((hasHit == true)) {
HXLINE( 291)				 ::pi_xy::algo::HitQuad v71 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,leftX,bottomY,rightX,bottomY,rightX,cy5,leftX,dy16,true);
            			}
            		}
HXLINE( 296)		au = bu;
HXLINE( 297)		bu = ((Float)1.);
HXLINE( 298)		{
HXLINE( 298)			Float bx3 = (x + widNew);
HXDLIN( 298)			Float cx3 = (x + widNew);
HXDLIN( 298)			Float cy6 = (y + hiNew);
HXDLIN( 298)			Float dy19 = (y + hiNew);
HXDLIN( 298)			{
HXLINE( 298)				Float au17 = au;
HXDLIN( 298)				Float av17 = av;
HXDLIN( 298)				Float bu17 = bu;
HXDLIN( 298)				Float bv16 = av;
HXDLIN( 298)				bool hasUndo16 = false;
HXDLIN( 298)				Float temp16 = au17;
HXLINE( 422)				au17 = bu17;
HXLINE( 423)				bu17 = temp16;
HXLINE( 424)				temp16 = av17;
HXLINE( 425)				av17 = bv16;
HXLINE( 426)				bv16 = temp16;
HXLINE( 298)				Float bcx16 = (bx3 - rightX);
HXDLIN( 298)				Float bcy16 = (bottomY - dy19);
HXDLIN( 298)				Float acx16 = (rightX - rightX);
HXDLIN( 298)				Float acy16 = (bottomY - dy19);
HXDLIN( 298)				Float dot1116 = ((bcx16 * bcx16) + (bcy16 * bcy16));
HXDLIN( 298)				Float dot1216 = ((bcx16 * acx16) + (bcy16 * acy16));
HXDLIN( 298)				Float dot2216 = ((acx16 * acx16) + (acy16 * acy16));
HXDLIN( 298)				Float denom116 = (( (Float)(1) ) / ((dot1116 * dot2216) - (dot1216 * dot1216)));
HXDLIN( 298)				 ::pi_xy::iter::IntIterStart xIter316;
HXDLIN( 298)				if ((rightX > bx3)) {
HXLINE( 298)					if ((rightX > rightX)) {
HXLINE( 298)						int min64;
HXDLIN( 298)						if ((bx3 > rightX)) {
HXLINE( 298)							min64 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 298)							min64 = ::Math_obj::floor(bx3);
            						}
HXDLIN( 298)						int ii_min128 = min64;
HXDLIN( 298)						int ii_max128 = ::Math_obj::ceil(rightX);
HXDLIN( 298)						xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min128,ii_max128);
            					}
            					else {
HXLINE( 298)						int ii_min129 = ::Math_obj::floor(bx3);
HXDLIN( 298)						int ii_max129 = ::Math_obj::ceil(rightX);
HXDLIN( 298)						xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min129,ii_max129);
            					}
            				}
            				else {
HXLINE( 298)					if ((bx3 > rightX)) {
HXLINE( 298)						int min65;
HXDLIN( 298)						if ((rightX > rightX)) {
HXLINE( 298)							min65 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 298)							min65 = ::Math_obj::ceil(rightX);
            						}
HXDLIN( 298)						int ii_min130 = min65;
HXDLIN( 298)						int ii_max130 = ::Math_obj::ceil(bx3);
HXDLIN( 298)						xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min130,ii_max130);
            					}
            					else {
HXLINE( 298)						int ii_min131 = ::Math_obj::floor(rightX);
HXDLIN( 298)						int ii_max131 = ::Math_obj::ceil(rightX);
HXDLIN( 298)						xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min131,ii_max131);
            					}
            				}
HXDLIN( 298)				 ::pi_xy::iter::IntIterStart yIter316;
HXDLIN( 298)				if ((bottomY > bottomY)) {
HXLINE( 298)					if ((bottomY > dy19)) {
HXLINE( 298)						int min66;
HXDLIN( 298)						if ((bottomY > dy19)) {
HXLINE( 298)							min66 = ::Math_obj::floor(dy19);
            						}
            						else {
HXLINE( 298)							min66 = ::Math_obj::floor(bottomY);
            						}
HXDLIN( 298)						int ii_min132 = min66;
HXDLIN( 298)						int ii_max132 = ::Math_obj::ceil(bottomY);
HXDLIN( 298)						yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min132,ii_max132);
            					}
            					else {
HXLINE( 298)						int ii_min133 = ::Math_obj::floor(bottomY);
HXDLIN( 298)						int ii_max133 = ::Math_obj::ceil(dy19);
HXDLIN( 298)						yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min133,ii_max133);
            					}
            				}
            				else {
HXLINE( 298)					if ((bottomY > dy19)) {
HXLINE( 298)						int min67;
HXDLIN( 298)						if ((bottomY > dy19)) {
HXLINE( 298)							min67 = ::Math_obj::floor(dy19);
            						}
            						else {
HXLINE( 298)							min67 = ::Math_obj::ceil(bottomY);
            						}
HXDLIN( 298)						int ii_min134 = min67;
HXDLIN( 298)						int ii_max134 = ::Math_obj::ceil(bottomY);
HXDLIN( 298)						yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min134,ii_max134);
            					}
            					else {
HXLINE( 298)						int ii_min135 = ::Math_obj::floor(bottomY);
HXDLIN( 298)						int ii_max135 = ::Math_obj::ceil(dy19);
HXDLIN( 298)						yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min135,ii_max135);
            					}
            				}
HXDLIN( 298)				 ::pi_xy::ImageStruct undoImage48 = null();
HXDLIN( 298)				if (hasUndo16) {
HXLINE( 298)					int width16 = ((xIter316->max - xIter316->start) + 1);
HXDLIN( 298)					int height16 = ((yIter316->max - yIter316->start) + 1);
HXDLIN( 298)					 ::Dynamic imageType16 = null();
HXDLIN( 298)					 ::pi_xy::ImageStruct this545 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 298)					if (::hx::IsNull( imageType16 )) {
HXLINE(  54)						imageType16 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 298)					::Dynamic undoImage49;
HXDLIN( 298)					switch((int)(( (int)(imageType16) ))){
            						case (int)0: {
HXLINE( 298)							 ::iterMagic::BytesImg byt16 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::BytesImg b92 = byt16;
HXDLIN( 298)							{
HXLINE( 298)								b92->width = width16;
HXDLIN( 298)								b92->height = height16;
HXDLIN( 298)								b92->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 298)								b92->data = ::haxe::io::Bytes_obj::alloc((b92->length * 4));
HXDLIN( 298)								{
HXLINE( 298)									int len32 = b92->length;
HXDLIN( 298)									int w16 = 0;
HXDLIN( 298)									{
HXLINE( 298)										int _g320 = 0;
HXDLIN( 298)										int _g321 = b92->height;
HXDLIN( 298)										while((_g320 < _g321)){
HXLINE( 298)											_g320 = (_g320 + 1);
HXDLIN( 298)											int y65 = (_g320 - 1);
HXDLIN( 298)											{
HXLINE( 298)												int _g322 = 0;
HXDLIN( 298)												int _g323 = b92->width;
HXDLIN( 298)												while((_g322 < _g323)){
HXLINE( 298)													_g322 = (_g322 + 1);
HXDLIN( 298)													int x65 = (_g322 - 1);
HXDLIN( 298)													{
HXLINE( 298)														w16 = (w16 + 1);
HXDLIN( 298)														b92->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 298)													{
HXLINE( 298)														w16 = (w16 + 1);
HXDLIN( 298)														b92->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 298)													{
HXLINE( 298)														w16 = (w16 + 1);
HXDLIN( 298)														b92->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 298)													{
HXLINE( 298)														w16 = (w16 + 1);
HXDLIN( 298)														b92->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 298)							undoImage49 = b92;
            						}
            						break;
            						case (int)1: {
HXLINE( 298)							 ::iterMagic::ArrIntImg arrI16 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::ArrIntImg a74 = arrI16;
HXDLIN( 298)							{
HXLINE( 298)								a74->width = width16;
HXDLIN( 298)								a74->height = height16;
HXDLIN( 298)								a74->data = ::Array_obj< int >::__new(0);
HXDLIN( 298)								a74->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 298)								{
HXLINE( 298)									int _g324 = 0;
HXDLIN( 298)									int _g325 = a74->length;
HXDLIN( 298)									while((_g324 < _g325)){
HXLINE( 298)										_g324 = (_g324 + 1);
HXDLIN( 298)										int i96 = (_g324 - 1);
HXDLIN( 298)										a74->data[i96] = 0;
            									}
            								}
            							}
HXDLIN( 298)							undoImage49 = a74;
            						}
            						break;
            						case (int)2: {
HXLINE( 298)							 ::iterMagic::U32ArrImg u32a16 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::U32ArrImg b93 = u32a16;
HXDLIN( 298)							{
HXLINE( 298)								b93->width = width16;
HXDLIN( 298)								b93->height = height16;
HXDLIN( 298)								b93->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 298)								int size16 = (b93->length * 4);
HXDLIN( 298)								b93->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size16),0,size16);
HXDLIN( 298)								{
HXLINE( 298)									int _g326 = 0;
HXDLIN( 298)									int _g327 = b93->length;
HXDLIN( 298)									while((_g326 < _g327)){
HXLINE( 298)										_g326 = (_g326 + 1);
HXDLIN( 298)										int i97 = (_g326 - 1);
HXDLIN( 298)										{
HXLINE( 298)											 ::haxe::io::ArrayBufferViewImpl this546 = b93->data;
HXDLIN( 298)											bool undoImage50;
HXDLIN( 298)											if ((i97 >= 0)) {
HXLINE( 298)												undoImage50 = (i97 < (this546->byteLength >> 2));
            											}
            											else {
HXLINE( 298)												undoImage50 = false;
            											}
HXDLIN( 298)											if (undoImage50) {
HXLINE( 298)												 ::haxe::io::Bytes _this16 = this546->bytes;
HXDLIN( 298)												int pos16 = ((i97 << 2) + this546->byteOffset);
HXDLIN( 298)												_this16->b[pos16] = ( (unsigned char)(0) );
HXDLIN( 298)												_this16->b[(pos16 + 1)] = ( (unsigned char)(0) );
HXDLIN( 298)												_this16->b[(pos16 + 2)] = ( (unsigned char)(0) );
HXDLIN( 298)												_this16->b[(pos16 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 298)							undoImage49 = b93;
            						}
            						break;
            						case (int)3: {
HXLINE( 298)							 ::iterMagic::VecIntImg vec16 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::VecIntImg v72 = vec16;
HXDLIN( 298)							{
HXLINE( 298)								v72->width = width16;
HXDLIN( 298)								v72->height = height16;
HXDLIN( 298)								v72->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 298)								v72->data = ::Array_obj< int >::__new(v72->length);
HXDLIN( 298)								{
HXLINE( 298)									int _g328 = 0;
HXDLIN( 298)									int _g329 = v72->length;
HXDLIN( 298)									while((_g328 < _g329)){
HXLINE( 298)										_g328 = (_g328 + 1);
HXDLIN( 298)										int i98 = (_g328 - 1);
HXDLIN( 298)										v72->data->__unsafe_set(i98,0);
            									}
            								}
            							}
HXDLIN( 298)							undoImage49 = v72;
            						}
            						break;
            						case (int)4: {
HXLINE( 298)							 ::iterMagic::StackIntImg sInt16 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::StackIntImg b94 = sInt16;
HXDLIN( 298)							{
HXLINE( 298)								b94->width = width16;
HXDLIN( 298)								b94->height = height16;
HXDLIN( 298)								b94->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN( 298)								b94->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 298)								{
HXLINE( 298)									int len33 = b94->length;
HXDLIN( 298)									 ::haxe::ds::GenericStack_Int d16 = b94->data;
HXDLIN( 298)									if (::hx::IsNull( d16->head )) {
HXLINE( 298)										int _g330 = 0;
HXDLIN( 298)										int _g331 = len33;
HXDLIN( 298)										while((_g330 < _g331)){
HXLINE( 298)											_g330 = (_g330 + 1);
HXDLIN( 298)											int i99 = (_g330 - 1);
HXDLIN( 298)											d16->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d16->head);
            										}
            									}
            									else {
HXLINE( 298)										int _g332 = 0;
HXDLIN( 298)										int _g333 = len33;
HXDLIN( 298)										while((_g332 < _g333)){
HXLINE( 298)											_g332 = (_g332 + 1);
HXDLIN( 298)											int i100 = (_g332 - 1);
HXDLIN( 298)											{
HXLINE( 298)												 ::haxe::ds::GenericCell_Int l16 = b94->data->head;
HXDLIN( 298)												 ::haxe::ds::GenericCell_Int prev16 = null();
HXDLIN( 298)												{
HXLINE( 298)													int _g334 = 0;
HXDLIN( 298)													int _g335 = i100;
HXDLIN( 298)													while((_g334 < _g335)){
HXLINE( 298)														_g334 = (_g334 + 1);
HXDLIN( 298)														int i101 = (_g334 - 1);
HXLINE( 345)														prev16 = l16;
HXLINE( 346)														l16 = l16->next;
            													}
            												}
HXLINE( 298)												if (::hx::IsNull( prev16 )) {
HXLINE( 298)													b94->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l16->next);
HXDLIN( 298)													l16 = null();
            												}
            												else {
HXLINE( 298)													prev16->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l16->next);
HXDLIN( 298)													l16 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 298)							undoImage49 = b94;
            						}
            						break;
            					}
HXDLIN( 298)					this545->image = undoImage49;
HXDLIN( 298)					this545->width = width16;
HXDLIN( 298)					this545->height = height16;
HXDLIN( 298)					this545->imageType = ( (int)(imageType16) );
HXDLIN( 298)					undoImage48 = this545;
HXDLIN( 298)					{
HXLINE( 298)						int rectLeft16 = xIter316->start;
HXDLIN( 298)						int rectTop16 = yIter316->start;
HXDLIN( 298)						int rectRight16 = xIter316->max;
HXDLIN( 298)						bool forceClear16 = false;
HXDLIN( 298)						{
HXLINE( 298)							int _g336 = rectTop16;
HXDLIN( 298)							int _g337 = yIter316->max;
HXDLIN( 298)							while((_g336 < _g337)){
HXLINE( 298)								_g336 = (_g336 + 1);
HXDLIN( 298)								int dy20 = (_g336 - 1);
HXDLIN( 298)								{
HXLINE( 298)									int _g338 = rectLeft16;
HXDLIN( 298)									int _g339 = rectRight16;
HXDLIN( 298)									while((_g338 < _g339)){
HXLINE( 298)										_g338 = (_g338 + 1);
HXDLIN( 298)										int dx17 = (_g338 - 1);
HXDLIN( 298)										::Dynamic this547 = pixelImage->image;
HXDLIN( 298)										int index96;
HXDLIN( 298)										if (pixelImage->useVirtualPos) {
HXLINE( 298)											index96 = ::Std_obj::_hx_int(((((( (Float)(dy20) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx17) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 298)											index96 = ::Std_obj::_hx_int(( (Float)(((dy20 * pixelImage->width) + dx17)) ));
            										}
HXDLIN( 298)										int c80 = ::iterMagic::Iimg_obj::get(this547,index96);
HXDLIN( 298)										int col32;
HXDLIN( 298)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)											col32 = ((((((c80 >> 24) & 255) << 24) | ((c80 & 255) << 16)) | (((c80 >> 8) & 255) << 8)) | ((c80 >> 16) & 255));
            										}
            										else {
HXLINE( 298)											col32 = c80;
            										}
HXDLIN( 298)										bool _hx_tmp144;
HXDLIN( 298)										if (pixelImage->useMask) {
HXLINE( 298)											_hx_tmp144 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 298)											_hx_tmp144 = false;
            										}
HXDLIN( 298)										if (_hx_tmp144) {
HXLINE( 298)											 ::pi_xy::ImageStruct this548 = pixelImage->mask;
HXDLIN( 298)											::Dynamic this549 = this548->image;
HXDLIN( 298)											int index97;
HXDLIN( 298)											if (this548->useVirtualPos) {
HXLINE( 298)												index97 = ::Std_obj::_hx_int(((((( (Float)(dy20) ) - this548->virtualY) * ( (Float)(this548->width) )) + dx17) - this548->virtualX));
            											}
            											else {
HXLINE( 298)												index97 = ::Std_obj::_hx_int(( (Float)(((dy20 * this548->width) + dx17)) ));
            											}
HXDLIN( 298)											int c81 = ::iterMagic::Iimg_obj::get(this549,index97);
HXDLIN( 298)											int v73;
HXDLIN( 298)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)												v73 = ((((((c81 >> 24) & 255) << 24) | ((c81 & 255) << 16)) | (((c81 >> 8) & 255) << 8)) | ((c81 >> 16) & 255));
            											}
            											else {
HXLINE( 298)												v73 = c81;
            											}
HXDLIN( 298)											int maskPixel16 = v73;
HXDLIN( 298)											int this550 = col32;
HXDLIN( 298)											if ((maskPixel16 == 0)) {
HXLINE( 298)												col32 = this550;
            											}
            											else {
HXLINE( 298)												Float m016;
HXDLIN( 298)												int this551 = ((maskPixel16 >> 24) & 255);
HXDLIN( 298)												if ((this551 == 0)) {
HXLINE( 298)													m016 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													m016 = (( (Float)(this551) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float m116;
HXDLIN( 298)												int this552 = ((maskPixel16 >> 16) & 255);
HXDLIN( 298)												if ((this552 == 0)) {
HXLINE( 298)													m116 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													m116 = (( (Float)(this552) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float m216;
HXDLIN( 298)												int this553 = ((maskPixel16 >> 8) & 255);
HXDLIN( 298)												if ((this553 == 0)) {
HXLINE( 298)													m216 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													m216 = (( (Float)(this553) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float m316;
HXDLIN( 298)												int this554 = (maskPixel16 & 255);
HXDLIN( 298)												if ((this554 == 0)) {
HXLINE( 298)													m316 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													m316 = (( (Float)(this554) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												int ch016 = ::Std_obj::_hx_int(((((Float)1.) - m016) * ( (Float)(((this550 >> 24) & 255)) )));
HXDLIN( 298)												int ch116 = ::Std_obj::_hx_int(((((Float)1.) - m116) * ( (Float)(((this550 >> 16) & 255)) )));
HXDLIN( 298)												int ch216 = ::Std_obj::_hx_int(((((Float)1.) - m216) * ( (Float)(((this550 >> 8) & 255)) )));
HXDLIN( 298)												int ch316 = ::Std_obj::_hx_int(((((Float)1.) - m316) * ( (Float)((this550 & 255)) )));
HXDLIN( 298)												col32 = ((((::Math_obj::round((( (Float)(ch016) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch116) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch216) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch316) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 298)										if ((col32 != 0)) {
HXLINE( 298)											int x66 = (dx17 - rectLeft16);
HXDLIN( 298)											int y66 = (dy20 - rectTop16);
HXDLIN( 298)											int c82 = col32;
HXDLIN( 298)											bool _hx_tmp145;
HXDLIN( 298)											if ((((c82 >> 24) & 255) < 254)) {
HXLINE( 298)												_hx_tmp145 = undoImage48->transparent;
            											}
            											else {
HXLINE( 298)												_hx_tmp145 = false;
            											}
HXDLIN( 298)											if (_hx_tmp145) {
HXLINE( 298)												int location32;
HXDLIN( 298)												if (undoImage48->useVirtualPos) {
HXLINE( 298)													location32 = ::Std_obj::_hx_int(((((( (Float)(y66) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x66) - undoImage48->virtualX));
            												}
            												else {
HXLINE( 298)													location32 = ::Std_obj::_hx_int(( (Float)(((y66 * undoImage48->width) + x66)) ));
            												}
HXDLIN( 298)												int this555 = ::iterMagic::Iimg_obj::get(undoImage48->image,location32);
HXDLIN( 298)												int this556;
HXDLIN( 298)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)													this556 = ((((((this555 >> 24) & 255) << 24) | ((this555 & 255) << 16)) | (((this555 >> 8) & 255) << 8)) | ((this555 >> 16) & 255));
            												}
            												else {
HXLINE( 298)													this556 = this555;
            												}
HXDLIN( 298)												Float a135;
HXDLIN( 298)												int this557 = ((this556 >> 24) & 255);
HXDLIN( 298)												if ((this557 == 0)) {
HXLINE( 298)													a135 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													a135 = (( (Float)(this557) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float r132;
HXDLIN( 298)												int this558 = ((this556 >> 16) & 255);
HXDLIN( 298)												if ((this558 == 0)) {
HXLINE( 298)													r132 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													r132 = (( (Float)(this558) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float g132;
HXDLIN( 298)												int this559 = ((this556 >> 8) & 255);
HXDLIN( 298)												if ((this559 == 0)) {
HXLINE( 298)													g132 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													g132 = (( (Float)(this559) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float b136;
HXDLIN( 298)												int this560 = (this556 & 255);
HXDLIN( 298)												if ((this560 == 0)) {
HXLINE( 298)													b136 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													b136 = (( (Float)(this560) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float a233;
HXDLIN( 298)												int this561 = ((col32 >> 24) & 255);
HXDLIN( 298)												if ((this561 == 0)) {
HXLINE( 298)													a233 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													a233 = (( (Float)(this561) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float r232;
HXDLIN( 298)												int this562 = ((col32 >> 16) & 255);
HXDLIN( 298)												if ((this562 == 0)) {
HXLINE( 298)													r232 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													r232 = (( (Float)(this562) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float g232;
HXDLIN( 298)												int this563 = ((col32 >> 8) & 255);
HXDLIN( 298)												if ((this563 == 0)) {
HXLINE( 298)													g232 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													g232 = (( (Float)(this563) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float b236;
HXDLIN( 298)												int this564 = (col32 & 255);
HXDLIN( 298)												if ((this564 == 0)) {
HXLINE( 298)													b236 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													b236 = (( (Float)(this564) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float a332 = (a135 * (( (Float)(1) ) - a233));
HXDLIN( 298)												int r52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r132 * a332) + (r232 * a233))));
HXDLIN( 298)												int g52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g132 * a332) + (g232 * a233))));
HXDLIN( 298)												int b95 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b136 * a332) + (b236 * a233))));
HXDLIN( 298)												int a75 = ::Std_obj::_hx_int((( (Float)(255) ) * (a332 + a233)));
HXDLIN( 298)												int blended32 = ((((a75 << 24) | (r52 << 16)) | (g52 << 8)) | b95);
HXDLIN( 298)												{
HXLINE( 298)													int _hx_tmp146;
HXDLIN( 298)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)														_hx_tmp146 = ((((((blended32 >> 24) & 255) << 24) | ((blended32 & 255) << 16)) | (((blended32 >> 8) & 255) << 8)) | ((blended32 >> 16) & 255));
            													}
            													else {
HXLINE( 298)														_hx_tmp146 = blended32;
            													}
HXDLIN( 298)													::iterMagic::Iimg_obj::set(undoImage48->image,location32,_hx_tmp146);
            												}
            											}
            											else {
HXLINE( 298)												::Dynamic this565 = undoImage48->image;
HXDLIN( 298)												int index98;
HXDLIN( 298)												if (undoImage48->useVirtualPos) {
HXLINE( 298)													index98 = ::Std_obj::_hx_int(((((( (Float)(y66) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x66) - undoImage48->virtualX));
            												}
            												else {
HXLINE( 298)													index98 = ::Std_obj::_hx_int(( (Float)(((y66 * undoImage48->width) + x66)) ));
            												}
HXDLIN( 298)												int _hx_tmp147;
HXDLIN( 298)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)													_hx_tmp147 = ((((((c82 >> 24) & 255) << 24) | ((c82 & 255) << 16)) | (((c82 >> 8) & 255) << 8)) | ((c82 >> 16) & 255));
            												}
            												else {
HXLINE( 298)													_hx_tmp147 = c82;
            												}
HXDLIN( 298)												::iterMagic::Iimg_obj::set(this565,index98,_hx_tmp147);
            											}
            										}
            										else {
HXLINE( 298)											if (forceClear16) {
HXLINE( 298)												::Dynamic this566 = undoImage48->image;
HXDLIN( 298)												int x67 = (dx17 - rectLeft16);
HXDLIN( 298)												int y67 = (dy20 - rectTop16);
HXDLIN( 298)												int index99;
HXDLIN( 298)												if (undoImage48->useVirtualPos) {
HXLINE( 298)													index99 = ::Std_obj::_hx_int(((((( (Float)(y67) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x67) - undoImage48->virtualX));
            												}
            												else {
HXLINE( 298)													index99 = ::Std_obj::_hx_int(( (Float)(((y67 * undoImage48->width) + x67)) ));
            												}
HXDLIN( 298)												::iterMagic::Iimg_obj::set(this566,index99,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 298)				{
HXLINE( 298)					int _g_min32 = xIter316->start;
HXDLIN( 298)					int _g_max32 = xIter316->max;
HXDLIN( 298)					while((_g_min32 < _g_max32)){
HXLINE( 298)						_g_min32 = (_g_min32 + 1);
HXDLIN( 298)						int px16 = (_g_min32 - 1);
HXDLIN( 298)						Float pcx16 = (( (Float)(px16) ) - rightX);
HXDLIN( 298)						{
HXLINE( 298)							int _g_min33 = yIter316->start;
HXDLIN( 298)							int _g_max33 = yIter316->max;
HXDLIN( 298)							while((_g_min33 < _g_max33)){
HXLINE( 298)								_g_min33 = (_g_min33 + 1);
HXDLIN( 298)								int py16 = (_g_min33 - 1);
HXDLIN( 298)								Float pcy16 = (( (Float)(py16) ) - dy19);
HXDLIN( 298)								Float dot3116 = ((pcx16 * bcx16) + (pcy16 * bcy16));
HXDLIN( 298)								Float dot3216 = ((pcx16 * acx16) + (pcy16 * acy16));
HXDLIN( 298)								Float ratioA16 = (((dot2216 * dot3116) - (dot1216 * dot3216)) * denom116);
HXDLIN( 298)								Float ratioB16 = (((dot1116 * dot3216) - (dot1216 * dot3116)) * denom116);
HXDLIN( 298)								Float ratioC16 = ((((Float)1.0) - ratioB16) - ratioA16);
HXDLIN( 298)								bool _hx_tmp148;
HXDLIN( 298)								bool _hx_tmp149;
HXDLIN( 298)								if ((ratioA16 >= 0)) {
HXLINE( 298)									_hx_tmp149 = (ratioB16 >= 0);
            								}
            								else {
HXLINE( 298)									_hx_tmp149 = false;
            								}
HXDLIN( 298)								if (_hx_tmp149) {
HXLINE( 298)									_hx_tmp148 = (ratioC16 >= 0);
            								}
            								else {
HXLINE( 298)									_hx_tmp148 = false;
            								}
HXDLIN( 298)								if (_hx_tmp148) {
HXLINE( 298)									Float u16 = (((au17 * ratioA16) + (bu17 * ratioB16)) + (au * ratioC16));
HXDLIN( 298)									Float v74 = (((av17 * ratioA16) + (bv16 * ratioB16)) + (cv * ratioC16));
HXDLIN( 298)									int x68 = ::Std_obj::_hx_int(((u16 * win->width) + win->x));
HXDLIN( 298)									int y68 = ::Std_obj::_hx_int(((v74 * win->height) + win->y));
HXDLIN( 298)									::Dynamic this567 = texture->image;
HXDLIN( 298)									int index100;
HXDLIN( 298)									if (texture->useVirtualPos) {
HXLINE( 298)										index100 = ::Std_obj::_hx_int(((((( (Float)(y68) ) - texture->virtualY) * ( (Float)(texture->width) )) + x68) - texture->virtualX));
            									}
            									else {
HXLINE( 298)										index100 = ::Std_obj::_hx_int(( (Float)(((y68 * texture->width) + x68)) ));
            									}
HXDLIN( 298)									int c83 = ::iterMagic::Iimg_obj::get(this567,index100);
HXDLIN( 298)									int col33;
HXDLIN( 298)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)										col33 = ((((((c83 >> 24) & 255) << 24) | ((c83 & 255) << 16)) | (((c83 >> 8) & 255) << 8)) | ((c83 >> 16) & 255));
            									}
            									else {
HXLINE( 298)										col33 = c83;
            									}
HXDLIN( 298)									{
HXLINE( 298)										int c84 = col33;
HXDLIN( 298)										bool _hx_tmp150;
HXDLIN( 298)										if ((((c84 >> 24) & 255) < 254)) {
HXLINE( 298)											_hx_tmp150 = pixelImage->transparent;
            										}
            										else {
HXLINE( 298)											_hx_tmp150 = false;
            										}
HXDLIN( 298)										if (_hx_tmp150) {
HXLINE( 298)											int location33;
HXDLIN( 298)											if (pixelImage->useVirtualPos) {
HXLINE( 298)												location33 = ::Std_obj::_hx_int(((((( (Float)(py16) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px16) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 298)												location33 = ::Std_obj::_hx_int(( (Float)(((py16 * pixelImage->width) + px16)) ));
            											}
HXDLIN( 298)											int this568 = ::iterMagic::Iimg_obj::get(pixelImage->image,location33);
HXDLIN( 298)											int this569;
HXDLIN( 298)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)												this569 = ((((((this568 >> 24) & 255) << 24) | ((this568 & 255) << 16)) | (((this568 >> 8) & 255) << 8)) | ((this568 >> 16) & 255));
            											}
            											else {
HXLINE( 298)												this569 = this568;
            											}
HXDLIN( 298)											Float a136;
HXDLIN( 298)											int this570 = ((this569 >> 24) & 255);
HXDLIN( 298)											if ((this570 == 0)) {
HXLINE( 298)												a136 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												a136 = (( (Float)(this570) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float r133;
HXDLIN( 298)											int this571 = ((this569 >> 16) & 255);
HXDLIN( 298)											if ((this571 == 0)) {
HXLINE( 298)												r133 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												r133 = (( (Float)(this571) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float g133;
HXDLIN( 298)											int this572 = ((this569 >> 8) & 255);
HXDLIN( 298)											if ((this572 == 0)) {
HXLINE( 298)												g133 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												g133 = (( (Float)(this572) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float b137;
HXDLIN( 298)											int this573 = (this569 & 255);
HXDLIN( 298)											if ((this573 == 0)) {
HXLINE( 298)												b137 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												b137 = (( (Float)(this573) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float a234;
HXDLIN( 298)											int this574 = ((col33 >> 24) & 255);
HXDLIN( 298)											if ((this574 == 0)) {
HXLINE( 298)												a234 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												a234 = (( (Float)(this574) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float r233;
HXDLIN( 298)											int this575 = ((col33 >> 16) & 255);
HXDLIN( 298)											if ((this575 == 0)) {
HXLINE( 298)												r233 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												r233 = (( (Float)(this575) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float g233;
HXDLIN( 298)											int this576 = ((col33 >> 8) & 255);
HXDLIN( 298)											if ((this576 == 0)) {
HXLINE( 298)												g233 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												g233 = (( (Float)(this576) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float b237;
HXDLIN( 298)											int this577 = (col33 & 255);
HXDLIN( 298)											if ((this577 == 0)) {
HXLINE( 298)												b237 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												b237 = (( (Float)(this577) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float a333 = (a136 * (( (Float)(1) ) - a234));
HXDLIN( 298)											int r53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r133 * a333) + (r233 * a234))));
HXDLIN( 298)											int g53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g133 * a333) + (g233 * a234))));
HXDLIN( 298)											int b96 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b137 * a333) + (b237 * a234))));
HXDLIN( 298)											int a76 = ::Std_obj::_hx_int((( (Float)(255) ) * (a333 + a234)));
HXDLIN( 298)											int blended33 = ((((a76 << 24) | (r53 << 16)) | (g53 << 8)) | b96);
HXDLIN( 298)											{
HXLINE( 298)												int _hx_tmp151;
HXDLIN( 298)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)													_hx_tmp151 = ((((((blended33 >> 24) & 255) << 24) | ((blended33 & 255) << 16)) | (((blended33 >> 8) & 255) << 8)) | ((blended33 >> 16) & 255));
            												}
            												else {
HXLINE( 298)													_hx_tmp151 = blended33;
            												}
HXDLIN( 298)												::iterMagic::Iimg_obj::set(pixelImage->image,location33,_hx_tmp151);
            											}
            										}
            										else {
HXLINE( 298)											::Dynamic this578 = pixelImage->image;
HXDLIN( 298)											int index101;
HXDLIN( 298)											if (pixelImage->useVirtualPos) {
HXLINE( 298)												index101 = ::Std_obj::_hx_int(((((( (Float)(py16) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px16) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 298)												index101 = ::Std_obj::_hx_int(( (Float)(((py16 * pixelImage->width) + px16)) ));
            											}
HXDLIN( 298)											int _hx_tmp152;
HXDLIN( 298)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)												_hx_tmp152 = ((((((c84 >> 24) & 255) << 24) | ((c84 & 255) << 16)) | (((c84 >> 8) & 255) << 8)) | ((c84 >> 16) & 255));
            											}
            											else {
HXLINE( 298)												_hx_tmp152 = c84;
            											}
HXDLIN( 298)											::iterMagic::Iimg_obj::set(this578,index101,_hx_tmp152);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 298)				if ((hasHit == false)) {
HXLINE( 298)					 ::pi_xy::algo::HitTri v75 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,bottomY,bx3,bottomY,rightX,dy19,true);
HXDLIN( 298)					if (hasUndo16) {
HXLINE( 298)						v75->undoImage = undoImage48;
HXDLIN( 298)						v75->undoX = xIter316->start;
HXDLIN( 298)						v75->undoY = yIter316->start;
            					}
            				}
            			}
HXDLIN( 298)			{
HXLINE( 298)				Float au18 = bu;
HXDLIN( 298)				Float av18 = av;
HXDLIN( 298)				Float bu18 = bu;
HXDLIN( 298)				Float bv17 = cv;
HXDLIN( 298)				bool hasUndo17 = false;
HXDLIN( 298)				Float temp17 = au18;
HXLINE( 422)				au18 = bu18;
HXLINE( 423)				bu18 = temp17;
HXLINE( 424)				temp17 = av18;
HXLINE( 425)				av18 = bv17;
HXLINE( 426)				bv17 = temp17;
HXLINE( 298)				Float bcx17 = (cx3 - rightX);
HXDLIN( 298)				Float bcy17 = (cy6 - dy19);
HXDLIN( 298)				Float acx17 = (bx3 - rightX);
HXDLIN( 298)				Float acy17 = (bottomY - dy19);
HXDLIN( 298)				Float dot1117 = ((bcx17 * bcx17) + (bcy17 * bcy17));
HXDLIN( 298)				Float dot1217 = ((bcx17 * acx17) + (bcy17 * acy17));
HXDLIN( 298)				Float dot2217 = ((acx17 * acx17) + (acy17 * acy17));
HXDLIN( 298)				Float denom117 = (( (Float)(1) ) / ((dot1117 * dot2217) - (dot1217 * dot1217)));
HXDLIN( 298)				 ::pi_xy::iter::IntIterStart xIter317;
HXDLIN( 298)				if ((bx3 > cx3)) {
HXLINE( 298)					if ((bx3 > rightX)) {
HXLINE( 298)						int min68;
HXDLIN( 298)						if ((cx3 > rightX)) {
HXLINE( 298)							min68 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 298)							min68 = ::Math_obj::floor(cx3);
            						}
HXDLIN( 298)						int ii_min136 = min68;
HXDLIN( 298)						int ii_max136 = ::Math_obj::ceil(bx3);
HXDLIN( 298)						xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min136,ii_max136);
            					}
            					else {
HXLINE( 298)						int ii_min137 = ::Math_obj::floor(cx3);
HXDLIN( 298)						int ii_max137 = ::Math_obj::ceil(rightX);
HXDLIN( 298)						xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min137,ii_max137);
            					}
            				}
            				else {
HXLINE( 298)					if ((cx3 > rightX)) {
HXLINE( 298)						int min69;
HXDLIN( 298)						if ((bx3 > rightX)) {
HXLINE( 298)							min69 = ::Math_obj::floor(rightX);
            						}
            						else {
HXLINE( 298)							min69 = ::Math_obj::ceil(bx3);
            						}
HXDLIN( 298)						int ii_min138 = min69;
HXDLIN( 298)						int ii_max138 = ::Math_obj::ceil(cx3);
HXDLIN( 298)						xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min138,ii_max138);
            					}
            					else {
HXLINE( 298)						int ii_min139 = ::Math_obj::floor(bx3);
HXDLIN( 298)						int ii_max139 = ::Math_obj::ceil(rightX);
HXDLIN( 298)						xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min139,ii_max139);
            					}
            				}
HXDLIN( 298)				 ::pi_xy::iter::IntIterStart yIter317;
HXDLIN( 298)				if ((bottomY > cy6)) {
HXLINE( 298)					if ((bottomY > dy19)) {
HXLINE( 298)						int min70;
HXDLIN( 298)						if ((cy6 > dy19)) {
HXLINE( 298)							min70 = ::Math_obj::floor(dy19);
            						}
            						else {
HXLINE( 298)							min70 = ::Math_obj::floor(cy6);
            						}
HXDLIN( 298)						int ii_min140 = min70;
HXDLIN( 298)						int ii_max140 = ::Math_obj::ceil(bottomY);
HXDLIN( 298)						yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min140,ii_max140);
            					}
            					else {
HXLINE( 298)						int ii_min141 = ::Math_obj::floor(cy6);
HXDLIN( 298)						int ii_max141 = ::Math_obj::ceil(dy19);
HXDLIN( 298)						yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min141,ii_max141);
            					}
            				}
            				else {
HXLINE( 298)					if ((cy6 > dy19)) {
HXLINE( 298)						int min71;
HXDLIN( 298)						if ((bottomY > dy19)) {
HXLINE( 298)							min71 = ::Math_obj::floor(dy19);
            						}
            						else {
HXLINE( 298)							min71 = ::Math_obj::ceil(bottomY);
            						}
HXDLIN( 298)						int ii_min142 = min71;
HXDLIN( 298)						int ii_max142 = ::Math_obj::ceil(cy6);
HXDLIN( 298)						yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min142,ii_max142);
            					}
            					else {
HXLINE( 298)						int ii_min143 = ::Math_obj::floor(bottomY);
HXDLIN( 298)						int ii_max143 = ::Math_obj::ceil(dy19);
HXDLIN( 298)						yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min143,ii_max143);
            					}
            				}
HXDLIN( 298)				 ::pi_xy::ImageStruct undoImage51 = null();
HXDLIN( 298)				if (hasUndo17) {
HXLINE( 298)					int width17 = ((xIter317->max - xIter317->start) + 1);
HXDLIN( 298)					int height17 = ((yIter317->max - yIter317->start) + 1);
HXDLIN( 298)					 ::Dynamic imageType17 = null();
HXDLIN( 298)					 ::pi_xy::ImageStruct this579 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 298)					if (::hx::IsNull( imageType17 )) {
HXLINE(  54)						imageType17 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 298)					::Dynamic undoImage52;
HXDLIN( 298)					switch((int)(( (int)(imageType17) ))){
            						case (int)0: {
HXLINE( 298)							 ::iterMagic::BytesImg byt17 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::BytesImg b97 = byt17;
HXDLIN( 298)							{
HXLINE( 298)								b97->width = width17;
HXDLIN( 298)								b97->height = height17;
HXDLIN( 298)								b97->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 298)								b97->data = ::haxe::io::Bytes_obj::alloc((b97->length * 4));
HXDLIN( 298)								{
HXLINE( 298)									int len34 = b97->length;
HXDLIN( 298)									int w17 = 0;
HXDLIN( 298)									{
HXLINE( 298)										int _g340 = 0;
HXDLIN( 298)										int _g341 = b97->height;
HXDLIN( 298)										while((_g340 < _g341)){
HXLINE( 298)											_g340 = (_g340 + 1);
HXDLIN( 298)											int y69 = (_g340 - 1);
HXDLIN( 298)											{
HXLINE( 298)												int _g342 = 0;
HXDLIN( 298)												int _g343 = b97->width;
HXDLIN( 298)												while((_g342 < _g343)){
HXLINE( 298)													_g342 = (_g342 + 1);
HXDLIN( 298)													int x69 = (_g342 - 1);
HXDLIN( 298)													{
HXLINE( 298)														w17 = (w17 + 1);
HXDLIN( 298)														b97->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 298)													{
HXLINE( 298)														w17 = (w17 + 1);
HXDLIN( 298)														b97->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 298)													{
HXLINE( 298)														w17 = (w17 + 1);
HXDLIN( 298)														b97->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 298)													{
HXLINE( 298)														w17 = (w17 + 1);
HXDLIN( 298)														b97->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 298)							undoImage52 = b97;
            						}
            						break;
            						case (int)1: {
HXLINE( 298)							 ::iterMagic::ArrIntImg arrI17 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::ArrIntImg a77 = arrI17;
HXDLIN( 298)							{
HXLINE( 298)								a77->width = width17;
HXDLIN( 298)								a77->height = height17;
HXDLIN( 298)								a77->data = ::Array_obj< int >::__new(0);
HXDLIN( 298)								a77->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 298)								{
HXLINE( 298)									int _g344 = 0;
HXDLIN( 298)									int _g345 = a77->length;
HXDLIN( 298)									while((_g344 < _g345)){
HXLINE( 298)										_g344 = (_g344 + 1);
HXDLIN( 298)										int i102 = (_g344 - 1);
HXDLIN( 298)										a77->data[i102] = 0;
            									}
            								}
            							}
HXDLIN( 298)							undoImage52 = a77;
            						}
            						break;
            						case (int)2: {
HXLINE( 298)							 ::iterMagic::U32ArrImg u32a17 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::U32ArrImg b98 = u32a17;
HXDLIN( 298)							{
HXLINE( 298)								b98->width = width17;
HXDLIN( 298)								b98->height = height17;
HXDLIN( 298)								b98->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 298)								int size17 = (b98->length * 4);
HXDLIN( 298)								b98->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size17),0,size17);
HXDLIN( 298)								{
HXLINE( 298)									int _g346 = 0;
HXDLIN( 298)									int _g347 = b98->length;
HXDLIN( 298)									while((_g346 < _g347)){
HXLINE( 298)										_g346 = (_g346 + 1);
HXDLIN( 298)										int i103 = (_g346 - 1);
HXDLIN( 298)										{
HXLINE( 298)											 ::haxe::io::ArrayBufferViewImpl this580 = b98->data;
HXDLIN( 298)											bool undoImage53;
HXDLIN( 298)											if ((i103 >= 0)) {
HXLINE( 298)												undoImage53 = (i103 < (this580->byteLength >> 2));
            											}
            											else {
HXLINE( 298)												undoImage53 = false;
            											}
HXDLIN( 298)											if (undoImage53) {
HXLINE( 298)												 ::haxe::io::Bytes _this17 = this580->bytes;
HXDLIN( 298)												int pos17 = ((i103 << 2) + this580->byteOffset);
HXDLIN( 298)												_this17->b[pos17] = ( (unsigned char)(0) );
HXDLIN( 298)												_this17->b[(pos17 + 1)] = ( (unsigned char)(0) );
HXDLIN( 298)												_this17->b[(pos17 + 2)] = ( (unsigned char)(0) );
HXDLIN( 298)												_this17->b[(pos17 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 298)							undoImage52 = b98;
            						}
            						break;
            						case (int)3: {
HXLINE( 298)							 ::iterMagic::VecIntImg vec17 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::VecIntImg v76 = vec17;
HXDLIN( 298)							{
HXLINE( 298)								v76->width = width17;
HXDLIN( 298)								v76->height = height17;
HXDLIN( 298)								v76->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 298)								v76->data = ::Array_obj< int >::__new(v76->length);
HXDLIN( 298)								{
HXLINE( 298)									int _g348 = 0;
HXDLIN( 298)									int _g349 = v76->length;
HXDLIN( 298)									while((_g348 < _g349)){
HXLINE( 298)										_g348 = (_g348 + 1);
HXDLIN( 298)										int i104 = (_g348 - 1);
HXDLIN( 298)										v76->data->__unsafe_set(i104,0);
            									}
            								}
            							}
HXDLIN( 298)							undoImage52 = v76;
            						}
            						break;
            						case (int)4: {
HXLINE( 298)							 ::iterMagic::StackIntImg sInt17 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 298)							 ::iterMagic::StackIntImg b99 = sInt17;
HXDLIN( 298)							{
HXLINE( 298)								b99->width = width17;
HXDLIN( 298)								b99->height = height17;
HXDLIN( 298)								b99->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN( 298)								b99->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 298)								{
HXLINE( 298)									int len35 = b99->length;
HXDLIN( 298)									 ::haxe::ds::GenericStack_Int d17 = b99->data;
HXDLIN( 298)									if (::hx::IsNull( d17->head )) {
HXLINE( 298)										int _g350 = 0;
HXDLIN( 298)										int _g351 = len35;
HXDLIN( 298)										while((_g350 < _g351)){
HXLINE( 298)											_g350 = (_g350 + 1);
HXDLIN( 298)											int i105 = (_g350 - 1);
HXDLIN( 298)											d17->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d17->head);
            										}
            									}
            									else {
HXLINE( 298)										int _g352 = 0;
HXDLIN( 298)										int _g353 = len35;
HXDLIN( 298)										while((_g352 < _g353)){
HXLINE( 298)											_g352 = (_g352 + 1);
HXDLIN( 298)											int i106 = (_g352 - 1);
HXDLIN( 298)											{
HXLINE( 298)												 ::haxe::ds::GenericCell_Int l17 = b99->data->head;
HXDLIN( 298)												 ::haxe::ds::GenericCell_Int prev17 = null();
HXDLIN( 298)												{
HXLINE( 298)													int _g354 = 0;
HXDLIN( 298)													int _g355 = i106;
HXDLIN( 298)													while((_g354 < _g355)){
HXLINE( 298)														_g354 = (_g354 + 1);
HXDLIN( 298)														int i107 = (_g354 - 1);
HXLINE( 345)														prev17 = l17;
HXLINE( 346)														l17 = l17->next;
            													}
            												}
HXLINE( 298)												if (::hx::IsNull( prev17 )) {
HXLINE( 298)													b99->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l17->next);
HXDLIN( 298)													l17 = null();
            												}
            												else {
HXLINE( 298)													prev17->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l17->next);
HXDLIN( 298)													l17 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 298)							undoImage52 = b99;
            						}
            						break;
            					}
HXDLIN( 298)					this579->image = undoImage52;
HXDLIN( 298)					this579->width = width17;
HXDLIN( 298)					this579->height = height17;
HXDLIN( 298)					this579->imageType = ( (int)(imageType17) );
HXDLIN( 298)					undoImage51 = this579;
HXDLIN( 298)					{
HXLINE( 298)						int rectLeft17 = xIter317->start;
HXDLIN( 298)						int rectTop17 = yIter317->start;
HXDLIN( 298)						int rectRight17 = xIter317->max;
HXDLIN( 298)						bool forceClear17 = false;
HXDLIN( 298)						{
HXLINE( 298)							int _g356 = rectTop17;
HXDLIN( 298)							int _g357 = yIter317->max;
HXDLIN( 298)							while((_g356 < _g357)){
HXLINE( 298)								_g356 = (_g356 + 1);
HXDLIN( 298)								int dy21 = (_g356 - 1);
HXDLIN( 298)								{
HXLINE( 298)									int _g358 = rectLeft17;
HXDLIN( 298)									int _g359 = rectRight17;
HXDLIN( 298)									while((_g358 < _g359)){
HXLINE( 298)										_g358 = (_g358 + 1);
HXDLIN( 298)										int dx18 = (_g358 - 1);
HXDLIN( 298)										::Dynamic this581 = pixelImage->image;
HXDLIN( 298)										int index102;
HXDLIN( 298)										if (pixelImage->useVirtualPos) {
HXLINE( 298)											index102 = ::Std_obj::_hx_int(((((( (Float)(dy21) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx18) - pixelImage->virtualX));
            										}
            										else {
HXLINE( 298)											index102 = ::Std_obj::_hx_int(( (Float)(((dy21 * pixelImage->width) + dx18)) ));
            										}
HXDLIN( 298)										int c85 = ::iterMagic::Iimg_obj::get(this581,index102);
HXDLIN( 298)										int col34;
HXDLIN( 298)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)											col34 = ((((((c85 >> 24) & 255) << 24) | ((c85 & 255) << 16)) | (((c85 >> 8) & 255) << 8)) | ((c85 >> 16) & 255));
            										}
            										else {
HXLINE( 298)											col34 = c85;
            										}
HXDLIN( 298)										bool _hx_tmp153;
HXDLIN( 298)										if (pixelImage->useMask) {
HXLINE( 298)											_hx_tmp153 = ::hx::IsNotNull( pixelImage->mask );
            										}
            										else {
HXLINE( 298)											_hx_tmp153 = false;
            										}
HXDLIN( 298)										if (_hx_tmp153) {
HXLINE( 298)											 ::pi_xy::ImageStruct this582 = pixelImage->mask;
HXDLIN( 298)											::Dynamic this583 = this582->image;
HXDLIN( 298)											int index103;
HXDLIN( 298)											if (this582->useVirtualPos) {
HXLINE( 298)												index103 = ::Std_obj::_hx_int(((((( (Float)(dy21) ) - this582->virtualY) * ( (Float)(this582->width) )) + dx18) - this582->virtualX));
            											}
            											else {
HXLINE( 298)												index103 = ::Std_obj::_hx_int(( (Float)(((dy21 * this582->width) + dx18)) ));
            											}
HXDLIN( 298)											int c86 = ::iterMagic::Iimg_obj::get(this583,index103);
HXDLIN( 298)											int v77;
HXDLIN( 298)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)												v77 = ((((((c86 >> 24) & 255) << 24) | ((c86 & 255) << 16)) | (((c86 >> 8) & 255) << 8)) | ((c86 >> 16) & 255));
            											}
            											else {
HXLINE( 298)												v77 = c86;
            											}
HXDLIN( 298)											int maskPixel17 = v77;
HXDLIN( 298)											int this584 = col34;
HXDLIN( 298)											if ((maskPixel17 == 0)) {
HXLINE( 298)												col34 = this584;
            											}
            											else {
HXLINE( 298)												Float m017;
HXDLIN( 298)												int this585 = ((maskPixel17 >> 24) & 255);
HXDLIN( 298)												if ((this585 == 0)) {
HXLINE( 298)													m017 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													m017 = (( (Float)(this585) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float m117;
HXDLIN( 298)												int this586 = ((maskPixel17 >> 16) & 255);
HXDLIN( 298)												if ((this586 == 0)) {
HXLINE( 298)													m117 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													m117 = (( (Float)(this586) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float m217;
HXDLIN( 298)												int this587 = ((maskPixel17 >> 8) & 255);
HXDLIN( 298)												if ((this587 == 0)) {
HXLINE( 298)													m217 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													m217 = (( (Float)(this587) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float m317;
HXDLIN( 298)												int this588 = (maskPixel17 & 255);
HXDLIN( 298)												if ((this588 == 0)) {
HXLINE( 298)													m317 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													m317 = (( (Float)(this588) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												int ch017 = ::Std_obj::_hx_int(((((Float)1.) - m017) * ( (Float)(((this584 >> 24) & 255)) )));
HXDLIN( 298)												int ch117 = ::Std_obj::_hx_int(((((Float)1.) - m117) * ( (Float)(((this584 >> 16) & 255)) )));
HXDLIN( 298)												int ch217 = ::Std_obj::_hx_int(((((Float)1.) - m217) * ( (Float)(((this584 >> 8) & 255)) )));
HXDLIN( 298)												int ch317 = ::Std_obj::_hx_int(((((Float)1.) - m317) * ( (Float)((this584 & 255)) )));
HXDLIN( 298)												col34 = ((((::Math_obj::round((( (Float)(ch017) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch117) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch217) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch317) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 298)										if ((col34 != 0)) {
HXLINE( 298)											int x70 = (dx18 - rectLeft17);
HXDLIN( 298)											int y70 = (dy21 - rectTop17);
HXDLIN( 298)											int c87 = col34;
HXDLIN( 298)											bool _hx_tmp154;
HXDLIN( 298)											if ((((c87 >> 24) & 255) < 254)) {
HXLINE( 298)												_hx_tmp154 = undoImage51->transparent;
            											}
            											else {
HXLINE( 298)												_hx_tmp154 = false;
            											}
HXDLIN( 298)											if (_hx_tmp154) {
HXLINE( 298)												int location34;
HXDLIN( 298)												if (undoImage51->useVirtualPos) {
HXLINE( 298)													location34 = ::Std_obj::_hx_int(((((( (Float)(y70) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x70) - undoImage51->virtualX));
            												}
            												else {
HXLINE( 298)													location34 = ::Std_obj::_hx_int(( (Float)(((y70 * undoImage51->width) + x70)) ));
            												}
HXDLIN( 298)												int this589 = ::iterMagic::Iimg_obj::get(undoImage51->image,location34);
HXDLIN( 298)												int this590;
HXDLIN( 298)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)													this590 = ((((((this589 >> 24) & 255) << 24) | ((this589 & 255) << 16)) | (((this589 >> 8) & 255) << 8)) | ((this589 >> 16) & 255));
            												}
            												else {
HXLINE( 298)													this590 = this589;
            												}
HXDLIN( 298)												Float a137;
HXDLIN( 298)												int this591 = ((this590 >> 24) & 255);
HXDLIN( 298)												if ((this591 == 0)) {
HXLINE( 298)													a137 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													a137 = (( (Float)(this591) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float r134;
HXDLIN( 298)												int this592 = ((this590 >> 16) & 255);
HXDLIN( 298)												if ((this592 == 0)) {
HXLINE( 298)													r134 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													r134 = (( (Float)(this592) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float g134;
HXDLIN( 298)												int this593 = ((this590 >> 8) & 255);
HXDLIN( 298)												if ((this593 == 0)) {
HXLINE( 298)													g134 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													g134 = (( (Float)(this593) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float b138;
HXDLIN( 298)												int this594 = (this590 & 255);
HXDLIN( 298)												if ((this594 == 0)) {
HXLINE( 298)													b138 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													b138 = (( (Float)(this594) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float a235;
HXDLIN( 298)												int this595 = ((col34 >> 24) & 255);
HXDLIN( 298)												if ((this595 == 0)) {
HXLINE( 298)													a235 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													a235 = (( (Float)(this595) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float r234;
HXDLIN( 298)												int this596 = ((col34 >> 16) & 255);
HXDLIN( 298)												if ((this596 == 0)) {
HXLINE( 298)													r234 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													r234 = (( (Float)(this596) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float g234;
HXDLIN( 298)												int this597 = ((col34 >> 8) & 255);
HXDLIN( 298)												if ((this597 == 0)) {
HXLINE( 298)													g234 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													g234 = (( (Float)(this597) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float b238;
HXDLIN( 298)												int this598 = (col34 & 255);
HXDLIN( 298)												if ((this598 == 0)) {
HXLINE( 298)													b238 = ((Float)0.);
            												}
            												else {
HXLINE( 298)													b238 = (( (Float)(this598) ) / ( (Float)(255) ));
            												}
HXDLIN( 298)												Float a334 = (a137 * (( (Float)(1) ) - a235));
HXDLIN( 298)												int r54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r134 * a334) + (r234 * a235))));
HXDLIN( 298)												int g54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g134 * a334) + (g234 * a235))));
HXDLIN( 298)												int b100 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b138 * a334) + (b238 * a235))));
HXDLIN( 298)												int a78 = ::Std_obj::_hx_int((( (Float)(255) ) * (a334 + a235)));
HXDLIN( 298)												int blended34 = ((((a78 << 24) | (r54 << 16)) | (g54 << 8)) | b100);
HXDLIN( 298)												{
HXLINE( 298)													int _hx_tmp155;
HXDLIN( 298)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)														_hx_tmp155 = ((((((blended34 >> 24) & 255) << 24) | ((blended34 & 255) << 16)) | (((blended34 >> 8) & 255) << 8)) | ((blended34 >> 16) & 255));
            													}
            													else {
HXLINE( 298)														_hx_tmp155 = blended34;
            													}
HXDLIN( 298)													::iterMagic::Iimg_obj::set(undoImage51->image,location34,_hx_tmp155);
            												}
            											}
            											else {
HXLINE( 298)												::Dynamic this599 = undoImage51->image;
HXDLIN( 298)												int index104;
HXDLIN( 298)												if (undoImage51->useVirtualPos) {
HXLINE( 298)													index104 = ::Std_obj::_hx_int(((((( (Float)(y70) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x70) - undoImage51->virtualX));
            												}
            												else {
HXLINE( 298)													index104 = ::Std_obj::_hx_int(( (Float)(((y70 * undoImage51->width) + x70)) ));
            												}
HXDLIN( 298)												int _hx_tmp156;
HXDLIN( 298)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)													_hx_tmp156 = ((((((c87 >> 24) & 255) << 24) | ((c87 & 255) << 16)) | (((c87 >> 8) & 255) << 8)) | ((c87 >> 16) & 255));
            												}
            												else {
HXLINE( 298)													_hx_tmp156 = c87;
            												}
HXDLIN( 298)												::iterMagic::Iimg_obj::set(this599,index104,_hx_tmp156);
            											}
            										}
            										else {
HXLINE( 298)											if (forceClear17) {
HXLINE( 298)												::Dynamic this600 = undoImage51->image;
HXDLIN( 298)												int x71 = (dx18 - rectLeft17);
HXDLIN( 298)												int y71 = (dy21 - rectTop17);
HXDLIN( 298)												int index105;
HXDLIN( 298)												if (undoImage51->useVirtualPos) {
HXLINE( 298)													index105 = ::Std_obj::_hx_int(((((( (Float)(y71) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x71) - undoImage51->virtualX));
            												}
            												else {
HXLINE( 298)													index105 = ::Std_obj::_hx_int(( (Float)(((y71 * undoImage51->width) + x71)) ));
            												}
HXDLIN( 298)												::iterMagic::Iimg_obj::set(this600,index105,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 298)				{
HXLINE( 298)					int _g_min34 = xIter317->start;
HXDLIN( 298)					int _g_max34 = xIter317->max;
HXDLIN( 298)					while((_g_min34 < _g_max34)){
HXLINE( 298)						_g_min34 = (_g_min34 + 1);
HXDLIN( 298)						int px17 = (_g_min34 - 1);
HXDLIN( 298)						Float pcx17 = (( (Float)(px17) ) - rightX);
HXDLIN( 298)						{
HXLINE( 298)							int _g_min35 = yIter317->start;
HXDLIN( 298)							int _g_max35 = yIter317->max;
HXDLIN( 298)							while((_g_min35 < _g_max35)){
HXLINE( 298)								_g_min35 = (_g_min35 + 1);
HXDLIN( 298)								int py17 = (_g_min35 - 1);
HXDLIN( 298)								Float pcy17 = (( (Float)(py17) ) - dy19);
HXDLIN( 298)								Float dot3117 = ((pcx17 * bcx17) + (pcy17 * bcy17));
HXDLIN( 298)								Float dot3217 = ((pcx17 * acx17) + (pcy17 * acy17));
HXDLIN( 298)								Float ratioA17 = (((dot2217 * dot3117) - (dot1217 * dot3217)) * denom117);
HXDLIN( 298)								Float ratioB17 = (((dot1117 * dot3217) - (dot1217 * dot3117)) * denom117);
HXDLIN( 298)								Float ratioC17 = ((((Float)1.0) - ratioB17) - ratioA17);
HXDLIN( 298)								bool _hx_tmp157;
HXDLIN( 298)								bool _hx_tmp158;
HXDLIN( 298)								if ((ratioA17 >= 0)) {
HXLINE( 298)									_hx_tmp158 = (ratioB17 >= 0);
            								}
            								else {
HXLINE( 298)									_hx_tmp158 = false;
            								}
HXDLIN( 298)								if (_hx_tmp158) {
HXLINE( 298)									_hx_tmp157 = (ratioC17 >= 0);
            								}
            								else {
HXLINE( 298)									_hx_tmp157 = false;
            								}
HXDLIN( 298)								if (_hx_tmp157) {
HXLINE( 298)									Float u17 = (((au18 * ratioA17) + (bu18 * ratioB17)) + (au * ratioC17));
HXDLIN( 298)									Float v78 = (((av18 * ratioA17) + (bv17 * ratioB17)) + (cv * ratioC17));
HXDLIN( 298)									int x72 = ::Std_obj::_hx_int(((u17 * win->width) + win->x));
HXDLIN( 298)									int y72 = ::Std_obj::_hx_int(((v78 * win->height) + win->y));
HXDLIN( 298)									::Dynamic this601 = texture->image;
HXDLIN( 298)									int index106;
HXDLIN( 298)									if (texture->useVirtualPos) {
HXLINE( 298)										index106 = ::Std_obj::_hx_int(((((( (Float)(y72) ) - texture->virtualY) * ( (Float)(texture->width) )) + x72) - texture->virtualX));
            									}
            									else {
HXLINE( 298)										index106 = ::Std_obj::_hx_int(( (Float)(((y72 * texture->width) + x72)) ));
            									}
HXDLIN( 298)									int c88 = ::iterMagic::Iimg_obj::get(this601,index106);
HXDLIN( 298)									int col35;
HXDLIN( 298)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)										col35 = ((((((c88 >> 24) & 255) << 24) | ((c88 & 255) << 16)) | (((c88 >> 8) & 255) << 8)) | ((c88 >> 16) & 255));
            									}
            									else {
HXLINE( 298)										col35 = c88;
            									}
HXDLIN( 298)									{
HXLINE( 298)										int c89 = col35;
HXDLIN( 298)										bool _hx_tmp159;
HXDLIN( 298)										if ((((c89 >> 24) & 255) < 254)) {
HXLINE( 298)											_hx_tmp159 = pixelImage->transparent;
            										}
            										else {
HXLINE( 298)											_hx_tmp159 = false;
            										}
HXDLIN( 298)										if (_hx_tmp159) {
HXLINE( 298)											int location35;
HXDLIN( 298)											if (pixelImage->useVirtualPos) {
HXLINE( 298)												location35 = ::Std_obj::_hx_int(((((( (Float)(py17) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px17) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 298)												location35 = ::Std_obj::_hx_int(( (Float)(((py17 * pixelImage->width) + px17)) ));
            											}
HXDLIN( 298)											int this602 = ::iterMagic::Iimg_obj::get(pixelImage->image,location35);
HXDLIN( 298)											int this603;
HXDLIN( 298)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)												this603 = ((((((this602 >> 24) & 255) << 24) | ((this602 & 255) << 16)) | (((this602 >> 8) & 255) << 8)) | ((this602 >> 16) & 255));
            											}
            											else {
HXLINE( 298)												this603 = this602;
            											}
HXDLIN( 298)											Float a138;
HXDLIN( 298)											int this604 = ((this603 >> 24) & 255);
HXDLIN( 298)											if ((this604 == 0)) {
HXLINE( 298)												a138 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												a138 = (( (Float)(this604) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float r135;
HXDLIN( 298)											int this605 = ((this603 >> 16) & 255);
HXDLIN( 298)											if ((this605 == 0)) {
HXLINE( 298)												r135 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												r135 = (( (Float)(this605) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float g135;
HXDLIN( 298)											int this606 = ((this603 >> 8) & 255);
HXDLIN( 298)											if ((this606 == 0)) {
HXLINE( 298)												g135 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												g135 = (( (Float)(this606) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float b139;
HXDLIN( 298)											int this607 = (this603 & 255);
HXDLIN( 298)											if ((this607 == 0)) {
HXLINE( 298)												b139 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												b139 = (( (Float)(this607) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float a236;
HXDLIN( 298)											int this608 = ((col35 >> 24) & 255);
HXDLIN( 298)											if ((this608 == 0)) {
HXLINE( 298)												a236 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												a236 = (( (Float)(this608) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float r235;
HXDLIN( 298)											int this609 = ((col35 >> 16) & 255);
HXDLIN( 298)											if ((this609 == 0)) {
HXLINE( 298)												r235 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												r235 = (( (Float)(this609) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float g235;
HXDLIN( 298)											int this610 = ((col35 >> 8) & 255);
HXDLIN( 298)											if ((this610 == 0)) {
HXLINE( 298)												g235 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												g235 = (( (Float)(this610) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float b239;
HXDLIN( 298)											int this611 = (col35 & 255);
HXDLIN( 298)											if ((this611 == 0)) {
HXLINE( 298)												b239 = ((Float)0.);
            											}
            											else {
HXLINE( 298)												b239 = (( (Float)(this611) ) / ( (Float)(255) ));
            											}
HXDLIN( 298)											Float a335 = (a138 * (( (Float)(1) ) - a236));
HXDLIN( 298)											int r55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r135 * a335) + (r235 * a236))));
HXDLIN( 298)											int g55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g135 * a335) + (g235 * a236))));
HXDLIN( 298)											int b101 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b139 * a335) + (b239 * a236))));
HXDLIN( 298)											int a79 = ::Std_obj::_hx_int((( (Float)(255) ) * (a335 + a236)));
HXDLIN( 298)											int blended35 = ((((a79 << 24) | (r55 << 16)) | (g55 << 8)) | b101);
HXDLIN( 298)											{
HXLINE( 298)												int _hx_tmp160;
HXDLIN( 298)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)													_hx_tmp160 = ((((((blended35 >> 24) & 255) << 24) | ((blended35 & 255) << 16)) | (((blended35 >> 8) & 255) << 8)) | ((blended35 >> 16) & 255));
            												}
            												else {
HXLINE( 298)													_hx_tmp160 = blended35;
            												}
HXDLIN( 298)												::iterMagic::Iimg_obj::set(pixelImage->image,location35,_hx_tmp160);
            											}
            										}
            										else {
HXLINE( 298)											::Dynamic this612 = pixelImage->image;
HXDLIN( 298)											int index107;
HXDLIN( 298)											if (pixelImage->useVirtualPos) {
HXLINE( 298)												index107 = ::Std_obj::_hx_int(((((( (Float)(py17) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + px17) - pixelImage->virtualX));
            											}
            											else {
HXLINE( 298)												index107 = ::Std_obj::_hx_int(( (Float)(((py17 * pixelImage->width) + px17)) ));
            											}
HXDLIN( 298)											int _hx_tmp161;
HXDLIN( 298)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)												_hx_tmp161 = ((((((c89 >> 24) & 255) << 24) | ((c89 & 255) << 16)) | (((c89 >> 8) & 255) << 8)) | ((c89 >> 16) & 255));
            											}
            											else {
HXLINE( 298)												_hx_tmp161 = c89;
            											}
HXDLIN( 298)											::iterMagic::Iimg_obj::set(this612,index107,_hx_tmp161);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 298)				if ((hasHit == false)) {
HXLINE( 298)					 ::pi_xy::algo::HitTri v79 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx3,bottomY,cx3,cy6,rightX,dy19,true);
HXDLIN( 298)					if (hasUndo17) {
HXLINE( 298)						v79->undoImage = undoImage51;
HXDLIN( 298)						v79->undoX = xIter317->start;
HXDLIN( 298)						v79->undoY = yIter317->start;
            					}
            				}
            			}
HXDLIN( 298)			if ((hasHit == true)) {
HXLINE( 298)				 ::pi_xy::algo::HitQuad v80 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,rightX,bottomY,bx3,bottomY,cx3,cy6,rightX,dy19,true);
            			}
            		}
HXLINE( 303)		if ((hasHit == true)) {
HXLINE( 304)			 ::pi_xy::algo::HitQuad v81 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXLINE( 305)			return v81;
            		}
            		else {
HXLINE( 307)			return null();
            		}
HXLINE( 303)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC18(QuadPixel_Fields__obj,imageNineSlice,return )


QuadPixel_Fields__obj::QuadPixel_Fields__obj()
{
}

bool QuadPixel_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"imageNineSlice") ) { outValue = imageNineSlice_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"imgQuadrilateral") ) { outValue = imgQuadrilateral_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"fillQuadrilateral") ) { outValue = fillQuadrilateral_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"tileQuadrilateral") ) { outValue = tileQuadrilateral_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"fillSoftQuadrilateral") ) { outValue = fillSoftQuadrilateral_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fillGradQuadrilateral") ) { outValue = fillGradQuadrilateral_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"imgQuadrilateralFudge") ) { outValue = imgQuadrilateralFudge_dyn(); return true; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"fillSoftQuadrilateralFudge") ) { outValue = fillSoftQuadrilateralFudge_dyn(); return true; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"fillSoftQuadrilateralQuarter") ) { outValue = fillSoftQuadrilateralQuarter_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *QuadPixel_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *QuadPixel_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class QuadPixel_Fields__obj::__mClass;

static ::String QuadPixel_Fields__obj_sStaticFields[] = {
	HX_("fillQuadrilateral",76,b9,61,b1),
	HX_("fillSoftQuadrilateral",ac,a4,2e,e9),
	HX_("fillSoftQuadrilateralFudge",47,b9,4f,f8),
	HX_("fillSoftQuadrilateralQuarter",e0,48,2f,8d),
	HX_("tileQuadrilateral",eb,ed,f9,87),
	HX_("fillGradQuadrilateral",48,f3,91,07),
	HX_("imgQuadrilateralFudge",bd,a5,7c,94),
	HX_("imgQuadrilateral",f6,0b,d5,4b),
	HX_("imageNineSlice",e5,16,ec,39),
	::String(null())
};

void QuadPixel_Fields__obj::__register()
{
	QuadPixel_Fields__obj _hx_dummy;
	QuadPixel_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.algo._QuadPixel.QuadPixel_Fields_",4c,e2,fc,76);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &QuadPixel_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(QuadPixel_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< QuadPixel_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = QuadPixel_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = QuadPixel_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace algo
} // end namespace _QuadPixel
