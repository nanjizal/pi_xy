// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_LineGridShape
#include <pi_xy/triangleGML/LineGridShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_BasicShape
#include <pi_xy/triangleGML/triGML/BasicShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_GroupShape
#include <pi_xy/triangleGML/triGML/GroupShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_ShapeInterface
#include <pi_xy/triangleGML/triGML/ShapeInterface.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_shape_contour_LineGridShape_
#include <pi_xy/triangleGML/triGML/shape/contour/LineGridShape_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a1ca35afad0c0c79_7_new,"pi_xy.triangleGML.LineGridShape","new",0xa27cbf82,"pi_xy.triangleGML.LineGridShape.new","pi_xy/triangleGML/LineGridShape.hx",7,0x88a447b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a1ca35afad0c0c79_8_render,"pi_xy.triangleGML.LineGridShape","render",0x3c791d74,"pi_xy.triangleGML.LineGridShape.render","pi_xy/triangleGML/LineGridShape.hx",8,0x88a447b0)
namespace pi_xy{
namespace triangleGML{

void LineGridShape_obj::__construct( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic left, ::Dynamic top, ::Dynamic width, ::Dynamic height, ::Dynamic delta, ::Dynamic deltaH){
            	HX_STACKFRAME(&_hx_pos_a1ca35afad0c0c79_7_new)
HXDLIN(   7)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH);
            	}

Dynamic LineGridShape_obj::__CreateEmpty() { return new LineGridShape_obj; }

void *LineGridShape_obj::_hx_vtable = 0;

Dynamic LineGridShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LineGridShape_obj > _hx_result = new LineGridShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10]);
	return _hx_result;
}

bool LineGridShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1d577963) {
		if (inClassId<=(int)0x1a0bd5c0) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x1a0bd5c0;
		} else {
			return inClassId==(int)0x1d577963;
		}
	} else {
		return inClassId==(int)0x4cd3f070 || inClassId==(int)0x7ff8cec5;
	}
}

 ::Dynamic LineGridShape_obj::render( ::Dynamic _tmp_pixelImage){
            	HX_GC_STACKFRAME(&_hx_pos_a1ca35afad0c0c79_8_render)
HXLINE(   9)		 ::pi_xy::ImageStruct pixelImage = ( ( ::pi_xy::ImageStruct)(_tmp_pixelImage) );
HXDLIN(   9)		bool _hx_tmp;
HXDLIN(   9)		bool _hx_tmp1;
HXDLIN(   9)		bool _hx_tmp2;
HXDLIN(   9)		bool _hx_tmp3;
HXDLIN(   9)		if ((this->rotation == ((Float)0.))) {
HXLINE(   9)			_hx_tmp3 = (this->skewX != ((Float)0.));
            		}
            		else {
HXLINE(   9)			_hx_tmp3 = true;
            		}
HXDLIN(   9)		if (!(_hx_tmp3)) {
HXLINE(   9)			_hx_tmp2 = (this->skewY != ((Float)0.));
            		}
            		else {
HXLINE(   9)			_hx_tmp2 = true;
            		}
HXDLIN(   9)		if (!(_hx_tmp2)) {
HXLINE(   9)			_hx_tmp1 = (this->scaleX != ((Float)1.));
            		}
            		else {
HXLINE(   9)			_hx_tmp1 = true;
            		}
HXDLIN(   9)		if (!(_hx_tmp1)) {
HXLINE(   9)			_hx_tmp = (this->scaleY != ((Float)1.));
            		}
            		else {
HXLINE(   9)			_hx_tmp = true;
            		}
HXDLIN(   9)		if (_hx_tmp) {
HXLINE(  14)			int width = ::Math_obj::ceil(this->width);
HXDLIN(  14)			int height = ::Math_obj::ceil(this->height);
HXDLIN(  14)			 ::Dynamic imageType = null();
HXDLIN(  14)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  14)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  14)			::Dynamic _hx_tmp4;
HXDLIN(  14)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE(  14)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  14)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  14)					{
HXLINE(  14)						b->width = width;
HXDLIN(  14)						b->height = height;
HXDLIN(  14)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  14)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  14)						{
HXLINE(  14)							int len = b->length;
HXDLIN(  14)							int w = 0;
HXDLIN(  14)							{
HXLINE(  14)								int _g = 0;
HXDLIN(  14)								int _g1 = b->height;
HXDLIN(  14)								while((_g < _g1)){
HXLINE(  14)									_g = (_g + 1);
HXDLIN(  14)									int y = (_g - 1);
HXDLIN(  14)									{
HXLINE(  14)										int _g2 = 0;
HXDLIN(  14)										int _g3 = b->width;
HXDLIN(  14)										while((_g2 < _g3)){
HXLINE(  14)											_g2 = (_g2 + 1);
HXDLIN(  14)											int x = (_g2 - 1);
HXDLIN(  14)											{
HXLINE(  14)												w = (w + 1);
HXDLIN(  14)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  14)											{
HXLINE(  14)												w = (w + 1);
HXDLIN(  14)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  14)											{
HXLINE(  14)												w = (w + 1);
HXDLIN(  14)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  14)											{
HXLINE(  14)												w = (w + 1);
HXDLIN(  14)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  14)					_hx_tmp4 = b;
            				}
            				break;
            				case (int)1: {
HXLINE(  14)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  14)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  14)					{
HXLINE(  14)						a->width = width;
HXDLIN(  14)						a->height = height;
HXDLIN(  14)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  14)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  14)						{
HXLINE(  14)							int _g4 = 0;
HXDLIN(  14)							int _g5 = a->length;
HXDLIN(  14)							while((_g4 < _g5)){
HXLINE(  14)								_g4 = (_g4 + 1);
HXDLIN(  14)								int i = (_g4 - 1);
HXDLIN(  14)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  14)					_hx_tmp4 = a;
            				}
            				break;
            				case (int)2: {
HXLINE(  14)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  14)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  14)					{
HXLINE(  14)						b1->width = width;
HXDLIN(  14)						b1->height = height;
HXDLIN(  14)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  14)						int size = (b1->length * 4);
HXDLIN(  14)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  14)						{
HXLINE(  14)							int _g6 = 0;
HXDLIN(  14)							int _g7 = b1->length;
HXDLIN(  14)							while((_g6 < _g7)){
HXLINE(  14)								_g6 = (_g6 + 1);
HXDLIN(  14)								int i1 = (_g6 - 1);
HXDLIN(  14)								{
HXLINE(  14)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  14)									bool _hx_tmp5;
HXDLIN(  14)									if ((i1 >= 0)) {
HXLINE(  14)										_hx_tmp5 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  14)										_hx_tmp5 = false;
            									}
HXDLIN(  14)									if (_hx_tmp5) {
HXLINE(  14)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  14)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  14)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  14)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  14)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  14)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  14)					_hx_tmp4 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE(  14)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  14)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  14)					{
HXLINE(  14)						v->width = width;
HXDLIN(  14)						v->height = height;
HXDLIN(  14)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  14)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  14)						{
HXLINE(  14)							int _g8 = 0;
HXDLIN(  14)							int _g9 = v->length;
HXDLIN(  14)							while((_g8 < _g9)){
HXLINE(  14)								_g8 = (_g8 + 1);
HXDLIN(  14)								int i2 = (_g8 - 1);
HXDLIN(  14)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  14)					_hx_tmp4 = v;
            				}
            				break;
            				case (int)4: {
HXLINE(  14)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  14)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  14)					{
HXLINE(  14)						b2->width = width;
HXDLIN(  14)						b2->height = height;
HXDLIN(  14)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  14)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  14)						{
HXLINE(  14)							int len1 = b2->length;
HXDLIN(  14)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  14)							if (::hx::IsNull( d->head )) {
HXLINE(  14)								int _g10 = 0;
HXDLIN(  14)								int _g11 = len1;
HXDLIN(  14)								while((_g10 < _g11)){
HXLINE(  14)									_g10 = (_g10 + 1);
HXDLIN(  14)									int i3 = (_g10 - 1);
HXDLIN(  14)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE(  14)								int _g12 = 0;
HXDLIN(  14)								int _g13 = len1;
HXDLIN(  14)								while((_g12 < _g13)){
HXLINE(  14)									_g12 = (_g12 + 1);
HXDLIN(  14)									int i4 = (_g12 - 1);
HXDLIN(  14)									{
HXLINE(  14)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  14)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  14)										{
HXLINE(  14)											int _g14 = 0;
HXDLIN(  14)											int _g15 = i4;
HXDLIN(  14)											while((_g14 < _g15)){
HXLINE(  14)												_g14 = (_g14 + 1);
HXDLIN(  14)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  14)										if (::hx::IsNull( prev )) {
HXLINE(  14)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  14)											l = null();
            										}
            										else {
HXLINE(  14)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  14)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  14)					_hx_tmp4 = b2;
            				}
            				break;
            			}
HXDLIN(  14)			this1->image = _hx_tmp4;
HXDLIN(  14)			this1->width = width;
HXDLIN(  14)			this1->height = height;
HXDLIN(  14)			this1->imageType = ( (int)(imageType) );
HXDLIN(  14)			 ::pi_xy::ImageStruct temp = this1;
HXLINE(  15)			temp->transparent = false;
HXLINE(  16)			if ((this->deltaH != ((Float)0.))) {
HXLINE(  17)				 ::pi_xy::ImageStruct this3 = temp;
HXDLIN(  17)				Float w1 = this->width;
HXDLIN(  17)				Float h = this->height;
HXDLIN(  17)				Float deltaW = this->delta;
HXDLIN(  17)				Float deltaH = this->deltaH;
HXDLIN(  17)				Float thick = this->strokeWidth;
HXDLIN(  17)				int color = this->strokeColor;
HXDLIN(  17)				Float h_ = (( (Float)(::Math_obj::floor((h / deltaH))) ) * deltaH);
HXDLIN(  17)				Float w_ = (( (Float)(::Math_obj::floor((w1 / deltaW))) ) * deltaW);
HXDLIN(  17)				{
HXLINE(  17)					int _g16 = 0;
HXDLIN(  17)					int _g17 = (::Math_obj::floor((w1 / deltaW)) + 1);
HXDLIN(  17)					while((_g16 < _g17)){
HXLINE(  17)						_g16 = (_g16 + 1);
HXDLIN(  17)						int i6 = (_g16 - 1);
HXDLIN(  17)						{
HXLINE(  17)							int r_x = ::Std_obj::_hx_int(((( (Float)(i6) ) * deltaW) - (thick / ( (Float)(2) ))));
HXDLIN(  17)							int r_y = 0;
HXDLIN(  17)							int r_w = ::Std_obj::_hx_int(thick);
HXDLIN(  17)							int r_h = ::Std_obj::_hx_int(h_);
HXDLIN(  17)							int xmax = ((r_x + r_w) + 1);
HXDLIN(  17)							int ymax = ((r_y + r_h) + 1);
HXDLIN(  17)							int ii_min = r_x;
HXDLIN(  17)							int ii_max = xmax;
HXDLIN(  17)							int xRange__start = ii_min;
HXDLIN(  17)							int xRange__max = ii_max;
HXDLIN(  17)							int ii_min1 = r_y;
HXDLIN(  17)							int ii_max1 = ymax;
HXDLIN(  17)							int yRange__start = ii_min1;
HXDLIN(  17)							int yRange__max = ii_max1;
HXDLIN(  17)							int range_x = xRange__start;
HXDLIN(  17)							int range_y = (yRange__start - 1);
HXDLIN(  17)							int range_xReset = range_x;
HXDLIN(  17)							int range_yReset = range_y;
HXDLIN(  17)							int range_xMax = (xRange__max - 2);
HXDLIN(  17)							int range_yMax = (yRange__max - 2);
HXDLIN(  17)							int _this_min = 0;
HXDLIN(  17)							int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  17)							while((_this_min < _this_max)){
HXLINE(  17)								_this_min = (_this_min + 1);
HXDLIN(  17)								int i7 = (_this_min - 1);
HXDLIN(  17)								if ((range_y > range_yMax)) {
HXLINE(  17)									range_y = range_yReset;
HXDLIN(  17)									range_x = (range_x + 1);
            								}
HXDLIN(  17)								range_y = (range_y + 1);
HXDLIN(  17)								int i8 = i7;
HXDLIN(  17)								{
HXLINE(  17)									int x1 = range_x;
HXDLIN(  17)									int y1 = range_y;
HXDLIN(  17)									int c = color;
HXDLIN(  17)									bool _hx_tmp6;
HXDLIN(  17)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  17)										_hx_tmp6 = this3->transparent;
            									}
            									else {
HXLINE(  17)										_hx_tmp6 = false;
            									}
HXDLIN(  17)									if (_hx_tmp6) {
HXLINE(  17)										int location;
HXDLIN(  17)										if (this3->useVirtualPos) {
HXLINE(  17)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this3->virtualY) * ( (Float)(this3->width) )) + x1) - this3->virtualX));
            										}
            										else {
HXLINE(  17)											location = ::Std_obj::_hx_int(( (Float)(((y1 * this3->width) + x1)) ));
            										}
HXDLIN(  17)										int this4 = ::iterMagic::Iimg_obj::get(this3->image,location);
HXDLIN(  17)										int this5;
HXDLIN(  17)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  17)											this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            										}
            										else {
HXLINE(  17)											this5 = this4;
            										}
HXDLIN(  17)										Float a1;
HXDLIN(  17)										int this6 = ((this5 >> 24) & 255);
HXDLIN(  17)										if ((this6 == 0)) {
HXLINE(  17)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float r1;
HXDLIN(  17)										int this7 = ((this5 >> 16) & 255);
HXDLIN(  17)										if ((this7 == 0)) {
HXLINE(  17)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float g1;
HXDLIN(  17)										int this8 = ((this5 >> 8) & 255);
HXDLIN(  17)										if ((this8 == 0)) {
HXLINE(  17)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float b11;
HXDLIN(  17)										int this9 = (this5 & 255);
HXDLIN(  17)										if ((this9 == 0)) {
HXLINE(  17)											b11 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float a2;
HXDLIN(  17)										int this10 = ((color >> 24) & 255);
HXDLIN(  17)										if ((this10 == 0)) {
HXLINE(  17)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float r2;
HXDLIN(  17)										int this11 = ((color >> 16) & 255);
HXDLIN(  17)										if ((this11 == 0)) {
HXLINE(  17)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float g2;
HXDLIN(  17)										int this12 = ((color >> 8) & 255);
HXDLIN(  17)										if ((this12 == 0)) {
HXLINE(  17)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float b21;
HXDLIN(  17)										int this13 = (color & 255);
HXDLIN(  17)										if ((this13 == 0)) {
HXLINE(  17)											b21 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  17)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  17)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  17)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  17)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  17)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  17)										{
HXLINE(  17)											int _hx_tmp7;
HXDLIN(  17)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  17)												_hx_tmp7 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  17)												_hx_tmp7 = blended;
            											}
HXDLIN(  17)											::iterMagic::Iimg_obj::set(this3->image,location,_hx_tmp7);
            										}
            									}
            									else {
HXLINE(  17)										::Dynamic this14 = this3->image;
HXDLIN(  17)										int index;
HXDLIN(  17)										if (this3->useVirtualPos) {
HXLINE(  17)											index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this3->virtualY) * ( (Float)(this3->width) )) + x1) - this3->virtualX));
            										}
            										else {
HXLINE(  17)											index = ::Std_obj::_hx_int(( (Float)(((y1 * this3->width) + x1)) ));
            										}
HXDLIN(  17)										int _hx_tmp8;
HXDLIN(  17)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  17)											_hx_tmp8 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  17)											_hx_tmp8 = c;
            										}
HXDLIN(  17)										::iterMagic::Iimg_obj::set(this14,index,_hx_tmp8);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  17)				{
HXLINE(  17)					int _g18 = 0;
HXDLIN(  17)					int _g19 = (::Math_obj::floor((h / deltaH)) + 1);
HXDLIN(  17)					while((_g18 < _g19)){
HXLINE(  17)						_g18 = (_g18 + 1);
HXDLIN(  17)						int i9 = (_g18 - 1);
HXDLIN(  17)						{
HXLINE(  17)							int r_x1 = 0;
HXDLIN(  17)							int r_y1 = ::Std_obj::_hx_int(((( (Float)(i9) ) * deltaH) - (thick / ( (Float)(2) ))));
HXDLIN(  17)							int r_w1 = ::Std_obj::_hx_int(w_);
HXDLIN(  17)							int r_h1 = ::Std_obj::_hx_int(thick);
HXDLIN(  17)							int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN(  17)							int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN(  17)							int ii_min2 = r_x1;
HXDLIN(  17)							int ii_max2 = xmax1;
HXDLIN(  17)							int xRange__start1 = ii_min2;
HXDLIN(  17)							int xRange__max1 = ii_max2;
HXDLIN(  17)							int ii_min3 = r_y1;
HXDLIN(  17)							int ii_max3 = ymax1;
HXDLIN(  17)							int yRange__start1 = ii_min3;
HXDLIN(  17)							int yRange__max1 = ii_max3;
HXDLIN(  17)							int range_x1 = xRange__start1;
HXDLIN(  17)							int range_y1 = (yRange__start1 - 1);
HXDLIN(  17)							int range_xReset1 = range_x1;
HXDLIN(  17)							int range_yReset1 = range_y1;
HXDLIN(  17)							int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  17)							int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  17)							int _this_min1 = 0;
HXDLIN(  17)							int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  17)							while((_this_min1 < _this_max1)){
HXLINE(  17)								_this_min1 = (_this_min1 + 1);
HXDLIN(  17)								int i10 = (_this_min1 - 1);
HXDLIN(  17)								if ((range_y1 > range_yMax1)) {
HXLINE(  17)									range_y1 = range_yReset1;
HXDLIN(  17)									range_x1 = (range_x1 + 1);
            								}
HXDLIN(  17)								range_y1 = (range_y1 + 1);
HXDLIN(  17)								int i11 = i10;
HXDLIN(  17)								{
HXLINE(  17)									int x2 = range_x1;
HXDLIN(  17)									int y2 = range_y1;
HXDLIN(  17)									int c1 = color;
HXDLIN(  17)									bool _hx_tmp9;
HXDLIN(  17)									if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  17)										_hx_tmp9 = this3->transparent;
            									}
            									else {
HXLINE(  17)										_hx_tmp9 = false;
            									}
HXDLIN(  17)									if (_hx_tmp9) {
HXLINE(  17)										int location1;
HXDLIN(  17)										if (this3->useVirtualPos) {
HXLINE(  17)											location1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this3->virtualY) * ( (Float)(this3->width) )) + x2) - this3->virtualX));
            										}
            										else {
HXLINE(  17)											location1 = ::Std_obj::_hx_int(( (Float)(((y2 * this3->width) + x2)) ));
            										}
HXDLIN(  17)										int this15 = ::iterMagic::Iimg_obj::get(this3->image,location1);
HXDLIN(  17)										int this16;
HXDLIN(  17)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  17)											this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            										}
            										else {
HXLINE(  17)											this16 = this15;
            										}
HXDLIN(  17)										Float a11;
HXDLIN(  17)										int this17 = ((this16 >> 24) & 255);
HXDLIN(  17)										if ((this17 == 0)) {
HXLINE(  17)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float r11;
HXDLIN(  17)										int this18 = ((this16 >> 16) & 255);
HXDLIN(  17)										if ((this18 == 0)) {
HXLINE(  17)											r11 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											r11 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float g11;
HXDLIN(  17)										int this19 = ((this16 >> 8) & 255);
HXDLIN(  17)										if ((this19 == 0)) {
HXLINE(  17)											g11 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											g11 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float b12;
HXDLIN(  17)										int this20 = (this16 & 255);
HXDLIN(  17)										if ((this20 == 0)) {
HXLINE(  17)											b12 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											b12 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float a21;
HXDLIN(  17)										int this21 = ((color >> 24) & 255);
HXDLIN(  17)										if ((this21 == 0)) {
HXLINE(  17)											a21 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											a21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float r21;
HXDLIN(  17)										int this22 = ((color >> 16) & 255);
HXDLIN(  17)										if ((this22 == 0)) {
HXLINE(  17)											r21 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											r21 = (( (Float)(this22) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float g21;
HXDLIN(  17)										int this23 = ((color >> 8) & 255);
HXDLIN(  17)										if ((this23 == 0)) {
HXLINE(  17)											g21 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											g21 = (( (Float)(this23) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float b22;
HXDLIN(  17)										int this24 = (color & 255);
HXDLIN(  17)										if ((this24 == 0)) {
HXLINE(  17)											b22 = ((Float)0.);
            										}
            										else {
HXLINE(  17)											b22 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN(  17)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  17)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  17)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  17)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  17)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  17)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  17)										{
HXLINE(  17)											int _hx_tmp10;
HXDLIN(  17)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  17)												_hx_tmp10 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE(  17)												_hx_tmp10 = blended1;
            											}
HXDLIN(  17)											::iterMagic::Iimg_obj::set(this3->image,location1,_hx_tmp10);
            										}
            									}
            									else {
HXLINE(  17)										::Dynamic this25 = this3->image;
HXDLIN(  17)										int index1;
HXDLIN(  17)										if (this3->useVirtualPos) {
HXLINE(  17)											index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this3->virtualY) * ( (Float)(this3->width) )) + x2) - this3->virtualX));
            										}
            										else {
HXLINE(  17)											index1 = ::Std_obj::_hx_int(( (Float)(((y2 * this3->width) + x2)) ));
            										}
HXDLIN(  17)										int _hx_tmp11;
HXDLIN(  17)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  17)											_hx_tmp11 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE(  17)											_hx_tmp11 = c1;
            										}
HXDLIN(  17)										::iterMagic::Iimg_obj::set(this25,index1,_hx_tmp11);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            			else {
HXLINE(  19)				 ::pi_xy::ImageStruct this26 = temp;
HXDLIN(  19)				Float w2 = this->width;
HXDLIN(  19)				Float h1 = this->height;
HXDLIN(  19)				Float delta = this->delta;
HXDLIN(  19)				Float thick1 = this->strokeWidth;
HXDLIN(  19)				int color1 = this->strokeColor;
HXDLIN(  19)				Float h_1 = (( (Float)(::Math_obj::floor((h1 / delta))) ) * delta);
HXDLIN(  19)				Float w_1 = (( (Float)(::Math_obj::floor((w2 / delta))) ) * delta);
HXDLIN(  19)				{
HXLINE(  19)					int _g20 = 0;
HXDLIN(  19)					int _g21 = (::Math_obj::floor((w2 / delta)) + 1);
HXDLIN(  19)					while((_g20 < _g21)){
HXLINE(  19)						_g20 = (_g20 + 1);
HXDLIN(  19)						int i12 = (_g20 - 1);
HXDLIN(  19)						{
HXLINE(  19)							int r_x2 = ::Std_obj::_hx_int(((( (Float)(i12) ) * delta) - (thick1 / ( (Float)(2) ))));
HXDLIN(  19)							int r_y2 = 0;
HXDLIN(  19)							int r_w2 = ::Std_obj::_hx_int(thick1);
HXDLIN(  19)							int r_h2 = ::Std_obj::_hx_int(h_1);
HXDLIN(  19)							int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN(  19)							int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN(  19)							int ii_min4 = r_x2;
HXDLIN(  19)							int ii_max4 = xmax2;
HXDLIN(  19)							int xRange__start2 = ii_min4;
HXDLIN(  19)							int xRange__max2 = ii_max4;
HXDLIN(  19)							int ii_min5 = r_y2;
HXDLIN(  19)							int ii_max5 = ymax2;
HXDLIN(  19)							int yRange__start2 = ii_min5;
HXDLIN(  19)							int yRange__max2 = ii_max5;
HXDLIN(  19)							int range_x2 = xRange__start2;
HXDLIN(  19)							int range_y2 = (yRange__start2 - 1);
HXDLIN(  19)							int range_xReset2 = range_x2;
HXDLIN(  19)							int range_yReset2 = range_y2;
HXDLIN(  19)							int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  19)							int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  19)							int _this_min2 = 0;
HXDLIN(  19)							int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  19)							while((_this_min2 < _this_max2)){
HXLINE(  19)								_this_min2 = (_this_min2 + 1);
HXDLIN(  19)								int i13 = (_this_min2 - 1);
HXDLIN(  19)								if ((range_y2 > range_yMax2)) {
HXLINE(  19)									range_y2 = range_yReset2;
HXDLIN(  19)									range_x2 = (range_x2 + 1);
            								}
HXDLIN(  19)								range_y2 = (range_y2 + 1);
HXDLIN(  19)								int i14 = i13;
HXDLIN(  19)								{
HXLINE(  19)									int x3 = range_x2;
HXDLIN(  19)									int y3 = range_y2;
HXDLIN(  19)									int c2 = color1;
HXDLIN(  19)									bool _hx_tmp12;
HXDLIN(  19)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  19)										_hx_tmp12 = this26->transparent;
            									}
            									else {
HXLINE(  19)										_hx_tmp12 = false;
            									}
HXDLIN(  19)									if (_hx_tmp12) {
HXLINE(  19)										int location2;
HXDLIN(  19)										if (this26->useVirtualPos) {
HXLINE(  19)											location2 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this26->virtualY) * ( (Float)(this26->width) )) + x3) - this26->virtualX));
            										}
            										else {
HXLINE(  19)											location2 = ::Std_obj::_hx_int(( (Float)(((y3 * this26->width) + x3)) ));
            										}
HXDLIN(  19)										int this27 = ::iterMagic::Iimg_obj::get(this26->image,location2);
HXDLIN(  19)										int this28;
HXDLIN(  19)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)											this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            										}
            										else {
HXLINE(  19)											this28 = this27;
            										}
HXDLIN(  19)										Float a12;
HXDLIN(  19)										int this29 = ((this28 >> 24) & 255);
HXDLIN(  19)										if ((this29 == 0)) {
HXLINE(  19)											a12 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											a12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float r12;
HXDLIN(  19)										int this30 = ((this28 >> 16) & 255);
HXDLIN(  19)										if ((this30 == 0)) {
HXLINE(  19)											r12 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											r12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float g12;
HXDLIN(  19)										int this31 = ((this28 >> 8) & 255);
HXDLIN(  19)										if ((this31 == 0)) {
HXLINE(  19)											g12 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											g12 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float b13;
HXDLIN(  19)										int this32 = (this28 & 255);
HXDLIN(  19)										if ((this32 == 0)) {
HXLINE(  19)											b13 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											b13 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float a22;
HXDLIN(  19)										int this33 = ((color1 >> 24) & 255);
HXDLIN(  19)										if ((this33 == 0)) {
HXLINE(  19)											a22 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											a22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float r22;
HXDLIN(  19)										int this34 = ((color1 >> 16) & 255);
HXDLIN(  19)										if ((this34 == 0)) {
HXLINE(  19)											r22 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											r22 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float g22;
HXDLIN(  19)										int this35 = ((color1 >> 8) & 255);
HXDLIN(  19)										if ((this35 == 0)) {
HXLINE(  19)											g22 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											g22 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float b23;
HXDLIN(  19)										int this36 = (color1 & 255);
HXDLIN(  19)										if ((this36 == 0)) {
HXLINE(  19)											b23 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											b23 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  19)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  19)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  19)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  19)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  19)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  19)										{
HXLINE(  19)											int _hx_tmp13;
HXDLIN(  19)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)												_hx_tmp13 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE(  19)												_hx_tmp13 = blended2;
            											}
HXDLIN(  19)											::iterMagic::Iimg_obj::set(this26->image,location2,_hx_tmp13);
            										}
            									}
            									else {
HXLINE(  19)										::Dynamic this37 = this26->image;
HXDLIN(  19)										int index2;
HXDLIN(  19)										if (this26->useVirtualPos) {
HXLINE(  19)											index2 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this26->virtualY) * ( (Float)(this26->width) )) + x3) - this26->virtualX));
            										}
            										else {
HXLINE(  19)											index2 = ::Std_obj::_hx_int(( (Float)(((y3 * this26->width) + x3)) ));
            										}
HXDLIN(  19)										int _hx_tmp14;
HXDLIN(  19)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)											_hx_tmp14 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE(  19)											_hx_tmp14 = c2;
            										}
HXDLIN(  19)										::iterMagic::Iimg_obj::set(this37,index2,_hx_tmp14);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  19)				{
HXLINE(  19)					int _g22 = 0;
HXDLIN(  19)					int _g23 = (::Math_obj::floor((h1 / delta)) + 1);
HXDLIN(  19)					while((_g22 < _g23)){
HXLINE(  19)						_g22 = (_g22 + 1);
HXDLIN(  19)						int i15 = (_g22 - 1);
HXDLIN(  19)						{
HXLINE(  19)							int r_x3 = 0;
HXDLIN(  19)							int r_y3 = ::Std_obj::_hx_int(((( (Float)(i15) ) * delta) - (thick1 / ( (Float)(2) ))));
HXDLIN(  19)							int r_w3 = ::Std_obj::_hx_int(w_1);
HXDLIN(  19)							int r_h3 = ::Std_obj::_hx_int(thick1);
HXDLIN(  19)							int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN(  19)							int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN(  19)							int ii_min6 = r_x3;
HXDLIN(  19)							int ii_max6 = xmax3;
HXDLIN(  19)							int xRange__start3 = ii_min6;
HXDLIN(  19)							int xRange__max3 = ii_max6;
HXDLIN(  19)							int ii_min7 = r_y3;
HXDLIN(  19)							int ii_max7 = ymax3;
HXDLIN(  19)							int yRange__start3 = ii_min7;
HXDLIN(  19)							int yRange__max3 = ii_max7;
HXDLIN(  19)							int range_x3 = xRange__start3;
HXDLIN(  19)							int range_y3 = (yRange__start3 - 1);
HXDLIN(  19)							int range_xReset3 = range_x3;
HXDLIN(  19)							int range_yReset3 = range_y3;
HXDLIN(  19)							int range_xMax3 = (xRange__max3 - 2);
HXDLIN(  19)							int range_yMax3 = (yRange__max3 - 2);
HXDLIN(  19)							int _this_min3 = 0;
HXDLIN(  19)							int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN(  19)							while((_this_min3 < _this_max3)){
HXLINE(  19)								_this_min3 = (_this_min3 + 1);
HXDLIN(  19)								int i16 = (_this_min3 - 1);
HXDLIN(  19)								if ((range_y3 > range_yMax3)) {
HXLINE(  19)									range_y3 = range_yReset3;
HXDLIN(  19)									range_x3 = (range_x3 + 1);
            								}
HXDLIN(  19)								range_y3 = (range_y3 + 1);
HXDLIN(  19)								int i17 = i16;
HXDLIN(  19)								{
HXLINE(  19)									int x4 = range_x3;
HXDLIN(  19)									int y4 = range_y3;
HXDLIN(  19)									int c3 = color1;
HXDLIN(  19)									bool _hx_tmp15;
HXDLIN(  19)									if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  19)										_hx_tmp15 = this26->transparent;
            									}
            									else {
HXLINE(  19)										_hx_tmp15 = false;
            									}
HXDLIN(  19)									if (_hx_tmp15) {
HXLINE(  19)										int location3;
HXDLIN(  19)										if (this26->useVirtualPos) {
HXLINE(  19)											location3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this26->virtualY) * ( (Float)(this26->width) )) + x4) - this26->virtualX));
            										}
            										else {
HXLINE(  19)											location3 = ::Std_obj::_hx_int(( (Float)(((y4 * this26->width) + x4)) ));
            										}
HXDLIN(  19)										int this38 = ::iterMagic::Iimg_obj::get(this26->image,location3);
HXDLIN(  19)										int this39;
HXDLIN(  19)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)											this39 = ((((((this38 >> 24) & 255) << 24) | ((this38 & 255) << 16)) | (((this38 >> 8) & 255) << 8)) | ((this38 >> 16) & 255));
            										}
            										else {
HXLINE(  19)											this39 = this38;
            										}
HXDLIN(  19)										Float a13;
HXDLIN(  19)										int this40 = ((this39 >> 24) & 255);
HXDLIN(  19)										if ((this40 == 0)) {
HXLINE(  19)											a13 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											a13 = (( (Float)(this40) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float r13;
HXDLIN(  19)										int this41 = ((this39 >> 16) & 255);
HXDLIN(  19)										if ((this41 == 0)) {
HXLINE(  19)											r13 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											r13 = (( (Float)(this41) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float g13;
HXDLIN(  19)										int this42 = ((this39 >> 8) & 255);
HXDLIN(  19)										if ((this42 == 0)) {
HXLINE(  19)											g13 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											g13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float b14;
HXDLIN(  19)										int this43 = (this39 & 255);
HXDLIN(  19)										if ((this43 == 0)) {
HXLINE(  19)											b14 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											b14 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float a23;
HXDLIN(  19)										int this44 = ((color1 >> 24) & 255);
HXDLIN(  19)										if ((this44 == 0)) {
HXLINE(  19)											a23 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											a23 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float r23;
HXDLIN(  19)										int this45 = ((color1 >> 16) & 255);
HXDLIN(  19)										if ((this45 == 0)) {
HXLINE(  19)											r23 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											r23 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float g23;
HXDLIN(  19)										int this46 = ((color1 >> 8) & 255);
HXDLIN(  19)										if ((this46 == 0)) {
HXLINE(  19)											g23 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											g23 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float b24;
HXDLIN(  19)										int this47 = (color1 & 255);
HXDLIN(  19)										if ((this47 == 0)) {
HXLINE(  19)											b24 = ((Float)0.);
            										}
            										else {
HXLINE(  19)											b24 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN(  19)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  19)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  19)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  19)										int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  19)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  19)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b6);
HXDLIN(  19)										{
HXLINE(  19)											int _hx_tmp16;
HXDLIN(  19)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)												_hx_tmp16 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE(  19)												_hx_tmp16 = blended3;
            											}
HXDLIN(  19)											::iterMagic::Iimg_obj::set(this26->image,location3,_hx_tmp16);
            										}
            									}
            									else {
HXLINE(  19)										::Dynamic this48 = this26->image;
HXDLIN(  19)										int index3;
HXDLIN(  19)										if (this26->useVirtualPos) {
HXLINE(  19)											index3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this26->virtualY) * ( (Float)(this26->width) )) + x4) - this26->virtualX));
            										}
            										else {
HXLINE(  19)											index3 = ::Std_obj::_hx_int(( (Float)(((y4 * this26->width) + x4)) ));
            										}
HXDLIN(  19)										int _hx_tmp17;
HXDLIN(  19)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)											_hx_tmp17 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE(  19)											_hx_tmp17 = c3;
            										}
HXDLIN(  19)										::iterMagic::Iimg_obj::set(this48,index3,_hx_tmp17);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXLINE(  21)			Float win_x = ( (Float)(0) );
HXDLIN(  21)			Float win_y = ( (Float)(0) );
HXDLIN(  21)			Float win_width = ( (Float)(temp->width) );
HXDLIN(  21)			Float win_height = ( (Float)(temp->height) );
HXLINE(  22)			int width1 = ::Math_obj::ceil(this->width);
HXDLIN(  22)			int height1 = ::Math_obj::ceil(this->height);
HXDLIN(  22)			 ::Dynamic imageType1 = null();
HXDLIN(  22)			 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  22)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  22)			::Dynamic _hx_tmp18;
HXDLIN(  22)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXLINE(  22)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  22)					 ::iterMagic::BytesImg b7 = byt1;
HXDLIN(  22)					{
HXLINE(  22)						b7->width = width1;
HXDLIN(  22)						b7->height = height1;
HXDLIN(  22)						b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)						b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN(  22)						{
HXLINE(  22)							int len2 = b7->length;
HXDLIN(  22)							int w3 = 0;
HXDLIN(  22)							{
HXLINE(  22)								int _g24 = 0;
HXDLIN(  22)								int _g25 = b7->height;
HXDLIN(  22)								while((_g24 < _g25)){
HXLINE(  22)									_g24 = (_g24 + 1);
HXDLIN(  22)									int y5 = (_g24 - 1);
HXDLIN(  22)									{
HXLINE(  22)										int _g26 = 0;
HXDLIN(  22)										int _g27 = b7->width;
HXDLIN(  22)										while((_g26 < _g27)){
HXLINE(  22)											_g26 = (_g26 + 1);
HXDLIN(  22)											int x5 = (_g26 - 1);
HXDLIN(  22)											{
HXLINE(  22)												w3 = (w3 + 1);
HXDLIN(  22)												b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  22)											{
HXLINE(  22)												w3 = (w3 + 1);
HXDLIN(  22)												b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  22)											{
HXLINE(  22)												w3 = (w3 + 1);
HXDLIN(  22)												b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  22)											{
HXLINE(  22)												w3 = (w3 + 1);
HXDLIN(  22)												b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  22)					_hx_tmp18 = b7;
            				}
            				break;
            				case (int)1: {
HXLINE(  22)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  22)					 ::iterMagic::ArrIntImg a8 = arrI1;
HXDLIN(  22)					{
HXLINE(  22)						a8->width = width1;
HXDLIN(  22)						a8->height = height1;
HXDLIN(  22)						a8->data = ::Array_obj< int >::__new(0);
HXDLIN(  22)						a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)						{
HXLINE(  22)							int _g28 = 0;
HXDLIN(  22)							int _g29 = a8->length;
HXDLIN(  22)							while((_g28 < _g29)){
HXLINE(  22)								_g28 = (_g28 + 1);
HXDLIN(  22)								int i18 = (_g28 - 1);
HXDLIN(  22)								a8->data[i18] = 0;
            							}
            						}
            					}
HXDLIN(  22)					_hx_tmp18 = a8;
            				}
            				break;
            				case (int)2: {
HXLINE(  22)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  22)					 ::iterMagic::U32ArrImg b8 = u32a1;
HXDLIN(  22)					{
HXLINE(  22)						b8->width = width1;
HXDLIN(  22)						b8->height = height1;
HXDLIN(  22)						b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)						int size1 = (b8->length * 4);
HXDLIN(  22)						b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  22)						{
HXLINE(  22)							int _g30 = 0;
HXDLIN(  22)							int _g31 = b8->length;
HXDLIN(  22)							while((_g30 < _g31)){
HXLINE(  22)								_g30 = (_g30 + 1);
HXDLIN(  22)								int i19 = (_g30 - 1);
HXDLIN(  22)								{
HXLINE(  22)									 ::haxe::io::ArrayBufferViewImpl this50 = b8->data;
HXDLIN(  22)									bool _hx_tmp19;
HXDLIN(  22)									if ((i19 >= 0)) {
HXLINE(  22)										_hx_tmp19 = (i19 < (this50->byteLength >> 2));
            									}
            									else {
HXLINE(  22)										_hx_tmp19 = false;
            									}
HXDLIN(  22)									if (_hx_tmp19) {
HXLINE(  22)										 ::haxe::io::Bytes _this1 = this50->bytes;
HXDLIN(  22)										int pos1 = ((i19 << 2) + this50->byteOffset);
HXDLIN(  22)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  22)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  22)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  22)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  22)					_hx_tmp18 = b8;
            				}
            				break;
            				case (int)3: {
HXLINE(  22)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  22)					 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN(  22)					{
HXLINE(  22)						v1->width = width1;
HXDLIN(  22)						v1->height = height1;
HXDLIN(  22)						v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)						v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(  22)						{
HXLINE(  22)							int _g32 = 0;
HXDLIN(  22)							int _g33 = v1->length;
HXDLIN(  22)							while((_g32 < _g33)){
HXLINE(  22)								_g32 = (_g32 + 1);
HXDLIN(  22)								int i20 = (_g32 - 1);
HXDLIN(  22)								v1->data->__unsafe_set(i20,0);
            							}
            						}
            					}
HXDLIN(  22)					_hx_tmp18 = v1;
            				}
            				break;
            				case (int)4: {
HXLINE(  22)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  22)					 ::iterMagic::StackIntImg b9 = sInt1;
HXDLIN(  22)					{
HXLINE(  22)						b9->width = width1;
HXDLIN(  22)						b9->height = height1;
HXDLIN(  22)						b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  22)						b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  22)						{
HXLINE(  22)							int len3 = b9->length;
HXDLIN(  22)							 ::haxe::ds::GenericStack_Int d1 = b9->data;
HXDLIN(  22)							if (::hx::IsNull( d1->head )) {
HXLINE(  22)								int _g34 = 0;
HXDLIN(  22)								int _g35 = len3;
HXDLIN(  22)								while((_g34 < _g35)){
HXLINE(  22)									_g34 = (_g34 + 1);
HXDLIN(  22)									int i21 = (_g34 - 1);
HXDLIN(  22)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXLINE(  22)								int _g36 = 0;
HXDLIN(  22)								int _g37 = len3;
HXDLIN(  22)								while((_g36 < _g37)){
HXLINE(  22)									_g36 = (_g36 + 1);
HXDLIN(  22)									int i22 = (_g36 - 1);
HXDLIN(  22)									{
HXLINE(  22)										 ::haxe::ds::GenericCell_Int l1 = b9->data->head;
HXDLIN(  22)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  22)										{
HXLINE(  22)											int _g38 = 0;
HXDLIN(  22)											int _g39 = i22;
HXDLIN(  22)											while((_g38 < _g39)){
HXLINE(  22)												_g38 = (_g38 + 1);
HXDLIN(  22)												int i23 = (_g38 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE(  22)										if (::hx::IsNull( prev1 )) {
HXLINE(  22)											b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  22)											l1 = null();
            										}
            										else {
HXLINE(  22)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  22)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  22)					_hx_tmp18 = b9;
            				}
            				break;
            			}
HXDLIN(  22)			this49->image = _hx_tmp18;
HXDLIN(  22)			this49->width = width1;
HXDLIN(  22)			this49->height = height1;
HXDLIN(  22)			this49->imageType = ( (int)(imageType1) );
HXDLIN(  22)			 ::pi_xy::ImageStruct temp2 = this49;
HXLINE(  23)			temp2->transparent = true;
HXLINE(  24)			{
HXLINE(  24)				 ::pi_xy::ImageStruct this51 = temp2;
HXDLIN(  24)				Float wid = ( (Float)(temp->width) );
HXDLIN(  24)				Float hi = ( (Float)(temp->height) );
HXDLIN(  24)				Float theta = this->rotation;
HXDLIN(  24)				Float centreX = this->transformCentreX;
HXDLIN(  24)				Float centreY = this->transformCentreY;
HXDLIN(  24)				Float skewX = this->skewX;
HXDLIN(  24)				Float skewY = this->skewY;
HXDLIN(  24)				Float scaleX = this->scaleX;
HXDLIN(  24)				Float scaleY = this->scaleY;
HXDLIN(  24)				bool hasHit = true;
HXDLIN(  24)				Float ax = ( (Float)(0) );
HXDLIN(  24)				Float ay = ( (Float)(0) );
HXDLIN(  24)				if ((theta != ((Float)0.))) {
HXLINE(  64)					centreX = ((wid / ( (Float)(2) )) + centreX);
HXLINE(  65)					centreY = ((hi / ( (Float)(2) )) + centreY);
HXLINE(  24)					ax = (ax - centreX);
HXDLIN(  24)					ay = (ay - centreY);
            				}
HXDLIN(  24)				Float bx = (ax + wid);
HXDLIN(  24)				Float by = ay;
HXDLIN(  24)				Float cx = bx;
HXDLIN(  24)				Float cy = (ay + hi);
HXDLIN(  24)				Float dx = ax;
HXDLIN(  24)				Float dy = cy;
HXDLIN(  24)				if ((skewX != ((Float)0.))) {
HXLINE(  24)					ax = (ax + skewX);
HXDLIN(  24)					bx = (bx + skewX);
HXDLIN(  24)					cx = (cx - skewX);
HXDLIN(  24)					dx = (dx - skewX);
            				}
HXDLIN(  24)				if ((skewY != ((Float)0.))) {
HXLINE(  24)					ay = (ay - skewY);
HXDLIN(  24)					dy = (dy - skewY);
HXDLIN(  24)					by = (by + skewY);
HXDLIN(  24)					cy = (cy + skewY);
            				}
HXDLIN(  24)				if ((scaleX != 1)) {
HXLINE(  24)					ax = (ax * scaleX);
HXDLIN(  24)					bx = (bx * scaleX);
HXDLIN(  24)					cx = (cx * scaleX);
HXDLIN(  24)					dx = (dx * scaleX);
            				}
HXDLIN(  24)				if ((scaleY != ((Float)1.))) {
HXLINE(  24)					ay = (ay * scaleY);
HXDLIN(  24)					bx = (bx * scaleY);
HXDLIN(  24)					cx = (cx * scaleY);
HXDLIN(  24)					dx = (dx * scaleY);
            				}
HXDLIN(  24)				if ((theta != 0)) {
HXLINE(  24)					Float sin = ::Math_obj::sin(theta);
HXDLIN(  24)					Float cos = ::Math_obj::cos(theta);
HXDLIN(  24)					Float temp1 = ax;
HXLINE( 104)					ax = ((temp1 * cos) - (ay * sin));
HXLINE( 105)					ay = ((ay * cos) + (temp1 * sin));
HXLINE(  24)					Float temp3 = bx;
HXLINE( 107)					bx = ((temp3 * cos) - (by * sin));
HXLINE( 108)					by = ((by * cos) + (temp3 * sin));
HXLINE(  24)					Float temp4 = cx;
HXLINE( 110)					cx = ((temp4 * cos) - (cy * sin));
HXLINE( 111)					cy = ((cy * cos) + (temp4 * sin));
HXLINE(  24)					Float temp5 = dx;
HXLINE( 113)					dx = ((temp5 * cos) - (dy * sin));
HXLINE( 114)					dy = ((dy * cos) + (temp5 * sin));
HXLINE(  24)					ax = (ax + centreX);
HXDLIN(  24)					ay = (ay + centreY);
HXDLIN(  24)					bx = (bx + centreX);
HXDLIN(  24)					by = (by + centreY);
HXDLIN(  24)					cx = (cx + centreX);
HXDLIN(  24)					cy = (cy + centreY);
HXDLIN(  24)					dx = (dx + centreX);
HXDLIN(  24)					dy = (dy + centreY);
            				}
HXDLIN(  24)				{
HXLINE(  24)					Float bu = ((Float)1.);
HXDLIN(  24)					Float bv = ((Float)0.);
HXDLIN(  24)					Float cu = ((Float)1.);
HXDLIN(  24)					Float cv = ((Float)1.);
HXDLIN(  24)					Float du = ((Float)0.);
HXDLIN(  24)					Float dv = ((Float)1.);
HXDLIN(  24)					{
HXLINE(  24)						Float au = ((Float)0.);
HXDLIN(  24)						Float av = ((Float)0.);
HXDLIN(  24)						Float bu1 = bu;
HXDLIN(  24)						Float bv1 = bv;
HXDLIN(  24)						bool hasUndo = false;
HXDLIN(  24)						Float temp6 = au;
HXLINE( 422)						au = bu1;
HXLINE( 423)						bu1 = temp6;
HXLINE( 424)						temp6 = av;
HXLINE( 425)						av = bv1;
HXLINE( 426)						bv1 = temp6;
HXLINE(  24)						Float bcx = (bx - dx);
HXDLIN(  24)						Float bcy = (by - dy);
HXDLIN(  24)						Float acx = (ax - dx);
HXDLIN(  24)						Float acy = (ay - dy);
HXDLIN(  24)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  24)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  24)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  24)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  24)						 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  24)						if ((ax > bx)) {
HXLINE(  24)							if ((ax > dx)) {
HXLINE(  24)								int min;
HXDLIN(  24)								if ((bx > dx)) {
HXLINE(  24)									min = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  24)									min = ::Math_obj::floor(bx);
            								}
HXDLIN(  24)								int ii_min8 = min;
HXDLIN(  24)								int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN(  24)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            							else {
HXLINE(  24)								int ii_min9 = ::Math_obj::floor(bx);
HXDLIN(  24)								int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN(  24)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            						}
            						else {
HXLINE(  24)							if ((bx > dx)) {
HXLINE(  24)								int min1;
HXDLIN(  24)								if ((ax > dx)) {
HXLINE(  24)									min1 = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  24)									min1 = ::Math_obj::ceil(ax);
            								}
HXDLIN(  24)								int ii_min10 = min1;
HXDLIN(  24)								int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN(  24)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            							else {
HXLINE(  24)								int ii_min11 = ::Math_obj::floor(ax);
HXDLIN(  24)								int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN(  24)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            						}
HXDLIN(  24)						 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  24)						if ((ay > by)) {
HXLINE(  24)							if ((ay > dy)) {
HXLINE(  24)								int min2;
HXDLIN(  24)								if ((by > dy)) {
HXLINE(  24)									min2 = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  24)									min2 = ::Math_obj::floor(by);
            								}
HXDLIN(  24)								int ii_min12 = min2;
HXDLIN(  24)								int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN(  24)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            							else {
HXLINE(  24)								int ii_min13 = ::Math_obj::floor(by);
HXDLIN(  24)								int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN(  24)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            						}
            						else {
HXLINE(  24)							if ((by > dy)) {
HXLINE(  24)								int min3;
HXDLIN(  24)								if ((ay > dy)) {
HXLINE(  24)									min3 = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  24)									min3 = ::Math_obj::ceil(ay);
            								}
HXDLIN(  24)								int ii_min14 = min3;
HXDLIN(  24)								int ii_max14 = ::Math_obj::ceil(by);
HXDLIN(  24)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            							else {
HXLINE(  24)								int ii_min15 = ::Math_obj::floor(ay);
HXDLIN(  24)								int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN(  24)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            						}
HXDLIN(  24)						 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  24)						if (hasUndo) {
HXLINE(  24)							int width2 = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  24)							int height2 = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  24)							 ::Dynamic imageType2 = null();
HXDLIN(  24)							 ::pi_xy::ImageStruct this52 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  24)							if (::hx::IsNull( imageType2 )) {
HXLINE(  54)								imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  24)							::Dynamic undoImage1;
HXDLIN(  24)							switch((int)(( (int)(imageType2) ))){
            								case (int)0: {
HXLINE(  24)									 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::BytesImg b10 = byt2;
HXDLIN(  24)									{
HXLINE(  24)										b10->width = width2;
HXDLIN(  24)										b10->height = height2;
HXDLIN(  24)										b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  24)										b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN(  24)										{
HXLINE(  24)											int len4 = b10->length;
HXDLIN(  24)											int w4 = 0;
HXDLIN(  24)											{
HXLINE(  24)												int _g40 = 0;
HXDLIN(  24)												int _g41 = b10->height;
HXDLIN(  24)												while((_g40 < _g41)){
HXLINE(  24)													_g40 = (_g40 + 1);
HXDLIN(  24)													int y6 = (_g40 - 1);
HXDLIN(  24)													{
HXLINE(  24)														int _g42 = 0;
HXDLIN(  24)														int _g43 = b10->width;
HXDLIN(  24)														while((_g42 < _g43)){
HXLINE(  24)															_g42 = (_g42 + 1);
HXDLIN(  24)															int x6 = (_g42 - 1);
HXDLIN(  24)															{
HXLINE(  24)																w4 = (w4 + 1);
HXDLIN(  24)																b10->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  24)															{
HXLINE(  24)																w4 = (w4 + 1);
HXDLIN(  24)																b10->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  24)															{
HXLINE(  24)																w4 = (w4 + 1);
HXDLIN(  24)																b10->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  24)															{
HXLINE(  24)																w4 = (w4 + 1);
HXDLIN(  24)																b10->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  24)									undoImage1 = b10;
            								}
            								break;
            								case (int)1: {
HXLINE(  24)									 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::ArrIntImg a9 = arrI2;
HXDLIN(  24)									{
HXLINE(  24)										a9->width = width2;
HXDLIN(  24)										a9->height = height2;
HXDLIN(  24)										a9->data = ::Array_obj< int >::__new(0);
HXDLIN(  24)										a9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  24)										{
HXLINE(  24)											int _g44 = 0;
HXDLIN(  24)											int _g45 = a9->length;
HXDLIN(  24)											while((_g44 < _g45)){
HXLINE(  24)												_g44 = (_g44 + 1);
HXDLIN(  24)												int i24 = (_g44 - 1);
HXDLIN(  24)												a9->data[i24] = 0;
            											}
            										}
            									}
HXDLIN(  24)									undoImage1 = a9;
            								}
            								break;
            								case (int)2: {
HXLINE(  24)									 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::U32ArrImg b15 = u32a2;
HXDLIN(  24)									{
HXLINE(  24)										b15->width = width2;
HXDLIN(  24)										b15->height = height2;
HXDLIN(  24)										b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  24)										int size2 = (b15->length * 4);
HXDLIN(  24)										b15->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  24)										{
HXLINE(  24)											int _g46 = 0;
HXDLIN(  24)											int _g47 = b15->length;
HXDLIN(  24)											while((_g46 < _g47)){
HXLINE(  24)												_g46 = (_g46 + 1);
HXDLIN(  24)												int i25 = (_g46 - 1);
HXDLIN(  24)												{
HXLINE(  24)													 ::haxe::io::ArrayBufferViewImpl this53 = b15->data;
HXDLIN(  24)													bool undoImage2;
HXDLIN(  24)													if ((i25 >= 0)) {
HXLINE(  24)														undoImage2 = (i25 < (this53->byteLength >> 2));
            													}
            													else {
HXLINE(  24)														undoImage2 = false;
            													}
HXDLIN(  24)													if (undoImage2) {
HXLINE(  24)														 ::haxe::io::Bytes _this2 = this53->bytes;
HXDLIN(  24)														int pos2 = ((i25 << 2) + this53->byteOffset);
HXDLIN(  24)														_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  24)														_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  24)														_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  24)														_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  24)									undoImage1 = b15;
            								}
            								break;
            								case (int)3: {
HXLINE(  24)									 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::VecIntImg v2 = vec2;
HXDLIN(  24)									{
HXLINE(  24)										v2->width = width2;
HXDLIN(  24)										v2->height = height2;
HXDLIN(  24)										v2->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  24)										v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  24)										{
HXLINE(  24)											int _g48 = 0;
HXDLIN(  24)											int _g49 = v2->length;
HXDLIN(  24)											while((_g48 < _g49)){
HXLINE(  24)												_g48 = (_g48 + 1);
HXDLIN(  24)												int i26 = (_g48 - 1);
HXDLIN(  24)												v2->data->__unsafe_set(i26,0);
            											}
            										}
            									}
HXDLIN(  24)									undoImage1 = v2;
            								}
            								break;
            								case (int)4: {
HXLINE(  24)									 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::StackIntImg b16 = sInt2;
HXDLIN(  24)									{
HXLINE(  24)										b16->width = width2;
HXDLIN(  24)										b16->height = height2;
HXDLIN(  24)										b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  24)										b16->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  24)										{
HXLINE(  24)											int len5 = b16->length;
HXDLIN(  24)											 ::haxe::ds::GenericStack_Int d2 = b16->data;
HXDLIN(  24)											if (::hx::IsNull( d2->head )) {
HXLINE(  24)												int _g50 = 0;
HXDLIN(  24)												int _g51 = len5;
HXDLIN(  24)												while((_g50 < _g51)){
HXLINE(  24)													_g50 = (_g50 + 1);
HXDLIN(  24)													int i27 = (_g50 - 1);
HXDLIN(  24)													d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            												}
            											}
            											else {
HXLINE(  24)												int _g52 = 0;
HXDLIN(  24)												int _g53 = len5;
HXDLIN(  24)												while((_g52 < _g53)){
HXLINE(  24)													_g52 = (_g52 + 1);
HXDLIN(  24)													int i28 = (_g52 - 1);
HXDLIN(  24)													{
HXLINE(  24)														 ::haxe::ds::GenericCell_Int l2 = b16->data->head;
HXDLIN(  24)														 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  24)														{
HXLINE(  24)															int _g54 = 0;
HXDLIN(  24)															int _g55 = i28;
HXDLIN(  24)															while((_g54 < _g55)){
HXLINE(  24)																_g54 = (_g54 + 1);
HXDLIN(  24)																int i29 = (_g54 - 1);
HXLINE( 345)																prev2 = l2;
HXLINE( 346)																l2 = l2->next;
            															}
            														}
HXLINE(  24)														if (::hx::IsNull( prev2 )) {
HXLINE(  24)															b16->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  24)															l2 = null();
            														}
            														else {
HXLINE(  24)															prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  24)															l2 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  24)									undoImage1 = b16;
            								}
            								break;
            							}
HXDLIN(  24)							this52->image = undoImage1;
HXDLIN(  24)							this52->width = width2;
HXDLIN(  24)							this52->height = height2;
HXDLIN(  24)							this52->imageType = ( (int)(imageType2) );
HXDLIN(  24)							undoImage = this52;
HXDLIN(  24)							{
HXLINE(  24)								int rectLeft = xIter3->start;
HXDLIN(  24)								int rectTop = yIter3->start;
HXDLIN(  24)								int rectRight = xIter3->max;
HXDLIN(  24)								bool forceClear = false;
HXDLIN(  24)								{
HXLINE(  24)									int _g56 = rectTop;
HXDLIN(  24)									int _g57 = yIter3->max;
HXDLIN(  24)									while((_g56 < _g57)){
HXLINE(  24)										_g56 = (_g56 + 1);
HXDLIN(  24)										int dy1 = (_g56 - 1);
HXDLIN(  24)										{
HXLINE(  24)											int _g58 = rectLeft;
HXDLIN(  24)											int _g59 = rectRight;
HXDLIN(  24)											while((_g58 < _g59)){
HXLINE(  24)												_g58 = (_g58 + 1);
HXDLIN(  24)												int dx1 = (_g58 - 1);
HXDLIN(  24)												::Dynamic this54 = this51->image;
HXDLIN(  24)												int index4;
HXDLIN(  24)												if (this51->useVirtualPos) {
HXLINE(  24)													index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this51->virtualY) * ( (Float)(this51->width) )) + dx1) - this51->virtualX));
            												}
            												else {
HXLINE(  24)													index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this51->width) + dx1)) ));
            												}
HXDLIN(  24)												int c4 = ::iterMagic::Iimg_obj::get(this54,index4);
HXDLIN(  24)												int col;
HXDLIN(  24)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)													col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE(  24)													col = c4;
            												}
HXDLIN(  24)												bool _hx_tmp20;
HXDLIN(  24)												if (this51->useMask) {
HXLINE(  24)													_hx_tmp20 = ::hx::IsNotNull( this51->mask );
            												}
            												else {
HXLINE(  24)													_hx_tmp20 = false;
            												}
HXDLIN(  24)												if (_hx_tmp20) {
HXLINE(  24)													 ::pi_xy::ImageStruct this55 = this51->mask;
HXDLIN(  24)													::Dynamic this56 = this55->image;
HXDLIN(  24)													int index5;
HXDLIN(  24)													if (this55->useVirtualPos) {
HXLINE(  24)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this55->virtualY) * ( (Float)(this55->width) )) + dx1) - this55->virtualX));
            													}
            													else {
HXLINE(  24)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this55->width) + dx1)) ));
            													}
HXDLIN(  24)													int c5 = ::iterMagic::Iimg_obj::get(this56,index5);
HXDLIN(  24)													int v3;
HXDLIN(  24)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)														v3 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXLINE(  24)														v3 = c5;
            													}
HXDLIN(  24)													int maskPixel = v3;
HXDLIN(  24)													int this57 = col;
HXDLIN(  24)													if ((maskPixel == 0)) {
HXLINE(  24)														col = this57;
            													}
            													else {
HXLINE(  24)														Float m0;
HXDLIN(  24)														int this58 = ((maskPixel >> 24) & 255);
HXDLIN(  24)														if ((this58 == 0)) {
HXLINE(  24)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															m0 = (( (Float)(this58) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float m1;
HXDLIN(  24)														int this59 = ((maskPixel >> 16) & 255);
HXDLIN(  24)														if ((this59 == 0)) {
HXLINE(  24)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															m1 = (( (Float)(this59) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float m2;
HXDLIN(  24)														int this60 = ((maskPixel >> 8) & 255);
HXDLIN(  24)														if ((this60 == 0)) {
HXLINE(  24)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															m2 = (( (Float)(this60) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float m3;
HXDLIN(  24)														int this61 = (maskPixel & 255);
HXDLIN(  24)														if ((this61 == 0)) {
HXLINE(  24)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															m3 = (( (Float)(this61) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this57 >> 24) & 255)) )));
HXDLIN(  24)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this57 >> 16) & 255)) )));
HXDLIN(  24)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this57 >> 8) & 255)) )));
HXDLIN(  24)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this57 & 255)) )));
HXDLIN(  24)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  24)												if ((col != 0)) {
HXLINE(  24)													int x7 = (dx1 - rectLeft);
HXDLIN(  24)													int y7 = (dy1 - rectTop);
HXDLIN(  24)													int c6 = col;
HXDLIN(  24)													bool _hx_tmp21;
HXDLIN(  24)													if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  24)														_hx_tmp21 = undoImage->transparent;
            													}
            													else {
HXLINE(  24)														_hx_tmp21 = false;
            													}
HXDLIN(  24)													if (_hx_tmp21) {
HXLINE(  24)														int location4;
HXDLIN(  24)														if (undoImage->useVirtualPos) {
HXLINE(  24)															location4 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x7) - undoImage->virtualX));
            														}
            														else {
HXLINE(  24)															location4 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage->width) + x7)) ));
            														}
HXDLIN(  24)														int this62 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN(  24)														int this63;
HXDLIN(  24)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)															this63 = ((((((this62 >> 24) & 255) << 24) | ((this62 & 255) << 16)) | (((this62 >> 8) & 255) << 8)) | ((this62 >> 16) & 255));
            														}
            														else {
HXLINE(  24)															this63 = this62;
            														}
HXDLIN(  24)														Float a14;
HXDLIN(  24)														int this64 = ((this63 >> 24) & 255);
HXDLIN(  24)														if ((this64 == 0)) {
HXLINE(  24)															a14 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															a14 = (( (Float)(this64) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float r14;
HXDLIN(  24)														int this65 = ((this63 >> 16) & 255);
HXDLIN(  24)														if ((this65 == 0)) {
HXLINE(  24)															r14 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															r14 = (( (Float)(this65) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float g14;
HXDLIN(  24)														int this66 = ((this63 >> 8) & 255);
HXDLIN(  24)														if ((this66 == 0)) {
HXLINE(  24)															g14 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															g14 = (( (Float)(this66) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float b17;
HXDLIN(  24)														int this67 = (this63 & 255);
HXDLIN(  24)														if ((this67 == 0)) {
HXLINE(  24)															b17 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															b17 = (( (Float)(this67) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float a24;
HXDLIN(  24)														int this68 = ((col >> 24) & 255);
HXDLIN(  24)														if ((this68 == 0)) {
HXLINE(  24)															a24 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															a24 = (( (Float)(this68) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float r24;
HXDLIN(  24)														int this69 = ((col >> 16) & 255);
HXDLIN(  24)														if ((this69 == 0)) {
HXLINE(  24)															r24 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															r24 = (( (Float)(this69) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float g24;
HXDLIN(  24)														int this70 = ((col >> 8) & 255);
HXDLIN(  24)														if ((this70 == 0)) {
HXLINE(  24)															g24 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															g24 = (( (Float)(this70) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float b25;
HXDLIN(  24)														int this71 = (col & 255);
HXDLIN(  24)														if ((this71 == 0)) {
HXLINE(  24)															b25 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															b25 = (( (Float)(this71) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  24)														int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  24)														int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  24)														int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a34) + (b25 * a24))));
HXDLIN(  24)														int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  24)														int blended4 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b18);
HXDLIN(  24)														{
HXLINE(  24)															int _hx_tmp22;
HXDLIN(  24)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																_hx_tmp22 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            															}
            															else {
HXLINE(  24)																_hx_tmp22 = blended4;
            															}
HXDLIN(  24)															::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp22);
            														}
            													}
            													else {
HXLINE(  24)														::Dynamic this72 = undoImage->image;
HXDLIN(  24)														int index6;
HXDLIN(  24)														if (undoImage->useVirtualPos) {
HXLINE(  24)															index6 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x7) - undoImage->virtualX));
            														}
            														else {
HXLINE(  24)															index6 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage->width) + x7)) ));
            														}
HXDLIN(  24)														int _hx_tmp23;
HXDLIN(  24)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)															_hx_tmp23 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXLINE(  24)															_hx_tmp23 = c6;
            														}
HXDLIN(  24)														::iterMagic::Iimg_obj::set(this72,index6,_hx_tmp23);
            													}
            												}
            												else {
HXLINE(  24)													if (forceClear) {
HXLINE(  24)														::Dynamic this73 = undoImage->image;
HXDLIN(  24)														int x8 = (dx1 - rectLeft);
HXDLIN(  24)														int y8 = (dy1 - rectTop);
HXDLIN(  24)														int index7;
HXDLIN(  24)														if (undoImage->useVirtualPos) {
HXLINE(  24)															index7 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x8) - undoImage->virtualX));
            														}
            														else {
HXLINE(  24)															index7 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage->width) + x8)) ));
            														}
HXDLIN(  24)														::iterMagic::Iimg_obj::set(this73,index7,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  24)						{
HXLINE(  24)							int _g_min = xIter3->start;
HXDLIN(  24)							int _g_max = xIter3->max;
HXDLIN(  24)							while((_g_min < _g_max)){
HXLINE(  24)								_g_min = (_g_min + 1);
HXDLIN(  24)								int px = (_g_min - 1);
HXDLIN(  24)								Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  24)								{
HXLINE(  24)									int _g_min1 = yIter3->start;
HXDLIN(  24)									int _g_max1 = yIter3->max;
HXDLIN(  24)									while((_g_min1 < _g_max1)){
HXLINE(  24)										_g_min1 = (_g_min1 + 1);
HXDLIN(  24)										int py = (_g_min1 - 1);
HXDLIN(  24)										Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  24)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  24)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  24)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  24)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  24)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  24)										bool _hx_tmp24;
HXDLIN(  24)										bool _hx_tmp25;
HXDLIN(  24)										if ((ratioA >= 0)) {
HXLINE(  24)											_hx_tmp25 = (ratioB >= 0);
            										}
            										else {
HXLINE(  24)											_hx_tmp25 = false;
            										}
HXDLIN(  24)										if (_hx_tmp25) {
HXLINE(  24)											_hx_tmp24 = (ratioC >= 0);
            										}
            										else {
HXLINE(  24)											_hx_tmp24 = false;
            										}
HXDLIN(  24)										if (_hx_tmp24) {
HXLINE(  24)											Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN(  24)											Float v4 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN(  24)											int x9 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  24)											int y9 = ::Std_obj::_hx_int(((v4 * win_height) + win_y));
HXDLIN(  24)											::Dynamic this74 = temp->image;
HXDLIN(  24)											int index8;
HXDLIN(  24)											if (temp->useVirtualPos) {
HXLINE(  24)												index8 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - temp->virtualY) * ( (Float)(temp->width) )) + x9) - temp->virtualX));
            											}
            											else {
HXLINE(  24)												index8 = ::Std_obj::_hx_int(( (Float)(((y9 * temp->width) + x9)) ));
            											}
HXDLIN(  24)											int c7 = ::iterMagic::Iimg_obj::get(this74,index8);
HXDLIN(  24)											int col1;
HXDLIN(  24)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)												col1 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            											}
            											else {
HXLINE(  24)												col1 = c7;
            											}
HXDLIN(  24)											{
HXLINE(  24)												int c8 = col1;
HXDLIN(  24)												bool _hx_tmp26;
HXDLIN(  24)												if ((((c8 >> 24) & 255) < 254)) {
HXLINE(  24)													_hx_tmp26 = this51->transparent;
            												}
            												else {
HXLINE(  24)													_hx_tmp26 = false;
            												}
HXDLIN(  24)												if (_hx_tmp26) {
HXLINE(  24)													int location5;
HXDLIN(  24)													if (this51->useVirtualPos) {
HXLINE(  24)														location5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this51->virtualY) * ( (Float)(this51->width) )) + px) - this51->virtualX));
            													}
            													else {
HXLINE(  24)														location5 = ::Std_obj::_hx_int(( (Float)(((py * this51->width) + px)) ));
            													}
HXDLIN(  24)													int this75 = ::iterMagic::Iimg_obj::get(this51->image,location5);
HXDLIN(  24)													int this76;
HXDLIN(  24)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)														this76 = ((((((this75 >> 24) & 255) << 24) | ((this75 & 255) << 16)) | (((this75 >> 8) & 255) << 8)) | ((this75 >> 16) & 255));
            													}
            													else {
HXLINE(  24)														this76 = this75;
            													}
HXDLIN(  24)													Float a15;
HXDLIN(  24)													int this77 = ((this76 >> 24) & 255);
HXDLIN(  24)													if ((this77 == 0)) {
HXLINE(  24)														a15 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														a15 = (( (Float)(this77) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float r15;
HXDLIN(  24)													int this78 = ((this76 >> 16) & 255);
HXDLIN(  24)													if ((this78 == 0)) {
HXLINE(  24)														r15 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														r15 = (( (Float)(this78) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float g15;
HXDLIN(  24)													int this79 = ((this76 >> 8) & 255);
HXDLIN(  24)													if ((this79 == 0)) {
HXLINE(  24)														g15 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														g15 = (( (Float)(this79) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float b19;
HXDLIN(  24)													int this80 = (this76 & 255);
HXDLIN(  24)													if ((this80 == 0)) {
HXLINE(  24)														b19 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														b19 = (( (Float)(this80) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float a25;
HXDLIN(  24)													int this81 = ((col1 >> 24) & 255);
HXDLIN(  24)													if ((this81 == 0)) {
HXLINE(  24)														a25 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														a25 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float r25;
HXDLIN(  24)													int this82 = ((col1 >> 16) & 255);
HXDLIN(  24)													if ((this82 == 0)) {
HXLINE(  24)														r25 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														r25 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float g25;
HXDLIN(  24)													int this83 = ((col1 >> 8) & 255);
HXDLIN(  24)													if ((this83 == 0)) {
HXLINE(  24)														g25 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														g25 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float b26;
HXDLIN(  24)													int this84 = (col1 & 255);
HXDLIN(  24)													if ((this84 == 0)) {
HXLINE(  24)														b26 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														b26 = (( (Float)(this84) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  24)													int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  24)													int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  24)													int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a35) + (b26 * a25))));
HXDLIN(  24)													int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  24)													int blended5 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b20);
HXDLIN(  24)													{
HXLINE(  24)														int _hx_tmp27;
HXDLIN(  24)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)															_hx_tmp27 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            														}
            														else {
HXLINE(  24)															_hx_tmp27 = blended5;
            														}
HXDLIN(  24)														::iterMagic::Iimg_obj::set(this51->image,location5,_hx_tmp27);
            													}
            												}
            												else {
HXLINE(  24)													::Dynamic this85 = this51->image;
HXDLIN(  24)													int index9;
HXDLIN(  24)													if (this51->useVirtualPos) {
HXLINE(  24)														index9 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this51->virtualY) * ( (Float)(this51->width) )) + px) - this51->virtualX));
            													}
            													else {
HXLINE(  24)														index9 = ::Std_obj::_hx_int(( (Float)(((py * this51->width) + px)) ));
            													}
HXDLIN(  24)													int _hx_tmp28;
HXDLIN(  24)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)														_hx_tmp28 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXLINE(  24)														_hx_tmp28 = c8;
            													}
HXDLIN(  24)													::iterMagic::Iimg_obj::set(this85,index9,_hx_tmp28);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  24)						if ((hasHit == false)) {
HXLINE(  24)							 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx,by,dx,dy,true);
HXDLIN(  24)							if (hasUndo) {
HXLINE(  24)								v5->undoImage = undoImage;
HXDLIN(  24)								v5->undoX = xIter3->start;
HXDLIN(  24)								v5->undoY = yIter3->start;
            							}
            						}
            					}
HXDLIN(  24)					{
HXLINE(  24)						Float au1 = bu;
HXDLIN(  24)						Float av1 = bv;
HXDLIN(  24)						Float bu2 = cu;
HXDLIN(  24)						Float bv2 = cv;
HXDLIN(  24)						bool hasUndo1 = false;
HXDLIN(  24)						Float temp7 = au1;
HXLINE( 422)						au1 = bu2;
HXLINE( 423)						bu2 = temp7;
HXLINE( 424)						temp7 = av1;
HXLINE( 425)						av1 = bv2;
HXLINE( 426)						bv2 = temp7;
HXLINE(  24)						Float bcx1 = (cx - dx);
HXDLIN(  24)						Float bcy1 = (cy - dy);
HXDLIN(  24)						Float acx1 = (bx - dx);
HXDLIN(  24)						Float acy1 = (by - dy);
HXDLIN(  24)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  24)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  24)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  24)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  24)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  24)						if ((bx > cx)) {
HXLINE(  24)							if ((bx > dx)) {
HXLINE(  24)								int min4;
HXDLIN(  24)								if ((cx > dx)) {
HXLINE(  24)									min4 = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  24)									min4 = ::Math_obj::floor(cx);
            								}
HXDLIN(  24)								int ii_min16 = min4;
HXDLIN(  24)								int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN(  24)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            							}
            							else {
HXLINE(  24)								int ii_min17 = ::Math_obj::floor(cx);
HXDLIN(  24)								int ii_max17 = ::Math_obj::ceil(dx);
HXDLIN(  24)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            							}
            						}
            						else {
HXLINE(  24)							if ((cx > dx)) {
HXLINE(  24)								int min5;
HXDLIN(  24)								if ((bx > dx)) {
HXLINE(  24)									min5 = ::Math_obj::floor(dx);
            								}
            								else {
HXLINE(  24)									min5 = ::Math_obj::ceil(bx);
            								}
HXDLIN(  24)								int ii_min18 = min5;
HXDLIN(  24)								int ii_max18 = ::Math_obj::ceil(cx);
HXDLIN(  24)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            							}
            							else {
HXLINE(  24)								int ii_min19 = ::Math_obj::floor(bx);
HXDLIN(  24)								int ii_max19 = ::Math_obj::ceil(dx);
HXDLIN(  24)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            							}
            						}
HXDLIN(  24)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  24)						if ((by > cy)) {
HXLINE(  24)							if ((by > dy)) {
HXLINE(  24)								int min6;
HXDLIN(  24)								if ((cy > dy)) {
HXLINE(  24)									min6 = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  24)									min6 = ::Math_obj::floor(cy);
            								}
HXDLIN(  24)								int ii_min20 = min6;
HXDLIN(  24)								int ii_max20 = ::Math_obj::ceil(by);
HXDLIN(  24)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            							}
            							else {
HXLINE(  24)								int ii_min21 = ::Math_obj::floor(cy);
HXDLIN(  24)								int ii_max21 = ::Math_obj::ceil(dy);
HXDLIN(  24)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            							}
            						}
            						else {
HXLINE(  24)							if ((cy > dy)) {
HXLINE(  24)								int min7;
HXDLIN(  24)								if ((by > dy)) {
HXLINE(  24)									min7 = ::Math_obj::floor(dy);
            								}
            								else {
HXLINE(  24)									min7 = ::Math_obj::ceil(by);
            								}
HXDLIN(  24)								int ii_min22 = min7;
HXDLIN(  24)								int ii_max22 = ::Math_obj::ceil(cy);
HXDLIN(  24)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            							}
            							else {
HXLINE(  24)								int ii_min23 = ::Math_obj::floor(by);
HXDLIN(  24)								int ii_max23 = ::Math_obj::ceil(dy);
HXDLIN(  24)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            							}
            						}
HXDLIN(  24)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  24)						if (hasUndo1) {
HXLINE(  24)							int width3 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  24)							int height3 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  24)							 ::Dynamic imageType3 = null();
HXDLIN(  24)							 ::pi_xy::ImageStruct this86 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  24)							if (::hx::IsNull( imageType3 )) {
HXLINE(  54)								imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  24)							::Dynamic undoImage4;
HXDLIN(  24)							switch((int)(( (int)(imageType3) ))){
            								case (int)0: {
HXLINE(  24)									 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::BytesImg b27 = byt3;
HXDLIN(  24)									{
HXLINE(  24)										b27->width = width3;
HXDLIN(  24)										b27->height = height3;
HXDLIN(  24)										b27->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  24)										b27->data = ::haxe::io::Bytes_obj::alloc((b27->length * 4));
HXDLIN(  24)										{
HXLINE(  24)											int len6 = b27->length;
HXDLIN(  24)											int w5 = 0;
HXDLIN(  24)											{
HXLINE(  24)												int _g60 = 0;
HXDLIN(  24)												int _g61 = b27->height;
HXDLIN(  24)												while((_g60 < _g61)){
HXLINE(  24)													_g60 = (_g60 + 1);
HXDLIN(  24)													int y10 = (_g60 - 1);
HXDLIN(  24)													{
HXLINE(  24)														int _g62 = 0;
HXDLIN(  24)														int _g63 = b27->width;
HXDLIN(  24)														while((_g62 < _g63)){
HXLINE(  24)															_g62 = (_g62 + 1);
HXDLIN(  24)															int x10 = (_g62 - 1);
HXDLIN(  24)															{
HXLINE(  24)																w5 = (w5 + 1);
HXDLIN(  24)																b27->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  24)															{
HXLINE(  24)																w5 = (w5 + 1);
HXDLIN(  24)																b27->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  24)															{
HXLINE(  24)																w5 = (w5 + 1);
HXDLIN(  24)																b27->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  24)															{
HXLINE(  24)																w5 = (w5 + 1);
HXDLIN(  24)																b27->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  24)									undoImage4 = b27;
            								}
            								break;
            								case (int)1: {
HXLINE(  24)									 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::ArrIntImg a17 = arrI3;
HXDLIN(  24)									{
HXLINE(  24)										a17->width = width3;
HXDLIN(  24)										a17->height = height3;
HXDLIN(  24)										a17->data = ::Array_obj< int >::__new(0);
HXDLIN(  24)										a17->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  24)										{
HXLINE(  24)											int _g64 = 0;
HXDLIN(  24)											int _g65 = a17->length;
HXDLIN(  24)											while((_g64 < _g65)){
HXLINE(  24)												_g64 = (_g64 + 1);
HXDLIN(  24)												int i30 = (_g64 - 1);
HXDLIN(  24)												a17->data[i30] = 0;
            											}
            										}
            									}
HXDLIN(  24)									undoImage4 = a17;
            								}
            								break;
            								case (int)2: {
HXLINE(  24)									 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::U32ArrImg b28 = u32a3;
HXDLIN(  24)									{
HXLINE(  24)										b28->width = width3;
HXDLIN(  24)										b28->height = height3;
HXDLIN(  24)										b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  24)										int size3 = (b28->length * 4);
HXDLIN(  24)										b28->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  24)										{
HXLINE(  24)											int _g66 = 0;
HXDLIN(  24)											int _g67 = b28->length;
HXDLIN(  24)											while((_g66 < _g67)){
HXLINE(  24)												_g66 = (_g66 + 1);
HXDLIN(  24)												int i31 = (_g66 - 1);
HXDLIN(  24)												{
HXLINE(  24)													 ::haxe::io::ArrayBufferViewImpl this87 = b28->data;
HXDLIN(  24)													bool undoImage5;
HXDLIN(  24)													if ((i31 >= 0)) {
HXLINE(  24)														undoImage5 = (i31 < (this87->byteLength >> 2));
            													}
            													else {
HXLINE(  24)														undoImage5 = false;
            													}
HXDLIN(  24)													if (undoImage5) {
HXLINE(  24)														 ::haxe::io::Bytes _this3 = this87->bytes;
HXDLIN(  24)														int pos3 = ((i31 << 2) + this87->byteOffset);
HXDLIN(  24)														_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  24)														_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  24)														_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  24)														_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  24)									undoImage4 = b28;
            								}
            								break;
            								case (int)3: {
HXLINE(  24)									 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::VecIntImg v6 = vec3;
HXDLIN(  24)									{
HXLINE(  24)										v6->width = width3;
HXDLIN(  24)										v6->height = height3;
HXDLIN(  24)										v6->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  24)										v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN(  24)										{
HXLINE(  24)											int _g68 = 0;
HXDLIN(  24)											int _g69 = v6->length;
HXDLIN(  24)											while((_g68 < _g69)){
HXLINE(  24)												_g68 = (_g68 + 1);
HXDLIN(  24)												int i32 = (_g68 - 1);
HXDLIN(  24)												v6->data->__unsafe_set(i32,0);
            											}
            										}
            									}
HXDLIN(  24)									undoImage4 = v6;
            								}
            								break;
            								case (int)4: {
HXLINE(  24)									 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)									 ::iterMagic::StackIntImg b29 = sInt3;
HXDLIN(  24)									{
HXLINE(  24)										b29->width = width3;
HXDLIN(  24)										b29->height = height3;
HXDLIN(  24)										b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  24)										b29->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  24)										{
HXLINE(  24)											int len7 = b29->length;
HXDLIN(  24)											 ::haxe::ds::GenericStack_Int d3 = b29->data;
HXDLIN(  24)											if (::hx::IsNull( d3->head )) {
HXLINE(  24)												int _g70 = 0;
HXDLIN(  24)												int _g71 = len7;
HXDLIN(  24)												while((_g70 < _g71)){
HXLINE(  24)													_g70 = (_g70 + 1);
HXDLIN(  24)													int i33 = (_g70 - 1);
HXDLIN(  24)													d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            												}
            											}
            											else {
HXLINE(  24)												int _g72 = 0;
HXDLIN(  24)												int _g73 = len7;
HXDLIN(  24)												while((_g72 < _g73)){
HXLINE(  24)													_g72 = (_g72 + 1);
HXDLIN(  24)													int i34 = (_g72 - 1);
HXDLIN(  24)													{
HXLINE(  24)														 ::haxe::ds::GenericCell_Int l3 = b29->data->head;
HXDLIN(  24)														 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  24)														{
HXLINE(  24)															int _g74 = 0;
HXDLIN(  24)															int _g75 = i34;
HXDLIN(  24)															while((_g74 < _g75)){
HXLINE(  24)																_g74 = (_g74 + 1);
HXDLIN(  24)																int i35 = (_g74 - 1);
HXLINE( 345)																prev3 = l3;
HXLINE( 346)																l3 = l3->next;
            															}
            														}
HXLINE(  24)														if (::hx::IsNull( prev3 )) {
HXLINE(  24)															b29->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  24)															l3 = null();
            														}
            														else {
HXLINE(  24)															prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  24)															l3 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  24)									undoImage4 = b29;
            								}
            								break;
            							}
HXDLIN(  24)							this86->image = undoImage4;
HXDLIN(  24)							this86->width = width3;
HXDLIN(  24)							this86->height = height3;
HXDLIN(  24)							this86->imageType = ( (int)(imageType3) );
HXDLIN(  24)							undoImage3 = this86;
HXDLIN(  24)							{
HXLINE(  24)								int rectLeft1 = xIter31->start;
HXDLIN(  24)								int rectTop1 = yIter31->start;
HXDLIN(  24)								int rectRight1 = xIter31->max;
HXDLIN(  24)								bool forceClear1 = false;
HXDLIN(  24)								{
HXLINE(  24)									int _g76 = rectTop1;
HXDLIN(  24)									int _g77 = yIter31->max;
HXDLIN(  24)									while((_g76 < _g77)){
HXLINE(  24)										_g76 = (_g76 + 1);
HXDLIN(  24)										int dy2 = (_g76 - 1);
HXDLIN(  24)										{
HXLINE(  24)											int _g78 = rectLeft1;
HXDLIN(  24)											int _g79 = rectRight1;
HXDLIN(  24)											while((_g78 < _g79)){
HXLINE(  24)												_g78 = (_g78 + 1);
HXDLIN(  24)												int dx2 = (_g78 - 1);
HXDLIN(  24)												::Dynamic this88 = this51->image;
HXDLIN(  24)												int index10;
HXDLIN(  24)												if (this51->useVirtualPos) {
HXLINE(  24)													index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this51->virtualY) * ( (Float)(this51->width) )) + dx2) - this51->virtualX));
            												}
            												else {
HXLINE(  24)													index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this51->width) + dx2)) ));
            												}
HXDLIN(  24)												int c9 = ::iterMagic::Iimg_obj::get(this88,index10);
HXDLIN(  24)												int col2;
HXDLIN(  24)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)													col2 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE(  24)													col2 = c9;
            												}
HXDLIN(  24)												bool _hx_tmp29;
HXDLIN(  24)												if (this51->useMask) {
HXLINE(  24)													_hx_tmp29 = ::hx::IsNotNull( this51->mask );
            												}
            												else {
HXLINE(  24)													_hx_tmp29 = false;
            												}
HXDLIN(  24)												if (_hx_tmp29) {
HXLINE(  24)													 ::pi_xy::ImageStruct this89 = this51->mask;
HXDLIN(  24)													::Dynamic this90 = this89->image;
HXDLIN(  24)													int index11;
HXDLIN(  24)													if (this89->useVirtualPos) {
HXLINE(  24)														index11 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this89->virtualY) * ( (Float)(this89->width) )) + dx2) - this89->virtualX));
            													}
            													else {
HXLINE(  24)														index11 = ::Std_obj::_hx_int(( (Float)(((dy2 * this89->width) + dx2)) ));
            													}
HXDLIN(  24)													int c10 = ::iterMagic::Iimg_obj::get(this90,index11);
HXDLIN(  24)													int v7;
HXDLIN(  24)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)														v7 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            													}
            													else {
HXLINE(  24)														v7 = c10;
            													}
HXDLIN(  24)													int maskPixel1 = v7;
HXDLIN(  24)													int this91 = col2;
HXDLIN(  24)													if ((maskPixel1 == 0)) {
HXLINE(  24)														col2 = this91;
            													}
            													else {
HXLINE(  24)														Float m01;
HXDLIN(  24)														int this92 = ((maskPixel1 >> 24) & 255);
HXDLIN(  24)														if ((this92 == 0)) {
HXLINE(  24)															m01 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															m01 = (( (Float)(this92) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float m11;
HXDLIN(  24)														int this93 = ((maskPixel1 >> 16) & 255);
HXDLIN(  24)														if ((this93 == 0)) {
HXLINE(  24)															m11 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															m11 = (( (Float)(this93) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float m21;
HXDLIN(  24)														int this94 = ((maskPixel1 >> 8) & 255);
HXDLIN(  24)														if ((this94 == 0)) {
HXLINE(  24)															m21 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															m21 = (( (Float)(this94) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float m31;
HXDLIN(  24)														int this95 = (maskPixel1 & 255);
HXDLIN(  24)														if ((this95 == 0)) {
HXLINE(  24)															m31 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															m31 = (( (Float)(this95) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this91 >> 24) & 255)) )));
HXDLIN(  24)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this91 >> 16) & 255)) )));
HXDLIN(  24)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this91 >> 8) & 255)) )));
HXDLIN(  24)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this91 & 255)) )));
HXDLIN(  24)														col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  24)												if ((col2 != 0)) {
HXLINE(  24)													int x11 = (dx2 - rectLeft1);
HXDLIN(  24)													int y11 = (dy2 - rectTop1);
HXDLIN(  24)													int c11 = col2;
HXDLIN(  24)													bool _hx_tmp30;
HXDLIN(  24)													if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  24)														_hx_tmp30 = undoImage3->transparent;
            													}
            													else {
HXLINE(  24)														_hx_tmp30 = false;
            													}
HXDLIN(  24)													if (_hx_tmp30) {
HXLINE(  24)														int location6;
HXDLIN(  24)														if (undoImage3->useVirtualPos) {
HXLINE(  24)															location6 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x11) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  24)															location6 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage3->width) + x11)) ));
            														}
HXDLIN(  24)														int this96 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN(  24)														int this97;
HXDLIN(  24)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)															this97 = ((((((this96 >> 24) & 255) << 24) | ((this96 & 255) << 16)) | (((this96 >> 8) & 255) << 8)) | ((this96 >> 16) & 255));
            														}
            														else {
HXLINE(  24)															this97 = this96;
            														}
HXDLIN(  24)														Float a18;
HXDLIN(  24)														int this98 = ((this97 >> 24) & 255);
HXDLIN(  24)														if ((this98 == 0)) {
HXLINE(  24)															a18 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															a18 = (( (Float)(this98) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float r16;
HXDLIN(  24)														int this99 = ((this97 >> 16) & 255);
HXDLIN(  24)														if ((this99 == 0)) {
HXLINE(  24)															r16 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															r16 = (( (Float)(this99) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float g16;
HXDLIN(  24)														int this100 = ((this97 >> 8) & 255);
HXDLIN(  24)														if ((this100 == 0)) {
HXLINE(  24)															g16 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															g16 = (( (Float)(this100) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float b110;
HXDLIN(  24)														int this101 = (this97 & 255);
HXDLIN(  24)														if ((this101 == 0)) {
HXLINE(  24)															b110 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															b110 = (( (Float)(this101) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float a26;
HXDLIN(  24)														int this102 = ((col2 >> 24) & 255);
HXDLIN(  24)														if ((this102 == 0)) {
HXLINE(  24)															a26 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															a26 = (( (Float)(this102) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float r26;
HXDLIN(  24)														int this103 = ((col2 >> 16) & 255);
HXDLIN(  24)														if ((this103 == 0)) {
HXLINE(  24)															r26 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															r26 = (( (Float)(this103) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float g26;
HXDLIN(  24)														int this104 = ((col2 >> 8) & 255);
HXDLIN(  24)														if ((this104 == 0)) {
HXLINE(  24)															g26 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															g26 = (( (Float)(this104) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float b210;
HXDLIN(  24)														int this105 = (col2 & 255);
HXDLIN(  24)														if ((this105 == 0)) {
HXLINE(  24)															b210 = ((Float)0.);
            														}
            														else {
HXLINE(  24)															b210 = (( (Float)(this105) ) / ( (Float)(255) ));
            														}
HXDLIN(  24)														Float a36 = (a18 * (( (Float)(1) ) - a26));
HXDLIN(  24)														int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  24)														int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  24)														int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b210 * a26))));
HXDLIN(  24)														int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  24)														int blended6 = ((((a19 << 24) | (r8 << 16)) | (g8 << 8)) | b30);
HXDLIN(  24)														{
HXLINE(  24)															int _hx_tmp31;
HXDLIN(  24)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																_hx_tmp31 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            															}
            															else {
HXLINE(  24)																_hx_tmp31 = blended6;
            															}
HXDLIN(  24)															::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp31);
            														}
            													}
            													else {
HXLINE(  24)														::Dynamic this106 = undoImage3->image;
HXDLIN(  24)														int index12;
HXDLIN(  24)														if (undoImage3->useVirtualPos) {
HXLINE(  24)															index12 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x11) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  24)															index12 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage3->width) + x11)) ));
            														}
HXDLIN(  24)														int _hx_tmp32;
HXDLIN(  24)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)															_hx_tmp32 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            														}
            														else {
HXLINE(  24)															_hx_tmp32 = c11;
            														}
HXDLIN(  24)														::iterMagic::Iimg_obj::set(this106,index12,_hx_tmp32);
            													}
            												}
            												else {
HXLINE(  24)													if (forceClear1) {
HXLINE(  24)														::Dynamic this107 = undoImage3->image;
HXDLIN(  24)														int x12 = (dx2 - rectLeft1);
HXDLIN(  24)														int y12 = (dy2 - rectTop1);
HXDLIN(  24)														int index13;
HXDLIN(  24)														if (undoImage3->useVirtualPos) {
HXLINE(  24)															index13 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x12) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  24)															index13 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage3->width) + x12)) ));
            														}
HXDLIN(  24)														::iterMagic::Iimg_obj::set(this107,index13,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  24)						{
HXLINE(  24)							int _g_min2 = xIter31->start;
HXDLIN(  24)							int _g_max2 = xIter31->max;
HXDLIN(  24)							while((_g_min2 < _g_max2)){
HXLINE(  24)								_g_min2 = (_g_min2 + 1);
HXDLIN(  24)								int px1 = (_g_min2 - 1);
HXDLIN(  24)								Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN(  24)								{
HXLINE(  24)									int _g_min3 = yIter31->start;
HXDLIN(  24)									int _g_max3 = yIter31->max;
HXDLIN(  24)									while((_g_min3 < _g_max3)){
HXLINE(  24)										_g_min3 = (_g_min3 + 1);
HXDLIN(  24)										int py1 = (_g_min3 - 1);
HXDLIN(  24)										Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN(  24)										Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  24)										Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  24)										Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  24)										Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  24)										Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  24)										bool _hx_tmp33;
HXDLIN(  24)										bool _hx_tmp34;
HXDLIN(  24)										if ((ratioA1 >= 0)) {
HXLINE(  24)											_hx_tmp34 = (ratioB1 >= 0);
            										}
            										else {
HXLINE(  24)											_hx_tmp34 = false;
            										}
HXDLIN(  24)										if (_hx_tmp34) {
HXLINE(  24)											_hx_tmp33 = (ratioC1 >= 0);
            										}
            										else {
HXLINE(  24)											_hx_tmp33 = false;
            										}
HXDLIN(  24)										if (_hx_tmp33) {
HXLINE(  24)											Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN(  24)											Float v8 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN(  24)											int x13 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  24)											int y13 = ::Std_obj::_hx_int(((v8 * win_height) + win_y));
HXDLIN(  24)											::Dynamic this108 = temp->image;
HXDLIN(  24)											int index14;
HXDLIN(  24)											if (temp->useVirtualPos) {
HXLINE(  24)												index14 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - temp->virtualY) * ( (Float)(temp->width) )) + x13) - temp->virtualX));
            											}
            											else {
HXLINE(  24)												index14 = ::Std_obj::_hx_int(( (Float)(((y13 * temp->width) + x13)) ));
            											}
HXDLIN(  24)											int c12 = ::iterMagic::Iimg_obj::get(this108,index14);
HXDLIN(  24)											int col3;
HXDLIN(  24)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)												col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            											}
            											else {
HXLINE(  24)												col3 = c12;
            											}
HXDLIN(  24)											{
HXLINE(  24)												int c13 = col3;
HXDLIN(  24)												bool _hx_tmp35;
HXDLIN(  24)												if ((((c13 >> 24) & 255) < 254)) {
HXLINE(  24)													_hx_tmp35 = this51->transparent;
            												}
            												else {
HXLINE(  24)													_hx_tmp35 = false;
            												}
HXDLIN(  24)												if (_hx_tmp35) {
HXLINE(  24)													int location7;
HXDLIN(  24)													if (this51->useVirtualPos) {
HXLINE(  24)														location7 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this51->virtualY) * ( (Float)(this51->width) )) + px1) - this51->virtualX));
            													}
            													else {
HXLINE(  24)														location7 = ::Std_obj::_hx_int(( (Float)(((py1 * this51->width) + px1)) ));
            													}
HXDLIN(  24)													int this109 = ::iterMagic::Iimg_obj::get(this51->image,location7);
HXDLIN(  24)													int this110;
HXDLIN(  24)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)														this110 = ((((((this109 >> 24) & 255) << 24) | ((this109 & 255) << 16)) | (((this109 >> 8) & 255) << 8)) | ((this109 >> 16) & 255));
            													}
            													else {
HXLINE(  24)														this110 = this109;
            													}
HXDLIN(  24)													Float a110;
HXDLIN(  24)													int this111 = ((this110 >> 24) & 255);
HXDLIN(  24)													if ((this111 == 0)) {
HXLINE(  24)														a110 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														a110 = (( (Float)(this111) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float r17;
HXDLIN(  24)													int this112 = ((this110 >> 16) & 255);
HXDLIN(  24)													if ((this112 == 0)) {
HXLINE(  24)														r17 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														r17 = (( (Float)(this112) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float g17;
HXDLIN(  24)													int this113 = ((this110 >> 8) & 255);
HXDLIN(  24)													if ((this113 == 0)) {
HXLINE(  24)														g17 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														g17 = (( (Float)(this113) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float b111;
HXDLIN(  24)													int this114 = (this110 & 255);
HXDLIN(  24)													if ((this114 == 0)) {
HXLINE(  24)														b111 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														b111 = (( (Float)(this114) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float a27;
HXDLIN(  24)													int this115 = ((col3 >> 24) & 255);
HXDLIN(  24)													if ((this115 == 0)) {
HXLINE(  24)														a27 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														a27 = (( (Float)(this115) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float r27;
HXDLIN(  24)													int this116 = ((col3 >> 16) & 255);
HXDLIN(  24)													if ((this116 == 0)) {
HXLINE(  24)														r27 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														r27 = (( (Float)(this116) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float g27;
HXDLIN(  24)													int this117 = ((col3 >> 8) & 255);
HXDLIN(  24)													if ((this117 == 0)) {
HXLINE(  24)														g27 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														g27 = (( (Float)(this117) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float b211;
HXDLIN(  24)													int this118 = (col3 & 255);
HXDLIN(  24)													if ((this118 == 0)) {
HXLINE(  24)														b211 = ((Float)0.);
            													}
            													else {
HXLINE(  24)														b211 = (( (Float)(this118) ) / ( (Float)(255) ));
            													}
HXDLIN(  24)													Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN(  24)													int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  24)													int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  24)													int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b211 * a27))));
HXDLIN(  24)													int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  24)													int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b31);
HXDLIN(  24)													{
HXLINE(  24)														int _hx_tmp36;
HXDLIN(  24)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)															_hx_tmp36 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            														}
            														else {
HXLINE(  24)															_hx_tmp36 = blended7;
            														}
HXDLIN(  24)														::iterMagic::Iimg_obj::set(this51->image,location7,_hx_tmp36);
            													}
            												}
            												else {
HXLINE(  24)													::Dynamic this119 = this51->image;
HXDLIN(  24)													int index15;
HXDLIN(  24)													if (this51->useVirtualPos) {
HXLINE(  24)														index15 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this51->virtualY) * ( (Float)(this51->width) )) + px1) - this51->virtualX));
            													}
            													else {
HXLINE(  24)														index15 = ::Std_obj::_hx_int(( (Float)(((py1 * this51->width) + px1)) ));
            													}
HXDLIN(  24)													int _hx_tmp37;
HXDLIN(  24)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)														_hx_tmp37 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXLINE(  24)														_hx_tmp37 = c13;
            													}
HXDLIN(  24)													::iterMagic::Iimg_obj::set(this119,index15,_hx_tmp37);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  24)						if ((hasHit == false)) {
HXLINE(  24)							 ::pi_xy::algo::HitTri v9 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,cx,cy,dx,dy,true);
HXDLIN(  24)							if (hasUndo1) {
HXLINE(  24)								v9->undoImage = undoImage3;
HXDLIN(  24)								v9->undoX = xIter31->start;
HXDLIN(  24)								v9->undoY = yIter31->start;
            							}
            						}
            					}
HXDLIN(  24)					if ((hasHit == true)) {
HXLINE(  24)						 ::pi_xy::algo::HitQuad v10 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
            					}
            				}
            			}
HXLINE(  25)			{
HXLINE(  25)				int x14 = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  25)				int y14 = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  25)				bool forceClear2 = false;
HXDLIN(  25)				{
HXLINE(  25)					int _g80 = 0;
HXDLIN(  25)					int _g81 = temp2->height;
HXDLIN(  25)					while((_g80 < _g81)){
HXLINE(  25)						_g80 = (_g80 + 1);
HXDLIN(  25)						int dy3 = (_g80 - 1);
HXDLIN(  25)						{
HXLINE(  25)							int _g82 = 0;
HXDLIN(  25)							int _g83 = temp2->width;
HXDLIN(  25)							while((_g82 < _g83)){
HXLINE(  25)								_g82 = (_g82 + 1);
HXDLIN(  25)								int dx3 = (_g82 - 1);
HXDLIN(  25)								::Dynamic this120 = temp2->image;
HXDLIN(  25)								int index16;
HXDLIN(  25)								if (temp2->useVirtualPos) {
HXLINE(  25)									index16 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - temp2->virtualY) * ( (Float)(temp2->width) )) + dx3) - temp2->virtualX));
            								}
            								else {
HXLINE(  25)									index16 = ::Std_obj::_hx_int(( (Float)(((dy3 * temp2->width) + dx3)) ));
            								}
HXDLIN(  25)								int c14 = ::iterMagic::Iimg_obj::get(this120,index16);
HXDLIN(  25)								int col4;
HXDLIN(  25)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)									col4 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            								}
            								else {
HXLINE(  25)									col4 = c14;
            								}
HXDLIN(  25)								bool _hx_tmp38;
HXDLIN(  25)								if (temp2->useMask) {
HXLINE(  25)									_hx_tmp38 = ::hx::IsNotNull( temp2->mask );
            								}
            								else {
HXLINE(  25)									_hx_tmp38 = false;
            								}
HXDLIN(  25)								if (_hx_tmp38) {
HXLINE(  25)									 ::pi_xy::ImageStruct this121 = temp2->mask;
HXDLIN(  25)									::Dynamic this122 = this121->image;
HXDLIN(  25)									int index17;
HXDLIN(  25)									if (this121->useVirtualPos) {
HXLINE(  25)										index17 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this121->virtualY) * ( (Float)(this121->width) )) + dx3) - this121->virtualX));
            									}
            									else {
HXLINE(  25)										index17 = ::Std_obj::_hx_int(( (Float)(((dy3 * this121->width) + dx3)) ));
            									}
HXDLIN(  25)									int c15 = ::iterMagic::Iimg_obj::get(this122,index17);
HXDLIN(  25)									int v11;
HXDLIN(  25)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)										v11 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            									}
            									else {
HXLINE(  25)										v11 = c15;
            									}
HXDLIN(  25)									int maskPixel2 = v11;
HXDLIN(  25)									int this123 = col4;
HXDLIN(  25)									if ((maskPixel2 == 0)) {
HXLINE(  25)										col4 = this123;
            									}
            									else {
HXLINE(  25)										Float m02;
HXDLIN(  25)										int this124 = ((maskPixel2 >> 24) & 255);
HXDLIN(  25)										if ((this124 == 0)) {
HXLINE(  25)											m02 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											m02 = (( (Float)(this124) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float m12;
HXDLIN(  25)										int this125 = ((maskPixel2 >> 16) & 255);
HXDLIN(  25)										if ((this125 == 0)) {
HXLINE(  25)											m12 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											m12 = (( (Float)(this125) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float m22;
HXDLIN(  25)										int this126 = ((maskPixel2 >> 8) & 255);
HXDLIN(  25)										if ((this126 == 0)) {
HXLINE(  25)											m22 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											m22 = (( (Float)(this126) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float m32;
HXDLIN(  25)										int this127 = (maskPixel2 & 255);
HXDLIN(  25)										if ((this127 == 0)) {
HXLINE(  25)											m32 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											m32 = (( (Float)(this127) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this123 >> 24) & 255)) )));
HXDLIN(  25)										int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this123 >> 16) & 255)) )));
HXDLIN(  25)										int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this123 >> 8) & 255)) )));
HXDLIN(  25)										int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this123 & 255)) )));
HXDLIN(  25)										col4 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  25)								if ((col4 != 0)) {
HXLINE(  25)									int x15 = (x14 + dx3);
HXDLIN(  25)									int y15 = (y14 + dy3);
HXDLIN(  25)									int c16 = col4;
HXDLIN(  25)									bool _hx_tmp39;
HXDLIN(  25)									if ((((c16 >> 24) & 255) < 254)) {
HXLINE(  25)										_hx_tmp39 = pixelImage->transparent;
            									}
            									else {
HXLINE(  25)										_hx_tmp39 = false;
            									}
HXDLIN(  25)									if (_hx_tmp39) {
HXLINE(  25)										int location8;
HXDLIN(  25)										if (pixelImage->useVirtualPos) {
HXLINE(  25)											location8 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x15) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  25)											location8 = ::Std_obj::_hx_int(( (Float)(((y15 * pixelImage->width) + x15)) ));
            										}
HXDLIN(  25)										int this128 = ::iterMagic::Iimg_obj::get(pixelImage->image,location8);
HXDLIN(  25)										int this129;
HXDLIN(  25)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)											this129 = ((((((this128 >> 24) & 255) << 24) | ((this128 & 255) << 16)) | (((this128 >> 8) & 255) << 8)) | ((this128 >> 16) & 255));
            										}
            										else {
HXLINE(  25)											this129 = this128;
            										}
HXDLIN(  25)										Float a111;
HXDLIN(  25)										int this130 = ((this129 >> 24) & 255);
HXDLIN(  25)										if ((this130 == 0)) {
HXLINE(  25)											a111 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											a111 = (( (Float)(this130) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float r18;
HXDLIN(  25)										int this131 = ((this129 >> 16) & 255);
HXDLIN(  25)										if ((this131 == 0)) {
HXLINE(  25)											r18 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											r18 = (( (Float)(this131) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float g18;
HXDLIN(  25)										int this132 = ((this129 >> 8) & 255);
HXDLIN(  25)										if ((this132 == 0)) {
HXLINE(  25)											g18 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											g18 = (( (Float)(this132) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float b112;
HXDLIN(  25)										int this133 = (this129 & 255);
HXDLIN(  25)										if ((this133 == 0)) {
HXLINE(  25)											b112 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											b112 = (( (Float)(this133) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float a28;
HXDLIN(  25)										int this134 = ((col4 >> 24) & 255);
HXDLIN(  25)										if ((this134 == 0)) {
HXLINE(  25)											a28 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											a28 = (( (Float)(this134) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float r28;
HXDLIN(  25)										int this135 = ((col4 >> 16) & 255);
HXDLIN(  25)										if ((this135 == 0)) {
HXLINE(  25)											r28 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											r28 = (( (Float)(this135) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float g28;
HXDLIN(  25)										int this136 = ((col4 >> 8) & 255);
HXDLIN(  25)										if ((this136 == 0)) {
HXLINE(  25)											g28 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											g28 = (( (Float)(this136) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float b212;
HXDLIN(  25)										int this137 = (col4 & 255);
HXDLIN(  25)										if ((this137 == 0)) {
HXLINE(  25)											b212 = ((Float)0.);
            										}
            										else {
HXLINE(  25)											b212 = (( (Float)(this137) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float a38 = (a111 * (( (Float)(1) ) - a28));
HXDLIN(  25)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN(  25)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN(  25)										int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a38) + (b212 * a28))));
HXDLIN(  25)										int a29 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN(  25)										int blended8 = ((((a29 << 24) | (r10 << 16)) | (g10 << 8)) | b32);
HXDLIN(  25)										{
HXLINE(  25)											int _hx_tmp40;
HXDLIN(  25)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)												_hx_tmp40 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXLINE(  25)												_hx_tmp40 = blended8;
            											}
HXDLIN(  25)											::iterMagic::Iimg_obj::set(pixelImage->image,location8,_hx_tmp40);
            										}
            									}
            									else {
HXLINE(  25)										::Dynamic this138 = pixelImage->image;
HXDLIN(  25)										int index18;
HXDLIN(  25)										if (pixelImage->useVirtualPos) {
HXLINE(  25)											index18 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x15) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  25)											index18 = ::Std_obj::_hx_int(( (Float)(((y15 * pixelImage->width) + x15)) ));
            										}
HXDLIN(  25)										int _hx_tmp41;
HXDLIN(  25)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)											_hx_tmp41 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            										}
            										else {
HXLINE(  25)											_hx_tmp41 = c16;
            										}
HXDLIN(  25)										::iterMagic::Iimg_obj::set(this138,index18,_hx_tmp41);
            									}
            								}
            								else {
HXLINE(  25)									if (forceClear2) {
HXLINE(  25)										::Dynamic this139 = pixelImage->image;
HXDLIN(  25)										int x16 = (x14 + dx3);
HXDLIN(  25)										int y16 = (y14 + dy3);
HXDLIN(  25)										int index19;
HXDLIN(  25)										if (pixelImage->useVirtualPos) {
HXLINE(  25)											index19 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x16) - pixelImage->virtualX));
            										}
            										else {
HXLINE(  25)											index19 = ::Std_obj::_hx_int(( (Float)(((y16 * pixelImage->width) + x16)) ));
            										}
HXDLIN(  25)										::iterMagic::Iimg_obj::set(this139,index19,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXLINE(  26)			temp = null();
HXLINE(  27)			temp2 = null();
            		}
            		else {
HXLINE(  29)			if ((this->deltaH != ((Float)0.))) {
HXLINE(  30)				 ::pi_xy::ImageStruct this140 = pixelImage;
HXDLIN(  30)				Float x17 = (this->left + this->offX);
HXDLIN(  30)				Float y17 = (this->top + this->offY);
HXDLIN(  30)				Float w6 = this->width;
HXDLIN(  30)				Float h2 = this->height;
HXDLIN(  30)				Float deltaW1 = this->delta;
HXDLIN(  30)				Float deltaH1 = this->deltaH;
HXDLIN(  30)				Float thick2 = this->strokeWidth;
HXDLIN(  30)				int color2 = this->strokeColor;
HXDLIN(  30)				Float h_2 = (( (Float)(::Math_obj::floor((h2 / deltaH1))) ) * deltaH1);
HXDLIN(  30)				Float w_2 = (( (Float)(::Math_obj::floor((w6 / deltaW1))) ) * deltaW1);
HXDLIN(  30)				{
HXLINE(  30)					int _g84 = 0;
HXDLIN(  30)					int _g85 = (::Math_obj::floor((w6 / deltaW1)) + 1);
HXDLIN(  30)					while((_g84 < _g85)){
HXLINE(  30)						_g84 = (_g84 + 1);
HXDLIN(  30)						int i36 = (_g84 - 1);
HXDLIN(  30)						{
HXLINE(  30)							int r_x4 = ::Std_obj::_hx_int(((x17 + (( (Float)(i36) ) * deltaW1)) - (thick2 / ( (Float)(2) ))));
HXDLIN(  30)							int r_y4 = ::Std_obj::_hx_int(y17);
HXDLIN(  30)							int r_w4 = ::Std_obj::_hx_int(thick2);
HXDLIN(  30)							int r_h4 = ::Std_obj::_hx_int(h_2);
HXDLIN(  30)							int xmax4 = ((r_x4 + r_w4) + 1);
HXDLIN(  30)							int ymax4 = ((r_y4 + r_h4) + 1);
HXDLIN(  30)							int ii_min24 = r_x4;
HXDLIN(  30)							int ii_max24 = xmax4;
HXDLIN(  30)							int xRange__start4 = ii_min24;
HXDLIN(  30)							int xRange__max4 = ii_max24;
HXDLIN(  30)							int ii_min25 = r_y4;
HXDLIN(  30)							int ii_max25 = ymax4;
HXDLIN(  30)							int yRange__start4 = ii_min25;
HXDLIN(  30)							int yRange__max4 = ii_max25;
HXDLIN(  30)							int range_x4 = xRange__start4;
HXDLIN(  30)							int range_y4 = (yRange__start4 - 1);
HXDLIN(  30)							int range_xReset4 = range_x4;
HXDLIN(  30)							int range_yReset4 = range_y4;
HXDLIN(  30)							int range_xMax4 = (xRange__max4 - 2);
HXDLIN(  30)							int range_yMax4 = (yRange__max4 - 2);
HXDLIN(  30)							int _this_min4 = 0;
HXDLIN(  30)							int _this_max4 = ::Std_obj::_hx_int(( (Float)(((xRange__max4 - xRange__start4) * (yRange__max4 - yRange__start4))) ));
HXDLIN(  30)							while((_this_min4 < _this_max4)){
HXLINE(  30)								_this_min4 = (_this_min4 + 1);
HXDLIN(  30)								int i37 = (_this_min4 - 1);
HXDLIN(  30)								if ((range_y4 > range_yMax4)) {
HXLINE(  30)									range_y4 = range_yReset4;
HXDLIN(  30)									range_x4 = (range_x4 + 1);
            								}
HXDLIN(  30)								range_y4 = (range_y4 + 1);
HXDLIN(  30)								int i38 = i37;
HXDLIN(  30)								{
HXLINE(  30)									int x18 = range_x4;
HXDLIN(  30)									int y18 = range_y4;
HXDLIN(  30)									int c17 = color2;
HXDLIN(  30)									bool _hx_tmp42;
HXDLIN(  30)									if ((((c17 >> 24) & 255) < 254)) {
HXLINE(  30)										_hx_tmp42 = this140->transparent;
            									}
            									else {
HXLINE(  30)										_hx_tmp42 = false;
            									}
HXDLIN(  30)									if (_hx_tmp42) {
HXLINE(  30)										int location9;
HXDLIN(  30)										if (this140->useVirtualPos) {
HXLINE(  30)											location9 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - this140->virtualY) * ( (Float)(this140->width) )) + x18) - this140->virtualX));
            										}
            										else {
HXLINE(  30)											location9 = ::Std_obj::_hx_int(( (Float)(((y18 * this140->width) + x18)) ));
            										}
HXDLIN(  30)										int this141 = ::iterMagic::Iimg_obj::get(this140->image,location9);
HXDLIN(  30)										int this142;
HXDLIN(  30)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)											this142 = ((((((this141 >> 24) & 255) << 24) | ((this141 & 255) << 16)) | (((this141 >> 8) & 255) << 8)) | ((this141 >> 16) & 255));
            										}
            										else {
HXLINE(  30)											this142 = this141;
            										}
HXDLIN(  30)										Float a112;
HXDLIN(  30)										int this143 = ((this142 >> 24) & 255);
HXDLIN(  30)										if ((this143 == 0)) {
HXLINE(  30)											a112 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											a112 = (( (Float)(this143) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float r19;
HXDLIN(  30)										int this144 = ((this142 >> 16) & 255);
HXDLIN(  30)										if ((this144 == 0)) {
HXLINE(  30)											r19 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											r19 = (( (Float)(this144) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float g19;
HXDLIN(  30)										int this145 = ((this142 >> 8) & 255);
HXDLIN(  30)										if ((this145 == 0)) {
HXLINE(  30)											g19 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											g19 = (( (Float)(this145) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float b113;
HXDLIN(  30)										int this146 = (this142 & 255);
HXDLIN(  30)										if ((this146 == 0)) {
HXLINE(  30)											b113 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											b113 = (( (Float)(this146) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float a210;
HXDLIN(  30)										int this147 = ((color2 >> 24) & 255);
HXDLIN(  30)										if ((this147 == 0)) {
HXLINE(  30)											a210 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											a210 = (( (Float)(this147) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float r29;
HXDLIN(  30)										int this148 = ((color2 >> 16) & 255);
HXDLIN(  30)										if ((this148 == 0)) {
HXLINE(  30)											r29 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											r29 = (( (Float)(this148) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float g29;
HXDLIN(  30)										int this149 = ((color2 >> 8) & 255);
HXDLIN(  30)										if ((this149 == 0)) {
HXLINE(  30)											g29 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											g29 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float b213;
HXDLIN(  30)										int this150 = (color2 & 255);
HXDLIN(  30)										if ((this150 == 0)) {
HXLINE(  30)											b213 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											b213 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float a39 = (a112 * (( (Float)(1) ) - a210));
HXDLIN(  30)										int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN(  30)										int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN(  30)										int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a39) + (b213 * a210))));
HXDLIN(  30)										int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN(  30)										int blended9 = ((((a30 << 24) | (r20 << 16)) | (g20 << 8)) | b33);
HXDLIN(  30)										{
HXLINE(  30)											int _hx_tmp43;
HXDLIN(  30)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)												_hx_tmp43 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            											}
            											else {
HXLINE(  30)												_hx_tmp43 = blended9;
            											}
HXDLIN(  30)											::iterMagic::Iimg_obj::set(this140->image,location9,_hx_tmp43);
            										}
            									}
            									else {
HXLINE(  30)										::Dynamic this151 = this140->image;
HXDLIN(  30)										int index20;
HXDLIN(  30)										if (this140->useVirtualPos) {
HXLINE(  30)											index20 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - this140->virtualY) * ( (Float)(this140->width) )) + x18) - this140->virtualX));
            										}
            										else {
HXLINE(  30)											index20 = ::Std_obj::_hx_int(( (Float)(((y18 * this140->width) + x18)) ));
            										}
HXDLIN(  30)										int _hx_tmp44;
HXDLIN(  30)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)											_hx_tmp44 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            										}
            										else {
HXLINE(  30)											_hx_tmp44 = c17;
            										}
HXDLIN(  30)										::iterMagic::Iimg_obj::set(this151,index20,_hx_tmp44);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  30)				{
HXLINE(  30)					int _g86 = 0;
HXDLIN(  30)					int _g87 = (::Math_obj::floor((h2 / deltaH1)) + 1);
HXDLIN(  30)					while((_g86 < _g87)){
HXLINE(  30)						_g86 = (_g86 + 1);
HXDLIN(  30)						int i39 = (_g86 - 1);
HXDLIN(  30)						{
HXLINE(  30)							int r_x5 = ::Std_obj::_hx_int(x17);
HXDLIN(  30)							int r_y5 = ::Std_obj::_hx_int(((y17 + (( (Float)(i39) ) * deltaH1)) - (thick2 / ( (Float)(2) ))));
HXDLIN(  30)							int r_w5 = ::Std_obj::_hx_int(w_2);
HXDLIN(  30)							int r_h5 = ::Std_obj::_hx_int(thick2);
HXDLIN(  30)							int xmax5 = ((r_x5 + r_w5) + 1);
HXDLIN(  30)							int ymax5 = ((r_y5 + r_h5) + 1);
HXDLIN(  30)							int ii_min26 = r_x5;
HXDLIN(  30)							int ii_max26 = xmax5;
HXDLIN(  30)							int xRange__start5 = ii_min26;
HXDLIN(  30)							int xRange__max5 = ii_max26;
HXDLIN(  30)							int ii_min27 = r_y5;
HXDLIN(  30)							int ii_max27 = ymax5;
HXDLIN(  30)							int yRange__start5 = ii_min27;
HXDLIN(  30)							int yRange__max5 = ii_max27;
HXDLIN(  30)							int range_x5 = xRange__start5;
HXDLIN(  30)							int range_y5 = (yRange__start5 - 1);
HXDLIN(  30)							int range_xReset5 = range_x5;
HXDLIN(  30)							int range_yReset5 = range_y5;
HXDLIN(  30)							int range_xMax5 = (xRange__max5 - 2);
HXDLIN(  30)							int range_yMax5 = (yRange__max5 - 2);
HXDLIN(  30)							int _this_min5 = 0;
HXDLIN(  30)							int _this_max5 = ::Std_obj::_hx_int(( (Float)(((xRange__max5 - xRange__start5) * (yRange__max5 - yRange__start5))) ));
HXDLIN(  30)							while((_this_min5 < _this_max5)){
HXLINE(  30)								_this_min5 = (_this_min5 + 1);
HXDLIN(  30)								int i40 = (_this_min5 - 1);
HXDLIN(  30)								if ((range_y5 > range_yMax5)) {
HXLINE(  30)									range_y5 = range_yReset5;
HXDLIN(  30)									range_x5 = (range_x5 + 1);
            								}
HXDLIN(  30)								range_y5 = (range_y5 + 1);
HXDLIN(  30)								int i41 = i40;
HXDLIN(  30)								{
HXLINE(  30)									int x19 = range_x5;
HXDLIN(  30)									int y19 = range_y5;
HXDLIN(  30)									int c18 = color2;
HXDLIN(  30)									bool _hx_tmp45;
HXDLIN(  30)									if ((((c18 >> 24) & 255) < 254)) {
HXLINE(  30)										_hx_tmp45 = this140->transparent;
            									}
            									else {
HXLINE(  30)										_hx_tmp45 = false;
            									}
HXDLIN(  30)									if (_hx_tmp45) {
HXLINE(  30)										int location10;
HXDLIN(  30)										if (this140->useVirtualPos) {
HXLINE(  30)											location10 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this140->virtualY) * ( (Float)(this140->width) )) + x19) - this140->virtualX));
            										}
            										else {
HXLINE(  30)											location10 = ::Std_obj::_hx_int(( (Float)(((y19 * this140->width) + x19)) ));
            										}
HXDLIN(  30)										int this152 = ::iterMagic::Iimg_obj::get(this140->image,location10);
HXDLIN(  30)										int this153;
HXDLIN(  30)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)											this153 = ((((((this152 >> 24) & 255) << 24) | ((this152 & 255) << 16)) | (((this152 >> 8) & 255) << 8)) | ((this152 >> 16) & 255));
            										}
            										else {
HXLINE(  30)											this153 = this152;
            										}
HXDLIN(  30)										Float a113;
HXDLIN(  30)										int this154 = ((this153 >> 24) & 255);
HXDLIN(  30)										if ((this154 == 0)) {
HXLINE(  30)											a113 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											a113 = (( (Float)(this154) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float r110;
HXDLIN(  30)										int this155 = ((this153 >> 16) & 255);
HXDLIN(  30)										if ((this155 == 0)) {
HXLINE(  30)											r110 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											r110 = (( (Float)(this155) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float g110;
HXDLIN(  30)										int this156 = ((this153 >> 8) & 255);
HXDLIN(  30)										if ((this156 == 0)) {
HXLINE(  30)											g110 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											g110 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float b114;
HXDLIN(  30)										int this157 = (this153 & 255);
HXDLIN(  30)										if ((this157 == 0)) {
HXLINE(  30)											b114 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											b114 = (( (Float)(this157) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float a211;
HXDLIN(  30)										int this158 = ((color2 >> 24) & 255);
HXDLIN(  30)										if ((this158 == 0)) {
HXLINE(  30)											a211 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											a211 = (( (Float)(this158) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float r210;
HXDLIN(  30)										int this159 = ((color2 >> 16) & 255);
HXDLIN(  30)										if ((this159 == 0)) {
HXLINE(  30)											r210 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											r210 = (( (Float)(this159) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float g210;
HXDLIN(  30)										int this160 = ((color2 >> 8) & 255);
HXDLIN(  30)										if ((this160 == 0)) {
HXLINE(  30)											g210 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											g210 = (( (Float)(this160) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float b214;
HXDLIN(  30)										int this161 = (color2 & 255);
HXDLIN(  30)										if ((this161 == 0)) {
HXLINE(  30)											b214 = ((Float)0.);
            										}
            										else {
HXLINE(  30)											b214 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN(  30)										Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN(  30)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN(  30)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN(  30)										int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b214 * a211))));
HXDLIN(  30)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN(  30)										int blended10 = ((((a40 << 24) | (r30 << 16)) | (g30 << 8)) | b34);
HXDLIN(  30)										{
HXLINE(  30)											int _hx_tmp46;
HXDLIN(  30)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)												_hx_tmp46 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXLINE(  30)												_hx_tmp46 = blended10;
            											}
HXDLIN(  30)											::iterMagic::Iimg_obj::set(this140->image,location10,_hx_tmp46);
            										}
            									}
            									else {
HXLINE(  30)										::Dynamic this162 = this140->image;
HXDLIN(  30)										int index21;
HXDLIN(  30)										if (this140->useVirtualPos) {
HXLINE(  30)											index21 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this140->virtualY) * ( (Float)(this140->width) )) + x19) - this140->virtualX));
            										}
            										else {
HXLINE(  30)											index21 = ::Std_obj::_hx_int(( (Float)(((y19 * this140->width) + x19)) ));
            										}
HXDLIN(  30)										int _hx_tmp47;
HXDLIN(  30)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  30)											_hx_tmp47 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXLINE(  30)											_hx_tmp47 = c18;
            										}
HXDLIN(  30)										::iterMagic::Iimg_obj::set(this162,index21,_hx_tmp47);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            			else {
HXLINE(  32)				 ::pi_xy::ImageStruct this163 = pixelImage;
HXDLIN(  32)				Float x20 = (this->left + this->offX);
HXDLIN(  32)				Float y20 = (this->top + this->offY);
HXDLIN(  32)				Float w7 = this->width;
HXDLIN(  32)				Float h3 = this->height;
HXDLIN(  32)				Float delta1 = this->delta;
HXDLIN(  32)				Float thick3 = this->strokeWidth;
HXDLIN(  32)				int color3 = this->strokeColor;
HXDLIN(  32)				Float h_3 = (( (Float)(::Math_obj::floor((h3 / delta1))) ) * delta1);
HXDLIN(  32)				Float w_3 = (( (Float)(::Math_obj::floor((w7 / delta1))) ) * delta1);
HXDLIN(  32)				{
HXLINE(  32)					int _g88 = 0;
HXDLIN(  32)					int _g89 = (::Math_obj::floor((w7 / delta1)) + 1);
HXDLIN(  32)					while((_g88 < _g89)){
HXLINE(  32)						_g88 = (_g88 + 1);
HXDLIN(  32)						int i42 = (_g88 - 1);
HXDLIN(  32)						{
HXLINE(  32)							int r_x6 = ::Std_obj::_hx_int(((x20 + (( (Float)(i42) ) * delta1)) - (thick3 / ( (Float)(2) ))));
HXDLIN(  32)							int r_y6 = ::Std_obj::_hx_int(y20);
HXDLIN(  32)							int r_w6 = ::Std_obj::_hx_int(thick3);
HXDLIN(  32)							int r_h6 = ::Std_obj::_hx_int(h_3);
HXDLIN(  32)							int xmax6 = ((r_x6 + r_w6) + 1);
HXDLIN(  32)							int ymax6 = ((r_y6 + r_h6) + 1);
HXDLIN(  32)							int ii_min28 = r_x6;
HXDLIN(  32)							int ii_max28 = xmax6;
HXDLIN(  32)							int xRange__start6 = ii_min28;
HXDLIN(  32)							int xRange__max6 = ii_max28;
HXDLIN(  32)							int ii_min29 = r_y6;
HXDLIN(  32)							int ii_max29 = ymax6;
HXDLIN(  32)							int yRange__start6 = ii_min29;
HXDLIN(  32)							int yRange__max6 = ii_max29;
HXDLIN(  32)							int range_x6 = xRange__start6;
HXDLIN(  32)							int range_y6 = (yRange__start6 - 1);
HXDLIN(  32)							int range_xReset6 = range_x6;
HXDLIN(  32)							int range_yReset6 = range_y6;
HXDLIN(  32)							int range_xMax6 = (xRange__max6 - 2);
HXDLIN(  32)							int range_yMax6 = (yRange__max6 - 2);
HXDLIN(  32)							int _this_min6 = 0;
HXDLIN(  32)							int _this_max6 = ::Std_obj::_hx_int(( (Float)(((xRange__max6 - xRange__start6) * (yRange__max6 - yRange__start6))) ));
HXDLIN(  32)							while((_this_min6 < _this_max6)){
HXLINE(  32)								_this_min6 = (_this_min6 + 1);
HXDLIN(  32)								int i43 = (_this_min6 - 1);
HXDLIN(  32)								if ((range_y6 > range_yMax6)) {
HXLINE(  32)									range_y6 = range_yReset6;
HXDLIN(  32)									range_x6 = (range_x6 + 1);
            								}
HXDLIN(  32)								range_y6 = (range_y6 + 1);
HXDLIN(  32)								int i44 = i43;
HXDLIN(  32)								{
HXLINE(  32)									int x21 = range_x6;
HXDLIN(  32)									int y21 = range_y6;
HXDLIN(  32)									int c19 = color3;
HXDLIN(  32)									bool _hx_tmp48;
HXDLIN(  32)									if ((((c19 >> 24) & 255) < 254)) {
HXLINE(  32)										_hx_tmp48 = this163->transparent;
            									}
            									else {
HXLINE(  32)										_hx_tmp48 = false;
            									}
HXDLIN(  32)									if (_hx_tmp48) {
HXLINE(  32)										int location11;
HXDLIN(  32)										if (this163->useVirtualPos) {
HXLINE(  32)											location11 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this163->virtualY) * ( (Float)(this163->width) )) + x21) - this163->virtualX));
            										}
            										else {
HXLINE(  32)											location11 = ::Std_obj::_hx_int(( (Float)(((y21 * this163->width) + x21)) ));
            										}
HXDLIN(  32)										int this164 = ::iterMagic::Iimg_obj::get(this163->image,location11);
HXDLIN(  32)										int this165;
HXDLIN(  32)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  32)											this165 = ((((((this164 >> 24) & 255) << 24) | ((this164 & 255) << 16)) | (((this164 >> 8) & 255) << 8)) | ((this164 >> 16) & 255));
            										}
            										else {
HXLINE(  32)											this165 = this164;
            										}
HXDLIN(  32)										Float a114;
HXDLIN(  32)										int this166 = ((this165 >> 24) & 255);
HXDLIN(  32)										if ((this166 == 0)) {
HXLINE(  32)											a114 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											a114 = (( (Float)(this166) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float r111;
HXDLIN(  32)										int this167 = ((this165 >> 16) & 255);
HXDLIN(  32)										if ((this167 == 0)) {
HXLINE(  32)											r111 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											r111 = (( (Float)(this167) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float g111;
HXDLIN(  32)										int this168 = ((this165 >> 8) & 255);
HXDLIN(  32)										if ((this168 == 0)) {
HXLINE(  32)											g111 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											g111 = (( (Float)(this168) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float b115;
HXDLIN(  32)										int this169 = (this165 & 255);
HXDLIN(  32)										if ((this169 == 0)) {
HXLINE(  32)											b115 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											b115 = (( (Float)(this169) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float a212;
HXDLIN(  32)										int this170 = ((color3 >> 24) & 255);
HXDLIN(  32)										if ((this170 == 0)) {
HXLINE(  32)											a212 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											a212 = (( (Float)(this170) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float r211;
HXDLIN(  32)										int this171 = ((color3 >> 16) & 255);
HXDLIN(  32)										if ((this171 == 0)) {
HXLINE(  32)											r211 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											r211 = (( (Float)(this171) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float g211;
HXDLIN(  32)										int this172 = ((color3 >> 8) & 255);
HXDLIN(  32)										if ((this172 == 0)) {
HXLINE(  32)											g211 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											g211 = (( (Float)(this172) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float b215;
HXDLIN(  32)										int this173 = (color3 & 255);
HXDLIN(  32)										if ((this173 == 0)) {
HXLINE(  32)											b215 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											b215 = (( (Float)(this173) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN(  32)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN(  32)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN(  32)										int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b215 * a212))));
HXDLIN(  32)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN(  32)										int blended11 = ((((a41 << 24) | (r31 << 16)) | (g31 << 8)) | b35);
HXDLIN(  32)										{
HXLINE(  32)											int _hx_tmp49;
HXDLIN(  32)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  32)												_hx_tmp49 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXLINE(  32)												_hx_tmp49 = blended11;
            											}
HXDLIN(  32)											::iterMagic::Iimg_obj::set(this163->image,location11,_hx_tmp49);
            										}
            									}
            									else {
HXLINE(  32)										::Dynamic this174 = this163->image;
HXDLIN(  32)										int index22;
HXDLIN(  32)										if (this163->useVirtualPos) {
HXLINE(  32)											index22 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this163->virtualY) * ( (Float)(this163->width) )) + x21) - this163->virtualX));
            										}
            										else {
HXLINE(  32)											index22 = ::Std_obj::_hx_int(( (Float)(((y21 * this163->width) + x21)) ));
            										}
HXDLIN(  32)										int _hx_tmp50;
HXDLIN(  32)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  32)											_hx_tmp50 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            										}
            										else {
HXLINE(  32)											_hx_tmp50 = c19;
            										}
HXDLIN(  32)										::iterMagic::Iimg_obj::set(this174,index22,_hx_tmp50);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  32)				{
HXLINE(  32)					int _g90 = 0;
HXDLIN(  32)					int _g91 = (::Math_obj::floor((h3 / delta1)) + 1);
HXDLIN(  32)					while((_g90 < _g91)){
HXLINE(  32)						_g90 = (_g90 + 1);
HXDLIN(  32)						int i45 = (_g90 - 1);
HXDLIN(  32)						{
HXLINE(  32)							int r_x7 = ::Std_obj::_hx_int(x20);
HXDLIN(  32)							int r_y7 = ::Std_obj::_hx_int(((y20 + (( (Float)(i45) ) * delta1)) - (thick3 / ( (Float)(2) ))));
HXDLIN(  32)							int r_w7 = ::Std_obj::_hx_int(w_3);
HXDLIN(  32)							int r_h7 = ::Std_obj::_hx_int(thick3);
HXDLIN(  32)							int xmax7 = ((r_x7 + r_w7) + 1);
HXDLIN(  32)							int ymax7 = ((r_y7 + r_h7) + 1);
HXDLIN(  32)							int ii_min30 = r_x7;
HXDLIN(  32)							int ii_max30 = xmax7;
HXDLIN(  32)							int xRange__start7 = ii_min30;
HXDLIN(  32)							int xRange__max7 = ii_max30;
HXDLIN(  32)							int ii_min31 = r_y7;
HXDLIN(  32)							int ii_max31 = ymax7;
HXDLIN(  32)							int yRange__start7 = ii_min31;
HXDLIN(  32)							int yRange__max7 = ii_max31;
HXDLIN(  32)							int range_x7 = xRange__start7;
HXDLIN(  32)							int range_y7 = (yRange__start7 - 1);
HXDLIN(  32)							int range_xReset7 = range_x7;
HXDLIN(  32)							int range_yReset7 = range_y7;
HXDLIN(  32)							int range_xMax7 = (xRange__max7 - 2);
HXDLIN(  32)							int range_yMax7 = (yRange__max7 - 2);
HXDLIN(  32)							int _this_min7 = 0;
HXDLIN(  32)							int _this_max7 = ::Std_obj::_hx_int(( (Float)(((xRange__max7 - xRange__start7) * (yRange__max7 - yRange__start7))) ));
HXDLIN(  32)							while((_this_min7 < _this_max7)){
HXLINE(  32)								_this_min7 = (_this_min7 + 1);
HXDLIN(  32)								int i46 = (_this_min7 - 1);
HXDLIN(  32)								if ((range_y7 > range_yMax7)) {
HXLINE(  32)									range_y7 = range_yReset7;
HXDLIN(  32)									range_x7 = (range_x7 + 1);
            								}
HXDLIN(  32)								range_y7 = (range_y7 + 1);
HXDLIN(  32)								int i47 = i46;
HXDLIN(  32)								{
HXLINE(  32)									int x22 = range_x7;
HXDLIN(  32)									int y22 = range_y7;
HXDLIN(  32)									int c20 = color3;
HXDLIN(  32)									bool _hx_tmp51;
HXDLIN(  32)									if ((((c20 >> 24) & 255) < 254)) {
HXLINE(  32)										_hx_tmp51 = this163->transparent;
            									}
            									else {
HXLINE(  32)										_hx_tmp51 = false;
            									}
HXDLIN(  32)									if (_hx_tmp51) {
HXLINE(  32)										int location12;
HXDLIN(  32)										if (this163->useVirtualPos) {
HXLINE(  32)											location12 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this163->virtualY) * ( (Float)(this163->width) )) + x22) - this163->virtualX));
            										}
            										else {
HXLINE(  32)											location12 = ::Std_obj::_hx_int(( (Float)(((y22 * this163->width) + x22)) ));
            										}
HXDLIN(  32)										int this175 = ::iterMagic::Iimg_obj::get(this163->image,location12);
HXDLIN(  32)										int this176;
HXDLIN(  32)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  32)											this176 = ((((((this175 >> 24) & 255) << 24) | ((this175 & 255) << 16)) | (((this175 >> 8) & 255) << 8)) | ((this175 >> 16) & 255));
            										}
            										else {
HXLINE(  32)											this176 = this175;
            										}
HXDLIN(  32)										Float a115;
HXDLIN(  32)										int this177 = ((this176 >> 24) & 255);
HXDLIN(  32)										if ((this177 == 0)) {
HXLINE(  32)											a115 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											a115 = (( (Float)(this177) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float r112;
HXDLIN(  32)										int this178 = ((this176 >> 16) & 255);
HXDLIN(  32)										if ((this178 == 0)) {
HXLINE(  32)											r112 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											r112 = (( (Float)(this178) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float g112;
HXDLIN(  32)										int this179 = ((this176 >> 8) & 255);
HXDLIN(  32)										if ((this179 == 0)) {
HXLINE(  32)											g112 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											g112 = (( (Float)(this179) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float b116;
HXDLIN(  32)										int this180 = (this176 & 255);
HXDLIN(  32)										if ((this180 == 0)) {
HXLINE(  32)											b116 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											b116 = (( (Float)(this180) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float a213;
HXDLIN(  32)										int this181 = ((color3 >> 24) & 255);
HXDLIN(  32)										if ((this181 == 0)) {
HXLINE(  32)											a213 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											a213 = (( (Float)(this181) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float r212;
HXDLIN(  32)										int this182 = ((color3 >> 16) & 255);
HXDLIN(  32)										if ((this182 == 0)) {
HXLINE(  32)											r212 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											r212 = (( (Float)(this182) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float g212;
HXDLIN(  32)										int this183 = ((color3 >> 8) & 255);
HXDLIN(  32)										if ((this183 == 0)) {
HXLINE(  32)											g212 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											g212 = (( (Float)(this183) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float b216;
HXDLIN(  32)										int this184 = (color3 & 255);
HXDLIN(  32)										if ((this184 == 0)) {
HXLINE(  32)											b216 = ((Float)0.);
            										}
            										else {
HXLINE(  32)											b216 = (( (Float)(this184) ) / ( (Float)(255) ));
            										}
HXDLIN(  32)										Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN(  32)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN(  32)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN(  32)										int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b216 * a213))));
HXDLIN(  32)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN(  32)										int blended12 = ((((a42 << 24) | (r32 << 16)) | (g32 << 8)) | b36);
HXDLIN(  32)										{
HXLINE(  32)											int _hx_tmp52;
HXDLIN(  32)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  32)												_hx_tmp52 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXLINE(  32)												_hx_tmp52 = blended12;
            											}
HXDLIN(  32)											::iterMagic::Iimg_obj::set(this163->image,location12,_hx_tmp52);
            										}
            									}
            									else {
HXLINE(  32)										::Dynamic this185 = this163->image;
HXDLIN(  32)										int index23;
HXDLIN(  32)										if (this163->useVirtualPos) {
HXLINE(  32)											index23 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this163->virtualY) * ( (Float)(this163->width) )) + x22) - this163->virtualX));
            										}
            										else {
HXLINE(  32)											index23 = ::Std_obj::_hx_int(( (Float)(((y22 * this163->width) + x22)) ));
            										}
HXDLIN(  32)										int _hx_tmp53;
HXDLIN(  32)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  32)											_hx_tmp53 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            										}
            										else {
HXLINE(  32)											_hx_tmp53 = c20;
            										}
HXDLIN(  32)										::iterMagic::Iimg_obj::set(this185,index23,_hx_tmp53);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  35)		return pixelImage;
            	}



::hx::ObjectPtr< LineGridShape_obj > LineGridShape_obj::__new( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic left, ::Dynamic top, ::Dynamic width, ::Dynamic height, ::Dynamic delta, ::Dynamic deltaH) {
	::hx::ObjectPtr< LineGridShape_obj > __this = new LineGridShape_obj();
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH);
	return __this;
}

::hx::ObjectPtr< LineGridShape_obj > LineGridShape_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic left, ::Dynamic top, ::Dynamic width, ::Dynamic height, ::Dynamic delta, ::Dynamic deltaH) {
	LineGridShape_obj *__this = (LineGridShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(LineGridShape_obj), true, "pi_xy.triangleGML.LineGridShape"));
	*(void **)__this = LineGridShape_obj::_hx_vtable;
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,left,top,width,height,delta,deltaH);
	return __this;
}

LineGridShape_obj::LineGridShape_obj()
{
}

::hx::Val LineGridShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *LineGridShape_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *LineGridShape_obj_sStaticStorageInfo = 0;
#endif

static ::String LineGridShape_obj_sMemberFields[] = {
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class LineGridShape_obj::__mClass;

void LineGridShape_obj::__register()
{
	LineGridShape_obj _hx_dummy;
	LineGridShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.triangleGML.LineGridShape",90,96,0a,b2);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(LineGridShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< LineGridShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LineGridShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LineGridShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace triangleGML
