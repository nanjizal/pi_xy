// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTriArray
#include <pi_xy/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__FillShape_FillShape_Impl_
#include <pi_xy/imageAbstracts/_FillShape/FillShape_Impl_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_17__new,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","_new",0x4ddcee8f,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_._new","pi_xy/imageAbstracts/FillShape.hx",17,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_29_square,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","square",0xf5bb014b,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.square","pi_xy/imageAbstracts/FillShape.hx",29,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_42_triangle,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","triangle",0xaf52c6f6,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.triangle","pi_xy/imageAbstracts/FillShape.hx",42,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_58_quad,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","quad",0x59c811f5,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.quad","pi_xy/imageAbstracts/FillShape.hx",58,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_68_line,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","line",0x5670f122,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.line","pi_xy/imageAbstracts/FillShape.hx",68,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_89_roundRectangle,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","roundRectangle",0xa1f9a0af,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.roundRectangle","pi_xy/imageAbstracts/FillShape.hx",89,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_107_quadrant,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","quadrant",0x0a74fe2a,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.quadrant","pi_xy/imageAbstracts/FillShape.hx",107,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_120_quadrantI,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","quadrantI",0x1be966df,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.quadrantI","pi_xy/imageAbstracts/FillShape.hx",120,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_131_quadrantII,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","quadrantII",0x50509c8a,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.quadrantII","pi_xy/imageAbstracts/FillShape.hx",131,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_143_quadrantIII,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","quadrantIII",0xf6385c7f,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.quadrantIII","pi_xy/imageAbstracts/FillShape.hx",143,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_156_quadrantIV,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","quadrantIV",0x50509c97,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.quadrantIV","pi_xy/imageAbstracts/FillShape.hx",156,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_164_simonSays,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","simonSays",0x15784110,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.simonSays","pi_xy/imageAbstracts/FillShape.hx",164,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_176_circle,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","circle",0xf2d672be,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.circle","pi_xy/imageAbstracts/FillShape.hx",176,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_187_ellipse,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","ellipse",0x9e9dd870,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.ellipse","pi_xy/imageAbstracts/FillShape.hx",187,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_207_polyBuild,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","polyBuild",0x8aac9954,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.polyBuild","pi_xy/imageAbstracts/FillShape.hx",207,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_222_arrowHead,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","arrowHead",0x3a89079b,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.arrowHead","pi_xy/imageAbstracts/FillShape.hx",222,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_235_pentagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","pentagon",0x95c006ae,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.pentagon","pi_xy/imageAbstracts/FillShape.hx",235,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_248_hexagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","hexagon",0x325d1f72,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.hexagon","pi_xy/imageAbstracts/FillShape.hx",248,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_261_heptagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","heptagon",0x98e32e74,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.heptagon","pi_xy/imageAbstracts/FillShape.hx",261,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_274_septagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","septagon",0x0e0e15c9,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.septagon","pi_xy/imageAbstracts/FillShape.hx",274,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_287_octagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","octagon",0x3b2253f7,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.octagon","pi_xy/imageAbstracts/FillShape.hx",287,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_300_nonagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","nonagon",0x696db6a4,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.nonagon","pi_xy/imageAbstracts/FillShape.hx",300,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_313_enneagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","enneagon",0xf3d39893,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.enneagon","pi_xy/imageAbstracts/FillShape.hx",313,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_326_decagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","decagon",0x749d15d9,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.decagon","pi_xy/imageAbstracts/FillShape.hx",326,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_339_hendecagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","hendecagon",0x31b39744,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.hendecagon","pi_xy/imageAbstracts/FillShape.hx",339,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_352_undecagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","undecagon",0x1761a520,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.undecagon","pi_xy/imageAbstracts/FillShape.hx",352,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_365_dodecagon,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","dodecagon",0x4e8c1e2e,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.dodecagon","pi_xy/imageAbstracts/FillShape.hx",365,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_379_pie,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","pie",0xa8013ede,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.pie","pi_xy/imageAbstracts/FillShape.hx",379,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_419_sweepTri,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","sweepTri",0xfb7c8ecd,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.sweepTri","pi_xy/imageAbstracts/FillShape.hx",419,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_434_lineGrid,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","lineGrid",0xa3222d08,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.lineGrid","pi_xy/imageAbstracts/FillShape.hx",434,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_449_lineGridWH,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","lineGridWH",0x51cdcb19,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.lineGridWH","pi_xy/imageAbstracts/FillShape.hx",449,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_469_arrow,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","arrow",0xfcefa8db,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.arrow","pi_xy/imageAbstracts/FillShape.hx",469,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_482_arrowBoth,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","arrowBoth",0x369966fc,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.arrowBoth","pi_xy/imageAbstracts/FillShape.hx",482,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_497_fixArrow,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","fixArrow",0xad846be2,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.fixArrow","pi_xy/imageAbstracts/FillShape.hx",497,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_513_fixArrowBoth,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","fixArrowBoth",0xec19b983,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.fixArrowBoth","pi_xy/imageAbstracts/FillShape.hx",513,0x0e4f8ff1)
HX_LOCAL_STACK_FRAME(_hx_pos_2dbda5e369a0ff2f_532_ellipseTri,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_","ellipseTri",0xb1e12e9b,"pi_xy.imageAbstracts._FillShape.FillShape_Impl_.ellipseTri","pi_xy/imageAbstracts/FillShape.hx",532,0x0e4f8ff1)
namespace pi_xy{
namespace imageAbstracts{
namespace _FillShape{

void FillShape_Impl__obj::__construct() { }

Dynamic FillShape_Impl__obj::__CreateEmpty() { return new FillShape_Impl__obj; }

void *FillShape_Impl__obj::_hx_vtable = 0;

Dynamic FillShape_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FillShape_Impl__obj > _hx_result = new FillShape_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FillShape_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x073c83a2;
}

 ::pi_xy::ImageStruct FillShape_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_17__new)
HXLINE(  19)		 ::Dynamic imageType = null();
HXDLIN(  19)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  19)		if (::hx::IsNull( imageType )) {
HXLINE(  19)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  19)		::Dynamic this2;
HXDLIN(  19)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  19)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  19)				{
HXLINE(  19)					b->width = w;
HXDLIN(  19)					b->height = h;
HXDLIN(  19)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  19)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  19)					{
HXLINE(  19)						int len = b->length;
HXDLIN(  19)						int w1 = 0;
HXDLIN(  19)						{
HXLINE(  19)							int _g = 0;
HXDLIN(  19)							int _g1 = b->height;
HXDLIN(  19)							while((_g < _g1)){
HXLINE(  19)								_g = (_g + 1);
HXDLIN(  19)								int y = (_g - 1);
HXDLIN(  19)								{
HXLINE(  19)									int _g2 = 0;
HXDLIN(  19)									int _g3 = b->width;
HXDLIN(  19)									while((_g2 < _g3)){
HXLINE(  19)										_g2 = (_g2 + 1);
HXDLIN(  19)										int x = (_g2 - 1);
HXDLIN(  19)										{
HXLINE(  19)											w1 = (w1 + 1);
HXDLIN(  19)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  19)										{
HXLINE(  19)											w1 = (w1 + 1);
HXDLIN(  19)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  19)										{
HXLINE(  19)											w1 = (w1 + 1);
HXDLIN(  19)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  19)										{
HXLINE(  19)											w1 = (w1 + 1);
HXDLIN(  19)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  19)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  19)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  19)				{
HXLINE(  19)					a->width = w;
HXDLIN(  19)					a->height = h;
HXDLIN(  19)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  19)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  19)					{
HXLINE(  19)						int _g4 = 0;
HXDLIN(  19)						int _g5 = a->length;
HXDLIN(  19)						while((_g4 < _g5)){
HXLINE(  19)							_g4 = (_g4 + 1);
HXDLIN(  19)							int i = (_g4 - 1);
HXDLIN(  19)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  19)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  19)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  19)				{
HXLINE(  19)					b1->width = w;
HXDLIN(  19)					b1->height = h;
HXDLIN(  19)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  19)					int size = (b1->length * 4);
HXDLIN(  19)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  19)					{
HXLINE(  19)						int _g6 = 0;
HXDLIN(  19)						int _g7 = b1->length;
HXDLIN(  19)						while((_g6 < _g7)){
HXLINE(  19)							_g6 = (_g6 + 1);
HXDLIN(  19)							int i1 = (_g6 - 1);
HXDLIN(  19)							{
HXLINE(  19)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  19)								bool this4;
HXDLIN(  19)								if ((i1 >= 0)) {
HXLINE(  19)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  19)									this4 = false;
            								}
HXDLIN(  19)								if (this4) {
HXLINE(  19)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  19)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  19)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  19)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  19)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  19)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  19)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  19)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  19)				{
HXLINE(  19)					v->width = w;
HXDLIN(  19)					v->height = h;
HXDLIN(  19)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  19)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  19)					{
HXLINE(  19)						int _g8 = 0;
HXDLIN(  19)						int _g9 = v->length;
HXDLIN(  19)						while((_g8 < _g9)){
HXLINE(  19)							_g8 = (_g8 + 1);
HXDLIN(  19)							int i2 = (_g8 - 1);
HXDLIN(  19)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  19)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  19)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  19)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  19)				{
HXLINE(  19)					b2->width = w;
HXDLIN(  19)					b2->height = h;
HXDLIN(  19)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  19)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  19)					{
HXLINE(  19)						int len1 = b2->length;
HXDLIN(  19)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  19)						if (::hx::IsNull( d->head )) {
HXLINE(  19)							int _g10 = 0;
HXDLIN(  19)							int _g11 = len1;
HXDLIN(  19)							while((_g10 < _g11)){
HXLINE(  19)								_g10 = (_g10 + 1);
HXDLIN(  19)								int i3 = (_g10 - 1);
HXDLIN(  19)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  19)							int _g12 = 0;
HXDLIN(  19)							int _g13 = len1;
HXDLIN(  19)							while((_g12 < _g13)){
HXLINE(  19)								_g12 = (_g12 + 1);
HXDLIN(  19)								int i4 = (_g12 - 1);
HXDLIN(  19)								{
HXLINE(  19)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  19)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  19)									{
HXLINE(  19)										int _g14 = 0;
HXDLIN(  19)										int _g15 = i4;
HXDLIN(  19)										while((_g14 < _g15)){
HXLINE(  19)											_g14 = (_g14 + 1);
HXDLIN(  19)											int i5 = (_g14 - 1);
HXDLIN(  19)											prev = l;
HXDLIN(  19)											l = l->next;
            										}
            									}
HXDLIN(  19)									if (::hx::IsNull( prev )) {
HXLINE(  19)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  19)										l = null();
            									}
            									else {
HXLINE(  19)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  19)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  19)				this2 = b2;
            			}
            			break;
            		}
HXDLIN(  19)		this1->image = this2;
HXDLIN(  19)		this1->width = w;
HXDLIN(  19)		this1->height = h;
HXDLIN(  19)		this1->imageType = ( (int)(imageType) );
HXLINE(  17)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FillShape_Impl__obj,_new,return )

void FillShape_Impl__obj::square( ::pi_xy::ImageStruct this1,Float x,Float y,Float d,int color){
            	HX_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_29_square)
HXDLIN(  29)		int r_x = ::Std_obj::_hx_int((x - (d / ( (Float)(2) ))));
HXDLIN(  29)		int r_y = ::Std_obj::_hx_int((y - (d / ( (Float)(2) ))));
HXDLIN(  29)		int r_w = ::Std_obj::_hx_int(d);
HXDLIN(  29)		int r_h = ::Std_obj::_hx_int(d);
HXDLIN(  29)		int xmax = ((r_x + r_w) + 1);
HXDLIN(  29)		int ymax = ((r_y + r_h) + 1);
HXDLIN(  29)		int ii_min = r_x;
HXDLIN(  29)		int ii_max = xmax;
HXDLIN(  29)		int xRange__start = ii_min;
HXDLIN(  29)		int xRange__max = ii_max;
HXDLIN(  29)		int ii_min1 = r_y;
HXDLIN(  29)		int ii_max1 = ymax;
HXDLIN(  29)		int yRange__start = ii_min1;
HXDLIN(  29)		int yRange__max = ii_max1;
HXDLIN(  29)		int range_x = xRange__start;
HXDLIN(  29)		int range_y = (yRange__start - 1);
HXDLIN(  29)		int range_xReset = range_x;
HXDLIN(  29)		int range_yReset = range_y;
HXDLIN(  29)		int range_xMax = (xRange__max - 2);
HXDLIN(  29)		int range_yMax = (yRange__max - 2);
HXDLIN(  29)		int _this_min = 0;
HXDLIN(  29)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  29)		while((_this_min < _this_max)){
HXDLIN(  29)			_this_min = (_this_min + 1);
HXDLIN(  29)			int i = (_this_min - 1);
HXDLIN(  29)			if ((range_y > range_yMax)) {
HXDLIN(  29)				range_y = range_yReset;
HXDLIN(  29)				range_x = (range_x + 1);
            			}
HXDLIN(  29)			range_y = (range_y + 1);
HXDLIN(  29)			int i1 = i;
HXDLIN(  29)			{
HXDLIN(  29)				int x1 = range_x;
HXDLIN(  29)				int y1 = range_y;
HXDLIN(  29)				int c = color;
HXDLIN(  29)				bool _hx_tmp;
HXDLIN(  29)				if ((((c >> 24) & 255) < 254)) {
HXDLIN(  29)					_hx_tmp = this1->transparent;
            				}
            				else {
HXDLIN(  29)					_hx_tmp = false;
            				}
HXDLIN(  29)				if (_hx_tmp) {
HXDLIN(  29)					int location;
HXDLIN(  29)					if (this1->useVirtualPos) {
HXDLIN(  29)						location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            					}
            					else {
HXDLIN(  29)						location = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            					}
HXDLIN(  29)					int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN(  29)					int this3;
HXDLIN(  29)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)						this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            					}
            					else {
HXDLIN(  29)						this3 = this2;
            					}
HXDLIN(  29)					Float a1;
HXDLIN(  29)					int this4 = ((this3 >> 24) & 255);
HXDLIN(  29)					if ((this4 == 0)) {
HXDLIN(  29)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN(  29)						a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float r1;
HXDLIN(  29)					int this5 = ((this3 >> 16) & 255);
HXDLIN(  29)					if ((this5 == 0)) {
HXDLIN(  29)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN(  29)						r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float g1;
HXDLIN(  29)					int this6 = ((this3 >> 8) & 255);
HXDLIN(  29)					if ((this6 == 0)) {
HXDLIN(  29)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN(  29)						g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float b1;
HXDLIN(  29)					int this7 = (this3 & 255);
HXDLIN(  29)					if ((this7 == 0)) {
HXDLIN(  29)						b1 = ((Float)0.);
            					}
            					else {
HXDLIN(  29)						b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float a2;
HXDLIN(  29)					int this8 = ((color >> 24) & 255);
HXDLIN(  29)					if ((this8 == 0)) {
HXDLIN(  29)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN(  29)						a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float r2;
HXDLIN(  29)					int this9 = ((color >> 16) & 255);
HXDLIN(  29)					if ((this9 == 0)) {
HXDLIN(  29)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN(  29)						r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float g2;
HXDLIN(  29)					int this10 = ((color >> 8) & 255);
HXDLIN(  29)					if ((this10 == 0)) {
HXDLIN(  29)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN(  29)						g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float b2;
HXDLIN(  29)					int this11 = (color & 255);
HXDLIN(  29)					if ((this11 == 0)) {
HXDLIN(  29)						b2 = ((Float)0.);
            					}
            					else {
HXDLIN(  29)						b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  29)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  29)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  29)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  29)					int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  29)					int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  29)					int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  29)					{
HXDLIN(  29)						int _hx_tmp1;
HXDLIN(  29)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)							_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN(  29)							_hx_tmp1 = blended;
            						}
HXDLIN(  29)						::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            					}
            				}
            				else {
HXDLIN(  29)					::Dynamic this12 = this1->image;
HXDLIN(  29)					int index;
HXDLIN(  29)					if (this1->useVirtualPos) {
HXDLIN(  29)						index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            					}
            					else {
HXDLIN(  29)						index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            					}
HXDLIN(  29)					int _hx_tmp2;
HXDLIN(  29)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  29)						_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXDLIN(  29)						_hx_tmp2 = c;
            					}
HXDLIN(  29)					::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FillShape_Impl__obj,square,(void))

 ::pi_xy::algo::HitTri FillShape_Impl__obj::triangle( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,int color,::hx::Null< bool >  __o_hasHit,::hx::Null< bool >  __o_hasUndo){
            		bool hasHit = __o_hasHit.Default(false);
            		bool hasUndo = __o_hasUndo.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_42_triangle)
HXDLIN(  42)		Float bx1 = bx;
HXDLIN(  42)		Float by1 = by;
HXDLIN(  42)		Float cx1 = cx;
HXDLIN(  42)		Float cy1 = cy;
HXDLIN(  42)		bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  42)		if (!(adjustWinding)) {
HXDLIN(  42)			Float bx_ = bx1;
HXDLIN(  42)			Float by_ = by1;
HXLINE(  25)			bx1 = cx1;
HXLINE(  26)			by1 = cy1;
HXLINE(  27)			cx1 = bx_;
HXLINE(  28)			cy1 = by_;
            		}
HXLINE(  42)		Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  42)		Float sx = (cy1 - ay);
HXDLIN(  42)		Float sy = (ax - cx1);
HXDLIN(  42)		Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  42)		Float tx = (ay - by1);
HXDLIN(  42)		Float ty = (bx1 - ax);
HXDLIN(  42)		Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  42)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  42)		if ((ax > bx1)) {
HXDLIN(  42)			if ((ax > cx1)) {
HXDLIN(  42)				int min;
HXDLIN(  42)				if ((bx1 > cx1)) {
HXDLIN(  42)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN(  42)					min = ::Math_obj::floor(bx1);
            				}
HXDLIN(  42)				int ii_min = min;
HXDLIN(  42)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  42)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN(  42)				int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  42)				int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  42)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN(  42)			if ((bx1 > cx1)) {
HXDLIN(  42)				int min1;
HXDLIN(  42)				if ((ax > cx1)) {
HXDLIN(  42)					min1 = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN(  42)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN(  42)				int ii_min2 = min1;
HXDLIN(  42)				int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  42)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN(  42)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  42)				int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  42)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN(  42)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  42)		if ((ay > by1)) {
HXDLIN(  42)			if ((ay > cy1)) {
HXDLIN(  42)				int min2;
HXDLIN(  42)				if ((by1 > cy1)) {
HXDLIN(  42)					min2 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN(  42)					min2 = ::Math_obj::floor(by1);
            				}
HXDLIN(  42)				int ii_min4 = min2;
HXDLIN(  42)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  42)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN(  42)				int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  42)				int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  42)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN(  42)			if ((by1 > cy1)) {
HXDLIN(  42)				int min3;
HXDLIN(  42)				if ((ay > cy1)) {
HXDLIN(  42)					min3 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN(  42)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN(  42)				int ii_min6 = min3;
HXDLIN(  42)				int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  42)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN(  42)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  42)				int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  42)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN(  42)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  42)		if (hasUndo) {
HXDLIN(  42)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  42)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  42)			 ::Dynamic imageType = null();
HXDLIN(  42)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  42)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  42)			::Dynamic undoImage1;
HXDLIN(  42)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN(  42)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  42)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  42)					{
HXDLIN(  42)						b->width = width;
HXDLIN(  42)						b->height = height;
HXDLIN(  42)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  42)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  42)						{
HXDLIN(  42)							int len = b->length;
HXDLIN(  42)							int w = 0;
HXDLIN(  42)							{
HXDLIN(  42)								int _g = 0;
HXDLIN(  42)								int _g1 = b->height;
HXDLIN(  42)								while((_g < _g1)){
HXDLIN(  42)									_g = (_g + 1);
HXDLIN(  42)									int y = (_g - 1);
HXDLIN(  42)									{
HXDLIN(  42)										int _g2 = 0;
HXDLIN(  42)										int _g3 = b->width;
HXDLIN(  42)										while((_g2 < _g3)){
HXDLIN(  42)											_g2 = (_g2 + 1);
HXDLIN(  42)											int x = (_g2 - 1);
HXDLIN(  42)											{
HXDLIN(  42)												w = (w + 1);
HXDLIN(  42)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  42)											{
HXDLIN(  42)												w = (w + 1);
HXDLIN(  42)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  42)											{
HXDLIN(  42)												w = (w + 1);
HXDLIN(  42)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  42)											{
HXDLIN(  42)												w = (w + 1);
HXDLIN(  42)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  42)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN(  42)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  42)					{
HXDLIN(  42)						a->width = width;
HXDLIN(  42)						a->height = height;
HXDLIN(  42)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  42)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  42)						{
HXDLIN(  42)							int _g4 = 0;
HXDLIN(  42)							int _g5 = a->length;
HXDLIN(  42)							while((_g4 < _g5)){
HXDLIN(  42)								_g4 = (_g4 + 1);
HXDLIN(  42)								int i = (_g4 - 1);
HXDLIN(  42)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  42)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN(  42)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  42)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  42)					{
HXDLIN(  42)						b1->width = width;
HXDLIN(  42)						b1->height = height;
HXDLIN(  42)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  42)						int size = (b1->length * 4);
HXDLIN(  42)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  42)						{
HXDLIN(  42)							int _g6 = 0;
HXDLIN(  42)							int _g7 = b1->length;
HXDLIN(  42)							while((_g6 < _g7)){
HXDLIN(  42)								_g6 = (_g6 + 1);
HXDLIN(  42)								int i1 = (_g6 - 1);
HXDLIN(  42)								{
HXDLIN(  42)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  42)									bool undoImage2;
HXDLIN(  42)									if ((i1 >= 0)) {
HXDLIN(  42)										undoImage2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXDLIN(  42)										undoImage2 = false;
            									}
HXDLIN(  42)									if (undoImage2) {
HXDLIN(  42)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  42)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  42)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  42)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  42)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  42)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  42)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN(  42)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  42)					{
HXDLIN(  42)						v->width = width;
HXDLIN(  42)						v->height = height;
HXDLIN(  42)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  42)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  42)						{
HXDLIN(  42)							int _g8 = 0;
HXDLIN(  42)							int _g9 = v->length;
HXDLIN(  42)							while((_g8 < _g9)){
HXDLIN(  42)								_g8 = (_g8 + 1);
HXDLIN(  42)								int i2 = (_g8 - 1);
HXDLIN(  42)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  42)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN(  42)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  42)					{
HXDLIN(  42)						b2->width = width;
HXDLIN(  42)						b2->height = height;
HXDLIN(  42)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  42)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  42)						{
HXDLIN(  42)							int len1 = b2->length;
HXDLIN(  42)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  42)							if (::hx::IsNull( d->head )) {
HXDLIN(  42)								int _g10 = 0;
HXDLIN(  42)								int _g11 = len1;
HXDLIN(  42)								while((_g10 < _g11)){
HXDLIN(  42)									_g10 = (_g10 + 1);
HXDLIN(  42)									int i3 = (_g10 - 1);
HXDLIN(  42)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN(  42)								int _g12 = 0;
HXDLIN(  42)								int _g13 = len1;
HXDLIN(  42)								while((_g12 < _g13)){
HXDLIN(  42)									_g12 = (_g12 + 1);
HXDLIN(  42)									int i4 = (_g12 - 1);
HXDLIN(  42)									{
HXDLIN(  42)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  42)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  42)										{
HXDLIN(  42)											int _g14 = 0;
HXDLIN(  42)											int _g15 = i4;
HXDLIN(  42)											while((_g14 < _g15)){
HXDLIN(  42)												_g14 = (_g14 + 1);
HXDLIN(  42)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  42)										if (::hx::IsNull( prev )) {
HXDLIN(  42)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  42)											l = null();
            										}
            										else {
HXDLIN(  42)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  42)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  42)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN(  42)			this2->image = undoImage1;
HXDLIN(  42)			this2->width = width;
HXDLIN(  42)			this2->height = height;
HXDLIN(  42)			this2->imageType = ( (int)(imageType) );
HXDLIN(  42)			undoImage = this2;
HXDLIN(  42)			{
HXDLIN(  42)				int rectLeft = xIter3->start;
HXDLIN(  42)				int rectTop = yIter3->start;
HXDLIN(  42)				int rectRight = xIter3->max;
HXDLIN(  42)				bool forceClear = false;
HXDLIN(  42)				{
HXDLIN(  42)					int _g16 = rectTop;
HXDLIN(  42)					int _g17 = yIter3->max;
HXDLIN(  42)					while((_g16 < _g17)){
HXDLIN(  42)						_g16 = (_g16 + 1);
HXDLIN(  42)						int dy = (_g16 - 1);
HXDLIN(  42)						{
HXDLIN(  42)							int _g18 = rectLeft;
HXDLIN(  42)							int _g19 = rectRight;
HXDLIN(  42)							while((_g18 < _g19)){
HXDLIN(  42)								_g18 = (_g18 + 1);
HXDLIN(  42)								int dx = (_g18 - 1);
HXDLIN(  42)								::Dynamic this4 = this1->image;
HXDLIN(  42)								int index;
HXDLIN(  42)								if (this1->useVirtualPos) {
HXDLIN(  42)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXDLIN(  42)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  42)								int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  42)								int col;
HXDLIN(  42)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  42)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN(  42)									col = c;
            								}
HXDLIN(  42)								bool _hx_tmp;
HXDLIN(  42)								if (this1->useMask) {
HXDLIN(  42)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN(  42)									_hx_tmp = false;
            								}
HXDLIN(  42)								if (_hx_tmp) {
HXDLIN(  42)									 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  42)									::Dynamic this6 = this5->image;
HXDLIN(  42)									int index1;
HXDLIN(  42)									if (this5->useVirtualPos) {
HXDLIN(  42)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            									}
            									else {
HXDLIN(  42)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            									}
HXDLIN(  42)									int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  42)									int v1;
HXDLIN(  42)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  42)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN(  42)										v1 = c1;
            									}
HXDLIN(  42)									int maskPixel = v1;
HXDLIN(  42)									int this7 = col;
HXDLIN(  42)									if ((maskPixel == 0)) {
HXDLIN(  42)										col = this7;
            									}
            									else {
HXDLIN(  42)										Float m0;
HXDLIN(  42)										int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  42)										if ((this8 == 0)) {
HXDLIN(  42)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float m1;
HXDLIN(  42)										int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  42)										if ((this9 == 0)) {
HXDLIN(  42)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float m2;
HXDLIN(  42)										int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  42)										if ((this10 == 0)) {
HXDLIN(  42)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float m3;
HXDLIN(  42)										int this11 = (maskPixel & 255);
HXDLIN(  42)										if ((this11 == 0)) {
HXDLIN(  42)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  42)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  42)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  42)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  42)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  42)								if ((col != 0)) {
HXDLIN(  42)									int x1 = (dx - rectLeft);
HXDLIN(  42)									int y1 = (dy - rectTop);
HXDLIN(  42)									int c2 = col;
HXDLIN(  42)									bool _hx_tmp1;
HXDLIN(  42)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  42)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN(  42)										_hx_tmp1 = false;
            									}
HXDLIN(  42)									if (_hx_tmp1) {
HXDLIN(  42)										int location;
HXDLIN(  42)										if (undoImage->useVirtualPos) {
HXDLIN(  42)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  42)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  42)										int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  42)										int this13;
HXDLIN(  42)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  42)											this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            										}
            										else {
HXDLIN(  42)											this13 = this12;
            										}
HXDLIN(  42)										Float a1;
HXDLIN(  42)										int this14 = ((this13 >> 24) & 255);
HXDLIN(  42)										if ((this14 == 0)) {
HXDLIN(  42)											a1 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float r1;
HXDLIN(  42)										int this15 = ((this13 >> 16) & 255);
HXDLIN(  42)										if ((this15 == 0)) {
HXDLIN(  42)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float g1;
HXDLIN(  42)										int this16 = ((this13 >> 8) & 255);
HXDLIN(  42)										if ((this16 == 0)) {
HXDLIN(  42)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float b11;
HXDLIN(  42)										int this17 = (this13 & 255);
HXDLIN(  42)										if ((this17 == 0)) {
HXDLIN(  42)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float a2;
HXDLIN(  42)										int this18 = ((col >> 24) & 255);
HXDLIN(  42)										if ((this18 == 0)) {
HXDLIN(  42)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float r2;
HXDLIN(  42)										int this19 = ((col >> 16) & 255);
HXDLIN(  42)										if ((this19 == 0)) {
HXDLIN(  42)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float g2;
HXDLIN(  42)										int this20 = ((col >> 8) & 255);
HXDLIN(  42)										if ((this20 == 0)) {
HXDLIN(  42)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float b21;
HXDLIN(  42)										int this21 = (col & 255);
HXDLIN(  42)										if ((this21 == 0)) {
HXDLIN(  42)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  42)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  42)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  42)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  42)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  42)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  42)										{
HXDLIN(  42)											int _hx_tmp2;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  42)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN(  42)												_hx_tmp2 = blended;
            											}
HXDLIN(  42)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN(  42)										::Dynamic this22 = undoImage->image;
HXDLIN(  42)										int index2;
HXDLIN(  42)										if (undoImage->useVirtualPos) {
HXDLIN(  42)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  42)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  42)										int _hx_tmp3;
HXDLIN(  42)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  42)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN(  42)											_hx_tmp3 = c2;
            										}
HXDLIN(  42)										::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN(  42)									if (forceClear) {
HXDLIN(  42)										::Dynamic this23 = undoImage->image;
HXDLIN(  42)										int x2 = (dx - rectLeft);
HXDLIN(  42)										int y2 = (dy - rectTop);
HXDLIN(  42)										int index3;
HXDLIN(  42)										if (undoImage->useVirtualPos) {
HXDLIN(  42)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  42)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(  42)										::iterMagic::Iimg_obj::set(this23,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  42)		bool found = false;
HXDLIN(  42)		Float s = ((Float)0.);
HXDLIN(  42)		Float t = ((Float)0.);
HXDLIN(  42)		Float sxx = ((Float)0.);
HXDLIN(  42)		Float txx = ((Float)0.);
HXDLIN(  42)		{
HXDLIN(  42)			int _g_min = xIter3->start;
HXDLIN(  42)			int _g_max = xIter3->max;
HXDLIN(  42)			while((_g_min < _g_max)){
HXDLIN(  42)				_g_min = (_g_min + 1);
HXDLIN(  42)				int x3 = (_g_min - 1);
HXLINE(  60)				sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)				txx = (tx * ( (Float)(x3) ));
HXLINE(  62)				found = false;
HXLINE(  42)				{
HXDLIN(  42)					int _g_min1 = yIter3->start;
HXDLIN(  42)					int _g_max1 = yIter3->max;
HXDLIN(  42)					while((_g_min1 < _g_max1)){
HXDLIN(  42)						_g_min1 = (_g_min1 + 1);
HXDLIN(  42)						int y3 = (_g_min1 - 1);
HXLINE(  64)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  42)						bool _hx_tmp4;
HXDLIN(  42)						if (!((s <= 0))) {
HXDLIN(  42)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXDLIN(  42)							_hx_tmp4 = true;
            						}
HXDLIN(  42)						if (_hx_tmp4) {
HXDLIN(  42)							if (found) {
HXDLIN(  42)								goto _hx_goto_22;
            							}
            						}
            						else {
HXDLIN(  42)							if (((s + t) < A)) {
HXDLIN(  42)								{
HXDLIN(  42)									int c3 = color;
HXDLIN(  42)									bool _hx_tmp5;
HXDLIN(  42)									if ((((c3 >> 24) & 255) < 254)) {
HXDLIN(  42)										_hx_tmp5 = this1->transparent;
            									}
            									else {
HXDLIN(  42)										_hx_tmp5 = false;
            									}
HXDLIN(  42)									if (_hx_tmp5) {
HXDLIN(  42)										int location1;
HXDLIN(  42)										if (this1->useVirtualPos) {
HXDLIN(  42)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXDLIN(  42)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN(  42)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  42)										int this25;
HXDLIN(  42)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  42)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXDLIN(  42)											this25 = this24;
            										}
HXDLIN(  42)										Float a11;
HXDLIN(  42)										int this26 = ((this25 >> 24) & 255);
HXDLIN(  42)										if ((this26 == 0)) {
HXDLIN(  42)											a11 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float r11;
HXDLIN(  42)										int this27 = ((this25 >> 16) & 255);
HXDLIN(  42)										if ((this27 == 0)) {
HXDLIN(  42)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float g11;
HXDLIN(  42)										int this28 = ((this25 >> 8) & 255);
HXDLIN(  42)										if ((this28 == 0)) {
HXDLIN(  42)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float b12;
HXDLIN(  42)										int this29 = (this25 & 255);
HXDLIN(  42)										if ((this29 == 0)) {
HXDLIN(  42)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float a21;
HXDLIN(  42)										int this30 = ((color >> 24) & 255);
HXDLIN(  42)										if ((this30 == 0)) {
HXDLIN(  42)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float r21;
HXDLIN(  42)										int this31 = ((color >> 16) & 255);
HXDLIN(  42)										if ((this31 == 0)) {
HXDLIN(  42)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float g21;
HXDLIN(  42)										int this32 = ((color >> 8) & 255);
HXDLIN(  42)										if ((this32 == 0)) {
HXDLIN(  42)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float b22;
HXDLIN(  42)										int this33 = (color & 255);
HXDLIN(  42)										if ((this33 == 0)) {
HXDLIN(  42)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN(  42)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN(  42)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  42)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  42)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  42)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  42)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  42)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  42)										{
HXDLIN(  42)											int _hx_tmp6;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  42)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN(  42)												_hx_tmp6 = blended1;
            											}
HXDLIN(  42)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXDLIN(  42)										::Dynamic this34 = this1->image;
HXDLIN(  42)										int index4;
HXDLIN(  42)										if (this1->useVirtualPos) {
HXDLIN(  42)											index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXDLIN(  42)											index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN(  42)										int _hx_tmp7;
HXDLIN(  42)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  42)											_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXDLIN(  42)											_hx_tmp7 = c3;
            										}
HXDLIN(  42)										::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            									}
            								}
HXLINE(  73)								found = true;
            							}
            							else {
HXDLIN(  42)								if (found) {
HXDLIN(  42)									goto _hx_goto_22;
            								}
            							}
            						}
            					}
            					_hx_goto_22:;
            				}
            			}
            		}
HXDLIN(  42)		if ((hasHit == true)) {
HXDLIN(  42)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  42)			if (hasUndo) {
HXDLIN(  42)				v2->undoImage = undoImage;
HXDLIN(  42)				v2->undoX = xIter3->start;
HXDLIN(  42)				v2->undoY = yIter3->start;
            			}
HXDLIN(  42)			return v2;
            		}
            		else {
HXDLIN(  42)			return null();
            		}
HXDLIN(  42)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(FillShape_Impl__obj,triangle,return )

 ::pi_xy::algo::HitQuad FillShape_Impl__obj::quad( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy,int color,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_58_quad)
HXDLIN(  58)		{
HXDLIN(  58)			Float bx1 = bx;
HXDLIN(  58)			Float by1 = by;
HXDLIN(  58)			Float cx1 = dx;
HXDLIN(  58)			Float cy1 = dy;
HXDLIN(  58)			bool hasUndo = false;
HXDLIN(  58)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  58)			if (!(adjustWinding)) {
HXDLIN(  58)				Float bx_ = bx1;
HXDLIN(  58)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE(  58)			{
HXDLIN(  58)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  58)				Float sx = (cy1 - ay);
HXDLIN(  58)				Float sy = (ax - cx1);
HXDLIN(  58)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  58)				Float tx = (ay - by1);
HXDLIN(  58)				Float ty = (bx1 - ax);
HXDLIN(  58)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  58)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  58)				if ((ax > bx1)) {
HXDLIN(  58)					if ((ax > cx1)) {
HXDLIN(  58)						int min;
HXDLIN(  58)						if ((bx1 > cx1)) {
HXDLIN(  58)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXDLIN(  58)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN(  58)						int ii_min = min;
HXDLIN(  58)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  58)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXDLIN(  58)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  58)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  58)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXDLIN(  58)					if ((bx1 > cx1)) {
HXDLIN(  58)						int min1;
HXDLIN(  58)						if ((ax > cx1)) {
HXDLIN(  58)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXDLIN(  58)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN(  58)						int ii_min2 = min1;
HXDLIN(  58)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  58)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXDLIN(  58)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  58)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  58)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN(  58)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  58)				if ((ay > by1)) {
HXDLIN(  58)					if ((ay > cy1)) {
HXDLIN(  58)						int min2;
HXDLIN(  58)						if ((by1 > cy1)) {
HXDLIN(  58)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXDLIN(  58)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN(  58)						int ii_min4 = min2;
HXDLIN(  58)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  58)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXDLIN(  58)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  58)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  58)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXDLIN(  58)					if ((by1 > cy1)) {
HXDLIN(  58)						int min3;
HXDLIN(  58)						if ((ay > cy1)) {
HXDLIN(  58)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXDLIN(  58)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN(  58)						int ii_min6 = min3;
HXDLIN(  58)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  58)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXDLIN(  58)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  58)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  58)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN(  58)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  58)				if (hasUndo) {
HXDLIN(  58)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  58)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  58)					 ::Dynamic imageType = null();
HXDLIN(  58)					 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  58)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  58)					::Dynamic undoImage1;
HXDLIN(  58)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXDLIN(  58)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::BytesImg b = byt;
HXDLIN(  58)							{
HXDLIN(  58)								b->width = width;
HXDLIN(  58)								b->height = height;
HXDLIN(  58)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  58)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  58)								{
HXDLIN(  58)									int len = b->length;
HXDLIN(  58)									int w = 0;
HXDLIN(  58)									{
HXDLIN(  58)										int _g = 0;
HXDLIN(  58)										int _g1 = b->height;
HXDLIN(  58)										while((_g < _g1)){
HXDLIN(  58)											_g = (_g + 1);
HXDLIN(  58)											int y = (_g - 1);
HXDLIN(  58)											{
HXDLIN(  58)												int _g2 = 0;
HXDLIN(  58)												int _g3 = b->width;
HXDLIN(  58)												while((_g2 < _g3)){
HXDLIN(  58)													_g2 = (_g2 + 1);
HXDLIN(  58)													int x = (_g2 - 1);
HXDLIN(  58)													{
HXDLIN(  58)														w = (w + 1);
HXDLIN(  58)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  58)													{
HXDLIN(  58)														w = (w + 1);
HXDLIN(  58)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  58)													{
HXDLIN(  58)														w = (w + 1);
HXDLIN(  58)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  58)													{
HXDLIN(  58)														w = (w + 1);
HXDLIN(  58)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  58)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXDLIN(  58)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  58)							{
HXDLIN(  58)								a->width = width;
HXDLIN(  58)								a->height = height;
HXDLIN(  58)								a->data = ::Array_obj< int >::__new(0);
HXDLIN(  58)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  58)								{
HXDLIN(  58)									int _g4 = 0;
HXDLIN(  58)									int _g5 = a->length;
HXDLIN(  58)									while((_g4 < _g5)){
HXDLIN(  58)										_g4 = (_g4 + 1);
HXDLIN(  58)										int i = (_g4 - 1);
HXDLIN(  58)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN(  58)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXDLIN(  58)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  58)							{
HXDLIN(  58)								b1->width = width;
HXDLIN(  58)								b1->height = height;
HXDLIN(  58)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  58)								int size = (b1->length * 4);
HXDLIN(  58)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  58)								{
HXDLIN(  58)									int _g6 = 0;
HXDLIN(  58)									int _g7 = b1->length;
HXDLIN(  58)									while((_g6 < _g7)){
HXDLIN(  58)										_g6 = (_g6 + 1);
HXDLIN(  58)										int i1 = (_g6 - 1);
HXDLIN(  58)										{
HXDLIN(  58)											 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  58)											bool undoImage2;
HXDLIN(  58)											if ((i1 >= 0)) {
HXDLIN(  58)												undoImage2 = (i1 < (this3->byteLength >> 2));
            											}
            											else {
HXDLIN(  58)												undoImage2 = false;
            											}
HXDLIN(  58)											if (undoImage2) {
HXDLIN(  58)												 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  58)												int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  58)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  58)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  58)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  58)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  58)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXDLIN(  58)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::VecIntImg v = vec;
HXDLIN(  58)							{
HXDLIN(  58)								v->width = width;
HXDLIN(  58)								v->height = height;
HXDLIN(  58)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  58)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  58)								{
HXDLIN(  58)									int _g8 = 0;
HXDLIN(  58)									int _g9 = v->length;
HXDLIN(  58)									while((_g8 < _g9)){
HXDLIN(  58)										_g8 = (_g8 + 1);
HXDLIN(  58)										int i2 = (_g8 - 1);
HXDLIN(  58)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN(  58)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXDLIN(  58)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  58)							{
HXDLIN(  58)								b2->width = width;
HXDLIN(  58)								b2->height = height;
HXDLIN(  58)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  58)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  58)								{
HXDLIN(  58)									int len1 = b2->length;
HXDLIN(  58)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  58)									if (::hx::IsNull( d->head )) {
HXDLIN(  58)										int _g10 = 0;
HXDLIN(  58)										int _g11 = len1;
HXDLIN(  58)										while((_g10 < _g11)){
HXDLIN(  58)											_g10 = (_g10 + 1);
HXDLIN(  58)											int i3 = (_g10 - 1);
HXDLIN(  58)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXDLIN(  58)										int _g12 = 0;
HXDLIN(  58)										int _g13 = len1;
HXDLIN(  58)										while((_g12 < _g13)){
HXDLIN(  58)											_g12 = (_g12 + 1);
HXDLIN(  58)											int i4 = (_g12 - 1);
HXDLIN(  58)											{
HXDLIN(  58)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  58)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  58)												{
HXDLIN(  58)													int _g14 = 0;
HXDLIN(  58)													int _g15 = i4;
HXDLIN(  58)													while((_g14 < _g15)){
HXDLIN(  58)														_g14 = (_g14 + 1);
HXDLIN(  58)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE(  58)												if (::hx::IsNull( prev )) {
HXDLIN(  58)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  58)													l = null();
            												}
            												else {
HXDLIN(  58)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  58)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  58)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN(  58)					this2->image = undoImage1;
HXDLIN(  58)					this2->width = width;
HXDLIN(  58)					this2->height = height;
HXDLIN(  58)					this2->imageType = ( (int)(imageType) );
HXDLIN(  58)					undoImage = this2;
HXDLIN(  58)					{
HXDLIN(  58)						int rectLeft = xIter3->start;
HXDLIN(  58)						int rectTop = yIter3->start;
HXDLIN(  58)						int rectRight = xIter3->max;
HXDLIN(  58)						bool forceClear = false;
HXDLIN(  58)						{
HXDLIN(  58)							int _g16 = rectTop;
HXDLIN(  58)							int _g17 = yIter3->max;
HXDLIN(  58)							while((_g16 < _g17)){
HXDLIN(  58)								_g16 = (_g16 + 1);
HXDLIN(  58)								int dy1 = (_g16 - 1);
HXDLIN(  58)								{
HXDLIN(  58)									int _g18 = rectLeft;
HXDLIN(  58)									int _g19 = rectRight;
HXDLIN(  58)									while((_g18 < _g19)){
HXDLIN(  58)										_g18 = (_g18 + 1);
HXDLIN(  58)										int dx1 = (_g18 - 1);
HXDLIN(  58)										::Dynamic this4 = this1->image;
HXDLIN(  58)										int index;
HXDLIN(  58)										if (this1->useVirtualPos) {
HXDLIN(  58)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            										}
            										else {
HXDLIN(  58)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            										}
HXDLIN(  58)										int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  58)										int col;
HXDLIN(  58)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXDLIN(  58)											col = c;
            										}
HXDLIN(  58)										bool _hx_tmp;
HXDLIN(  58)										if (this1->useMask) {
HXDLIN(  58)											_hx_tmp = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN(  58)											_hx_tmp = false;
            										}
HXDLIN(  58)										if (_hx_tmp) {
HXDLIN(  58)											 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  58)											::Dynamic this6 = this5->image;
HXDLIN(  58)											int index1;
HXDLIN(  58)											if (this5->useVirtualPos) {
HXDLIN(  58)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            											}
            											else {
HXDLIN(  58)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            											}
HXDLIN(  58)											int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  58)											int v1;
HXDLIN(  58)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXDLIN(  58)												v1 = c1;
            											}
HXDLIN(  58)											int maskPixel = v1;
HXDLIN(  58)											int this7 = col;
HXDLIN(  58)											if ((maskPixel == 0)) {
HXDLIN(  58)												col = this7;
            											}
            											else {
HXDLIN(  58)												Float m0;
HXDLIN(  58)												int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  58)												if ((this8 == 0)) {
HXDLIN(  58)													m0 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float m1;
HXDLIN(  58)												int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  58)												if ((this9 == 0)) {
HXDLIN(  58)													m1 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float m2;
HXDLIN(  58)												int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  58)												if ((this10 == 0)) {
HXDLIN(  58)													m2 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float m3;
HXDLIN(  58)												int this11 = (maskPixel & 255);
HXDLIN(  58)												if ((this11 == 0)) {
HXDLIN(  58)													m3 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  58)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  58)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  58)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  58)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  58)										if ((col != 0)) {
HXDLIN(  58)											int x1 = (dx1 - rectLeft);
HXDLIN(  58)											int y1 = (dy1 - rectTop);
HXDLIN(  58)											int c2 = col;
HXDLIN(  58)											bool _hx_tmp1;
HXDLIN(  58)											if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  58)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXDLIN(  58)												_hx_tmp1 = false;
            											}
HXDLIN(  58)											if (_hx_tmp1) {
HXDLIN(  58)												int location;
HXDLIN(  58)												if (undoImage->useVirtualPos) {
HXDLIN(  58)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  58)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN(  58)												int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  58)												int this13;
HXDLIN(  58)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)													this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            												}
            												else {
HXDLIN(  58)													this13 = this12;
            												}
HXDLIN(  58)												Float a1;
HXDLIN(  58)												int this14 = ((this13 >> 24) & 255);
HXDLIN(  58)												if ((this14 == 0)) {
HXDLIN(  58)													a1 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float r1;
HXDLIN(  58)												int this15 = ((this13 >> 16) & 255);
HXDLIN(  58)												if ((this15 == 0)) {
HXDLIN(  58)													r1 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float g1;
HXDLIN(  58)												int this16 = ((this13 >> 8) & 255);
HXDLIN(  58)												if ((this16 == 0)) {
HXDLIN(  58)													g1 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float b11;
HXDLIN(  58)												int this17 = (this13 & 255);
HXDLIN(  58)												if ((this17 == 0)) {
HXDLIN(  58)													b11 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float a2;
HXDLIN(  58)												int this18 = ((col >> 24) & 255);
HXDLIN(  58)												if ((this18 == 0)) {
HXDLIN(  58)													a2 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float r2;
HXDLIN(  58)												int this19 = ((col >> 16) & 255);
HXDLIN(  58)												if ((this19 == 0)) {
HXDLIN(  58)													r2 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float g2;
HXDLIN(  58)												int this20 = ((col >> 8) & 255);
HXDLIN(  58)												if ((this20 == 0)) {
HXDLIN(  58)													g2 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float b21;
HXDLIN(  58)												int this21 = (col & 255);
HXDLIN(  58)												if ((this21 == 0)) {
HXDLIN(  58)													b21 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  58)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  58)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  58)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  58)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  58)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  58)												{
HXDLIN(  58)													int _hx_tmp2;
HXDLIN(  58)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXDLIN(  58)														_hx_tmp2 = blended;
            													}
HXDLIN(  58)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXDLIN(  58)												::Dynamic this22 = undoImage->image;
HXDLIN(  58)												int index2;
HXDLIN(  58)												if (undoImage->useVirtualPos) {
HXDLIN(  58)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  58)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN(  58)												int _hx_tmp3;
HXDLIN(  58)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXDLIN(  58)													_hx_tmp3 = c2;
            												}
HXDLIN(  58)												::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            											}
            										}
            										else {
HXDLIN(  58)											if (forceClear) {
HXDLIN(  58)												::Dynamic this23 = undoImage->image;
HXDLIN(  58)												int x2 = (dx1 - rectLeft);
HXDLIN(  58)												int y2 = (dy1 - rectTop);
HXDLIN(  58)												int index3;
HXDLIN(  58)												if (undoImage->useVirtualPos) {
HXDLIN(  58)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  58)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN(  58)												::iterMagic::Iimg_obj::set(this23,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  58)				bool found = false;
HXDLIN(  58)				Float s = ((Float)0.);
HXDLIN(  58)				Float t = ((Float)0.);
HXDLIN(  58)				Float sxx = ((Float)0.);
HXDLIN(  58)				Float txx = ((Float)0.);
HXDLIN(  58)				{
HXDLIN(  58)					int _g_min = xIter3->start;
HXDLIN(  58)					int _g_max = xIter3->max;
HXDLIN(  58)					while((_g_min < _g_max)){
HXDLIN(  58)						_g_min = (_g_min + 1);
HXDLIN(  58)						int x3 = (_g_min - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)						txx = (tx * ( (Float)(x3) ));
HXLINE(  62)						found = false;
HXLINE(  58)						{
HXDLIN(  58)							int _g_min1 = yIter3->start;
HXDLIN(  58)							int _g_max1 = yIter3->max;
HXDLIN(  58)							while((_g_min1 < _g_max1)){
HXDLIN(  58)								_g_min1 = (_g_min1 + 1);
HXDLIN(  58)								int y3 = (_g_min1 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  58)								bool _hx_tmp4;
HXDLIN(  58)								if (!((s <= 0))) {
HXDLIN(  58)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXDLIN(  58)									_hx_tmp4 = true;
            								}
HXDLIN(  58)								if (_hx_tmp4) {
HXDLIN(  58)									if (found) {
HXDLIN(  58)										goto _hx_goto_35;
            									}
            								}
            								else {
HXDLIN(  58)									if (((s + t) < A)) {
HXDLIN(  58)										{
HXDLIN(  58)											int c3 = color;
HXDLIN(  58)											bool _hx_tmp5;
HXDLIN(  58)											if ((((c3 >> 24) & 255) < 254)) {
HXDLIN(  58)												_hx_tmp5 = this1->transparent;
            											}
            											else {
HXDLIN(  58)												_hx_tmp5 = false;
            											}
HXDLIN(  58)											if (_hx_tmp5) {
HXDLIN(  58)												int location1;
HXDLIN(  58)												if (this1->useVirtualPos) {
HXDLIN(  58)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXDLIN(  58)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN(  58)												int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  58)												int this25;
HXDLIN(  58)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)													this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXDLIN(  58)													this25 = this24;
            												}
HXDLIN(  58)												Float a11;
HXDLIN(  58)												int this26 = ((this25 >> 24) & 255);
HXDLIN(  58)												if ((this26 == 0)) {
HXDLIN(  58)													a11 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float r11;
HXDLIN(  58)												int this27 = ((this25 >> 16) & 255);
HXDLIN(  58)												if ((this27 == 0)) {
HXDLIN(  58)													r11 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float g11;
HXDLIN(  58)												int this28 = ((this25 >> 8) & 255);
HXDLIN(  58)												if ((this28 == 0)) {
HXDLIN(  58)													g11 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float b12;
HXDLIN(  58)												int this29 = (this25 & 255);
HXDLIN(  58)												if ((this29 == 0)) {
HXDLIN(  58)													b12 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float a21;
HXDLIN(  58)												int this30 = ((color >> 24) & 255);
HXDLIN(  58)												if ((this30 == 0)) {
HXDLIN(  58)													a21 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float r21;
HXDLIN(  58)												int this31 = ((color >> 16) & 255);
HXDLIN(  58)												if ((this31 == 0)) {
HXDLIN(  58)													r21 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float g21;
HXDLIN(  58)												int this32 = ((color >> 8) & 255);
HXDLIN(  58)												if ((this32 == 0)) {
HXDLIN(  58)													g21 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float b22;
HXDLIN(  58)												int this33 = (color & 255);
HXDLIN(  58)												if ((this33 == 0)) {
HXDLIN(  58)													b22 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  58)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  58)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  58)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  58)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  58)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  58)												{
HXDLIN(  58)													int _hx_tmp6;
HXDLIN(  58)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXDLIN(  58)														_hx_tmp6 = blended1;
            													}
HXDLIN(  58)													::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXDLIN(  58)												::Dynamic this34 = this1->image;
HXDLIN(  58)												int index4;
HXDLIN(  58)												if (this1->useVirtualPos) {
HXDLIN(  58)													index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXDLIN(  58)													index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN(  58)												int _hx_tmp7;
HXDLIN(  58)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)													_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXDLIN(  58)													_hx_tmp7 = c3;
            												}
HXDLIN(  58)												::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            											}
            										}
HXLINE(  73)										found = true;
            									}
            									else {
HXDLIN(  58)										if (found) {
HXDLIN(  58)											goto _hx_goto_35;
            										}
            									}
            								}
            							}
            							_hx_goto_35:;
            						}
            					}
            				}
HXDLIN(  58)				if ((hasHit == true)) {
HXDLIN(  58)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  58)					if (hasUndo) {
HXDLIN(  58)						v2->undoImage = undoImage;
HXDLIN(  58)						v2->undoX = xIter3->start;
HXDLIN(  58)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN(  58)		{
HXDLIN(  58)			Float bx2 = cx;
HXDLIN(  58)			Float by2 = cy;
HXDLIN(  58)			Float cx2 = dx;
HXDLIN(  58)			Float cy2 = dy;
HXDLIN(  58)			bool hasUndo1 = false;
HXDLIN(  58)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  58)			if (!(adjustWinding1)) {
HXDLIN(  58)				Float bx_1 = bx2;
HXDLIN(  58)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE(  58)			{
HXDLIN(  58)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  58)				Float sx1 = (cy2 - by);
HXDLIN(  58)				Float sy1 = (bx - cx2);
HXDLIN(  58)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  58)				Float tx1 = (by - by2);
HXDLIN(  58)				Float ty1 = (bx2 - bx);
HXDLIN(  58)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  58)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  58)				if ((bx > bx2)) {
HXDLIN(  58)					if ((bx > cx2)) {
HXDLIN(  58)						int min4;
HXDLIN(  58)						if ((bx2 > cx2)) {
HXDLIN(  58)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXDLIN(  58)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN(  58)						int ii_min8 = min4;
HXDLIN(  58)						int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN(  58)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXDLIN(  58)						int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN(  58)						int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  58)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXDLIN(  58)					if ((bx2 > cx2)) {
HXDLIN(  58)						int min5;
HXDLIN(  58)						if ((bx > cx2)) {
HXDLIN(  58)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXDLIN(  58)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN(  58)						int ii_min10 = min5;
HXDLIN(  58)						int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN(  58)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXDLIN(  58)						int ii_min11 = ::Math_obj::floor(bx);
HXDLIN(  58)						int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  58)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN(  58)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  58)				if ((by > by2)) {
HXDLIN(  58)					if ((by > cy2)) {
HXDLIN(  58)						int min6;
HXDLIN(  58)						if ((by2 > cy2)) {
HXDLIN(  58)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXDLIN(  58)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN(  58)						int ii_min12 = min6;
HXDLIN(  58)						int ii_max12 = ::Math_obj::ceil(by);
HXDLIN(  58)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXDLIN(  58)						int ii_min13 = ::Math_obj::floor(by2);
HXDLIN(  58)						int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  58)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXDLIN(  58)					if ((by2 > cy2)) {
HXDLIN(  58)						int min7;
HXDLIN(  58)						if ((by > cy2)) {
HXDLIN(  58)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXDLIN(  58)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN(  58)						int ii_min14 = min7;
HXDLIN(  58)						int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN(  58)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXDLIN(  58)						int ii_min15 = ::Math_obj::floor(by);
HXDLIN(  58)						int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  58)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN(  58)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  58)				if (hasUndo1) {
HXDLIN(  58)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  58)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  58)					 ::Dynamic imageType1 = null();
HXDLIN(  58)					 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  58)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  58)					::Dynamic undoImage4;
HXDLIN(  58)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXDLIN(  58)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  58)							{
HXDLIN(  58)								b5->width = width1;
HXDLIN(  58)								b5->height = height1;
HXDLIN(  58)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  58)								{
HXDLIN(  58)									int len2 = b5->length;
HXDLIN(  58)									int w1 = 0;
HXDLIN(  58)									{
HXDLIN(  58)										int _g20 = 0;
HXDLIN(  58)										int _g21 = b5->height;
HXDLIN(  58)										while((_g20 < _g21)){
HXDLIN(  58)											_g20 = (_g20 + 1);
HXDLIN(  58)											int y4 = (_g20 - 1);
HXDLIN(  58)											{
HXDLIN(  58)												int _g22 = 0;
HXDLIN(  58)												int _g23 = b5->width;
HXDLIN(  58)												while((_g22 < _g23)){
HXDLIN(  58)													_g22 = (_g22 + 1);
HXDLIN(  58)													int x4 = (_g22 - 1);
HXDLIN(  58)													{
HXDLIN(  58)														w1 = (w1 + 1);
HXDLIN(  58)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  58)													{
HXDLIN(  58)														w1 = (w1 + 1);
HXDLIN(  58)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  58)													{
HXDLIN(  58)														w1 = (w1 + 1);
HXDLIN(  58)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  58)													{
HXDLIN(  58)														w1 = (w1 + 1);
HXDLIN(  58)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  58)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXDLIN(  58)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  58)							{
HXDLIN(  58)								a6->width = width1;
HXDLIN(  58)								a6->height = height1;
HXDLIN(  58)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  58)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)								{
HXDLIN(  58)									int _g24 = 0;
HXDLIN(  58)									int _g25 = a6->length;
HXDLIN(  58)									while((_g24 < _g25)){
HXDLIN(  58)										_g24 = (_g24 + 1);
HXDLIN(  58)										int i6 = (_g24 - 1);
HXDLIN(  58)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN(  58)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXDLIN(  58)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  58)							{
HXDLIN(  58)								b6->width = width1;
HXDLIN(  58)								b6->height = height1;
HXDLIN(  58)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)								int size1 = (b6->length * 4);
HXDLIN(  58)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  58)								{
HXDLIN(  58)									int _g26 = 0;
HXDLIN(  58)									int _g27 = b6->length;
HXDLIN(  58)									while((_g26 < _g27)){
HXDLIN(  58)										_g26 = (_g26 + 1);
HXDLIN(  58)										int i7 = (_g26 - 1);
HXDLIN(  58)										{
HXDLIN(  58)											 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN(  58)											bool undoImage5;
HXDLIN(  58)											if ((i7 >= 0)) {
HXDLIN(  58)												undoImage5 = (i7 < (this36->byteLength >> 2));
            											}
            											else {
HXDLIN(  58)												undoImage5 = false;
            											}
HXDLIN(  58)											if (undoImage5) {
HXDLIN(  58)												 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN(  58)												int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN(  58)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  58)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  58)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  58)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  58)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXDLIN(  58)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  58)							{
HXDLIN(  58)								v3->width = width1;
HXDLIN(  58)								v3->height = height1;
HXDLIN(  58)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  58)								{
HXDLIN(  58)									int _g28 = 0;
HXDLIN(  58)									int _g29 = v3->length;
HXDLIN(  58)									while((_g28 < _g29)){
HXDLIN(  58)										_g28 = (_g28 + 1);
HXDLIN(  58)										int i8 = (_g28 - 1);
HXDLIN(  58)										v3->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN(  58)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXDLIN(  58)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  58)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  58)							{
HXDLIN(  58)								b7->width = width1;
HXDLIN(  58)								b7->height = height1;
HXDLIN(  58)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  58)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  58)								{
HXDLIN(  58)									int len3 = b7->length;
HXDLIN(  58)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  58)									if (::hx::IsNull( d1->head )) {
HXDLIN(  58)										int _g30 = 0;
HXDLIN(  58)										int _g31 = len3;
HXDLIN(  58)										while((_g30 < _g31)){
HXDLIN(  58)											_g30 = (_g30 + 1);
HXDLIN(  58)											int i9 = (_g30 - 1);
HXDLIN(  58)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXDLIN(  58)										int _g32 = 0;
HXDLIN(  58)										int _g33 = len3;
HXDLIN(  58)										while((_g32 < _g33)){
HXDLIN(  58)											_g32 = (_g32 + 1);
HXDLIN(  58)											int i10 = (_g32 - 1);
HXDLIN(  58)											{
HXDLIN(  58)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  58)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  58)												{
HXDLIN(  58)													int _g34 = 0;
HXDLIN(  58)													int _g35 = i10;
HXDLIN(  58)													while((_g34 < _g35)){
HXDLIN(  58)														_g34 = (_g34 + 1);
HXDLIN(  58)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE(  58)												if (::hx::IsNull( prev1 )) {
HXDLIN(  58)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  58)													l1 = null();
            												}
            												else {
HXDLIN(  58)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  58)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  58)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN(  58)					this35->image = undoImage4;
HXDLIN(  58)					this35->width = width1;
HXDLIN(  58)					this35->height = height1;
HXDLIN(  58)					this35->imageType = ( (int)(imageType1) );
HXDLIN(  58)					undoImage3 = this35;
HXDLIN(  58)					{
HXDLIN(  58)						int rectLeft1 = xIter31->start;
HXDLIN(  58)						int rectTop1 = yIter31->start;
HXDLIN(  58)						int rectRight1 = xIter31->max;
HXDLIN(  58)						bool forceClear1 = false;
HXDLIN(  58)						{
HXDLIN(  58)							int _g36 = rectTop1;
HXDLIN(  58)							int _g37 = yIter31->max;
HXDLIN(  58)							while((_g36 < _g37)){
HXDLIN(  58)								_g36 = (_g36 + 1);
HXDLIN(  58)								int dy2 = (_g36 - 1);
HXDLIN(  58)								{
HXDLIN(  58)									int _g38 = rectLeft1;
HXDLIN(  58)									int _g39 = rectRight1;
HXDLIN(  58)									while((_g38 < _g39)){
HXDLIN(  58)										_g38 = (_g38 + 1);
HXDLIN(  58)										int dx2 = (_g38 - 1);
HXDLIN(  58)										::Dynamic this37 = this1->image;
HXDLIN(  58)										int index5;
HXDLIN(  58)										if (this1->useVirtualPos) {
HXDLIN(  58)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            										}
            										else {
HXDLIN(  58)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            										}
HXDLIN(  58)										int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN(  58)										int col1;
HXDLIN(  58)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)											col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN(  58)											col1 = c4;
            										}
HXDLIN(  58)										bool _hx_tmp8;
HXDLIN(  58)										if (this1->useMask) {
HXDLIN(  58)											_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN(  58)											_hx_tmp8 = false;
            										}
HXDLIN(  58)										if (_hx_tmp8) {
HXDLIN(  58)											 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN(  58)											::Dynamic this39 = this38->image;
HXDLIN(  58)											int index6;
HXDLIN(  58)											if (this38->useVirtualPos) {
HXDLIN(  58)												index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            											}
            											else {
HXDLIN(  58)												index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            											}
HXDLIN(  58)											int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN(  58)											int v4;
HXDLIN(  58)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)												v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXDLIN(  58)												v4 = c5;
            											}
HXDLIN(  58)											int maskPixel1 = v4;
HXDLIN(  58)											int this40 = col1;
HXDLIN(  58)											if ((maskPixel1 == 0)) {
HXDLIN(  58)												col1 = this40;
            											}
            											else {
HXDLIN(  58)												Float m01;
HXDLIN(  58)												int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN(  58)												if ((this41 == 0)) {
HXDLIN(  58)													m01 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float m11;
HXDLIN(  58)												int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN(  58)												if ((this42 == 0)) {
HXDLIN(  58)													m11 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float m21;
HXDLIN(  58)												int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN(  58)												if ((this43 == 0)) {
HXDLIN(  58)													m21 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float m31;
HXDLIN(  58)												int this44 = (maskPixel1 & 255);
HXDLIN(  58)												if ((this44 == 0)) {
HXDLIN(  58)													m31 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN(  58)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN(  58)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN(  58)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN(  58)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  58)										if ((col1 != 0)) {
HXDLIN(  58)											int x5 = (dx2 - rectLeft1);
HXDLIN(  58)											int y5 = (dy2 - rectTop1);
HXDLIN(  58)											int c6 = col1;
HXDLIN(  58)											bool _hx_tmp9;
HXDLIN(  58)											if ((((c6 >> 24) & 255) < 254)) {
HXDLIN(  58)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXDLIN(  58)												_hx_tmp9 = false;
            											}
HXDLIN(  58)											if (_hx_tmp9) {
HXDLIN(  58)												int location2;
HXDLIN(  58)												if (undoImage3->useVirtualPos) {
HXDLIN(  58)													location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  58)													location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN(  58)												int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  58)												int this46;
HXDLIN(  58)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)													this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            												}
            												else {
HXDLIN(  58)													this46 = this45;
            												}
HXDLIN(  58)												Float a12;
HXDLIN(  58)												int this47 = ((this46 >> 24) & 255);
HXDLIN(  58)												if ((this47 == 0)) {
HXDLIN(  58)													a12 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float r12;
HXDLIN(  58)												int this48 = ((this46 >> 16) & 255);
HXDLIN(  58)												if ((this48 == 0)) {
HXDLIN(  58)													r12 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float g12;
HXDLIN(  58)												int this49 = ((this46 >> 8) & 255);
HXDLIN(  58)												if ((this49 == 0)) {
HXDLIN(  58)													g12 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float b13;
HXDLIN(  58)												int this50 = (this46 & 255);
HXDLIN(  58)												if ((this50 == 0)) {
HXDLIN(  58)													b13 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float a22;
HXDLIN(  58)												int this51 = ((col1 >> 24) & 255);
HXDLIN(  58)												if ((this51 == 0)) {
HXDLIN(  58)													a22 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float r22;
HXDLIN(  58)												int this52 = ((col1 >> 16) & 255);
HXDLIN(  58)												if ((this52 == 0)) {
HXDLIN(  58)													r22 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float g22;
HXDLIN(  58)												int this53 = ((col1 >> 8) & 255);
HXDLIN(  58)												if ((this53 == 0)) {
HXDLIN(  58)													g22 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float b23;
HXDLIN(  58)												int this54 = (col1 & 255);
HXDLIN(  58)												if ((this54 == 0)) {
HXDLIN(  58)													b23 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  58)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  58)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  58)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  58)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  58)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  58)												{
HXDLIN(  58)													int _hx_tmp10;
HXDLIN(  58)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXDLIN(  58)														_hx_tmp10 = blended2;
            													}
HXDLIN(  58)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXDLIN(  58)												::Dynamic this55 = undoImage3->image;
HXDLIN(  58)												int index7;
HXDLIN(  58)												if (undoImage3->useVirtualPos) {
HXDLIN(  58)													index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  58)													index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN(  58)												int _hx_tmp11;
HXDLIN(  58)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)													_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXDLIN(  58)													_hx_tmp11 = c6;
            												}
HXDLIN(  58)												::iterMagic::Iimg_obj::set(this55,index7,_hx_tmp11);
            											}
            										}
            										else {
HXDLIN(  58)											if (forceClear1) {
HXDLIN(  58)												::Dynamic this56 = undoImage3->image;
HXDLIN(  58)												int x6 = (dx2 - rectLeft1);
HXDLIN(  58)												int y6 = (dy2 - rectTop1);
HXDLIN(  58)												int index8;
HXDLIN(  58)												if (undoImage3->useVirtualPos) {
HXDLIN(  58)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  58)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN(  58)												::iterMagic::Iimg_obj::set(this56,index8,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  58)				bool found1 = false;
HXDLIN(  58)				Float s1 = ((Float)0.);
HXDLIN(  58)				Float t1 = ((Float)0.);
HXDLIN(  58)				Float sxx1 = ((Float)0.);
HXDLIN(  58)				Float txx1 = ((Float)0.);
HXDLIN(  58)				{
HXDLIN(  58)					int _g_min2 = xIter31->start;
HXDLIN(  58)					int _g_max2 = xIter31->max;
HXDLIN(  58)					while((_g_min2 < _g_max2)){
HXDLIN(  58)						_g_min2 = (_g_min2 + 1);
HXDLIN(  58)						int x7 = (_g_min2 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)						found1 = false;
HXLINE(  58)						{
HXDLIN(  58)							int _g_min3 = yIter31->start;
HXDLIN(  58)							int _g_max3 = yIter31->max;
HXDLIN(  58)							while((_g_min3 < _g_max3)){
HXDLIN(  58)								_g_min3 = (_g_min3 + 1);
HXDLIN(  58)								int y7 = (_g_min3 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  58)								bool _hx_tmp12;
HXDLIN(  58)								if (!((s1 <= 0))) {
HXDLIN(  58)									_hx_tmp12 = (t1 <= 0);
            								}
            								else {
HXDLIN(  58)									_hx_tmp12 = true;
            								}
HXDLIN(  58)								if (_hx_tmp12) {
HXDLIN(  58)									if (found1) {
HXDLIN(  58)										goto _hx_goto_47;
            									}
            								}
            								else {
HXDLIN(  58)									if (((s1 + t1) < A1)) {
HXDLIN(  58)										{
HXDLIN(  58)											int c7 = color;
HXDLIN(  58)											bool _hx_tmp13;
HXDLIN(  58)											if ((((c7 >> 24) & 255) < 254)) {
HXDLIN(  58)												_hx_tmp13 = this1->transparent;
            											}
            											else {
HXDLIN(  58)												_hx_tmp13 = false;
            											}
HXDLIN(  58)											if (_hx_tmp13) {
HXDLIN(  58)												int location3;
HXDLIN(  58)												if (this1->useVirtualPos) {
HXDLIN(  58)													location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXDLIN(  58)													location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN(  58)												int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  58)												int this58;
HXDLIN(  58)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)													this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            												}
            												else {
HXDLIN(  58)													this58 = this57;
            												}
HXDLIN(  58)												Float a13;
HXDLIN(  58)												int this59 = ((this58 >> 24) & 255);
HXDLIN(  58)												if ((this59 == 0)) {
HXDLIN(  58)													a13 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													a13 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float r13;
HXDLIN(  58)												int this60 = ((this58 >> 16) & 255);
HXDLIN(  58)												if ((this60 == 0)) {
HXDLIN(  58)													r13 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float g13;
HXDLIN(  58)												int this61 = ((this58 >> 8) & 255);
HXDLIN(  58)												if ((this61 == 0)) {
HXDLIN(  58)													g13 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float b14;
HXDLIN(  58)												int this62 = (this58 & 255);
HXDLIN(  58)												if ((this62 == 0)) {
HXDLIN(  58)													b14 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float a23;
HXDLIN(  58)												int this63 = ((color >> 24) & 255);
HXDLIN(  58)												if ((this63 == 0)) {
HXDLIN(  58)													a23 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float r23;
HXDLIN(  58)												int this64 = ((color >> 16) & 255);
HXDLIN(  58)												if ((this64 == 0)) {
HXDLIN(  58)													r23 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float g23;
HXDLIN(  58)												int this65 = ((color >> 8) & 255);
HXDLIN(  58)												if ((this65 == 0)) {
HXDLIN(  58)													g23 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float b24;
HXDLIN(  58)												int this66 = (color & 255);
HXDLIN(  58)												if ((this66 == 0)) {
HXDLIN(  58)													b24 = ((Float)0.);
            												}
            												else {
HXDLIN(  58)													b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  58)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  58)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  58)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  58)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  58)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  58)												int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  58)												{
HXDLIN(  58)													int _hx_tmp14;
HXDLIN(  58)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXDLIN(  58)														_hx_tmp14 = blended3;
            													}
HXDLIN(  58)													::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXDLIN(  58)												::Dynamic this67 = this1->image;
HXDLIN(  58)												int index9;
HXDLIN(  58)												if (this1->useVirtualPos) {
HXDLIN(  58)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXDLIN(  58)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN(  58)												int _hx_tmp15;
HXDLIN(  58)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  58)													_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXDLIN(  58)													_hx_tmp15 = c7;
            												}
HXDLIN(  58)												::iterMagic::Iimg_obj::set(this67,index9,_hx_tmp15);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXDLIN(  58)										if (found1) {
HXDLIN(  58)											goto _hx_goto_47;
            										}
            									}
            								}
            							}
            							_hx_goto_47:;
            						}
            					}
            				}
HXDLIN(  58)				if ((hasHit == true)) {
HXDLIN(  58)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  58)					if (hasUndo1) {
HXDLIN(  58)						v5->undoImage = undoImage3;
HXDLIN(  58)						v5->undoX = xIter31->start;
HXDLIN(  58)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN(  58)		if ((hasHit == true)) {
HXDLIN(  58)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  58)			return v6;
            		}
            		else {
HXDLIN(  58)			return null();
            		}
HXDLIN(  58)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(FillShape_Impl__obj,quad,return )

 ::pi_xy::algo::HitQuad FillShape_Impl__obj::line( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float thick,int color,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		bool hasHit = __o_hasHit.Default(true);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_68_line)
HXLINE(  69)		Float o = (qy - py);
HXLINE(  70)		Float a = (qx - px);
HXLINE(  71)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXLINE(  72)		Float theta = ::Math_obj::atan2(o,a);
HXLINE(  73)		 ::Dynamic debugCorners1 = debugCorners;
HXLINE(  75)		if (::hx::IsNull( debugCorners1 )) {
HXLINE(  75)			debugCorners1 = false;
            		}
HXLINE(  73)		Float sin = ::Math_obj::sin(theta);
HXDLIN(  73)		Float cos = ::Math_obj::cos(theta);
HXDLIN(  73)		Float radius = (thick / ( (Float)(2) ));
HXDLIN(  73)		Float dx = ((Float)0.1);
HXDLIN(  73)		Float dy = radius;
HXDLIN(  73)		Float cx = h;
HXDLIN(  73)		Float cy = radius;
HXDLIN(  73)		Float bx = h;
HXDLIN(  73)		Float by = -(radius);
HXDLIN(  73)		Float ax = ((Float)0.1);
HXDLIN(  73)		Float ay = -(radius);
HXDLIN(  73)		Float temp = ((Float)0.);
HXLINE(  28)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE(  29)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE(  30)		ax = temp;
HXLINE(  32)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE(  33)		by = (py + ((by * cos) + (bx * sin)));
HXLINE(  34)		bx = temp;
HXLINE(  36)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE(  37)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE(  38)		cx = temp;
HXLINE(  40)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE(  41)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  42)		dx = temp;
HXLINE(  73)		if (( (bool)(debugCorners1) )) {
HXLINE(  73)			{
HXLINE(  73)				 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  73)				{
HXLINE(  73)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN(  73)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN(  73)					int r_w = 12;
HXDLIN(  73)					int r_h = 12;
HXDLIN(  73)					int xmax = ((r_x + r_w) + 1);
HXDLIN(  73)					int ymax = ((r_y + r_h) + 1);
HXDLIN(  73)					int ii_min = r_x;
HXDLIN(  73)					int ii_max = xmax;
HXDLIN(  73)					int xRange__start = ii_min;
HXDLIN(  73)					int xRange__max = ii_max;
HXDLIN(  73)					int ii_min1 = r_y;
HXDLIN(  73)					int ii_max1 = ymax;
HXDLIN(  73)					int yRange__start = ii_min1;
HXDLIN(  73)					int yRange__max = ii_max1;
HXDLIN(  73)					int range_x = xRange__start;
HXDLIN(  73)					int range_y = (yRange__start - 1);
HXDLIN(  73)					int range_xReset = range_x;
HXDLIN(  73)					int range_yReset = range_y;
HXDLIN(  73)					int range_xMax = (xRange__max - 2);
HXDLIN(  73)					int range_yMax = (yRange__max - 2);
HXDLIN(  73)					int _this_min = 0;
HXDLIN(  73)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  73)					while((_this_min < _this_max)){
HXLINE(  73)						_this_min = (_this_min + 1);
HXDLIN(  73)						int i = (_this_min - 1);
HXDLIN(  73)						if ((range_y > range_yMax)) {
HXLINE(  73)							range_y = range_yReset;
HXDLIN(  73)							range_x = (range_x + 1);
            						}
HXDLIN(  73)						range_y = (range_y + 1);
HXDLIN(  73)						int i1 = i;
HXDLIN(  73)						{
HXLINE(  73)							int x = range_x;
HXDLIN(  73)							int y = range_y;
HXDLIN(  73)							int c = -65536;
HXDLIN(  73)							bool _hx_tmp;
HXDLIN(  73)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  73)								_hx_tmp = this2->transparent;
            							}
            							else {
HXLINE(  73)								_hx_tmp = false;
            							}
HXDLIN(  73)							if (_hx_tmp) {
HXLINE(  73)								int location;
HXDLIN(  73)								if (this2->useVirtualPos) {
HXLINE(  73)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            								}
            								else {
HXLINE(  73)									location = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            								}
HXDLIN(  73)								int this3 = ::iterMagic::Iimg_obj::get(this2->image,location);
HXDLIN(  73)								int this4;
HXDLIN(  73)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  73)									this4 = this3;
            								}
HXDLIN(  73)								Float a1;
HXDLIN(  73)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  73)								if ((this5 == 0)) {
HXLINE(  73)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float r1;
HXDLIN(  73)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  73)								if ((this6 == 0)) {
HXLINE(  73)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float g1;
HXDLIN(  73)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  73)								if ((this7 == 0)) {
HXLINE(  73)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float b1;
HXDLIN(  73)								int this8 = (this4 & 255);
HXDLIN(  73)								if ((this8 == 0)) {
HXLINE(  73)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float a2;
HXDLIN(  73)								int this9 = ((-65536 >> 24) & 255);
HXDLIN(  73)								if ((this9 == 0)) {
HXLINE(  73)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float r2;
HXDLIN(  73)								int this10 = ((-65536 >> 16) & 255);
HXDLIN(  73)								if ((this10 == 0)) {
HXLINE(  73)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float g2;
HXDLIN(  73)								int this11 = ((-65536 >> 8) & 255);
HXDLIN(  73)								if ((this11 == 0)) {
HXLINE(  73)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float b2;
HXDLIN(  73)								int this12 = (-65536 & 255);
HXDLIN(  73)								if ((this12 == 0)) {
HXLINE(  73)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  73)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  73)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  73)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  73)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  73)								int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  73)								{
HXLINE(  73)									int _hx_tmp1;
HXDLIN(  73)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  73)										_hx_tmp1 = blended;
            									}
HXDLIN(  73)									::iterMagic::Iimg_obj::set(this2->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE(  73)								::Dynamic this13 = this2->image;
HXDLIN(  73)								int index;
HXDLIN(  73)								if (this2->useVirtualPos) {
HXLINE(  73)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            								}
            								else {
HXLINE(  73)									index = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            								}
HXDLIN(  73)								int _hx_tmp2;
HXDLIN(  73)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  73)									_hx_tmp2 = c;
            								}
HXDLIN(  73)								::iterMagic::Iimg_obj::set(this13,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  73)			{
HXLINE(  73)				 ::pi_xy::ImageStruct this14 = this1;
HXDLIN(  73)				{
HXLINE(  73)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN(  73)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN(  73)					int r_w1 = 12;
HXDLIN(  73)					int r_h1 = 12;
HXDLIN(  73)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN(  73)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN(  73)					int ii_min2 = r_x1;
HXDLIN(  73)					int ii_max2 = xmax1;
HXDLIN(  73)					int xRange__start1 = ii_min2;
HXDLIN(  73)					int xRange__max1 = ii_max2;
HXDLIN(  73)					int ii_min3 = r_y1;
HXDLIN(  73)					int ii_max3 = ymax1;
HXDLIN(  73)					int yRange__start1 = ii_min3;
HXDLIN(  73)					int yRange__max1 = ii_max3;
HXDLIN(  73)					int range_x1 = xRange__start1;
HXDLIN(  73)					int range_y1 = (yRange__start1 - 1);
HXDLIN(  73)					int range_xReset1 = range_x1;
HXDLIN(  73)					int range_yReset1 = range_y1;
HXDLIN(  73)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  73)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  73)					int _this_min1 = 0;
HXDLIN(  73)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  73)					while((_this_min1 < _this_max1)){
HXLINE(  73)						_this_min1 = (_this_min1 + 1);
HXDLIN(  73)						int i2 = (_this_min1 - 1);
HXDLIN(  73)						if ((range_y1 > range_yMax1)) {
HXLINE(  73)							range_y1 = range_yReset1;
HXDLIN(  73)							range_x1 = (range_x1 + 1);
            						}
HXDLIN(  73)						range_y1 = (range_y1 + 1);
HXDLIN(  73)						int i3 = i2;
HXDLIN(  73)						{
HXLINE(  73)							int x1 = range_x1;
HXDLIN(  73)							int y1 = range_y1;
HXDLIN(  73)							int c1 = -16711936;
HXDLIN(  73)							bool _hx_tmp3;
HXDLIN(  73)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  73)								_hx_tmp3 = this14->transparent;
            							}
            							else {
HXLINE(  73)								_hx_tmp3 = false;
            							}
HXDLIN(  73)							if (_hx_tmp3) {
HXLINE(  73)								int location1;
HXDLIN(  73)								if (this14->useVirtualPos) {
HXLINE(  73)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this14->virtualY) * ( (Float)(this14->width) )) + x1) - this14->virtualX));
            								}
            								else {
HXLINE(  73)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this14->width) + x1)) ));
            								}
HXDLIN(  73)								int this15 = ::iterMagic::Iimg_obj::get(this14->image,location1);
HXDLIN(  73)								int this16;
HXDLIN(  73)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)									this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            								}
            								else {
HXLINE(  73)									this16 = this15;
            								}
HXDLIN(  73)								Float a11;
HXDLIN(  73)								int this17 = ((this16 >> 24) & 255);
HXDLIN(  73)								if ((this17 == 0)) {
HXLINE(  73)									a11 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float r11;
HXDLIN(  73)								int this18 = ((this16 >> 16) & 255);
HXDLIN(  73)								if ((this18 == 0)) {
HXLINE(  73)									r11 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									r11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float g11;
HXDLIN(  73)								int this19 = ((this16 >> 8) & 255);
HXDLIN(  73)								if ((this19 == 0)) {
HXLINE(  73)									g11 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									g11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float b11;
HXDLIN(  73)								int this20 = (this16 & 255);
HXDLIN(  73)								if ((this20 == 0)) {
HXLINE(  73)									b11 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float a21;
HXDLIN(  73)								int this21 = ((-16711936 >> 24) & 255);
HXDLIN(  73)								if ((this21 == 0)) {
HXLINE(  73)									a21 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									a21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float r21;
HXDLIN(  73)								int this22 = ((-16711936 >> 16) & 255);
HXDLIN(  73)								if ((this22 == 0)) {
HXLINE(  73)									r21 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									r21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float g21;
HXDLIN(  73)								int this23 = ((-16711936 >> 8) & 255);
HXDLIN(  73)								if ((this23 == 0)) {
HXLINE(  73)									g21 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									g21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float b21;
HXDLIN(  73)								int this24 = (-16711936 & 255);
HXDLIN(  73)								if ((this24 == 0)) {
HXLINE(  73)									b21 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  73)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  73)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  73)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN(  73)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  73)								int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  73)								{
HXLINE(  73)									int _hx_tmp4;
HXDLIN(  73)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE(  73)										_hx_tmp4 = blended1;
            									}
HXDLIN(  73)									::iterMagic::Iimg_obj::set(this14->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE(  73)								::Dynamic this25 = this14->image;
HXDLIN(  73)								int index1;
HXDLIN(  73)								if (this14->useVirtualPos) {
HXLINE(  73)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this14->virtualY) * ( (Float)(this14->width) )) + x1) - this14->virtualX));
            								}
            								else {
HXLINE(  73)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this14->width) + x1)) ));
            								}
HXDLIN(  73)								int _hx_tmp5;
HXDLIN(  73)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  73)									_hx_tmp5 = c1;
            								}
HXDLIN(  73)								::iterMagic::Iimg_obj::set(this25,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  73)			{
HXLINE(  73)				 ::pi_xy::ImageStruct this26 = this1;
HXDLIN(  73)				{
HXLINE(  73)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN(  73)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN(  73)					int r_w2 = 12;
HXDLIN(  73)					int r_h2 = 12;
HXDLIN(  73)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN(  73)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN(  73)					int ii_min4 = r_x2;
HXDLIN(  73)					int ii_max4 = xmax2;
HXDLIN(  73)					int xRange__start2 = ii_min4;
HXDLIN(  73)					int xRange__max2 = ii_max4;
HXDLIN(  73)					int ii_min5 = r_y2;
HXDLIN(  73)					int ii_max5 = ymax2;
HXDLIN(  73)					int yRange__start2 = ii_min5;
HXDLIN(  73)					int yRange__max2 = ii_max5;
HXDLIN(  73)					int range_x2 = xRange__start2;
HXDLIN(  73)					int range_y2 = (yRange__start2 - 1);
HXDLIN(  73)					int range_xReset2 = range_x2;
HXDLIN(  73)					int range_yReset2 = range_y2;
HXDLIN(  73)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  73)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  73)					int _this_min2 = 0;
HXDLIN(  73)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  73)					while((_this_min2 < _this_max2)){
HXLINE(  73)						_this_min2 = (_this_min2 + 1);
HXDLIN(  73)						int i4 = (_this_min2 - 1);
HXDLIN(  73)						if ((range_y2 > range_yMax2)) {
HXLINE(  73)							range_y2 = range_yReset2;
HXDLIN(  73)							range_x2 = (range_x2 + 1);
            						}
HXDLIN(  73)						range_y2 = (range_y2 + 1);
HXDLIN(  73)						int i5 = i4;
HXDLIN(  73)						{
HXLINE(  73)							int x2 = range_x2;
HXDLIN(  73)							int y2 = range_y2;
HXDLIN(  73)							int c2 = -16776961;
HXDLIN(  73)							bool _hx_tmp6;
HXDLIN(  73)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  73)								_hx_tmp6 = this26->transparent;
            							}
            							else {
HXLINE(  73)								_hx_tmp6 = false;
            							}
HXDLIN(  73)							if (_hx_tmp6) {
HXLINE(  73)								int location2;
HXDLIN(  73)								if (this26->useVirtualPos) {
HXLINE(  73)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this26->virtualY) * ( (Float)(this26->width) )) + x2) - this26->virtualX));
            								}
            								else {
HXLINE(  73)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this26->width) + x2)) ));
            								}
HXDLIN(  73)								int this27 = ::iterMagic::Iimg_obj::get(this26->image,location2);
HXDLIN(  73)								int this28;
HXDLIN(  73)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)									this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            								}
            								else {
HXLINE(  73)									this28 = this27;
            								}
HXDLIN(  73)								Float a12;
HXDLIN(  73)								int this29 = ((this28 >> 24) & 255);
HXDLIN(  73)								if ((this29 == 0)) {
HXLINE(  73)									a12 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									a12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float r12;
HXDLIN(  73)								int this30 = ((this28 >> 16) & 255);
HXDLIN(  73)								if ((this30 == 0)) {
HXLINE(  73)									r12 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									r12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float g12;
HXDLIN(  73)								int this31 = ((this28 >> 8) & 255);
HXDLIN(  73)								if ((this31 == 0)) {
HXLINE(  73)									g12 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									g12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float b12;
HXDLIN(  73)								int this32 = (this28 & 255);
HXDLIN(  73)								if ((this32 == 0)) {
HXLINE(  73)									b12 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									b12 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float a22;
HXDLIN(  73)								int this33 = ((-16776961 >> 24) & 255);
HXDLIN(  73)								if ((this33 == 0)) {
HXLINE(  73)									a22 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									a22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float r22;
HXDLIN(  73)								int this34 = ((-16776961 >> 16) & 255);
HXDLIN(  73)								if ((this34 == 0)) {
HXLINE(  73)									r22 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									r22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float g22;
HXDLIN(  73)								int this35 = ((-16776961 >> 8) & 255);
HXDLIN(  73)								if ((this35 == 0)) {
HXLINE(  73)									g22 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									g22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float b22;
HXDLIN(  73)								int this36 = (-16776961 & 255);
HXDLIN(  73)								if ((this36 == 0)) {
HXLINE(  73)									b22 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									b22 = (( (Float)(this36) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  73)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  73)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  73)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN(  73)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  73)								int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN(  73)								{
HXLINE(  73)									int _hx_tmp7;
HXDLIN(  73)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE(  73)										_hx_tmp7 = blended2;
            									}
HXDLIN(  73)									::iterMagic::Iimg_obj::set(this26->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE(  73)								::Dynamic this37 = this26->image;
HXDLIN(  73)								int index2;
HXDLIN(  73)								if (this26->useVirtualPos) {
HXLINE(  73)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this26->virtualY) * ( (Float)(this26->width) )) + x2) - this26->virtualX));
            								}
            								else {
HXLINE(  73)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this26->width) + x2)) ));
            								}
HXDLIN(  73)								int _hx_tmp8;
HXDLIN(  73)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE(  73)									_hx_tmp8 = c2;
            								}
HXDLIN(  73)								::iterMagic::Iimg_obj::set(this37,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  73)			{
HXLINE(  73)				 ::pi_xy::ImageStruct this38 = this1;
HXDLIN(  73)				{
HXLINE(  73)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN(  73)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN(  73)					int r_w3 = 12;
HXDLIN(  73)					int r_h3 = 12;
HXDLIN(  73)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN(  73)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN(  73)					int ii_min6 = r_x3;
HXDLIN(  73)					int ii_max6 = xmax3;
HXDLIN(  73)					int xRange__start3 = ii_min6;
HXDLIN(  73)					int xRange__max3 = ii_max6;
HXDLIN(  73)					int ii_min7 = r_y3;
HXDLIN(  73)					int ii_max7 = ymax3;
HXDLIN(  73)					int yRange__start3 = ii_min7;
HXDLIN(  73)					int yRange__max3 = ii_max7;
HXDLIN(  73)					int range_x3 = xRange__start3;
HXDLIN(  73)					int range_y3 = (yRange__start3 - 1);
HXDLIN(  73)					int range_xReset3 = range_x3;
HXDLIN(  73)					int range_yReset3 = range_y3;
HXDLIN(  73)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN(  73)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN(  73)					int _this_min3 = 0;
HXDLIN(  73)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN(  73)					while((_this_min3 < _this_max3)){
HXLINE(  73)						_this_min3 = (_this_min3 + 1);
HXDLIN(  73)						int i6 = (_this_min3 - 1);
HXDLIN(  73)						if ((range_y3 > range_yMax3)) {
HXLINE(  73)							range_y3 = range_yReset3;
HXDLIN(  73)							range_x3 = (range_x3 + 1);
            						}
HXDLIN(  73)						range_y3 = (range_y3 + 1);
HXDLIN(  73)						int i7 = i6;
HXDLIN(  73)						{
HXLINE(  73)							int x3 = range_x3;
HXDLIN(  73)							int y3 = range_y3;
HXDLIN(  73)							int c3 = -1048336;
HXDLIN(  73)							bool _hx_tmp9;
HXDLIN(  73)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  73)								_hx_tmp9 = this38->transparent;
            							}
            							else {
HXLINE(  73)								_hx_tmp9 = false;
            							}
HXDLIN(  73)							if (_hx_tmp9) {
HXLINE(  73)								int location3;
HXDLIN(  73)								if (this38->useVirtualPos) {
HXLINE(  73)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this38->virtualY) * ( (Float)(this38->width) )) + x3) - this38->virtualX));
            								}
            								else {
HXLINE(  73)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this38->width) + x3)) ));
            								}
HXDLIN(  73)								int this39 = ::iterMagic::Iimg_obj::get(this38->image,location3);
HXDLIN(  73)								int this40;
HXDLIN(  73)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)									this40 = ((((((this39 >> 24) & 255) << 24) | ((this39 & 255) << 16)) | (((this39 >> 8) & 255) << 8)) | ((this39 >> 16) & 255));
            								}
            								else {
HXLINE(  73)									this40 = this39;
            								}
HXDLIN(  73)								Float a13;
HXDLIN(  73)								int this41 = ((this40 >> 24) & 255);
HXDLIN(  73)								if ((this41 == 0)) {
HXLINE(  73)									a13 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									a13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float r13;
HXDLIN(  73)								int this42 = ((this40 >> 16) & 255);
HXDLIN(  73)								if ((this42 == 0)) {
HXLINE(  73)									r13 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									r13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float g13;
HXDLIN(  73)								int this43 = ((this40 >> 8) & 255);
HXDLIN(  73)								if ((this43 == 0)) {
HXLINE(  73)									g13 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									g13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float b13;
HXDLIN(  73)								int this44 = (this40 & 255);
HXDLIN(  73)								if ((this44 == 0)) {
HXLINE(  73)									b13 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									b13 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float a23;
HXDLIN(  73)								int this45 = ((-1048336 >> 24) & 255);
HXDLIN(  73)								if ((this45 == 0)) {
HXLINE(  73)									a23 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									a23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float r23;
HXDLIN(  73)								int this46 = ((-1048336 >> 16) & 255);
HXDLIN(  73)								if ((this46 == 0)) {
HXLINE(  73)									r23 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									r23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float g23;
HXDLIN(  73)								int this47 = ((-1048336 >> 8) & 255);
HXDLIN(  73)								if ((this47 == 0)) {
HXLINE(  73)									g23 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									g23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float b23;
HXDLIN(  73)								int this48 = (-1048336 & 255);
HXDLIN(  73)								if ((this48 == 0)) {
HXLINE(  73)									b23 = ((Float)0.);
            								}
            								else {
HXLINE(  73)									b23 = (( (Float)(this48) ) / ( (Float)(255) ));
            								}
HXDLIN(  73)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  73)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  73)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  73)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN(  73)								int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  73)								int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN(  73)								{
HXLINE(  73)									int _hx_tmp10;
HXDLIN(  73)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE(  73)										_hx_tmp10 = blended3;
            									}
HXDLIN(  73)									::iterMagic::Iimg_obj::set(this38->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE(  73)								::Dynamic this49 = this38->image;
HXDLIN(  73)								int index3;
HXDLIN(  73)								if (this38->useVirtualPos) {
HXLINE(  73)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this38->virtualY) * ( (Float)(this38->width) )) + x3) - this38->virtualX));
            								}
            								else {
HXLINE(  73)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this38->width) + x3)) ));
            								}
HXDLIN(  73)								int _hx_tmp11;
HXDLIN(  73)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE(  73)									_hx_tmp11 = c3;
            								}
HXDLIN(  73)								::iterMagic::Iimg_obj::set(this49,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  73)		{
HXLINE(  73)			Float bx1 = bx;
HXDLIN(  73)			Float by1 = by;
HXDLIN(  73)			Float cx1 = dx;
HXDLIN(  73)			Float cy1 = dy;
HXDLIN(  73)			bool hasUndo = false;
HXDLIN(  73)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  73)			if (!(adjustWinding)) {
HXLINE(  73)				Float bx_ = bx1;
HXDLIN(  73)				Float by_ = by1;
HXLINE(  25)				bx1 = cx1;
HXLINE(  26)				by1 = cy1;
HXLINE(  27)				cx1 = bx_;
HXLINE(  28)				cy1 = by_;
            			}
HXLINE(  73)			{
HXLINE(  73)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  73)				Float sx = (cy1 - ay);
HXDLIN(  73)				Float sy = (ax - cx1);
HXDLIN(  73)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  73)				Float tx = (ay - by1);
HXDLIN(  73)				Float ty = (bx1 - ax);
HXDLIN(  73)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  73)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  73)				if ((ax > bx1)) {
HXLINE(  73)					if ((ax > cx1)) {
HXLINE(  73)						int min;
HXDLIN(  73)						if ((bx1 > cx1)) {
HXLINE(  73)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  73)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN(  73)						int ii_min8 = min;
HXDLIN(  73)						int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN(  73)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE(  73)						int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  73)						int ii_max9 = ::Math_obj::ceil(cx1);
HXDLIN(  73)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE(  73)					if ((bx1 > cx1)) {
HXLINE(  73)						int min1;
HXDLIN(  73)						if ((ax > cx1)) {
HXLINE(  73)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  73)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN(  73)						int ii_min10 = min1;
HXDLIN(  73)						int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  73)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE(  73)						int ii_min11 = ::Math_obj::floor(ax);
HXDLIN(  73)						int ii_max11 = ::Math_obj::ceil(cx1);
HXDLIN(  73)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN(  73)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  73)				if ((ay > by1)) {
HXLINE(  73)					if ((ay > cy1)) {
HXLINE(  73)						int min2;
HXDLIN(  73)						if ((by1 > cy1)) {
HXLINE(  73)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  73)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN(  73)						int ii_min12 = min2;
HXDLIN(  73)						int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN(  73)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE(  73)						int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  73)						int ii_max13 = ::Math_obj::ceil(cy1);
HXDLIN(  73)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE(  73)					if ((by1 > cy1)) {
HXLINE(  73)						int min3;
HXDLIN(  73)						if ((ay > cy1)) {
HXLINE(  73)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  73)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN(  73)						int ii_min14 = min3;
HXDLIN(  73)						int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  73)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE(  73)						int ii_min15 = ::Math_obj::floor(ay);
HXDLIN(  73)						int ii_max15 = ::Math_obj::ceil(cy1);
HXDLIN(  73)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN(  73)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  73)				if (hasUndo) {
HXLINE(  73)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  73)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  73)					 ::Dynamic imageType = null();
HXDLIN(  73)					 ::pi_xy::ImageStruct this50 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  73)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  73)					::Dynamic undoImage1;
HXDLIN(  73)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE(  73)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::BytesImg b6 = byt;
HXDLIN(  73)							{
HXLINE(  73)								b6->width = width;
HXDLIN(  73)								b6->height = height;
HXDLIN(  73)								b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  73)								b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  73)								{
HXLINE(  73)									int len = b6->length;
HXDLIN(  73)									int w = 0;
HXDLIN(  73)									{
HXLINE(  73)										int _g = 0;
HXDLIN(  73)										int _g1 = b6->height;
HXDLIN(  73)										while((_g < _g1)){
HXLINE(  73)											_g = (_g + 1);
HXDLIN(  73)											int y4 = (_g - 1);
HXDLIN(  73)											{
HXLINE(  73)												int _g2 = 0;
HXDLIN(  73)												int _g3 = b6->width;
HXDLIN(  73)												while((_g2 < _g3)){
HXLINE(  73)													_g2 = (_g2 + 1);
HXDLIN(  73)													int x4 = (_g2 - 1);
HXDLIN(  73)													{
HXLINE(  73)														w = (w + 1);
HXDLIN(  73)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  73)													{
HXLINE(  73)														w = (w + 1);
HXDLIN(  73)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  73)													{
HXLINE(  73)														w = (w + 1);
HXDLIN(  73)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  73)													{
HXLINE(  73)														w = (w + 1);
HXDLIN(  73)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  73)							undoImage1 = b6;
            						}
            						break;
            						case (int)1: {
HXLINE(  73)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::ArrIntImg a8 = arrI;
HXDLIN(  73)							{
HXLINE(  73)								a8->width = width;
HXDLIN(  73)								a8->height = height;
HXDLIN(  73)								a8->data = ::Array_obj< int >::__new(0);
HXDLIN(  73)								a8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  73)								{
HXLINE(  73)									int _g4 = 0;
HXDLIN(  73)									int _g5 = a8->length;
HXDLIN(  73)									while((_g4 < _g5)){
HXLINE(  73)										_g4 = (_g4 + 1);
HXDLIN(  73)										int i8 = (_g4 - 1);
HXDLIN(  73)										a8->data[i8] = 0;
            									}
            								}
            							}
HXDLIN(  73)							undoImage1 = a8;
            						}
            						break;
            						case (int)2: {
HXLINE(  73)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN(  73)							{
HXLINE(  73)								b7->width = width;
HXDLIN(  73)								b7->height = height;
HXDLIN(  73)								b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  73)								int size = (b7->length * 4);
HXDLIN(  73)								b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  73)								{
HXLINE(  73)									int _g6 = 0;
HXDLIN(  73)									int _g7 = b7->length;
HXDLIN(  73)									while((_g6 < _g7)){
HXLINE(  73)										_g6 = (_g6 + 1);
HXDLIN(  73)										int i9 = (_g6 - 1);
HXDLIN(  73)										{
HXLINE(  73)											 ::haxe::io::ArrayBufferViewImpl this51 = b7->data;
HXDLIN(  73)											bool undoImage2;
HXDLIN(  73)											if ((i9 >= 0)) {
HXLINE(  73)												undoImage2 = (i9 < (this51->byteLength >> 2));
            											}
            											else {
HXLINE(  73)												undoImage2 = false;
            											}
HXDLIN(  73)											if (undoImage2) {
HXLINE(  73)												 ::haxe::io::Bytes _this = this51->bytes;
HXDLIN(  73)												int pos = ((i9 << 2) + this51->byteOffset);
HXDLIN(  73)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  73)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  73)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  73)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  73)							undoImage1 = b7;
            						}
            						break;
            						case (int)3: {
HXLINE(  73)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::VecIntImg v = vec;
HXDLIN(  73)							{
HXLINE(  73)								v->width = width;
HXDLIN(  73)								v->height = height;
HXDLIN(  73)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  73)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  73)								{
HXLINE(  73)									int _g8 = 0;
HXDLIN(  73)									int _g9 = v->length;
HXDLIN(  73)									while((_g8 < _g9)){
HXLINE(  73)										_g8 = (_g8 + 1);
HXDLIN(  73)										int i10 = (_g8 - 1);
HXDLIN(  73)										v->data->__unsafe_set(i10,0);
            									}
            								}
            							}
HXDLIN(  73)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE(  73)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN(  73)							{
HXLINE(  73)								b8->width = width;
HXDLIN(  73)								b8->height = height;
HXDLIN(  73)								b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  73)								b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  73)								{
HXLINE(  73)									int len1 = b8->length;
HXDLIN(  73)									 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN(  73)									if (::hx::IsNull( d->head )) {
HXLINE(  73)										int _g10 = 0;
HXDLIN(  73)										int _g11 = len1;
HXDLIN(  73)										while((_g10 < _g11)){
HXLINE(  73)											_g10 = (_g10 + 1);
HXDLIN(  73)											int i11 = (_g10 - 1);
HXDLIN(  73)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE(  73)										int _g12 = 0;
HXDLIN(  73)										int _g13 = len1;
HXDLIN(  73)										while((_g12 < _g13)){
HXLINE(  73)											_g12 = (_g12 + 1);
HXDLIN(  73)											int i12 = (_g12 - 1);
HXDLIN(  73)											{
HXLINE(  73)												 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN(  73)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  73)												{
HXLINE(  73)													int _g14 = 0;
HXDLIN(  73)													int _g15 = i12;
HXDLIN(  73)													while((_g14 < _g15)){
HXLINE(  73)														_g14 = (_g14 + 1);
HXDLIN(  73)														int i13 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE(  73)												if (::hx::IsNull( prev )) {
HXLINE(  73)													b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  73)													l = null();
            												}
            												else {
HXLINE(  73)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  73)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  73)							undoImage1 = b8;
            						}
            						break;
            					}
HXDLIN(  73)					this50->image = undoImage1;
HXDLIN(  73)					this50->width = width;
HXDLIN(  73)					this50->height = height;
HXDLIN(  73)					this50->imageType = ( (int)(imageType) );
HXDLIN(  73)					undoImage = this50;
HXDLIN(  73)					{
HXLINE(  73)						int rectLeft = xIter3->start;
HXDLIN(  73)						int rectTop = yIter3->start;
HXDLIN(  73)						int rectRight = xIter3->max;
HXDLIN(  73)						bool forceClear = false;
HXDLIN(  73)						{
HXLINE(  73)							int _g16 = rectTop;
HXDLIN(  73)							int _g17 = yIter3->max;
HXDLIN(  73)							while((_g16 < _g17)){
HXLINE(  73)								_g16 = (_g16 + 1);
HXDLIN(  73)								int dy1 = (_g16 - 1);
HXDLIN(  73)								{
HXLINE(  73)									int _g18 = rectLeft;
HXDLIN(  73)									int _g19 = rectRight;
HXDLIN(  73)									while((_g18 < _g19)){
HXLINE(  73)										_g18 = (_g18 + 1);
HXDLIN(  73)										int dx1 = (_g18 - 1);
HXDLIN(  73)										::Dynamic this52 = this1->image;
HXDLIN(  73)										int index4;
HXDLIN(  73)										if (this1->useVirtualPos) {
HXLINE(  73)											index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            										}
            										else {
HXLINE(  73)											index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            										}
HXDLIN(  73)										int c4 = ::iterMagic::Iimg_obj::get(this52,index4);
HXDLIN(  73)										int col;
HXDLIN(  73)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)											col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE(  73)											col = c4;
            										}
HXDLIN(  73)										bool _hx_tmp12;
HXDLIN(  73)										if (this1->useMask) {
HXLINE(  73)											_hx_tmp12 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE(  73)											_hx_tmp12 = false;
            										}
HXDLIN(  73)										if (_hx_tmp12) {
HXLINE(  73)											 ::pi_xy::ImageStruct this53 = this1->mask;
HXDLIN(  73)											::Dynamic this54 = this53->image;
HXDLIN(  73)											int index5;
HXDLIN(  73)											if (this53->useVirtualPos) {
HXLINE(  73)												index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this53->virtualY) * ( (Float)(this53->width) )) + dx1) - this53->virtualX));
            											}
            											else {
HXLINE(  73)												index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this53->width) + dx1)) ));
            											}
HXDLIN(  73)											int c5 = ::iterMagic::Iimg_obj::get(this54,index5);
HXDLIN(  73)											int v1;
HXDLIN(  73)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)												v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE(  73)												v1 = c5;
            											}
HXDLIN(  73)											int maskPixel = v1;
HXDLIN(  73)											int this55 = col;
HXDLIN(  73)											if ((maskPixel == 0)) {
HXLINE(  73)												col = this55;
            											}
            											else {
HXLINE(  73)												Float m0;
HXDLIN(  73)												int this56 = ((maskPixel >> 24) & 255);
HXDLIN(  73)												if ((this56 == 0)) {
HXLINE(  73)													m0 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m0 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m1;
HXDLIN(  73)												int this57 = ((maskPixel >> 16) & 255);
HXDLIN(  73)												if ((this57 == 0)) {
HXLINE(  73)													m1 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m1 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m2;
HXDLIN(  73)												int this58 = ((maskPixel >> 8) & 255);
HXDLIN(  73)												if ((this58 == 0)) {
HXLINE(  73)													m2 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m2 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m3;
HXDLIN(  73)												int this59 = (maskPixel & 255);
HXDLIN(  73)												if ((this59 == 0)) {
HXLINE(  73)													m3 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m3 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this55 >> 24) & 255)) )));
HXDLIN(  73)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this55 >> 16) & 255)) )));
HXDLIN(  73)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this55 >> 8) & 255)) )));
HXDLIN(  73)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this55 & 255)) )));
HXDLIN(  73)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  73)										if ((col != 0)) {
HXLINE(  73)											int x5 = (dx1 - rectLeft);
HXDLIN(  73)											int y5 = (dy1 - rectTop);
HXDLIN(  73)											int c6 = col;
HXDLIN(  73)											bool _hx_tmp13;
HXDLIN(  73)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  73)												_hx_tmp13 = undoImage->transparent;
            											}
            											else {
HXLINE(  73)												_hx_tmp13 = false;
            											}
HXDLIN(  73)											if (_hx_tmp13) {
HXLINE(  73)												int location4;
HXDLIN(  73)												if (undoImage->useVirtualPos) {
HXLINE(  73)													location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE(  73)													location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN(  73)												int this60 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN(  73)												int this61;
HXDLIN(  73)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													this61 = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													this61 = this60;
            												}
HXDLIN(  73)												Float a14;
HXDLIN(  73)												int this62 = ((this61 >> 24) & 255);
HXDLIN(  73)												if ((this62 == 0)) {
HXLINE(  73)													a14 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a14 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r14;
HXDLIN(  73)												int this63 = ((this61 >> 16) & 255);
HXDLIN(  73)												if ((this63 == 0)) {
HXLINE(  73)													r14 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r14 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g14;
HXDLIN(  73)												int this64 = ((this61 >> 8) & 255);
HXDLIN(  73)												if ((this64 == 0)) {
HXLINE(  73)													g14 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g14 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b14;
HXDLIN(  73)												int this65 = (this61 & 255);
HXDLIN(  73)												if ((this65 == 0)) {
HXLINE(  73)													b14 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b14 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a24;
HXDLIN(  73)												int this66 = ((col >> 24) & 255);
HXDLIN(  73)												if ((this66 == 0)) {
HXLINE(  73)													a24 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a24 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r24;
HXDLIN(  73)												int this67 = ((col >> 16) & 255);
HXDLIN(  73)												if ((this67 == 0)) {
HXLINE(  73)													r24 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r24 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g24;
HXDLIN(  73)												int this68 = ((col >> 8) & 255);
HXDLIN(  73)												if ((this68 == 0)) {
HXLINE(  73)													g24 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g24 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b24;
HXDLIN(  73)												int this69 = (col & 255);
HXDLIN(  73)												if ((this69 == 0)) {
HXLINE(  73)													b24 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b24 = (( (Float)(this69) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  73)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  73)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  73)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN(  73)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  73)												int blended4 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN(  73)												{
HXLINE(  73)													int _hx_tmp14;
HXDLIN(  73)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)														_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXLINE(  73)														_hx_tmp14 = blended4;
            													}
HXDLIN(  73)													::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            												}
            											}
            											else {
HXLINE(  73)												::Dynamic this70 = undoImage->image;
HXDLIN(  73)												int index6;
HXDLIN(  73)												if (undoImage->useVirtualPos) {
HXLINE(  73)													index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE(  73)													index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN(  73)												int _hx_tmp15;
HXDLIN(  73)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													_hx_tmp15 = c6;
            												}
HXDLIN(  73)												::iterMagic::Iimg_obj::set(this70,index6,_hx_tmp15);
            											}
            										}
            										else {
HXLINE(  73)											if (forceClear) {
HXLINE(  73)												::Dynamic this71 = undoImage->image;
HXDLIN(  73)												int x6 = (dx1 - rectLeft);
HXDLIN(  73)												int y6 = (dy1 - rectTop);
HXDLIN(  73)												int index7;
HXDLIN(  73)												if (undoImage->useVirtualPos) {
HXLINE(  73)													index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            												}
            												else {
HXLINE(  73)													index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            												}
HXDLIN(  73)												::iterMagic::Iimg_obj::set(this71,index7,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  73)				bool found = false;
HXDLIN(  73)				Float s = ((Float)0.);
HXDLIN(  73)				Float t = ((Float)0.);
HXDLIN(  73)				Float sxx = ((Float)0.);
HXDLIN(  73)				Float txx = ((Float)0.);
HXDLIN(  73)				{
HXLINE(  73)					int _g_min = xIter3->start;
HXDLIN(  73)					int _g_max = xIter3->max;
HXDLIN(  73)					while((_g_min < _g_max)){
HXLINE(  73)						_g_min = (_g_min + 1);
HXDLIN(  73)						int x7 = (_g_min - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x7) ));
HXLINE(  61)						txx = (tx * ( (Float)(x7) ));
HXLINE(  62)						found = false;
HXLINE(  73)						{
HXLINE(  73)							int _g_min1 = yIter3->start;
HXDLIN(  73)							int _g_max1 = yIter3->max;
HXDLIN(  73)							while((_g_min1 < _g_max1)){
HXLINE(  73)								_g_min1 = (_g_min1 + 1);
HXDLIN(  73)								int y7 = (_g_min1 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y7) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y7) )));
HXLINE(  73)								bool _hx_tmp16;
HXDLIN(  73)								if (!((s <= 0))) {
HXLINE(  73)									_hx_tmp16 = (t <= 0);
            								}
            								else {
HXLINE(  73)									_hx_tmp16 = true;
            								}
HXDLIN(  73)								if (_hx_tmp16) {
HXLINE(  73)									if (found) {
HXLINE(  73)										goto _hx_goto_64;
            									}
            								}
            								else {
HXLINE(  73)									if (((s + t) < A)) {
HXLINE(  73)										{
HXLINE(  73)											int c7 = color;
HXDLIN(  73)											bool _hx_tmp17;
HXDLIN(  73)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  73)												_hx_tmp17 = this1->transparent;
            											}
            											else {
HXLINE(  73)												_hx_tmp17 = false;
            											}
HXDLIN(  73)											if (_hx_tmp17) {
HXLINE(  73)												int location5;
HXDLIN(  73)												if (this1->useVirtualPos) {
HXLINE(  73)													location5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXLINE(  73)													location5 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN(  73)												int this72 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN(  73)												int this73;
HXDLIN(  73)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													this73 = ((((((this72 >> 24) & 255) << 24) | ((this72 & 255) << 16)) | (((this72 >> 8) & 255) << 8)) | ((this72 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													this73 = this72;
            												}
HXDLIN(  73)												Float a15;
HXDLIN(  73)												int this74 = ((this73 >> 24) & 255);
HXDLIN(  73)												if ((this74 == 0)) {
HXLINE(  73)													a15 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a15 = (( (Float)(this74) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r15;
HXDLIN(  73)												int this75 = ((this73 >> 16) & 255);
HXDLIN(  73)												if ((this75 == 0)) {
HXLINE(  73)													r15 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r15 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g15;
HXDLIN(  73)												int this76 = ((this73 >> 8) & 255);
HXDLIN(  73)												if ((this76 == 0)) {
HXLINE(  73)													g15 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g15 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b15;
HXDLIN(  73)												int this77 = (this73 & 255);
HXDLIN(  73)												if ((this77 == 0)) {
HXLINE(  73)													b15 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b15 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a25;
HXDLIN(  73)												int this78 = ((color >> 24) & 255);
HXDLIN(  73)												if ((this78 == 0)) {
HXLINE(  73)													a25 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a25 = (( (Float)(this78) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r25;
HXDLIN(  73)												int this79 = ((color >> 16) & 255);
HXDLIN(  73)												if ((this79 == 0)) {
HXLINE(  73)													r25 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r25 = (( (Float)(this79) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g25;
HXDLIN(  73)												int this80 = ((color >> 8) & 255);
HXDLIN(  73)												if ((this80 == 0)) {
HXLINE(  73)													g25 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g25 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b25;
HXDLIN(  73)												int this81 = (color & 255);
HXDLIN(  73)												if ((this81 == 0)) {
HXLINE(  73)													b25 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b25 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  73)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  73)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  73)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN(  73)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  73)												int blended5 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN(  73)												{
HXLINE(  73)													int _hx_tmp18;
HXDLIN(  73)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)														_hx_tmp18 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXLINE(  73)														_hx_tmp18 = blended5;
            													}
HXDLIN(  73)													::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp18);
            												}
            											}
            											else {
HXLINE(  73)												::Dynamic this82 = this1->image;
HXDLIN(  73)												int index8;
HXDLIN(  73)												if (this1->useVirtualPos) {
HXLINE(  73)													index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXLINE(  73)													index8 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN(  73)												int _hx_tmp19;
HXDLIN(  73)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													_hx_tmp19 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													_hx_tmp19 = c7;
            												}
HXDLIN(  73)												::iterMagic::Iimg_obj::set(this82,index8,_hx_tmp19);
            											}
            										}
HXDLIN(  73)										found = true;
            									}
            									else {
HXLINE(  73)										if (found) {
HXLINE(  73)											goto _hx_goto_64;
            										}
            									}
            								}
            							}
            							_hx_goto_64:;
            						}
            					}
            				}
HXDLIN(  73)				if ((hasHit == true)) {
HXLINE(  73)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  73)					if (hasUndo) {
HXLINE(  73)						v2->undoImage = undoImage;
HXDLIN(  73)						v2->undoX = xIter3->start;
HXDLIN(  73)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN(  73)		{
HXLINE(  73)			Float bx2 = cx;
HXDLIN(  73)			Float by2 = cy;
HXDLIN(  73)			Float cx2 = dx;
HXDLIN(  73)			Float cy2 = dy;
HXDLIN(  73)			bool hasUndo1 = false;
HXDLIN(  73)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  73)			if (!(adjustWinding1)) {
HXLINE(  73)				Float bx_1 = bx2;
HXDLIN(  73)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE(  73)			{
HXLINE(  73)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  73)				Float sx1 = (cy2 - by);
HXDLIN(  73)				Float sy1 = (bx - cx2);
HXDLIN(  73)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  73)				Float tx1 = (by - by2);
HXDLIN(  73)				Float ty1 = (bx2 - bx);
HXDLIN(  73)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  73)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  73)				if ((bx > bx2)) {
HXLINE(  73)					if ((bx > cx2)) {
HXLINE(  73)						int min4;
HXDLIN(  73)						if ((bx2 > cx2)) {
HXLINE(  73)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE(  73)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN(  73)						int ii_min16 = min4;
HXDLIN(  73)						int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN(  73)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            					}
            					else {
HXLINE(  73)						int ii_min17 = ::Math_obj::floor(bx2);
HXDLIN(  73)						int ii_max17 = ::Math_obj::ceil(cx2);
HXDLIN(  73)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            					}
            				}
            				else {
HXLINE(  73)					if ((bx2 > cx2)) {
HXLINE(  73)						int min5;
HXDLIN(  73)						if ((bx > cx2)) {
HXLINE(  73)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE(  73)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN(  73)						int ii_min18 = min5;
HXDLIN(  73)						int ii_max18 = ::Math_obj::ceil(bx2);
HXDLIN(  73)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXLINE(  73)						int ii_min19 = ::Math_obj::floor(bx);
HXDLIN(  73)						int ii_max19 = ::Math_obj::ceil(cx2);
HXDLIN(  73)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
HXDLIN(  73)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  73)				if ((by > by2)) {
HXLINE(  73)					if ((by > cy2)) {
HXLINE(  73)						int min6;
HXDLIN(  73)						if ((by2 > cy2)) {
HXLINE(  73)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  73)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN(  73)						int ii_min20 = min6;
HXDLIN(  73)						int ii_max20 = ::Math_obj::ceil(by);
HXDLIN(  73)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXLINE(  73)						int ii_min21 = ::Math_obj::floor(by2);
HXDLIN(  73)						int ii_max21 = ::Math_obj::ceil(cy2);
HXDLIN(  73)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
            				else {
HXLINE(  73)					if ((by2 > cy2)) {
HXLINE(  73)						int min7;
HXDLIN(  73)						if ((by > cy2)) {
HXLINE(  73)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  73)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN(  73)						int ii_min22 = min7;
HXDLIN(  73)						int ii_max22 = ::Math_obj::ceil(by2);
HXDLIN(  73)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXLINE(  73)						int ii_min23 = ::Math_obj::floor(by);
HXDLIN(  73)						int ii_max23 = ::Math_obj::ceil(cy2);
HXDLIN(  73)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
HXDLIN(  73)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  73)				if (hasUndo1) {
HXLINE(  73)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  73)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  73)					 ::Dynamic imageType1 = null();
HXDLIN(  73)					 ::pi_xy::ImageStruct this83 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  73)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  73)					::Dynamic undoImage4;
HXDLIN(  73)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE(  73)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::BytesImg b16 = byt1;
HXDLIN(  73)							{
HXLINE(  73)								b16->width = width1;
HXDLIN(  73)								b16->height = height1;
HXDLIN(  73)								b16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  73)								b16->data = ::haxe::io::Bytes_obj::alloc((b16->length * 4));
HXDLIN(  73)								{
HXLINE(  73)									int len2 = b16->length;
HXDLIN(  73)									int w1 = 0;
HXDLIN(  73)									{
HXLINE(  73)										int _g20 = 0;
HXDLIN(  73)										int _g21 = b16->height;
HXDLIN(  73)										while((_g20 < _g21)){
HXLINE(  73)											_g20 = (_g20 + 1);
HXDLIN(  73)											int y8 = (_g20 - 1);
HXDLIN(  73)											{
HXLINE(  73)												int _g22 = 0;
HXDLIN(  73)												int _g23 = b16->width;
HXDLIN(  73)												while((_g22 < _g23)){
HXLINE(  73)													_g22 = (_g22 + 1);
HXDLIN(  73)													int x8 = (_g22 - 1);
HXDLIN(  73)													{
HXLINE(  73)														w1 = (w1 + 1);
HXDLIN(  73)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  73)													{
HXLINE(  73)														w1 = (w1 + 1);
HXDLIN(  73)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  73)													{
HXLINE(  73)														w1 = (w1 + 1);
HXDLIN(  73)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  73)													{
HXLINE(  73)														w1 = (w1 + 1);
HXDLIN(  73)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  73)							undoImage4 = b16;
            						}
            						break;
            						case (int)1: {
HXLINE(  73)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::ArrIntImg a16 = arrI1;
HXDLIN(  73)							{
HXLINE(  73)								a16->width = width1;
HXDLIN(  73)								a16->height = height1;
HXDLIN(  73)								a16->data = ::Array_obj< int >::__new(0);
HXDLIN(  73)								a16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  73)								{
HXLINE(  73)									int _g24 = 0;
HXDLIN(  73)									int _g25 = a16->length;
HXDLIN(  73)									while((_g24 < _g25)){
HXLINE(  73)										_g24 = (_g24 + 1);
HXDLIN(  73)										int i14 = (_g24 - 1);
HXDLIN(  73)										a16->data[i14] = 0;
            									}
            								}
            							}
HXDLIN(  73)							undoImage4 = a16;
            						}
            						break;
            						case (int)2: {
HXLINE(  73)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::U32ArrImg b17 = u32a1;
HXDLIN(  73)							{
HXLINE(  73)								b17->width = width1;
HXDLIN(  73)								b17->height = height1;
HXDLIN(  73)								b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  73)								int size1 = (b17->length * 4);
HXDLIN(  73)								b17->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  73)								{
HXLINE(  73)									int _g26 = 0;
HXDLIN(  73)									int _g27 = b17->length;
HXDLIN(  73)									while((_g26 < _g27)){
HXLINE(  73)										_g26 = (_g26 + 1);
HXDLIN(  73)										int i15 = (_g26 - 1);
HXDLIN(  73)										{
HXLINE(  73)											 ::haxe::io::ArrayBufferViewImpl this84 = b17->data;
HXDLIN(  73)											bool undoImage5;
HXDLIN(  73)											if ((i15 >= 0)) {
HXLINE(  73)												undoImage5 = (i15 < (this84->byteLength >> 2));
            											}
            											else {
HXLINE(  73)												undoImage5 = false;
            											}
HXDLIN(  73)											if (undoImage5) {
HXLINE(  73)												 ::haxe::io::Bytes _this1 = this84->bytes;
HXDLIN(  73)												int pos1 = ((i15 << 2) + this84->byteOffset);
HXDLIN(  73)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  73)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  73)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  73)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  73)							undoImage4 = b17;
            						}
            						break;
            						case (int)3: {
HXLINE(  73)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  73)							{
HXLINE(  73)								v3->width = width1;
HXDLIN(  73)								v3->height = height1;
HXDLIN(  73)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  73)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  73)								{
HXLINE(  73)									int _g28 = 0;
HXDLIN(  73)									int _g29 = v3->length;
HXDLIN(  73)									while((_g28 < _g29)){
HXLINE(  73)										_g28 = (_g28 + 1);
HXDLIN(  73)										int i16 = (_g28 - 1);
HXDLIN(  73)										v3->data->__unsafe_set(i16,0);
            									}
            								}
            							}
HXDLIN(  73)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE(  73)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  73)							 ::iterMagic::StackIntImg b18 = sInt1;
HXDLIN(  73)							{
HXLINE(  73)								b18->width = width1;
HXDLIN(  73)								b18->height = height1;
HXDLIN(  73)								b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  73)								b18->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  73)								{
HXLINE(  73)									int len3 = b18->length;
HXDLIN(  73)									 ::haxe::ds::GenericStack_Int d1 = b18->data;
HXDLIN(  73)									if (::hx::IsNull( d1->head )) {
HXLINE(  73)										int _g30 = 0;
HXDLIN(  73)										int _g31 = len3;
HXDLIN(  73)										while((_g30 < _g31)){
HXLINE(  73)											_g30 = (_g30 + 1);
HXDLIN(  73)											int i17 = (_g30 - 1);
HXDLIN(  73)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE(  73)										int _g32 = 0;
HXDLIN(  73)										int _g33 = len3;
HXDLIN(  73)										while((_g32 < _g33)){
HXLINE(  73)											_g32 = (_g32 + 1);
HXDLIN(  73)											int i18 = (_g32 - 1);
HXDLIN(  73)											{
HXLINE(  73)												 ::haxe::ds::GenericCell_Int l1 = b18->data->head;
HXDLIN(  73)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  73)												{
HXLINE(  73)													int _g34 = 0;
HXDLIN(  73)													int _g35 = i18;
HXDLIN(  73)													while((_g34 < _g35)){
HXLINE(  73)														_g34 = (_g34 + 1);
HXDLIN(  73)														int i19 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE(  73)												if (::hx::IsNull( prev1 )) {
HXLINE(  73)													b18->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  73)													l1 = null();
            												}
            												else {
HXLINE(  73)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  73)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  73)							undoImage4 = b18;
            						}
            						break;
            					}
HXDLIN(  73)					this83->image = undoImage4;
HXDLIN(  73)					this83->width = width1;
HXDLIN(  73)					this83->height = height1;
HXDLIN(  73)					this83->imageType = ( (int)(imageType1) );
HXDLIN(  73)					undoImage3 = this83;
HXDLIN(  73)					{
HXLINE(  73)						int rectLeft1 = xIter31->start;
HXDLIN(  73)						int rectTop1 = yIter31->start;
HXDLIN(  73)						int rectRight1 = xIter31->max;
HXDLIN(  73)						bool forceClear1 = false;
HXDLIN(  73)						{
HXLINE(  73)							int _g36 = rectTop1;
HXDLIN(  73)							int _g37 = yIter31->max;
HXDLIN(  73)							while((_g36 < _g37)){
HXLINE(  73)								_g36 = (_g36 + 1);
HXDLIN(  73)								int dy2 = (_g36 - 1);
HXDLIN(  73)								{
HXLINE(  73)									int _g38 = rectLeft1;
HXDLIN(  73)									int _g39 = rectRight1;
HXDLIN(  73)									while((_g38 < _g39)){
HXLINE(  73)										_g38 = (_g38 + 1);
HXDLIN(  73)										int dx2 = (_g38 - 1);
HXDLIN(  73)										::Dynamic this85 = this1->image;
HXDLIN(  73)										int index9;
HXDLIN(  73)										if (this1->useVirtualPos) {
HXLINE(  73)											index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            										}
            										else {
HXLINE(  73)											index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            										}
HXDLIN(  73)										int c8 = ::iterMagic::Iimg_obj::get(this85,index9);
HXDLIN(  73)										int col1;
HXDLIN(  73)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)											col1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE(  73)											col1 = c8;
            										}
HXDLIN(  73)										bool _hx_tmp20;
HXDLIN(  73)										if (this1->useMask) {
HXLINE(  73)											_hx_tmp20 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE(  73)											_hx_tmp20 = false;
            										}
HXDLIN(  73)										if (_hx_tmp20) {
HXLINE(  73)											 ::pi_xy::ImageStruct this86 = this1->mask;
HXDLIN(  73)											::Dynamic this87 = this86->image;
HXDLIN(  73)											int index10;
HXDLIN(  73)											if (this86->useVirtualPos) {
HXLINE(  73)												index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this86->virtualY) * ( (Float)(this86->width) )) + dx2) - this86->virtualX));
            											}
            											else {
HXLINE(  73)												index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this86->width) + dx2)) ));
            											}
HXDLIN(  73)											int c9 = ::iterMagic::Iimg_obj::get(this87,index10);
HXDLIN(  73)											int v4;
HXDLIN(  73)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)												v4 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE(  73)												v4 = c9;
            											}
HXDLIN(  73)											int maskPixel1 = v4;
HXDLIN(  73)											int this88 = col1;
HXDLIN(  73)											if ((maskPixel1 == 0)) {
HXLINE(  73)												col1 = this88;
            											}
            											else {
HXLINE(  73)												Float m01;
HXDLIN(  73)												int this89 = ((maskPixel1 >> 24) & 255);
HXDLIN(  73)												if ((this89 == 0)) {
HXLINE(  73)													m01 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m01 = (( (Float)(this89) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m11;
HXDLIN(  73)												int this90 = ((maskPixel1 >> 16) & 255);
HXDLIN(  73)												if ((this90 == 0)) {
HXLINE(  73)													m11 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m11 = (( (Float)(this90) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m21;
HXDLIN(  73)												int this91 = ((maskPixel1 >> 8) & 255);
HXDLIN(  73)												if ((this91 == 0)) {
HXLINE(  73)													m21 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m21 = (( (Float)(this91) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float m31;
HXDLIN(  73)												int this92 = (maskPixel1 & 255);
HXDLIN(  73)												if ((this92 == 0)) {
HXLINE(  73)													m31 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													m31 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this88 >> 24) & 255)) )));
HXDLIN(  73)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this88 >> 16) & 255)) )));
HXDLIN(  73)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this88 >> 8) & 255)) )));
HXDLIN(  73)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this88 & 255)) )));
HXDLIN(  73)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  73)										if ((col1 != 0)) {
HXLINE(  73)											int x9 = (dx2 - rectLeft1);
HXDLIN(  73)											int y9 = (dy2 - rectTop1);
HXDLIN(  73)											int c10 = col1;
HXDLIN(  73)											bool _hx_tmp21;
HXDLIN(  73)											if ((((c10 >> 24) & 255) < 254)) {
HXLINE(  73)												_hx_tmp21 = undoImage3->transparent;
            											}
            											else {
HXLINE(  73)												_hx_tmp21 = false;
            											}
HXDLIN(  73)											if (_hx_tmp21) {
HXLINE(  73)												int location6;
HXDLIN(  73)												if (undoImage3->useVirtualPos) {
HXLINE(  73)													location6 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  73)													location6 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            												}
HXDLIN(  73)												int this93 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN(  73)												int this94;
HXDLIN(  73)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													this94 = ((((((this93 >> 24) & 255) << 24) | ((this93 & 255) << 16)) | (((this93 >> 8) & 255) << 8)) | ((this93 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													this94 = this93;
            												}
HXDLIN(  73)												Float a17;
HXDLIN(  73)												int this95 = ((this94 >> 24) & 255);
HXDLIN(  73)												if ((this95 == 0)) {
HXLINE(  73)													a17 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a17 = (( (Float)(this95) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r16;
HXDLIN(  73)												int this96 = ((this94 >> 16) & 255);
HXDLIN(  73)												if ((this96 == 0)) {
HXLINE(  73)													r16 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r16 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g16;
HXDLIN(  73)												int this97 = ((this94 >> 8) & 255);
HXDLIN(  73)												if ((this97 == 0)) {
HXLINE(  73)													g16 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g16 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b19;
HXDLIN(  73)												int this98 = (this94 & 255);
HXDLIN(  73)												if ((this98 == 0)) {
HXLINE(  73)													b19 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b19 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a26;
HXDLIN(  73)												int this99 = ((col1 >> 24) & 255);
HXDLIN(  73)												if ((this99 == 0)) {
HXLINE(  73)													a26 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a26 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r26;
HXDLIN(  73)												int this100 = ((col1 >> 16) & 255);
HXDLIN(  73)												if ((this100 == 0)) {
HXLINE(  73)													r26 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r26 = (( (Float)(this100) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g26;
HXDLIN(  73)												int this101 = ((col1 >> 8) & 255);
HXDLIN(  73)												if ((this101 == 0)) {
HXLINE(  73)													g26 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g26 = (( (Float)(this101) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b26;
HXDLIN(  73)												int this102 = (col1 & 255);
HXDLIN(  73)												if ((this102 == 0)) {
HXLINE(  73)													b26 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b26 = (( (Float)(this102) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN(  73)												int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  73)												int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  73)												int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a36) + (b26 * a26))));
HXDLIN(  73)												int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  73)												int blended6 = ((((a18 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN(  73)												{
HXLINE(  73)													int _hx_tmp22;
HXDLIN(  73)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)														_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXLINE(  73)														_hx_tmp22 = blended6;
            													}
HXDLIN(  73)													::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            												}
            											}
            											else {
HXLINE(  73)												::Dynamic this103 = undoImage3->image;
HXDLIN(  73)												int index11;
HXDLIN(  73)												if (undoImage3->useVirtualPos) {
HXLINE(  73)													index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  73)													index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            												}
HXDLIN(  73)												int _hx_tmp23;
HXDLIN(  73)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													_hx_tmp23 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													_hx_tmp23 = c10;
            												}
HXDLIN(  73)												::iterMagic::Iimg_obj::set(this103,index11,_hx_tmp23);
            											}
            										}
            										else {
HXLINE(  73)											if (forceClear1) {
HXLINE(  73)												::Dynamic this104 = undoImage3->image;
HXDLIN(  73)												int x10 = (dx2 - rectLeft1);
HXDLIN(  73)												int y10 = (dy2 - rectTop1);
HXDLIN(  73)												int index12;
HXDLIN(  73)												if (undoImage3->useVirtualPos) {
HXLINE(  73)													index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  73)													index12 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage3->width) + x10)) ));
            												}
HXDLIN(  73)												::iterMagic::Iimg_obj::set(this104,index12,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  73)				bool found1 = false;
HXDLIN(  73)				Float s1 = ((Float)0.);
HXDLIN(  73)				Float t1 = ((Float)0.);
HXDLIN(  73)				Float sxx1 = ((Float)0.);
HXDLIN(  73)				Float txx1 = ((Float)0.);
HXDLIN(  73)				{
HXLINE(  73)					int _g_min2 = xIter31->start;
HXDLIN(  73)					int _g_max2 = xIter31->max;
HXDLIN(  73)					while((_g_min2 < _g_max2)){
HXLINE(  73)						_g_min2 = (_g_min2 + 1);
HXDLIN(  73)						int x11 = (_g_min2 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x11) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x11) ));
HXLINE(  62)						found1 = false;
HXLINE(  73)						{
HXLINE(  73)							int _g_min3 = yIter31->start;
HXDLIN(  73)							int _g_max3 = yIter31->max;
HXDLIN(  73)							while((_g_min3 < _g_max3)){
HXLINE(  73)								_g_min3 = (_g_min3 + 1);
HXDLIN(  73)								int y11 = (_g_min3 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y11) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y11) )));
HXLINE(  73)								bool _hx_tmp24;
HXDLIN(  73)								if (!((s1 <= 0))) {
HXLINE(  73)									_hx_tmp24 = (t1 <= 0);
            								}
            								else {
HXLINE(  73)									_hx_tmp24 = true;
            								}
HXDLIN(  73)								if (_hx_tmp24) {
HXLINE(  73)									if (found1) {
HXLINE(  73)										goto _hx_goto_76;
            									}
            								}
            								else {
HXLINE(  73)									if (((s1 + t1) < A1)) {
HXLINE(  73)										{
HXLINE(  73)											int c11 = color;
HXDLIN(  73)											bool _hx_tmp25;
HXDLIN(  73)											if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  73)												_hx_tmp25 = this1->transparent;
            											}
            											else {
HXLINE(  73)												_hx_tmp25 = false;
            											}
HXDLIN(  73)											if (_hx_tmp25) {
HXLINE(  73)												int location7;
HXDLIN(  73)												if (this1->useVirtualPos) {
HXLINE(  73)													location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            												}
            												else {
HXLINE(  73)													location7 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            												}
HXDLIN(  73)												int this105 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN(  73)												int this106;
HXDLIN(  73)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													this106 = ((((((this105 >> 24) & 255) << 24) | ((this105 & 255) << 16)) | (((this105 >> 8) & 255) << 8)) | ((this105 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													this106 = this105;
            												}
HXDLIN(  73)												Float a19;
HXDLIN(  73)												int this107 = ((this106 >> 24) & 255);
HXDLIN(  73)												if ((this107 == 0)) {
HXLINE(  73)													a19 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a19 = (( (Float)(this107) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r17;
HXDLIN(  73)												int this108 = ((this106 >> 16) & 255);
HXDLIN(  73)												if ((this108 == 0)) {
HXLINE(  73)													r17 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r17 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g17;
HXDLIN(  73)												int this109 = ((this106 >> 8) & 255);
HXDLIN(  73)												if ((this109 == 0)) {
HXLINE(  73)													g17 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g17 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b110;
HXDLIN(  73)												int this110 = (this106 & 255);
HXDLIN(  73)												if ((this110 == 0)) {
HXLINE(  73)													b110 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b110 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a27;
HXDLIN(  73)												int this111 = ((color >> 24) & 255);
HXDLIN(  73)												if ((this111 == 0)) {
HXLINE(  73)													a27 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													a27 = (( (Float)(this111) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float r27;
HXDLIN(  73)												int this112 = ((color >> 16) & 255);
HXDLIN(  73)												if ((this112 == 0)) {
HXLINE(  73)													r27 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													r27 = (( (Float)(this112) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float g27;
HXDLIN(  73)												int this113 = ((color >> 8) & 255);
HXDLIN(  73)												if ((this113 == 0)) {
HXLINE(  73)													g27 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													g27 = (( (Float)(this113) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float b27;
HXDLIN(  73)												int this114 = (color & 255);
HXDLIN(  73)												if ((this114 == 0)) {
HXLINE(  73)													b27 = ((Float)0.);
            												}
            												else {
HXLINE(  73)													b27 = (( (Float)(this114) ) / ( (Float)(255) ));
            												}
HXDLIN(  73)												Float a37 = (a19 * (( (Float)(1) ) - a27));
HXDLIN(  73)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  73)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  73)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b27 * a27))));
HXDLIN(  73)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  73)												int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b28);
HXDLIN(  73)												{
HXLINE(  73)													int _hx_tmp26;
HXDLIN(  73)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)														_hx_tmp26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXLINE(  73)														_hx_tmp26 = blended7;
            													}
HXDLIN(  73)													::iterMagic::Iimg_obj::set(this1->image,location7,_hx_tmp26);
            												}
            											}
            											else {
HXLINE(  73)												::Dynamic this115 = this1->image;
HXDLIN(  73)												int index13;
HXDLIN(  73)												if (this1->useVirtualPos) {
HXLINE(  73)													index13 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            												}
            												else {
HXLINE(  73)													index13 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            												}
HXDLIN(  73)												int _hx_tmp27;
HXDLIN(  73)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  73)													_hx_tmp27 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            												}
            												else {
HXLINE(  73)													_hx_tmp27 = c11;
            												}
HXDLIN(  73)												::iterMagic::Iimg_obj::set(this115,index13,_hx_tmp27);
            											}
            										}
HXDLIN(  73)										found1 = true;
            									}
            									else {
HXLINE(  73)										if (found1) {
HXLINE(  73)											goto _hx_goto_76;
            										}
            									}
            								}
            							}
            							_hx_goto_76:;
            						}
            					}
            				}
HXDLIN(  73)				if ((hasHit == true)) {
HXLINE(  73)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  73)					if (hasUndo1) {
HXLINE(  73)						v5->undoImage = undoImage3;
HXDLIN(  73)						v5->undoX = xIter31->start;
HXDLIN(  73)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN(  73)		if ((hasHit == true)) {
HXLINE(  73)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  73)			return v6;
            		}
            		else {
HXLINE(  73)			return null();
            		}
HXDLIN(  73)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FillShape_Impl__obj,line,return )

void FillShape_Impl__obj::roundRectangle( ::pi_xy::ImageStruct this1,Float x,Float y,Float hi,Float wid,int color, ::Dynamic __o_dx, ::Dynamic __o_dy, ::Dynamic __o_fat, ::Dynamic __o_tall){
            		 ::Dynamic dx = __o_dx;
            		if (::hx::IsNull(__o_dx)) dx = ((Float)-1.);
            		 ::Dynamic dy = __o_dy;
            		if (::hx::IsNull(__o_dy)) dy = ((Float)-1.);
            		 ::Dynamic fat = __o_fat;
            		if (::hx::IsNull(__o_fat)) fat = ((Float)-1.);
            		 ::Dynamic tall = __o_tall;
            		if (::hx::IsNull(__o_tall)) tall = ((Float)-1.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_89_roundRectangle)
HXDLIN(  89)		 ::Dynamic dx1 = dx;
HXDLIN(  89)		 ::Dynamic dy1 = dy;
HXDLIN(  89)		 ::Dynamic fat1 = fat;
HXDLIN(  89)		 ::Dynamic tall1 = tall;
HXLINE(  95)		if (::hx::IsNull( tall1 )) {
HXLINE(  95)			tall1 = ((Float)-1.);
            		}
HXDLIN(  95)		if (::hx::IsNull( fat1 )) {
HXLINE(  95)			fat1 = ((Float)-1.);
            		}
HXLINE(  94)		if (::hx::IsNull( dy1 )) {
HXLINE(  94)			dy1 = ((Float)-1.);
            		}
HXDLIN(  94)		if (::hx::IsNull( dx1 )) {
HXLINE(  94)			dx1 = ((Float)-1.);
            		}
HXLINE(  89)		if (::hx::IsLess( dx1,((Float)0.) )) {
HXDLIN(  89)			Float smallest;
HXDLIN(  89)			if ((hi < wid)) {
HXDLIN(  89)				smallest = hi;
            			}
            			else {
HXDLIN(  89)				smallest = wid;
            			}
HXDLIN(  89)			Float goldenRatio = ((Float)1.61803398875);
HXLINE(  26)			dx1 = (smallest / (goldenRatio + 2));
            		}
HXLINE(  89)		if (::hx::IsLess( dy1,((Float)0.) )) {
HXLINE(  28)			dy1 = dx1;
            		}
HXLINE(  89)		if (::hx::IsLess( fat1,((Float)0.) )) {
HXLINE(  29)			fat1 = (wid - (( (Float)(2) ) * ( (Float)(dx1) )));
            		}
HXLINE(  89)		if (::hx::IsLess( tall1,((Float)0.) )) {
HXLINE(  30)			tall1 = (hi - (( (Float)(2) ) * ( (Float)(dy1) )));
            		}
HXLINE(  89)		Float rightRadius = ((wid - ( (Float)(fat1) )) - ( (Float)(dx1) ));
HXDLIN(  89)		Float bottomRadius = ((hi - ( (Float)(tall1) )) - ( (Float)(dy1) ));
HXDLIN(  89)		Float farX = ((x + dx1) + fat1);
HXDLIN(  89)		Float lowerY = ((y + dy1) + tall1);
HXDLIN(  89)		{
HXDLIN(  89)			 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  89)			Float cx = (x + dx1);
HXDLIN(  89)			Float cy = (y + dy1);
HXDLIN(  89)			Float rx = ( (Float)(dx1) );
HXDLIN(  89)			Float ry = ( (Float)(dy1) );
HXDLIN(  89)			{
HXDLIN(  89)				 ::Dynamic targetError = ((Float)1.05);
HXDLIN(  89)				if (::hx::IsNull( targetError )) {
HXLINE( 113)					targetError = ((Float)1.05);
            				}
HXLINE(  89)				Float rSmall;
HXDLIN(  89)				if ((rx > ry)) {
HXDLIN(  89)					rSmall = ry;
            				}
            				else {
HXDLIN(  89)					rSmall = rx;
            				}
HXDLIN(  89)				 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN(  89)				if (::hx::IsNull( targetE )) {
HXLINE(  20)					targetE = ((Float)1.05);
            				}
HXLINE(  89)				int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  89)				int noSides;
HXDLIN(  89)				if ((result < 12)) {
HXDLIN(  89)					noSides = 12;
            				}
            				else {
HXDLIN(  89)					if ((result > 500)) {
HXDLIN(  89)						noSides = 500;
            					}
            					else {
HXDLIN(  89)						noSides = result;
            					}
            				}
HXDLIN(  89)				int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN(  89)				Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN(  89)				Float omega = ::Math_obj::PI;
HXDLIN(  89)				int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN(  89)				Float lastX = ((Float)0.);
HXDLIN(  89)				Float lastY = ((Float)0.);
HXDLIN(  89)				{
HXLINE(  26)					lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)					lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            				}
HXLINE(  89)				{
HXDLIN(  89)					int _g = 0;
HXDLIN(  89)					int _g1 = (quarter + 1);
HXDLIN(  89)					while((_g < _g1)){
HXDLIN(  89)						_g = (_g + 1);
HXDLIN(  89)						int i = (_g - 1);
HXDLIN(  89)						Float nextX = (cx + (rx * ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  89)						Float nextY = (cy + (ry * ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  89)						{
HXDLIN(  89)							 ::pi_xy::ImageStruct this3 = this2;
HXDLIN(  89)							bool hasHit = false;
HXDLIN(  89)							bool hasUndo = false;
HXDLIN(  89)							{
HXDLIN(  89)								Float bx = lastX;
HXDLIN(  89)								Float by = lastY;
HXDLIN(  89)								Float cx1 = nextX;
HXDLIN(  89)								Float cy1 = nextY;
HXDLIN(  89)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  89)								if (!(adjustWinding)) {
HXDLIN(  89)									Float bx_ = bx;
HXDLIN(  89)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE(  89)								{
HXDLIN(  89)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  89)									Float sx = (cy1 - cy);
HXDLIN(  89)									Float sy = (cx - cx1);
HXDLIN(  89)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  89)									Float tx = (cy - by);
HXDLIN(  89)									Float ty = (bx - cx);
HXDLIN(  89)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  89)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  89)									if ((cx > bx)) {
HXDLIN(  89)										if ((cx > cx1)) {
HXDLIN(  89)											int min;
HXDLIN(  89)											if ((bx > cx1)) {
HXDLIN(  89)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN(  89)												min = ::Math_obj::floor(bx);
            											}
HXDLIN(  89)											int ii_min = min;
HXDLIN(  89)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  89)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN(  89)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  89)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  89)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN(  89)										if ((bx > cx1)) {
HXDLIN(  89)											int min1;
HXDLIN(  89)											if ((cx > cx1)) {
HXDLIN(  89)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN(  89)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN(  89)											int ii_min2 = min1;
HXDLIN(  89)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  89)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN(  89)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN(  89)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  89)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN(  89)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  89)									if ((cy > by)) {
HXDLIN(  89)										if ((cy > cy1)) {
HXDLIN(  89)											int min2;
HXDLIN(  89)											if ((by > cy1)) {
HXDLIN(  89)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN(  89)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN(  89)											int ii_min4 = min2;
HXDLIN(  89)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN(  89)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN(  89)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  89)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  89)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN(  89)										if ((by > cy1)) {
HXDLIN(  89)											int min3;
HXDLIN(  89)											if ((cy > cy1)) {
HXDLIN(  89)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN(  89)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN(  89)											int ii_min6 = min3;
HXDLIN(  89)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  89)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN(  89)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN(  89)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  89)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN(  89)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  89)									if (hasUndo) {
HXDLIN(  89)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  89)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  89)										 ::Dynamic imageType = null();
HXDLIN(  89)										 ::pi_xy::ImageStruct this4 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  89)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE(  89)										::Dynamic undoImage1;
HXDLIN(  89)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN(  89)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::BytesImg b = byt;
HXDLIN(  89)												{
HXDLIN(  89)													b->width = width;
HXDLIN(  89)													b->height = height;
HXDLIN(  89)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  89)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  89)													{
HXDLIN(  89)														int len = b->length;
HXDLIN(  89)														int w = 0;
HXDLIN(  89)														{
HXDLIN(  89)															int _g2 = 0;
HXDLIN(  89)															int _g3 = b->height;
HXDLIN(  89)															while((_g2 < _g3)){
HXDLIN(  89)																_g2 = (_g2 + 1);
HXDLIN(  89)																int y1 = (_g2 - 1);
HXDLIN(  89)																{
HXDLIN(  89)																	int _g4 = 0;
HXDLIN(  89)																	int _g5 = b->width;
HXDLIN(  89)																	while((_g4 < _g5)){
HXDLIN(  89)																		_g4 = (_g4 + 1);
HXDLIN(  89)																		int x1 = (_g4 - 1);
HXDLIN(  89)																		{
HXDLIN(  89)																			w = (w + 1);
HXDLIN(  89)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w = (w + 1);
HXDLIN(  89)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w = (w + 1);
HXDLIN(  89)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w = (w + 1);
HXDLIN(  89)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN(  89)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  89)												{
HXDLIN(  89)													a->width = width;
HXDLIN(  89)													a->height = height;
HXDLIN(  89)													a->data = ::Array_obj< int >::__new(0);
HXDLIN(  89)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  89)													{
HXDLIN(  89)														int _g6 = 0;
HXDLIN(  89)														int _g7 = a->length;
HXDLIN(  89)														while((_g6 < _g7)){
HXDLIN(  89)															_g6 = (_g6 + 1);
HXDLIN(  89)															int i1 = (_g6 - 1);
HXDLIN(  89)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN(  89)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN(  89)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  89)												{
HXDLIN(  89)													b1->width = width;
HXDLIN(  89)													b1->height = height;
HXDLIN(  89)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  89)													int size = (b1->length * 4);
HXDLIN(  89)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  89)													{
HXDLIN(  89)														int _g8 = 0;
HXDLIN(  89)														int _g9 = b1->length;
HXDLIN(  89)														while((_g8 < _g9)){
HXDLIN(  89)															_g8 = (_g8 + 1);
HXDLIN(  89)															int i2 = (_g8 - 1);
HXDLIN(  89)															{
HXDLIN(  89)																 ::haxe::io::ArrayBufferViewImpl this5 = b1->data;
HXDLIN(  89)																bool undoImage2;
HXDLIN(  89)																if ((i2 >= 0)) {
HXDLIN(  89)																	undoImage2 = (i2 < (this5->byteLength >> 2));
            																}
            																else {
HXDLIN(  89)																	undoImage2 = false;
            																}
HXDLIN(  89)																if (undoImage2) {
HXDLIN(  89)																	 ::haxe::io::Bytes _this = this5->bytes;
HXDLIN(  89)																	int pos = ((i2 << 2) + this5->byteOffset);
HXDLIN(  89)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN(  89)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::VecIntImg v = vec;
HXDLIN(  89)												{
HXDLIN(  89)													v->width = width;
HXDLIN(  89)													v->height = height;
HXDLIN(  89)													v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  89)													v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  89)													{
HXDLIN(  89)														int _g10 = 0;
HXDLIN(  89)														int _g11 = v->length;
HXDLIN(  89)														while((_g10 < _g11)){
HXDLIN(  89)															_g10 = (_g10 + 1);
HXDLIN(  89)															int i3 = (_g10 - 1);
HXDLIN(  89)															v->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN(  89)												undoImage1 = v;
            											}
            											break;
            											case (int)4: {
HXDLIN(  89)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  89)												{
HXDLIN(  89)													b2->width = width;
HXDLIN(  89)													b2->height = height;
HXDLIN(  89)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  89)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  89)													{
HXDLIN(  89)														int len1 = b2->length;
HXDLIN(  89)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  89)														if (::hx::IsNull( d->head )) {
HXDLIN(  89)															int _g12 = 0;
HXDLIN(  89)															int _g13 = len1;
HXDLIN(  89)															while((_g12 < _g13)){
HXDLIN(  89)																_g12 = (_g12 + 1);
HXDLIN(  89)																int i4 = (_g12 - 1);
HXDLIN(  89)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN(  89)															int _g14 = 0;
HXDLIN(  89)															int _g15 = len1;
HXDLIN(  89)															while((_g14 < _g15)){
HXDLIN(  89)																_g14 = (_g14 + 1);
HXDLIN(  89)																int i5 = (_g14 - 1);
HXDLIN(  89)																{
HXDLIN(  89)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  89)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  89)																	{
HXDLIN(  89)																		int _g16 = 0;
HXDLIN(  89)																		int _g17 = i5;
HXDLIN(  89)																		while((_g16 < _g17)){
HXDLIN(  89)																			_g16 = (_g16 + 1);
HXDLIN(  89)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE(  89)																	if (::hx::IsNull( prev )) {
HXDLIN(  89)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  89)																		l = null();
            																	}
            																	else {
HXDLIN(  89)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  89)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN(  89)										this4->image = undoImage1;
HXDLIN(  89)										this4->width = width;
HXDLIN(  89)										this4->height = height;
HXDLIN(  89)										this4->imageType = ( (int)(imageType) );
HXDLIN(  89)										undoImage = this4;
HXDLIN(  89)										{
HXDLIN(  89)											int rectLeft = xIter3->start;
HXDLIN(  89)											int rectTop = yIter3->start;
HXDLIN(  89)											int rectRight = xIter3->max;
HXDLIN(  89)											bool forceClear = false;
HXDLIN(  89)											{
HXDLIN(  89)												int _g18 = rectTop;
HXDLIN(  89)												int _g19 = yIter3->max;
HXDLIN(  89)												while((_g18 < _g19)){
HXDLIN(  89)													_g18 = (_g18 + 1);
HXDLIN(  89)													int dy2 = (_g18 - 1);
HXDLIN(  89)													{
HXDLIN(  89)														int _g20 = rectLeft;
HXDLIN(  89)														int _g21 = rectRight;
HXDLIN(  89)														while((_g20 < _g21)){
HXDLIN(  89)															_g20 = (_g20 + 1);
HXDLIN(  89)															int dx2 = (_g20 - 1);
HXDLIN(  89)															::Dynamic this6 = this3->image;
HXDLIN(  89)															int index;
HXDLIN(  89)															if (this3->useVirtualPos) {
HXDLIN(  89)																index = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this3->virtualY) * ( (Float)(this3->width) )) + dx2) - this3->virtualX));
            															}
            															else {
HXDLIN(  89)																index = ::Std_obj::_hx_int(( (Float)(((dy2 * this3->width) + dx2)) ));
            															}
HXDLIN(  89)															int c = ::iterMagic::Iimg_obj::get(this6,index);
HXDLIN(  89)															int col;
HXDLIN(  89)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN(  89)																col = c;
            															}
HXDLIN(  89)															bool _hx_tmp;
HXDLIN(  89)															if (this3->useMask) {
HXDLIN(  89)																_hx_tmp = ::hx::IsNotNull( this3->mask );
            															}
            															else {
HXDLIN(  89)																_hx_tmp = false;
            															}
HXDLIN(  89)															if (_hx_tmp) {
HXDLIN(  89)																 ::pi_xy::ImageStruct this7 = this3->mask;
HXDLIN(  89)																::Dynamic this8 = this7->image;
HXDLIN(  89)																int index1;
HXDLIN(  89)																if (this7->useVirtualPos) {
HXDLIN(  89)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this7->virtualY) * ( (Float)(this7->width) )) + dx2) - this7->virtualX));
            																}
            																else {
HXDLIN(  89)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy2 * this7->width) + dx2)) ));
            																}
HXDLIN(  89)																int c1 = ::iterMagic::Iimg_obj::get(this8,index1);
HXDLIN(  89)																int v1;
HXDLIN(  89)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																	v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN(  89)																	v1 = c1;
            																}
HXDLIN(  89)																int maskPixel = v1;
HXDLIN(  89)																int this9 = col;
HXDLIN(  89)																if ((maskPixel == 0)) {
HXDLIN(  89)																	col = this9;
            																}
            																else {
HXDLIN(  89)																	Float m0;
HXDLIN(  89)																	int this10 = ((maskPixel >> 24) & 255);
HXDLIN(  89)																	if ((this10 == 0)) {
HXDLIN(  89)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m0 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m1;
HXDLIN(  89)																	int this11 = ((maskPixel >> 16) & 255);
HXDLIN(  89)																	if ((this11 == 0)) {
HXDLIN(  89)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m1 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m2;
HXDLIN(  89)																	int this12 = ((maskPixel >> 8) & 255);
HXDLIN(  89)																	if ((this12 == 0)) {
HXDLIN(  89)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m2 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m3;
HXDLIN(  89)																	int this13 = (maskPixel & 255);
HXDLIN(  89)																	if ((this13 == 0)) {
HXDLIN(  89)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m3 = (( (Float)(this13) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this9 >> 24) & 255)) )));
HXDLIN(  89)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this9 >> 16) & 255)) )));
HXDLIN(  89)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this9 >> 8) & 255)) )));
HXDLIN(  89)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this9 & 255)) )));
HXDLIN(  89)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN(  89)															if ((col != 0)) {
HXDLIN(  89)																int x2 = (dx2 - rectLeft);
HXDLIN(  89)																int y2 = (dy2 - rectTop);
HXDLIN(  89)																int c2 = col;
HXDLIN(  89)																bool _hx_tmp1;
HXDLIN(  89)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  89)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN(  89)																	_hx_tmp1 = false;
            																}
HXDLIN(  89)																if (_hx_tmp1) {
HXDLIN(  89)																	int location;
HXDLIN(  89)																	if (undoImage->useVirtualPos) {
HXDLIN(  89)																		location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		location = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN(  89)																	int this14 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  89)																	int this15;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		this15 = this14;
            																	}
HXDLIN(  89)																	Float a1;
HXDLIN(  89)																	int this16 = ((this15 >> 24) & 255);
HXDLIN(  89)																	if ((this16 == 0)) {
HXDLIN(  89)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r1;
HXDLIN(  89)																	int this17 = ((this15 >> 16) & 255);
HXDLIN(  89)																	if ((this17 == 0)) {
HXDLIN(  89)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g1;
HXDLIN(  89)																	int this18 = ((this15 >> 8) & 255);
HXDLIN(  89)																	if ((this18 == 0)) {
HXDLIN(  89)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g1 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b11;
HXDLIN(  89)																	int this19 = (this15 & 255);
HXDLIN(  89)																	if ((this19 == 0)) {
HXDLIN(  89)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a2;
HXDLIN(  89)																	int this20 = ((col >> 24) & 255);
HXDLIN(  89)																	if ((this20 == 0)) {
HXDLIN(  89)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r2;
HXDLIN(  89)																	int this21 = ((col >> 16) & 255);
HXDLIN(  89)																	if ((this21 == 0)) {
HXDLIN(  89)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g2;
HXDLIN(  89)																	int this22 = ((col >> 8) & 255);
HXDLIN(  89)																	if ((this22 == 0)) {
HXDLIN(  89)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g2 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b21;
HXDLIN(  89)																	int this23 = (col & 255);
HXDLIN(  89)																	if ((this23 == 0)) {
HXDLIN(  89)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  89)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  89)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  89)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  89)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  89)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  89)																	{
HXDLIN(  89)																		int _hx_tmp2;
HXDLIN(  89)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN(  89)																			_hx_tmp2 = blended;
            																		}
HXDLIN(  89)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN(  89)																	::Dynamic this24 = undoImage->image;
HXDLIN(  89)																	int index2;
HXDLIN(  89)																	if (undoImage->useVirtualPos) {
HXDLIN(  89)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index2 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN(  89)																	int _hx_tmp3;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		_hx_tmp3 = c2;
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this24,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN(  89)																if (forceClear) {
HXDLIN(  89)																	::Dynamic this25 = undoImage->image;
HXDLIN(  89)																	int x3 = (dx2 - rectLeft);
HXDLIN(  89)																	int y3 = (dy2 - rectTop);
HXDLIN(  89)																	int index3;
HXDLIN(  89)																	if (undoImage->useVirtualPos) {
HXDLIN(  89)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this25,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  89)									bool found = false;
HXDLIN(  89)									Float s = ((Float)0.);
HXDLIN(  89)									Float t = ((Float)0.);
HXDLIN(  89)									Float sxx = ((Float)0.);
HXDLIN(  89)									Float txx = ((Float)0.);
HXDLIN(  89)									{
HXDLIN(  89)										int _g_min = xIter3->start;
HXDLIN(  89)										int _g_max = xIter3->max;
HXDLIN(  89)										while((_g_min < _g_max)){
HXDLIN(  89)											_g_min = (_g_min + 1);
HXDLIN(  89)											int x4 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x4) ));
HXLINE(  61)											txx = (tx * ( (Float)(x4) ));
HXLINE(  62)											found = false;
HXLINE(  89)											{
HXDLIN(  89)												int _g_min1 = yIter3->start;
HXDLIN(  89)												int _g_max1 = yIter3->max;
HXDLIN(  89)												while((_g_min1 < _g_max1)){
HXDLIN(  89)													_g_min1 = (_g_min1 + 1);
HXDLIN(  89)													int y4 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y4) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y4) )));
HXLINE(  89)													bool _hx_tmp4;
HXDLIN(  89)													if (!((s <= 0))) {
HXDLIN(  89)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN(  89)														_hx_tmp4 = true;
            													}
HXDLIN(  89)													if (_hx_tmp4) {
HXDLIN(  89)														if (found) {
HXDLIN(  89)															goto _hx_goto_90;
            														}
            													}
            													else {
HXDLIN(  89)														if (((s + t) < A)) {
HXDLIN(  89)															{
HXDLIN(  89)																int c3 = color;
HXDLIN(  89)																bool _hx_tmp5;
HXDLIN(  89)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN(  89)																	_hx_tmp5 = this3->transparent;
            																}
            																else {
HXDLIN(  89)																	_hx_tmp5 = false;
            																}
HXDLIN(  89)																if (_hx_tmp5) {
HXDLIN(  89)																	int location1;
HXDLIN(  89)																	if (this3->useVirtualPos) {
HXDLIN(  89)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this3->virtualY) * ( (Float)(this3->width) )) + x4) - this3->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		location1 = ::Std_obj::_hx_int(( (Float)(((y4 * this3->width) + x4)) ));
            																	}
HXDLIN(  89)																	int this26 = ::iterMagic::Iimg_obj::get(this3->image,location1);
HXDLIN(  89)																	int this27;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		this27 = this26;
            																	}
HXDLIN(  89)																	Float a11;
HXDLIN(  89)																	int this28 = ((this27 >> 24) & 255);
HXDLIN(  89)																	if ((this28 == 0)) {
HXDLIN(  89)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r11;
HXDLIN(  89)																	int this29 = ((this27 >> 16) & 255);
HXDLIN(  89)																	if ((this29 == 0)) {
HXDLIN(  89)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g11;
HXDLIN(  89)																	int this30 = ((this27 >> 8) & 255);
HXDLIN(  89)																	if ((this30 == 0)) {
HXDLIN(  89)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b12;
HXDLIN(  89)																	int this31 = (this27 & 255);
HXDLIN(  89)																	if ((this31 == 0)) {
HXDLIN(  89)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a21;
HXDLIN(  89)																	int this32 = ((color >> 24) & 255);
HXDLIN(  89)																	if ((this32 == 0)) {
HXDLIN(  89)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r21;
HXDLIN(  89)																	int this33 = ((color >> 16) & 255);
HXDLIN(  89)																	if ((this33 == 0)) {
HXDLIN(  89)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g21;
HXDLIN(  89)																	int this34 = ((color >> 8) & 255);
HXDLIN(  89)																	if ((this34 == 0)) {
HXDLIN(  89)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b22;
HXDLIN(  89)																	int this35 = (color & 255);
HXDLIN(  89)																	if ((this35 == 0)) {
HXDLIN(  89)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  89)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  89)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  89)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  89)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  89)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  89)																	{
HXDLIN(  89)																		int _hx_tmp6;
HXDLIN(  89)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN(  89)																			_hx_tmp6 = blended1;
            																		}
HXDLIN(  89)																		::iterMagic::Iimg_obj::set(this3->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN(  89)																	::Dynamic this36 = this3->image;
HXDLIN(  89)																	int index4;
HXDLIN(  89)																	if (this3->useVirtualPos) {
HXDLIN(  89)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this3->virtualY) * ( (Float)(this3->width) )) + x4) - this3->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index4 = ::Std_obj::_hx_int(( (Float)(((y4 * this3->width) + x4)) ));
            																	}
HXDLIN(  89)																	int _hx_tmp7;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		_hx_tmp7 = c3;
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this36,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN(  89)															if (found) {
HXDLIN(  89)																goto _hx_goto_90;
            															}
            														}
            													}
            												}
            												_hx_goto_90:;
            											}
            										}
            									}
HXDLIN(  89)									if ((hasHit == true)) {
HXDLIN(  89)										 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  89)										if (hasUndo) {
HXDLIN(  89)											v2->undoImage = undoImage;
HXDLIN(  89)											v2->undoX = xIter3->start;
HXDLIN(  89)											v2->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  46)						lastX = nextX;
HXLINE(  47)						lastY = nextY;
            					}
            				}
            			}
            		}
HXLINE(  89)		{
HXDLIN(  89)			int r_x = ::Std_obj::_hx_int((x + dx1));
HXDLIN(  89)			int r_y = ::Std_obj::_hx_int(y);
HXDLIN(  89)			int r_w = ::Std_obj::_hx_int(( (Float)(fat1) ));
HXDLIN(  89)			int r_h = ::Std_obj::_hx_int(( (Float)(dy1) ));
HXDLIN(  89)			int xmax = ((r_x + r_w) + 1);
HXDLIN(  89)			int ymax = ((r_y + r_h) + 1);
HXDLIN(  89)			int ii_min8 = r_x;
HXDLIN(  89)			int ii_max8 = xmax;
HXDLIN(  89)			int xRange__start = ii_min8;
HXDLIN(  89)			int xRange__max = ii_max8;
HXDLIN(  89)			int ii_min9 = r_y;
HXDLIN(  89)			int ii_max9 = ymax;
HXDLIN(  89)			int yRange__start = ii_min9;
HXDLIN(  89)			int yRange__max = ii_max9;
HXDLIN(  89)			int range_x = xRange__start;
HXDLIN(  89)			int range_y = (yRange__start - 1);
HXDLIN(  89)			int range_xReset = range_x;
HXDLIN(  89)			int range_yReset = range_y;
HXDLIN(  89)			int range_xMax = (xRange__max - 2);
HXDLIN(  89)			int range_yMax = (yRange__max - 2);
HXDLIN(  89)			int _this_min = 0;
HXDLIN(  89)			int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  89)			while((_this_min < _this_max)){
HXDLIN(  89)				_this_min = (_this_min + 1);
HXDLIN(  89)				int i7 = (_this_min - 1);
HXDLIN(  89)				if ((range_y > range_yMax)) {
HXDLIN(  89)					range_y = range_yReset;
HXDLIN(  89)					range_x = (range_x + 1);
            				}
HXDLIN(  89)				range_y = (range_y + 1);
HXDLIN(  89)				int i8 = i7;
HXDLIN(  89)				{
HXDLIN(  89)					int x5 = range_x;
HXDLIN(  89)					int y5 = range_y;
HXDLIN(  89)					int c4 = color;
HXDLIN(  89)					bool _hx_tmp8;
HXDLIN(  89)					if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  89)						_hx_tmp8 = this1->transparent;
            					}
            					else {
HXDLIN(  89)						_hx_tmp8 = false;
            					}
HXDLIN(  89)					if (_hx_tmp8) {
HXDLIN(  89)						int location2;
HXDLIN(  89)						if (this1->useVirtualPos) {
HXDLIN(  89)							location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this1->virtualY) * ( (Float)(this1->width) )) + x5) - this1->virtualX));
            						}
            						else {
HXDLIN(  89)							location2 = ::Std_obj::_hx_int(( (Float)(((y5 * this1->width) + x5)) ));
            						}
HXDLIN(  89)						int this37 = ::iterMagic::Iimg_obj::get(this1->image,location2);
HXDLIN(  89)						int this38;
HXDLIN(  89)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)							this38 = ((((((this37 >> 24) & 255) << 24) | ((this37 & 255) << 16)) | (((this37 >> 8) & 255) << 8)) | ((this37 >> 16) & 255));
            						}
            						else {
HXDLIN(  89)							this38 = this37;
            						}
HXDLIN(  89)						Float a12;
HXDLIN(  89)						int this39 = ((this38 >> 24) & 255);
HXDLIN(  89)						if ((this39 == 0)) {
HXDLIN(  89)							a12 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							a12 = (( (Float)(this39) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float r12;
HXDLIN(  89)						int this40 = ((this38 >> 16) & 255);
HXDLIN(  89)						if ((this40 == 0)) {
HXDLIN(  89)							r12 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							r12 = (( (Float)(this40) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float g12;
HXDLIN(  89)						int this41 = ((this38 >> 8) & 255);
HXDLIN(  89)						if ((this41 == 0)) {
HXDLIN(  89)							g12 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							g12 = (( (Float)(this41) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float b13;
HXDLIN(  89)						int this42 = (this38 & 255);
HXDLIN(  89)						if ((this42 == 0)) {
HXDLIN(  89)							b13 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							b13 = (( (Float)(this42) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float a22;
HXDLIN(  89)						int this43 = ((color >> 24) & 255);
HXDLIN(  89)						if ((this43 == 0)) {
HXDLIN(  89)							a22 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							a22 = (( (Float)(this43) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float r22;
HXDLIN(  89)						int this44 = ((color >> 16) & 255);
HXDLIN(  89)						if ((this44 == 0)) {
HXDLIN(  89)							r22 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							r22 = (( (Float)(this44) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float g22;
HXDLIN(  89)						int this45 = ((color >> 8) & 255);
HXDLIN(  89)						if ((this45 == 0)) {
HXDLIN(  89)							g22 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							g22 = (( (Float)(this45) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float b23;
HXDLIN(  89)						int this46 = (color & 255);
HXDLIN(  89)						if ((this46 == 0)) {
HXDLIN(  89)							b23 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							b23 = (( (Float)(this46) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  89)						int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  89)						int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  89)						int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  89)						int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  89)						int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b5);
HXDLIN(  89)						{
HXDLIN(  89)							int _hx_tmp9;
HXDLIN(  89)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)								_hx_tmp9 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            							}
            							else {
HXDLIN(  89)								_hx_tmp9 = blended2;
            							}
HXDLIN(  89)							::iterMagic::Iimg_obj::set(this1->image,location2,_hx_tmp9);
            						}
            					}
            					else {
HXDLIN(  89)						::Dynamic this47 = this1->image;
HXDLIN(  89)						int index5;
HXDLIN(  89)						if (this1->useVirtualPos) {
HXDLIN(  89)							index5 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this1->virtualY) * ( (Float)(this1->width) )) + x5) - this1->virtualX));
            						}
            						else {
HXDLIN(  89)							index5 = ::Std_obj::_hx_int(( (Float)(((y5 * this1->width) + x5)) ));
            						}
HXDLIN(  89)						int _hx_tmp10;
HXDLIN(  89)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)							_hx_tmp10 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            						}
            						else {
HXDLIN(  89)							_hx_tmp10 = c4;
            						}
HXDLIN(  89)						::iterMagic::Iimg_obj::set(this47,index5,_hx_tmp10);
            					}
            				}
            			}
            		}
HXDLIN(  89)		{
HXDLIN(  89)			 ::pi_xy::ImageStruct this48 = this1;
HXDLIN(  89)			Float cy2 = (y + dy1);
HXDLIN(  89)			Float ry1 = ( (Float)(dy1) );
HXDLIN(  89)			{
HXDLIN(  89)				 ::Dynamic targetError1 = ((Float)1.05);
HXDLIN(  89)				if (::hx::IsNull( targetError1 )) {
HXLINE( 113)					targetError1 = ((Float)1.05);
            				}
HXLINE(  89)				Float rSmall1;
HXDLIN(  89)				if ((rightRadius > ry1)) {
HXDLIN(  89)					rSmall1 = ry1;
            				}
            				else {
HXDLIN(  89)					rSmall1 = rightRadius;
            				}
HXDLIN(  89)				 ::Dynamic targetE1 = ( (Float)(targetError1) );
HXDLIN(  89)				if (::hx::IsNull( targetE1 )) {
HXLINE(  20)					targetE1 = ((Float)1.05);
            				}
HXLINE(  89)				int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN(  89)				int noSides1;
HXDLIN(  89)				if ((result1 < 12)) {
HXDLIN(  89)					noSides1 = 12;
            				}
            				else {
HXDLIN(  89)					if ((result1 > 500)) {
HXDLIN(  89)						noSides1 = 500;
            					}
            					else {
HXDLIN(  89)						noSides1 = result1;
            					}
            				}
HXDLIN(  89)				int sides1 = (::Math_obj::ceil((( (Float)(noSides1) ) / ( (Float)(4) ))) * 4);
HXDLIN(  89)				Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  89)				Float omega1 = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN(  89)				int quarter1 = ::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(4) )));
HXDLIN(  89)				Float lastX1 = ((Float)0.);
HXDLIN(  89)				Float lastY1 = ((Float)0.);
HXDLIN(  89)				{
HXLINE(  26)					lastX1 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides1) ) * theta1) + omega1))));
HXLINE(  27)					lastY1 = (cy2 + (ry1 * ::Math_obj::sin(((( (Float)(sides1) ) * theta1) + omega1))));
            				}
HXLINE(  89)				{
HXDLIN(  89)					int _g22 = 0;
HXDLIN(  89)					int _g23 = (quarter1 + 1);
HXDLIN(  89)					while((_g22 < _g23)){
HXDLIN(  89)						_g22 = (_g22 + 1);
HXDLIN(  89)						int i9 = (_g22 - 1);
HXDLIN(  89)						Float nextX1 = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i9) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  89)						Float nextY1 = (cy2 + (ry1 * ::Math_obj::sin((((( (Float)(i9) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN(  89)						{
HXDLIN(  89)							 ::pi_xy::ImageStruct this49 = this48;
HXDLIN(  89)							bool hasHit1 = false;
HXDLIN(  89)							bool hasUndo1 = false;
HXDLIN(  89)							{
HXDLIN(  89)								Float bx1 = lastX1;
HXDLIN(  89)								Float by1 = lastY1;
HXDLIN(  89)								Float cx2 = nextX1;
HXDLIN(  89)								Float cy3 = nextY1;
HXDLIN(  89)								bool adjustWinding1 = (((((farX * by1) - (bx1 * cy2)) + ((bx1 * cy3) - (cx2 * by1))) + ((cx2 * cy2) - (farX * cy3))) > 0);
HXDLIN(  89)								if (!(adjustWinding1)) {
HXDLIN(  89)									Float bx_1 = bx1;
HXDLIN(  89)									Float by_1 = by1;
HXLINE(  25)									bx1 = cx2;
HXLINE(  26)									by1 = cy3;
HXLINE(  27)									cx2 = bx_1;
HXLINE(  28)									cy3 = by_1;
            								}
HXLINE(  89)								{
HXDLIN(  89)									Float s01 = ((cy2 * cx2) - (farX * cy3));
HXDLIN(  89)									Float sx1 = (cy3 - cy2);
HXDLIN(  89)									Float sy1 = (farX - cx2);
HXDLIN(  89)									Float t01 = ((farX * by1) - (cy2 * bx1));
HXDLIN(  89)									Float tx1 = (cy2 - by1);
HXDLIN(  89)									Float ty1 = (bx1 - farX);
HXDLIN(  89)									Float A1 = ((((-(by1) * cx2) + (cy2 * (-(bx1) + cx2))) + (farX * (by1 - cy3))) + (bx1 * cy3));
HXDLIN(  89)									 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  89)									if ((farX > bx1)) {
HXDLIN(  89)										if ((farX > cx2)) {
HXDLIN(  89)											int min4;
HXDLIN(  89)											if ((bx1 > cx2)) {
HXDLIN(  89)												min4 = ::Math_obj::floor(cx2);
            											}
            											else {
HXDLIN(  89)												min4 = ::Math_obj::floor(bx1);
            											}
HXDLIN(  89)											int ii_min10 = min4;
HXDLIN(  89)											int ii_max10 = ::Math_obj::ceil(farX);
HXDLIN(  89)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            										}
            										else {
HXDLIN(  89)											int ii_min11 = ::Math_obj::floor(bx1);
HXDLIN(  89)											int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  89)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            										}
            									}
            									else {
HXDLIN(  89)										if ((bx1 > cx2)) {
HXDLIN(  89)											int min5;
HXDLIN(  89)											if ((farX > cx2)) {
HXDLIN(  89)												min5 = ::Math_obj::floor(cx2);
            											}
            											else {
HXDLIN(  89)												min5 = ::Math_obj::ceil(farX);
            											}
HXDLIN(  89)											int ii_min12 = min5;
HXDLIN(  89)											int ii_max12 = ::Math_obj::ceil(bx1);
HXDLIN(  89)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            										}
            										else {
HXDLIN(  89)											int ii_min13 = ::Math_obj::floor(farX);
HXDLIN(  89)											int ii_max13 = ::Math_obj::ceil(cx2);
HXDLIN(  89)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            										}
            									}
HXDLIN(  89)									 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  89)									if ((cy2 > by1)) {
HXDLIN(  89)										if ((cy2 > cy3)) {
HXDLIN(  89)											int min6;
HXDLIN(  89)											if ((by1 > cy3)) {
HXDLIN(  89)												min6 = ::Math_obj::floor(cy3);
            											}
            											else {
HXDLIN(  89)												min6 = ::Math_obj::floor(by1);
            											}
HXDLIN(  89)											int ii_min14 = min6;
HXDLIN(  89)											int ii_max14 = ::Math_obj::ceil(cy2);
HXDLIN(  89)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            										}
            										else {
HXDLIN(  89)											int ii_min15 = ::Math_obj::floor(by1);
HXDLIN(  89)											int ii_max15 = ::Math_obj::ceil(cy3);
HXDLIN(  89)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            										}
            									}
            									else {
HXDLIN(  89)										if ((by1 > cy3)) {
HXDLIN(  89)											int min7;
HXDLIN(  89)											if ((cy2 > cy3)) {
HXDLIN(  89)												min7 = ::Math_obj::floor(cy3);
            											}
            											else {
HXDLIN(  89)												min7 = ::Math_obj::ceil(cy2);
            											}
HXDLIN(  89)											int ii_min16 = min7;
HXDLIN(  89)											int ii_max16 = ::Math_obj::ceil(by1);
HXDLIN(  89)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            										}
            										else {
HXDLIN(  89)											int ii_min17 = ::Math_obj::floor(cy2);
HXDLIN(  89)											int ii_max17 = ::Math_obj::ceil(cy3);
HXDLIN(  89)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            										}
            									}
HXDLIN(  89)									 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  89)									if (hasUndo1) {
HXDLIN(  89)										int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  89)										int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  89)										 ::Dynamic imageType1 = null();
HXDLIN(  89)										 ::pi_xy::ImageStruct this50 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  89)										if (::hx::IsNull( imageType1 )) {
HXLINE(  54)											imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE(  89)										::Dynamic undoImage4;
HXDLIN(  89)										switch((int)(( (int)(imageType1) ))){
            											case (int)0: {
HXDLIN(  89)												 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::BytesImg b6 = byt1;
HXDLIN(  89)												{
HXDLIN(  89)													b6->width = width1;
HXDLIN(  89)													b6->height = height1;
HXDLIN(  89)													b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  89)													b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  89)													{
HXDLIN(  89)														int len2 = b6->length;
HXDLIN(  89)														int w1 = 0;
HXDLIN(  89)														{
HXDLIN(  89)															int _g24 = 0;
HXDLIN(  89)															int _g25 = b6->height;
HXDLIN(  89)															while((_g24 < _g25)){
HXDLIN(  89)																_g24 = (_g24 + 1);
HXDLIN(  89)																int y6 = (_g24 - 1);
HXDLIN(  89)																{
HXDLIN(  89)																	int _g26 = 0;
HXDLIN(  89)																	int _g27 = b6->width;
HXDLIN(  89)																	while((_g26 < _g27)){
HXDLIN(  89)																		_g26 = (_g26 + 1);
HXDLIN(  89)																		int x6 = (_g26 - 1);
HXDLIN(  89)																		{
HXDLIN(  89)																			w1 = (w1 + 1);
HXDLIN(  89)																			b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w1 = (w1 + 1);
HXDLIN(  89)																			b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w1 = (w1 + 1);
HXDLIN(  89)																			b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w1 = (w1 + 1);
HXDLIN(  89)																			b6->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage4 = b6;
            											}
            											break;
            											case (int)1: {
HXDLIN(  89)												 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN(  89)												{
HXDLIN(  89)													a7->width = width1;
HXDLIN(  89)													a7->height = height1;
HXDLIN(  89)													a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  89)													a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  89)													{
HXDLIN(  89)														int _g28 = 0;
HXDLIN(  89)														int _g29 = a7->length;
HXDLIN(  89)														while((_g28 < _g29)){
HXDLIN(  89)															_g28 = (_g28 + 1);
HXDLIN(  89)															int i10 = (_g28 - 1);
HXDLIN(  89)															a7->data[i10] = 0;
            														}
            													}
            												}
HXDLIN(  89)												undoImage4 = a7;
            											}
            											break;
            											case (int)2: {
HXDLIN(  89)												 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::U32ArrImg b7 = u32a1;
HXDLIN(  89)												{
HXDLIN(  89)													b7->width = width1;
HXDLIN(  89)													b7->height = height1;
HXDLIN(  89)													b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  89)													int size1 = (b7->length * 4);
HXDLIN(  89)													b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  89)													{
HXDLIN(  89)														int _g30 = 0;
HXDLIN(  89)														int _g31 = b7->length;
HXDLIN(  89)														while((_g30 < _g31)){
HXDLIN(  89)															_g30 = (_g30 + 1);
HXDLIN(  89)															int i11 = (_g30 - 1);
HXDLIN(  89)															{
HXDLIN(  89)																 ::haxe::io::ArrayBufferViewImpl this51 = b7->data;
HXDLIN(  89)																bool undoImage5;
HXDLIN(  89)																if ((i11 >= 0)) {
HXDLIN(  89)																	undoImage5 = (i11 < (this51->byteLength >> 2));
            																}
            																else {
HXDLIN(  89)																	undoImage5 = false;
            																}
HXDLIN(  89)																if (undoImage5) {
HXDLIN(  89)																	 ::haxe::io::Bytes _this1 = this51->bytes;
HXDLIN(  89)																	int pos1 = ((i11 << 2) + this51->byteOffset);
HXDLIN(  89)																	_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage4 = b7;
            											}
            											break;
            											case (int)3: {
HXDLIN(  89)												 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  89)												{
HXDLIN(  89)													v3->width = width1;
HXDLIN(  89)													v3->height = height1;
HXDLIN(  89)													v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  89)													v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  89)													{
HXDLIN(  89)														int _g32 = 0;
HXDLIN(  89)														int _g33 = v3->length;
HXDLIN(  89)														while((_g32 < _g33)){
HXDLIN(  89)															_g32 = (_g32 + 1);
HXDLIN(  89)															int i12 = (_g32 - 1);
HXDLIN(  89)															v3->data->__unsafe_set(i12,0);
            														}
            													}
            												}
HXDLIN(  89)												undoImage4 = v3;
            											}
            											break;
            											case (int)4: {
HXDLIN(  89)												 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN(  89)												{
HXDLIN(  89)													b8->width = width1;
HXDLIN(  89)													b8->height = height1;
HXDLIN(  89)													b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  89)													b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  89)													{
HXDLIN(  89)														int len3 = b8->length;
HXDLIN(  89)														 ::haxe::ds::GenericStack_Int d1 = b8->data;
HXDLIN(  89)														if (::hx::IsNull( d1->head )) {
HXDLIN(  89)															int _g34 = 0;
HXDLIN(  89)															int _g35 = len3;
HXDLIN(  89)															while((_g34 < _g35)){
HXDLIN(  89)																_g34 = (_g34 + 1);
HXDLIN(  89)																int i13 = (_g34 - 1);
HXDLIN(  89)																d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            															}
            														}
            														else {
HXDLIN(  89)															int _g36 = 0;
HXDLIN(  89)															int _g37 = len3;
HXDLIN(  89)															while((_g36 < _g37)){
HXDLIN(  89)																_g36 = (_g36 + 1);
HXDLIN(  89)																int i14 = (_g36 - 1);
HXDLIN(  89)																{
HXDLIN(  89)																	 ::haxe::ds::GenericCell_Int l1 = b8->data->head;
HXDLIN(  89)																	 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  89)																	{
HXDLIN(  89)																		int _g38 = 0;
HXDLIN(  89)																		int _g39 = i14;
HXDLIN(  89)																		while((_g38 < _g39)){
HXDLIN(  89)																			_g38 = (_g38 + 1);
HXDLIN(  89)																			int i15 = (_g38 - 1);
HXLINE( 345)																			prev1 = l1;
HXLINE( 346)																			l1 = l1->next;
            																		}
            																	}
HXLINE(  89)																	if (::hx::IsNull( prev1 )) {
HXDLIN(  89)																		b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  89)																		l1 = null();
            																	}
            																	else {
HXDLIN(  89)																		prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  89)																		l1 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage4 = b8;
            											}
            											break;
            										}
HXDLIN(  89)										this50->image = undoImage4;
HXDLIN(  89)										this50->width = width1;
HXDLIN(  89)										this50->height = height1;
HXDLIN(  89)										this50->imageType = ( (int)(imageType1) );
HXDLIN(  89)										undoImage3 = this50;
HXDLIN(  89)										{
HXDLIN(  89)											int rectLeft1 = xIter31->start;
HXDLIN(  89)											int rectTop1 = yIter31->start;
HXDLIN(  89)											int rectRight1 = xIter31->max;
HXDLIN(  89)											bool forceClear1 = false;
HXDLIN(  89)											{
HXDLIN(  89)												int _g40 = rectTop1;
HXDLIN(  89)												int _g41 = yIter31->max;
HXDLIN(  89)												while((_g40 < _g41)){
HXDLIN(  89)													_g40 = (_g40 + 1);
HXDLIN(  89)													int dy3 = (_g40 - 1);
HXDLIN(  89)													{
HXDLIN(  89)														int _g42 = rectLeft1;
HXDLIN(  89)														int _g43 = rectRight1;
HXDLIN(  89)														while((_g42 < _g43)){
HXDLIN(  89)															_g42 = (_g42 + 1);
HXDLIN(  89)															int dx3 = (_g42 - 1);
HXDLIN(  89)															::Dynamic this52 = this49->image;
HXDLIN(  89)															int index6;
HXDLIN(  89)															if (this49->useVirtualPos) {
HXDLIN(  89)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this49->virtualY) * ( (Float)(this49->width) )) + dx3) - this49->virtualX));
            															}
            															else {
HXDLIN(  89)																index6 = ::Std_obj::_hx_int(( (Float)(((dy3 * this49->width) + dx3)) ));
            															}
HXDLIN(  89)															int c5 = ::iterMagic::Iimg_obj::get(this52,index6);
HXDLIN(  89)															int col1;
HXDLIN(  89)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN(  89)																col1 = c5;
            															}
HXDLIN(  89)															bool _hx_tmp11;
HXDLIN(  89)															if (this49->useMask) {
HXDLIN(  89)																_hx_tmp11 = ::hx::IsNotNull( this49->mask );
            															}
            															else {
HXDLIN(  89)																_hx_tmp11 = false;
            															}
HXDLIN(  89)															if (_hx_tmp11) {
HXDLIN(  89)																 ::pi_xy::ImageStruct this53 = this49->mask;
HXDLIN(  89)																::Dynamic this54 = this53->image;
HXDLIN(  89)																int index7;
HXDLIN(  89)																if (this53->useVirtualPos) {
HXDLIN(  89)																	index7 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this53->virtualY) * ( (Float)(this53->width) )) + dx3) - this53->virtualX));
            																}
            																else {
HXDLIN(  89)																	index7 = ::Std_obj::_hx_int(( (Float)(((dy3 * this53->width) + dx3)) ));
            																}
HXDLIN(  89)																int c6 = ::iterMagic::Iimg_obj::get(this54,index7);
HXDLIN(  89)																int v4;
HXDLIN(  89)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																	v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN(  89)																	v4 = c6;
            																}
HXDLIN(  89)																int maskPixel1 = v4;
HXDLIN(  89)																int this55 = col1;
HXDLIN(  89)																if ((maskPixel1 == 0)) {
HXDLIN(  89)																	col1 = this55;
            																}
            																else {
HXDLIN(  89)																	Float m01;
HXDLIN(  89)																	int this56 = ((maskPixel1 >> 24) & 255);
HXDLIN(  89)																	if ((this56 == 0)) {
HXDLIN(  89)																		m01 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m01 = (( (Float)(this56) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m11;
HXDLIN(  89)																	int this57 = ((maskPixel1 >> 16) & 255);
HXDLIN(  89)																	if ((this57 == 0)) {
HXDLIN(  89)																		m11 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m11 = (( (Float)(this57) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m21;
HXDLIN(  89)																	int this58 = ((maskPixel1 >> 8) & 255);
HXDLIN(  89)																	if ((this58 == 0)) {
HXDLIN(  89)																		m21 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m21 = (( (Float)(this58) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m31;
HXDLIN(  89)																	int this59 = (maskPixel1 & 255);
HXDLIN(  89)																	if ((this59 == 0)) {
HXDLIN(  89)																		m31 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m31 = (( (Float)(this59) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this55 >> 24) & 255)) )));
HXDLIN(  89)																	int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this55 >> 16) & 255)) )));
HXDLIN(  89)																	int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this55 >> 8) & 255)) )));
HXDLIN(  89)																	int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this55 & 255)) )));
HXDLIN(  89)																	col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN(  89)															if ((col1 != 0)) {
HXDLIN(  89)																int x7 = (dx3 - rectLeft1);
HXDLIN(  89)																int y7 = (dy3 - rectTop1);
HXDLIN(  89)																int c7 = col1;
HXDLIN(  89)																bool _hx_tmp12;
HXDLIN(  89)																if ((((c7 >> 24) & 255) < 254)) {
HXDLIN(  89)																	_hx_tmp12 = undoImage3->transparent;
            																}
            																else {
HXDLIN(  89)																	_hx_tmp12 = false;
            																}
HXDLIN(  89)																if (_hx_tmp12) {
HXDLIN(  89)																	int location3;
HXDLIN(  89)																	if (undoImage3->useVirtualPos) {
HXDLIN(  89)																		location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		location3 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            																	}
HXDLIN(  89)																	int this60 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN(  89)																	int this61;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		this61 = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		this61 = this60;
            																	}
HXDLIN(  89)																	Float a13;
HXDLIN(  89)																	int this62 = ((this61 >> 24) & 255);
HXDLIN(  89)																	if ((this62 == 0)) {
HXDLIN(  89)																		a13 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r13;
HXDLIN(  89)																	int this63 = ((this61 >> 16) & 255);
HXDLIN(  89)																	if ((this63 == 0)) {
HXDLIN(  89)																		r13 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g13;
HXDLIN(  89)																	int this64 = ((this61 >> 8) & 255);
HXDLIN(  89)																	if ((this64 == 0)) {
HXDLIN(  89)																		g13 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g13 = (( (Float)(this64) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b14;
HXDLIN(  89)																	int this65 = (this61 & 255);
HXDLIN(  89)																	if ((this65 == 0)) {
HXDLIN(  89)																		b14 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b14 = (( (Float)(this65) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a23;
HXDLIN(  89)																	int this66 = ((col1 >> 24) & 255);
HXDLIN(  89)																	if ((this66 == 0)) {
HXDLIN(  89)																		a23 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r23;
HXDLIN(  89)																	int this67 = ((col1 >> 16) & 255);
HXDLIN(  89)																	if ((this67 == 0)) {
HXDLIN(  89)																		r23 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g23;
HXDLIN(  89)																	int this68 = ((col1 >> 8) & 255);
HXDLIN(  89)																	if ((this68 == 0)) {
HXDLIN(  89)																		g23 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g23 = (( (Float)(this68) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b24;
HXDLIN(  89)																	int this69 = (col1 & 255);
HXDLIN(  89)																	if ((this69 == 0)) {
HXDLIN(  89)																		b24 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b24 = (( (Float)(this69) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  89)																	int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  89)																	int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  89)																	int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  89)																	int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  89)																	int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  89)																	{
HXDLIN(  89)																		int _hx_tmp13;
HXDLIN(  89)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																			_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																		}
            																		else {
HXDLIN(  89)																			_hx_tmp13 = blended3;
            																		}
HXDLIN(  89)																		::iterMagic::Iimg_obj::set(undoImage3->image,location3,_hx_tmp13);
            																	}
            																}
            																else {
HXDLIN(  89)																	::Dynamic this70 = undoImage3->image;
HXDLIN(  89)																	int index8;
HXDLIN(  89)																	if (undoImage3->useVirtualPos) {
HXDLIN(  89)																		index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index8 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            																	}
HXDLIN(  89)																	int _hx_tmp14;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		_hx_tmp14 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		_hx_tmp14 = c7;
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this70,index8,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN(  89)																if (forceClear1) {
HXDLIN(  89)																	::Dynamic this71 = undoImage3->image;
HXDLIN(  89)																	int x8 = (dx3 - rectLeft1);
HXDLIN(  89)																	int y8 = (dy3 - rectTop1);
HXDLIN(  89)																	int index9;
HXDLIN(  89)																	if (undoImage3->useVirtualPos) {
HXDLIN(  89)																		index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index9 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this71,index9,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  89)									bool found1 = false;
HXDLIN(  89)									Float s1 = ((Float)0.);
HXDLIN(  89)									Float t1 = ((Float)0.);
HXDLIN(  89)									Float sxx1 = ((Float)0.);
HXDLIN(  89)									Float txx1 = ((Float)0.);
HXDLIN(  89)									{
HXDLIN(  89)										int _g_min2 = xIter31->start;
HXDLIN(  89)										int _g_max2 = xIter31->max;
HXDLIN(  89)										while((_g_min2 < _g_max2)){
HXDLIN(  89)											_g_min2 = (_g_min2 + 1);
HXDLIN(  89)											int x9 = (_g_min2 - 1);
HXLINE(  60)											sxx1 = (sx1 * ( (Float)(x9) ));
HXLINE(  61)											txx1 = (tx1 * ( (Float)(x9) ));
HXLINE(  62)											found1 = false;
HXLINE(  89)											{
HXDLIN(  89)												int _g_min3 = yIter31->start;
HXDLIN(  89)												int _g_max3 = yIter31->max;
HXDLIN(  89)												while((_g_min3 < _g_max3)){
HXDLIN(  89)													_g_min3 = (_g_min3 + 1);
HXDLIN(  89)													int y9 = (_g_min3 - 1);
HXLINE(  64)													s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y9) )));
HXLINE(  65)													t1 = ((t01 + txx1) + (ty1 * ( (Float)(y9) )));
HXLINE(  89)													bool _hx_tmp15;
HXDLIN(  89)													if (!((s1 <= 0))) {
HXDLIN(  89)														_hx_tmp15 = (t1 <= 0);
            													}
            													else {
HXDLIN(  89)														_hx_tmp15 = true;
            													}
HXDLIN(  89)													if (_hx_tmp15) {
HXDLIN(  89)														if (found1) {
HXDLIN(  89)															goto _hx_goto_104;
            														}
            													}
            													else {
HXDLIN(  89)														if (((s1 + t1) < A1)) {
HXDLIN(  89)															{
HXDLIN(  89)																int c8 = color;
HXDLIN(  89)																bool _hx_tmp16;
HXDLIN(  89)																if ((((c8 >> 24) & 255) < 254)) {
HXDLIN(  89)																	_hx_tmp16 = this49->transparent;
            																}
            																else {
HXDLIN(  89)																	_hx_tmp16 = false;
            																}
HXDLIN(  89)																if (_hx_tmp16) {
HXDLIN(  89)																	int location4;
HXDLIN(  89)																	if (this49->useVirtualPos) {
HXDLIN(  89)																		location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - this49->virtualY) * ( (Float)(this49->width) )) + x9) - this49->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		location4 = ::Std_obj::_hx_int(( (Float)(((y9 * this49->width) + x9)) ));
            																	}
HXDLIN(  89)																	int this72 = ::iterMagic::Iimg_obj::get(this49->image,location4);
HXDLIN(  89)																	int this73;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		this73 = ((((((this72 >> 24) & 255) << 24) | ((this72 & 255) << 16)) | (((this72 >> 8) & 255) << 8)) | ((this72 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		this73 = this72;
            																	}
HXDLIN(  89)																	Float a14;
HXDLIN(  89)																	int this74 = ((this73 >> 24) & 255);
HXDLIN(  89)																	if ((this74 == 0)) {
HXDLIN(  89)																		a14 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a14 = (( (Float)(this74) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r14;
HXDLIN(  89)																	int this75 = ((this73 >> 16) & 255);
HXDLIN(  89)																	if ((this75 == 0)) {
HXDLIN(  89)																		r14 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r14 = (( (Float)(this75) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g14;
HXDLIN(  89)																	int this76 = ((this73 >> 8) & 255);
HXDLIN(  89)																	if ((this76 == 0)) {
HXDLIN(  89)																		g14 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g14 = (( (Float)(this76) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b15;
HXDLIN(  89)																	int this77 = (this73 & 255);
HXDLIN(  89)																	if ((this77 == 0)) {
HXDLIN(  89)																		b15 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b15 = (( (Float)(this77) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a24;
HXDLIN(  89)																	int this78 = ((color >> 24) & 255);
HXDLIN(  89)																	if ((this78 == 0)) {
HXDLIN(  89)																		a24 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a24 = (( (Float)(this78) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r24;
HXDLIN(  89)																	int this79 = ((color >> 16) & 255);
HXDLIN(  89)																	if ((this79 == 0)) {
HXDLIN(  89)																		r24 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r24 = (( (Float)(this79) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g24;
HXDLIN(  89)																	int this80 = ((color >> 8) & 255);
HXDLIN(  89)																	if ((this80 == 0)) {
HXDLIN(  89)																		g24 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g24 = (( (Float)(this80) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b25;
HXDLIN(  89)																	int this81 = (color & 255);
HXDLIN(  89)																	if ((this81 == 0)) {
HXDLIN(  89)																		b25 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b25 = (( (Float)(this81) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  89)																	int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  89)																	int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  89)																	int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b25 * a24))));
HXDLIN(  89)																	int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  89)																	int blended4 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b10);
HXDLIN(  89)																	{
HXDLIN(  89)																		int _hx_tmp17;
HXDLIN(  89)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																			_hx_tmp17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            																		}
            																		else {
HXDLIN(  89)																			_hx_tmp17 = blended4;
            																		}
HXDLIN(  89)																		::iterMagic::Iimg_obj::set(this49->image,location4,_hx_tmp17);
            																	}
            																}
            																else {
HXDLIN(  89)																	::Dynamic this82 = this49->image;
HXDLIN(  89)																	int index10;
HXDLIN(  89)																	if (this49->useVirtualPos) {
HXDLIN(  89)																		index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - this49->virtualY) * ( (Float)(this49->width) )) + x9) - this49->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index10 = ::Std_obj::_hx_int(( (Float)(((y9 * this49->width) + x9)) ));
            																	}
HXDLIN(  89)																	int _hx_tmp18;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		_hx_tmp18 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		_hx_tmp18 = c8;
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this82,index10,_hx_tmp18);
            																}
            															}
HXLINE(  73)															found1 = true;
            														}
            														else {
HXDLIN(  89)															if (found1) {
HXDLIN(  89)																goto _hx_goto_104;
            															}
            														}
            													}
            												}
            												_hx_goto_104:;
            											}
            										}
            									}
HXDLIN(  89)									if ((hasHit1 == true)) {
HXDLIN(  89)										 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX,cy2,bx1,by1,cx2,cy3,true);
HXDLIN(  89)										if (hasUndo1) {
HXDLIN(  89)											v5->undoImage = undoImage3;
HXDLIN(  89)											v5->undoX = xIter31->start;
HXDLIN(  89)											v5->undoY = yIter31->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  46)						lastX1 = nextX1;
HXLINE(  47)						lastY1 = nextY1;
            					}
            				}
            			}
            		}
HXLINE(  89)		{
HXDLIN(  89)			int r_x1 = ::Std_obj::_hx_int(x);
HXDLIN(  89)			int r_y1 = ::Std_obj::_hx_int((y + dy1));
HXDLIN(  89)			int r_w1 = ::Std_obj::_hx_int(wid);
HXDLIN(  89)			int r_h1 = ::Std_obj::_hx_int(( (Float)(tall1) ));
HXDLIN(  89)			int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN(  89)			int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN(  89)			int ii_min18 = r_x1;
HXDLIN(  89)			int ii_max18 = xmax1;
HXDLIN(  89)			int xRange__start1 = ii_min18;
HXDLIN(  89)			int xRange__max1 = ii_max18;
HXDLIN(  89)			int ii_min19 = r_y1;
HXDLIN(  89)			int ii_max19 = ymax1;
HXDLIN(  89)			int yRange__start1 = ii_min19;
HXDLIN(  89)			int yRange__max1 = ii_max19;
HXDLIN(  89)			int range_x1 = xRange__start1;
HXDLIN(  89)			int range_y1 = (yRange__start1 - 1);
HXDLIN(  89)			int range_xReset1 = range_x1;
HXDLIN(  89)			int range_yReset1 = range_y1;
HXDLIN(  89)			int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  89)			int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  89)			int _this_min1 = 0;
HXDLIN(  89)			int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  89)			while((_this_min1 < _this_max1)){
HXDLIN(  89)				_this_min1 = (_this_min1 + 1);
HXDLIN(  89)				int i16 = (_this_min1 - 1);
HXDLIN(  89)				if ((range_y1 > range_yMax1)) {
HXDLIN(  89)					range_y1 = range_yReset1;
HXDLIN(  89)					range_x1 = (range_x1 + 1);
            				}
HXDLIN(  89)				range_y1 = (range_y1 + 1);
HXDLIN(  89)				int i17 = i16;
HXDLIN(  89)				{
HXDLIN(  89)					int x10 = range_x1;
HXDLIN(  89)					int y10 = range_y1;
HXDLIN(  89)					int c9 = color;
HXDLIN(  89)					bool _hx_tmp19;
HXDLIN(  89)					if ((((c9 >> 24) & 255) < 254)) {
HXDLIN(  89)						_hx_tmp19 = this1->transparent;
            					}
            					else {
HXDLIN(  89)						_hx_tmp19 = false;
            					}
HXDLIN(  89)					if (_hx_tmp19) {
HXDLIN(  89)						int location5;
HXDLIN(  89)						if (this1->useVirtualPos) {
HXDLIN(  89)							location5 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x10) - this1->virtualX));
            						}
            						else {
HXDLIN(  89)							location5 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x10)) ));
            						}
HXDLIN(  89)						int this83 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN(  89)						int this84;
HXDLIN(  89)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)							this84 = ((((((this83 >> 24) & 255) << 24) | ((this83 & 255) << 16)) | (((this83 >> 8) & 255) << 8)) | ((this83 >> 16) & 255));
            						}
            						else {
HXDLIN(  89)							this84 = this83;
            						}
HXDLIN(  89)						Float a15;
HXDLIN(  89)						int this85 = ((this84 >> 24) & 255);
HXDLIN(  89)						if ((this85 == 0)) {
HXDLIN(  89)							a15 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							a15 = (( (Float)(this85) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float r15;
HXDLIN(  89)						int this86 = ((this84 >> 16) & 255);
HXDLIN(  89)						if ((this86 == 0)) {
HXDLIN(  89)							r15 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							r15 = (( (Float)(this86) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float g15;
HXDLIN(  89)						int this87 = ((this84 >> 8) & 255);
HXDLIN(  89)						if ((this87 == 0)) {
HXDLIN(  89)							g15 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							g15 = (( (Float)(this87) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float b16;
HXDLIN(  89)						int this88 = (this84 & 255);
HXDLIN(  89)						if ((this88 == 0)) {
HXDLIN(  89)							b16 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							b16 = (( (Float)(this88) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float a25;
HXDLIN(  89)						int this89 = ((color >> 24) & 255);
HXDLIN(  89)						if ((this89 == 0)) {
HXDLIN(  89)							a25 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							a25 = (( (Float)(this89) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float r25;
HXDLIN(  89)						int this90 = ((color >> 16) & 255);
HXDLIN(  89)						if ((this90 == 0)) {
HXDLIN(  89)							r25 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							r25 = (( (Float)(this90) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float g25;
HXDLIN(  89)						int this91 = ((color >> 8) & 255);
HXDLIN(  89)						if ((this91 == 0)) {
HXDLIN(  89)							g25 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							g25 = (( (Float)(this91) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float b26;
HXDLIN(  89)						int this92 = (color & 255);
HXDLIN(  89)						if ((this92 == 0)) {
HXDLIN(  89)							b26 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							b26 = (( (Float)(this92) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  89)						int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  89)						int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  89)						int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a35) + (b26 * a25))));
HXDLIN(  89)						int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  89)						int blended5 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b17);
HXDLIN(  89)						{
HXDLIN(  89)							int _hx_tmp20;
HXDLIN(  89)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)								_hx_tmp20 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            							}
            							else {
HXDLIN(  89)								_hx_tmp20 = blended5;
            							}
HXDLIN(  89)							::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp20);
            						}
            					}
            					else {
HXDLIN(  89)						::Dynamic this93 = this1->image;
HXDLIN(  89)						int index11;
HXDLIN(  89)						if (this1->useVirtualPos) {
HXDLIN(  89)							index11 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x10) - this1->virtualX));
            						}
            						else {
HXDLIN(  89)							index11 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x10)) ));
            						}
HXDLIN(  89)						int _hx_tmp21;
HXDLIN(  89)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)							_hx_tmp21 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            						}
            						else {
HXDLIN(  89)							_hx_tmp21 = c9;
            						}
HXDLIN(  89)						::iterMagic::Iimg_obj::set(this93,index11,_hx_tmp21);
            					}
            				}
            			}
            		}
HXDLIN(  89)		{
HXDLIN(  89)			 ::pi_xy::ImageStruct this94 = this1;
HXDLIN(  89)			Float cx3 = (x + dx1);
HXDLIN(  89)			Float rx1 = ( (Float)(dx1) );
HXDLIN(  89)			{
HXDLIN(  89)				 ::Dynamic targetError2 = ((Float)1.05);
HXDLIN(  89)				if (::hx::IsNull( targetError2 )) {
HXLINE( 113)					targetError2 = ((Float)1.05);
            				}
HXLINE(  89)				Float rSmall2;
HXDLIN(  89)				if ((rx1 > bottomRadius)) {
HXDLIN(  89)					rSmall2 = bottomRadius;
            				}
            				else {
HXDLIN(  89)					rSmall2 = rx1;
            				}
HXDLIN(  89)				 ::Dynamic targetE2 = ( (Float)(targetError2) );
HXDLIN(  89)				if (::hx::IsNull( targetE2 )) {
HXLINE(  20)					targetE2 = ((Float)1.05);
            				}
HXLINE(  89)				int result2 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE2) ) / rSmall2)))));
HXDLIN(  89)				int noSides2;
HXDLIN(  89)				if ((result2 < 12)) {
HXDLIN(  89)					noSides2 = 12;
            				}
            				else {
HXDLIN(  89)					if ((result2 > 500)) {
HXDLIN(  89)						noSides2 = 500;
            					}
            					else {
HXDLIN(  89)						noSides2 = result2;
            					}
            				}
HXDLIN(  89)				int sides2 = (::Math_obj::ceil((( (Float)(noSides2) ) / ( (Float)(4) ))) * 4);
HXDLIN(  89)				Float theta2 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides2) ));
HXDLIN(  89)				Float omega2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  89)				int quarter2 = ::Std_obj::_hx_int((( (Float)(sides2) ) / ( (Float)(4) )));
HXDLIN(  89)				Float lastX2 = ((Float)0.);
HXDLIN(  89)				Float lastY2 = ((Float)0.);
HXDLIN(  89)				{
HXLINE(  26)					lastX2 = (cx3 + (rx1 * ::Math_obj::cos(((( (Float)(sides2) ) * theta2) + omega2))));
HXLINE(  27)					lastY2 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides2) ) * theta2) + omega2))));
            				}
HXLINE(  89)				{
HXDLIN(  89)					int _g44 = 0;
HXDLIN(  89)					int _g45 = (quarter2 + 1);
HXDLIN(  89)					while((_g44 < _g45)){
HXDLIN(  89)						_g44 = (_g44 + 1);
HXDLIN(  89)						int i18 = (_g44 - 1);
HXDLIN(  89)						Float nextX2 = (cx3 + (rx1 * ::Math_obj::cos((((( (Float)(i18) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  89)						Float nextY2 = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i18) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN(  89)						{
HXDLIN(  89)							 ::pi_xy::ImageStruct this95 = this94;
HXDLIN(  89)							bool hasHit2 = false;
HXDLIN(  89)							bool hasUndo2 = false;
HXDLIN(  89)							{
HXDLIN(  89)								Float bx2 = lastX2;
HXDLIN(  89)								Float by2 = lastY2;
HXDLIN(  89)								Float cx4 = nextX2;
HXDLIN(  89)								Float cy4 = nextY2;
HXDLIN(  89)								bool adjustWinding2 = (((((cx3 * by2) - (bx2 * lowerY)) + ((bx2 * cy4) - (cx4 * by2))) + ((cx4 * lowerY) - (cx3 * cy4))) > 0);
HXDLIN(  89)								if (!(adjustWinding2)) {
HXDLIN(  89)									Float bx_2 = bx2;
HXDLIN(  89)									Float by_2 = by2;
HXLINE(  25)									bx2 = cx4;
HXLINE(  26)									by2 = cy4;
HXLINE(  27)									cx4 = bx_2;
HXLINE(  28)									cy4 = by_2;
            								}
HXLINE(  89)								{
HXDLIN(  89)									Float s02 = ((lowerY * cx4) - (cx3 * cy4));
HXDLIN(  89)									Float sx2 = (cy4 - lowerY);
HXDLIN(  89)									Float sy2 = (cx3 - cx4);
HXDLIN(  89)									Float t02 = ((cx3 * by2) - (lowerY * bx2));
HXDLIN(  89)									Float tx2 = (lowerY - by2);
HXDLIN(  89)									Float ty2 = (bx2 - cx3);
HXDLIN(  89)									Float A2 = ((((-(by2) * cx4) + (lowerY * (-(bx2) + cx4))) + (cx3 * (by2 - cy4))) + (bx2 * cy4));
HXDLIN(  89)									 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  89)									if ((cx3 > bx2)) {
HXDLIN(  89)										if ((cx3 > cx4)) {
HXDLIN(  89)											int min8;
HXDLIN(  89)											if ((bx2 > cx4)) {
HXDLIN(  89)												min8 = ::Math_obj::floor(cx4);
            											}
            											else {
HXDLIN(  89)												min8 = ::Math_obj::floor(bx2);
            											}
HXDLIN(  89)											int ii_min20 = min8;
HXDLIN(  89)											int ii_max20 = ::Math_obj::ceil(cx3);
HXDLIN(  89)											xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            										}
            										else {
HXDLIN(  89)											int ii_min21 = ::Math_obj::floor(bx2);
HXDLIN(  89)											int ii_max21 = ::Math_obj::ceil(cx4);
HXDLIN(  89)											xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            										}
            									}
            									else {
HXDLIN(  89)										if ((bx2 > cx4)) {
HXDLIN(  89)											int min9;
HXDLIN(  89)											if ((cx3 > cx4)) {
HXDLIN(  89)												min9 = ::Math_obj::floor(cx4);
            											}
            											else {
HXDLIN(  89)												min9 = ::Math_obj::ceil(cx3);
            											}
HXDLIN(  89)											int ii_min22 = min9;
HXDLIN(  89)											int ii_max22 = ::Math_obj::ceil(bx2);
HXDLIN(  89)											xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            										}
            										else {
HXDLIN(  89)											int ii_min23 = ::Math_obj::floor(cx3);
HXDLIN(  89)											int ii_max23 = ::Math_obj::ceil(cx4);
HXDLIN(  89)											xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            										}
            									}
HXDLIN(  89)									 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  89)									if ((lowerY > by2)) {
HXDLIN(  89)										if ((lowerY > cy4)) {
HXDLIN(  89)											int min10;
HXDLIN(  89)											if ((by2 > cy4)) {
HXDLIN(  89)												min10 = ::Math_obj::floor(cy4);
            											}
            											else {
HXDLIN(  89)												min10 = ::Math_obj::floor(by2);
            											}
HXDLIN(  89)											int ii_min24 = min10;
HXDLIN(  89)											int ii_max24 = ::Math_obj::ceil(lowerY);
HXDLIN(  89)											yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            										}
            										else {
HXDLIN(  89)											int ii_min25 = ::Math_obj::floor(by2);
HXDLIN(  89)											int ii_max25 = ::Math_obj::ceil(cy4);
HXDLIN(  89)											yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            										}
            									}
            									else {
HXDLIN(  89)										if ((by2 > cy4)) {
HXDLIN(  89)											int min11;
HXDLIN(  89)											if ((lowerY > cy4)) {
HXDLIN(  89)												min11 = ::Math_obj::floor(cy4);
            											}
            											else {
HXDLIN(  89)												min11 = ::Math_obj::ceil(lowerY);
            											}
HXDLIN(  89)											int ii_min26 = min11;
HXDLIN(  89)											int ii_max26 = ::Math_obj::ceil(by2);
HXDLIN(  89)											yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            										}
            										else {
HXDLIN(  89)											int ii_min27 = ::Math_obj::floor(lowerY);
HXDLIN(  89)											int ii_max27 = ::Math_obj::ceil(cy4);
HXDLIN(  89)											yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            										}
            									}
HXDLIN(  89)									 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  89)									if (hasUndo2) {
HXDLIN(  89)										int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  89)										int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  89)										 ::Dynamic imageType2 = null();
HXDLIN(  89)										 ::pi_xy::ImageStruct this96 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  89)										if (::hx::IsNull( imageType2 )) {
HXLINE(  54)											imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE(  89)										::Dynamic undoImage7;
HXDLIN(  89)										switch((int)(( (int)(imageType2) ))){
            											case (int)0: {
HXDLIN(  89)												 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::BytesImg b18 = byt2;
HXDLIN(  89)												{
HXDLIN(  89)													b18->width = width2;
HXDLIN(  89)													b18->height = height2;
HXDLIN(  89)													b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  89)													b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN(  89)													{
HXDLIN(  89)														int len4 = b18->length;
HXDLIN(  89)														int w2 = 0;
HXDLIN(  89)														{
HXDLIN(  89)															int _g46 = 0;
HXDLIN(  89)															int _g47 = b18->height;
HXDLIN(  89)															while((_g46 < _g47)){
HXDLIN(  89)																_g46 = (_g46 + 1);
HXDLIN(  89)																int y11 = (_g46 - 1);
HXDLIN(  89)																{
HXDLIN(  89)																	int _g48 = 0;
HXDLIN(  89)																	int _g49 = b18->width;
HXDLIN(  89)																	while((_g48 < _g49)){
HXDLIN(  89)																		_g48 = (_g48 + 1);
HXDLIN(  89)																		int x11 = (_g48 - 1);
HXDLIN(  89)																		{
HXDLIN(  89)																			w2 = (w2 + 1);
HXDLIN(  89)																			b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w2 = (w2 + 1);
HXDLIN(  89)																			b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w2 = (w2 + 1);
HXDLIN(  89)																			b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w2 = (w2 + 1);
HXDLIN(  89)																			b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage7 = b18;
            											}
            											break;
            											case (int)1: {
HXDLIN(  89)												 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::ArrIntImg a16 = arrI2;
HXDLIN(  89)												{
HXDLIN(  89)													a16->width = width2;
HXDLIN(  89)													a16->height = height2;
HXDLIN(  89)													a16->data = ::Array_obj< int >::__new(0);
HXDLIN(  89)													a16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  89)													{
HXDLIN(  89)														int _g50 = 0;
HXDLIN(  89)														int _g51 = a16->length;
HXDLIN(  89)														while((_g50 < _g51)){
HXDLIN(  89)															_g50 = (_g50 + 1);
HXDLIN(  89)															int i19 = (_g50 - 1);
HXDLIN(  89)															a16->data[i19] = 0;
            														}
            													}
            												}
HXDLIN(  89)												undoImage7 = a16;
            											}
            											break;
            											case (int)2: {
HXDLIN(  89)												 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::U32ArrImg b19 = u32a2;
HXDLIN(  89)												{
HXDLIN(  89)													b19->width = width2;
HXDLIN(  89)													b19->height = height2;
HXDLIN(  89)													b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  89)													int size2 = (b19->length * 4);
HXDLIN(  89)													b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  89)													{
HXDLIN(  89)														int _g52 = 0;
HXDLIN(  89)														int _g53 = b19->length;
HXDLIN(  89)														while((_g52 < _g53)){
HXDLIN(  89)															_g52 = (_g52 + 1);
HXDLIN(  89)															int i20 = (_g52 - 1);
HXDLIN(  89)															{
HXDLIN(  89)																 ::haxe::io::ArrayBufferViewImpl this97 = b19->data;
HXDLIN(  89)																bool undoImage8;
HXDLIN(  89)																if ((i20 >= 0)) {
HXDLIN(  89)																	undoImage8 = (i20 < (this97->byteLength >> 2));
            																}
            																else {
HXDLIN(  89)																	undoImage8 = false;
            																}
HXDLIN(  89)																if (undoImage8) {
HXDLIN(  89)																	 ::haxe::io::Bytes _this2 = this97->bytes;
HXDLIN(  89)																	int pos2 = ((i20 << 2) + this97->byteOffset);
HXDLIN(  89)																	_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage7 = b19;
            											}
            											break;
            											case (int)3: {
HXDLIN(  89)												 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN(  89)												{
HXDLIN(  89)													v6->width = width2;
HXDLIN(  89)													v6->height = height2;
HXDLIN(  89)													v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  89)													v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN(  89)													{
HXDLIN(  89)														int _g54 = 0;
HXDLIN(  89)														int _g55 = v6->length;
HXDLIN(  89)														while((_g54 < _g55)){
HXDLIN(  89)															_g54 = (_g54 + 1);
HXDLIN(  89)															int i21 = (_g54 - 1);
HXDLIN(  89)															v6->data->__unsafe_set(i21,0);
            														}
            													}
            												}
HXDLIN(  89)												undoImage7 = v6;
            											}
            											break;
            											case (int)4: {
HXDLIN(  89)												 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::StackIntImg b20 = sInt2;
HXDLIN(  89)												{
HXDLIN(  89)													b20->width = width2;
HXDLIN(  89)													b20->height = height2;
HXDLIN(  89)													b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  89)													b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  89)													{
HXDLIN(  89)														int len5 = b20->length;
HXDLIN(  89)														 ::haxe::ds::GenericStack_Int d2 = b20->data;
HXDLIN(  89)														if (::hx::IsNull( d2->head )) {
HXDLIN(  89)															int _g56 = 0;
HXDLIN(  89)															int _g57 = len5;
HXDLIN(  89)															while((_g56 < _g57)){
HXDLIN(  89)																_g56 = (_g56 + 1);
HXDLIN(  89)																int i22 = (_g56 - 1);
HXDLIN(  89)																d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            															}
            														}
            														else {
HXDLIN(  89)															int _g58 = 0;
HXDLIN(  89)															int _g59 = len5;
HXDLIN(  89)															while((_g58 < _g59)){
HXDLIN(  89)																_g58 = (_g58 + 1);
HXDLIN(  89)																int i23 = (_g58 - 1);
HXDLIN(  89)																{
HXDLIN(  89)																	 ::haxe::ds::GenericCell_Int l2 = b20->data->head;
HXDLIN(  89)																	 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  89)																	{
HXDLIN(  89)																		int _g60 = 0;
HXDLIN(  89)																		int _g61 = i23;
HXDLIN(  89)																		while((_g60 < _g61)){
HXDLIN(  89)																			_g60 = (_g60 + 1);
HXDLIN(  89)																			int i24 = (_g60 - 1);
HXLINE( 345)																			prev2 = l2;
HXLINE( 346)																			l2 = l2->next;
            																		}
            																	}
HXLINE(  89)																	if (::hx::IsNull( prev2 )) {
HXDLIN(  89)																		b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  89)																		l2 = null();
            																	}
            																	else {
HXDLIN(  89)																		prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  89)																		l2 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage7 = b20;
            											}
            											break;
            										}
HXDLIN(  89)										this96->image = undoImage7;
HXDLIN(  89)										this96->width = width2;
HXDLIN(  89)										this96->height = height2;
HXDLIN(  89)										this96->imageType = ( (int)(imageType2) );
HXDLIN(  89)										undoImage6 = this96;
HXDLIN(  89)										{
HXDLIN(  89)											int rectLeft2 = xIter32->start;
HXDLIN(  89)											int rectTop2 = yIter32->start;
HXDLIN(  89)											int rectRight2 = xIter32->max;
HXDLIN(  89)											bool forceClear2 = false;
HXDLIN(  89)											{
HXDLIN(  89)												int _g62 = rectTop2;
HXDLIN(  89)												int _g63 = yIter32->max;
HXDLIN(  89)												while((_g62 < _g63)){
HXDLIN(  89)													_g62 = (_g62 + 1);
HXDLIN(  89)													int dy4 = (_g62 - 1);
HXDLIN(  89)													{
HXDLIN(  89)														int _g64 = rectLeft2;
HXDLIN(  89)														int _g65 = rectRight2;
HXDLIN(  89)														while((_g64 < _g65)){
HXDLIN(  89)															_g64 = (_g64 + 1);
HXDLIN(  89)															int dx4 = (_g64 - 1);
HXDLIN(  89)															::Dynamic this98 = this95->image;
HXDLIN(  89)															int index12;
HXDLIN(  89)															if (this95->useVirtualPos) {
HXDLIN(  89)																index12 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this95->virtualY) * ( (Float)(this95->width) )) + dx4) - this95->virtualX));
            															}
            															else {
HXDLIN(  89)																index12 = ::Std_obj::_hx_int(( (Float)(((dy4 * this95->width) + dx4)) ));
            															}
HXDLIN(  89)															int c10 = ::iterMagic::Iimg_obj::get(this98,index12);
HXDLIN(  89)															int col2;
HXDLIN(  89)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																col2 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            															}
            															else {
HXDLIN(  89)																col2 = c10;
            															}
HXDLIN(  89)															bool _hx_tmp22;
HXDLIN(  89)															if (this95->useMask) {
HXDLIN(  89)																_hx_tmp22 = ::hx::IsNotNull( this95->mask );
            															}
            															else {
HXDLIN(  89)																_hx_tmp22 = false;
            															}
HXDLIN(  89)															if (_hx_tmp22) {
HXDLIN(  89)																 ::pi_xy::ImageStruct this99 = this95->mask;
HXDLIN(  89)																::Dynamic this100 = this99->image;
HXDLIN(  89)																int index13;
HXDLIN(  89)																if (this99->useVirtualPos) {
HXDLIN(  89)																	index13 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this99->virtualY) * ( (Float)(this99->width) )) + dx4) - this99->virtualX));
            																}
            																else {
HXDLIN(  89)																	index13 = ::Std_obj::_hx_int(( (Float)(((dy4 * this99->width) + dx4)) ));
            																}
HXDLIN(  89)																int c11 = ::iterMagic::Iimg_obj::get(this100,index13);
HXDLIN(  89)																int v7;
HXDLIN(  89)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																	v7 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            																}
            																else {
HXDLIN(  89)																	v7 = c11;
            																}
HXDLIN(  89)																int maskPixel2 = v7;
HXDLIN(  89)																int this101 = col2;
HXDLIN(  89)																if ((maskPixel2 == 0)) {
HXDLIN(  89)																	col2 = this101;
            																}
            																else {
HXDLIN(  89)																	Float m02;
HXDLIN(  89)																	int this102 = ((maskPixel2 >> 24) & 255);
HXDLIN(  89)																	if ((this102 == 0)) {
HXDLIN(  89)																		m02 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m02 = (( (Float)(this102) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m12;
HXDLIN(  89)																	int this103 = ((maskPixel2 >> 16) & 255);
HXDLIN(  89)																	if ((this103 == 0)) {
HXDLIN(  89)																		m12 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m12 = (( (Float)(this103) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m22;
HXDLIN(  89)																	int this104 = ((maskPixel2 >> 8) & 255);
HXDLIN(  89)																	if ((this104 == 0)) {
HXDLIN(  89)																		m22 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m22 = (( (Float)(this104) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m32;
HXDLIN(  89)																	int this105 = (maskPixel2 & 255);
HXDLIN(  89)																	if ((this105 == 0)) {
HXDLIN(  89)																		m32 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m32 = (( (Float)(this105) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this101 >> 24) & 255)) )));
HXDLIN(  89)																	int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this101 >> 16) & 255)) )));
HXDLIN(  89)																	int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this101 >> 8) & 255)) )));
HXDLIN(  89)																	int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this101 & 255)) )));
HXDLIN(  89)																	col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN(  89)															if ((col2 != 0)) {
HXDLIN(  89)																int x12 = (dx4 - rectLeft2);
HXDLIN(  89)																int y12 = (dy4 - rectTop2);
HXDLIN(  89)																int c12 = col2;
HXDLIN(  89)																bool _hx_tmp23;
HXDLIN(  89)																if ((((c12 >> 24) & 255) < 254)) {
HXDLIN(  89)																	_hx_tmp23 = undoImage6->transparent;
            																}
            																else {
HXDLIN(  89)																	_hx_tmp23 = false;
            																}
HXDLIN(  89)																if (_hx_tmp23) {
HXDLIN(  89)																	int location6;
HXDLIN(  89)																	if (undoImage6->useVirtualPos) {
HXDLIN(  89)																		location6 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x12) - undoImage6->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		location6 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage6->width) + x12)) ));
            																	}
HXDLIN(  89)																	int this106 = ::iterMagic::Iimg_obj::get(undoImage6->image,location6);
HXDLIN(  89)																	int this107;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		this107 = ((((((this106 >> 24) & 255) << 24) | ((this106 & 255) << 16)) | (((this106 >> 8) & 255) << 8)) | ((this106 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		this107 = this106;
            																	}
HXDLIN(  89)																	Float a17;
HXDLIN(  89)																	int this108 = ((this107 >> 24) & 255);
HXDLIN(  89)																	if ((this108 == 0)) {
HXDLIN(  89)																		a17 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a17 = (( (Float)(this108) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r16;
HXDLIN(  89)																	int this109 = ((this107 >> 16) & 255);
HXDLIN(  89)																	if ((this109 == 0)) {
HXDLIN(  89)																		r16 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r16 = (( (Float)(this109) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g16;
HXDLIN(  89)																	int this110 = ((this107 >> 8) & 255);
HXDLIN(  89)																	if ((this110 == 0)) {
HXDLIN(  89)																		g16 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g16 = (( (Float)(this110) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b110;
HXDLIN(  89)																	int this111 = (this107 & 255);
HXDLIN(  89)																	if ((this111 == 0)) {
HXDLIN(  89)																		b110 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b110 = (( (Float)(this111) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a26;
HXDLIN(  89)																	int this112 = ((col2 >> 24) & 255);
HXDLIN(  89)																	if ((this112 == 0)) {
HXDLIN(  89)																		a26 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a26 = (( (Float)(this112) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r26;
HXDLIN(  89)																	int this113 = ((col2 >> 16) & 255);
HXDLIN(  89)																	if ((this113 == 0)) {
HXDLIN(  89)																		r26 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r26 = (( (Float)(this113) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g26;
HXDLIN(  89)																	int this114 = ((col2 >> 8) & 255);
HXDLIN(  89)																	if ((this114 == 0)) {
HXDLIN(  89)																		g26 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g26 = (( (Float)(this114) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b27;
HXDLIN(  89)																	int this115 = (col2 & 255);
HXDLIN(  89)																	if ((this115 == 0)) {
HXDLIN(  89)																		b27 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b27 = (( (Float)(this115) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN(  89)																	int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  89)																	int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  89)																	int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b27 * a26))));
HXDLIN(  89)																	int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  89)																	int blended6 = ((((a18 << 24) | (r8 << 16)) | (g8 << 8)) | b28);
HXDLIN(  89)																	{
HXDLIN(  89)																		int _hx_tmp24;
HXDLIN(  89)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																			_hx_tmp24 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            																		}
            																		else {
HXDLIN(  89)																			_hx_tmp24 = blended6;
            																		}
HXDLIN(  89)																		::iterMagic::Iimg_obj::set(undoImage6->image,location6,_hx_tmp24);
            																	}
            																}
            																else {
HXDLIN(  89)																	::Dynamic this116 = undoImage6->image;
HXDLIN(  89)																	int index14;
HXDLIN(  89)																	if (undoImage6->useVirtualPos) {
HXDLIN(  89)																		index14 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x12) - undoImage6->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index14 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage6->width) + x12)) ));
            																	}
HXDLIN(  89)																	int _hx_tmp25;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		_hx_tmp25 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		_hx_tmp25 = c12;
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this116,index14,_hx_tmp25);
            																}
            															}
            															else {
HXDLIN(  89)																if (forceClear2) {
HXDLIN(  89)																	::Dynamic this117 = undoImage6->image;
HXDLIN(  89)																	int x13 = (dx4 - rectLeft2);
HXDLIN(  89)																	int y13 = (dy4 - rectTop2);
HXDLIN(  89)																	int index15;
HXDLIN(  89)																	if (undoImage6->useVirtualPos) {
HXDLIN(  89)																		index15 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x13) - undoImage6->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index15 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage6->width) + x13)) ));
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this117,index15,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  89)									bool found2 = false;
HXDLIN(  89)									Float s2 = ((Float)0.);
HXDLIN(  89)									Float t2 = ((Float)0.);
HXDLIN(  89)									Float sxx2 = ((Float)0.);
HXDLIN(  89)									Float txx2 = ((Float)0.);
HXDLIN(  89)									{
HXDLIN(  89)										int _g_min4 = xIter32->start;
HXDLIN(  89)										int _g_max4 = xIter32->max;
HXDLIN(  89)										while((_g_min4 < _g_max4)){
HXDLIN(  89)											_g_min4 = (_g_min4 + 1);
HXDLIN(  89)											int x14 = (_g_min4 - 1);
HXLINE(  60)											sxx2 = (sx2 * ( (Float)(x14) ));
HXLINE(  61)											txx2 = (tx2 * ( (Float)(x14) ));
HXLINE(  62)											found2 = false;
HXLINE(  89)											{
HXDLIN(  89)												int _g_min5 = yIter32->start;
HXDLIN(  89)												int _g_max5 = yIter32->max;
HXDLIN(  89)												while((_g_min5 < _g_max5)){
HXDLIN(  89)													_g_min5 = (_g_min5 + 1);
HXDLIN(  89)													int y14 = (_g_min5 - 1);
HXLINE(  64)													s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y14) )));
HXLINE(  65)													t2 = ((t02 + txx2) + (ty2 * ( (Float)(y14) )));
HXLINE(  89)													bool _hx_tmp26;
HXDLIN(  89)													if (!((s2 <= 0))) {
HXDLIN(  89)														_hx_tmp26 = (t2 <= 0);
            													}
            													else {
HXDLIN(  89)														_hx_tmp26 = true;
            													}
HXDLIN(  89)													if (_hx_tmp26) {
HXDLIN(  89)														if (found2) {
HXDLIN(  89)															goto _hx_goto_118;
            														}
            													}
            													else {
HXDLIN(  89)														if (((s2 + t2) < A2)) {
HXDLIN(  89)															{
HXDLIN(  89)																int c13 = color;
HXDLIN(  89)																bool _hx_tmp27;
HXDLIN(  89)																if ((((c13 >> 24) & 255) < 254)) {
HXDLIN(  89)																	_hx_tmp27 = this95->transparent;
            																}
            																else {
HXDLIN(  89)																	_hx_tmp27 = false;
            																}
HXDLIN(  89)																if (_hx_tmp27) {
HXDLIN(  89)																	int location7;
HXDLIN(  89)																	if (this95->useVirtualPos) {
HXDLIN(  89)																		location7 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - this95->virtualY) * ( (Float)(this95->width) )) + x14) - this95->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		location7 = ::Std_obj::_hx_int(( (Float)(((y14 * this95->width) + x14)) ));
            																	}
HXDLIN(  89)																	int this118 = ::iterMagic::Iimg_obj::get(this95->image,location7);
HXDLIN(  89)																	int this119;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		this119 = ((((((this118 >> 24) & 255) << 24) | ((this118 & 255) << 16)) | (((this118 >> 8) & 255) << 8)) | ((this118 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		this119 = this118;
            																	}
HXDLIN(  89)																	Float a19;
HXDLIN(  89)																	int this120 = ((this119 >> 24) & 255);
HXDLIN(  89)																	if ((this120 == 0)) {
HXDLIN(  89)																		a19 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a19 = (( (Float)(this120) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r17;
HXDLIN(  89)																	int this121 = ((this119 >> 16) & 255);
HXDLIN(  89)																	if ((this121 == 0)) {
HXDLIN(  89)																		r17 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r17 = (( (Float)(this121) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g17;
HXDLIN(  89)																	int this122 = ((this119 >> 8) & 255);
HXDLIN(  89)																	if ((this122 == 0)) {
HXDLIN(  89)																		g17 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g17 = (( (Float)(this122) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b111;
HXDLIN(  89)																	int this123 = (this119 & 255);
HXDLIN(  89)																	if ((this123 == 0)) {
HXDLIN(  89)																		b111 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b111 = (( (Float)(this123) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a27;
HXDLIN(  89)																	int this124 = ((color >> 24) & 255);
HXDLIN(  89)																	if ((this124 == 0)) {
HXDLIN(  89)																		a27 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a27 = (( (Float)(this124) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r27;
HXDLIN(  89)																	int this125 = ((color >> 16) & 255);
HXDLIN(  89)																	if ((this125 == 0)) {
HXDLIN(  89)																		r27 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r27 = (( (Float)(this125) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g27;
HXDLIN(  89)																	int this126 = ((color >> 8) & 255);
HXDLIN(  89)																	if ((this126 == 0)) {
HXDLIN(  89)																		g27 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g27 = (( (Float)(this126) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b29;
HXDLIN(  89)																	int this127 = (color & 255);
HXDLIN(  89)																	if ((this127 == 0)) {
HXDLIN(  89)																		b29 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b29 = (( (Float)(this127) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a37 = (a19 * (( (Float)(1) ) - a27));
HXDLIN(  89)																	int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  89)																	int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  89)																	int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b29 * a27))));
HXDLIN(  89)																	int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  89)																	int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b30);
HXDLIN(  89)																	{
HXDLIN(  89)																		int _hx_tmp28;
HXDLIN(  89)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																			_hx_tmp28 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																		}
            																		else {
HXDLIN(  89)																			_hx_tmp28 = blended7;
            																		}
HXDLIN(  89)																		::iterMagic::Iimg_obj::set(this95->image,location7,_hx_tmp28);
            																	}
            																}
            																else {
HXDLIN(  89)																	::Dynamic this128 = this95->image;
HXDLIN(  89)																	int index16;
HXDLIN(  89)																	if (this95->useVirtualPos) {
HXDLIN(  89)																		index16 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - this95->virtualY) * ( (Float)(this95->width) )) + x14) - this95->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index16 = ::Std_obj::_hx_int(( (Float)(((y14 * this95->width) + x14)) ));
            																	}
HXDLIN(  89)																	int _hx_tmp29;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		_hx_tmp29 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		_hx_tmp29 = c13;
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this128,index16,_hx_tmp29);
            																}
            															}
HXLINE(  73)															found2 = true;
            														}
            														else {
HXDLIN(  89)															if (found2) {
HXDLIN(  89)																goto _hx_goto_118;
            															}
            														}
            													}
            												}
            												_hx_goto_118:;
            											}
            										}
            									}
HXDLIN(  89)									if ((hasHit2 == true)) {
HXDLIN(  89)										 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx3,lowerY,bx2,by2,cx4,cy4,true);
HXDLIN(  89)										if (hasUndo2) {
HXDLIN(  89)											v8->undoImage = undoImage6;
HXDLIN(  89)											v8->undoX = xIter32->start;
HXDLIN(  89)											v8->undoY = yIter32->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  46)						lastX2 = nextX2;
HXLINE(  47)						lastY2 = nextY2;
            					}
            				}
            			}
            		}
HXLINE(  89)		{
HXDLIN(  89)			int r_x2 = ::Std_obj::_hx_int((x + dx1));
HXDLIN(  89)			int r_y2 = ::Std_obj::_hx_int(lowerY);
HXDLIN(  89)			int r_w2 = ::Std_obj::_hx_int(( (Float)(fat1) ));
HXDLIN(  89)			int r_h2 = ::Std_obj::_hx_int(bottomRadius);
HXDLIN(  89)			int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN(  89)			int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN(  89)			int ii_min28 = r_x2;
HXDLIN(  89)			int ii_max28 = xmax2;
HXDLIN(  89)			int xRange__start2 = ii_min28;
HXDLIN(  89)			int xRange__max2 = ii_max28;
HXDLIN(  89)			int ii_min29 = r_y2;
HXDLIN(  89)			int ii_max29 = ymax2;
HXDLIN(  89)			int yRange__start2 = ii_min29;
HXDLIN(  89)			int yRange__max2 = ii_max29;
HXDLIN(  89)			int range_x2 = xRange__start2;
HXDLIN(  89)			int range_y2 = (yRange__start2 - 1);
HXDLIN(  89)			int range_xReset2 = range_x2;
HXDLIN(  89)			int range_yReset2 = range_y2;
HXDLIN(  89)			int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  89)			int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  89)			int _this_min2 = 0;
HXDLIN(  89)			int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  89)			while((_this_min2 < _this_max2)){
HXDLIN(  89)				_this_min2 = (_this_min2 + 1);
HXDLIN(  89)				int i25 = (_this_min2 - 1);
HXDLIN(  89)				if ((range_y2 > range_yMax2)) {
HXDLIN(  89)					range_y2 = range_yReset2;
HXDLIN(  89)					range_x2 = (range_x2 + 1);
            				}
HXDLIN(  89)				range_y2 = (range_y2 + 1);
HXDLIN(  89)				int i26 = i25;
HXDLIN(  89)				{
HXDLIN(  89)					int x15 = range_x2;
HXDLIN(  89)					int y15 = range_y2;
HXDLIN(  89)					int c14 = color;
HXDLIN(  89)					bool _hx_tmp30;
HXDLIN(  89)					if ((((c14 >> 24) & 255) < 254)) {
HXDLIN(  89)						_hx_tmp30 = this1->transparent;
            					}
            					else {
HXDLIN(  89)						_hx_tmp30 = false;
            					}
HXDLIN(  89)					if (_hx_tmp30) {
HXDLIN(  89)						int location8;
HXDLIN(  89)						if (this1->useVirtualPos) {
HXDLIN(  89)							location8 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            						}
            						else {
HXDLIN(  89)							location8 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            						}
HXDLIN(  89)						int this129 = ::iterMagic::Iimg_obj::get(this1->image,location8);
HXDLIN(  89)						int this130;
HXDLIN(  89)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)							this130 = ((((((this129 >> 24) & 255) << 24) | ((this129 & 255) << 16)) | (((this129 >> 8) & 255) << 8)) | ((this129 >> 16) & 255));
            						}
            						else {
HXDLIN(  89)							this130 = this129;
            						}
HXDLIN(  89)						Float a110;
HXDLIN(  89)						int this131 = ((this130 >> 24) & 255);
HXDLIN(  89)						if ((this131 == 0)) {
HXDLIN(  89)							a110 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							a110 = (( (Float)(this131) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float r18;
HXDLIN(  89)						int this132 = ((this130 >> 16) & 255);
HXDLIN(  89)						if ((this132 == 0)) {
HXDLIN(  89)							r18 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							r18 = (( (Float)(this132) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float g18;
HXDLIN(  89)						int this133 = ((this130 >> 8) & 255);
HXDLIN(  89)						if ((this133 == 0)) {
HXDLIN(  89)							g18 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							g18 = (( (Float)(this133) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float b112;
HXDLIN(  89)						int this134 = (this130 & 255);
HXDLIN(  89)						if ((this134 == 0)) {
HXDLIN(  89)							b112 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							b112 = (( (Float)(this134) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float a28;
HXDLIN(  89)						int this135 = ((color >> 24) & 255);
HXDLIN(  89)						if ((this135 == 0)) {
HXDLIN(  89)							a28 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							a28 = (( (Float)(this135) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float r28;
HXDLIN(  89)						int this136 = ((color >> 16) & 255);
HXDLIN(  89)						if ((this136 == 0)) {
HXDLIN(  89)							r28 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							r28 = (( (Float)(this136) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float g28;
HXDLIN(  89)						int this137 = ((color >> 8) & 255);
HXDLIN(  89)						if ((this137 == 0)) {
HXDLIN(  89)							g28 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							g28 = (( (Float)(this137) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float b210;
HXDLIN(  89)						int this138 = (color & 255);
HXDLIN(  89)						if ((this138 == 0)) {
HXDLIN(  89)							b210 = ((Float)0.);
            						}
            						else {
HXDLIN(  89)							b210 = (( (Float)(this138) ) / ( (Float)(255) ));
            						}
HXDLIN(  89)						Float a38 = (a110 * (( (Float)(1) ) - a28));
HXDLIN(  89)						int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN(  89)						int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN(  89)						int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a38) + (b210 * a28))));
HXDLIN(  89)						int a29 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN(  89)						int blended8 = ((((a29 << 24) | (r10 << 16)) | (g10 << 8)) | b31);
HXDLIN(  89)						{
HXDLIN(  89)							int _hx_tmp31;
HXDLIN(  89)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)								_hx_tmp31 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            							}
            							else {
HXDLIN(  89)								_hx_tmp31 = blended8;
            							}
HXDLIN(  89)							::iterMagic::Iimg_obj::set(this1->image,location8,_hx_tmp31);
            						}
            					}
            					else {
HXDLIN(  89)						::Dynamic this139 = this1->image;
HXDLIN(  89)						int index17;
HXDLIN(  89)						if (this1->useVirtualPos) {
HXDLIN(  89)							index17 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            						}
            						else {
HXDLIN(  89)							index17 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            						}
HXDLIN(  89)						int _hx_tmp32;
HXDLIN(  89)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)							_hx_tmp32 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            						}
            						else {
HXDLIN(  89)							_hx_tmp32 = c14;
            						}
HXDLIN(  89)						::iterMagic::Iimg_obj::set(this139,index17,_hx_tmp32);
            					}
            				}
            			}
            		}
HXDLIN(  89)		{
HXDLIN(  89)			 ::pi_xy::ImageStruct this140 = this1;
HXDLIN(  89)			{
HXDLIN(  89)				 ::Dynamic targetError3 = ((Float)1.05);
HXDLIN(  89)				if (::hx::IsNull( targetError3 )) {
HXLINE( 113)					targetError3 = ((Float)1.05);
            				}
HXLINE(  89)				Float rSmall3;
HXDLIN(  89)				if ((rightRadius > bottomRadius)) {
HXDLIN(  89)					rSmall3 = bottomRadius;
            				}
            				else {
HXDLIN(  89)					rSmall3 = rightRadius;
            				}
HXDLIN(  89)				 ::Dynamic targetE3 = ( (Float)(targetError3) );
HXDLIN(  89)				if (::hx::IsNull( targetE3 )) {
HXLINE(  20)					targetE3 = ((Float)1.05);
            				}
HXLINE(  89)				int result3 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE3) ) / rSmall3)))));
HXDLIN(  89)				int noSides3;
HXDLIN(  89)				if ((result3 < 12)) {
HXDLIN(  89)					noSides3 = 12;
            				}
            				else {
HXDLIN(  89)					if ((result3 > 500)) {
HXDLIN(  89)						noSides3 = 500;
            					}
            					else {
HXDLIN(  89)						noSides3 = result3;
            					}
            				}
HXDLIN(  89)				int sides3 = (::Math_obj::ceil((( (Float)(noSides3) ) / ( (Float)(4) ))) * 4);
HXDLIN(  89)				Float theta3 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN(  89)				Float omega3 = ( (Float)(0) );
HXDLIN(  89)				int quarter3 = ::Std_obj::_hx_int((( (Float)(sides3) ) / ( (Float)(4) )));
HXDLIN(  89)				Float lastX3 = ((Float)0.);
HXDLIN(  89)				Float lastY3 = ((Float)0.);
HXDLIN(  89)				{
HXLINE(  26)					lastX3 = (farX + (rightRadius * ::Math_obj::cos(((( (Float)(sides3) ) * theta3) + omega3))));
HXLINE(  27)					lastY3 = (lowerY + (bottomRadius * ::Math_obj::sin(((( (Float)(sides3) ) * theta3) + omega3))));
            				}
HXLINE(  89)				{
HXDLIN(  89)					int _g66 = 0;
HXDLIN(  89)					int _g67 = (quarter3 + 1);
HXDLIN(  89)					while((_g66 < _g67)){
HXDLIN(  89)						_g66 = (_g66 + 1);
HXDLIN(  89)						int i27 = (_g66 - 1);
HXDLIN(  89)						Float nextX3 = (farX + (rightRadius * ::Math_obj::cos((((( (Float)(i27) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  89)						Float nextY3 = (lowerY + (bottomRadius * ::Math_obj::sin((((( (Float)(i27) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN(  89)						{
HXDLIN(  89)							 ::pi_xy::ImageStruct this141 = this140;
HXDLIN(  89)							bool hasHit3 = false;
HXDLIN(  89)							bool hasUndo3 = false;
HXDLIN(  89)							{
HXDLIN(  89)								Float bx3 = lastX3;
HXDLIN(  89)								Float by3 = lastY3;
HXDLIN(  89)								Float cx5 = nextX3;
HXDLIN(  89)								Float cy5 = nextY3;
HXDLIN(  89)								bool adjustWinding3 = (((((farX * by3) - (bx3 * lowerY)) + ((bx3 * cy5) - (cx5 * by3))) + ((cx5 * lowerY) - (farX * cy5))) > 0);
HXDLIN(  89)								if (!(adjustWinding3)) {
HXDLIN(  89)									Float bx_3 = bx3;
HXDLIN(  89)									Float by_3 = by3;
HXLINE(  25)									bx3 = cx5;
HXLINE(  26)									by3 = cy5;
HXLINE(  27)									cx5 = bx_3;
HXLINE(  28)									cy5 = by_3;
            								}
HXLINE(  89)								{
HXDLIN(  89)									Float s03 = ((lowerY * cx5) - (farX * cy5));
HXDLIN(  89)									Float sx3 = (cy5 - lowerY);
HXDLIN(  89)									Float sy3 = (farX - cx5);
HXDLIN(  89)									Float t03 = ((farX * by3) - (lowerY * bx3));
HXDLIN(  89)									Float tx3 = (lowerY - by3);
HXDLIN(  89)									Float ty3 = (bx3 - farX);
HXDLIN(  89)									Float A3 = ((((-(by3) * cx5) + (lowerY * (-(bx3) + cx5))) + (farX * (by3 - cy5))) + (bx3 * cy5));
HXDLIN(  89)									 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  89)									if ((farX > bx3)) {
HXDLIN(  89)										if ((farX > cx5)) {
HXDLIN(  89)											int min12;
HXDLIN(  89)											if ((bx3 > cx5)) {
HXDLIN(  89)												min12 = ::Math_obj::floor(cx5);
            											}
            											else {
HXDLIN(  89)												min12 = ::Math_obj::floor(bx3);
            											}
HXDLIN(  89)											int ii_min30 = min12;
HXDLIN(  89)											int ii_max30 = ::Math_obj::ceil(farX);
HXDLIN(  89)											xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            										}
            										else {
HXDLIN(  89)											int ii_min31 = ::Math_obj::floor(bx3);
HXDLIN(  89)											int ii_max31 = ::Math_obj::ceil(cx5);
HXDLIN(  89)											xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            										}
            									}
            									else {
HXDLIN(  89)										if ((bx3 > cx5)) {
HXDLIN(  89)											int min13;
HXDLIN(  89)											if ((farX > cx5)) {
HXDLIN(  89)												min13 = ::Math_obj::floor(cx5);
            											}
            											else {
HXDLIN(  89)												min13 = ::Math_obj::ceil(farX);
            											}
HXDLIN(  89)											int ii_min32 = min13;
HXDLIN(  89)											int ii_max32 = ::Math_obj::ceil(bx3);
HXDLIN(  89)											xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            										}
            										else {
HXDLIN(  89)											int ii_min33 = ::Math_obj::floor(farX);
HXDLIN(  89)											int ii_max33 = ::Math_obj::ceil(cx5);
HXDLIN(  89)											xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            										}
            									}
HXDLIN(  89)									 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  89)									if ((lowerY > by3)) {
HXDLIN(  89)										if ((lowerY > cy5)) {
HXDLIN(  89)											int min14;
HXDLIN(  89)											if ((by3 > cy5)) {
HXDLIN(  89)												min14 = ::Math_obj::floor(cy5);
            											}
            											else {
HXDLIN(  89)												min14 = ::Math_obj::floor(by3);
            											}
HXDLIN(  89)											int ii_min34 = min14;
HXDLIN(  89)											int ii_max34 = ::Math_obj::ceil(lowerY);
HXDLIN(  89)											yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            										}
            										else {
HXDLIN(  89)											int ii_min35 = ::Math_obj::floor(by3);
HXDLIN(  89)											int ii_max35 = ::Math_obj::ceil(cy5);
HXDLIN(  89)											yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            										}
            									}
            									else {
HXDLIN(  89)										if ((by3 > cy5)) {
HXDLIN(  89)											int min15;
HXDLIN(  89)											if ((lowerY > cy5)) {
HXDLIN(  89)												min15 = ::Math_obj::floor(cy5);
            											}
            											else {
HXDLIN(  89)												min15 = ::Math_obj::ceil(lowerY);
            											}
HXDLIN(  89)											int ii_min36 = min15;
HXDLIN(  89)											int ii_max36 = ::Math_obj::ceil(by3);
HXDLIN(  89)											yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            										}
            										else {
HXDLIN(  89)											int ii_min37 = ::Math_obj::floor(lowerY);
HXDLIN(  89)											int ii_max37 = ::Math_obj::ceil(cy5);
HXDLIN(  89)											yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            										}
            									}
HXDLIN(  89)									 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  89)									if (hasUndo3) {
HXDLIN(  89)										int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  89)										int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  89)										 ::Dynamic imageType3 = null();
HXDLIN(  89)										 ::pi_xy::ImageStruct this142 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  89)										if (::hx::IsNull( imageType3 )) {
HXLINE(  54)											imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE(  89)										::Dynamic undoImage10;
HXDLIN(  89)										switch((int)(( (int)(imageType3) ))){
            											case (int)0: {
HXDLIN(  89)												 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::BytesImg b32 = byt3;
HXDLIN(  89)												{
HXDLIN(  89)													b32->width = width3;
HXDLIN(  89)													b32->height = height3;
HXDLIN(  89)													b32->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  89)													b32->data = ::haxe::io::Bytes_obj::alloc((b32->length * 4));
HXDLIN(  89)													{
HXDLIN(  89)														int len6 = b32->length;
HXDLIN(  89)														int w3 = 0;
HXDLIN(  89)														{
HXDLIN(  89)															int _g68 = 0;
HXDLIN(  89)															int _g69 = b32->height;
HXDLIN(  89)															while((_g68 < _g69)){
HXDLIN(  89)																_g68 = (_g68 + 1);
HXDLIN(  89)																int y16 = (_g68 - 1);
HXDLIN(  89)																{
HXDLIN(  89)																	int _g70 = 0;
HXDLIN(  89)																	int _g71 = b32->width;
HXDLIN(  89)																	while((_g70 < _g71)){
HXDLIN(  89)																		_g70 = (_g70 + 1);
HXDLIN(  89)																		int x16 = (_g70 - 1);
HXDLIN(  89)																		{
HXDLIN(  89)																			w3 = (w3 + 1);
HXDLIN(  89)																			b32->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w3 = (w3 + 1);
HXDLIN(  89)																			b32->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w3 = (w3 + 1);
HXDLIN(  89)																			b32->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN(  89)																		{
HXDLIN(  89)																			w3 = (w3 + 1);
HXDLIN(  89)																			b32->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage10 = b32;
            											}
            											break;
            											case (int)1: {
HXDLIN(  89)												 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::ArrIntImg a30 = arrI3;
HXDLIN(  89)												{
HXDLIN(  89)													a30->width = width3;
HXDLIN(  89)													a30->height = height3;
HXDLIN(  89)													a30->data = ::Array_obj< int >::__new(0);
HXDLIN(  89)													a30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  89)													{
HXDLIN(  89)														int _g72 = 0;
HXDLIN(  89)														int _g73 = a30->length;
HXDLIN(  89)														while((_g72 < _g73)){
HXDLIN(  89)															_g72 = (_g72 + 1);
HXDLIN(  89)															int i28 = (_g72 - 1);
HXDLIN(  89)															a30->data[i28] = 0;
            														}
            													}
            												}
HXDLIN(  89)												undoImage10 = a30;
            											}
            											break;
            											case (int)2: {
HXDLIN(  89)												 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::U32ArrImg b33 = u32a3;
HXDLIN(  89)												{
HXDLIN(  89)													b33->width = width3;
HXDLIN(  89)													b33->height = height3;
HXDLIN(  89)													b33->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  89)													int size3 = (b33->length * 4);
HXDLIN(  89)													b33->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  89)													{
HXDLIN(  89)														int _g74 = 0;
HXDLIN(  89)														int _g75 = b33->length;
HXDLIN(  89)														while((_g74 < _g75)){
HXDLIN(  89)															_g74 = (_g74 + 1);
HXDLIN(  89)															int i29 = (_g74 - 1);
HXDLIN(  89)															{
HXDLIN(  89)																 ::haxe::io::ArrayBufferViewImpl this143 = b33->data;
HXDLIN(  89)																bool undoImage11;
HXDLIN(  89)																if ((i29 >= 0)) {
HXDLIN(  89)																	undoImage11 = (i29 < (this143->byteLength >> 2));
            																}
            																else {
HXDLIN(  89)																	undoImage11 = false;
            																}
HXDLIN(  89)																if (undoImage11) {
HXDLIN(  89)																	 ::haxe::io::Bytes _this3 = this143->bytes;
HXDLIN(  89)																	int pos3 = ((i29 << 2) + this143->byteOffset);
HXDLIN(  89)																	_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  89)																	_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage10 = b33;
            											}
            											break;
            											case (int)3: {
HXDLIN(  89)												 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN(  89)												{
HXDLIN(  89)													v9->width = width3;
HXDLIN(  89)													v9->height = height3;
HXDLIN(  89)													v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  89)													v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN(  89)													{
HXDLIN(  89)														int _g76 = 0;
HXDLIN(  89)														int _g77 = v9->length;
HXDLIN(  89)														while((_g76 < _g77)){
HXDLIN(  89)															_g76 = (_g76 + 1);
HXDLIN(  89)															int i30 = (_g76 - 1);
HXDLIN(  89)															v9->data->__unsafe_set(i30,0);
            														}
            													}
            												}
HXDLIN(  89)												undoImage10 = v9;
            											}
            											break;
            											case (int)4: {
HXDLIN(  89)												 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  89)												 ::iterMagic::StackIntImg b34 = sInt3;
HXDLIN(  89)												{
HXDLIN(  89)													b34->width = width3;
HXDLIN(  89)													b34->height = height3;
HXDLIN(  89)													b34->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  89)													b34->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  89)													{
HXDLIN(  89)														int len7 = b34->length;
HXDLIN(  89)														 ::haxe::ds::GenericStack_Int d3 = b34->data;
HXDLIN(  89)														if (::hx::IsNull( d3->head )) {
HXDLIN(  89)															int _g78 = 0;
HXDLIN(  89)															int _g79 = len7;
HXDLIN(  89)															while((_g78 < _g79)){
HXDLIN(  89)																_g78 = (_g78 + 1);
HXDLIN(  89)																int i31 = (_g78 - 1);
HXDLIN(  89)																d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            															}
            														}
            														else {
HXDLIN(  89)															int _g80 = 0;
HXDLIN(  89)															int _g81 = len7;
HXDLIN(  89)															while((_g80 < _g81)){
HXDLIN(  89)																_g80 = (_g80 + 1);
HXDLIN(  89)																int i32 = (_g80 - 1);
HXDLIN(  89)																{
HXDLIN(  89)																	 ::haxe::ds::GenericCell_Int l3 = b34->data->head;
HXDLIN(  89)																	 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  89)																	{
HXDLIN(  89)																		int _g82 = 0;
HXDLIN(  89)																		int _g83 = i32;
HXDLIN(  89)																		while((_g82 < _g83)){
HXDLIN(  89)																			_g82 = (_g82 + 1);
HXDLIN(  89)																			int i33 = (_g82 - 1);
HXLINE( 345)																			prev3 = l3;
HXLINE( 346)																			l3 = l3->next;
            																		}
            																	}
HXLINE(  89)																	if (::hx::IsNull( prev3 )) {
HXDLIN(  89)																		b34->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  89)																		l3 = null();
            																	}
            																	else {
HXDLIN(  89)																		prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  89)																		l3 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN(  89)												undoImage10 = b34;
            											}
            											break;
            										}
HXDLIN(  89)										this142->image = undoImage10;
HXDLIN(  89)										this142->width = width3;
HXDLIN(  89)										this142->height = height3;
HXDLIN(  89)										this142->imageType = ( (int)(imageType3) );
HXDLIN(  89)										undoImage9 = this142;
HXDLIN(  89)										{
HXDLIN(  89)											int rectLeft3 = xIter33->start;
HXDLIN(  89)											int rectTop3 = yIter33->start;
HXDLIN(  89)											int rectRight3 = xIter33->max;
HXDLIN(  89)											bool forceClear3 = false;
HXDLIN(  89)											{
HXDLIN(  89)												int _g84 = rectTop3;
HXDLIN(  89)												int _g85 = yIter33->max;
HXDLIN(  89)												while((_g84 < _g85)){
HXDLIN(  89)													_g84 = (_g84 + 1);
HXDLIN(  89)													int dy5 = (_g84 - 1);
HXDLIN(  89)													{
HXDLIN(  89)														int _g86 = rectLeft3;
HXDLIN(  89)														int _g87 = rectRight3;
HXDLIN(  89)														while((_g86 < _g87)){
HXDLIN(  89)															_g86 = (_g86 + 1);
HXDLIN(  89)															int dx5 = (_g86 - 1);
HXDLIN(  89)															::Dynamic this144 = this141->image;
HXDLIN(  89)															int index18;
HXDLIN(  89)															if (this141->useVirtualPos) {
HXDLIN(  89)																index18 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this141->virtualY) * ( (Float)(this141->width) )) + dx5) - this141->virtualX));
            															}
            															else {
HXDLIN(  89)																index18 = ::Std_obj::_hx_int(( (Float)(((dy5 * this141->width) + dx5)) ));
            															}
HXDLIN(  89)															int c15 = ::iterMagic::Iimg_obj::get(this144,index18);
HXDLIN(  89)															int col3;
HXDLIN(  89)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																col3 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            															}
            															else {
HXDLIN(  89)																col3 = c15;
            															}
HXDLIN(  89)															bool _hx_tmp33;
HXDLIN(  89)															if (this141->useMask) {
HXDLIN(  89)																_hx_tmp33 = ::hx::IsNotNull( this141->mask );
            															}
            															else {
HXDLIN(  89)																_hx_tmp33 = false;
            															}
HXDLIN(  89)															if (_hx_tmp33) {
HXDLIN(  89)																 ::pi_xy::ImageStruct this145 = this141->mask;
HXDLIN(  89)																::Dynamic this146 = this145->image;
HXDLIN(  89)																int index19;
HXDLIN(  89)																if (this145->useVirtualPos) {
HXDLIN(  89)																	index19 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this145->virtualY) * ( (Float)(this145->width) )) + dx5) - this145->virtualX));
            																}
            																else {
HXDLIN(  89)																	index19 = ::Std_obj::_hx_int(( (Float)(((dy5 * this145->width) + dx5)) ));
            																}
HXDLIN(  89)																int c16 = ::iterMagic::Iimg_obj::get(this146,index19);
HXDLIN(  89)																int v10;
HXDLIN(  89)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																	v10 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            																}
            																else {
HXDLIN(  89)																	v10 = c16;
            																}
HXDLIN(  89)																int maskPixel3 = v10;
HXDLIN(  89)																int this147 = col3;
HXDLIN(  89)																if ((maskPixel3 == 0)) {
HXDLIN(  89)																	col3 = this147;
            																}
            																else {
HXDLIN(  89)																	Float m03;
HXDLIN(  89)																	int this148 = ((maskPixel3 >> 24) & 255);
HXDLIN(  89)																	if ((this148 == 0)) {
HXDLIN(  89)																		m03 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m03 = (( (Float)(this148) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m13;
HXDLIN(  89)																	int this149 = ((maskPixel3 >> 16) & 255);
HXDLIN(  89)																	if ((this149 == 0)) {
HXDLIN(  89)																		m13 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m13 = (( (Float)(this149) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m23;
HXDLIN(  89)																	int this150 = ((maskPixel3 >> 8) & 255);
HXDLIN(  89)																	if ((this150 == 0)) {
HXDLIN(  89)																		m23 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m23 = (( (Float)(this150) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float m33;
HXDLIN(  89)																	int this151 = (maskPixel3 & 255);
HXDLIN(  89)																	if ((this151 == 0)) {
HXDLIN(  89)																		m33 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		m33 = (( (Float)(this151) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this147 >> 24) & 255)) )));
HXDLIN(  89)																	int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this147 >> 16) & 255)) )));
HXDLIN(  89)																	int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this147 >> 8) & 255)) )));
HXDLIN(  89)																	int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this147 & 255)) )));
HXDLIN(  89)																	col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN(  89)															if ((col3 != 0)) {
HXDLIN(  89)																int x17 = (dx5 - rectLeft3);
HXDLIN(  89)																int y17 = (dy5 - rectTop3);
HXDLIN(  89)																int c17 = col3;
HXDLIN(  89)																bool _hx_tmp34;
HXDLIN(  89)																if ((((c17 >> 24) & 255) < 254)) {
HXDLIN(  89)																	_hx_tmp34 = undoImage9->transparent;
            																}
            																else {
HXDLIN(  89)																	_hx_tmp34 = false;
            																}
HXDLIN(  89)																if (_hx_tmp34) {
HXDLIN(  89)																	int location9;
HXDLIN(  89)																	if (undoImage9->useVirtualPos) {
HXDLIN(  89)																		location9 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x17) - undoImage9->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		location9 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage9->width) + x17)) ));
            																	}
HXDLIN(  89)																	int this152 = ::iterMagic::Iimg_obj::get(undoImage9->image,location9);
HXDLIN(  89)																	int this153;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		this153 = ((((((this152 >> 24) & 255) << 24) | ((this152 & 255) << 16)) | (((this152 >> 8) & 255) << 8)) | ((this152 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		this153 = this152;
            																	}
HXDLIN(  89)																	Float a111;
HXDLIN(  89)																	int this154 = ((this153 >> 24) & 255);
HXDLIN(  89)																	if ((this154 == 0)) {
HXDLIN(  89)																		a111 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a111 = (( (Float)(this154) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r19;
HXDLIN(  89)																	int this155 = ((this153 >> 16) & 255);
HXDLIN(  89)																	if ((this155 == 0)) {
HXDLIN(  89)																		r19 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r19 = (( (Float)(this155) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g19;
HXDLIN(  89)																	int this156 = ((this153 >> 8) & 255);
HXDLIN(  89)																	if ((this156 == 0)) {
HXDLIN(  89)																		g19 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g19 = (( (Float)(this156) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b113;
HXDLIN(  89)																	int this157 = (this153 & 255);
HXDLIN(  89)																	if ((this157 == 0)) {
HXDLIN(  89)																		b113 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b113 = (( (Float)(this157) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a210;
HXDLIN(  89)																	int this158 = ((col3 >> 24) & 255);
HXDLIN(  89)																	if ((this158 == 0)) {
HXDLIN(  89)																		a210 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a210 = (( (Float)(this158) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r29;
HXDLIN(  89)																	int this159 = ((col3 >> 16) & 255);
HXDLIN(  89)																	if ((this159 == 0)) {
HXDLIN(  89)																		r29 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r29 = (( (Float)(this159) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g29;
HXDLIN(  89)																	int this160 = ((col3 >> 8) & 255);
HXDLIN(  89)																	if ((this160 == 0)) {
HXDLIN(  89)																		g29 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g29 = (( (Float)(this160) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b211;
HXDLIN(  89)																	int this161 = (col3 & 255);
HXDLIN(  89)																	if ((this161 == 0)) {
HXDLIN(  89)																		b211 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b211 = (( (Float)(this161) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN(  89)																	int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN(  89)																	int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN(  89)																	int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a39) + (b211 * a210))));
HXDLIN(  89)																	int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN(  89)																	int blended9 = ((((a40 << 24) | (r20 << 16)) | (g20 << 8)) | b35);
HXDLIN(  89)																	{
HXDLIN(  89)																		int _hx_tmp35;
HXDLIN(  89)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																			_hx_tmp35 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            																		}
            																		else {
HXDLIN(  89)																			_hx_tmp35 = blended9;
            																		}
HXDLIN(  89)																		::iterMagic::Iimg_obj::set(undoImage9->image,location9,_hx_tmp35);
            																	}
            																}
            																else {
HXDLIN(  89)																	::Dynamic this162 = undoImage9->image;
HXDLIN(  89)																	int index20;
HXDLIN(  89)																	if (undoImage9->useVirtualPos) {
HXDLIN(  89)																		index20 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x17) - undoImage9->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index20 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage9->width) + x17)) ));
            																	}
HXDLIN(  89)																	int _hx_tmp36;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		_hx_tmp36 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		_hx_tmp36 = c17;
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this162,index20,_hx_tmp36);
            																}
            															}
            															else {
HXDLIN(  89)																if (forceClear3) {
HXDLIN(  89)																	::Dynamic this163 = undoImage9->image;
HXDLIN(  89)																	int x18 = (dx5 - rectLeft3);
HXDLIN(  89)																	int y18 = (dy5 - rectTop3);
HXDLIN(  89)																	int index21;
HXDLIN(  89)																	if (undoImage9->useVirtualPos) {
HXDLIN(  89)																		index21 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x18) - undoImage9->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index21 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage9->width) + x18)) ));
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this163,index21,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  89)									bool found3 = false;
HXDLIN(  89)									Float s3 = ((Float)0.);
HXDLIN(  89)									Float t3 = ((Float)0.);
HXDLIN(  89)									Float sxx3 = ((Float)0.);
HXDLIN(  89)									Float txx3 = ((Float)0.);
HXDLIN(  89)									{
HXDLIN(  89)										int _g_min6 = xIter33->start;
HXDLIN(  89)										int _g_max6 = xIter33->max;
HXDLIN(  89)										while((_g_min6 < _g_max6)){
HXDLIN(  89)											_g_min6 = (_g_min6 + 1);
HXDLIN(  89)											int x19 = (_g_min6 - 1);
HXLINE(  60)											sxx3 = (sx3 * ( (Float)(x19) ));
HXLINE(  61)											txx3 = (tx3 * ( (Float)(x19) ));
HXLINE(  62)											found3 = false;
HXLINE(  89)											{
HXDLIN(  89)												int _g_min7 = yIter33->start;
HXDLIN(  89)												int _g_max7 = yIter33->max;
HXDLIN(  89)												while((_g_min7 < _g_max7)){
HXDLIN(  89)													_g_min7 = (_g_min7 + 1);
HXDLIN(  89)													int y19 = (_g_min7 - 1);
HXLINE(  64)													s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y19) )));
HXLINE(  65)													t3 = ((t03 + txx3) + (ty3 * ( (Float)(y19) )));
HXLINE(  89)													bool _hx_tmp37;
HXDLIN(  89)													if (!((s3 <= 0))) {
HXDLIN(  89)														_hx_tmp37 = (t3 <= 0);
            													}
            													else {
HXDLIN(  89)														_hx_tmp37 = true;
            													}
HXDLIN(  89)													if (_hx_tmp37) {
HXDLIN(  89)														if (found3) {
HXDLIN(  89)															goto _hx_goto_132;
            														}
            													}
            													else {
HXDLIN(  89)														if (((s3 + t3) < A3)) {
HXDLIN(  89)															{
HXDLIN(  89)																int c18 = color;
HXDLIN(  89)																bool _hx_tmp38;
HXDLIN(  89)																if ((((c18 >> 24) & 255) < 254)) {
HXDLIN(  89)																	_hx_tmp38 = this141->transparent;
            																}
            																else {
HXDLIN(  89)																	_hx_tmp38 = false;
            																}
HXDLIN(  89)																if (_hx_tmp38) {
HXDLIN(  89)																	int location10;
HXDLIN(  89)																	if (this141->useVirtualPos) {
HXDLIN(  89)																		location10 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this141->virtualY) * ( (Float)(this141->width) )) + x19) - this141->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		location10 = ::Std_obj::_hx_int(( (Float)(((y19 * this141->width) + x19)) ));
            																	}
HXDLIN(  89)																	int this164 = ::iterMagic::Iimg_obj::get(this141->image,location10);
HXDLIN(  89)																	int this165;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		this165 = ((((((this164 >> 24) & 255) << 24) | ((this164 & 255) << 16)) | (((this164 >> 8) & 255) << 8)) | ((this164 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		this165 = this164;
            																	}
HXDLIN(  89)																	Float a112;
HXDLIN(  89)																	int this166 = ((this165 >> 24) & 255);
HXDLIN(  89)																	if ((this166 == 0)) {
HXDLIN(  89)																		a112 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a112 = (( (Float)(this166) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r110;
HXDLIN(  89)																	int this167 = ((this165 >> 16) & 255);
HXDLIN(  89)																	if ((this167 == 0)) {
HXDLIN(  89)																		r110 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r110 = (( (Float)(this167) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g110;
HXDLIN(  89)																	int this168 = ((this165 >> 8) & 255);
HXDLIN(  89)																	if ((this168 == 0)) {
HXDLIN(  89)																		g110 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g110 = (( (Float)(this168) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b114;
HXDLIN(  89)																	int this169 = (this165 & 255);
HXDLIN(  89)																	if ((this169 == 0)) {
HXDLIN(  89)																		b114 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b114 = (( (Float)(this169) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a211;
HXDLIN(  89)																	int this170 = ((color >> 24) & 255);
HXDLIN(  89)																	if ((this170 == 0)) {
HXDLIN(  89)																		a211 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		a211 = (( (Float)(this170) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float r210;
HXDLIN(  89)																	int this171 = ((color >> 16) & 255);
HXDLIN(  89)																	if ((this171 == 0)) {
HXDLIN(  89)																		r210 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		r210 = (( (Float)(this171) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float g210;
HXDLIN(  89)																	int this172 = ((color >> 8) & 255);
HXDLIN(  89)																	if ((this172 == 0)) {
HXDLIN(  89)																		g210 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		g210 = (( (Float)(this172) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float b212;
HXDLIN(  89)																	int this173 = (color & 255);
HXDLIN(  89)																	if ((this173 == 0)) {
HXDLIN(  89)																		b212 = ((Float)0.);
            																	}
            																	else {
HXDLIN(  89)																		b212 = (( (Float)(this173) ) / ( (Float)(255) ));
            																	}
HXDLIN(  89)																	Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN(  89)																	int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN(  89)																	int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN(  89)																	int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b212 * a211))));
HXDLIN(  89)																	int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN(  89)																	int blended10 = ((((a41 << 24) | (r30 << 16)) | (g30 << 8)) | b36);
HXDLIN(  89)																	{
HXDLIN(  89)																		int _hx_tmp39;
HXDLIN(  89)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																			_hx_tmp39 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            																		}
            																		else {
HXDLIN(  89)																			_hx_tmp39 = blended10;
            																		}
HXDLIN(  89)																		::iterMagic::Iimg_obj::set(this141->image,location10,_hx_tmp39);
            																	}
            																}
            																else {
HXDLIN(  89)																	::Dynamic this174 = this141->image;
HXDLIN(  89)																	int index22;
HXDLIN(  89)																	if (this141->useVirtualPos) {
HXDLIN(  89)																		index22 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this141->virtualY) * ( (Float)(this141->width) )) + x19) - this141->virtualX));
            																	}
            																	else {
HXDLIN(  89)																		index22 = ::Std_obj::_hx_int(( (Float)(((y19 * this141->width) + x19)) ));
            																	}
HXDLIN(  89)																	int _hx_tmp40;
HXDLIN(  89)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  89)																		_hx_tmp40 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  89)																		_hx_tmp40 = c18;
            																	}
HXDLIN(  89)																	::iterMagic::Iimg_obj::set(this174,index22,_hx_tmp40);
            																}
            															}
HXLINE(  73)															found3 = true;
            														}
            														else {
HXDLIN(  89)															if (found3) {
HXDLIN(  89)																goto _hx_goto_132;
            															}
            														}
            													}
            												}
            												_hx_goto_132:;
            											}
            										}
            									}
HXDLIN(  89)									if ((hasHit3 == true)) {
HXDLIN(  89)										 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,farX,lowerY,bx3,by3,cx5,cy5,true);
HXDLIN(  89)										if (hasUndo3) {
HXDLIN(  89)											v11->undoImage = undoImage9;
HXDLIN(  89)											v11->undoX = xIter33->start;
HXDLIN(  89)											v11->undoY = yIter33->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  46)						lastX3 = nextX3;
HXLINE(  47)						lastY3 = nextY3;
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(FillShape_Impl__obj,roundRectangle,(void))

void FillShape_Impl__obj::quadrant( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,Float startAngle,int color, ::Dynamic phi, ::Dynamic __o_targetError){
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_107_quadrant)
HXDLIN( 107)		 ::Dynamic targetError1 = targetError;
HXLINE( 113)		if (::hx::IsNull( targetError1 )) {
HXLINE( 113)			targetError1 = ((Float)1.05);
            		}
HXLINE( 107)		Float rSmall;
HXDLIN( 107)		if ((rx > ry)) {
HXDLIN( 107)			rSmall = ry;
            		}
            		else {
HXDLIN( 107)			rSmall = rx;
            		}
HXDLIN( 107)		 ::Dynamic targetE = ( (Float)(targetError1) );
HXDLIN( 107)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 107)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 107)		int noSides;
HXDLIN( 107)		if ((result < 12)) {
HXDLIN( 107)			noSides = 12;
            		}
            		else {
HXDLIN( 107)			if ((result > 500)) {
HXDLIN( 107)				noSides = 500;
            			}
            			else {
HXDLIN( 107)				noSides = result;
            			}
            		}
HXDLIN( 107)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 107)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 107)		Float omega = startAngle;
HXDLIN( 107)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 107)		Float lastX = ((Float)0.);
HXDLIN( 107)		Float lastY = ((Float)0.);
HXDLIN( 107)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  23)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  24)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  26)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 107)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 107)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 107)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 107)			{
HXDLIN( 107)				int _g = 0;
HXDLIN( 107)				int _g1 = (quarter + 1);
HXDLIN( 107)				while((_g < _g1)){
HXDLIN( 107)					_g = (_g + 1);
HXDLIN( 107)					int i = (_g - 1);
HXDLIN( 107)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 107)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 107)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 107)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 107)					{
HXDLIN( 107)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 107)						bool hasHit = false;
HXDLIN( 107)						bool hasUndo = false;
HXDLIN( 107)						{
HXDLIN( 107)							Float bx = lastX;
HXDLIN( 107)							Float by = lastY;
HXDLIN( 107)							Float cx1 = nextX;
HXDLIN( 107)							Float cy1 = nextY;
HXDLIN( 107)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 107)							if (!(adjustWinding)) {
HXDLIN( 107)								Float bx_ = bx;
HXDLIN( 107)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE( 107)							{
HXDLIN( 107)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 107)								Float sx = (cy1 - cy);
HXDLIN( 107)								Float sy = (cx - cx1);
HXDLIN( 107)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 107)								Float tx = (cy - by);
HXDLIN( 107)								Float ty = (bx - cx);
HXDLIN( 107)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 107)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 107)								if ((cx > bx)) {
HXDLIN( 107)									if ((cx > cx1)) {
HXDLIN( 107)										int min;
HXDLIN( 107)										if ((bx > cx1)) {
HXDLIN( 107)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 107)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 107)										int ii_min = min;
HXDLIN( 107)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 107)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 107)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 107)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 107)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 107)									if ((bx > cx1)) {
HXDLIN( 107)										int min1;
HXDLIN( 107)										if ((cx > cx1)) {
HXDLIN( 107)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 107)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 107)										int ii_min2 = min1;
HXDLIN( 107)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 107)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 107)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 107)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 107)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 107)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 107)								if ((cy > by)) {
HXDLIN( 107)									if ((cy > cy1)) {
HXDLIN( 107)										int min2;
HXDLIN( 107)										if ((by > cy1)) {
HXDLIN( 107)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 107)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 107)										int ii_min4 = min2;
HXDLIN( 107)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 107)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 107)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 107)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 107)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 107)									if ((by > cy1)) {
HXDLIN( 107)										int min3;
HXDLIN( 107)										if ((cy > cy1)) {
HXDLIN( 107)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 107)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 107)										int ii_min6 = min3;
HXDLIN( 107)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 107)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 107)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 107)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 107)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 107)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 107)								if (hasUndo) {
HXDLIN( 107)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 107)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 107)									 ::Dynamic imageType = null();
HXDLIN( 107)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 107)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 107)									::Dynamic undoImage1;
HXDLIN( 107)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 107)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 107)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 107)											{
HXDLIN( 107)												b->width = width;
HXDLIN( 107)												b->height = height;
HXDLIN( 107)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 107)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 107)												{
HXDLIN( 107)													int len = b->length;
HXDLIN( 107)													int w = 0;
HXDLIN( 107)													{
HXDLIN( 107)														int _g2 = 0;
HXDLIN( 107)														int _g3 = b->height;
HXDLIN( 107)														while((_g2 < _g3)){
HXDLIN( 107)															_g2 = (_g2 + 1);
HXDLIN( 107)															int y = (_g2 - 1);
HXDLIN( 107)															{
HXDLIN( 107)																int _g4 = 0;
HXDLIN( 107)																int _g5 = b->width;
HXDLIN( 107)																while((_g4 < _g5)){
HXDLIN( 107)																	_g4 = (_g4 + 1);
HXDLIN( 107)																	int x = (_g4 - 1);
HXDLIN( 107)																	{
HXDLIN( 107)																		w = (w + 1);
HXDLIN( 107)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 107)																	{
HXDLIN( 107)																		w = (w + 1);
HXDLIN( 107)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 107)																	{
HXDLIN( 107)																		w = (w + 1);
HXDLIN( 107)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 107)																	{
HXDLIN( 107)																		w = (w + 1);
HXDLIN( 107)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 107)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 107)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 107)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 107)											{
HXDLIN( 107)												a->width = width;
HXDLIN( 107)												a->height = height;
HXDLIN( 107)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 107)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 107)												{
HXDLIN( 107)													int _g6 = 0;
HXDLIN( 107)													int _g7 = a->length;
HXDLIN( 107)													while((_g6 < _g7)){
HXDLIN( 107)														_g6 = (_g6 + 1);
HXDLIN( 107)														int i1 = (_g6 - 1);
HXDLIN( 107)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 107)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 107)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 107)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 107)											{
HXDLIN( 107)												b1->width = width;
HXDLIN( 107)												b1->height = height;
HXDLIN( 107)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 107)												int size = (b1->length * 4);
HXDLIN( 107)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 107)												{
HXDLIN( 107)													int _g8 = 0;
HXDLIN( 107)													int _g9 = b1->length;
HXDLIN( 107)													while((_g8 < _g9)){
HXDLIN( 107)														_g8 = (_g8 + 1);
HXDLIN( 107)														int i2 = (_g8 - 1);
HXDLIN( 107)														{
HXDLIN( 107)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 107)															bool undoImage2;
HXDLIN( 107)															if ((i2 >= 0)) {
HXDLIN( 107)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 107)																undoImage2 = false;
            															}
HXDLIN( 107)															if (undoImage2) {
HXDLIN( 107)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 107)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 107)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 107)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 107)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 107)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 107)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 107)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 107)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 107)											{
HXDLIN( 107)												v->width = width;
HXDLIN( 107)												v->height = height;
HXDLIN( 107)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 107)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 107)												{
HXDLIN( 107)													int _g10 = 0;
HXDLIN( 107)													int _g11 = v->length;
HXDLIN( 107)													while((_g10 < _g11)){
HXDLIN( 107)														_g10 = (_g10 + 1);
HXDLIN( 107)														int i3 = (_g10 - 1);
HXDLIN( 107)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 107)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 107)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 107)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 107)											{
HXDLIN( 107)												b2->width = width;
HXDLIN( 107)												b2->height = height;
HXDLIN( 107)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 107)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 107)												{
HXDLIN( 107)													int len1 = b2->length;
HXDLIN( 107)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 107)													if (::hx::IsNull( d->head )) {
HXDLIN( 107)														int _g12 = 0;
HXDLIN( 107)														int _g13 = len1;
HXDLIN( 107)														while((_g12 < _g13)){
HXDLIN( 107)															_g12 = (_g12 + 1);
HXDLIN( 107)															int i4 = (_g12 - 1);
HXDLIN( 107)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 107)														int _g14 = 0;
HXDLIN( 107)														int _g15 = len1;
HXDLIN( 107)														while((_g14 < _g15)){
HXDLIN( 107)															_g14 = (_g14 + 1);
HXDLIN( 107)															int i5 = (_g14 - 1);
HXDLIN( 107)															{
HXDLIN( 107)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 107)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 107)																{
HXDLIN( 107)																	int _g16 = 0;
HXDLIN( 107)																	int _g17 = i5;
HXDLIN( 107)																	while((_g16 < _g17)){
HXDLIN( 107)																		_g16 = (_g16 + 1);
HXDLIN( 107)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 107)																if (::hx::IsNull( prev )) {
HXDLIN( 107)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 107)																	l = null();
            																}
            																else {
HXDLIN( 107)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 107)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 107)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 107)									this3->image = undoImage1;
HXDLIN( 107)									this3->width = width;
HXDLIN( 107)									this3->height = height;
HXDLIN( 107)									this3->imageType = ( (int)(imageType) );
HXDLIN( 107)									undoImage = this3;
HXDLIN( 107)									{
HXDLIN( 107)										int rectLeft = xIter3->start;
HXDLIN( 107)										int rectTop = yIter3->start;
HXDLIN( 107)										int rectRight = xIter3->max;
HXDLIN( 107)										bool forceClear = false;
HXDLIN( 107)										{
HXDLIN( 107)											int _g18 = rectTop;
HXDLIN( 107)											int _g19 = yIter3->max;
HXDLIN( 107)											while((_g18 < _g19)){
HXDLIN( 107)												_g18 = (_g18 + 1);
HXDLIN( 107)												int dy = (_g18 - 1);
HXDLIN( 107)												{
HXDLIN( 107)													int _g20 = rectLeft;
HXDLIN( 107)													int _g21 = rectRight;
HXDLIN( 107)													while((_g20 < _g21)){
HXDLIN( 107)														_g20 = (_g20 + 1);
HXDLIN( 107)														int dx = (_g20 - 1);
HXDLIN( 107)														::Dynamic this5 = this2->image;
HXDLIN( 107)														int index;
HXDLIN( 107)														if (this2->useVirtualPos) {
HXDLIN( 107)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 107)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 107)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 107)														int col;
HXDLIN( 107)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 107)															col = c;
            														}
HXDLIN( 107)														bool _hx_tmp;
HXDLIN( 107)														if (this2->useMask) {
HXDLIN( 107)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 107)															_hx_tmp = false;
            														}
HXDLIN( 107)														if (_hx_tmp) {
HXDLIN( 107)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 107)															::Dynamic this7 = this6->image;
HXDLIN( 107)															int index1;
HXDLIN( 107)															if (this6->useVirtualPos) {
HXDLIN( 107)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 107)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 107)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 107)															int v1;
HXDLIN( 107)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 107)																v1 = c1;
            															}
HXDLIN( 107)															int maskPixel = v1;
HXDLIN( 107)															int this8 = col;
HXDLIN( 107)															if ((maskPixel == 0)) {
HXDLIN( 107)																col = this8;
            															}
            															else {
HXDLIN( 107)																Float m0;
HXDLIN( 107)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 107)																if ((this9 == 0)) {
HXDLIN( 107)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float m1;
HXDLIN( 107)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 107)																if ((this10 == 0)) {
HXDLIN( 107)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float m2;
HXDLIN( 107)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 107)																if ((this11 == 0)) {
HXDLIN( 107)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float m3;
HXDLIN( 107)																int this12 = (maskPixel & 255);
HXDLIN( 107)																if ((this12 == 0)) {
HXDLIN( 107)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 107)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 107)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 107)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 107)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 107)														if ((col != 0)) {
HXDLIN( 107)															int x1 = (dx - rectLeft);
HXDLIN( 107)															int y1 = (dy - rectTop);
HXDLIN( 107)															int c2 = col;
HXDLIN( 107)															bool _hx_tmp1;
HXDLIN( 107)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 107)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 107)																_hx_tmp1 = false;
            															}
HXDLIN( 107)															if (_hx_tmp1) {
HXDLIN( 107)																int location;
HXDLIN( 107)																if (undoImage->useVirtualPos) {
HXDLIN( 107)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 107)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 107)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 107)																int this14;
HXDLIN( 107)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 107)																	this14 = this13;
            																}
HXDLIN( 107)																Float a1;
HXDLIN( 107)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 107)																if ((this15 == 0)) {
HXDLIN( 107)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float r1;
HXDLIN( 107)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 107)																if ((this16 == 0)) {
HXDLIN( 107)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float g1;
HXDLIN( 107)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 107)																if ((this17 == 0)) {
HXDLIN( 107)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float b11;
HXDLIN( 107)																int this18 = (this14 & 255);
HXDLIN( 107)																if ((this18 == 0)) {
HXDLIN( 107)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float a2;
HXDLIN( 107)																int this19 = ((col >> 24) & 255);
HXDLIN( 107)																if ((this19 == 0)) {
HXDLIN( 107)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float r2;
HXDLIN( 107)																int this20 = ((col >> 16) & 255);
HXDLIN( 107)																if ((this20 == 0)) {
HXDLIN( 107)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float g2;
HXDLIN( 107)																int this21 = ((col >> 8) & 255);
HXDLIN( 107)																if ((this21 == 0)) {
HXDLIN( 107)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float b21;
HXDLIN( 107)																int this22 = (col & 255);
HXDLIN( 107)																if ((this22 == 0)) {
HXDLIN( 107)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 107)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 107)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 107)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 107)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 107)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 107)																{
HXDLIN( 107)																	int _hx_tmp2;
HXDLIN( 107)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 107)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 107)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 107)																::Dynamic this23 = undoImage->image;
HXDLIN( 107)																int index2;
HXDLIN( 107)																if (undoImage->useVirtualPos) {
HXDLIN( 107)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 107)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 107)																int _hx_tmp3;
HXDLIN( 107)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 107)																	_hx_tmp3 = c2;
            																}
HXDLIN( 107)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 107)															if (forceClear) {
HXDLIN( 107)																::Dynamic this24 = undoImage->image;
HXDLIN( 107)																int x2 = (dx - rectLeft);
HXDLIN( 107)																int y2 = (dy - rectTop);
HXDLIN( 107)																int index3;
HXDLIN( 107)																if (undoImage->useVirtualPos) {
HXDLIN( 107)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 107)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 107)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 107)								bool found = false;
HXDLIN( 107)								Float s = ((Float)0.);
HXDLIN( 107)								Float t = ((Float)0.);
HXDLIN( 107)								Float sxx = ((Float)0.);
HXDLIN( 107)								Float txx = ((Float)0.);
HXDLIN( 107)								{
HXDLIN( 107)									int _g_min = xIter3->start;
HXDLIN( 107)									int _g_max = xIter3->max;
HXDLIN( 107)									while((_g_min < _g_max)){
HXDLIN( 107)										_g_min = (_g_min + 1);
HXDLIN( 107)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE( 107)										{
HXDLIN( 107)											int _g_min1 = yIter3->start;
HXDLIN( 107)											int _g_max1 = yIter3->max;
HXDLIN( 107)											while((_g_min1 < _g_max1)){
HXDLIN( 107)												_g_min1 = (_g_min1 + 1);
HXDLIN( 107)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 107)												bool _hx_tmp4;
HXDLIN( 107)												if (!((s <= 0))) {
HXDLIN( 107)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 107)													_hx_tmp4 = true;
            												}
HXDLIN( 107)												if (_hx_tmp4) {
HXDLIN( 107)													if (found) {
HXDLIN( 107)														goto _hx_goto_146;
            													}
            												}
            												else {
HXDLIN( 107)													if (((s + t) < A)) {
HXDLIN( 107)														{
HXDLIN( 107)															int c3 = color;
HXDLIN( 107)															bool _hx_tmp5;
HXDLIN( 107)															if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 107)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 107)																_hx_tmp5 = false;
            															}
HXDLIN( 107)															if (_hx_tmp5) {
HXDLIN( 107)																int location1;
HXDLIN( 107)																if (this2->useVirtualPos) {
HXDLIN( 107)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 107)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 107)																int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 107)																int this26;
HXDLIN( 107)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXDLIN( 107)																	this26 = this25;
            																}
HXDLIN( 107)																Float a11;
HXDLIN( 107)																int this27 = ((this26 >> 24) & 255);
HXDLIN( 107)																if ((this27 == 0)) {
HXDLIN( 107)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float r11;
HXDLIN( 107)																int this28 = ((this26 >> 16) & 255);
HXDLIN( 107)																if ((this28 == 0)) {
HXDLIN( 107)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float g11;
HXDLIN( 107)																int this29 = ((this26 >> 8) & 255);
HXDLIN( 107)																if ((this29 == 0)) {
HXDLIN( 107)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float b12;
HXDLIN( 107)																int this30 = (this26 & 255);
HXDLIN( 107)																if ((this30 == 0)) {
HXDLIN( 107)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float a21;
HXDLIN( 107)																int this31 = ((color >> 24) & 255);
HXDLIN( 107)																if ((this31 == 0)) {
HXDLIN( 107)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float r21;
HXDLIN( 107)																int this32 = ((color >> 16) & 255);
HXDLIN( 107)																if ((this32 == 0)) {
HXDLIN( 107)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float g21;
HXDLIN( 107)																int this33 = ((color >> 8) & 255);
HXDLIN( 107)																if ((this33 == 0)) {
HXDLIN( 107)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float b22;
HXDLIN( 107)																int this34 = (color & 255);
HXDLIN( 107)																if ((this34 == 0)) {
HXDLIN( 107)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 107)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 107)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 107)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 107)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 107)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 107)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 107)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 107)																{
HXDLIN( 107)																	int _hx_tmp6;
HXDLIN( 107)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 107)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 107)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 107)																::Dynamic this35 = this2->image;
HXDLIN( 107)																int index4;
HXDLIN( 107)																if (this2->useVirtualPos) {
HXDLIN( 107)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 107)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 107)																int _hx_tmp7;
HXDLIN( 107)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXDLIN( 107)																	_hx_tmp7 = c3;
            																}
HXDLIN( 107)																::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXDLIN( 107)														if (found) {
HXDLIN( 107)															goto _hx_goto_146;
            														}
            													}
            												}
            											}
            											_hx_goto_146:;
            										}
            									}
            								}
HXDLIN( 107)								if ((hasHit == true)) {
HXDLIN( 107)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 107)									if (hasUndo) {
HXDLIN( 107)										v2->undoImage = undoImage;
HXDLIN( 107)										v2->undoX = xIter3->start;
HXDLIN( 107)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  38)					lastX = nextX;
HXLINE(  39)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 107)			int _g22 = 0;
HXDLIN( 107)			int _g23 = (quarter + 1);
HXDLIN( 107)			while((_g22 < _g23)){
HXDLIN( 107)				_g22 = (_g22 + 1);
HXDLIN( 107)				int i7 = (_g22 - 1);
HXDLIN( 107)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 107)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 107)				{
HXDLIN( 107)					 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 107)					bool hasHit1 = false;
HXDLIN( 107)					bool hasUndo1 = false;
HXDLIN( 107)					{
HXDLIN( 107)						Float bx1 = lastX;
HXDLIN( 107)						Float by1 = lastY;
HXDLIN( 107)						Float cx2 = nextX1;
HXDLIN( 107)						Float cy2 = nextY1;
HXDLIN( 107)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 107)						if (!(adjustWinding1)) {
HXDLIN( 107)							Float bx_1 = bx1;
HXDLIN( 107)							Float by_1 = by1;
HXLINE(  25)							bx1 = cx2;
HXLINE(  26)							by1 = cy2;
HXLINE(  27)							cx2 = bx_1;
HXLINE(  28)							cy2 = by_1;
            						}
HXLINE( 107)						{
HXDLIN( 107)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 107)							Float sx1 = (cy2 - cy);
HXDLIN( 107)							Float sy1 = (cx - cx2);
HXDLIN( 107)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 107)							Float tx1 = (cy - by1);
HXDLIN( 107)							Float ty1 = (bx1 - cx);
HXDLIN( 107)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 107)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 107)							if ((cx > bx1)) {
HXDLIN( 107)								if ((cx > cx2)) {
HXDLIN( 107)									int min4;
HXDLIN( 107)									if ((bx1 > cx2)) {
HXDLIN( 107)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 107)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 107)									int ii_min8 = min4;
HXDLIN( 107)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 107)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 107)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 107)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 107)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 107)								if ((bx1 > cx2)) {
HXDLIN( 107)									int min5;
HXDLIN( 107)									if ((cx > cx2)) {
HXDLIN( 107)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 107)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 107)									int ii_min10 = min5;
HXDLIN( 107)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 107)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 107)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 107)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 107)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 107)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 107)							if ((cy > by1)) {
HXDLIN( 107)								if ((cy > cy2)) {
HXDLIN( 107)									int min6;
HXDLIN( 107)									if ((by1 > cy2)) {
HXDLIN( 107)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 107)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 107)									int ii_min12 = min6;
HXDLIN( 107)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 107)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 107)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 107)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 107)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 107)								if ((by1 > cy2)) {
HXDLIN( 107)									int min7;
HXDLIN( 107)									if ((cy > cy2)) {
HXDLIN( 107)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 107)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 107)									int ii_min14 = min7;
HXDLIN( 107)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 107)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 107)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 107)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 107)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 107)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 107)							if (hasUndo1) {
HXDLIN( 107)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 107)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 107)								 ::Dynamic imageType1 = null();
HXDLIN( 107)								 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 107)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 107)								::Dynamic undoImage4;
HXDLIN( 107)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 107)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 107)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 107)										{
HXDLIN( 107)											b5->width = width1;
HXDLIN( 107)											b5->height = height1;
HXDLIN( 107)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 107)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 107)											{
HXDLIN( 107)												int len2 = b5->length;
HXDLIN( 107)												int w1 = 0;
HXDLIN( 107)												{
HXDLIN( 107)													int _g24 = 0;
HXDLIN( 107)													int _g25 = b5->height;
HXDLIN( 107)													while((_g24 < _g25)){
HXDLIN( 107)														_g24 = (_g24 + 1);
HXDLIN( 107)														int y4 = (_g24 - 1);
HXDLIN( 107)														{
HXDLIN( 107)															int _g26 = 0;
HXDLIN( 107)															int _g27 = b5->width;
HXDLIN( 107)															while((_g26 < _g27)){
HXDLIN( 107)																_g26 = (_g26 + 1);
HXDLIN( 107)																int x4 = (_g26 - 1);
HXDLIN( 107)																{
HXDLIN( 107)																	w1 = (w1 + 1);
HXDLIN( 107)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 107)																{
HXDLIN( 107)																	w1 = (w1 + 1);
HXDLIN( 107)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 107)																{
HXDLIN( 107)																	w1 = (w1 + 1);
HXDLIN( 107)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 107)																{
HXDLIN( 107)																	w1 = (w1 + 1);
HXDLIN( 107)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 107)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 107)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 107)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 107)										{
HXDLIN( 107)											a6->width = width1;
HXDLIN( 107)											a6->height = height1;
HXDLIN( 107)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 107)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 107)											{
HXDLIN( 107)												int _g28 = 0;
HXDLIN( 107)												int _g29 = a6->length;
HXDLIN( 107)												while((_g28 < _g29)){
HXDLIN( 107)													_g28 = (_g28 + 1);
HXDLIN( 107)													int i8 = (_g28 - 1);
HXDLIN( 107)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 107)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 107)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 107)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 107)										{
HXDLIN( 107)											b6->width = width1;
HXDLIN( 107)											b6->height = height1;
HXDLIN( 107)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 107)											int size1 = (b6->length * 4);
HXDLIN( 107)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 107)											{
HXDLIN( 107)												int _g30 = 0;
HXDLIN( 107)												int _g31 = b6->length;
HXDLIN( 107)												while((_g30 < _g31)){
HXDLIN( 107)													_g30 = (_g30 + 1);
HXDLIN( 107)													int i9 = (_g30 - 1);
HXDLIN( 107)													{
HXDLIN( 107)														 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 107)														bool undoImage5;
HXDLIN( 107)														if ((i9 >= 0)) {
HXDLIN( 107)															undoImage5 = (i9 < (this38->byteLength >> 2));
            														}
            														else {
HXDLIN( 107)															undoImage5 = false;
            														}
HXDLIN( 107)														if (undoImage5) {
HXDLIN( 107)															 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 107)															int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 107)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 107)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 107)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 107)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 107)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 107)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 107)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 107)										{
HXDLIN( 107)											v3->width = width1;
HXDLIN( 107)											v3->height = height1;
HXDLIN( 107)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 107)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 107)											{
HXDLIN( 107)												int _g32 = 0;
HXDLIN( 107)												int _g33 = v3->length;
HXDLIN( 107)												while((_g32 < _g33)){
HXDLIN( 107)													_g32 = (_g32 + 1);
HXDLIN( 107)													int i10 = (_g32 - 1);
HXDLIN( 107)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 107)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 107)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 107)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 107)										{
HXDLIN( 107)											b7->width = width1;
HXDLIN( 107)											b7->height = height1;
HXDLIN( 107)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 107)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 107)											{
HXDLIN( 107)												int len3 = b7->length;
HXDLIN( 107)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 107)												if (::hx::IsNull( d1->head )) {
HXDLIN( 107)													int _g34 = 0;
HXDLIN( 107)													int _g35 = len3;
HXDLIN( 107)													while((_g34 < _g35)){
HXDLIN( 107)														_g34 = (_g34 + 1);
HXDLIN( 107)														int i11 = (_g34 - 1);
HXDLIN( 107)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 107)													int _g36 = 0;
HXDLIN( 107)													int _g37 = len3;
HXDLIN( 107)													while((_g36 < _g37)){
HXDLIN( 107)														_g36 = (_g36 + 1);
HXDLIN( 107)														int i12 = (_g36 - 1);
HXDLIN( 107)														{
HXDLIN( 107)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 107)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 107)															{
HXDLIN( 107)																int _g38 = 0;
HXDLIN( 107)																int _g39 = i12;
HXDLIN( 107)																while((_g38 < _g39)){
HXDLIN( 107)																	_g38 = (_g38 + 1);
HXDLIN( 107)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 107)															if (::hx::IsNull( prev1 )) {
HXDLIN( 107)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 107)																l1 = null();
            															}
            															else {
HXDLIN( 107)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 107)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 107)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 107)								this37->image = undoImage4;
HXDLIN( 107)								this37->width = width1;
HXDLIN( 107)								this37->height = height1;
HXDLIN( 107)								this37->imageType = ( (int)(imageType1) );
HXDLIN( 107)								undoImage3 = this37;
HXDLIN( 107)								{
HXDLIN( 107)									int rectLeft1 = xIter31->start;
HXDLIN( 107)									int rectTop1 = yIter31->start;
HXDLIN( 107)									int rectRight1 = xIter31->max;
HXDLIN( 107)									bool forceClear1 = false;
HXDLIN( 107)									{
HXDLIN( 107)										int _g40 = rectTop1;
HXDLIN( 107)										int _g41 = yIter31->max;
HXDLIN( 107)										while((_g40 < _g41)){
HXDLIN( 107)											_g40 = (_g40 + 1);
HXDLIN( 107)											int dy1 = (_g40 - 1);
HXDLIN( 107)											{
HXDLIN( 107)												int _g42 = rectLeft1;
HXDLIN( 107)												int _g43 = rectRight1;
HXDLIN( 107)												while((_g42 < _g43)){
HXDLIN( 107)													_g42 = (_g42 + 1);
HXDLIN( 107)													int dx1 = (_g42 - 1);
HXDLIN( 107)													::Dynamic this39 = this36->image;
HXDLIN( 107)													int index5;
HXDLIN( 107)													if (this36->useVirtualPos) {
HXDLIN( 107)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            													}
            													else {
HXDLIN( 107)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            													}
HXDLIN( 107)													int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 107)													int col1;
HXDLIN( 107)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)														col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXDLIN( 107)														col1 = c4;
            													}
HXDLIN( 107)													bool _hx_tmp8;
HXDLIN( 107)													if (this36->useMask) {
HXDLIN( 107)														_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            													}
            													else {
HXDLIN( 107)														_hx_tmp8 = false;
            													}
HXDLIN( 107)													if (_hx_tmp8) {
HXDLIN( 107)														 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 107)														::Dynamic this41 = this40->image;
HXDLIN( 107)														int index6;
HXDLIN( 107)														if (this40->useVirtualPos) {
HXDLIN( 107)															index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            														}
            														else {
HXDLIN( 107)															index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            														}
HXDLIN( 107)														int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 107)														int v4;
HXDLIN( 107)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)															v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXDLIN( 107)															v4 = c5;
            														}
HXDLIN( 107)														int maskPixel1 = v4;
HXDLIN( 107)														int this42 = col1;
HXDLIN( 107)														if ((maskPixel1 == 0)) {
HXDLIN( 107)															col1 = this42;
            														}
            														else {
HXDLIN( 107)															Float m01;
HXDLIN( 107)															int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 107)															if ((this43 == 0)) {
HXDLIN( 107)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float m11;
HXDLIN( 107)															int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 107)															if ((this44 == 0)) {
HXDLIN( 107)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float m21;
HXDLIN( 107)															int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 107)															if ((this45 == 0)) {
HXDLIN( 107)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float m31;
HXDLIN( 107)															int this46 = (maskPixel1 & 255);
HXDLIN( 107)															if ((this46 == 0)) {
HXDLIN( 107)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 107)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 107)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 107)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 107)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 107)													if ((col1 != 0)) {
HXDLIN( 107)														int x5 = (dx1 - rectLeft1);
HXDLIN( 107)														int y5 = (dy1 - rectTop1);
HXDLIN( 107)														int c6 = col1;
HXDLIN( 107)														bool _hx_tmp9;
HXDLIN( 107)														if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 107)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 107)															_hx_tmp9 = false;
            														}
HXDLIN( 107)														if (_hx_tmp9) {
HXDLIN( 107)															int location2;
HXDLIN( 107)															if (undoImage3->useVirtualPos) {
HXDLIN( 107)																location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 107)																location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 107)															int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 107)															int this48;
HXDLIN( 107)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            															}
            															else {
HXDLIN( 107)																this48 = this47;
            															}
HXDLIN( 107)															Float a12;
HXDLIN( 107)															int this49 = ((this48 >> 24) & 255);
HXDLIN( 107)															if ((this49 == 0)) {
HXDLIN( 107)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float r12;
HXDLIN( 107)															int this50 = ((this48 >> 16) & 255);
HXDLIN( 107)															if ((this50 == 0)) {
HXDLIN( 107)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float g12;
HXDLIN( 107)															int this51 = ((this48 >> 8) & 255);
HXDLIN( 107)															if ((this51 == 0)) {
HXDLIN( 107)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float b13;
HXDLIN( 107)															int this52 = (this48 & 255);
HXDLIN( 107)															if ((this52 == 0)) {
HXDLIN( 107)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float a22;
HXDLIN( 107)															int this53 = ((col1 >> 24) & 255);
HXDLIN( 107)															if ((this53 == 0)) {
HXDLIN( 107)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float r22;
HXDLIN( 107)															int this54 = ((col1 >> 16) & 255);
HXDLIN( 107)															if ((this54 == 0)) {
HXDLIN( 107)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float g22;
HXDLIN( 107)															int this55 = ((col1 >> 8) & 255);
HXDLIN( 107)															if ((this55 == 0)) {
HXDLIN( 107)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float b23;
HXDLIN( 107)															int this56 = (col1 & 255);
HXDLIN( 107)															if ((this56 == 0)) {
HXDLIN( 107)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 107)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 107)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 107)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 107)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 107)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 107)															{
HXDLIN( 107)																int _hx_tmp10;
HXDLIN( 107)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 107)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 107)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 107)															::Dynamic this57 = undoImage3->image;
HXDLIN( 107)															int index7;
HXDLIN( 107)															if (undoImage3->useVirtualPos) {
HXDLIN( 107)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 107)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 107)															int _hx_tmp11;
HXDLIN( 107)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXDLIN( 107)																_hx_tmp11 = c6;
            															}
HXDLIN( 107)															::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 107)														if (forceClear1) {
HXDLIN( 107)															::Dynamic this58 = undoImage3->image;
HXDLIN( 107)															int x6 = (dx1 - rectLeft1);
HXDLIN( 107)															int y6 = (dy1 - rectTop1);
HXDLIN( 107)															int index8;
HXDLIN( 107)															if (undoImage3->useVirtualPos) {
HXDLIN( 107)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 107)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 107)															::iterMagic::Iimg_obj::set(this58,index8,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 107)							bool found1 = false;
HXDLIN( 107)							Float s1 = ((Float)0.);
HXDLIN( 107)							Float t1 = ((Float)0.);
HXDLIN( 107)							Float sxx1 = ((Float)0.);
HXDLIN( 107)							Float txx1 = ((Float)0.);
HXDLIN( 107)							{
HXDLIN( 107)								int _g_min2 = xIter31->start;
HXDLIN( 107)								int _g_max2 = xIter31->max;
HXDLIN( 107)								while((_g_min2 < _g_max2)){
HXDLIN( 107)									_g_min2 = (_g_min2 + 1);
HXDLIN( 107)									int x7 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)									found1 = false;
HXLINE( 107)									{
HXDLIN( 107)										int _g_min3 = yIter31->start;
HXDLIN( 107)										int _g_max3 = yIter31->max;
HXDLIN( 107)										while((_g_min3 < _g_max3)){
HXDLIN( 107)											_g_min3 = (_g_min3 + 1);
HXDLIN( 107)											int y7 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 107)											bool _hx_tmp12;
HXDLIN( 107)											if (!((s1 <= 0))) {
HXDLIN( 107)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 107)												_hx_tmp12 = true;
            											}
HXDLIN( 107)											if (_hx_tmp12) {
HXDLIN( 107)												if (found1) {
HXDLIN( 107)													goto _hx_goto_159;
            												}
            											}
            											else {
HXDLIN( 107)												if (((s1 + t1) < A1)) {
HXDLIN( 107)													{
HXDLIN( 107)														int c7 = color;
HXDLIN( 107)														bool _hx_tmp13;
HXDLIN( 107)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 107)															_hx_tmp13 = this36->transparent;
            														}
            														else {
HXDLIN( 107)															_hx_tmp13 = false;
            														}
HXDLIN( 107)														if (_hx_tmp13) {
HXDLIN( 107)															int location3;
HXDLIN( 107)															if (this36->useVirtualPos) {
HXDLIN( 107)																location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 107)																location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 107)															int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 107)															int this60;
HXDLIN( 107)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            															}
            															else {
HXDLIN( 107)																this60 = this59;
            															}
HXDLIN( 107)															Float a13;
HXDLIN( 107)															int this61 = ((this60 >> 24) & 255);
HXDLIN( 107)															if ((this61 == 0)) {
HXDLIN( 107)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float r13;
HXDLIN( 107)															int this62 = ((this60 >> 16) & 255);
HXDLIN( 107)															if ((this62 == 0)) {
HXDLIN( 107)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float g13;
HXDLIN( 107)															int this63 = ((this60 >> 8) & 255);
HXDLIN( 107)															if ((this63 == 0)) {
HXDLIN( 107)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float b14;
HXDLIN( 107)															int this64 = (this60 & 255);
HXDLIN( 107)															if ((this64 == 0)) {
HXDLIN( 107)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float a23;
HXDLIN( 107)															int this65 = ((color >> 24) & 255);
HXDLIN( 107)															if ((this65 == 0)) {
HXDLIN( 107)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float r23;
HXDLIN( 107)															int this66 = ((color >> 16) & 255);
HXDLIN( 107)															if ((this66 == 0)) {
HXDLIN( 107)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float g23;
HXDLIN( 107)															int this67 = ((color >> 8) & 255);
HXDLIN( 107)															if ((this67 == 0)) {
HXDLIN( 107)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float b24;
HXDLIN( 107)															int this68 = (color & 255);
HXDLIN( 107)															if ((this68 == 0)) {
HXDLIN( 107)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 107)																b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 107)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 107)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 107)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 107)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 107)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 107)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 107)															{
HXDLIN( 107)																int _hx_tmp14;
HXDLIN( 107)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 107)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 107)																::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 107)															::Dynamic this69 = this36->image;
HXDLIN( 107)															int index9;
HXDLIN( 107)															if (this36->useVirtualPos) {
HXDLIN( 107)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 107)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 107)															int _hx_tmp15;
HXDLIN( 107)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 107)																_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 107)																_hx_tmp15 = c7;
            															}
HXDLIN( 107)															::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXDLIN( 107)													if (found1) {
HXDLIN( 107)														goto _hx_goto_159;
            													}
            												}
            											}
            										}
            										_hx_goto_159:;
            									}
            								}
            							}
HXDLIN( 107)							if ((hasHit1 == true)) {
HXDLIN( 107)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 107)								if (hasUndo1) {
HXDLIN( 107)									v5->undoImage = undoImage3;
HXDLIN( 107)									v5->undoX = xIter31->start;
HXDLIN( 107)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  46)				lastX = nextX1;
HXLINE(  47)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FillShape_Impl__obj,quadrant,(void))

void FillShape_Impl__obj::quadrantI( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_120_quadrantI)
HXDLIN( 120)		 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 120)		if (::hx::IsNull( targetError )) {
HXLINE( 113)			targetError = ((Float)1.05);
            		}
HXLINE( 120)		Float rSmall;
HXDLIN( 120)		if ((rx > ry)) {
HXDLIN( 120)			rSmall = ry;
            		}
            		else {
HXDLIN( 120)			rSmall = rx;
            		}
HXDLIN( 120)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 120)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 120)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 120)		int noSides;
HXDLIN( 120)		if ((result < 12)) {
HXDLIN( 120)			noSides = 12;
            		}
            		else {
HXDLIN( 120)			if ((result > 500)) {
HXDLIN( 120)				noSides = 500;
            			}
            			else {
HXDLIN( 120)				noSides = result;
            			}
            		}
HXDLIN( 120)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 120)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 120)		Float omega = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN( 120)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 120)		Float lastX = ((Float)0.);
HXDLIN( 120)		Float lastY = ((Float)0.);
HXDLIN( 120)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  23)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  24)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  26)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 120)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 120)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 120)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 120)			{
HXDLIN( 120)				int _g = 0;
HXDLIN( 120)				int _g1 = (quarter + 1);
HXDLIN( 120)				while((_g < _g1)){
HXDLIN( 120)					_g = (_g + 1);
HXDLIN( 120)					int i = (_g - 1);
HXDLIN( 120)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 120)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 120)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 120)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 120)					{
HXDLIN( 120)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 120)						bool hasHit = false;
HXDLIN( 120)						bool hasUndo = false;
HXDLIN( 120)						{
HXDLIN( 120)							Float bx = lastX;
HXDLIN( 120)							Float by = lastY;
HXDLIN( 120)							Float cx1 = nextX;
HXDLIN( 120)							Float cy1 = nextY;
HXDLIN( 120)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 120)							if (!(adjustWinding)) {
HXDLIN( 120)								Float bx_ = bx;
HXDLIN( 120)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE( 120)							{
HXDLIN( 120)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 120)								Float sx = (cy1 - cy);
HXDLIN( 120)								Float sy = (cx - cx1);
HXDLIN( 120)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 120)								Float tx = (cy - by);
HXDLIN( 120)								Float ty = (bx - cx);
HXDLIN( 120)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 120)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 120)								if ((cx > bx)) {
HXDLIN( 120)									if ((cx > cx1)) {
HXDLIN( 120)										int min;
HXDLIN( 120)										if ((bx > cx1)) {
HXDLIN( 120)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 120)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 120)										int ii_min = min;
HXDLIN( 120)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 120)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 120)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 120)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 120)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 120)									if ((bx > cx1)) {
HXDLIN( 120)										int min1;
HXDLIN( 120)										if ((cx > cx1)) {
HXDLIN( 120)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 120)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 120)										int ii_min2 = min1;
HXDLIN( 120)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 120)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 120)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 120)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 120)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 120)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 120)								if ((cy > by)) {
HXDLIN( 120)									if ((cy > cy1)) {
HXDLIN( 120)										int min2;
HXDLIN( 120)										if ((by > cy1)) {
HXDLIN( 120)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 120)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 120)										int ii_min4 = min2;
HXDLIN( 120)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 120)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 120)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 120)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 120)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 120)									if ((by > cy1)) {
HXDLIN( 120)										int min3;
HXDLIN( 120)										if ((cy > cy1)) {
HXDLIN( 120)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 120)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 120)										int ii_min6 = min3;
HXDLIN( 120)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 120)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 120)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 120)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 120)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 120)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 120)								if (hasUndo) {
HXDLIN( 120)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 120)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 120)									 ::Dynamic imageType = null();
HXDLIN( 120)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 120)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 120)									::Dynamic undoImage1;
HXDLIN( 120)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 120)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 120)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 120)											{
HXDLIN( 120)												b->width = width;
HXDLIN( 120)												b->height = height;
HXDLIN( 120)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 120)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 120)												{
HXDLIN( 120)													int len = b->length;
HXDLIN( 120)													int w = 0;
HXDLIN( 120)													{
HXDLIN( 120)														int _g2 = 0;
HXDLIN( 120)														int _g3 = b->height;
HXDLIN( 120)														while((_g2 < _g3)){
HXDLIN( 120)															_g2 = (_g2 + 1);
HXDLIN( 120)															int y = (_g2 - 1);
HXDLIN( 120)															{
HXDLIN( 120)																int _g4 = 0;
HXDLIN( 120)																int _g5 = b->width;
HXDLIN( 120)																while((_g4 < _g5)){
HXDLIN( 120)																	_g4 = (_g4 + 1);
HXDLIN( 120)																	int x = (_g4 - 1);
HXDLIN( 120)																	{
HXDLIN( 120)																		w = (w + 1);
HXDLIN( 120)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 120)																	{
HXDLIN( 120)																		w = (w + 1);
HXDLIN( 120)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 120)																	{
HXDLIN( 120)																		w = (w + 1);
HXDLIN( 120)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 120)																	{
HXDLIN( 120)																		w = (w + 1);
HXDLIN( 120)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 120)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 120)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 120)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 120)											{
HXDLIN( 120)												a->width = width;
HXDLIN( 120)												a->height = height;
HXDLIN( 120)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 120)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 120)												{
HXDLIN( 120)													int _g6 = 0;
HXDLIN( 120)													int _g7 = a->length;
HXDLIN( 120)													while((_g6 < _g7)){
HXDLIN( 120)														_g6 = (_g6 + 1);
HXDLIN( 120)														int i1 = (_g6 - 1);
HXDLIN( 120)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 120)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 120)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 120)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 120)											{
HXDLIN( 120)												b1->width = width;
HXDLIN( 120)												b1->height = height;
HXDLIN( 120)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 120)												int size = (b1->length * 4);
HXDLIN( 120)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 120)												{
HXDLIN( 120)													int _g8 = 0;
HXDLIN( 120)													int _g9 = b1->length;
HXDLIN( 120)													while((_g8 < _g9)){
HXDLIN( 120)														_g8 = (_g8 + 1);
HXDLIN( 120)														int i2 = (_g8 - 1);
HXDLIN( 120)														{
HXDLIN( 120)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 120)															bool undoImage2;
HXDLIN( 120)															if ((i2 >= 0)) {
HXDLIN( 120)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 120)																undoImage2 = false;
            															}
HXDLIN( 120)															if (undoImage2) {
HXDLIN( 120)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 120)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 120)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 120)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 120)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 120)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 120)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 120)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 120)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 120)											{
HXDLIN( 120)												v->width = width;
HXDLIN( 120)												v->height = height;
HXDLIN( 120)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 120)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 120)												{
HXDLIN( 120)													int _g10 = 0;
HXDLIN( 120)													int _g11 = v->length;
HXDLIN( 120)													while((_g10 < _g11)){
HXDLIN( 120)														_g10 = (_g10 + 1);
HXDLIN( 120)														int i3 = (_g10 - 1);
HXDLIN( 120)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 120)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 120)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 120)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 120)											{
HXDLIN( 120)												b2->width = width;
HXDLIN( 120)												b2->height = height;
HXDLIN( 120)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 120)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 120)												{
HXDLIN( 120)													int len1 = b2->length;
HXDLIN( 120)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 120)													if (::hx::IsNull( d->head )) {
HXDLIN( 120)														int _g12 = 0;
HXDLIN( 120)														int _g13 = len1;
HXDLIN( 120)														while((_g12 < _g13)){
HXDLIN( 120)															_g12 = (_g12 + 1);
HXDLIN( 120)															int i4 = (_g12 - 1);
HXDLIN( 120)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 120)														int _g14 = 0;
HXDLIN( 120)														int _g15 = len1;
HXDLIN( 120)														while((_g14 < _g15)){
HXDLIN( 120)															_g14 = (_g14 + 1);
HXDLIN( 120)															int i5 = (_g14 - 1);
HXDLIN( 120)															{
HXDLIN( 120)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 120)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 120)																{
HXDLIN( 120)																	int _g16 = 0;
HXDLIN( 120)																	int _g17 = i5;
HXDLIN( 120)																	while((_g16 < _g17)){
HXDLIN( 120)																		_g16 = (_g16 + 1);
HXDLIN( 120)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 120)																if (::hx::IsNull( prev )) {
HXDLIN( 120)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 120)																	l = null();
            																}
            																else {
HXDLIN( 120)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 120)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 120)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 120)									this3->image = undoImage1;
HXDLIN( 120)									this3->width = width;
HXDLIN( 120)									this3->height = height;
HXDLIN( 120)									this3->imageType = ( (int)(imageType) );
HXDLIN( 120)									undoImage = this3;
HXDLIN( 120)									{
HXDLIN( 120)										int rectLeft = xIter3->start;
HXDLIN( 120)										int rectTop = yIter3->start;
HXDLIN( 120)										int rectRight = xIter3->max;
HXDLIN( 120)										bool forceClear = false;
HXDLIN( 120)										{
HXDLIN( 120)											int _g18 = rectTop;
HXDLIN( 120)											int _g19 = yIter3->max;
HXDLIN( 120)											while((_g18 < _g19)){
HXDLIN( 120)												_g18 = (_g18 + 1);
HXDLIN( 120)												int dy = (_g18 - 1);
HXDLIN( 120)												{
HXDLIN( 120)													int _g20 = rectLeft;
HXDLIN( 120)													int _g21 = rectRight;
HXDLIN( 120)													while((_g20 < _g21)){
HXDLIN( 120)														_g20 = (_g20 + 1);
HXDLIN( 120)														int dx = (_g20 - 1);
HXDLIN( 120)														::Dynamic this5 = this2->image;
HXDLIN( 120)														int index;
HXDLIN( 120)														if (this2->useVirtualPos) {
HXDLIN( 120)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 120)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 120)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 120)														int col;
HXDLIN( 120)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 120)															col = c;
            														}
HXDLIN( 120)														bool _hx_tmp;
HXDLIN( 120)														if (this2->useMask) {
HXDLIN( 120)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 120)															_hx_tmp = false;
            														}
HXDLIN( 120)														if (_hx_tmp) {
HXDLIN( 120)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 120)															::Dynamic this7 = this6->image;
HXDLIN( 120)															int index1;
HXDLIN( 120)															if (this6->useVirtualPos) {
HXDLIN( 120)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 120)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 120)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 120)															int v1;
HXDLIN( 120)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 120)																v1 = c1;
            															}
HXDLIN( 120)															int maskPixel = v1;
HXDLIN( 120)															int this8 = col;
HXDLIN( 120)															if ((maskPixel == 0)) {
HXDLIN( 120)																col = this8;
            															}
            															else {
HXDLIN( 120)																Float m0;
HXDLIN( 120)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 120)																if ((this9 == 0)) {
HXDLIN( 120)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float m1;
HXDLIN( 120)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 120)																if ((this10 == 0)) {
HXDLIN( 120)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float m2;
HXDLIN( 120)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 120)																if ((this11 == 0)) {
HXDLIN( 120)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float m3;
HXDLIN( 120)																int this12 = (maskPixel & 255);
HXDLIN( 120)																if ((this12 == 0)) {
HXDLIN( 120)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 120)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 120)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 120)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 120)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 120)														if ((col != 0)) {
HXDLIN( 120)															int x1 = (dx - rectLeft);
HXDLIN( 120)															int y1 = (dy - rectTop);
HXDLIN( 120)															int c2 = col;
HXDLIN( 120)															bool _hx_tmp1;
HXDLIN( 120)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 120)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 120)																_hx_tmp1 = false;
            															}
HXDLIN( 120)															if (_hx_tmp1) {
HXDLIN( 120)																int location;
HXDLIN( 120)																if (undoImage->useVirtualPos) {
HXDLIN( 120)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 120)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 120)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 120)																int this14;
HXDLIN( 120)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 120)																	this14 = this13;
            																}
HXDLIN( 120)																Float a1;
HXDLIN( 120)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 120)																if ((this15 == 0)) {
HXDLIN( 120)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float r1;
HXDLIN( 120)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 120)																if ((this16 == 0)) {
HXDLIN( 120)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float g1;
HXDLIN( 120)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 120)																if ((this17 == 0)) {
HXDLIN( 120)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float b11;
HXDLIN( 120)																int this18 = (this14 & 255);
HXDLIN( 120)																if ((this18 == 0)) {
HXDLIN( 120)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float a2;
HXDLIN( 120)																int this19 = ((col >> 24) & 255);
HXDLIN( 120)																if ((this19 == 0)) {
HXDLIN( 120)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float r2;
HXDLIN( 120)																int this20 = ((col >> 16) & 255);
HXDLIN( 120)																if ((this20 == 0)) {
HXDLIN( 120)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float g2;
HXDLIN( 120)																int this21 = ((col >> 8) & 255);
HXDLIN( 120)																if ((this21 == 0)) {
HXDLIN( 120)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float b21;
HXDLIN( 120)																int this22 = (col & 255);
HXDLIN( 120)																if ((this22 == 0)) {
HXDLIN( 120)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 120)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 120)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 120)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 120)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 120)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 120)																{
HXDLIN( 120)																	int _hx_tmp2;
HXDLIN( 120)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 120)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 120)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 120)																::Dynamic this23 = undoImage->image;
HXDLIN( 120)																int index2;
HXDLIN( 120)																if (undoImage->useVirtualPos) {
HXDLIN( 120)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 120)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 120)																int _hx_tmp3;
HXDLIN( 120)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 120)																	_hx_tmp3 = c2;
            																}
HXDLIN( 120)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 120)															if (forceClear) {
HXDLIN( 120)																::Dynamic this24 = undoImage->image;
HXDLIN( 120)																int x2 = (dx - rectLeft);
HXDLIN( 120)																int y2 = (dy - rectTop);
HXDLIN( 120)																int index3;
HXDLIN( 120)																if (undoImage->useVirtualPos) {
HXDLIN( 120)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 120)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 120)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 120)								bool found = false;
HXDLIN( 120)								Float s = ((Float)0.);
HXDLIN( 120)								Float t = ((Float)0.);
HXDLIN( 120)								Float sxx = ((Float)0.);
HXDLIN( 120)								Float txx = ((Float)0.);
HXDLIN( 120)								{
HXDLIN( 120)									int _g_min = xIter3->start;
HXDLIN( 120)									int _g_max = xIter3->max;
HXDLIN( 120)									while((_g_min < _g_max)){
HXDLIN( 120)										_g_min = (_g_min + 1);
HXDLIN( 120)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE( 120)										{
HXDLIN( 120)											int _g_min1 = yIter3->start;
HXDLIN( 120)											int _g_max1 = yIter3->max;
HXDLIN( 120)											while((_g_min1 < _g_max1)){
HXDLIN( 120)												_g_min1 = (_g_min1 + 1);
HXDLIN( 120)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 120)												bool _hx_tmp4;
HXDLIN( 120)												if (!((s <= 0))) {
HXDLIN( 120)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 120)													_hx_tmp4 = true;
            												}
HXDLIN( 120)												if (_hx_tmp4) {
HXDLIN( 120)													if (found) {
HXDLIN( 120)														goto _hx_goto_173;
            													}
            												}
            												else {
HXDLIN( 120)													if (((s + t) < A)) {
HXDLIN( 120)														{
HXDLIN( 120)															int c3 = color;
HXDLIN( 120)															bool _hx_tmp5;
HXDLIN( 120)															if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 120)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 120)																_hx_tmp5 = false;
            															}
HXDLIN( 120)															if (_hx_tmp5) {
HXDLIN( 120)																int location1;
HXDLIN( 120)																if (this2->useVirtualPos) {
HXDLIN( 120)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 120)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 120)																int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 120)																int this26;
HXDLIN( 120)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXDLIN( 120)																	this26 = this25;
            																}
HXDLIN( 120)																Float a11;
HXDLIN( 120)																int this27 = ((this26 >> 24) & 255);
HXDLIN( 120)																if ((this27 == 0)) {
HXDLIN( 120)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float r11;
HXDLIN( 120)																int this28 = ((this26 >> 16) & 255);
HXDLIN( 120)																if ((this28 == 0)) {
HXDLIN( 120)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float g11;
HXDLIN( 120)																int this29 = ((this26 >> 8) & 255);
HXDLIN( 120)																if ((this29 == 0)) {
HXDLIN( 120)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float b12;
HXDLIN( 120)																int this30 = (this26 & 255);
HXDLIN( 120)																if ((this30 == 0)) {
HXDLIN( 120)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float a21;
HXDLIN( 120)																int this31 = ((color >> 24) & 255);
HXDLIN( 120)																if ((this31 == 0)) {
HXDLIN( 120)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float r21;
HXDLIN( 120)																int this32 = ((color >> 16) & 255);
HXDLIN( 120)																if ((this32 == 0)) {
HXDLIN( 120)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float g21;
HXDLIN( 120)																int this33 = ((color >> 8) & 255);
HXDLIN( 120)																if ((this33 == 0)) {
HXDLIN( 120)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float b22;
HXDLIN( 120)																int this34 = (color & 255);
HXDLIN( 120)																if ((this34 == 0)) {
HXDLIN( 120)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 120)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 120)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 120)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 120)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 120)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 120)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 120)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 120)																{
HXDLIN( 120)																	int _hx_tmp6;
HXDLIN( 120)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 120)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 120)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 120)																::Dynamic this35 = this2->image;
HXDLIN( 120)																int index4;
HXDLIN( 120)																if (this2->useVirtualPos) {
HXDLIN( 120)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 120)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 120)																int _hx_tmp7;
HXDLIN( 120)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXDLIN( 120)																	_hx_tmp7 = c3;
            																}
HXDLIN( 120)																::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXDLIN( 120)														if (found) {
HXDLIN( 120)															goto _hx_goto_173;
            														}
            													}
            												}
            											}
            											_hx_goto_173:;
            										}
            									}
            								}
HXDLIN( 120)								if ((hasHit == true)) {
HXDLIN( 120)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 120)									if (hasUndo) {
HXDLIN( 120)										v2->undoImage = undoImage;
HXDLIN( 120)										v2->undoX = xIter3->start;
HXDLIN( 120)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  38)					lastX = nextX;
HXLINE(  39)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 120)			int _g22 = 0;
HXDLIN( 120)			int _g23 = (quarter + 1);
HXDLIN( 120)			while((_g22 < _g23)){
HXDLIN( 120)				_g22 = (_g22 + 1);
HXDLIN( 120)				int i7 = (_g22 - 1);
HXDLIN( 120)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 120)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 120)				{
HXDLIN( 120)					 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 120)					bool hasHit1 = false;
HXDLIN( 120)					bool hasUndo1 = false;
HXDLIN( 120)					{
HXDLIN( 120)						Float bx1 = lastX;
HXDLIN( 120)						Float by1 = lastY;
HXDLIN( 120)						Float cx2 = nextX1;
HXDLIN( 120)						Float cy2 = nextY1;
HXDLIN( 120)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 120)						if (!(adjustWinding1)) {
HXDLIN( 120)							Float bx_1 = bx1;
HXDLIN( 120)							Float by_1 = by1;
HXLINE(  25)							bx1 = cx2;
HXLINE(  26)							by1 = cy2;
HXLINE(  27)							cx2 = bx_1;
HXLINE(  28)							cy2 = by_1;
            						}
HXLINE( 120)						{
HXDLIN( 120)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 120)							Float sx1 = (cy2 - cy);
HXDLIN( 120)							Float sy1 = (cx - cx2);
HXDLIN( 120)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 120)							Float tx1 = (cy - by1);
HXDLIN( 120)							Float ty1 = (bx1 - cx);
HXDLIN( 120)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 120)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 120)							if ((cx > bx1)) {
HXDLIN( 120)								if ((cx > cx2)) {
HXDLIN( 120)									int min4;
HXDLIN( 120)									if ((bx1 > cx2)) {
HXDLIN( 120)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 120)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 120)									int ii_min8 = min4;
HXDLIN( 120)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 120)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 120)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 120)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 120)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 120)								if ((bx1 > cx2)) {
HXDLIN( 120)									int min5;
HXDLIN( 120)									if ((cx > cx2)) {
HXDLIN( 120)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 120)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 120)									int ii_min10 = min5;
HXDLIN( 120)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 120)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 120)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 120)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 120)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 120)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 120)							if ((cy > by1)) {
HXDLIN( 120)								if ((cy > cy2)) {
HXDLIN( 120)									int min6;
HXDLIN( 120)									if ((by1 > cy2)) {
HXDLIN( 120)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 120)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 120)									int ii_min12 = min6;
HXDLIN( 120)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 120)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 120)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 120)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 120)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 120)								if ((by1 > cy2)) {
HXDLIN( 120)									int min7;
HXDLIN( 120)									if ((cy > cy2)) {
HXDLIN( 120)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 120)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 120)									int ii_min14 = min7;
HXDLIN( 120)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 120)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 120)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 120)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 120)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 120)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 120)							if (hasUndo1) {
HXDLIN( 120)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 120)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 120)								 ::Dynamic imageType1 = null();
HXDLIN( 120)								 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 120)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 120)								::Dynamic undoImage4;
HXDLIN( 120)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 120)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 120)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 120)										{
HXDLIN( 120)											b5->width = width1;
HXDLIN( 120)											b5->height = height1;
HXDLIN( 120)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 120)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 120)											{
HXDLIN( 120)												int len2 = b5->length;
HXDLIN( 120)												int w1 = 0;
HXDLIN( 120)												{
HXDLIN( 120)													int _g24 = 0;
HXDLIN( 120)													int _g25 = b5->height;
HXDLIN( 120)													while((_g24 < _g25)){
HXDLIN( 120)														_g24 = (_g24 + 1);
HXDLIN( 120)														int y4 = (_g24 - 1);
HXDLIN( 120)														{
HXDLIN( 120)															int _g26 = 0;
HXDLIN( 120)															int _g27 = b5->width;
HXDLIN( 120)															while((_g26 < _g27)){
HXDLIN( 120)																_g26 = (_g26 + 1);
HXDLIN( 120)																int x4 = (_g26 - 1);
HXDLIN( 120)																{
HXDLIN( 120)																	w1 = (w1 + 1);
HXDLIN( 120)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 120)																{
HXDLIN( 120)																	w1 = (w1 + 1);
HXDLIN( 120)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 120)																{
HXDLIN( 120)																	w1 = (w1 + 1);
HXDLIN( 120)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 120)																{
HXDLIN( 120)																	w1 = (w1 + 1);
HXDLIN( 120)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 120)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 120)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 120)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 120)										{
HXDLIN( 120)											a6->width = width1;
HXDLIN( 120)											a6->height = height1;
HXDLIN( 120)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 120)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 120)											{
HXDLIN( 120)												int _g28 = 0;
HXDLIN( 120)												int _g29 = a6->length;
HXDLIN( 120)												while((_g28 < _g29)){
HXDLIN( 120)													_g28 = (_g28 + 1);
HXDLIN( 120)													int i8 = (_g28 - 1);
HXDLIN( 120)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 120)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 120)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 120)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 120)										{
HXDLIN( 120)											b6->width = width1;
HXDLIN( 120)											b6->height = height1;
HXDLIN( 120)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 120)											int size1 = (b6->length * 4);
HXDLIN( 120)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 120)											{
HXDLIN( 120)												int _g30 = 0;
HXDLIN( 120)												int _g31 = b6->length;
HXDLIN( 120)												while((_g30 < _g31)){
HXDLIN( 120)													_g30 = (_g30 + 1);
HXDLIN( 120)													int i9 = (_g30 - 1);
HXDLIN( 120)													{
HXDLIN( 120)														 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 120)														bool undoImage5;
HXDLIN( 120)														if ((i9 >= 0)) {
HXDLIN( 120)															undoImage5 = (i9 < (this38->byteLength >> 2));
            														}
            														else {
HXDLIN( 120)															undoImage5 = false;
            														}
HXDLIN( 120)														if (undoImage5) {
HXDLIN( 120)															 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 120)															int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 120)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 120)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 120)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 120)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 120)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 120)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 120)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 120)										{
HXDLIN( 120)											v3->width = width1;
HXDLIN( 120)											v3->height = height1;
HXDLIN( 120)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 120)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 120)											{
HXDLIN( 120)												int _g32 = 0;
HXDLIN( 120)												int _g33 = v3->length;
HXDLIN( 120)												while((_g32 < _g33)){
HXDLIN( 120)													_g32 = (_g32 + 1);
HXDLIN( 120)													int i10 = (_g32 - 1);
HXDLIN( 120)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 120)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 120)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 120)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 120)										{
HXDLIN( 120)											b7->width = width1;
HXDLIN( 120)											b7->height = height1;
HXDLIN( 120)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 120)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 120)											{
HXDLIN( 120)												int len3 = b7->length;
HXDLIN( 120)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 120)												if (::hx::IsNull( d1->head )) {
HXDLIN( 120)													int _g34 = 0;
HXDLIN( 120)													int _g35 = len3;
HXDLIN( 120)													while((_g34 < _g35)){
HXDLIN( 120)														_g34 = (_g34 + 1);
HXDLIN( 120)														int i11 = (_g34 - 1);
HXDLIN( 120)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 120)													int _g36 = 0;
HXDLIN( 120)													int _g37 = len3;
HXDLIN( 120)													while((_g36 < _g37)){
HXDLIN( 120)														_g36 = (_g36 + 1);
HXDLIN( 120)														int i12 = (_g36 - 1);
HXDLIN( 120)														{
HXDLIN( 120)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 120)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 120)															{
HXDLIN( 120)																int _g38 = 0;
HXDLIN( 120)																int _g39 = i12;
HXDLIN( 120)																while((_g38 < _g39)){
HXDLIN( 120)																	_g38 = (_g38 + 1);
HXDLIN( 120)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 120)															if (::hx::IsNull( prev1 )) {
HXDLIN( 120)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 120)																l1 = null();
            															}
            															else {
HXDLIN( 120)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 120)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 120)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 120)								this37->image = undoImage4;
HXDLIN( 120)								this37->width = width1;
HXDLIN( 120)								this37->height = height1;
HXDLIN( 120)								this37->imageType = ( (int)(imageType1) );
HXDLIN( 120)								undoImage3 = this37;
HXDLIN( 120)								{
HXDLIN( 120)									int rectLeft1 = xIter31->start;
HXDLIN( 120)									int rectTop1 = yIter31->start;
HXDLIN( 120)									int rectRight1 = xIter31->max;
HXDLIN( 120)									bool forceClear1 = false;
HXDLIN( 120)									{
HXDLIN( 120)										int _g40 = rectTop1;
HXDLIN( 120)										int _g41 = yIter31->max;
HXDLIN( 120)										while((_g40 < _g41)){
HXDLIN( 120)											_g40 = (_g40 + 1);
HXDLIN( 120)											int dy1 = (_g40 - 1);
HXDLIN( 120)											{
HXDLIN( 120)												int _g42 = rectLeft1;
HXDLIN( 120)												int _g43 = rectRight1;
HXDLIN( 120)												while((_g42 < _g43)){
HXDLIN( 120)													_g42 = (_g42 + 1);
HXDLIN( 120)													int dx1 = (_g42 - 1);
HXDLIN( 120)													::Dynamic this39 = this36->image;
HXDLIN( 120)													int index5;
HXDLIN( 120)													if (this36->useVirtualPos) {
HXDLIN( 120)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            													}
            													else {
HXDLIN( 120)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            													}
HXDLIN( 120)													int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 120)													int col1;
HXDLIN( 120)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)														col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXDLIN( 120)														col1 = c4;
            													}
HXDLIN( 120)													bool _hx_tmp8;
HXDLIN( 120)													if (this36->useMask) {
HXDLIN( 120)														_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            													}
            													else {
HXDLIN( 120)														_hx_tmp8 = false;
            													}
HXDLIN( 120)													if (_hx_tmp8) {
HXDLIN( 120)														 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 120)														::Dynamic this41 = this40->image;
HXDLIN( 120)														int index6;
HXDLIN( 120)														if (this40->useVirtualPos) {
HXDLIN( 120)															index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            														}
            														else {
HXDLIN( 120)															index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            														}
HXDLIN( 120)														int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 120)														int v4;
HXDLIN( 120)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)															v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXDLIN( 120)															v4 = c5;
            														}
HXDLIN( 120)														int maskPixel1 = v4;
HXDLIN( 120)														int this42 = col1;
HXDLIN( 120)														if ((maskPixel1 == 0)) {
HXDLIN( 120)															col1 = this42;
            														}
            														else {
HXDLIN( 120)															Float m01;
HXDLIN( 120)															int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 120)															if ((this43 == 0)) {
HXDLIN( 120)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float m11;
HXDLIN( 120)															int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 120)															if ((this44 == 0)) {
HXDLIN( 120)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float m21;
HXDLIN( 120)															int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 120)															if ((this45 == 0)) {
HXDLIN( 120)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float m31;
HXDLIN( 120)															int this46 = (maskPixel1 & 255);
HXDLIN( 120)															if ((this46 == 0)) {
HXDLIN( 120)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 120)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 120)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 120)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 120)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 120)													if ((col1 != 0)) {
HXDLIN( 120)														int x5 = (dx1 - rectLeft1);
HXDLIN( 120)														int y5 = (dy1 - rectTop1);
HXDLIN( 120)														int c6 = col1;
HXDLIN( 120)														bool _hx_tmp9;
HXDLIN( 120)														if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 120)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 120)															_hx_tmp9 = false;
            														}
HXDLIN( 120)														if (_hx_tmp9) {
HXDLIN( 120)															int location2;
HXDLIN( 120)															if (undoImage3->useVirtualPos) {
HXDLIN( 120)																location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 120)																location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 120)															int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 120)															int this48;
HXDLIN( 120)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            															}
            															else {
HXDLIN( 120)																this48 = this47;
            															}
HXDLIN( 120)															Float a12;
HXDLIN( 120)															int this49 = ((this48 >> 24) & 255);
HXDLIN( 120)															if ((this49 == 0)) {
HXDLIN( 120)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float r12;
HXDLIN( 120)															int this50 = ((this48 >> 16) & 255);
HXDLIN( 120)															if ((this50 == 0)) {
HXDLIN( 120)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float g12;
HXDLIN( 120)															int this51 = ((this48 >> 8) & 255);
HXDLIN( 120)															if ((this51 == 0)) {
HXDLIN( 120)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float b13;
HXDLIN( 120)															int this52 = (this48 & 255);
HXDLIN( 120)															if ((this52 == 0)) {
HXDLIN( 120)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float a22;
HXDLIN( 120)															int this53 = ((col1 >> 24) & 255);
HXDLIN( 120)															if ((this53 == 0)) {
HXDLIN( 120)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float r22;
HXDLIN( 120)															int this54 = ((col1 >> 16) & 255);
HXDLIN( 120)															if ((this54 == 0)) {
HXDLIN( 120)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float g22;
HXDLIN( 120)															int this55 = ((col1 >> 8) & 255);
HXDLIN( 120)															if ((this55 == 0)) {
HXDLIN( 120)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float b23;
HXDLIN( 120)															int this56 = (col1 & 255);
HXDLIN( 120)															if ((this56 == 0)) {
HXDLIN( 120)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 120)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 120)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 120)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 120)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 120)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 120)															{
HXDLIN( 120)																int _hx_tmp10;
HXDLIN( 120)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 120)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 120)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 120)															::Dynamic this57 = undoImage3->image;
HXDLIN( 120)															int index7;
HXDLIN( 120)															if (undoImage3->useVirtualPos) {
HXDLIN( 120)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 120)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 120)															int _hx_tmp11;
HXDLIN( 120)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXDLIN( 120)																_hx_tmp11 = c6;
            															}
HXDLIN( 120)															::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 120)														if (forceClear1) {
HXDLIN( 120)															::Dynamic this58 = undoImage3->image;
HXDLIN( 120)															int x6 = (dx1 - rectLeft1);
HXDLIN( 120)															int y6 = (dy1 - rectTop1);
HXDLIN( 120)															int index8;
HXDLIN( 120)															if (undoImage3->useVirtualPos) {
HXDLIN( 120)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 120)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 120)															::iterMagic::Iimg_obj::set(this58,index8,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 120)							bool found1 = false;
HXDLIN( 120)							Float s1 = ((Float)0.);
HXDLIN( 120)							Float t1 = ((Float)0.);
HXDLIN( 120)							Float sxx1 = ((Float)0.);
HXDLIN( 120)							Float txx1 = ((Float)0.);
HXDLIN( 120)							{
HXDLIN( 120)								int _g_min2 = xIter31->start;
HXDLIN( 120)								int _g_max2 = xIter31->max;
HXDLIN( 120)								while((_g_min2 < _g_max2)){
HXDLIN( 120)									_g_min2 = (_g_min2 + 1);
HXDLIN( 120)									int x7 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)									found1 = false;
HXLINE( 120)									{
HXDLIN( 120)										int _g_min3 = yIter31->start;
HXDLIN( 120)										int _g_max3 = yIter31->max;
HXDLIN( 120)										while((_g_min3 < _g_max3)){
HXDLIN( 120)											_g_min3 = (_g_min3 + 1);
HXDLIN( 120)											int y7 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 120)											bool _hx_tmp12;
HXDLIN( 120)											if (!((s1 <= 0))) {
HXDLIN( 120)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 120)												_hx_tmp12 = true;
            											}
HXDLIN( 120)											if (_hx_tmp12) {
HXDLIN( 120)												if (found1) {
HXDLIN( 120)													goto _hx_goto_186;
            												}
            											}
            											else {
HXDLIN( 120)												if (((s1 + t1) < A1)) {
HXDLIN( 120)													{
HXDLIN( 120)														int c7 = color;
HXDLIN( 120)														bool _hx_tmp13;
HXDLIN( 120)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 120)															_hx_tmp13 = this36->transparent;
            														}
            														else {
HXDLIN( 120)															_hx_tmp13 = false;
            														}
HXDLIN( 120)														if (_hx_tmp13) {
HXDLIN( 120)															int location3;
HXDLIN( 120)															if (this36->useVirtualPos) {
HXDLIN( 120)																location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 120)																location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 120)															int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 120)															int this60;
HXDLIN( 120)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            															}
            															else {
HXDLIN( 120)																this60 = this59;
            															}
HXDLIN( 120)															Float a13;
HXDLIN( 120)															int this61 = ((this60 >> 24) & 255);
HXDLIN( 120)															if ((this61 == 0)) {
HXDLIN( 120)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float r13;
HXDLIN( 120)															int this62 = ((this60 >> 16) & 255);
HXDLIN( 120)															if ((this62 == 0)) {
HXDLIN( 120)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float g13;
HXDLIN( 120)															int this63 = ((this60 >> 8) & 255);
HXDLIN( 120)															if ((this63 == 0)) {
HXDLIN( 120)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float b14;
HXDLIN( 120)															int this64 = (this60 & 255);
HXDLIN( 120)															if ((this64 == 0)) {
HXDLIN( 120)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float a23;
HXDLIN( 120)															int this65 = ((color >> 24) & 255);
HXDLIN( 120)															if ((this65 == 0)) {
HXDLIN( 120)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float r23;
HXDLIN( 120)															int this66 = ((color >> 16) & 255);
HXDLIN( 120)															if ((this66 == 0)) {
HXDLIN( 120)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float g23;
HXDLIN( 120)															int this67 = ((color >> 8) & 255);
HXDLIN( 120)															if ((this67 == 0)) {
HXDLIN( 120)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float b24;
HXDLIN( 120)															int this68 = (color & 255);
HXDLIN( 120)															if ((this68 == 0)) {
HXDLIN( 120)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 120)																b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 120)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 120)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 120)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 120)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 120)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 120)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 120)															{
HXDLIN( 120)																int _hx_tmp14;
HXDLIN( 120)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 120)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 120)																::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 120)															::Dynamic this69 = this36->image;
HXDLIN( 120)															int index9;
HXDLIN( 120)															if (this36->useVirtualPos) {
HXDLIN( 120)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 120)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 120)															int _hx_tmp15;
HXDLIN( 120)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 120)																_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 120)																_hx_tmp15 = c7;
            															}
HXDLIN( 120)															::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXDLIN( 120)													if (found1) {
HXDLIN( 120)														goto _hx_goto_186;
            													}
            												}
            											}
            										}
            										_hx_goto_186:;
            									}
            								}
            							}
HXDLIN( 120)							if ((hasHit1 == true)) {
HXDLIN( 120)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 120)								if (hasUndo1) {
HXDLIN( 120)									v5->undoImage = undoImage3;
HXDLIN( 120)									v5->undoX = xIter31->start;
HXDLIN( 120)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  46)				lastX = nextX1;
HXLINE(  47)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,quadrantI,(void))

void FillShape_Impl__obj::quadrantII( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_131_quadrantII)
HXDLIN( 131)		 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 131)		if (::hx::IsNull( targetError )) {
HXLINE( 113)			targetError = ((Float)1.05);
            		}
HXLINE( 131)		Float rSmall;
HXDLIN( 131)		if ((rx > ry)) {
HXDLIN( 131)			rSmall = ry;
            		}
            		else {
HXDLIN( 131)			rSmall = rx;
            		}
HXDLIN( 131)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 131)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 131)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 131)		int noSides;
HXDLIN( 131)		if ((result < 12)) {
HXDLIN( 131)			noSides = 12;
            		}
            		else {
HXDLIN( 131)			if ((result > 500)) {
HXDLIN( 131)				noSides = 500;
            			}
            			else {
HXDLIN( 131)				noSides = result;
            			}
            		}
HXDLIN( 131)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 131)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 131)		Float omega = ::Math_obj::PI;
HXDLIN( 131)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 131)		Float lastX = ((Float)0.);
HXDLIN( 131)		Float lastY = ((Float)0.);
HXDLIN( 131)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  23)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  24)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  26)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 131)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 131)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 131)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 131)			{
HXDLIN( 131)				int _g = 0;
HXDLIN( 131)				int _g1 = (quarter + 1);
HXDLIN( 131)				while((_g < _g1)){
HXDLIN( 131)					_g = (_g + 1);
HXDLIN( 131)					int i = (_g - 1);
HXDLIN( 131)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 131)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 131)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 131)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 131)					{
HXDLIN( 131)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 131)						bool hasHit = false;
HXDLIN( 131)						bool hasUndo = false;
HXDLIN( 131)						{
HXDLIN( 131)							Float bx = lastX;
HXDLIN( 131)							Float by = lastY;
HXDLIN( 131)							Float cx1 = nextX;
HXDLIN( 131)							Float cy1 = nextY;
HXDLIN( 131)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 131)							if (!(adjustWinding)) {
HXDLIN( 131)								Float bx_ = bx;
HXDLIN( 131)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE( 131)							{
HXDLIN( 131)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 131)								Float sx = (cy1 - cy);
HXDLIN( 131)								Float sy = (cx - cx1);
HXDLIN( 131)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 131)								Float tx = (cy - by);
HXDLIN( 131)								Float ty = (bx - cx);
HXDLIN( 131)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 131)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 131)								if ((cx > bx)) {
HXDLIN( 131)									if ((cx > cx1)) {
HXDLIN( 131)										int min;
HXDLIN( 131)										if ((bx > cx1)) {
HXDLIN( 131)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 131)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 131)										int ii_min = min;
HXDLIN( 131)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 131)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 131)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 131)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 131)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 131)									if ((bx > cx1)) {
HXDLIN( 131)										int min1;
HXDLIN( 131)										if ((cx > cx1)) {
HXDLIN( 131)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 131)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 131)										int ii_min2 = min1;
HXDLIN( 131)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 131)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 131)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 131)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 131)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 131)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 131)								if ((cy > by)) {
HXDLIN( 131)									if ((cy > cy1)) {
HXDLIN( 131)										int min2;
HXDLIN( 131)										if ((by > cy1)) {
HXDLIN( 131)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 131)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 131)										int ii_min4 = min2;
HXDLIN( 131)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 131)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 131)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 131)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 131)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 131)									if ((by > cy1)) {
HXDLIN( 131)										int min3;
HXDLIN( 131)										if ((cy > cy1)) {
HXDLIN( 131)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 131)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 131)										int ii_min6 = min3;
HXDLIN( 131)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 131)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 131)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 131)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 131)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 131)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 131)								if (hasUndo) {
HXDLIN( 131)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 131)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 131)									 ::Dynamic imageType = null();
HXDLIN( 131)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 131)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 131)									::Dynamic undoImage1;
HXDLIN( 131)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 131)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 131)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 131)											{
HXDLIN( 131)												b->width = width;
HXDLIN( 131)												b->height = height;
HXDLIN( 131)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 131)												{
HXDLIN( 131)													int len = b->length;
HXDLIN( 131)													int w = 0;
HXDLIN( 131)													{
HXDLIN( 131)														int _g2 = 0;
HXDLIN( 131)														int _g3 = b->height;
HXDLIN( 131)														while((_g2 < _g3)){
HXDLIN( 131)															_g2 = (_g2 + 1);
HXDLIN( 131)															int y = (_g2 - 1);
HXDLIN( 131)															{
HXDLIN( 131)																int _g4 = 0;
HXDLIN( 131)																int _g5 = b->width;
HXDLIN( 131)																while((_g4 < _g5)){
HXDLIN( 131)																	_g4 = (_g4 + 1);
HXDLIN( 131)																	int x = (_g4 - 1);
HXDLIN( 131)																	{
HXDLIN( 131)																		w = (w + 1);
HXDLIN( 131)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 131)																	{
HXDLIN( 131)																		w = (w + 1);
HXDLIN( 131)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 131)																	{
HXDLIN( 131)																		w = (w + 1);
HXDLIN( 131)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 131)																	{
HXDLIN( 131)																		w = (w + 1);
HXDLIN( 131)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 131)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 131)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 131)											{
HXDLIN( 131)												a->width = width;
HXDLIN( 131)												a->height = height;
HXDLIN( 131)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 131)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)												{
HXDLIN( 131)													int _g6 = 0;
HXDLIN( 131)													int _g7 = a->length;
HXDLIN( 131)													while((_g6 < _g7)){
HXDLIN( 131)														_g6 = (_g6 + 1);
HXDLIN( 131)														int i1 = (_g6 - 1);
HXDLIN( 131)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 131)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 131)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 131)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 131)											{
HXDLIN( 131)												b1->width = width;
HXDLIN( 131)												b1->height = height;
HXDLIN( 131)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)												int size = (b1->length * 4);
HXDLIN( 131)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 131)												{
HXDLIN( 131)													int _g8 = 0;
HXDLIN( 131)													int _g9 = b1->length;
HXDLIN( 131)													while((_g8 < _g9)){
HXDLIN( 131)														_g8 = (_g8 + 1);
HXDLIN( 131)														int i2 = (_g8 - 1);
HXDLIN( 131)														{
HXDLIN( 131)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 131)															bool undoImage2;
HXDLIN( 131)															if ((i2 >= 0)) {
HXDLIN( 131)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 131)																undoImage2 = false;
            															}
HXDLIN( 131)															if (undoImage2) {
HXDLIN( 131)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 131)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 131)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 131)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 131)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 131)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 131)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 131)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 131)											{
HXDLIN( 131)												v->width = width;
HXDLIN( 131)												v->height = height;
HXDLIN( 131)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 131)												{
HXDLIN( 131)													int _g10 = 0;
HXDLIN( 131)													int _g11 = v->length;
HXDLIN( 131)													while((_g10 < _g11)){
HXDLIN( 131)														_g10 = (_g10 + 1);
HXDLIN( 131)														int i3 = (_g10 - 1);
HXDLIN( 131)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 131)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 131)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 131)											{
HXDLIN( 131)												b2->width = width;
HXDLIN( 131)												b2->height = height;
HXDLIN( 131)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 131)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 131)												{
HXDLIN( 131)													int len1 = b2->length;
HXDLIN( 131)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 131)													if (::hx::IsNull( d->head )) {
HXDLIN( 131)														int _g12 = 0;
HXDLIN( 131)														int _g13 = len1;
HXDLIN( 131)														while((_g12 < _g13)){
HXDLIN( 131)															_g12 = (_g12 + 1);
HXDLIN( 131)															int i4 = (_g12 - 1);
HXDLIN( 131)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 131)														int _g14 = 0;
HXDLIN( 131)														int _g15 = len1;
HXDLIN( 131)														while((_g14 < _g15)){
HXDLIN( 131)															_g14 = (_g14 + 1);
HXDLIN( 131)															int i5 = (_g14 - 1);
HXDLIN( 131)															{
HXDLIN( 131)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 131)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 131)																{
HXDLIN( 131)																	int _g16 = 0;
HXDLIN( 131)																	int _g17 = i5;
HXDLIN( 131)																	while((_g16 < _g17)){
HXDLIN( 131)																		_g16 = (_g16 + 1);
HXDLIN( 131)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 131)																if (::hx::IsNull( prev )) {
HXDLIN( 131)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 131)																	l = null();
            																}
            																else {
HXDLIN( 131)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 131)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 131)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 131)									this3->image = undoImage1;
HXDLIN( 131)									this3->width = width;
HXDLIN( 131)									this3->height = height;
HXDLIN( 131)									this3->imageType = ( (int)(imageType) );
HXDLIN( 131)									undoImage = this3;
HXDLIN( 131)									{
HXDLIN( 131)										int rectLeft = xIter3->start;
HXDLIN( 131)										int rectTop = yIter3->start;
HXDLIN( 131)										int rectRight = xIter3->max;
HXDLIN( 131)										bool forceClear = false;
HXDLIN( 131)										{
HXDLIN( 131)											int _g18 = rectTop;
HXDLIN( 131)											int _g19 = yIter3->max;
HXDLIN( 131)											while((_g18 < _g19)){
HXDLIN( 131)												_g18 = (_g18 + 1);
HXDLIN( 131)												int dy = (_g18 - 1);
HXDLIN( 131)												{
HXDLIN( 131)													int _g20 = rectLeft;
HXDLIN( 131)													int _g21 = rectRight;
HXDLIN( 131)													while((_g20 < _g21)){
HXDLIN( 131)														_g20 = (_g20 + 1);
HXDLIN( 131)														int dx = (_g20 - 1);
HXDLIN( 131)														::Dynamic this5 = this2->image;
HXDLIN( 131)														int index;
HXDLIN( 131)														if (this2->useVirtualPos) {
HXDLIN( 131)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 131)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 131)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 131)														int col;
HXDLIN( 131)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 131)															col = c;
            														}
HXDLIN( 131)														bool _hx_tmp;
HXDLIN( 131)														if (this2->useMask) {
HXDLIN( 131)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 131)															_hx_tmp = false;
            														}
HXDLIN( 131)														if (_hx_tmp) {
HXDLIN( 131)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 131)															::Dynamic this7 = this6->image;
HXDLIN( 131)															int index1;
HXDLIN( 131)															if (this6->useVirtualPos) {
HXDLIN( 131)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 131)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 131)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 131)															int v1;
HXDLIN( 131)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 131)																v1 = c1;
            															}
HXDLIN( 131)															int maskPixel = v1;
HXDLIN( 131)															int this8 = col;
HXDLIN( 131)															if ((maskPixel == 0)) {
HXDLIN( 131)																col = this8;
            															}
            															else {
HXDLIN( 131)																Float m0;
HXDLIN( 131)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 131)																if ((this9 == 0)) {
HXDLIN( 131)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float m1;
HXDLIN( 131)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 131)																if ((this10 == 0)) {
HXDLIN( 131)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float m2;
HXDLIN( 131)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 131)																if ((this11 == 0)) {
HXDLIN( 131)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float m3;
HXDLIN( 131)																int this12 = (maskPixel & 255);
HXDLIN( 131)																if ((this12 == 0)) {
HXDLIN( 131)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 131)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 131)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 131)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 131)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 131)														if ((col != 0)) {
HXDLIN( 131)															int x1 = (dx - rectLeft);
HXDLIN( 131)															int y1 = (dy - rectTop);
HXDLIN( 131)															int c2 = col;
HXDLIN( 131)															bool _hx_tmp1;
HXDLIN( 131)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 131)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 131)																_hx_tmp1 = false;
            															}
HXDLIN( 131)															if (_hx_tmp1) {
HXDLIN( 131)																int location;
HXDLIN( 131)																if (undoImage->useVirtualPos) {
HXDLIN( 131)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 131)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 131)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 131)																int this14;
HXDLIN( 131)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 131)																	this14 = this13;
            																}
HXDLIN( 131)																Float a1;
HXDLIN( 131)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 131)																if ((this15 == 0)) {
HXDLIN( 131)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float r1;
HXDLIN( 131)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 131)																if ((this16 == 0)) {
HXDLIN( 131)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float g1;
HXDLIN( 131)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 131)																if ((this17 == 0)) {
HXDLIN( 131)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float b11;
HXDLIN( 131)																int this18 = (this14 & 255);
HXDLIN( 131)																if ((this18 == 0)) {
HXDLIN( 131)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float a2;
HXDLIN( 131)																int this19 = ((col >> 24) & 255);
HXDLIN( 131)																if ((this19 == 0)) {
HXDLIN( 131)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float r2;
HXDLIN( 131)																int this20 = ((col >> 16) & 255);
HXDLIN( 131)																if ((this20 == 0)) {
HXDLIN( 131)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float g2;
HXDLIN( 131)																int this21 = ((col >> 8) & 255);
HXDLIN( 131)																if ((this21 == 0)) {
HXDLIN( 131)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float b21;
HXDLIN( 131)																int this22 = (col & 255);
HXDLIN( 131)																if ((this22 == 0)) {
HXDLIN( 131)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 131)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 131)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 131)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 131)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 131)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 131)																{
HXDLIN( 131)																	int _hx_tmp2;
HXDLIN( 131)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 131)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 131)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 131)																::Dynamic this23 = undoImage->image;
HXDLIN( 131)																int index2;
HXDLIN( 131)																if (undoImage->useVirtualPos) {
HXDLIN( 131)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 131)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 131)																int _hx_tmp3;
HXDLIN( 131)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 131)																	_hx_tmp3 = c2;
            																}
HXDLIN( 131)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 131)															if (forceClear) {
HXDLIN( 131)																::Dynamic this24 = undoImage->image;
HXDLIN( 131)																int x2 = (dx - rectLeft);
HXDLIN( 131)																int y2 = (dy - rectTop);
HXDLIN( 131)																int index3;
HXDLIN( 131)																if (undoImage->useVirtualPos) {
HXDLIN( 131)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 131)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 131)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 131)								bool found = false;
HXDLIN( 131)								Float s = ((Float)0.);
HXDLIN( 131)								Float t = ((Float)0.);
HXDLIN( 131)								Float sxx = ((Float)0.);
HXDLIN( 131)								Float txx = ((Float)0.);
HXDLIN( 131)								{
HXDLIN( 131)									int _g_min = xIter3->start;
HXDLIN( 131)									int _g_max = xIter3->max;
HXDLIN( 131)									while((_g_min < _g_max)){
HXDLIN( 131)										_g_min = (_g_min + 1);
HXDLIN( 131)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE( 131)										{
HXDLIN( 131)											int _g_min1 = yIter3->start;
HXDLIN( 131)											int _g_max1 = yIter3->max;
HXDLIN( 131)											while((_g_min1 < _g_max1)){
HXDLIN( 131)												_g_min1 = (_g_min1 + 1);
HXDLIN( 131)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 131)												bool _hx_tmp4;
HXDLIN( 131)												if (!((s <= 0))) {
HXDLIN( 131)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 131)													_hx_tmp4 = true;
            												}
HXDLIN( 131)												if (_hx_tmp4) {
HXDLIN( 131)													if (found) {
HXDLIN( 131)														goto _hx_goto_200;
            													}
            												}
            												else {
HXDLIN( 131)													if (((s + t) < A)) {
HXDLIN( 131)														{
HXDLIN( 131)															int c3 = color;
HXDLIN( 131)															bool _hx_tmp5;
HXDLIN( 131)															if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 131)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 131)																_hx_tmp5 = false;
            															}
HXDLIN( 131)															if (_hx_tmp5) {
HXDLIN( 131)																int location1;
HXDLIN( 131)																if (this2->useVirtualPos) {
HXDLIN( 131)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 131)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 131)																int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 131)																int this26;
HXDLIN( 131)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXDLIN( 131)																	this26 = this25;
            																}
HXDLIN( 131)																Float a11;
HXDLIN( 131)																int this27 = ((this26 >> 24) & 255);
HXDLIN( 131)																if ((this27 == 0)) {
HXDLIN( 131)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float r11;
HXDLIN( 131)																int this28 = ((this26 >> 16) & 255);
HXDLIN( 131)																if ((this28 == 0)) {
HXDLIN( 131)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float g11;
HXDLIN( 131)																int this29 = ((this26 >> 8) & 255);
HXDLIN( 131)																if ((this29 == 0)) {
HXDLIN( 131)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float b12;
HXDLIN( 131)																int this30 = (this26 & 255);
HXDLIN( 131)																if ((this30 == 0)) {
HXDLIN( 131)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float a21;
HXDLIN( 131)																int this31 = ((color >> 24) & 255);
HXDLIN( 131)																if ((this31 == 0)) {
HXDLIN( 131)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float r21;
HXDLIN( 131)																int this32 = ((color >> 16) & 255);
HXDLIN( 131)																if ((this32 == 0)) {
HXDLIN( 131)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float g21;
HXDLIN( 131)																int this33 = ((color >> 8) & 255);
HXDLIN( 131)																if ((this33 == 0)) {
HXDLIN( 131)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float b22;
HXDLIN( 131)																int this34 = (color & 255);
HXDLIN( 131)																if ((this34 == 0)) {
HXDLIN( 131)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 131)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 131)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 131)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 131)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 131)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 131)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 131)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 131)																{
HXDLIN( 131)																	int _hx_tmp6;
HXDLIN( 131)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 131)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 131)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 131)																::Dynamic this35 = this2->image;
HXDLIN( 131)																int index4;
HXDLIN( 131)																if (this2->useVirtualPos) {
HXDLIN( 131)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 131)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 131)																int _hx_tmp7;
HXDLIN( 131)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXDLIN( 131)																	_hx_tmp7 = c3;
            																}
HXDLIN( 131)																::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXDLIN( 131)														if (found) {
HXDLIN( 131)															goto _hx_goto_200;
            														}
            													}
            												}
            											}
            											_hx_goto_200:;
            										}
            									}
            								}
HXDLIN( 131)								if ((hasHit == true)) {
HXDLIN( 131)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 131)									if (hasUndo) {
HXDLIN( 131)										v2->undoImage = undoImage;
HXDLIN( 131)										v2->undoX = xIter3->start;
HXDLIN( 131)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  38)					lastX = nextX;
HXLINE(  39)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 131)			int _g22 = 0;
HXDLIN( 131)			int _g23 = (quarter + 1);
HXDLIN( 131)			while((_g22 < _g23)){
HXDLIN( 131)				_g22 = (_g22 + 1);
HXDLIN( 131)				int i7 = (_g22 - 1);
HXDLIN( 131)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 131)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 131)				{
HXDLIN( 131)					 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 131)					bool hasHit1 = false;
HXDLIN( 131)					bool hasUndo1 = false;
HXDLIN( 131)					{
HXDLIN( 131)						Float bx1 = lastX;
HXDLIN( 131)						Float by1 = lastY;
HXDLIN( 131)						Float cx2 = nextX1;
HXDLIN( 131)						Float cy2 = nextY1;
HXDLIN( 131)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 131)						if (!(adjustWinding1)) {
HXDLIN( 131)							Float bx_1 = bx1;
HXDLIN( 131)							Float by_1 = by1;
HXLINE(  25)							bx1 = cx2;
HXLINE(  26)							by1 = cy2;
HXLINE(  27)							cx2 = bx_1;
HXLINE(  28)							cy2 = by_1;
            						}
HXLINE( 131)						{
HXDLIN( 131)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 131)							Float sx1 = (cy2 - cy);
HXDLIN( 131)							Float sy1 = (cx - cx2);
HXDLIN( 131)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 131)							Float tx1 = (cy - by1);
HXDLIN( 131)							Float ty1 = (bx1 - cx);
HXDLIN( 131)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 131)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 131)							if ((cx > bx1)) {
HXDLIN( 131)								if ((cx > cx2)) {
HXDLIN( 131)									int min4;
HXDLIN( 131)									if ((bx1 > cx2)) {
HXDLIN( 131)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 131)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 131)									int ii_min8 = min4;
HXDLIN( 131)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 131)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 131)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 131)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 131)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 131)								if ((bx1 > cx2)) {
HXDLIN( 131)									int min5;
HXDLIN( 131)									if ((cx > cx2)) {
HXDLIN( 131)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 131)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 131)									int ii_min10 = min5;
HXDLIN( 131)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 131)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 131)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 131)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 131)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 131)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 131)							if ((cy > by1)) {
HXDLIN( 131)								if ((cy > cy2)) {
HXDLIN( 131)									int min6;
HXDLIN( 131)									if ((by1 > cy2)) {
HXDLIN( 131)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 131)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 131)									int ii_min12 = min6;
HXDLIN( 131)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 131)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 131)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 131)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 131)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 131)								if ((by1 > cy2)) {
HXDLIN( 131)									int min7;
HXDLIN( 131)									if ((cy > cy2)) {
HXDLIN( 131)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 131)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 131)									int ii_min14 = min7;
HXDLIN( 131)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 131)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 131)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 131)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 131)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 131)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 131)							if (hasUndo1) {
HXDLIN( 131)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 131)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 131)								 ::Dynamic imageType1 = null();
HXDLIN( 131)								 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 131)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 131)								::Dynamic undoImage4;
HXDLIN( 131)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 131)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 131)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 131)										{
HXDLIN( 131)											b5->width = width1;
HXDLIN( 131)											b5->height = height1;
HXDLIN( 131)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 131)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 131)											{
HXDLIN( 131)												int len2 = b5->length;
HXDLIN( 131)												int w1 = 0;
HXDLIN( 131)												{
HXDLIN( 131)													int _g24 = 0;
HXDLIN( 131)													int _g25 = b5->height;
HXDLIN( 131)													while((_g24 < _g25)){
HXDLIN( 131)														_g24 = (_g24 + 1);
HXDLIN( 131)														int y4 = (_g24 - 1);
HXDLIN( 131)														{
HXDLIN( 131)															int _g26 = 0;
HXDLIN( 131)															int _g27 = b5->width;
HXDLIN( 131)															while((_g26 < _g27)){
HXDLIN( 131)																_g26 = (_g26 + 1);
HXDLIN( 131)																int x4 = (_g26 - 1);
HXDLIN( 131)																{
HXDLIN( 131)																	w1 = (w1 + 1);
HXDLIN( 131)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 131)																{
HXDLIN( 131)																	w1 = (w1 + 1);
HXDLIN( 131)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 131)																{
HXDLIN( 131)																	w1 = (w1 + 1);
HXDLIN( 131)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 131)																{
HXDLIN( 131)																	w1 = (w1 + 1);
HXDLIN( 131)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 131)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 131)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 131)										{
HXDLIN( 131)											a6->width = width1;
HXDLIN( 131)											a6->height = height1;
HXDLIN( 131)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 131)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 131)											{
HXDLIN( 131)												int _g28 = 0;
HXDLIN( 131)												int _g29 = a6->length;
HXDLIN( 131)												while((_g28 < _g29)){
HXDLIN( 131)													_g28 = (_g28 + 1);
HXDLIN( 131)													int i8 = (_g28 - 1);
HXDLIN( 131)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 131)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 131)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 131)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 131)										{
HXDLIN( 131)											b6->width = width1;
HXDLIN( 131)											b6->height = height1;
HXDLIN( 131)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 131)											int size1 = (b6->length * 4);
HXDLIN( 131)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 131)											{
HXDLIN( 131)												int _g30 = 0;
HXDLIN( 131)												int _g31 = b6->length;
HXDLIN( 131)												while((_g30 < _g31)){
HXDLIN( 131)													_g30 = (_g30 + 1);
HXDLIN( 131)													int i9 = (_g30 - 1);
HXDLIN( 131)													{
HXDLIN( 131)														 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 131)														bool undoImage5;
HXDLIN( 131)														if ((i9 >= 0)) {
HXDLIN( 131)															undoImage5 = (i9 < (this38->byteLength >> 2));
            														}
            														else {
HXDLIN( 131)															undoImage5 = false;
            														}
HXDLIN( 131)														if (undoImage5) {
HXDLIN( 131)															 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 131)															int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 131)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 131)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 131)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 131)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 131)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 131)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 131)										{
HXDLIN( 131)											v3->width = width1;
HXDLIN( 131)											v3->height = height1;
HXDLIN( 131)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 131)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 131)											{
HXDLIN( 131)												int _g32 = 0;
HXDLIN( 131)												int _g33 = v3->length;
HXDLIN( 131)												while((_g32 < _g33)){
HXDLIN( 131)													_g32 = (_g32 + 1);
HXDLIN( 131)													int i10 = (_g32 - 1);
HXDLIN( 131)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 131)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 131)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 131)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 131)										{
HXDLIN( 131)											b7->width = width1;
HXDLIN( 131)											b7->height = height1;
HXDLIN( 131)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 131)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 131)											{
HXDLIN( 131)												int len3 = b7->length;
HXDLIN( 131)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 131)												if (::hx::IsNull( d1->head )) {
HXDLIN( 131)													int _g34 = 0;
HXDLIN( 131)													int _g35 = len3;
HXDLIN( 131)													while((_g34 < _g35)){
HXDLIN( 131)														_g34 = (_g34 + 1);
HXDLIN( 131)														int i11 = (_g34 - 1);
HXDLIN( 131)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 131)													int _g36 = 0;
HXDLIN( 131)													int _g37 = len3;
HXDLIN( 131)													while((_g36 < _g37)){
HXDLIN( 131)														_g36 = (_g36 + 1);
HXDLIN( 131)														int i12 = (_g36 - 1);
HXDLIN( 131)														{
HXDLIN( 131)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 131)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 131)															{
HXDLIN( 131)																int _g38 = 0;
HXDLIN( 131)																int _g39 = i12;
HXDLIN( 131)																while((_g38 < _g39)){
HXDLIN( 131)																	_g38 = (_g38 + 1);
HXDLIN( 131)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 131)															if (::hx::IsNull( prev1 )) {
HXDLIN( 131)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 131)																l1 = null();
            															}
            															else {
HXDLIN( 131)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 131)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 131)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 131)								this37->image = undoImage4;
HXDLIN( 131)								this37->width = width1;
HXDLIN( 131)								this37->height = height1;
HXDLIN( 131)								this37->imageType = ( (int)(imageType1) );
HXDLIN( 131)								undoImage3 = this37;
HXDLIN( 131)								{
HXDLIN( 131)									int rectLeft1 = xIter31->start;
HXDLIN( 131)									int rectTop1 = yIter31->start;
HXDLIN( 131)									int rectRight1 = xIter31->max;
HXDLIN( 131)									bool forceClear1 = false;
HXDLIN( 131)									{
HXDLIN( 131)										int _g40 = rectTop1;
HXDLIN( 131)										int _g41 = yIter31->max;
HXDLIN( 131)										while((_g40 < _g41)){
HXDLIN( 131)											_g40 = (_g40 + 1);
HXDLIN( 131)											int dy1 = (_g40 - 1);
HXDLIN( 131)											{
HXDLIN( 131)												int _g42 = rectLeft1;
HXDLIN( 131)												int _g43 = rectRight1;
HXDLIN( 131)												while((_g42 < _g43)){
HXDLIN( 131)													_g42 = (_g42 + 1);
HXDLIN( 131)													int dx1 = (_g42 - 1);
HXDLIN( 131)													::Dynamic this39 = this36->image;
HXDLIN( 131)													int index5;
HXDLIN( 131)													if (this36->useVirtualPos) {
HXDLIN( 131)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            													}
            													else {
HXDLIN( 131)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            													}
HXDLIN( 131)													int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 131)													int col1;
HXDLIN( 131)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)														col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXDLIN( 131)														col1 = c4;
            													}
HXDLIN( 131)													bool _hx_tmp8;
HXDLIN( 131)													if (this36->useMask) {
HXDLIN( 131)														_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            													}
            													else {
HXDLIN( 131)														_hx_tmp8 = false;
            													}
HXDLIN( 131)													if (_hx_tmp8) {
HXDLIN( 131)														 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 131)														::Dynamic this41 = this40->image;
HXDLIN( 131)														int index6;
HXDLIN( 131)														if (this40->useVirtualPos) {
HXDLIN( 131)															index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            														}
            														else {
HXDLIN( 131)															index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            														}
HXDLIN( 131)														int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 131)														int v4;
HXDLIN( 131)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)															v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXDLIN( 131)															v4 = c5;
            														}
HXDLIN( 131)														int maskPixel1 = v4;
HXDLIN( 131)														int this42 = col1;
HXDLIN( 131)														if ((maskPixel1 == 0)) {
HXDLIN( 131)															col1 = this42;
            														}
            														else {
HXDLIN( 131)															Float m01;
HXDLIN( 131)															int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 131)															if ((this43 == 0)) {
HXDLIN( 131)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float m11;
HXDLIN( 131)															int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 131)															if ((this44 == 0)) {
HXDLIN( 131)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float m21;
HXDLIN( 131)															int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 131)															if ((this45 == 0)) {
HXDLIN( 131)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float m31;
HXDLIN( 131)															int this46 = (maskPixel1 & 255);
HXDLIN( 131)															if ((this46 == 0)) {
HXDLIN( 131)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 131)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 131)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 131)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 131)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 131)													if ((col1 != 0)) {
HXDLIN( 131)														int x5 = (dx1 - rectLeft1);
HXDLIN( 131)														int y5 = (dy1 - rectTop1);
HXDLIN( 131)														int c6 = col1;
HXDLIN( 131)														bool _hx_tmp9;
HXDLIN( 131)														if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 131)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 131)															_hx_tmp9 = false;
            														}
HXDLIN( 131)														if (_hx_tmp9) {
HXDLIN( 131)															int location2;
HXDLIN( 131)															if (undoImage3->useVirtualPos) {
HXDLIN( 131)																location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 131)																location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 131)															int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 131)															int this48;
HXDLIN( 131)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            															}
            															else {
HXDLIN( 131)																this48 = this47;
            															}
HXDLIN( 131)															Float a12;
HXDLIN( 131)															int this49 = ((this48 >> 24) & 255);
HXDLIN( 131)															if ((this49 == 0)) {
HXDLIN( 131)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float r12;
HXDLIN( 131)															int this50 = ((this48 >> 16) & 255);
HXDLIN( 131)															if ((this50 == 0)) {
HXDLIN( 131)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float g12;
HXDLIN( 131)															int this51 = ((this48 >> 8) & 255);
HXDLIN( 131)															if ((this51 == 0)) {
HXDLIN( 131)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float b13;
HXDLIN( 131)															int this52 = (this48 & 255);
HXDLIN( 131)															if ((this52 == 0)) {
HXDLIN( 131)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float a22;
HXDLIN( 131)															int this53 = ((col1 >> 24) & 255);
HXDLIN( 131)															if ((this53 == 0)) {
HXDLIN( 131)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float r22;
HXDLIN( 131)															int this54 = ((col1 >> 16) & 255);
HXDLIN( 131)															if ((this54 == 0)) {
HXDLIN( 131)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float g22;
HXDLIN( 131)															int this55 = ((col1 >> 8) & 255);
HXDLIN( 131)															if ((this55 == 0)) {
HXDLIN( 131)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float b23;
HXDLIN( 131)															int this56 = (col1 & 255);
HXDLIN( 131)															if ((this56 == 0)) {
HXDLIN( 131)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 131)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 131)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 131)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 131)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 131)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 131)															{
HXDLIN( 131)																int _hx_tmp10;
HXDLIN( 131)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 131)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 131)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 131)															::Dynamic this57 = undoImage3->image;
HXDLIN( 131)															int index7;
HXDLIN( 131)															if (undoImage3->useVirtualPos) {
HXDLIN( 131)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 131)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 131)															int _hx_tmp11;
HXDLIN( 131)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXDLIN( 131)																_hx_tmp11 = c6;
            															}
HXDLIN( 131)															::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 131)														if (forceClear1) {
HXDLIN( 131)															::Dynamic this58 = undoImage3->image;
HXDLIN( 131)															int x6 = (dx1 - rectLeft1);
HXDLIN( 131)															int y6 = (dy1 - rectTop1);
HXDLIN( 131)															int index8;
HXDLIN( 131)															if (undoImage3->useVirtualPos) {
HXDLIN( 131)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 131)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 131)															::iterMagic::Iimg_obj::set(this58,index8,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 131)							bool found1 = false;
HXDLIN( 131)							Float s1 = ((Float)0.);
HXDLIN( 131)							Float t1 = ((Float)0.);
HXDLIN( 131)							Float sxx1 = ((Float)0.);
HXDLIN( 131)							Float txx1 = ((Float)0.);
HXDLIN( 131)							{
HXDLIN( 131)								int _g_min2 = xIter31->start;
HXDLIN( 131)								int _g_max2 = xIter31->max;
HXDLIN( 131)								while((_g_min2 < _g_max2)){
HXDLIN( 131)									_g_min2 = (_g_min2 + 1);
HXDLIN( 131)									int x7 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)									found1 = false;
HXLINE( 131)									{
HXDLIN( 131)										int _g_min3 = yIter31->start;
HXDLIN( 131)										int _g_max3 = yIter31->max;
HXDLIN( 131)										while((_g_min3 < _g_max3)){
HXDLIN( 131)											_g_min3 = (_g_min3 + 1);
HXDLIN( 131)											int y7 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 131)											bool _hx_tmp12;
HXDLIN( 131)											if (!((s1 <= 0))) {
HXDLIN( 131)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 131)												_hx_tmp12 = true;
            											}
HXDLIN( 131)											if (_hx_tmp12) {
HXDLIN( 131)												if (found1) {
HXDLIN( 131)													goto _hx_goto_213;
            												}
            											}
            											else {
HXDLIN( 131)												if (((s1 + t1) < A1)) {
HXDLIN( 131)													{
HXDLIN( 131)														int c7 = color;
HXDLIN( 131)														bool _hx_tmp13;
HXDLIN( 131)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 131)															_hx_tmp13 = this36->transparent;
            														}
            														else {
HXDLIN( 131)															_hx_tmp13 = false;
            														}
HXDLIN( 131)														if (_hx_tmp13) {
HXDLIN( 131)															int location3;
HXDLIN( 131)															if (this36->useVirtualPos) {
HXDLIN( 131)																location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 131)																location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 131)															int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 131)															int this60;
HXDLIN( 131)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            															}
            															else {
HXDLIN( 131)																this60 = this59;
            															}
HXDLIN( 131)															Float a13;
HXDLIN( 131)															int this61 = ((this60 >> 24) & 255);
HXDLIN( 131)															if ((this61 == 0)) {
HXDLIN( 131)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float r13;
HXDLIN( 131)															int this62 = ((this60 >> 16) & 255);
HXDLIN( 131)															if ((this62 == 0)) {
HXDLIN( 131)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float g13;
HXDLIN( 131)															int this63 = ((this60 >> 8) & 255);
HXDLIN( 131)															if ((this63 == 0)) {
HXDLIN( 131)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float b14;
HXDLIN( 131)															int this64 = (this60 & 255);
HXDLIN( 131)															if ((this64 == 0)) {
HXDLIN( 131)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float a23;
HXDLIN( 131)															int this65 = ((color >> 24) & 255);
HXDLIN( 131)															if ((this65 == 0)) {
HXDLIN( 131)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float r23;
HXDLIN( 131)															int this66 = ((color >> 16) & 255);
HXDLIN( 131)															if ((this66 == 0)) {
HXDLIN( 131)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float g23;
HXDLIN( 131)															int this67 = ((color >> 8) & 255);
HXDLIN( 131)															if ((this67 == 0)) {
HXDLIN( 131)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float b24;
HXDLIN( 131)															int this68 = (color & 255);
HXDLIN( 131)															if ((this68 == 0)) {
HXDLIN( 131)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 131)																b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 131)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 131)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 131)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 131)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 131)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 131)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 131)															{
HXDLIN( 131)																int _hx_tmp14;
HXDLIN( 131)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 131)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 131)																::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 131)															::Dynamic this69 = this36->image;
HXDLIN( 131)															int index9;
HXDLIN( 131)															if (this36->useVirtualPos) {
HXDLIN( 131)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 131)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 131)															int _hx_tmp15;
HXDLIN( 131)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 131)																_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 131)																_hx_tmp15 = c7;
            															}
HXDLIN( 131)															::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXDLIN( 131)													if (found1) {
HXDLIN( 131)														goto _hx_goto_213;
            													}
            												}
            											}
            										}
            										_hx_goto_213:;
            									}
            								}
            							}
HXDLIN( 131)							if ((hasHit1 == true)) {
HXDLIN( 131)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 131)								if (hasUndo1) {
HXDLIN( 131)									v5->undoImage = undoImage3;
HXDLIN( 131)									v5->undoX = xIter31->start;
HXDLIN( 131)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  46)				lastX = nextX1;
HXLINE(  47)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,quadrantII,(void))

void FillShape_Impl__obj::quadrantIII( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_143_quadrantIII)
HXDLIN( 143)		 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 143)		if (::hx::IsNull( targetError )) {
HXLINE( 113)			targetError = ((Float)1.05);
            		}
HXLINE( 143)		Float rSmall;
HXDLIN( 143)		if ((rx > ry)) {
HXDLIN( 143)			rSmall = ry;
            		}
            		else {
HXDLIN( 143)			rSmall = rx;
            		}
HXDLIN( 143)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 143)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 143)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 143)		int noSides;
HXDLIN( 143)		if ((result < 12)) {
HXDLIN( 143)			noSides = 12;
            		}
            		else {
HXDLIN( 143)			if ((result > 500)) {
HXDLIN( 143)				noSides = 500;
            			}
            			else {
HXDLIN( 143)				noSides = result;
            			}
            		}
HXDLIN( 143)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 143)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 143)		Float omega = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 143)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 143)		Float lastX = ((Float)0.);
HXDLIN( 143)		Float lastY = ((Float)0.);
HXDLIN( 143)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  23)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  24)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  26)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 143)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 143)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 143)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 143)			{
HXDLIN( 143)				int _g = 0;
HXDLIN( 143)				int _g1 = (quarter + 1);
HXDLIN( 143)				while((_g < _g1)){
HXDLIN( 143)					_g = (_g + 1);
HXDLIN( 143)					int i = (_g - 1);
HXDLIN( 143)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 143)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 143)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 143)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 143)					{
HXDLIN( 143)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 143)						bool hasHit = false;
HXDLIN( 143)						bool hasUndo = false;
HXDLIN( 143)						{
HXDLIN( 143)							Float bx = lastX;
HXDLIN( 143)							Float by = lastY;
HXDLIN( 143)							Float cx1 = nextX;
HXDLIN( 143)							Float cy1 = nextY;
HXDLIN( 143)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 143)							if (!(adjustWinding)) {
HXDLIN( 143)								Float bx_ = bx;
HXDLIN( 143)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE( 143)							{
HXDLIN( 143)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 143)								Float sx = (cy1 - cy);
HXDLIN( 143)								Float sy = (cx - cx1);
HXDLIN( 143)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 143)								Float tx = (cy - by);
HXDLIN( 143)								Float ty = (bx - cx);
HXDLIN( 143)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 143)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 143)								if ((cx > bx)) {
HXDLIN( 143)									if ((cx > cx1)) {
HXDLIN( 143)										int min;
HXDLIN( 143)										if ((bx > cx1)) {
HXDLIN( 143)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 143)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 143)										int ii_min = min;
HXDLIN( 143)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 143)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 143)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 143)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 143)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 143)									if ((bx > cx1)) {
HXDLIN( 143)										int min1;
HXDLIN( 143)										if ((cx > cx1)) {
HXDLIN( 143)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 143)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 143)										int ii_min2 = min1;
HXDLIN( 143)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 143)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 143)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 143)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 143)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 143)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 143)								if ((cy > by)) {
HXDLIN( 143)									if ((cy > cy1)) {
HXDLIN( 143)										int min2;
HXDLIN( 143)										if ((by > cy1)) {
HXDLIN( 143)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 143)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 143)										int ii_min4 = min2;
HXDLIN( 143)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 143)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 143)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 143)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 143)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 143)									if ((by > cy1)) {
HXDLIN( 143)										int min3;
HXDLIN( 143)										if ((cy > cy1)) {
HXDLIN( 143)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 143)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 143)										int ii_min6 = min3;
HXDLIN( 143)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 143)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 143)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 143)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 143)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 143)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 143)								if (hasUndo) {
HXDLIN( 143)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 143)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 143)									 ::Dynamic imageType = null();
HXDLIN( 143)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 143)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 143)									::Dynamic undoImage1;
HXDLIN( 143)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 143)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 143)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 143)											{
HXDLIN( 143)												b->width = width;
HXDLIN( 143)												b->height = height;
HXDLIN( 143)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 143)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 143)												{
HXDLIN( 143)													int len = b->length;
HXDLIN( 143)													int w = 0;
HXDLIN( 143)													{
HXDLIN( 143)														int _g2 = 0;
HXDLIN( 143)														int _g3 = b->height;
HXDLIN( 143)														while((_g2 < _g3)){
HXDLIN( 143)															_g2 = (_g2 + 1);
HXDLIN( 143)															int y = (_g2 - 1);
HXDLIN( 143)															{
HXDLIN( 143)																int _g4 = 0;
HXDLIN( 143)																int _g5 = b->width;
HXDLIN( 143)																while((_g4 < _g5)){
HXDLIN( 143)																	_g4 = (_g4 + 1);
HXDLIN( 143)																	int x = (_g4 - 1);
HXDLIN( 143)																	{
HXDLIN( 143)																		w = (w + 1);
HXDLIN( 143)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 143)																	{
HXDLIN( 143)																		w = (w + 1);
HXDLIN( 143)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 143)																	{
HXDLIN( 143)																		w = (w + 1);
HXDLIN( 143)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 143)																	{
HXDLIN( 143)																		w = (w + 1);
HXDLIN( 143)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 143)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 143)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 143)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 143)											{
HXDLIN( 143)												a->width = width;
HXDLIN( 143)												a->height = height;
HXDLIN( 143)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 143)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 143)												{
HXDLIN( 143)													int _g6 = 0;
HXDLIN( 143)													int _g7 = a->length;
HXDLIN( 143)													while((_g6 < _g7)){
HXDLIN( 143)														_g6 = (_g6 + 1);
HXDLIN( 143)														int i1 = (_g6 - 1);
HXDLIN( 143)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 143)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 143)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 143)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 143)											{
HXDLIN( 143)												b1->width = width;
HXDLIN( 143)												b1->height = height;
HXDLIN( 143)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 143)												int size = (b1->length * 4);
HXDLIN( 143)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 143)												{
HXDLIN( 143)													int _g8 = 0;
HXDLIN( 143)													int _g9 = b1->length;
HXDLIN( 143)													while((_g8 < _g9)){
HXDLIN( 143)														_g8 = (_g8 + 1);
HXDLIN( 143)														int i2 = (_g8 - 1);
HXDLIN( 143)														{
HXDLIN( 143)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 143)															bool undoImage2;
HXDLIN( 143)															if ((i2 >= 0)) {
HXDLIN( 143)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 143)																undoImage2 = false;
            															}
HXDLIN( 143)															if (undoImage2) {
HXDLIN( 143)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 143)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 143)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 143)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 143)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 143)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 143)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 143)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 143)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 143)											{
HXDLIN( 143)												v->width = width;
HXDLIN( 143)												v->height = height;
HXDLIN( 143)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 143)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 143)												{
HXDLIN( 143)													int _g10 = 0;
HXDLIN( 143)													int _g11 = v->length;
HXDLIN( 143)													while((_g10 < _g11)){
HXDLIN( 143)														_g10 = (_g10 + 1);
HXDLIN( 143)														int i3 = (_g10 - 1);
HXDLIN( 143)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 143)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 143)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 143)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 143)											{
HXDLIN( 143)												b2->width = width;
HXDLIN( 143)												b2->height = height;
HXDLIN( 143)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 143)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 143)												{
HXDLIN( 143)													int len1 = b2->length;
HXDLIN( 143)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 143)													if (::hx::IsNull( d->head )) {
HXDLIN( 143)														int _g12 = 0;
HXDLIN( 143)														int _g13 = len1;
HXDLIN( 143)														while((_g12 < _g13)){
HXDLIN( 143)															_g12 = (_g12 + 1);
HXDLIN( 143)															int i4 = (_g12 - 1);
HXDLIN( 143)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 143)														int _g14 = 0;
HXDLIN( 143)														int _g15 = len1;
HXDLIN( 143)														while((_g14 < _g15)){
HXDLIN( 143)															_g14 = (_g14 + 1);
HXDLIN( 143)															int i5 = (_g14 - 1);
HXDLIN( 143)															{
HXDLIN( 143)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 143)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 143)																{
HXDLIN( 143)																	int _g16 = 0;
HXDLIN( 143)																	int _g17 = i5;
HXDLIN( 143)																	while((_g16 < _g17)){
HXDLIN( 143)																		_g16 = (_g16 + 1);
HXDLIN( 143)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 143)																if (::hx::IsNull( prev )) {
HXDLIN( 143)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 143)																	l = null();
            																}
            																else {
HXDLIN( 143)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 143)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 143)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 143)									this3->image = undoImage1;
HXDLIN( 143)									this3->width = width;
HXDLIN( 143)									this3->height = height;
HXDLIN( 143)									this3->imageType = ( (int)(imageType) );
HXDLIN( 143)									undoImage = this3;
HXDLIN( 143)									{
HXDLIN( 143)										int rectLeft = xIter3->start;
HXDLIN( 143)										int rectTop = yIter3->start;
HXDLIN( 143)										int rectRight = xIter3->max;
HXDLIN( 143)										bool forceClear = false;
HXDLIN( 143)										{
HXDLIN( 143)											int _g18 = rectTop;
HXDLIN( 143)											int _g19 = yIter3->max;
HXDLIN( 143)											while((_g18 < _g19)){
HXDLIN( 143)												_g18 = (_g18 + 1);
HXDLIN( 143)												int dy = (_g18 - 1);
HXDLIN( 143)												{
HXDLIN( 143)													int _g20 = rectLeft;
HXDLIN( 143)													int _g21 = rectRight;
HXDLIN( 143)													while((_g20 < _g21)){
HXDLIN( 143)														_g20 = (_g20 + 1);
HXDLIN( 143)														int dx = (_g20 - 1);
HXDLIN( 143)														::Dynamic this5 = this2->image;
HXDLIN( 143)														int index;
HXDLIN( 143)														if (this2->useVirtualPos) {
HXDLIN( 143)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 143)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 143)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 143)														int col;
HXDLIN( 143)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 143)															col = c;
            														}
HXDLIN( 143)														bool _hx_tmp;
HXDLIN( 143)														if (this2->useMask) {
HXDLIN( 143)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 143)															_hx_tmp = false;
            														}
HXDLIN( 143)														if (_hx_tmp) {
HXDLIN( 143)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 143)															::Dynamic this7 = this6->image;
HXDLIN( 143)															int index1;
HXDLIN( 143)															if (this6->useVirtualPos) {
HXDLIN( 143)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 143)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 143)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 143)															int v1;
HXDLIN( 143)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 143)																v1 = c1;
            															}
HXDLIN( 143)															int maskPixel = v1;
HXDLIN( 143)															int this8 = col;
HXDLIN( 143)															if ((maskPixel == 0)) {
HXDLIN( 143)																col = this8;
            															}
            															else {
HXDLIN( 143)																Float m0;
HXDLIN( 143)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 143)																if ((this9 == 0)) {
HXDLIN( 143)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float m1;
HXDLIN( 143)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 143)																if ((this10 == 0)) {
HXDLIN( 143)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float m2;
HXDLIN( 143)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 143)																if ((this11 == 0)) {
HXDLIN( 143)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float m3;
HXDLIN( 143)																int this12 = (maskPixel & 255);
HXDLIN( 143)																if ((this12 == 0)) {
HXDLIN( 143)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 143)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 143)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 143)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 143)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 143)														if ((col != 0)) {
HXDLIN( 143)															int x1 = (dx - rectLeft);
HXDLIN( 143)															int y1 = (dy - rectTop);
HXDLIN( 143)															int c2 = col;
HXDLIN( 143)															bool _hx_tmp1;
HXDLIN( 143)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 143)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 143)																_hx_tmp1 = false;
            															}
HXDLIN( 143)															if (_hx_tmp1) {
HXDLIN( 143)																int location;
HXDLIN( 143)																if (undoImage->useVirtualPos) {
HXDLIN( 143)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 143)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 143)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 143)																int this14;
HXDLIN( 143)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 143)																	this14 = this13;
            																}
HXDLIN( 143)																Float a1;
HXDLIN( 143)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 143)																if ((this15 == 0)) {
HXDLIN( 143)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float r1;
HXDLIN( 143)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 143)																if ((this16 == 0)) {
HXDLIN( 143)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float g1;
HXDLIN( 143)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 143)																if ((this17 == 0)) {
HXDLIN( 143)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float b11;
HXDLIN( 143)																int this18 = (this14 & 255);
HXDLIN( 143)																if ((this18 == 0)) {
HXDLIN( 143)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float a2;
HXDLIN( 143)																int this19 = ((col >> 24) & 255);
HXDLIN( 143)																if ((this19 == 0)) {
HXDLIN( 143)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float r2;
HXDLIN( 143)																int this20 = ((col >> 16) & 255);
HXDLIN( 143)																if ((this20 == 0)) {
HXDLIN( 143)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float g2;
HXDLIN( 143)																int this21 = ((col >> 8) & 255);
HXDLIN( 143)																if ((this21 == 0)) {
HXDLIN( 143)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float b21;
HXDLIN( 143)																int this22 = (col & 255);
HXDLIN( 143)																if ((this22 == 0)) {
HXDLIN( 143)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 143)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 143)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 143)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 143)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 143)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 143)																{
HXDLIN( 143)																	int _hx_tmp2;
HXDLIN( 143)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 143)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 143)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 143)																::Dynamic this23 = undoImage->image;
HXDLIN( 143)																int index2;
HXDLIN( 143)																if (undoImage->useVirtualPos) {
HXDLIN( 143)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 143)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 143)																int _hx_tmp3;
HXDLIN( 143)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 143)																	_hx_tmp3 = c2;
            																}
HXDLIN( 143)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 143)															if (forceClear) {
HXDLIN( 143)																::Dynamic this24 = undoImage->image;
HXDLIN( 143)																int x2 = (dx - rectLeft);
HXDLIN( 143)																int y2 = (dy - rectTop);
HXDLIN( 143)																int index3;
HXDLIN( 143)																if (undoImage->useVirtualPos) {
HXDLIN( 143)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 143)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 143)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 143)								bool found = false;
HXDLIN( 143)								Float s = ((Float)0.);
HXDLIN( 143)								Float t = ((Float)0.);
HXDLIN( 143)								Float sxx = ((Float)0.);
HXDLIN( 143)								Float txx = ((Float)0.);
HXDLIN( 143)								{
HXDLIN( 143)									int _g_min = xIter3->start;
HXDLIN( 143)									int _g_max = xIter3->max;
HXDLIN( 143)									while((_g_min < _g_max)){
HXDLIN( 143)										_g_min = (_g_min + 1);
HXDLIN( 143)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE( 143)										{
HXDLIN( 143)											int _g_min1 = yIter3->start;
HXDLIN( 143)											int _g_max1 = yIter3->max;
HXDLIN( 143)											while((_g_min1 < _g_max1)){
HXDLIN( 143)												_g_min1 = (_g_min1 + 1);
HXDLIN( 143)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 143)												bool _hx_tmp4;
HXDLIN( 143)												if (!((s <= 0))) {
HXDLIN( 143)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 143)													_hx_tmp4 = true;
            												}
HXDLIN( 143)												if (_hx_tmp4) {
HXDLIN( 143)													if (found) {
HXDLIN( 143)														goto _hx_goto_227;
            													}
            												}
            												else {
HXDLIN( 143)													if (((s + t) < A)) {
HXDLIN( 143)														{
HXDLIN( 143)															int c3 = color;
HXDLIN( 143)															bool _hx_tmp5;
HXDLIN( 143)															if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 143)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 143)																_hx_tmp5 = false;
            															}
HXDLIN( 143)															if (_hx_tmp5) {
HXDLIN( 143)																int location1;
HXDLIN( 143)																if (this2->useVirtualPos) {
HXDLIN( 143)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 143)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 143)																int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 143)																int this26;
HXDLIN( 143)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXDLIN( 143)																	this26 = this25;
            																}
HXDLIN( 143)																Float a11;
HXDLIN( 143)																int this27 = ((this26 >> 24) & 255);
HXDLIN( 143)																if ((this27 == 0)) {
HXDLIN( 143)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float r11;
HXDLIN( 143)																int this28 = ((this26 >> 16) & 255);
HXDLIN( 143)																if ((this28 == 0)) {
HXDLIN( 143)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float g11;
HXDLIN( 143)																int this29 = ((this26 >> 8) & 255);
HXDLIN( 143)																if ((this29 == 0)) {
HXDLIN( 143)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float b12;
HXDLIN( 143)																int this30 = (this26 & 255);
HXDLIN( 143)																if ((this30 == 0)) {
HXDLIN( 143)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float a21;
HXDLIN( 143)																int this31 = ((color >> 24) & 255);
HXDLIN( 143)																if ((this31 == 0)) {
HXDLIN( 143)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float r21;
HXDLIN( 143)																int this32 = ((color >> 16) & 255);
HXDLIN( 143)																if ((this32 == 0)) {
HXDLIN( 143)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float g21;
HXDLIN( 143)																int this33 = ((color >> 8) & 255);
HXDLIN( 143)																if ((this33 == 0)) {
HXDLIN( 143)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float b22;
HXDLIN( 143)																int this34 = (color & 255);
HXDLIN( 143)																if ((this34 == 0)) {
HXDLIN( 143)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 143)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 143)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 143)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 143)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 143)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 143)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 143)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 143)																{
HXDLIN( 143)																	int _hx_tmp6;
HXDLIN( 143)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 143)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 143)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 143)																::Dynamic this35 = this2->image;
HXDLIN( 143)																int index4;
HXDLIN( 143)																if (this2->useVirtualPos) {
HXDLIN( 143)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 143)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 143)																int _hx_tmp7;
HXDLIN( 143)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXDLIN( 143)																	_hx_tmp7 = c3;
            																}
HXDLIN( 143)																::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXDLIN( 143)														if (found) {
HXDLIN( 143)															goto _hx_goto_227;
            														}
            													}
            												}
            											}
            											_hx_goto_227:;
            										}
            									}
            								}
HXDLIN( 143)								if ((hasHit == true)) {
HXDLIN( 143)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 143)									if (hasUndo) {
HXDLIN( 143)										v2->undoImage = undoImage;
HXDLIN( 143)										v2->undoX = xIter3->start;
HXDLIN( 143)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  38)					lastX = nextX;
HXLINE(  39)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 143)			int _g22 = 0;
HXDLIN( 143)			int _g23 = (quarter + 1);
HXDLIN( 143)			while((_g22 < _g23)){
HXDLIN( 143)				_g22 = (_g22 + 1);
HXDLIN( 143)				int i7 = (_g22 - 1);
HXDLIN( 143)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 143)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 143)				{
HXDLIN( 143)					 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 143)					bool hasHit1 = false;
HXDLIN( 143)					bool hasUndo1 = false;
HXDLIN( 143)					{
HXDLIN( 143)						Float bx1 = lastX;
HXDLIN( 143)						Float by1 = lastY;
HXDLIN( 143)						Float cx2 = nextX1;
HXDLIN( 143)						Float cy2 = nextY1;
HXDLIN( 143)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 143)						if (!(adjustWinding1)) {
HXDLIN( 143)							Float bx_1 = bx1;
HXDLIN( 143)							Float by_1 = by1;
HXLINE(  25)							bx1 = cx2;
HXLINE(  26)							by1 = cy2;
HXLINE(  27)							cx2 = bx_1;
HXLINE(  28)							cy2 = by_1;
            						}
HXLINE( 143)						{
HXDLIN( 143)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 143)							Float sx1 = (cy2 - cy);
HXDLIN( 143)							Float sy1 = (cx - cx2);
HXDLIN( 143)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 143)							Float tx1 = (cy - by1);
HXDLIN( 143)							Float ty1 = (bx1 - cx);
HXDLIN( 143)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 143)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 143)							if ((cx > bx1)) {
HXDLIN( 143)								if ((cx > cx2)) {
HXDLIN( 143)									int min4;
HXDLIN( 143)									if ((bx1 > cx2)) {
HXDLIN( 143)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 143)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 143)									int ii_min8 = min4;
HXDLIN( 143)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 143)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 143)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 143)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 143)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 143)								if ((bx1 > cx2)) {
HXDLIN( 143)									int min5;
HXDLIN( 143)									if ((cx > cx2)) {
HXDLIN( 143)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 143)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 143)									int ii_min10 = min5;
HXDLIN( 143)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 143)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 143)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 143)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 143)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 143)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 143)							if ((cy > by1)) {
HXDLIN( 143)								if ((cy > cy2)) {
HXDLIN( 143)									int min6;
HXDLIN( 143)									if ((by1 > cy2)) {
HXDLIN( 143)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 143)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 143)									int ii_min12 = min6;
HXDLIN( 143)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 143)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 143)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 143)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 143)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 143)								if ((by1 > cy2)) {
HXDLIN( 143)									int min7;
HXDLIN( 143)									if ((cy > cy2)) {
HXDLIN( 143)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 143)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 143)									int ii_min14 = min7;
HXDLIN( 143)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 143)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 143)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 143)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 143)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 143)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 143)							if (hasUndo1) {
HXDLIN( 143)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 143)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 143)								 ::Dynamic imageType1 = null();
HXDLIN( 143)								 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 143)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 143)								::Dynamic undoImage4;
HXDLIN( 143)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 143)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 143)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 143)										{
HXDLIN( 143)											b5->width = width1;
HXDLIN( 143)											b5->height = height1;
HXDLIN( 143)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 143)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 143)											{
HXDLIN( 143)												int len2 = b5->length;
HXDLIN( 143)												int w1 = 0;
HXDLIN( 143)												{
HXDLIN( 143)													int _g24 = 0;
HXDLIN( 143)													int _g25 = b5->height;
HXDLIN( 143)													while((_g24 < _g25)){
HXDLIN( 143)														_g24 = (_g24 + 1);
HXDLIN( 143)														int y4 = (_g24 - 1);
HXDLIN( 143)														{
HXDLIN( 143)															int _g26 = 0;
HXDLIN( 143)															int _g27 = b5->width;
HXDLIN( 143)															while((_g26 < _g27)){
HXDLIN( 143)																_g26 = (_g26 + 1);
HXDLIN( 143)																int x4 = (_g26 - 1);
HXDLIN( 143)																{
HXDLIN( 143)																	w1 = (w1 + 1);
HXDLIN( 143)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 143)																{
HXDLIN( 143)																	w1 = (w1 + 1);
HXDLIN( 143)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 143)																{
HXDLIN( 143)																	w1 = (w1 + 1);
HXDLIN( 143)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 143)																{
HXDLIN( 143)																	w1 = (w1 + 1);
HXDLIN( 143)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 143)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 143)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 143)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 143)										{
HXDLIN( 143)											a6->width = width1;
HXDLIN( 143)											a6->height = height1;
HXDLIN( 143)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 143)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 143)											{
HXDLIN( 143)												int _g28 = 0;
HXDLIN( 143)												int _g29 = a6->length;
HXDLIN( 143)												while((_g28 < _g29)){
HXDLIN( 143)													_g28 = (_g28 + 1);
HXDLIN( 143)													int i8 = (_g28 - 1);
HXDLIN( 143)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 143)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 143)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 143)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 143)										{
HXDLIN( 143)											b6->width = width1;
HXDLIN( 143)											b6->height = height1;
HXDLIN( 143)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 143)											int size1 = (b6->length * 4);
HXDLIN( 143)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 143)											{
HXDLIN( 143)												int _g30 = 0;
HXDLIN( 143)												int _g31 = b6->length;
HXDLIN( 143)												while((_g30 < _g31)){
HXDLIN( 143)													_g30 = (_g30 + 1);
HXDLIN( 143)													int i9 = (_g30 - 1);
HXDLIN( 143)													{
HXDLIN( 143)														 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 143)														bool undoImage5;
HXDLIN( 143)														if ((i9 >= 0)) {
HXDLIN( 143)															undoImage5 = (i9 < (this38->byteLength >> 2));
            														}
            														else {
HXDLIN( 143)															undoImage5 = false;
            														}
HXDLIN( 143)														if (undoImage5) {
HXDLIN( 143)															 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 143)															int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 143)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 143)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 143)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 143)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 143)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 143)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 143)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 143)										{
HXDLIN( 143)											v3->width = width1;
HXDLIN( 143)											v3->height = height1;
HXDLIN( 143)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 143)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 143)											{
HXDLIN( 143)												int _g32 = 0;
HXDLIN( 143)												int _g33 = v3->length;
HXDLIN( 143)												while((_g32 < _g33)){
HXDLIN( 143)													_g32 = (_g32 + 1);
HXDLIN( 143)													int i10 = (_g32 - 1);
HXDLIN( 143)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 143)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 143)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 143)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 143)										{
HXDLIN( 143)											b7->width = width1;
HXDLIN( 143)											b7->height = height1;
HXDLIN( 143)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 143)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 143)											{
HXDLIN( 143)												int len3 = b7->length;
HXDLIN( 143)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 143)												if (::hx::IsNull( d1->head )) {
HXDLIN( 143)													int _g34 = 0;
HXDLIN( 143)													int _g35 = len3;
HXDLIN( 143)													while((_g34 < _g35)){
HXDLIN( 143)														_g34 = (_g34 + 1);
HXDLIN( 143)														int i11 = (_g34 - 1);
HXDLIN( 143)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 143)													int _g36 = 0;
HXDLIN( 143)													int _g37 = len3;
HXDLIN( 143)													while((_g36 < _g37)){
HXDLIN( 143)														_g36 = (_g36 + 1);
HXDLIN( 143)														int i12 = (_g36 - 1);
HXDLIN( 143)														{
HXDLIN( 143)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 143)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 143)															{
HXDLIN( 143)																int _g38 = 0;
HXDLIN( 143)																int _g39 = i12;
HXDLIN( 143)																while((_g38 < _g39)){
HXDLIN( 143)																	_g38 = (_g38 + 1);
HXDLIN( 143)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 143)															if (::hx::IsNull( prev1 )) {
HXDLIN( 143)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 143)																l1 = null();
            															}
            															else {
HXDLIN( 143)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 143)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 143)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 143)								this37->image = undoImage4;
HXDLIN( 143)								this37->width = width1;
HXDLIN( 143)								this37->height = height1;
HXDLIN( 143)								this37->imageType = ( (int)(imageType1) );
HXDLIN( 143)								undoImage3 = this37;
HXDLIN( 143)								{
HXDLIN( 143)									int rectLeft1 = xIter31->start;
HXDLIN( 143)									int rectTop1 = yIter31->start;
HXDLIN( 143)									int rectRight1 = xIter31->max;
HXDLIN( 143)									bool forceClear1 = false;
HXDLIN( 143)									{
HXDLIN( 143)										int _g40 = rectTop1;
HXDLIN( 143)										int _g41 = yIter31->max;
HXDLIN( 143)										while((_g40 < _g41)){
HXDLIN( 143)											_g40 = (_g40 + 1);
HXDLIN( 143)											int dy1 = (_g40 - 1);
HXDLIN( 143)											{
HXDLIN( 143)												int _g42 = rectLeft1;
HXDLIN( 143)												int _g43 = rectRight1;
HXDLIN( 143)												while((_g42 < _g43)){
HXDLIN( 143)													_g42 = (_g42 + 1);
HXDLIN( 143)													int dx1 = (_g42 - 1);
HXDLIN( 143)													::Dynamic this39 = this36->image;
HXDLIN( 143)													int index5;
HXDLIN( 143)													if (this36->useVirtualPos) {
HXDLIN( 143)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            													}
            													else {
HXDLIN( 143)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            													}
HXDLIN( 143)													int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 143)													int col1;
HXDLIN( 143)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)														col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXDLIN( 143)														col1 = c4;
            													}
HXDLIN( 143)													bool _hx_tmp8;
HXDLIN( 143)													if (this36->useMask) {
HXDLIN( 143)														_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            													}
            													else {
HXDLIN( 143)														_hx_tmp8 = false;
            													}
HXDLIN( 143)													if (_hx_tmp8) {
HXDLIN( 143)														 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 143)														::Dynamic this41 = this40->image;
HXDLIN( 143)														int index6;
HXDLIN( 143)														if (this40->useVirtualPos) {
HXDLIN( 143)															index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            														}
            														else {
HXDLIN( 143)															index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            														}
HXDLIN( 143)														int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 143)														int v4;
HXDLIN( 143)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)															v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXDLIN( 143)															v4 = c5;
            														}
HXDLIN( 143)														int maskPixel1 = v4;
HXDLIN( 143)														int this42 = col1;
HXDLIN( 143)														if ((maskPixel1 == 0)) {
HXDLIN( 143)															col1 = this42;
            														}
            														else {
HXDLIN( 143)															Float m01;
HXDLIN( 143)															int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 143)															if ((this43 == 0)) {
HXDLIN( 143)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float m11;
HXDLIN( 143)															int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 143)															if ((this44 == 0)) {
HXDLIN( 143)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float m21;
HXDLIN( 143)															int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 143)															if ((this45 == 0)) {
HXDLIN( 143)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float m31;
HXDLIN( 143)															int this46 = (maskPixel1 & 255);
HXDLIN( 143)															if ((this46 == 0)) {
HXDLIN( 143)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 143)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 143)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 143)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 143)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 143)													if ((col1 != 0)) {
HXDLIN( 143)														int x5 = (dx1 - rectLeft1);
HXDLIN( 143)														int y5 = (dy1 - rectTop1);
HXDLIN( 143)														int c6 = col1;
HXDLIN( 143)														bool _hx_tmp9;
HXDLIN( 143)														if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 143)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 143)															_hx_tmp9 = false;
            														}
HXDLIN( 143)														if (_hx_tmp9) {
HXDLIN( 143)															int location2;
HXDLIN( 143)															if (undoImage3->useVirtualPos) {
HXDLIN( 143)																location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 143)																location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 143)															int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 143)															int this48;
HXDLIN( 143)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            															}
            															else {
HXDLIN( 143)																this48 = this47;
            															}
HXDLIN( 143)															Float a12;
HXDLIN( 143)															int this49 = ((this48 >> 24) & 255);
HXDLIN( 143)															if ((this49 == 0)) {
HXDLIN( 143)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float r12;
HXDLIN( 143)															int this50 = ((this48 >> 16) & 255);
HXDLIN( 143)															if ((this50 == 0)) {
HXDLIN( 143)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float g12;
HXDLIN( 143)															int this51 = ((this48 >> 8) & 255);
HXDLIN( 143)															if ((this51 == 0)) {
HXDLIN( 143)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float b13;
HXDLIN( 143)															int this52 = (this48 & 255);
HXDLIN( 143)															if ((this52 == 0)) {
HXDLIN( 143)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float a22;
HXDLIN( 143)															int this53 = ((col1 >> 24) & 255);
HXDLIN( 143)															if ((this53 == 0)) {
HXDLIN( 143)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float r22;
HXDLIN( 143)															int this54 = ((col1 >> 16) & 255);
HXDLIN( 143)															if ((this54 == 0)) {
HXDLIN( 143)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float g22;
HXDLIN( 143)															int this55 = ((col1 >> 8) & 255);
HXDLIN( 143)															if ((this55 == 0)) {
HXDLIN( 143)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float b23;
HXDLIN( 143)															int this56 = (col1 & 255);
HXDLIN( 143)															if ((this56 == 0)) {
HXDLIN( 143)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 143)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 143)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 143)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 143)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 143)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 143)															{
HXDLIN( 143)																int _hx_tmp10;
HXDLIN( 143)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 143)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 143)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 143)															::Dynamic this57 = undoImage3->image;
HXDLIN( 143)															int index7;
HXDLIN( 143)															if (undoImage3->useVirtualPos) {
HXDLIN( 143)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 143)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 143)															int _hx_tmp11;
HXDLIN( 143)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXDLIN( 143)																_hx_tmp11 = c6;
            															}
HXDLIN( 143)															::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 143)														if (forceClear1) {
HXDLIN( 143)															::Dynamic this58 = undoImage3->image;
HXDLIN( 143)															int x6 = (dx1 - rectLeft1);
HXDLIN( 143)															int y6 = (dy1 - rectTop1);
HXDLIN( 143)															int index8;
HXDLIN( 143)															if (undoImage3->useVirtualPos) {
HXDLIN( 143)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 143)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 143)															::iterMagic::Iimg_obj::set(this58,index8,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 143)							bool found1 = false;
HXDLIN( 143)							Float s1 = ((Float)0.);
HXDLIN( 143)							Float t1 = ((Float)0.);
HXDLIN( 143)							Float sxx1 = ((Float)0.);
HXDLIN( 143)							Float txx1 = ((Float)0.);
HXDLIN( 143)							{
HXDLIN( 143)								int _g_min2 = xIter31->start;
HXDLIN( 143)								int _g_max2 = xIter31->max;
HXDLIN( 143)								while((_g_min2 < _g_max2)){
HXDLIN( 143)									_g_min2 = (_g_min2 + 1);
HXDLIN( 143)									int x7 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)									found1 = false;
HXLINE( 143)									{
HXDLIN( 143)										int _g_min3 = yIter31->start;
HXDLIN( 143)										int _g_max3 = yIter31->max;
HXDLIN( 143)										while((_g_min3 < _g_max3)){
HXDLIN( 143)											_g_min3 = (_g_min3 + 1);
HXDLIN( 143)											int y7 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 143)											bool _hx_tmp12;
HXDLIN( 143)											if (!((s1 <= 0))) {
HXDLIN( 143)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 143)												_hx_tmp12 = true;
            											}
HXDLIN( 143)											if (_hx_tmp12) {
HXDLIN( 143)												if (found1) {
HXDLIN( 143)													goto _hx_goto_240;
            												}
            											}
            											else {
HXDLIN( 143)												if (((s1 + t1) < A1)) {
HXDLIN( 143)													{
HXDLIN( 143)														int c7 = color;
HXDLIN( 143)														bool _hx_tmp13;
HXDLIN( 143)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 143)															_hx_tmp13 = this36->transparent;
            														}
            														else {
HXDLIN( 143)															_hx_tmp13 = false;
            														}
HXDLIN( 143)														if (_hx_tmp13) {
HXDLIN( 143)															int location3;
HXDLIN( 143)															if (this36->useVirtualPos) {
HXDLIN( 143)																location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 143)																location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 143)															int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 143)															int this60;
HXDLIN( 143)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            															}
            															else {
HXDLIN( 143)																this60 = this59;
            															}
HXDLIN( 143)															Float a13;
HXDLIN( 143)															int this61 = ((this60 >> 24) & 255);
HXDLIN( 143)															if ((this61 == 0)) {
HXDLIN( 143)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float r13;
HXDLIN( 143)															int this62 = ((this60 >> 16) & 255);
HXDLIN( 143)															if ((this62 == 0)) {
HXDLIN( 143)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float g13;
HXDLIN( 143)															int this63 = ((this60 >> 8) & 255);
HXDLIN( 143)															if ((this63 == 0)) {
HXDLIN( 143)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float b14;
HXDLIN( 143)															int this64 = (this60 & 255);
HXDLIN( 143)															if ((this64 == 0)) {
HXDLIN( 143)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float a23;
HXDLIN( 143)															int this65 = ((color >> 24) & 255);
HXDLIN( 143)															if ((this65 == 0)) {
HXDLIN( 143)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float r23;
HXDLIN( 143)															int this66 = ((color >> 16) & 255);
HXDLIN( 143)															if ((this66 == 0)) {
HXDLIN( 143)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float g23;
HXDLIN( 143)															int this67 = ((color >> 8) & 255);
HXDLIN( 143)															if ((this67 == 0)) {
HXDLIN( 143)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float b24;
HXDLIN( 143)															int this68 = (color & 255);
HXDLIN( 143)															if ((this68 == 0)) {
HXDLIN( 143)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 143)																b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 143)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 143)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 143)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 143)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 143)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 143)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 143)															{
HXDLIN( 143)																int _hx_tmp14;
HXDLIN( 143)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 143)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 143)																::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 143)															::Dynamic this69 = this36->image;
HXDLIN( 143)															int index9;
HXDLIN( 143)															if (this36->useVirtualPos) {
HXDLIN( 143)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 143)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 143)															int _hx_tmp15;
HXDLIN( 143)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 143)																_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 143)																_hx_tmp15 = c7;
            															}
HXDLIN( 143)															::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXDLIN( 143)													if (found1) {
HXDLIN( 143)														goto _hx_goto_240;
            													}
            												}
            											}
            										}
            										_hx_goto_240:;
            									}
            								}
            							}
HXDLIN( 143)							if ((hasHit1 == true)) {
HXDLIN( 143)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 143)								if (hasUndo1) {
HXDLIN( 143)									v5->undoImage = undoImage3;
HXDLIN( 143)									v5->undoX = xIter31->start;
HXDLIN( 143)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  46)				lastX = nextX1;
HXLINE(  47)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,quadrantIII,(void))

void FillShape_Impl__obj::quadrantIV( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_156_quadrantIV)
HXDLIN( 156)		 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 156)		if (::hx::IsNull( targetError )) {
HXLINE( 113)			targetError = ((Float)1.05);
            		}
HXLINE( 156)		Float rSmall;
HXDLIN( 156)		if ((rx > ry)) {
HXDLIN( 156)			rSmall = ry;
            		}
            		else {
HXDLIN( 156)			rSmall = rx;
            		}
HXDLIN( 156)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 156)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 156)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 156)		int noSides;
HXDLIN( 156)		if ((result < 12)) {
HXDLIN( 156)			noSides = 12;
            		}
            		else {
HXDLIN( 156)			if ((result > 500)) {
HXDLIN( 156)				noSides = 500;
            			}
            			else {
HXDLIN( 156)				noSides = result;
            			}
            		}
HXDLIN( 156)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 156)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 156)		Float omega = ( (Float)(0) );
HXDLIN( 156)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 156)		Float lastX = ((Float)0.);
HXDLIN( 156)		Float lastY = ((Float)0.);
HXDLIN( 156)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  23)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  24)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  26)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 156)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 156)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 156)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 156)			{
HXDLIN( 156)				int _g = 0;
HXDLIN( 156)				int _g1 = (quarter + 1);
HXDLIN( 156)				while((_g < _g1)){
HXDLIN( 156)					_g = (_g + 1);
HXDLIN( 156)					int i = (_g - 1);
HXDLIN( 156)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 156)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 156)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 156)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 156)					{
HXDLIN( 156)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 156)						bool hasHit = false;
HXDLIN( 156)						bool hasUndo = false;
HXDLIN( 156)						{
HXDLIN( 156)							Float bx = lastX;
HXDLIN( 156)							Float by = lastY;
HXDLIN( 156)							Float cx1 = nextX;
HXDLIN( 156)							Float cy1 = nextY;
HXDLIN( 156)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 156)							if (!(adjustWinding)) {
HXDLIN( 156)								Float bx_ = bx;
HXDLIN( 156)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE( 156)							{
HXDLIN( 156)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 156)								Float sx = (cy1 - cy);
HXDLIN( 156)								Float sy = (cx - cx1);
HXDLIN( 156)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 156)								Float tx = (cy - by);
HXDLIN( 156)								Float ty = (bx - cx);
HXDLIN( 156)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 156)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 156)								if ((cx > bx)) {
HXDLIN( 156)									if ((cx > cx1)) {
HXDLIN( 156)										int min;
HXDLIN( 156)										if ((bx > cx1)) {
HXDLIN( 156)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 156)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 156)										int ii_min = min;
HXDLIN( 156)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 156)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 156)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 156)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 156)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 156)									if ((bx > cx1)) {
HXDLIN( 156)										int min1;
HXDLIN( 156)										if ((cx > cx1)) {
HXDLIN( 156)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 156)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 156)										int ii_min2 = min1;
HXDLIN( 156)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 156)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 156)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 156)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 156)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 156)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 156)								if ((cy > by)) {
HXDLIN( 156)									if ((cy > cy1)) {
HXDLIN( 156)										int min2;
HXDLIN( 156)										if ((by > cy1)) {
HXDLIN( 156)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 156)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 156)										int ii_min4 = min2;
HXDLIN( 156)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 156)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 156)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 156)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 156)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 156)									if ((by > cy1)) {
HXDLIN( 156)										int min3;
HXDLIN( 156)										if ((cy > cy1)) {
HXDLIN( 156)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 156)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 156)										int ii_min6 = min3;
HXDLIN( 156)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 156)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 156)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 156)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 156)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 156)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 156)								if (hasUndo) {
HXDLIN( 156)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 156)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 156)									 ::Dynamic imageType = null();
HXDLIN( 156)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 156)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 156)									::Dynamic undoImage1;
HXDLIN( 156)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 156)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 156)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 156)											{
HXDLIN( 156)												b->width = width;
HXDLIN( 156)												b->height = height;
HXDLIN( 156)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 156)												{
HXDLIN( 156)													int len = b->length;
HXDLIN( 156)													int w = 0;
HXDLIN( 156)													{
HXDLIN( 156)														int _g2 = 0;
HXDLIN( 156)														int _g3 = b->height;
HXDLIN( 156)														while((_g2 < _g3)){
HXDLIN( 156)															_g2 = (_g2 + 1);
HXDLIN( 156)															int y = (_g2 - 1);
HXDLIN( 156)															{
HXDLIN( 156)																int _g4 = 0;
HXDLIN( 156)																int _g5 = b->width;
HXDLIN( 156)																while((_g4 < _g5)){
HXDLIN( 156)																	_g4 = (_g4 + 1);
HXDLIN( 156)																	int x = (_g4 - 1);
HXDLIN( 156)																	{
HXDLIN( 156)																		w = (w + 1);
HXDLIN( 156)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 156)																	{
HXDLIN( 156)																		w = (w + 1);
HXDLIN( 156)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 156)																	{
HXDLIN( 156)																		w = (w + 1);
HXDLIN( 156)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 156)																	{
HXDLIN( 156)																		w = (w + 1);
HXDLIN( 156)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 156)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 156)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 156)											{
HXDLIN( 156)												a->width = width;
HXDLIN( 156)												a->height = height;
HXDLIN( 156)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 156)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)												{
HXDLIN( 156)													int _g6 = 0;
HXDLIN( 156)													int _g7 = a->length;
HXDLIN( 156)													while((_g6 < _g7)){
HXDLIN( 156)														_g6 = (_g6 + 1);
HXDLIN( 156)														int i1 = (_g6 - 1);
HXDLIN( 156)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 156)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 156)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 156)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 156)											{
HXDLIN( 156)												b1->width = width;
HXDLIN( 156)												b1->height = height;
HXDLIN( 156)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)												int size = (b1->length * 4);
HXDLIN( 156)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 156)												{
HXDLIN( 156)													int _g8 = 0;
HXDLIN( 156)													int _g9 = b1->length;
HXDLIN( 156)													while((_g8 < _g9)){
HXDLIN( 156)														_g8 = (_g8 + 1);
HXDLIN( 156)														int i2 = (_g8 - 1);
HXDLIN( 156)														{
HXDLIN( 156)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 156)															bool undoImage2;
HXDLIN( 156)															if ((i2 >= 0)) {
HXDLIN( 156)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 156)																undoImage2 = false;
            															}
HXDLIN( 156)															if (undoImage2) {
HXDLIN( 156)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 156)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 156)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 156)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 156)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 156)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 156)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 156)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 156)											{
HXDLIN( 156)												v->width = width;
HXDLIN( 156)												v->height = height;
HXDLIN( 156)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 156)												{
HXDLIN( 156)													int _g10 = 0;
HXDLIN( 156)													int _g11 = v->length;
HXDLIN( 156)													while((_g10 < _g11)){
HXDLIN( 156)														_g10 = (_g10 + 1);
HXDLIN( 156)														int i3 = (_g10 - 1);
HXDLIN( 156)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 156)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 156)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 156)											{
HXDLIN( 156)												b2->width = width;
HXDLIN( 156)												b2->height = height;
HXDLIN( 156)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 156)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 156)												{
HXDLIN( 156)													int len1 = b2->length;
HXDLIN( 156)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 156)													if (::hx::IsNull( d->head )) {
HXDLIN( 156)														int _g12 = 0;
HXDLIN( 156)														int _g13 = len1;
HXDLIN( 156)														while((_g12 < _g13)){
HXDLIN( 156)															_g12 = (_g12 + 1);
HXDLIN( 156)															int i4 = (_g12 - 1);
HXDLIN( 156)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 156)														int _g14 = 0;
HXDLIN( 156)														int _g15 = len1;
HXDLIN( 156)														while((_g14 < _g15)){
HXDLIN( 156)															_g14 = (_g14 + 1);
HXDLIN( 156)															int i5 = (_g14 - 1);
HXDLIN( 156)															{
HXDLIN( 156)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 156)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 156)																{
HXDLIN( 156)																	int _g16 = 0;
HXDLIN( 156)																	int _g17 = i5;
HXDLIN( 156)																	while((_g16 < _g17)){
HXDLIN( 156)																		_g16 = (_g16 + 1);
HXDLIN( 156)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 156)																if (::hx::IsNull( prev )) {
HXDLIN( 156)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 156)																	l = null();
            																}
            																else {
HXDLIN( 156)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 156)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 156)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 156)									this3->image = undoImage1;
HXDLIN( 156)									this3->width = width;
HXDLIN( 156)									this3->height = height;
HXDLIN( 156)									this3->imageType = ( (int)(imageType) );
HXDLIN( 156)									undoImage = this3;
HXDLIN( 156)									{
HXDLIN( 156)										int rectLeft = xIter3->start;
HXDLIN( 156)										int rectTop = yIter3->start;
HXDLIN( 156)										int rectRight = xIter3->max;
HXDLIN( 156)										bool forceClear = false;
HXDLIN( 156)										{
HXDLIN( 156)											int _g18 = rectTop;
HXDLIN( 156)											int _g19 = yIter3->max;
HXDLIN( 156)											while((_g18 < _g19)){
HXDLIN( 156)												_g18 = (_g18 + 1);
HXDLIN( 156)												int dy = (_g18 - 1);
HXDLIN( 156)												{
HXDLIN( 156)													int _g20 = rectLeft;
HXDLIN( 156)													int _g21 = rectRight;
HXDLIN( 156)													while((_g20 < _g21)){
HXDLIN( 156)														_g20 = (_g20 + 1);
HXDLIN( 156)														int dx = (_g20 - 1);
HXDLIN( 156)														::Dynamic this5 = this2->image;
HXDLIN( 156)														int index;
HXDLIN( 156)														if (this2->useVirtualPos) {
HXDLIN( 156)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 156)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 156)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 156)														int col;
HXDLIN( 156)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 156)															col = c;
            														}
HXDLIN( 156)														bool _hx_tmp;
HXDLIN( 156)														if (this2->useMask) {
HXDLIN( 156)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 156)															_hx_tmp = false;
            														}
HXDLIN( 156)														if (_hx_tmp) {
HXDLIN( 156)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 156)															::Dynamic this7 = this6->image;
HXDLIN( 156)															int index1;
HXDLIN( 156)															if (this6->useVirtualPos) {
HXDLIN( 156)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 156)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 156)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 156)															int v1;
HXDLIN( 156)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 156)																v1 = c1;
            															}
HXDLIN( 156)															int maskPixel = v1;
HXDLIN( 156)															int this8 = col;
HXDLIN( 156)															if ((maskPixel == 0)) {
HXDLIN( 156)																col = this8;
            															}
            															else {
HXDLIN( 156)																Float m0;
HXDLIN( 156)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 156)																if ((this9 == 0)) {
HXDLIN( 156)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float m1;
HXDLIN( 156)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 156)																if ((this10 == 0)) {
HXDLIN( 156)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float m2;
HXDLIN( 156)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 156)																if ((this11 == 0)) {
HXDLIN( 156)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float m3;
HXDLIN( 156)																int this12 = (maskPixel & 255);
HXDLIN( 156)																if ((this12 == 0)) {
HXDLIN( 156)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 156)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 156)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 156)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 156)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 156)														if ((col != 0)) {
HXDLIN( 156)															int x1 = (dx - rectLeft);
HXDLIN( 156)															int y1 = (dy - rectTop);
HXDLIN( 156)															int c2 = col;
HXDLIN( 156)															bool _hx_tmp1;
HXDLIN( 156)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 156)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 156)																_hx_tmp1 = false;
            															}
HXDLIN( 156)															if (_hx_tmp1) {
HXDLIN( 156)																int location;
HXDLIN( 156)																if (undoImage->useVirtualPos) {
HXDLIN( 156)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 156)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 156)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 156)																int this14;
HXDLIN( 156)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 156)																	this14 = this13;
            																}
HXDLIN( 156)																Float a1;
HXDLIN( 156)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 156)																if ((this15 == 0)) {
HXDLIN( 156)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float r1;
HXDLIN( 156)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 156)																if ((this16 == 0)) {
HXDLIN( 156)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float g1;
HXDLIN( 156)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 156)																if ((this17 == 0)) {
HXDLIN( 156)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float b11;
HXDLIN( 156)																int this18 = (this14 & 255);
HXDLIN( 156)																if ((this18 == 0)) {
HXDLIN( 156)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float a2;
HXDLIN( 156)																int this19 = ((col >> 24) & 255);
HXDLIN( 156)																if ((this19 == 0)) {
HXDLIN( 156)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float r2;
HXDLIN( 156)																int this20 = ((col >> 16) & 255);
HXDLIN( 156)																if ((this20 == 0)) {
HXDLIN( 156)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float g2;
HXDLIN( 156)																int this21 = ((col >> 8) & 255);
HXDLIN( 156)																if ((this21 == 0)) {
HXDLIN( 156)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float b21;
HXDLIN( 156)																int this22 = (col & 255);
HXDLIN( 156)																if ((this22 == 0)) {
HXDLIN( 156)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 156)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 156)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 156)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 156)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 156)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 156)																{
HXDLIN( 156)																	int _hx_tmp2;
HXDLIN( 156)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 156)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 156)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 156)																::Dynamic this23 = undoImage->image;
HXDLIN( 156)																int index2;
HXDLIN( 156)																if (undoImage->useVirtualPos) {
HXDLIN( 156)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 156)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 156)																int _hx_tmp3;
HXDLIN( 156)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 156)																	_hx_tmp3 = c2;
            																}
HXDLIN( 156)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 156)															if (forceClear) {
HXDLIN( 156)																::Dynamic this24 = undoImage->image;
HXDLIN( 156)																int x2 = (dx - rectLeft);
HXDLIN( 156)																int y2 = (dy - rectTop);
HXDLIN( 156)																int index3;
HXDLIN( 156)																if (undoImage->useVirtualPos) {
HXDLIN( 156)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 156)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 156)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 156)								bool found = false;
HXDLIN( 156)								Float s = ((Float)0.);
HXDLIN( 156)								Float t = ((Float)0.);
HXDLIN( 156)								Float sxx = ((Float)0.);
HXDLIN( 156)								Float txx = ((Float)0.);
HXDLIN( 156)								{
HXDLIN( 156)									int _g_min = xIter3->start;
HXDLIN( 156)									int _g_max = xIter3->max;
HXDLIN( 156)									while((_g_min < _g_max)){
HXDLIN( 156)										_g_min = (_g_min + 1);
HXDLIN( 156)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE( 156)										{
HXDLIN( 156)											int _g_min1 = yIter3->start;
HXDLIN( 156)											int _g_max1 = yIter3->max;
HXDLIN( 156)											while((_g_min1 < _g_max1)){
HXDLIN( 156)												_g_min1 = (_g_min1 + 1);
HXDLIN( 156)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 156)												bool _hx_tmp4;
HXDLIN( 156)												if (!((s <= 0))) {
HXDLIN( 156)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 156)													_hx_tmp4 = true;
            												}
HXDLIN( 156)												if (_hx_tmp4) {
HXDLIN( 156)													if (found) {
HXDLIN( 156)														goto _hx_goto_254;
            													}
            												}
            												else {
HXDLIN( 156)													if (((s + t) < A)) {
HXDLIN( 156)														{
HXDLIN( 156)															int c3 = color;
HXDLIN( 156)															bool _hx_tmp5;
HXDLIN( 156)															if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 156)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 156)																_hx_tmp5 = false;
            															}
HXDLIN( 156)															if (_hx_tmp5) {
HXDLIN( 156)																int location1;
HXDLIN( 156)																if (this2->useVirtualPos) {
HXDLIN( 156)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 156)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 156)																int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 156)																int this26;
HXDLIN( 156)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXDLIN( 156)																	this26 = this25;
            																}
HXDLIN( 156)																Float a11;
HXDLIN( 156)																int this27 = ((this26 >> 24) & 255);
HXDLIN( 156)																if ((this27 == 0)) {
HXDLIN( 156)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float r11;
HXDLIN( 156)																int this28 = ((this26 >> 16) & 255);
HXDLIN( 156)																if ((this28 == 0)) {
HXDLIN( 156)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float g11;
HXDLIN( 156)																int this29 = ((this26 >> 8) & 255);
HXDLIN( 156)																if ((this29 == 0)) {
HXDLIN( 156)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float b12;
HXDLIN( 156)																int this30 = (this26 & 255);
HXDLIN( 156)																if ((this30 == 0)) {
HXDLIN( 156)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float a21;
HXDLIN( 156)																int this31 = ((color >> 24) & 255);
HXDLIN( 156)																if ((this31 == 0)) {
HXDLIN( 156)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float r21;
HXDLIN( 156)																int this32 = ((color >> 16) & 255);
HXDLIN( 156)																if ((this32 == 0)) {
HXDLIN( 156)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float g21;
HXDLIN( 156)																int this33 = ((color >> 8) & 255);
HXDLIN( 156)																if ((this33 == 0)) {
HXDLIN( 156)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float b22;
HXDLIN( 156)																int this34 = (color & 255);
HXDLIN( 156)																if ((this34 == 0)) {
HXDLIN( 156)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 156)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 156)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 156)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 156)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 156)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 156)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 156)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 156)																{
HXDLIN( 156)																	int _hx_tmp6;
HXDLIN( 156)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 156)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 156)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 156)																::Dynamic this35 = this2->image;
HXDLIN( 156)																int index4;
HXDLIN( 156)																if (this2->useVirtualPos) {
HXDLIN( 156)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 156)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 156)																int _hx_tmp7;
HXDLIN( 156)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXDLIN( 156)																	_hx_tmp7 = c3;
            																}
HXDLIN( 156)																::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXDLIN( 156)														if (found) {
HXDLIN( 156)															goto _hx_goto_254;
            														}
            													}
            												}
            											}
            											_hx_goto_254:;
            										}
            									}
            								}
HXDLIN( 156)								if ((hasHit == true)) {
HXDLIN( 156)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 156)									if (hasUndo) {
HXDLIN( 156)										v2->undoImage = undoImage;
HXDLIN( 156)										v2->undoX = xIter3->start;
HXDLIN( 156)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  38)					lastX = nextX;
HXLINE(  39)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 156)			int _g22 = 0;
HXDLIN( 156)			int _g23 = (quarter + 1);
HXDLIN( 156)			while((_g22 < _g23)){
HXDLIN( 156)				_g22 = (_g22 + 1);
HXDLIN( 156)				int i7 = (_g22 - 1);
HXDLIN( 156)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 156)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 156)				{
HXDLIN( 156)					 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 156)					bool hasHit1 = false;
HXDLIN( 156)					bool hasUndo1 = false;
HXDLIN( 156)					{
HXDLIN( 156)						Float bx1 = lastX;
HXDLIN( 156)						Float by1 = lastY;
HXDLIN( 156)						Float cx2 = nextX1;
HXDLIN( 156)						Float cy2 = nextY1;
HXDLIN( 156)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 156)						if (!(adjustWinding1)) {
HXDLIN( 156)							Float bx_1 = bx1;
HXDLIN( 156)							Float by_1 = by1;
HXLINE(  25)							bx1 = cx2;
HXLINE(  26)							by1 = cy2;
HXLINE(  27)							cx2 = bx_1;
HXLINE(  28)							cy2 = by_1;
            						}
HXLINE( 156)						{
HXDLIN( 156)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 156)							Float sx1 = (cy2 - cy);
HXDLIN( 156)							Float sy1 = (cx - cx2);
HXDLIN( 156)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 156)							Float tx1 = (cy - by1);
HXDLIN( 156)							Float ty1 = (bx1 - cx);
HXDLIN( 156)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 156)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 156)							if ((cx > bx1)) {
HXDLIN( 156)								if ((cx > cx2)) {
HXDLIN( 156)									int min4;
HXDLIN( 156)									if ((bx1 > cx2)) {
HXDLIN( 156)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 156)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 156)									int ii_min8 = min4;
HXDLIN( 156)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 156)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 156)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 156)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 156)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 156)								if ((bx1 > cx2)) {
HXDLIN( 156)									int min5;
HXDLIN( 156)									if ((cx > cx2)) {
HXDLIN( 156)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 156)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 156)									int ii_min10 = min5;
HXDLIN( 156)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 156)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 156)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 156)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 156)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 156)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 156)							if ((cy > by1)) {
HXDLIN( 156)								if ((cy > cy2)) {
HXDLIN( 156)									int min6;
HXDLIN( 156)									if ((by1 > cy2)) {
HXDLIN( 156)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 156)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 156)									int ii_min12 = min6;
HXDLIN( 156)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 156)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 156)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 156)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 156)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 156)								if ((by1 > cy2)) {
HXDLIN( 156)									int min7;
HXDLIN( 156)									if ((cy > cy2)) {
HXDLIN( 156)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 156)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 156)									int ii_min14 = min7;
HXDLIN( 156)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 156)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 156)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 156)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 156)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 156)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 156)							if (hasUndo1) {
HXDLIN( 156)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 156)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 156)								 ::Dynamic imageType1 = null();
HXDLIN( 156)								 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 156)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 156)								::Dynamic undoImage4;
HXDLIN( 156)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 156)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 156)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 156)										{
HXDLIN( 156)											b5->width = width1;
HXDLIN( 156)											b5->height = height1;
HXDLIN( 156)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 156)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 156)											{
HXDLIN( 156)												int len2 = b5->length;
HXDLIN( 156)												int w1 = 0;
HXDLIN( 156)												{
HXDLIN( 156)													int _g24 = 0;
HXDLIN( 156)													int _g25 = b5->height;
HXDLIN( 156)													while((_g24 < _g25)){
HXDLIN( 156)														_g24 = (_g24 + 1);
HXDLIN( 156)														int y4 = (_g24 - 1);
HXDLIN( 156)														{
HXDLIN( 156)															int _g26 = 0;
HXDLIN( 156)															int _g27 = b5->width;
HXDLIN( 156)															while((_g26 < _g27)){
HXDLIN( 156)																_g26 = (_g26 + 1);
HXDLIN( 156)																int x4 = (_g26 - 1);
HXDLIN( 156)																{
HXDLIN( 156)																	w1 = (w1 + 1);
HXDLIN( 156)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 156)																{
HXDLIN( 156)																	w1 = (w1 + 1);
HXDLIN( 156)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 156)																{
HXDLIN( 156)																	w1 = (w1 + 1);
HXDLIN( 156)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 156)																{
HXDLIN( 156)																	w1 = (w1 + 1);
HXDLIN( 156)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 156)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 156)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 156)										{
HXDLIN( 156)											a6->width = width1;
HXDLIN( 156)											a6->height = height1;
HXDLIN( 156)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 156)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 156)											{
HXDLIN( 156)												int _g28 = 0;
HXDLIN( 156)												int _g29 = a6->length;
HXDLIN( 156)												while((_g28 < _g29)){
HXDLIN( 156)													_g28 = (_g28 + 1);
HXDLIN( 156)													int i8 = (_g28 - 1);
HXDLIN( 156)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 156)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 156)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 156)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 156)										{
HXDLIN( 156)											b6->width = width1;
HXDLIN( 156)											b6->height = height1;
HXDLIN( 156)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 156)											int size1 = (b6->length * 4);
HXDLIN( 156)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 156)											{
HXDLIN( 156)												int _g30 = 0;
HXDLIN( 156)												int _g31 = b6->length;
HXDLIN( 156)												while((_g30 < _g31)){
HXDLIN( 156)													_g30 = (_g30 + 1);
HXDLIN( 156)													int i9 = (_g30 - 1);
HXDLIN( 156)													{
HXDLIN( 156)														 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 156)														bool undoImage5;
HXDLIN( 156)														if ((i9 >= 0)) {
HXDLIN( 156)															undoImage5 = (i9 < (this38->byteLength >> 2));
            														}
            														else {
HXDLIN( 156)															undoImage5 = false;
            														}
HXDLIN( 156)														if (undoImage5) {
HXDLIN( 156)															 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 156)															int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 156)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 156)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 156)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 156)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 156)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 156)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 156)										{
HXDLIN( 156)											v3->width = width1;
HXDLIN( 156)											v3->height = height1;
HXDLIN( 156)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 156)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 156)											{
HXDLIN( 156)												int _g32 = 0;
HXDLIN( 156)												int _g33 = v3->length;
HXDLIN( 156)												while((_g32 < _g33)){
HXDLIN( 156)													_g32 = (_g32 + 1);
HXDLIN( 156)													int i10 = (_g32 - 1);
HXDLIN( 156)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 156)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 156)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 156)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 156)										{
HXDLIN( 156)											b7->width = width1;
HXDLIN( 156)											b7->height = height1;
HXDLIN( 156)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 156)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 156)											{
HXDLIN( 156)												int len3 = b7->length;
HXDLIN( 156)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 156)												if (::hx::IsNull( d1->head )) {
HXDLIN( 156)													int _g34 = 0;
HXDLIN( 156)													int _g35 = len3;
HXDLIN( 156)													while((_g34 < _g35)){
HXDLIN( 156)														_g34 = (_g34 + 1);
HXDLIN( 156)														int i11 = (_g34 - 1);
HXDLIN( 156)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 156)													int _g36 = 0;
HXDLIN( 156)													int _g37 = len3;
HXDLIN( 156)													while((_g36 < _g37)){
HXDLIN( 156)														_g36 = (_g36 + 1);
HXDLIN( 156)														int i12 = (_g36 - 1);
HXDLIN( 156)														{
HXDLIN( 156)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 156)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 156)															{
HXDLIN( 156)																int _g38 = 0;
HXDLIN( 156)																int _g39 = i12;
HXDLIN( 156)																while((_g38 < _g39)){
HXDLIN( 156)																	_g38 = (_g38 + 1);
HXDLIN( 156)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 156)															if (::hx::IsNull( prev1 )) {
HXDLIN( 156)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 156)																l1 = null();
            															}
            															else {
HXDLIN( 156)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 156)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 156)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 156)								this37->image = undoImage4;
HXDLIN( 156)								this37->width = width1;
HXDLIN( 156)								this37->height = height1;
HXDLIN( 156)								this37->imageType = ( (int)(imageType1) );
HXDLIN( 156)								undoImage3 = this37;
HXDLIN( 156)								{
HXDLIN( 156)									int rectLeft1 = xIter31->start;
HXDLIN( 156)									int rectTop1 = yIter31->start;
HXDLIN( 156)									int rectRight1 = xIter31->max;
HXDLIN( 156)									bool forceClear1 = false;
HXDLIN( 156)									{
HXDLIN( 156)										int _g40 = rectTop1;
HXDLIN( 156)										int _g41 = yIter31->max;
HXDLIN( 156)										while((_g40 < _g41)){
HXDLIN( 156)											_g40 = (_g40 + 1);
HXDLIN( 156)											int dy1 = (_g40 - 1);
HXDLIN( 156)											{
HXDLIN( 156)												int _g42 = rectLeft1;
HXDLIN( 156)												int _g43 = rectRight1;
HXDLIN( 156)												while((_g42 < _g43)){
HXDLIN( 156)													_g42 = (_g42 + 1);
HXDLIN( 156)													int dx1 = (_g42 - 1);
HXDLIN( 156)													::Dynamic this39 = this36->image;
HXDLIN( 156)													int index5;
HXDLIN( 156)													if (this36->useVirtualPos) {
HXDLIN( 156)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            													}
            													else {
HXDLIN( 156)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            													}
HXDLIN( 156)													int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 156)													int col1;
HXDLIN( 156)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)														col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXDLIN( 156)														col1 = c4;
            													}
HXDLIN( 156)													bool _hx_tmp8;
HXDLIN( 156)													if (this36->useMask) {
HXDLIN( 156)														_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            													}
            													else {
HXDLIN( 156)														_hx_tmp8 = false;
            													}
HXDLIN( 156)													if (_hx_tmp8) {
HXDLIN( 156)														 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 156)														::Dynamic this41 = this40->image;
HXDLIN( 156)														int index6;
HXDLIN( 156)														if (this40->useVirtualPos) {
HXDLIN( 156)															index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            														}
            														else {
HXDLIN( 156)															index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            														}
HXDLIN( 156)														int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 156)														int v4;
HXDLIN( 156)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)															v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXDLIN( 156)															v4 = c5;
            														}
HXDLIN( 156)														int maskPixel1 = v4;
HXDLIN( 156)														int this42 = col1;
HXDLIN( 156)														if ((maskPixel1 == 0)) {
HXDLIN( 156)															col1 = this42;
            														}
            														else {
HXDLIN( 156)															Float m01;
HXDLIN( 156)															int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 156)															if ((this43 == 0)) {
HXDLIN( 156)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float m11;
HXDLIN( 156)															int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 156)															if ((this44 == 0)) {
HXDLIN( 156)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float m21;
HXDLIN( 156)															int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 156)															if ((this45 == 0)) {
HXDLIN( 156)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float m31;
HXDLIN( 156)															int this46 = (maskPixel1 & 255);
HXDLIN( 156)															if ((this46 == 0)) {
HXDLIN( 156)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 156)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 156)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 156)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 156)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 156)													if ((col1 != 0)) {
HXDLIN( 156)														int x5 = (dx1 - rectLeft1);
HXDLIN( 156)														int y5 = (dy1 - rectTop1);
HXDLIN( 156)														int c6 = col1;
HXDLIN( 156)														bool _hx_tmp9;
HXDLIN( 156)														if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 156)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 156)															_hx_tmp9 = false;
            														}
HXDLIN( 156)														if (_hx_tmp9) {
HXDLIN( 156)															int location2;
HXDLIN( 156)															if (undoImage3->useVirtualPos) {
HXDLIN( 156)																location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 156)																location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 156)															int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 156)															int this48;
HXDLIN( 156)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            															}
            															else {
HXDLIN( 156)																this48 = this47;
            															}
HXDLIN( 156)															Float a12;
HXDLIN( 156)															int this49 = ((this48 >> 24) & 255);
HXDLIN( 156)															if ((this49 == 0)) {
HXDLIN( 156)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float r12;
HXDLIN( 156)															int this50 = ((this48 >> 16) & 255);
HXDLIN( 156)															if ((this50 == 0)) {
HXDLIN( 156)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float g12;
HXDLIN( 156)															int this51 = ((this48 >> 8) & 255);
HXDLIN( 156)															if ((this51 == 0)) {
HXDLIN( 156)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float b13;
HXDLIN( 156)															int this52 = (this48 & 255);
HXDLIN( 156)															if ((this52 == 0)) {
HXDLIN( 156)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float a22;
HXDLIN( 156)															int this53 = ((col1 >> 24) & 255);
HXDLIN( 156)															if ((this53 == 0)) {
HXDLIN( 156)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float r22;
HXDLIN( 156)															int this54 = ((col1 >> 16) & 255);
HXDLIN( 156)															if ((this54 == 0)) {
HXDLIN( 156)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float g22;
HXDLIN( 156)															int this55 = ((col1 >> 8) & 255);
HXDLIN( 156)															if ((this55 == 0)) {
HXDLIN( 156)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float b23;
HXDLIN( 156)															int this56 = (col1 & 255);
HXDLIN( 156)															if ((this56 == 0)) {
HXDLIN( 156)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 156)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 156)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 156)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 156)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 156)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 156)															{
HXDLIN( 156)																int _hx_tmp10;
HXDLIN( 156)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 156)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 156)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 156)															::Dynamic this57 = undoImage3->image;
HXDLIN( 156)															int index7;
HXDLIN( 156)															if (undoImage3->useVirtualPos) {
HXDLIN( 156)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 156)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 156)															int _hx_tmp11;
HXDLIN( 156)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXDLIN( 156)																_hx_tmp11 = c6;
            															}
HXDLIN( 156)															::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 156)														if (forceClear1) {
HXDLIN( 156)															::Dynamic this58 = undoImage3->image;
HXDLIN( 156)															int x6 = (dx1 - rectLeft1);
HXDLIN( 156)															int y6 = (dy1 - rectTop1);
HXDLIN( 156)															int index8;
HXDLIN( 156)															if (undoImage3->useVirtualPos) {
HXDLIN( 156)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 156)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 156)															::iterMagic::Iimg_obj::set(this58,index8,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 156)							bool found1 = false;
HXDLIN( 156)							Float s1 = ((Float)0.);
HXDLIN( 156)							Float t1 = ((Float)0.);
HXDLIN( 156)							Float sxx1 = ((Float)0.);
HXDLIN( 156)							Float txx1 = ((Float)0.);
HXDLIN( 156)							{
HXDLIN( 156)								int _g_min2 = xIter31->start;
HXDLIN( 156)								int _g_max2 = xIter31->max;
HXDLIN( 156)								while((_g_min2 < _g_max2)){
HXDLIN( 156)									_g_min2 = (_g_min2 + 1);
HXDLIN( 156)									int x7 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)									found1 = false;
HXLINE( 156)									{
HXDLIN( 156)										int _g_min3 = yIter31->start;
HXDLIN( 156)										int _g_max3 = yIter31->max;
HXDLIN( 156)										while((_g_min3 < _g_max3)){
HXDLIN( 156)											_g_min3 = (_g_min3 + 1);
HXDLIN( 156)											int y7 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 156)											bool _hx_tmp12;
HXDLIN( 156)											if (!((s1 <= 0))) {
HXDLIN( 156)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 156)												_hx_tmp12 = true;
            											}
HXDLIN( 156)											if (_hx_tmp12) {
HXDLIN( 156)												if (found1) {
HXDLIN( 156)													goto _hx_goto_267;
            												}
            											}
            											else {
HXDLIN( 156)												if (((s1 + t1) < A1)) {
HXDLIN( 156)													{
HXDLIN( 156)														int c7 = color;
HXDLIN( 156)														bool _hx_tmp13;
HXDLIN( 156)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 156)															_hx_tmp13 = this36->transparent;
            														}
            														else {
HXDLIN( 156)															_hx_tmp13 = false;
            														}
HXDLIN( 156)														if (_hx_tmp13) {
HXDLIN( 156)															int location3;
HXDLIN( 156)															if (this36->useVirtualPos) {
HXDLIN( 156)																location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 156)																location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 156)															int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 156)															int this60;
HXDLIN( 156)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            															}
            															else {
HXDLIN( 156)																this60 = this59;
            															}
HXDLIN( 156)															Float a13;
HXDLIN( 156)															int this61 = ((this60 >> 24) & 255);
HXDLIN( 156)															if ((this61 == 0)) {
HXDLIN( 156)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float r13;
HXDLIN( 156)															int this62 = ((this60 >> 16) & 255);
HXDLIN( 156)															if ((this62 == 0)) {
HXDLIN( 156)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float g13;
HXDLIN( 156)															int this63 = ((this60 >> 8) & 255);
HXDLIN( 156)															if ((this63 == 0)) {
HXDLIN( 156)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float b14;
HXDLIN( 156)															int this64 = (this60 & 255);
HXDLIN( 156)															if ((this64 == 0)) {
HXDLIN( 156)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float a23;
HXDLIN( 156)															int this65 = ((color >> 24) & 255);
HXDLIN( 156)															if ((this65 == 0)) {
HXDLIN( 156)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float r23;
HXDLIN( 156)															int this66 = ((color >> 16) & 255);
HXDLIN( 156)															if ((this66 == 0)) {
HXDLIN( 156)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float g23;
HXDLIN( 156)															int this67 = ((color >> 8) & 255);
HXDLIN( 156)															if ((this67 == 0)) {
HXDLIN( 156)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float b24;
HXDLIN( 156)															int this68 = (color & 255);
HXDLIN( 156)															if ((this68 == 0)) {
HXDLIN( 156)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 156)																b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 156)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 156)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 156)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 156)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 156)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 156)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 156)															{
HXDLIN( 156)																int _hx_tmp14;
HXDLIN( 156)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 156)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 156)																::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 156)															::Dynamic this69 = this36->image;
HXDLIN( 156)															int index9;
HXDLIN( 156)															if (this36->useVirtualPos) {
HXDLIN( 156)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 156)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 156)															int _hx_tmp15;
HXDLIN( 156)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 156)																_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 156)																_hx_tmp15 = c7;
            															}
HXDLIN( 156)															::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXDLIN( 156)													if (found1) {
HXDLIN( 156)														goto _hx_goto_267;
            													}
            												}
            											}
            										}
            										_hx_goto_267:;
            									}
            								}
            							}
HXDLIN( 156)							if ((hasHit1 == true)) {
HXDLIN( 156)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 156)								if (hasUndo1) {
HXDLIN( 156)									v5->undoImage = undoImage3;
HXDLIN( 156)									v5->undoX = xIter31->start;
HXDLIN( 156)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  46)				lastX = nextX1;
HXLINE(  47)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,quadrantIV,(void))

void FillShape_Impl__obj::simonSays( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float radius){
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_164_simonSays)
HXLINE( 165)		{
HXLINE( 165)			 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 165)			if (::hx::IsNull( targetError )) {
HXLINE( 113)				targetError = ((Float)1.05);
            			}
HXLINE( 165)			Float rSmall;
HXDLIN( 165)			if ((radius > radius)) {
HXLINE( 165)				rSmall = radius;
            			}
            			else {
HXLINE( 165)				rSmall = radius;
            			}
HXDLIN( 165)			 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 165)			if (::hx::IsNull( targetE )) {
HXLINE(  20)				targetE = ((Float)1.05);
            			}
HXLINE( 165)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 165)			int noSides;
HXDLIN( 165)			if ((result < 12)) {
HXLINE( 165)				noSides = 12;
            			}
            			else {
HXLINE( 165)				if ((result > 500)) {
HXLINE( 165)					noSides = 500;
            				}
            				else {
HXLINE( 165)					noSides = result;
            				}
            			}
HXDLIN( 165)			int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 165)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 165)			Float omega = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN( 165)			int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 165)			Float lastX = ((Float)0.);
HXDLIN( 165)			Float lastY = ((Float)0.);
HXDLIN( 165)			{
HXLINE(  26)				lastX = (cx + (radius * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)				lastY = (cy + (radius * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            			}
HXLINE( 165)			{
HXLINE( 165)				int _g = 0;
HXDLIN( 165)				int _g1 = (quarter + 1);
HXDLIN( 165)				while((_g < _g1)){
HXLINE( 165)					_g = (_g + 1);
HXDLIN( 165)					int i = (_g - 1);
HXDLIN( 165)					Float nextX = (cx + (radius * ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 165)					Float nextY = (cy + (radius * ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 165)					{
HXLINE( 165)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 165)						bool hasHit = false;
HXDLIN( 165)						bool hasUndo = false;
HXDLIN( 165)						{
HXLINE( 165)							Float bx = lastX;
HXDLIN( 165)							Float by = lastY;
HXDLIN( 165)							Float cx1 = nextX;
HXDLIN( 165)							Float cy1 = nextY;
HXDLIN( 165)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 165)							if (!(adjustWinding)) {
HXLINE( 165)								Float bx_ = bx;
HXDLIN( 165)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE( 165)							{
HXLINE( 165)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 165)								Float sx = (cy1 - cy);
HXDLIN( 165)								Float sy = (cx - cx1);
HXDLIN( 165)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 165)								Float tx = (cy - by);
HXDLIN( 165)								Float ty = (bx - cx);
HXDLIN( 165)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 165)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 165)								if ((cx > bx)) {
HXLINE( 165)									if ((cx > cx1)) {
HXLINE( 165)										int min;
HXDLIN( 165)										if ((bx > cx1)) {
HXLINE( 165)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE( 165)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 165)										int ii_min = min;
HXDLIN( 165)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 165)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXLINE( 165)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 165)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 165)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXLINE( 165)									if ((bx > cx1)) {
HXLINE( 165)										int min1;
HXDLIN( 165)										if ((cx > cx1)) {
HXLINE( 165)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE( 165)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 165)										int ii_min2 = min1;
HXDLIN( 165)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 165)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXLINE( 165)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 165)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 165)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 165)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 165)								if ((cy > by)) {
HXLINE( 165)									if ((cy > cy1)) {
HXLINE( 165)										int min2;
HXDLIN( 165)										if ((by > cy1)) {
HXLINE( 165)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE( 165)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 165)										int ii_min4 = min2;
HXDLIN( 165)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 165)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXLINE( 165)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 165)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 165)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXLINE( 165)									if ((by > cy1)) {
HXLINE( 165)										int min3;
HXDLIN( 165)										if ((cy > cy1)) {
HXLINE( 165)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE( 165)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 165)										int ii_min6 = min3;
HXDLIN( 165)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 165)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXLINE( 165)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 165)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 165)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 165)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 165)								if (hasUndo) {
HXLINE( 165)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 165)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 165)									 ::Dynamic imageType = null();
HXDLIN( 165)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 165)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 165)									::Dynamic undoImage1;
HXDLIN( 165)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXLINE( 165)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 165)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 165)											{
HXLINE( 165)												b->width = width;
HXDLIN( 165)												b->height = height;
HXDLIN( 165)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 165)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 165)												{
HXLINE( 165)													int len = b->length;
HXDLIN( 165)													int w = 0;
HXDLIN( 165)													{
HXLINE( 165)														int _g2 = 0;
HXDLIN( 165)														int _g3 = b->height;
HXDLIN( 165)														while((_g2 < _g3)){
HXLINE( 165)															_g2 = (_g2 + 1);
HXDLIN( 165)															int y = (_g2 - 1);
HXDLIN( 165)															{
HXLINE( 165)																int _g4 = 0;
HXDLIN( 165)																int _g5 = b->width;
HXDLIN( 165)																while((_g4 < _g5)){
HXLINE( 165)																	_g4 = (_g4 + 1);
HXDLIN( 165)																	int x = (_g4 - 1);
HXDLIN( 165)																	{
HXLINE( 165)																		w = (w + 1);
HXDLIN( 165)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 165)																	{
HXLINE( 165)																		w = (w + 1);
HXDLIN( 165)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 165)																	{
HXLINE( 165)																		w = (w + 1);
HXDLIN( 165)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 165)																	{
HXLINE( 165)																		w = (w + 1);
HXDLIN( 165)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 165)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXLINE( 165)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 165)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 165)											{
HXLINE( 165)												a->width = width;
HXDLIN( 165)												a->height = height;
HXDLIN( 165)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 165)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 165)												{
HXLINE( 165)													int _g6 = 0;
HXDLIN( 165)													int _g7 = a->length;
HXDLIN( 165)													while((_g6 < _g7)){
HXLINE( 165)														_g6 = (_g6 + 1);
HXDLIN( 165)														int i1 = (_g6 - 1);
HXDLIN( 165)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 165)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXLINE( 165)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 165)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 165)											{
HXLINE( 165)												b1->width = width;
HXDLIN( 165)												b1->height = height;
HXDLIN( 165)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 165)												int size = (b1->length * 4);
HXDLIN( 165)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 165)												{
HXLINE( 165)													int _g8 = 0;
HXDLIN( 165)													int _g9 = b1->length;
HXDLIN( 165)													while((_g8 < _g9)){
HXLINE( 165)														_g8 = (_g8 + 1);
HXDLIN( 165)														int i2 = (_g8 - 1);
HXDLIN( 165)														{
HXLINE( 165)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 165)															bool undoImage2;
HXDLIN( 165)															if ((i2 >= 0)) {
HXLINE( 165)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXLINE( 165)																undoImage2 = false;
            															}
HXDLIN( 165)															if (undoImage2) {
HXLINE( 165)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 165)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 165)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 165)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 165)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 165)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 165)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXLINE( 165)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 165)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 165)											{
HXLINE( 165)												v->width = width;
HXDLIN( 165)												v->height = height;
HXDLIN( 165)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 165)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 165)												{
HXLINE( 165)													int _g10 = 0;
HXDLIN( 165)													int _g11 = v->length;
HXDLIN( 165)													while((_g10 < _g11)){
HXLINE( 165)														_g10 = (_g10 + 1);
HXDLIN( 165)														int i3 = (_g10 - 1);
HXDLIN( 165)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 165)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXLINE( 165)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 165)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 165)											{
HXLINE( 165)												b2->width = width;
HXDLIN( 165)												b2->height = height;
HXDLIN( 165)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 165)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 165)												{
HXLINE( 165)													int len1 = b2->length;
HXDLIN( 165)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 165)													if (::hx::IsNull( d->head )) {
HXLINE( 165)														int _g12 = 0;
HXDLIN( 165)														int _g13 = len1;
HXDLIN( 165)														while((_g12 < _g13)){
HXLINE( 165)															_g12 = (_g12 + 1);
HXDLIN( 165)															int i4 = (_g12 - 1);
HXDLIN( 165)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXLINE( 165)														int _g14 = 0;
HXDLIN( 165)														int _g15 = len1;
HXDLIN( 165)														while((_g14 < _g15)){
HXLINE( 165)															_g14 = (_g14 + 1);
HXDLIN( 165)															int i5 = (_g14 - 1);
HXDLIN( 165)															{
HXLINE( 165)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 165)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 165)																{
HXLINE( 165)																	int _g16 = 0;
HXDLIN( 165)																	int _g17 = i5;
HXDLIN( 165)																	while((_g16 < _g17)){
HXLINE( 165)																		_g16 = (_g16 + 1);
HXDLIN( 165)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 165)																if (::hx::IsNull( prev )) {
HXLINE( 165)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 165)																	l = null();
            																}
            																else {
HXLINE( 165)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 165)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 165)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 165)									this3->image = undoImage1;
HXDLIN( 165)									this3->width = width;
HXDLIN( 165)									this3->height = height;
HXDLIN( 165)									this3->imageType = ( (int)(imageType) );
HXDLIN( 165)									undoImage = this3;
HXDLIN( 165)									{
HXLINE( 165)										int rectLeft = xIter3->start;
HXDLIN( 165)										int rectTop = yIter3->start;
HXDLIN( 165)										int rectRight = xIter3->max;
HXDLIN( 165)										bool forceClear = false;
HXDLIN( 165)										{
HXLINE( 165)											int _g18 = rectTop;
HXDLIN( 165)											int _g19 = yIter3->max;
HXDLIN( 165)											while((_g18 < _g19)){
HXLINE( 165)												_g18 = (_g18 + 1);
HXDLIN( 165)												int dy = (_g18 - 1);
HXDLIN( 165)												{
HXLINE( 165)													int _g20 = rectLeft;
HXDLIN( 165)													int _g21 = rectRight;
HXDLIN( 165)													while((_g20 < _g21)){
HXLINE( 165)														_g20 = (_g20 + 1);
HXDLIN( 165)														int dx = (_g20 - 1);
HXDLIN( 165)														::Dynamic this5 = this2->image;
HXDLIN( 165)														int index;
HXDLIN( 165)														if (this2->useVirtualPos) {
HXLINE( 165)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXLINE( 165)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 165)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 165)														int col;
HXDLIN( 165)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE( 165)															col = c;
            														}
HXDLIN( 165)														bool _hx_tmp;
HXDLIN( 165)														if (this2->useMask) {
HXLINE( 165)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXLINE( 165)															_hx_tmp = false;
            														}
HXDLIN( 165)														if (_hx_tmp) {
HXLINE( 165)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 165)															::Dynamic this7 = this6->image;
HXDLIN( 165)															int index1;
HXDLIN( 165)															if (this6->useVirtualPos) {
HXLINE( 165)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXLINE( 165)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 165)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 165)															int v1;
HXDLIN( 165)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE( 165)																v1 = c1;
            															}
HXDLIN( 165)															int maskPixel = v1;
HXDLIN( 165)															int this8 = col;
HXDLIN( 165)															if ((maskPixel == 0)) {
HXLINE( 165)																col = this8;
            															}
            															else {
HXLINE( 165)																Float m0;
HXDLIN( 165)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 165)																if ((this9 == 0)) {
HXLINE( 165)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float m1;
HXDLIN( 165)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 165)																if ((this10 == 0)) {
HXLINE( 165)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float m2;
HXDLIN( 165)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 165)																if ((this11 == 0)) {
HXLINE( 165)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float m3;
HXDLIN( 165)																int this12 = (maskPixel & 255);
HXDLIN( 165)																if ((this12 == 0)) {
HXLINE( 165)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 165)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 165)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 165)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 165)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 165)														if ((col != 0)) {
HXLINE( 165)															int x1 = (dx - rectLeft);
HXDLIN( 165)															int y1 = (dy - rectTop);
HXDLIN( 165)															int c2 = col;
HXDLIN( 165)															bool _hx_tmp1;
HXDLIN( 165)															if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 165)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXLINE( 165)																_hx_tmp1 = false;
            															}
HXDLIN( 165)															if (_hx_tmp1) {
HXLINE( 165)																int location;
HXDLIN( 165)																if (undoImage->useVirtualPos) {
HXLINE( 165)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE( 165)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 165)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 165)																int this14;
HXDLIN( 165)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXLINE( 165)																	this14 = this13;
            																}
HXDLIN( 165)																Float a1;
HXDLIN( 165)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 165)																if ((this15 == 0)) {
HXLINE( 165)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float r1;
HXDLIN( 165)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 165)																if ((this16 == 0)) {
HXLINE( 165)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float g1;
HXDLIN( 165)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 165)																if ((this17 == 0)) {
HXLINE( 165)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float b11;
HXDLIN( 165)																int this18 = (this14 & 255);
HXDLIN( 165)																if ((this18 == 0)) {
HXLINE( 165)																	b11 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float a2;
HXDLIN( 165)																int this19 = ((col >> 24) & 255);
HXDLIN( 165)																if ((this19 == 0)) {
HXLINE( 165)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float r2;
HXDLIN( 165)																int this20 = ((col >> 16) & 255);
HXDLIN( 165)																if ((this20 == 0)) {
HXLINE( 165)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float g2;
HXDLIN( 165)																int this21 = ((col >> 8) & 255);
HXDLIN( 165)																if ((this21 == 0)) {
HXLINE( 165)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float b21;
HXDLIN( 165)																int this22 = (col & 255);
HXDLIN( 165)																if ((this22 == 0)) {
HXLINE( 165)																	b21 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 165)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 165)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 165)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 165)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 165)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 165)																{
HXLINE( 165)																	int _hx_tmp2;
HXDLIN( 165)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE( 165)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 165)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXLINE( 165)																::Dynamic this23 = undoImage->image;
HXDLIN( 165)																int index2;
HXDLIN( 165)																if (undoImage->useVirtualPos) {
HXLINE( 165)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE( 165)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 165)																int _hx_tmp3;
HXDLIN( 165)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXLINE( 165)																	_hx_tmp3 = c2;
            																}
HXDLIN( 165)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXLINE( 165)															if (forceClear) {
HXLINE( 165)																::Dynamic this24 = undoImage->image;
HXDLIN( 165)																int x2 = (dx - rectLeft);
HXDLIN( 165)																int y2 = (dy - rectTop);
HXDLIN( 165)																int index3;
HXDLIN( 165)																if (undoImage->useVirtualPos) {
HXLINE( 165)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXLINE( 165)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 165)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 165)								bool found = false;
HXDLIN( 165)								Float s = ((Float)0.);
HXDLIN( 165)								Float t = ((Float)0.);
HXDLIN( 165)								Float sxx = ((Float)0.);
HXDLIN( 165)								Float txx = ((Float)0.);
HXDLIN( 165)								{
HXLINE( 165)									int _g_min = xIter3->start;
HXDLIN( 165)									int _g_max = xIter3->max;
HXDLIN( 165)									while((_g_min < _g_max)){
HXLINE( 165)										_g_min = (_g_min + 1);
HXDLIN( 165)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE( 165)										{
HXLINE( 165)											int _g_min1 = yIter3->start;
HXDLIN( 165)											int _g_max1 = yIter3->max;
HXDLIN( 165)											while((_g_min1 < _g_max1)){
HXLINE( 165)												_g_min1 = (_g_min1 + 1);
HXDLIN( 165)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 165)												bool _hx_tmp4;
HXDLIN( 165)												if (!((s <= 0))) {
HXLINE( 165)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXLINE( 165)													_hx_tmp4 = true;
            												}
HXDLIN( 165)												if (_hx_tmp4) {
HXLINE( 165)													if (found) {
HXLINE( 165)														goto _hx_goto_281;
            													}
            												}
            												else {
HXLINE( 165)													if (((s + t) < A)) {
HXLINE( 165)														{
HXLINE( 165)															int c3 = -2605009;
HXDLIN( 165)															bool _hx_tmp5;
HXDLIN( 165)															if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 165)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXLINE( 165)																_hx_tmp5 = false;
            															}
HXDLIN( 165)															if (_hx_tmp5) {
HXLINE( 165)																int location1;
HXDLIN( 165)																if (this2->useVirtualPos) {
HXLINE( 165)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXLINE( 165)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 165)																int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 165)																int this26;
HXDLIN( 165)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXLINE( 165)																	this26 = this25;
            																}
HXDLIN( 165)																Float a11;
HXDLIN( 165)																int this27 = ((this26 >> 24) & 255);
HXDLIN( 165)																if ((this27 == 0)) {
HXLINE( 165)																	a11 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float r11;
HXDLIN( 165)																int this28 = ((this26 >> 16) & 255);
HXDLIN( 165)																if ((this28 == 0)) {
HXLINE( 165)																	r11 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float g11;
HXDLIN( 165)																int this29 = ((this26 >> 8) & 255);
HXDLIN( 165)																if ((this29 == 0)) {
HXLINE( 165)																	g11 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float b12;
HXDLIN( 165)																int this30 = (this26 & 255);
HXDLIN( 165)																if ((this30 == 0)) {
HXLINE( 165)																	b12 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float a21;
HXDLIN( 165)																int this31 = ((-2605009 >> 24) & 255);
HXDLIN( 165)																if ((this31 == 0)) {
HXLINE( 165)																	a21 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float r21;
HXDLIN( 165)																int this32 = ((-2605009 >> 16) & 255);
HXDLIN( 165)																if ((this32 == 0)) {
HXLINE( 165)																	r21 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float g21;
HXDLIN( 165)																int this33 = ((-2605009 >> 8) & 255);
HXDLIN( 165)																if ((this33 == 0)) {
HXLINE( 165)																	g21 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float b22;
HXDLIN( 165)																int this34 = (-2605009 & 255);
HXDLIN( 165)																if ((this34 == 0)) {
HXLINE( 165)																	b22 = ((Float)0.);
            																}
            																else {
HXLINE( 165)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 165)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 165)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 165)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 165)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 165)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 165)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 165)																{
HXLINE( 165)																	int _hx_tmp6;
HXDLIN( 165)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXLINE( 165)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 165)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXLINE( 165)																::Dynamic this35 = this2->image;
HXDLIN( 165)																int index4;
HXDLIN( 165)																if (this2->useVirtualPos) {
HXLINE( 165)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXLINE( 165)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 165)																int _hx_tmp7;
HXDLIN( 165)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 165)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXLINE( 165)																	_hx_tmp7 = c3;
            																}
HXDLIN( 165)																::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXLINE( 165)														if (found) {
HXLINE( 165)															goto _hx_goto_281;
            														}
            													}
            												}
            											}
            											_hx_goto_281:;
            										}
            									}
            								}
HXDLIN( 165)								if ((hasHit == true)) {
HXLINE( 165)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 165)									if (hasUndo) {
HXLINE( 165)										v2->undoImage = undoImage;
HXDLIN( 165)										v2->undoX = xIter3->start;
HXDLIN( 165)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  46)					lastX = nextX;
HXLINE(  47)					lastY = nextY;
            				}
            			}
            		}
HXLINE( 166)		{
HXLINE( 166)			 ::Dynamic targetError1 = ((Float)1.05);
HXDLIN( 166)			if (::hx::IsNull( targetError1 )) {
HXLINE( 113)				targetError1 = ((Float)1.05);
            			}
HXLINE( 166)			Float rSmall1;
HXDLIN( 166)			if ((radius > radius)) {
HXLINE( 166)				rSmall1 = radius;
            			}
            			else {
HXLINE( 166)				rSmall1 = radius;
            			}
HXDLIN( 166)			 ::Dynamic targetE1 = ( (Float)(targetError1) );
HXDLIN( 166)			if (::hx::IsNull( targetE1 )) {
HXLINE(  20)				targetE1 = ((Float)1.05);
            			}
HXLINE( 166)			int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN( 166)			int noSides1;
HXDLIN( 166)			if ((result1 < 12)) {
HXLINE( 166)				noSides1 = 12;
            			}
            			else {
HXLINE( 166)				if ((result1 > 500)) {
HXLINE( 166)					noSides1 = 500;
            				}
            				else {
HXLINE( 166)					noSides1 = result1;
            				}
            			}
HXDLIN( 166)			int sides1 = (::Math_obj::ceil((( (Float)(noSides1) ) / ( (Float)(4) ))) * 4);
HXDLIN( 166)			Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 166)			Float omega1 = ::Math_obj::PI;
HXDLIN( 166)			int quarter1 = ::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(4) )));
HXDLIN( 166)			Float lastX1 = ((Float)0.);
HXDLIN( 166)			Float lastY1 = ((Float)0.);
HXDLIN( 166)			{
HXLINE(  26)				lastX1 = (cx + (radius * ::Math_obj::cos(((( (Float)(sides1) ) * theta1) + omega1))));
HXLINE(  27)				lastY1 = (cy + (radius * ::Math_obj::sin(((( (Float)(sides1) ) * theta1) + omega1))));
            			}
HXLINE( 166)			{
HXLINE( 166)				int _g22 = 0;
HXDLIN( 166)				int _g23 = (quarter1 + 1);
HXDLIN( 166)				while((_g22 < _g23)){
HXLINE( 166)					_g22 = (_g22 + 1);
HXDLIN( 166)					int i7 = (_g22 - 1);
HXDLIN( 166)					Float nextX1 = (cx + (radius * ::Math_obj::cos((((( (Float)(i7) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN( 166)					Float nextY1 = (cy + (radius * ::Math_obj::sin((((( (Float)(i7) ) * theta1) + ((Float)0.0001)) + omega1))));
HXDLIN( 166)					{
HXLINE( 166)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 166)						bool hasHit1 = false;
HXDLIN( 166)						bool hasUndo1 = false;
HXDLIN( 166)						{
HXLINE( 166)							Float bx1 = lastX1;
HXDLIN( 166)							Float by1 = lastY1;
HXDLIN( 166)							Float cx2 = nextX1;
HXDLIN( 166)							Float cy2 = nextY1;
HXDLIN( 166)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 166)							if (!(adjustWinding1)) {
HXLINE( 166)								Float bx_1 = bx1;
HXDLIN( 166)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 166)							{
HXLINE( 166)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 166)								Float sx1 = (cy2 - cy);
HXDLIN( 166)								Float sy1 = (cx - cx2);
HXDLIN( 166)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 166)								Float tx1 = (cy - by1);
HXDLIN( 166)								Float ty1 = (bx1 - cx);
HXDLIN( 166)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 166)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 166)								if ((cx > bx1)) {
HXLINE( 166)									if ((cx > cx2)) {
HXLINE( 166)										int min4;
HXDLIN( 166)										if ((bx1 > cx2)) {
HXLINE( 166)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXLINE( 166)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 166)										int ii_min8 = min4;
HXDLIN( 166)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 166)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXLINE( 166)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 166)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 166)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXLINE( 166)									if ((bx1 > cx2)) {
HXLINE( 166)										int min5;
HXDLIN( 166)										if ((cx > cx2)) {
HXLINE( 166)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXLINE( 166)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 166)										int ii_min10 = min5;
HXDLIN( 166)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 166)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXLINE( 166)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 166)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 166)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 166)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 166)								if ((cy > by1)) {
HXLINE( 166)									if ((cy > cy2)) {
HXLINE( 166)										int min6;
HXDLIN( 166)										if ((by1 > cy2)) {
HXLINE( 166)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXLINE( 166)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 166)										int ii_min12 = min6;
HXDLIN( 166)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 166)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXLINE( 166)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 166)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 166)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXLINE( 166)									if ((by1 > cy2)) {
HXLINE( 166)										int min7;
HXDLIN( 166)										if ((cy > cy2)) {
HXLINE( 166)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXLINE( 166)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 166)										int ii_min14 = min7;
HXDLIN( 166)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 166)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXLINE( 166)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 166)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 166)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 166)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 166)								if (hasUndo1) {
HXLINE( 166)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 166)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 166)									 ::Dynamic imageType1 = null();
HXDLIN( 166)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 166)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 166)									::Dynamic undoImage4;
HXDLIN( 166)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXLINE( 166)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 166)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 166)											{
HXLINE( 166)												b5->width = width1;
HXDLIN( 166)												b5->height = height1;
HXDLIN( 166)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 166)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 166)												{
HXLINE( 166)													int len2 = b5->length;
HXDLIN( 166)													int w1 = 0;
HXDLIN( 166)													{
HXLINE( 166)														int _g24 = 0;
HXDLIN( 166)														int _g25 = b5->height;
HXDLIN( 166)														while((_g24 < _g25)){
HXLINE( 166)															_g24 = (_g24 + 1);
HXDLIN( 166)															int y4 = (_g24 - 1);
HXDLIN( 166)															{
HXLINE( 166)																int _g26 = 0;
HXDLIN( 166)																int _g27 = b5->width;
HXDLIN( 166)																while((_g26 < _g27)){
HXLINE( 166)																	_g26 = (_g26 + 1);
HXDLIN( 166)																	int x4 = (_g26 - 1);
HXDLIN( 166)																	{
HXLINE( 166)																		w1 = (w1 + 1);
HXDLIN( 166)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 166)																	{
HXLINE( 166)																		w1 = (w1 + 1);
HXDLIN( 166)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 166)																	{
HXLINE( 166)																		w1 = (w1 + 1);
HXDLIN( 166)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 166)																	{
HXLINE( 166)																		w1 = (w1 + 1);
HXDLIN( 166)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 166)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXLINE( 166)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 166)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 166)											{
HXLINE( 166)												a6->width = width1;
HXDLIN( 166)												a6->height = height1;
HXDLIN( 166)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 166)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 166)												{
HXLINE( 166)													int _g28 = 0;
HXDLIN( 166)													int _g29 = a6->length;
HXDLIN( 166)													while((_g28 < _g29)){
HXLINE( 166)														_g28 = (_g28 + 1);
HXDLIN( 166)														int i8 = (_g28 - 1);
HXDLIN( 166)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 166)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXLINE( 166)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 166)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 166)											{
HXLINE( 166)												b6->width = width1;
HXDLIN( 166)												b6->height = height1;
HXDLIN( 166)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 166)												int size1 = (b6->length * 4);
HXDLIN( 166)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 166)												{
HXLINE( 166)													int _g30 = 0;
HXDLIN( 166)													int _g31 = b6->length;
HXDLIN( 166)													while((_g30 < _g31)){
HXLINE( 166)														_g30 = (_g30 + 1);
HXDLIN( 166)														int i9 = (_g30 - 1);
HXDLIN( 166)														{
HXLINE( 166)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 166)															bool undoImage5;
HXDLIN( 166)															if ((i9 >= 0)) {
HXLINE( 166)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXLINE( 166)																undoImage5 = false;
            															}
HXDLIN( 166)															if (undoImage5) {
HXLINE( 166)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 166)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 166)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 166)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 166)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 166)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 166)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXLINE( 166)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 166)											 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 166)											{
HXLINE( 166)												v3->width = width1;
HXDLIN( 166)												v3->height = height1;
HXDLIN( 166)												v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 166)												v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 166)												{
HXLINE( 166)													int _g32 = 0;
HXDLIN( 166)													int _g33 = v3->length;
HXDLIN( 166)													while((_g32 < _g33)){
HXLINE( 166)														_g32 = (_g32 + 1);
HXDLIN( 166)														int i10 = (_g32 - 1);
HXDLIN( 166)														v3->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 166)											undoImage4 = v3;
            										}
            										break;
            										case (int)4: {
HXLINE( 166)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 166)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 166)											{
HXLINE( 166)												b7->width = width1;
HXDLIN( 166)												b7->height = height1;
HXDLIN( 166)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 166)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 166)												{
HXLINE( 166)													int len3 = b7->length;
HXDLIN( 166)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 166)													if (::hx::IsNull( d1->head )) {
HXLINE( 166)														int _g34 = 0;
HXDLIN( 166)														int _g35 = len3;
HXDLIN( 166)														while((_g34 < _g35)){
HXLINE( 166)															_g34 = (_g34 + 1);
HXDLIN( 166)															int i11 = (_g34 - 1);
HXDLIN( 166)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXLINE( 166)														int _g36 = 0;
HXDLIN( 166)														int _g37 = len3;
HXDLIN( 166)														while((_g36 < _g37)){
HXLINE( 166)															_g36 = (_g36 + 1);
HXDLIN( 166)															int i12 = (_g36 - 1);
HXDLIN( 166)															{
HXLINE( 166)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 166)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 166)																{
HXLINE( 166)																	int _g38 = 0;
HXDLIN( 166)																	int _g39 = i12;
HXDLIN( 166)																	while((_g38 < _g39)){
HXLINE( 166)																		_g38 = (_g38 + 1);
HXDLIN( 166)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 166)																if (::hx::IsNull( prev1 )) {
HXLINE( 166)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 166)																	l1 = null();
            																}
            																else {
HXLINE( 166)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 166)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 166)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 166)									this37->image = undoImage4;
HXDLIN( 166)									this37->width = width1;
HXDLIN( 166)									this37->height = height1;
HXDLIN( 166)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 166)									undoImage3 = this37;
HXDLIN( 166)									{
HXLINE( 166)										int rectLeft1 = xIter31->start;
HXDLIN( 166)										int rectTop1 = yIter31->start;
HXDLIN( 166)										int rectRight1 = xIter31->max;
HXDLIN( 166)										bool forceClear1 = false;
HXDLIN( 166)										{
HXLINE( 166)											int _g40 = rectTop1;
HXDLIN( 166)											int _g41 = yIter31->max;
HXDLIN( 166)											while((_g40 < _g41)){
HXLINE( 166)												_g40 = (_g40 + 1);
HXDLIN( 166)												int dy1 = (_g40 - 1);
HXDLIN( 166)												{
HXLINE( 166)													int _g42 = rectLeft1;
HXDLIN( 166)													int _g43 = rectRight1;
HXDLIN( 166)													while((_g42 < _g43)){
HXLINE( 166)														_g42 = (_g42 + 1);
HXDLIN( 166)														int dx1 = (_g42 - 1);
HXDLIN( 166)														::Dynamic this39 = this36->image;
HXDLIN( 166)														int index5;
HXDLIN( 166)														if (this36->useVirtualPos) {
HXLINE( 166)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXLINE( 166)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 166)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 166)														int col1;
HXDLIN( 166)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXLINE( 166)															col1 = c4;
            														}
HXDLIN( 166)														bool _hx_tmp8;
HXDLIN( 166)														if (this36->useMask) {
HXLINE( 166)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXLINE( 166)															_hx_tmp8 = false;
            														}
HXDLIN( 166)														if (_hx_tmp8) {
HXLINE( 166)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 166)															::Dynamic this41 = this40->image;
HXDLIN( 166)															int index6;
HXDLIN( 166)															if (this40->useVirtualPos) {
HXLINE( 166)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXLINE( 166)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 166)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 166)															int v4;
HXDLIN( 166)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)																v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXLINE( 166)																v4 = c5;
            															}
HXDLIN( 166)															int maskPixel1 = v4;
HXDLIN( 166)															int this42 = col1;
HXDLIN( 166)															if ((maskPixel1 == 0)) {
HXLINE( 166)																col1 = this42;
            															}
            															else {
HXLINE( 166)																Float m01;
HXDLIN( 166)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 166)																if ((this43 == 0)) {
HXLINE( 166)																	m01 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float m11;
HXDLIN( 166)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 166)																if ((this44 == 0)) {
HXLINE( 166)																	m11 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float m21;
HXDLIN( 166)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 166)																if ((this45 == 0)) {
HXLINE( 166)																	m21 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float m31;
HXDLIN( 166)																int this46 = (maskPixel1 & 255);
HXDLIN( 166)																if ((this46 == 0)) {
HXLINE( 166)																	m31 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 166)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 166)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 166)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 166)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 166)														if ((col1 != 0)) {
HXLINE( 166)															int x5 = (dx1 - rectLeft1);
HXDLIN( 166)															int y5 = (dy1 - rectTop1);
HXDLIN( 166)															int c6 = col1;
HXDLIN( 166)															bool _hx_tmp9;
HXDLIN( 166)															if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 166)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXLINE( 166)																_hx_tmp9 = false;
            															}
HXDLIN( 166)															if (_hx_tmp9) {
HXLINE( 166)																int location2;
HXDLIN( 166)																if (undoImage3->useVirtualPos) {
HXLINE( 166)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 166)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 166)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 166)																int this48;
HXDLIN( 166)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXLINE( 166)																	this48 = this47;
            																}
HXDLIN( 166)																Float a12;
HXDLIN( 166)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 166)																if ((this49 == 0)) {
HXLINE( 166)																	a12 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float r12;
HXDLIN( 166)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 166)																if ((this50 == 0)) {
HXLINE( 166)																	r12 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float g12;
HXDLIN( 166)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 166)																if ((this51 == 0)) {
HXLINE( 166)																	g12 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float b13;
HXDLIN( 166)																int this52 = (this48 & 255);
HXDLIN( 166)																if ((this52 == 0)) {
HXLINE( 166)																	b13 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float a22;
HXDLIN( 166)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 166)																if ((this53 == 0)) {
HXLINE( 166)																	a22 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float r22;
HXDLIN( 166)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 166)																if ((this54 == 0)) {
HXLINE( 166)																	r22 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float g22;
HXDLIN( 166)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 166)																if ((this55 == 0)) {
HXLINE( 166)																	g22 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float b23;
HXDLIN( 166)																int this56 = (col1 & 255);
HXDLIN( 166)																if ((this56 == 0)) {
HXLINE( 166)																	b23 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 166)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 166)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 166)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 166)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 166)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 166)																{
HXLINE( 166)																	int _hx_tmp10;
HXDLIN( 166)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXLINE( 166)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 166)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXLINE( 166)																::Dynamic this57 = undoImage3->image;
HXDLIN( 166)																int index7;
HXDLIN( 166)																if (undoImage3->useVirtualPos) {
HXLINE( 166)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 166)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 166)																int _hx_tmp11;
HXDLIN( 166)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXLINE( 166)																	_hx_tmp11 = c6;
            																}
HXDLIN( 166)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXLINE( 166)															if (forceClear1) {
HXLINE( 166)																::Dynamic this58 = undoImage3->image;
HXDLIN( 166)																int x6 = (dx1 - rectLeft1);
HXDLIN( 166)																int y6 = (dy1 - rectTop1);
HXDLIN( 166)																int index8;
HXDLIN( 166)																if (undoImage3->useVirtualPos) {
HXLINE( 166)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXLINE( 166)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 166)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 166)								bool found1 = false;
HXDLIN( 166)								Float s1 = ((Float)0.);
HXDLIN( 166)								Float t1 = ((Float)0.);
HXDLIN( 166)								Float sxx1 = ((Float)0.);
HXDLIN( 166)								Float txx1 = ((Float)0.);
HXDLIN( 166)								{
HXLINE( 166)									int _g_min2 = xIter31->start;
HXDLIN( 166)									int _g_max2 = xIter31->max;
HXDLIN( 166)									while((_g_min2 < _g_max2)){
HXLINE( 166)										_g_min2 = (_g_min2 + 1);
HXDLIN( 166)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 166)										{
HXLINE( 166)											int _g_min3 = yIter31->start;
HXDLIN( 166)											int _g_max3 = yIter31->max;
HXDLIN( 166)											while((_g_min3 < _g_max3)){
HXLINE( 166)												_g_min3 = (_g_min3 + 1);
HXDLIN( 166)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 166)												bool _hx_tmp12;
HXDLIN( 166)												if (!((s1 <= 0))) {
HXLINE( 166)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXLINE( 166)													_hx_tmp12 = true;
            												}
HXDLIN( 166)												if (_hx_tmp12) {
HXLINE( 166)													if (found1) {
HXLINE( 166)														goto _hx_goto_294;
            													}
            												}
            												else {
HXLINE( 166)													if (((s1 + t1) < A1)) {
HXLINE( 166)														{
HXLINE( 166)															int c7 = -12866724;
HXDLIN( 166)															bool _hx_tmp13;
HXDLIN( 166)															if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 166)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXLINE( 166)																_hx_tmp13 = false;
            															}
HXDLIN( 166)															if (_hx_tmp13) {
HXLINE( 166)																int location3;
HXDLIN( 166)																if (this36->useVirtualPos) {
HXLINE( 166)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXLINE( 166)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 166)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 166)																int this60;
HXDLIN( 166)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXLINE( 166)																	this60 = this59;
            																}
HXDLIN( 166)																Float a13;
HXDLIN( 166)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 166)																if ((this61 == 0)) {
HXLINE( 166)																	a13 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float r13;
HXDLIN( 166)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 166)																if ((this62 == 0)) {
HXLINE( 166)																	r13 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float g13;
HXDLIN( 166)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 166)																if ((this63 == 0)) {
HXLINE( 166)																	g13 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float b14;
HXDLIN( 166)																int this64 = (this60 & 255);
HXDLIN( 166)																if ((this64 == 0)) {
HXLINE( 166)																	b14 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float a23;
HXDLIN( 166)																int this65 = ((-12866724 >> 24) & 255);
HXDLIN( 166)																if ((this65 == 0)) {
HXLINE( 166)																	a23 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float r23;
HXDLIN( 166)																int this66 = ((-12866724 >> 16) & 255);
HXDLIN( 166)																if ((this66 == 0)) {
HXLINE( 166)																	r23 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float g23;
HXDLIN( 166)																int this67 = ((-12866724 >> 8) & 255);
HXDLIN( 166)																if ((this67 == 0)) {
HXLINE( 166)																	g23 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float b24;
HXDLIN( 166)																int this68 = (-12866724 & 255);
HXDLIN( 166)																if ((this68 == 0)) {
HXLINE( 166)																	b24 = ((Float)0.);
            																}
            																else {
HXLINE( 166)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 166)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 166)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 166)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 166)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 166)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 166)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 166)																{
HXLINE( 166)																	int _hx_tmp14;
HXDLIN( 166)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXLINE( 166)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 166)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXLINE( 166)																::Dynamic this69 = this36->image;
HXDLIN( 166)																int index9;
HXDLIN( 166)																if (this36->useVirtualPos) {
HXLINE( 166)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXLINE( 166)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 166)																int _hx_tmp15;
HXDLIN( 166)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 166)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXLINE( 166)																	_hx_tmp15 = c7;
            																}
HXDLIN( 166)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXLINE( 166)														if (found1) {
HXLINE( 166)															goto _hx_goto_294;
            														}
            													}
            												}
            											}
            											_hx_goto_294:;
            										}
            									}
            								}
HXDLIN( 166)								if ((hasHit1 == true)) {
HXLINE( 166)									 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 166)									if (hasUndo1) {
HXLINE( 166)										v5->undoImage = undoImage3;
HXDLIN( 166)										v5->undoX = xIter31->start;
HXDLIN( 166)										v5->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  46)					lastX1 = nextX1;
HXLINE(  47)					lastY1 = nextY1;
            				}
            			}
            		}
HXLINE( 167)		{
HXLINE( 167)			 ::Dynamic targetError2 = ((Float)1.05);
HXDLIN( 167)			if (::hx::IsNull( targetError2 )) {
HXLINE( 113)				targetError2 = ((Float)1.05);
            			}
HXLINE( 167)			Float rSmall2;
HXDLIN( 167)			if ((radius > radius)) {
HXLINE( 167)				rSmall2 = radius;
            			}
            			else {
HXLINE( 167)				rSmall2 = radius;
            			}
HXDLIN( 167)			 ::Dynamic targetE2 = ( (Float)(targetError2) );
HXDLIN( 167)			if (::hx::IsNull( targetE2 )) {
HXLINE(  20)				targetE2 = ((Float)1.05);
            			}
HXLINE( 167)			int result2 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE2) ) / rSmall2)))));
HXDLIN( 167)			int noSides2;
HXDLIN( 167)			if ((result2 < 12)) {
HXLINE( 167)				noSides2 = 12;
            			}
            			else {
HXLINE( 167)				if ((result2 > 500)) {
HXLINE( 167)					noSides2 = 500;
            				}
            				else {
HXLINE( 167)					noSides2 = result2;
            				}
            			}
HXDLIN( 167)			int sides2 = (::Math_obj::ceil((( (Float)(noSides2) ) / ( (Float)(4) ))) * 4);
HXDLIN( 167)			Float theta2 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides2) ));
HXDLIN( 167)			Float omega2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 167)			int quarter2 = ::Std_obj::_hx_int((( (Float)(sides2) ) / ( (Float)(4) )));
HXDLIN( 167)			Float lastX2 = ((Float)0.);
HXDLIN( 167)			Float lastY2 = ((Float)0.);
HXDLIN( 167)			{
HXLINE(  26)				lastX2 = (cx + (radius * ::Math_obj::cos(((( (Float)(sides2) ) * theta2) + omega2))));
HXLINE(  27)				lastY2 = (cy + (radius * ::Math_obj::sin(((( (Float)(sides2) ) * theta2) + omega2))));
            			}
HXLINE( 167)			{
HXLINE( 167)				int _g44 = 0;
HXDLIN( 167)				int _g45 = (quarter2 + 1);
HXDLIN( 167)				while((_g44 < _g45)){
HXLINE( 167)					_g44 = (_g44 + 1);
HXDLIN( 167)					int i14 = (_g44 - 1);
HXDLIN( 167)					Float nextX2 = (cx + (radius * ::Math_obj::cos((((( (Float)(i14) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN( 167)					Float nextY2 = (cy + (radius * ::Math_obj::sin((((( (Float)(i14) ) * theta2) + ((Float)0.0001)) + omega2))));
HXDLIN( 167)					{
HXLINE( 167)						 ::pi_xy::ImageStruct this70 = this1;
HXDLIN( 167)						bool hasHit2 = false;
HXDLIN( 167)						bool hasUndo2 = false;
HXDLIN( 167)						{
HXLINE( 167)							Float bx2 = lastX2;
HXDLIN( 167)							Float by2 = lastY2;
HXDLIN( 167)							Float cx3 = nextX2;
HXDLIN( 167)							Float cy3 = nextY2;
HXDLIN( 167)							bool adjustWinding2 = (((((cx * by2) - (bx2 * cy)) + ((bx2 * cy3) - (cx3 * by2))) + ((cx3 * cy) - (cx * cy3))) > 0);
HXDLIN( 167)							if (!(adjustWinding2)) {
HXLINE( 167)								Float bx_2 = bx2;
HXDLIN( 167)								Float by_2 = by2;
HXLINE(  25)								bx2 = cx3;
HXLINE(  26)								by2 = cy3;
HXLINE(  27)								cx3 = bx_2;
HXLINE(  28)								cy3 = by_2;
            							}
HXLINE( 167)							{
HXLINE( 167)								Float s02 = ((cy * cx3) - (cx * cy3));
HXDLIN( 167)								Float sx2 = (cy3 - cy);
HXDLIN( 167)								Float sy2 = (cx - cx3);
HXDLIN( 167)								Float t02 = ((cx * by2) - (cy * bx2));
HXDLIN( 167)								Float tx2 = (cy - by2);
HXDLIN( 167)								Float ty2 = (bx2 - cx);
HXDLIN( 167)								Float A2 = ((((-(by2) * cx3) + (cy * (-(bx2) + cx3))) + (cx * (by2 - cy3))) + (bx2 * cy3));
HXDLIN( 167)								 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 167)								if ((cx > bx2)) {
HXLINE( 167)									if ((cx > cx3)) {
HXLINE( 167)										int min8;
HXDLIN( 167)										if ((bx2 > cx3)) {
HXLINE( 167)											min8 = ::Math_obj::floor(cx3);
            										}
            										else {
HXLINE( 167)											min8 = ::Math_obj::floor(bx2);
            										}
HXDLIN( 167)										int ii_min16 = min8;
HXDLIN( 167)										int ii_max16 = ::Math_obj::ceil(cx);
HXDLIN( 167)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            									}
            									else {
HXLINE( 167)										int ii_min17 = ::Math_obj::floor(bx2);
HXDLIN( 167)										int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN( 167)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            									}
            								}
            								else {
HXLINE( 167)									if ((bx2 > cx3)) {
HXLINE( 167)										int min9;
HXDLIN( 167)										if ((cx > cx3)) {
HXLINE( 167)											min9 = ::Math_obj::floor(cx3);
            										}
            										else {
HXLINE( 167)											min9 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 167)										int ii_min18 = min9;
HXDLIN( 167)										int ii_max18 = ::Math_obj::ceil(bx2);
HXDLIN( 167)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            									}
            									else {
HXLINE( 167)										int ii_min19 = ::Math_obj::floor(cx);
HXDLIN( 167)										int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN( 167)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            									}
            								}
HXDLIN( 167)								 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 167)								if ((cy > by2)) {
HXLINE( 167)									if ((cy > cy3)) {
HXLINE( 167)										int min10;
HXDLIN( 167)										if ((by2 > cy3)) {
HXLINE( 167)											min10 = ::Math_obj::floor(cy3);
            										}
            										else {
HXLINE( 167)											min10 = ::Math_obj::floor(by2);
            										}
HXDLIN( 167)										int ii_min20 = min10;
HXDLIN( 167)										int ii_max20 = ::Math_obj::ceil(cy);
HXDLIN( 167)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            									}
            									else {
HXLINE( 167)										int ii_min21 = ::Math_obj::floor(by2);
HXDLIN( 167)										int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN( 167)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            									}
            								}
            								else {
HXLINE( 167)									if ((by2 > cy3)) {
HXLINE( 167)										int min11;
HXDLIN( 167)										if ((cy > cy3)) {
HXLINE( 167)											min11 = ::Math_obj::floor(cy3);
            										}
            										else {
HXLINE( 167)											min11 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 167)										int ii_min22 = min11;
HXDLIN( 167)										int ii_max22 = ::Math_obj::ceil(by2);
HXDLIN( 167)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            									}
            									else {
HXLINE( 167)										int ii_min23 = ::Math_obj::floor(cy);
HXDLIN( 167)										int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN( 167)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            									}
            								}
HXDLIN( 167)								 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 167)								if (hasUndo2) {
HXLINE( 167)									int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 167)									int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 167)									 ::Dynamic imageType2 = null();
HXDLIN( 167)									 ::pi_xy::ImageStruct this71 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 167)									if (::hx::IsNull( imageType2 )) {
HXLINE(  54)										imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 167)									::Dynamic undoImage7;
HXDLIN( 167)									switch((int)(( (int)(imageType2) ))){
            										case (int)0: {
HXLINE( 167)											 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 167)											 ::iterMagic::BytesImg b10 = byt2;
HXDLIN( 167)											{
HXLINE( 167)												b10->width = width2;
HXDLIN( 167)												b10->height = height2;
HXDLIN( 167)												b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 167)												b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN( 167)												{
HXLINE( 167)													int len4 = b10->length;
HXDLIN( 167)													int w2 = 0;
HXDLIN( 167)													{
HXLINE( 167)														int _g46 = 0;
HXDLIN( 167)														int _g47 = b10->height;
HXDLIN( 167)														while((_g46 < _g47)){
HXLINE( 167)															_g46 = (_g46 + 1);
HXDLIN( 167)															int y8 = (_g46 - 1);
HXDLIN( 167)															{
HXLINE( 167)																int _g48 = 0;
HXDLIN( 167)																int _g49 = b10->width;
HXDLIN( 167)																while((_g48 < _g49)){
HXLINE( 167)																	_g48 = (_g48 + 1);
HXDLIN( 167)																	int x8 = (_g48 - 1);
HXDLIN( 167)																	{
HXLINE( 167)																		w2 = (w2 + 1);
HXDLIN( 167)																		b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 167)																	{
HXLINE( 167)																		w2 = (w2 + 1);
HXDLIN( 167)																		b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 167)																	{
HXLINE( 167)																		w2 = (w2 + 1);
HXDLIN( 167)																		b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 167)																	{
HXLINE( 167)																		w2 = (w2 + 1);
HXDLIN( 167)																		b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 167)											undoImage7 = b10;
            										}
            										break;
            										case (int)1: {
HXLINE( 167)											 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 167)											 ::iterMagic::ArrIntImg a9 = arrI2;
HXDLIN( 167)											{
HXLINE( 167)												a9->width = width2;
HXDLIN( 167)												a9->height = height2;
HXDLIN( 167)												a9->data = ::Array_obj< int >::__new(0);
HXDLIN( 167)												a9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 167)												{
HXLINE( 167)													int _g50 = 0;
HXDLIN( 167)													int _g51 = a9->length;
HXDLIN( 167)													while((_g50 < _g51)){
HXLINE( 167)														_g50 = (_g50 + 1);
HXDLIN( 167)														int i15 = (_g50 - 1);
HXDLIN( 167)														a9->data[i15] = 0;
            													}
            												}
            											}
HXDLIN( 167)											undoImage7 = a9;
            										}
            										break;
            										case (int)2: {
HXLINE( 167)											 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 167)											 ::iterMagic::U32ArrImg b15 = u32a2;
HXDLIN( 167)											{
HXLINE( 167)												b15->width = width2;
HXDLIN( 167)												b15->height = height2;
HXDLIN( 167)												b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 167)												int size2 = (b15->length * 4);
HXDLIN( 167)												b15->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 167)												{
HXLINE( 167)													int _g52 = 0;
HXDLIN( 167)													int _g53 = b15->length;
HXDLIN( 167)													while((_g52 < _g53)){
HXLINE( 167)														_g52 = (_g52 + 1);
HXDLIN( 167)														int i16 = (_g52 - 1);
HXDLIN( 167)														{
HXLINE( 167)															 ::haxe::io::ArrayBufferViewImpl this72 = b15->data;
HXDLIN( 167)															bool undoImage8;
HXDLIN( 167)															if ((i16 >= 0)) {
HXLINE( 167)																undoImage8 = (i16 < (this72->byteLength >> 2));
            															}
            															else {
HXLINE( 167)																undoImage8 = false;
            															}
HXDLIN( 167)															if (undoImage8) {
HXLINE( 167)																 ::haxe::io::Bytes _this2 = this72->bytes;
HXDLIN( 167)																int pos2 = ((i16 << 2) + this72->byteOffset);
HXDLIN( 167)																_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 167)																_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 167)																_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 167)																_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 167)											undoImage7 = b15;
            										}
            										break;
            										case (int)3: {
HXLINE( 167)											 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 167)											 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN( 167)											{
HXLINE( 167)												v6->width = width2;
HXDLIN( 167)												v6->height = height2;
HXDLIN( 167)												v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 167)												v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN( 167)												{
HXLINE( 167)													int _g54 = 0;
HXDLIN( 167)													int _g55 = v6->length;
HXDLIN( 167)													while((_g54 < _g55)){
HXLINE( 167)														_g54 = (_g54 + 1);
HXDLIN( 167)														int i17 = (_g54 - 1);
HXDLIN( 167)														v6->data->__unsafe_set(i17,0);
            													}
            												}
            											}
HXDLIN( 167)											undoImage7 = v6;
            										}
            										break;
            										case (int)4: {
HXLINE( 167)											 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 167)											 ::iterMagic::StackIntImg b16 = sInt2;
HXDLIN( 167)											{
HXLINE( 167)												b16->width = width2;
HXDLIN( 167)												b16->height = height2;
HXDLIN( 167)												b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 167)												b16->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 167)												{
HXLINE( 167)													int len5 = b16->length;
HXDLIN( 167)													 ::haxe::ds::GenericStack_Int d2 = b16->data;
HXDLIN( 167)													if (::hx::IsNull( d2->head )) {
HXLINE( 167)														int _g56 = 0;
HXDLIN( 167)														int _g57 = len5;
HXDLIN( 167)														while((_g56 < _g57)){
HXLINE( 167)															_g56 = (_g56 + 1);
HXDLIN( 167)															int i18 = (_g56 - 1);
HXDLIN( 167)															d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            														}
            													}
            													else {
HXLINE( 167)														int _g58 = 0;
HXDLIN( 167)														int _g59 = len5;
HXDLIN( 167)														while((_g58 < _g59)){
HXLINE( 167)															_g58 = (_g58 + 1);
HXDLIN( 167)															int i19 = (_g58 - 1);
HXDLIN( 167)															{
HXLINE( 167)																 ::haxe::ds::GenericCell_Int l2 = b16->data->head;
HXDLIN( 167)																 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 167)																{
HXLINE( 167)																	int _g60 = 0;
HXDLIN( 167)																	int _g61 = i19;
HXDLIN( 167)																	while((_g60 < _g61)){
HXLINE( 167)																		_g60 = (_g60 + 1);
HXDLIN( 167)																		int i20 = (_g60 - 1);
HXLINE( 345)																		prev2 = l2;
HXLINE( 346)																		l2 = l2->next;
            																	}
            																}
HXLINE( 167)																if (::hx::IsNull( prev2 )) {
HXLINE( 167)																	b16->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 167)																	l2 = null();
            																}
            																else {
HXLINE( 167)																	prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 167)																	l2 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 167)											undoImage7 = b16;
            										}
            										break;
            									}
HXDLIN( 167)									this71->image = undoImage7;
HXDLIN( 167)									this71->width = width2;
HXDLIN( 167)									this71->height = height2;
HXDLIN( 167)									this71->imageType = ( (int)(imageType2) );
HXDLIN( 167)									undoImage6 = this71;
HXDLIN( 167)									{
HXLINE( 167)										int rectLeft2 = xIter32->start;
HXDLIN( 167)										int rectTop2 = yIter32->start;
HXDLIN( 167)										int rectRight2 = xIter32->max;
HXDLIN( 167)										bool forceClear2 = false;
HXDLIN( 167)										{
HXLINE( 167)											int _g62 = rectTop2;
HXDLIN( 167)											int _g63 = yIter32->max;
HXDLIN( 167)											while((_g62 < _g63)){
HXLINE( 167)												_g62 = (_g62 + 1);
HXDLIN( 167)												int dy2 = (_g62 - 1);
HXDLIN( 167)												{
HXLINE( 167)													int _g64 = rectLeft2;
HXDLIN( 167)													int _g65 = rectRight2;
HXDLIN( 167)													while((_g64 < _g65)){
HXLINE( 167)														_g64 = (_g64 + 1);
HXDLIN( 167)														int dx2 = (_g64 - 1);
HXDLIN( 167)														::Dynamic this73 = this70->image;
HXDLIN( 167)														int index10;
HXDLIN( 167)														if (this70->useVirtualPos) {
HXLINE( 167)															index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this70->virtualY) * ( (Float)(this70->width) )) + dx2) - this70->virtualX));
            														}
            														else {
HXLINE( 167)															index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this70->width) + dx2)) ));
            														}
HXDLIN( 167)														int c8 = ::iterMagic::Iimg_obj::get(this73,index10);
HXDLIN( 167)														int col2;
HXDLIN( 167)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)															col2 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            														}
            														else {
HXLINE( 167)															col2 = c8;
            														}
HXDLIN( 167)														bool _hx_tmp16;
HXDLIN( 167)														if (this70->useMask) {
HXLINE( 167)															_hx_tmp16 = ::hx::IsNotNull( this70->mask );
            														}
            														else {
HXLINE( 167)															_hx_tmp16 = false;
            														}
HXDLIN( 167)														if (_hx_tmp16) {
HXLINE( 167)															 ::pi_xy::ImageStruct this74 = this70->mask;
HXDLIN( 167)															::Dynamic this75 = this74->image;
HXDLIN( 167)															int index11;
HXDLIN( 167)															if (this74->useVirtualPos) {
HXLINE( 167)																index11 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this74->virtualY) * ( (Float)(this74->width) )) + dx2) - this74->virtualX));
            															}
            															else {
HXLINE( 167)																index11 = ::Std_obj::_hx_int(( (Float)(((dy2 * this74->width) + dx2)) ));
            															}
HXDLIN( 167)															int c9 = ::iterMagic::Iimg_obj::get(this75,index11);
HXDLIN( 167)															int v7;
HXDLIN( 167)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)																v7 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXLINE( 167)																v7 = c9;
            															}
HXDLIN( 167)															int maskPixel2 = v7;
HXDLIN( 167)															int this76 = col2;
HXDLIN( 167)															if ((maskPixel2 == 0)) {
HXLINE( 167)																col2 = this76;
            															}
            															else {
HXLINE( 167)																Float m02;
HXDLIN( 167)																int this77 = ((maskPixel2 >> 24) & 255);
HXDLIN( 167)																if ((this77 == 0)) {
HXLINE( 167)																	m02 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	m02 = (( (Float)(this77) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float m12;
HXDLIN( 167)																int this78 = ((maskPixel2 >> 16) & 255);
HXDLIN( 167)																if ((this78 == 0)) {
HXLINE( 167)																	m12 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	m12 = (( (Float)(this78) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float m22;
HXDLIN( 167)																int this79 = ((maskPixel2 >> 8) & 255);
HXDLIN( 167)																if ((this79 == 0)) {
HXLINE( 167)																	m22 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	m22 = (( (Float)(this79) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float m32;
HXDLIN( 167)																int this80 = (maskPixel2 & 255);
HXDLIN( 167)																if ((this80 == 0)) {
HXLINE( 167)																	m32 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	m32 = (( (Float)(this80) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this76 >> 24) & 255)) )));
HXDLIN( 167)																int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this76 >> 16) & 255)) )));
HXDLIN( 167)																int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this76 >> 8) & 255)) )));
HXDLIN( 167)																int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this76 & 255)) )));
HXDLIN( 167)																col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 167)														if ((col2 != 0)) {
HXLINE( 167)															int x9 = (dx2 - rectLeft2);
HXDLIN( 167)															int y9 = (dy2 - rectTop2);
HXDLIN( 167)															int c10 = col2;
HXDLIN( 167)															bool _hx_tmp17;
HXDLIN( 167)															if ((((c10 >> 24) & 255) < 254)) {
HXLINE( 167)																_hx_tmp17 = undoImage6->transparent;
            															}
            															else {
HXLINE( 167)																_hx_tmp17 = false;
            															}
HXDLIN( 167)															if (_hx_tmp17) {
HXLINE( 167)																int location4;
HXDLIN( 167)																if (undoImage6->useVirtualPos) {
HXLINE( 167)																	location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 167)																	location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            																}
HXDLIN( 167)																int this81 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 167)																int this82;
HXDLIN( 167)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)																	this82 = ((((((this81 >> 24) & 255) << 24) | ((this81 & 255) << 16)) | (((this81 >> 8) & 255) << 8)) | ((this81 >> 16) & 255));
            																}
            																else {
HXLINE( 167)																	this82 = this81;
            																}
HXDLIN( 167)																Float a14;
HXDLIN( 167)																int this83 = ((this82 >> 24) & 255);
HXDLIN( 167)																if ((this83 == 0)) {
HXLINE( 167)																	a14 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	a14 = (( (Float)(this83) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float r14;
HXDLIN( 167)																int this84 = ((this82 >> 16) & 255);
HXDLIN( 167)																if ((this84 == 0)) {
HXLINE( 167)																	r14 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	r14 = (( (Float)(this84) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float g14;
HXDLIN( 167)																int this85 = ((this82 >> 8) & 255);
HXDLIN( 167)																if ((this85 == 0)) {
HXLINE( 167)																	g14 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	g14 = (( (Float)(this85) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float b17;
HXDLIN( 167)																int this86 = (this82 & 255);
HXDLIN( 167)																if ((this86 == 0)) {
HXLINE( 167)																	b17 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	b17 = (( (Float)(this86) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float a24;
HXDLIN( 167)																int this87 = ((col2 >> 24) & 255);
HXDLIN( 167)																if ((this87 == 0)) {
HXLINE( 167)																	a24 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	a24 = (( (Float)(this87) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float r24;
HXDLIN( 167)																int this88 = ((col2 >> 16) & 255);
HXDLIN( 167)																if ((this88 == 0)) {
HXLINE( 167)																	r24 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	r24 = (( (Float)(this88) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float g24;
HXDLIN( 167)																int this89 = ((col2 >> 8) & 255);
HXDLIN( 167)																if ((this89 == 0)) {
HXLINE( 167)																	g24 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	g24 = (( (Float)(this89) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float b25;
HXDLIN( 167)																int this90 = (col2 & 255);
HXDLIN( 167)																if ((this90 == 0)) {
HXLINE( 167)																	b25 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	b25 = (( (Float)(this90) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN( 167)																int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 167)																int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 167)																int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a34) + (b25 * a24))));
HXDLIN( 167)																int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 167)																int blended4 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b18);
HXDLIN( 167)																{
HXLINE( 167)																	int _hx_tmp18;
HXDLIN( 167)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)																		_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            																	}
            																	else {
HXLINE( 167)																		_hx_tmp18 = blended4;
            																	}
HXDLIN( 167)																	::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            																}
            															}
            															else {
HXLINE( 167)																::Dynamic this91 = undoImage6->image;
HXDLIN( 167)																int index12;
HXDLIN( 167)																if (undoImage6->useVirtualPos) {
HXLINE( 167)																	index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 167)																	index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            																}
HXDLIN( 167)																int _hx_tmp19;
HXDLIN( 167)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)																	_hx_tmp19 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            																}
            																else {
HXLINE( 167)																	_hx_tmp19 = c10;
            																}
HXDLIN( 167)																::iterMagic::Iimg_obj::set(this91,index12,_hx_tmp19);
            															}
            														}
            														else {
HXLINE( 167)															if (forceClear2) {
HXLINE( 167)																::Dynamic this92 = undoImage6->image;
HXDLIN( 167)																int x10 = (dx2 - rectLeft2);
HXDLIN( 167)																int y10 = (dy2 - rectTop2);
HXDLIN( 167)																int index13;
HXDLIN( 167)																if (undoImage6->useVirtualPos) {
HXLINE( 167)																	index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            																}
            																else {
HXLINE( 167)																	index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            																}
HXDLIN( 167)																::iterMagic::Iimg_obj::set(this92,index13,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 167)								bool found2 = false;
HXDLIN( 167)								Float s2 = ((Float)0.);
HXDLIN( 167)								Float t2 = ((Float)0.);
HXDLIN( 167)								Float sxx2 = ((Float)0.);
HXDLIN( 167)								Float txx2 = ((Float)0.);
HXDLIN( 167)								{
HXLINE( 167)									int _g_min4 = xIter32->start;
HXDLIN( 167)									int _g_max4 = xIter32->max;
HXDLIN( 167)									while((_g_min4 < _g_max4)){
HXLINE( 167)										_g_min4 = (_g_min4 + 1);
HXDLIN( 167)										int x11 = (_g_min4 - 1);
HXLINE(  60)										sxx2 = (sx2 * ( (Float)(x11) ));
HXLINE(  61)										txx2 = (tx2 * ( (Float)(x11) ));
HXLINE(  62)										found2 = false;
HXLINE( 167)										{
HXLINE( 167)											int _g_min5 = yIter32->start;
HXDLIN( 167)											int _g_max5 = yIter32->max;
HXDLIN( 167)											while((_g_min5 < _g_max5)){
HXLINE( 167)												_g_min5 = (_g_min5 + 1);
HXDLIN( 167)												int y11 = (_g_min5 - 1);
HXLINE(  64)												s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y11) )));
HXLINE(  65)												t2 = ((t02 + txx2) + (ty2 * ( (Float)(y11) )));
HXLINE( 167)												bool _hx_tmp20;
HXDLIN( 167)												if (!((s2 <= 0))) {
HXLINE( 167)													_hx_tmp20 = (t2 <= 0);
            												}
            												else {
HXLINE( 167)													_hx_tmp20 = true;
            												}
HXDLIN( 167)												if (_hx_tmp20) {
HXLINE( 167)													if (found2) {
HXLINE( 167)														goto _hx_goto_307;
            													}
            												}
            												else {
HXLINE( 167)													if (((s2 + t2) < A2)) {
HXLINE( 167)														{
HXLINE( 167)															int c11 = -856476;
HXDLIN( 167)															bool _hx_tmp21;
HXDLIN( 167)															if ((((c11 >> 24) & 255) < 254)) {
HXLINE( 167)																_hx_tmp21 = this70->transparent;
            															}
            															else {
HXLINE( 167)																_hx_tmp21 = false;
            															}
HXDLIN( 167)															if (_hx_tmp21) {
HXLINE( 167)																int location5;
HXDLIN( 167)																if (this70->useVirtualPos) {
HXLINE( 167)																	location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this70->virtualY) * ( (Float)(this70->width) )) + x11) - this70->virtualX));
            																}
            																else {
HXLINE( 167)																	location5 = ::Std_obj::_hx_int(( (Float)(((y11 * this70->width) + x11)) ));
            																}
HXDLIN( 167)																int this93 = ::iterMagic::Iimg_obj::get(this70->image,location5);
HXDLIN( 167)																int this94;
HXDLIN( 167)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)																	this94 = ((((((this93 >> 24) & 255) << 24) | ((this93 & 255) << 16)) | (((this93 >> 8) & 255) << 8)) | ((this93 >> 16) & 255));
            																}
            																else {
HXLINE( 167)																	this94 = this93;
            																}
HXDLIN( 167)																Float a15;
HXDLIN( 167)																int this95 = ((this94 >> 24) & 255);
HXDLIN( 167)																if ((this95 == 0)) {
HXLINE( 167)																	a15 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	a15 = (( (Float)(this95) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float r15;
HXDLIN( 167)																int this96 = ((this94 >> 16) & 255);
HXDLIN( 167)																if ((this96 == 0)) {
HXLINE( 167)																	r15 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	r15 = (( (Float)(this96) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float g15;
HXDLIN( 167)																int this97 = ((this94 >> 8) & 255);
HXDLIN( 167)																if ((this97 == 0)) {
HXLINE( 167)																	g15 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	g15 = (( (Float)(this97) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float b19;
HXDLIN( 167)																int this98 = (this94 & 255);
HXDLIN( 167)																if ((this98 == 0)) {
HXLINE( 167)																	b19 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	b19 = (( (Float)(this98) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float a25;
HXDLIN( 167)																int this99 = ((-856476 >> 24) & 255);
HXDLIN( 167)																if ((this99 == 0)) {
HXLINE( 167)																	a25 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	a25 = (( (Float)(this99) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float r25;
HXDLIN( 167)																int this100 = ((-856476 >> 16) & 255);
HXDLIN( 167)																if ((this100 == 0)) {
HXLINE( 167)																	r25 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	r25 = (( (Float)(this100) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float g25;
HXDLIN( 167)																int this101 = ((-856476 >> 8) & 255);
HXDLIN( 167)																if ((this101 == 0)) {
HXLINE( 167)																	g25 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	g25 = (( (Float)(this101) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float b26;
HXDLIN( 167)																int this102 = (-856476 & 255);
HXDLIN( 167)																if ((this102 == 0)) {
HXLINE( 167)																	b26 = ((Float)0.);
            																}
            																else {
HXLINE( 167)																	b26 = (( (Float)(this102) ) / ( (Float)(255) ));
            																}
HXDLIN( 167)																Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN( 167)																int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 167)																int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 167)																int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a35) + (b26 * a25))));
HXDLIN( 167)																int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 167)																int blended5 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b20);
HXDLIN( 167)																{
HXLINE( 167)																	int _hx_tmp22;
HXDLIN( 167)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)																		_hx_tmp22 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            																	}
            																	else {
HXLINE( 167)																		_hx_tmp22 = blended5;
            																	}
HXDLIN( 167)																	::iterMagic::Iimg_obj::set(this70->image,location5,_hx_tmp22);
            																}
            															}
            															else {
HXLINE( 167)																::Dynamic this103 = this70->image;
HXDLIN( 167)																int index14;
HXDLIN( 167)																if (this70->useVirtualPos) {
HXLINE( 167)																	index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this70->virtualY) * ( (Float)(this70->width) )) + x11) - this70->virtualX));
            																}
            																else {
HXLINE( 167)																	index14 = ::Std_obj::_hx_int(( (Float)(((y11 * this70->width) + x11)) ));
            																}
HXDLIN( 167)																int _hx_tmp23;
HXDLIN( 167)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 167)																	_hx_tmp23 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            																}
            																else {
HXLINE( 167)																	_hx_tmp23 = c11;
            																}
HXDLIN( 167)																::iterMagic::Iimg_obj::set(this103,index14,_hx_tmp23);
            															}
            														}
HXLINE(  73)														found2 = true;
            													}
            													else {
HXLINE( 167)														if (found2) {
HXLINE( 167)															goto _hx_goto_307;
            														}
            													}
            												}
            											}
            											_hx_goto_307:;
            										}
            									}
            								}
HXDLIN( 167)								if ((hasHit2 == true)) {
HXLINE( 167)									 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx2,by2,cx3,cy3,true);
HXDLIN( 167)									if (hasUndo2) {
HXLINE( 167)										v8->undoImage = undoImage6;
HXDLIN( 167)										v8->undoX = xIter32->start;
HXDLIN( 167)										v8->undoY = yIter32->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  46)					lastX2 = nextX2;
HXLINE(  47)					lastY2 = nextY2;
            				}
            			}
            		}
HXLINE( 168)		{
HXLINE( 168)			 ::Dynamic targetError3 = ((Float)1.05);
HXDLIN( 168)			if (::hx::IsNull( targetError3 )) {
HXLINE( 113)				targetError3 = ((Float)1.05);
            			}
HXLINE( 168)			Float rSmall3;
HXDLIN( 168)			if ((radius > radius)) {
HXLINE( 168)				rSmall3 = radius;
            			}
            			else {
HXLINE( 168)				rSmall3 = radius;
            			}
HXDLIN( 168)			 ::Dynamic targetE3 = ( (Float)(targetError3) );
HXDLIN( 168)			if (::hx::IsNull( targetE3 )) {
HXLINE(  20)				targetE3 = ((Float)1.05);
            			}
HXLINE( 168)			int result3 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE3) ) / rSmall3)))));
HXDLIN( 168)			int noSides3;
HXDLIN( 168)			if ((result3 < 12)) {
HXLINE( 168)				noSides3 = 12;
            			}
            			else {
HXLINE( 168)				if ((result3 > 500)) {
HXLINE( 168)					noSides3 = 500;
            				}
            				else {
HXLINE( 168)					noSides3 = result3;
            				}
            			}
HXDLIN( 168)			int sides3 = (::Math_obj::ceil((( (Float)(noSides3) ) / ( (Float)(4) ))) * 4);
HXDLIN( 168)			Float theta3 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN( 168)			Float omega3 = ( (Float)(0) );
HXDLIN( 168)			int quarter3 = ::Std_obj::_hx_int((( (Float)(sides3) ) / ( (Float)(4) )));
HXDLIN( 168)			Float lastX3 = ((Float)0.);
HXDLIN( 168)			Float lastY3 = ((Float)0.);
HXDLIN( 168)			{
HXLINE(  26)				lastX3 = (cx + (radius * ::Math_obj::cos(((( (Float)(sides3) ) * theta3) + omega3))));
HXLINE(  27)				lastY3 = (cy + (radius * ::Math_obj::sin(((( (Float)(sides3) ) * theta3) + omega3))));
            			}
HXLINE( 168)			{
HXLINE( 168)				int _g66 = 0;
HXDLIN( 168)				int _g67 = (quarter3 + 1);
HXDLIN( 168)				while((_g66 < _g67)){
HXLINE( 168)					_g66 = (_g66 + 1);
HXDLIN( 168)					int i21 = (_g66 - 1);
HXDLIN( 168)					Float nextX3 = (cx + (radius * ::Math_obj::cos((((( (Float)(i21) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN( 168)					Float nextY3 = (cy + (radius * ::Math_obj::sin((((( (Float)(i21) ) * theta3) + ((Float)0.0001)) + omega3))));
HXDLIN( 168)					{
HXLINE( 168)						 ::pi_xy::ImageStruct this104 = this1;
HXDLIN( 168)						bool hasHit3 = false;
HXDLIN( 168)						bool hasUndo3 = false;
HXDLIN( 168)						{
HXLINE( 168)							Float bx3 = lastX3;
HXDLIN( 168)							Float by3 = lastY3;
HXDLIN( 168)							Float cx4 = nextX3;
HXDLIN( 168)							Float cy4 = nextY3;
HXDLIN( 168)							bool adjustWinding3 = (((((cx * by3) - (bx3 * cy)) + ((bx3 * cy4) - (cx4 * by3))) + ((cx4 * cy) - (cx * cy4))) > 0);
HXDLIN( 168)							if (!(adjustWinding3)) {
HXLINE( 168)								Float bx_3 = bx3;
HXDLIN( 168)								Float by_3 = by3;
HXLINE(  25)								bx3 = cx4;
HXLINE(  26)								by3 = cy4;
HXLINE(  27)								cx4 = bx_3;
HXLINE(  28)								cy4 = by_3;
            							}
HXLINE( 168)							{
HXLINE( 168)								Float s03 = ((cy * cx4) - (cx * cy4));
HXDLIN( 168)								Float sx3 = (cy4 - cy);
HXDLIN( 168)								Float sy3 = (cx - cx4);
HXDLIN( 168)								Float t03 = ((cx * by3) - (cy * bx3));
HXDLIN( 168)								Float tx3 = (cy - by3);
HXDLIN( 168)								Float ty3 = (bx3 - cx);
HXDLIN( 168)								Float A3 = ((((-(by3) * cx4) + (cy * (-(bx3) + cx4))) + (cx * (by3 - cy4))) + (bx3 * cy4));
HXDLIN( 168)								 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 168)								if ((cx > bx3)) {
HXLINE( 168)									if ((cx > cx4)) {
HXLINE( 168)										int min12;
HXDLIN( 168)										if ((bx3 > cx4)) {
HXLINE( 168)											min12 = ::Math_obj::floor(cx4);
            										}
            										else {
HXLINE( 168)											min12 = ::Math_obj::floor(bx3);
            										}
HXDLIN( 168)										int ii_min24 = min12;
HXDLIN( 168)										int ii_max24 = ::Math_obj::ceil(cx);
HXDLIN( 168)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            									}
            									else {
HXLINE( 168)										int ii_min25 = ::Math_obj::floor(bx3);
HXDLIN( 168)										int ii_max25 = ::Math_obj::ceil(cx4);
HXDLIN( 168)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            									}
            								}
            								else {
HXLINE( 168)									if ((bx3 > cx4)) {
HXLINE( 168)										int min13;
HXDLIN( 168)										if ((cx > cx4)) {
HXLINE( 168)											min13 = ::Math_obj::floor(cx4);
            										}
            										else {
HXLINE( 168)											min13 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 168)										int ii_min26 = min13;
HXDLIN( 168)										int ii_max26 = ::Math_obj::ceil(bx3);
HXDLIN( 168)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            									}
            									else {
HXLINE( 168)										int ii_min27 = ::Math_obj::floor(cx);
HXDLIN( 168)										int ii_max27 = ::Math_obj::ceil(cx4);
HXDLIN( 168)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            									}
            								}
HXDLIN( 168)								 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 168)								if ((cy > by3)) {
HXLINE( 168)									if ((cy > cy4)) {
HXLINE( 168)										int min14;
HXDLIN( 168)										if ((by3 > cy4)) {
HXLINE( 168)											min14 = ::Math_obj::floor(cy4);
            										}
            										else {
HXLINE( 168)											min14 = ::Math_obj::floor(by3);
            										}
HXDLIN( 168)										int ii_min28 = min14;
HXDLIN( 168)										int ii_max28 = ::Math_obj::ceil(cy);
HXDLIN( 168)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            									}
            									else {
HXLINE( 168)										int ii_min29 = ::Math_obj::floor(by3);
HXDLIN( 168)										int ii_max29 = ::Math_obj::ceil(cy4);
HXDLIN( 168)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            									}
            								}
            								else {
HXLINE( 168)									if ((by3 > cy4)) {
HXLINE( 168)										int min15;
HXDLIN( 168)										if ((cy > cy4)) {
HXLINE( 168)											min15 = ::Math_obj::floor(cy4);
            										}
            										else {
HXLINE( 168)											min15 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 168)										int ii_min30 = min15;
HXDLIN( 168)										int ii_max30 = ::Math_obj::ceil(by3);
HXDLIN( 168)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            									}
            									else {
HXLINE( 168)										int ii_min31 = ::Math_obj::floor(cy);
HXDLIN( 168)										int ii_max31 = ::Math_obj::ceil(cy4);
HXDLIN( 168)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            									}
            								}
HXDLIN( 168)								 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 168)								if (hasUndo3) {
HXLINE( 168)									int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 168)									int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 168)									 ::Dynamic imageType3 = null();
HXDLIN( 168)									 ::pi_xy::ImageStruct this105 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 168)									if (::hx::IsNull( imageType3 )) {
HXLINE(  54)										imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 168)									::Dynamic undoImage10;
HXDLIN( 168)									switch((int)(( (int)(imageType3) ))){
            										case (int)0: {
HXLINE( 168)											 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::BytesImg b27 = byt3;
HXDLIN( 168)											{
HXLINE( 168)												b27->width = width3;
HXDLIN( 168)												b27->height = height3;
HXDLIN( 168)												b27->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 168)												b27->data = ::haxe::io::Bytes_obj::alloc((b27->length * 4));
HXDLIN( 168)												{
HXLINE( 168)													int len6 = b27->length;
HXDLIN( 168)													int w3 = 0;
HXDLIN( 168)													{
HXLINE( 168)														int _g68 = 0;
HXDLIN( 168)														int _g69 = b27->height;
HXDLIN( 168)														while((_g68 < _g69)){
HXLINE( 168)															_g68 = (_g68 + 1);
HXDLIN( 168)															int y12 = (_g68 - 1);
HXDLIN( 168)															{
HXLINE( 168)																int _g70 = 0;
HXDLIN( 168)																int _g71 = b27->width;
HXDLIN( 168)																while((_g70 < _g71)){
HXLINE( 168)																	_g70 = (_g70 + 1);
HXDLIN( 168)																	int x12 = (_g70 - 1);
HXDLIN( 168)																	{
HXLINE( 168)																		w3 = (w3 + 1);
HXDLIN( 168)																		b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 168)																	{
HXLINE( 168)																		w3 = (w3 + 1);
HXDLIN( 168)																		b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 168)																	{
HXLINE( 168)																		w3 = (w3 + 1);
HXDLIN( 168)																		b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 168)																	{
HXLINE( 168)																		w3 = (w3 + 1);
HXDLIN( 168)																		b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 168)											undoImage10 = b27;
            										}
            										break;
            										case (int)1: {
HXLINE( 168)											 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::ArrIntImg a17 = arrI3;
HXDLIN( 168)											{
HXLINE( 168)												a17->width = width3;
HXDLIN( 168)												a17->height = height3;
HXDLIN( 168)												a17->data = ::Array_obj< int >::__new(0);
HXDLIN( 168)												a17->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 168)												{
HXLINE( 168)													int _g72 = 0;
HXDLIN( 168)													int _g73 = a17->length;
HXDLIN( 168)													while((_g72 < _g73)){
HXLINE( 168)														_g72 = (_g72 + 1);
HXDLIN( 168)														int i22 = (_g72 - 1);
HXDLIN( 168)														a17->data[i22] = 0;
            													}
            												}
            											}
HXDLIN( 168)											undoImage10 = a17;
            										}
            										break;
            										case (int)2: {
HXLINE( 168)											 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::U32ArrImg b28 = u32a3;
HXDLIN( 168)											{
HXLINE( 168)												b28->width = width3;
HXDLIN( 168)												b28->height = height3;
HXDLIN( 168)												b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 168)												int size3 = (b28->length * 4);
HXDLIN( 168)												b28->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 168)												{
HXLINE( 168)													int _g74 = 0;
HXDLIN( 168)													int _g75 = b28->length;
HXDLIN( 168)													while((_g74 < _g75)){
HXLINE( 168)														_g74 = (_g74 + 1);
HXDLIN( 168)														int i23 = (_g74 - 1);
HXDLIN( 168)														{
HXLINE( 168)															 ::haxe::io::ArrayBufferViewImpl this106 = b28->data;
HXDLIN( 168)															bool undoImage11;
HXDLIN( 168)															if ((i23 >= 0)) {
HXLINE( 168)																undoImage11 = (i23 < (this106->byteLength >> 2));
            															}
            															else {
HXLINE( 168)																undoImage11 = false;
            															}
HXDLIN( 168)															if (undoImage11) {
HXLINE( 168)																 ::haxe::io::Bytes _this3 = this106->bytes;
HXDLIN( 168)																int pos3 = ((i23 << 2) + this106->byteOffset);
HXDLIN( 168)																_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 168)																_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 168)																_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 168)																_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 168)											undoImage10 = b28;
            										}
            										break;
            										case (int)3: {
HXLINE( 168)											 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN( 168)											{
HXLINE( 168)												v9->width = width3;
HXDLIN( 168)												v9->height = height3;
HXDLIN( 168)												v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 168)												v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN( 168)												{
HXLINE( 168)													int _g76 = 0;
HXDLIN( 168)													int _g77 = v9->length;
HXDLIN( 168)													while((_g76 < _g77)){
HXLINE( 168)														_g76 = (_g76 + 1);
HXDLIN( 168)														int i24 = (_g76 - 1);
HXDLIN( 168)														v9->data->__unsafe_set(i24,0);
            													}
            												}
            											}
HXDLIN( 168)											undoImage10 = v9;
            										}
            										break;
            										case (int)4: {
HXLINE( 168)											 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)											 ::iterMagic::StackIntImg b29 = sInt3;
HXDLIN( 168)											{
HXLINE( 168)												b29->width = width3;
HXDLIN( 168)												b29->height = height3;
HXDLIN( 168)												b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 168)												b29->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 168)												{
HXLINE( 168)													int len7 = b29->length;
HXDLIN( 168)													 ::haxe::ds::GenericStack_Int d3 = b29->data;
HXDLIN( 168)													if (::hx::IsNull( d3->head )) {
HXLINE( 168)														int _g78 = 0;
HXDLIN( 168)														int _g79 = len7;
HXDLIN( 168)														while((_g78 < _g79)){
HXLINE( 168)															_g78 = (_g78 + 1);
HXDLIN( 168)															int i25 = (_g78 - 1);
HXDLIN( 168)															d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            														}
            													}
            													else {
HXLINE( 168)														int _g80 = 0;
HXDLIN( 168)														int _g81 = len7;
HXDLIN( 168)														while((_g80 < _g81)){
HXLINE( 168)															_g80 = (_g80 + 1);
HXDLIN( 168)															int i26 = (_g80 - 1);
HXDLIN( 168)															{
HXLINE( 168)																 ::haxe::ds::GenericCell_Int l3 = b29->data->head;
HXDLIN( 168)																 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 168)																{
HXLINE( 168)																	int _g82 = 0;
HXDLIN( 168)																	int _g83 = i26;
HXDLIN( 168)																	while((_g82 < _g83)){
HXLINE( 168)																		_g82 = (_g82 + 1);
HXDLIN( 168)																		int i27 = (_g82 - 1);
HXLINE( 345)																		prev3 = l3;
HXLINE( 346)																		l3 = l3->next;
            																	}
            																}
HXLINE( 168)																if (::hx::IsNull( prev3 )) {
HXLINE( 168)																	b29->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 168)																	l3 = null();
            																}
            																else {
HXLINE( 168)																	prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 168)																	l3 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 168)											undoImage10 = b29;
            										}
            										break;
            									}
HXDLIN( 168)									this105->image = undoImage10;
HXDLIN( 168)									this105->width = width3;
HXDLIN( 168)									this105->height = height3;
HXDLIN( 168)									this105->imageType = ( (int)(imageType3) );
HXDLIN( 168)									undoImage9 = this105;
HXDLIN( 168)									{
HXLINE( 168)										int rectLeft3 = xIter33->start;
HXDLIN( 168)										int rectTop3 = yIter33->start;
HXDLIN( 168)										int rectRight3 = xIter33->max;
HXDLIN( 168)										bool forceClear3 = false;
HXDLIN( 168)										{
HXLINE( 168)											int _g84 = rectTop3;
HXDLIN( 168)											int _g85 = yIter33->max;
HXDLIN( 168)											while((_g84 < _g85)){
HXLINE( 168)												_g84 = (_g84 + 1);
HXDLIN( 168)												int dy3 = (_g84 - 1);
HXDLIN( 168)												{
HXLINE( 168)													int _g86 = rectLeft3;
HXDLIN( 168)													int _g87 = rectRight3;
HXDLIN( 168)													while((_g86 < _g87)){
HXLINE( 168)														_g86 = (_g86 + 1);
HXDLIN( 168)														int dx3 = (_g86 - 1);
HXDLIN( 168)														::Dynamic this107 = this104->image;
HXDLIN( 168)														int index15;
HXDLIN( 168)														if (this104->useVirtualPos) {
HXLINE( 168)															index15 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this104->virtualY) * ( (Float)(this104->width) )) + dx3) - this104->virtualX));
            														}
            														else {
HXLINE( 168)															index15 = ::Std_obj::_hx_int(( (Float)(((dy3 * this104->width) + dx3)) ));
            														}
HXDLIN( 168)														int c12 = ::iterMagic::Iimg_obj::get(this107,index15);
HXDLIN( 168)														int col3;
HXDLIN( 168)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)															col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            														}
            														else {
HXLINE( 168)															col3 = c12;
            														}
HXDLIN( 168)														bool _hx_tmp24;
HXDLIN( 168)														if (this104->useMask) {
HXLINE( 168)															_hx_tmp24 = ::hx::IsNotNull( this104->mask );
            														}
            														else {
HXLINE( 168)															_hx_tmp24 = false;
            														}
HXDLIN( 168)														if (_hx_tmp24) {
HXLINE( 168)															 ::pi_xy::ImageStruct this108 = this104->mask;
HXDLIN( 168)															::Dynamic this109 = this108->image;
HXDLIN( 168)															int index16;
HXDLIN( 168)															if (this108->useVirtualPos) {
HXLINE( 168)																index16 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this108->virtualY) * ( (Float)(this108->width) )) + dx3) - this108->virtualX));
            															}
            															else {
HXLINE( 168)																index16 = ::Std_obj::_hx_int(( (Float)(((dy3 * this108->width) + dx3)) ));
            															}
HXDLIN( 168)															int c13 = ::iterMagic::Iimg_obj::get(this109,index16);
HXDLIN( 168)															int v10;
HXDLIN( 168)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																v10 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            															}
            															else {
HXLINE( 168)																v10 = c13;
            															}
HXDLIN( 168)															int maskPixel3 = v10;
HXDLIN( 168)															int this110 = col3;
HXDLIN( 168)															if ((maskPixel3 == 0)) {
HXLINE( 168)																col3 = this110;
            															}
            															else {
HXLINE( 168)																Float m03;
HXDLIN( 168)																int this111 = ((maskPixel3 >> 24) & 255);
HXDLIN( 168)																if ((this111 == 0)) {
HXLINE( 168)																	m03 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	m03 = (( (Float)(this111) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float m13;
HXDLIN( 168)																int this112 = ((maskPixel3 >> 16) & 255);
HXDLIN( 168)																if ((this112 == 0)) {
HXLINE( 168)																	m13 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	m13 = (( (Float)(this112) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float m23;
HXDLIN( 168)																int this113 = ((maskPixel3 >> 8) & 255);
HXDLIN( 168)																if ((this113 == 0)) {
HXLINE( 168)																	m23 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	m23 = (( (Float)(this113) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float m33;
HXDLIN( 168)																int this114 = (maskPixel3 & 255);
HXDLIN( 168)																if ((this114 == 0)) {
HXLINE( 168)																	m33 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	m33 = (( (Float)(this114) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this110 >> 24) & 255)) )));
HXDLIN( 168)																int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this110 >> 16) & 255)) )));
HXDLIN( 168)																int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this110 >> 8) & 255)) )));
HXDLIN( 168)																int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this110 & 255)) )));
HXDLIN( 168)																col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 168)														if ((col3 != 0)) {
HXLINE( 168)															int x13 = (dx3 - rectLeft3);
HXDLIN( 168)															int y13 = (dy3 - rectTop3);
HXDLIN( 168)															int c14 = col3;
HXDLIN( 168)															bool _hx_tmp25;
HXDLIN( 168)															if ((((c14 >> 24) & 255) < 254)) {
HXLINE( 168)																_hx_tmp25 = undoImage9->transparent;
            															}
            															else {
HXLINE( 168)																_hx_tmp25 = false;
            															}
HXDLIN( 168)															if (_hx_tmp25) {
HXLINE( 168)																int location6;
HXDLIN( 168)																if (undoImage9->useVirtualPos) {
HXLINE( 168)																	location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 168)																	location6 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            																}
HXDLIN( 168)																int this115 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 168)																int this116;
HXDLIN( 168)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																	this116 = ((((((this115 >> 24) & 255) << 24) | ((this115 & 255) << 16)) | (((this115 >> 8) & 255) << 8)) | ((this115 >> 16) & 255));
            																}
            																else {
HXLINE( 168)																	this116 = this115;
            																}
HXDLIN( 168)																Float a18;
HXDLIN( 168)																int this117 = ((this116 >> 24) & 255);
HXDLIN( 168)																if ((this117 == 0)) {
HXLINE( 168)																	a18 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	a18 = (( (Float)(this117) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float r16;
HXDLIN( 168)																int this118 = ((this116 >> 16) & 255);
HXDLIN( 168)																if ((this118 == 0)) {
HXLINE( 168)																	r16 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	r16 = (( (Float)(this118) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float g16;
HXDLIN( 168)																int this119 = ((this116 >> 8) & 255);
HXDLIN( 168)																if ((this119 == 0)) {
HXLINE( 168)																	g16 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	g16 = (( (Float)(this119) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float b110;
HXDLIN( 168)																int this120 = (this116 & 255);
HXDLIN( 168)																if ((this120 == 0)) {
HXLINE( 168)																	b110 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	b110 = (( (Float)(this120) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float a26;
HXDLIN( 168)																int this121 = ((col3 >> 24) & 255);
HXDLIN( 168)																if ((this121 == 0)) {
HXLINE( 168)																	a26 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	a26 = (( (Float)(this121) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float r26;
HXDLIN( 168)																int this122 = ((col3 >> 16) & 255);
HXDLIN( 168)																if ((this122 == 0)) {
HXLINE( 168)																	r26 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	r26 = (( (Float)(this122) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float g26;
HXDLIN( 168)																int this123 = ((col3 >> 8) & 255);
HXDLIN( 168)																if ((this123 == 0)) {
HXLINE( 168)																	g26 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	g26 = (( (Float)(this123) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float b210;
HXDLIN( 168)																int this124 = (col3 & 255);
HXDLIN( 168)																if ((this124 == 0)) {
HXLINE( 168)																	b210 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	b210 = (( (Float)(this124) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float a36 = (a18 * (( (Float)(1) ) - a26));
HXDLIN( 168)																int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN( 168)																int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN( 168)																int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b210 * a26))));
HXDLIN( 168)																int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN( 168)																int blended6 = ((((a19 << 24) | (r8 << 16)) | (g8 << 8)) | b30);
HXDLIN( 168)																{
HXLINE( 168)																	int _hx_tmp26;
HXDLIN( 168)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																		_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            																	}
            																	else {
HXLINE( 168)																		_hx_tmp26 = blended6;
            																	}
HXDLIN( 168)																	::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            																}
            															}
            															else {
HXLINE( 168)																::Dynamic this125 = undoImage9->image;
HXDLIN( 168)																int index17;
HXDLIN( 168)																if (undoImage9->useVirtualPos) {
HXLINE( 168)																	index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 168)																	index17 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            																}
HXDLIN( 168)																int _hx_tmp27;
HXDLIN( 168)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																	_hx_tmp27 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            																}
            																else {
HXLINE( 168)																	_hx_tmp27 = c14;
            																}
HXDLIN( 168)																::iterMagic::Iimg_obj::set(this125,index17,_hx_tmp27);
            															}
            														}
            														else {
HXLINE( 168)															if (forceClear3) {
HXLINE( 168)																::Dynamic this126 = undoImage9->image;
HXDLIN( 168)																int x14 = (dx3 - rectLeft3);
HXDLIN( 168)																int y14 = (dy3 - rectTop3);
HXDLIN( 168)																int index18;
HXDLIN( 168)																if (undoImage9->useVirtualPos) {
HXLINE( 168)																	index18 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            																}
            																else {
HXLINE( 168)																	index18 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            																}
HXDLIN( 168)																::iterMagic::Iimg_obj::set(this126,index18,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 168)								bool found3 = false;
HXDLIN( 168)								Float s3 = ((Float)0.);
HXDLIN( 168)								Float t3 = ((Float)0.);
HXDLIN( 168)								Float sxx3 = ((Float)0.);
HXDLIN( 168)								Float txx3 = ((Float)0.);
HXDLIN( 168)								{
HXLINE( 168)									int _g_min6 = xIter33->start;
HXDLIN( 168)									int _g_max6 = xIter33->max;
HXDLIN( 168)									while((_g_min6 < _g_max6)){
HXLINE( 168)										_g_min6 = (_g_min6 + 1);
HXDLIN( 168)										int x15 = (_g_min6 - 1);
HXLINE(  60)										sxx3 = (sx3 * ( (Float)(x15) ));
HXLINE(  61)										txx3 = (tx3 * ( (Float)(x15) ));
HXLINE(  62)										found3 = false;
HXLINE( 168)										{
HXLINE( 168)											int _g_min7 = yIter33->start;
HXDLIN( 168)											int _g_max7 = yIter33->max;
HXDLIN( 168)											while((_g_min7 < _g_max7)){
HXLINE( 168)												_g_min7 = (_g_min7 + 1);
HXDLIN( 168)												int y15 = (_g_min7 - 1);
HXLINE(  64)												s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y15) )));
HXLINE(  65)												t3 = ((t03 + txx3) + (ty3 * ( (Float)(y15) )));
HXLINE( 168)												bool _hx_tmp28;
HXDLIN( 168)												if (!((s3 <= 0))) {
HXLINE( 168)													_hx_tmp28 = (t3 <= 0);
            												}
            												else {
HXLINE( 168)													_hx_tmp28 = true;
            												}
HXDLIN( 168)												if (_hx_tmp28) {
HXLINE( 168)													if (found3) {
HXLINE( 168)														goto _hx_goto_320;
            													}
            												}
            												else {
HXLINE( 168)													if (((s3 + t3) < A3)) {
HXLINE( 168)														{
HXLINE( 168)															int c15 = -13795390;
HXDLIN( 168)															bool _hx_tmp29;
HXDLIN( 168)															if ((((c15 >> 24) & 255) < 254)) {
HXLINE( 168)																_hx_tmp29 = this104->transparent;
            															}
            															else {
HXLINE( 168)																_hx_tmp29 = false;
            															}
HXDLIN( 168)															if (_hx_tmp29) {
HXLINE( 168)																int location7;
HXDLIN( 168)																if (this104->useVirtualPos) {
HXLINE( 168)																	location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this104->virtualY) * ( (Float)(this104->width) )) + x15) - this104->virtualX));
            																}
            																else {
HXLINE( 168)																	location7 = ::Std_obj::_hx_int(( (Float)(((y15 * this104->width) + x15)) ));
            																}
HXDLIN( 168)																int this127 = ::iterMagic::Iimg_obj::get(this104->image,location7);
HXDLIN( 168)																int this128;
HXDLIN( 168)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																	this128 = ((((((this127 >> 24) & 255) << 24) | ((this127 & 255) << 16)) | (((this127 >> 8) & 255) << 8)) | ((this127 >> 16) & 255));
            																}
            																else {
HXLINE( 168)																	this128 = this127;
            																}
HXDLIN( 168)																Float a110;
HXDLIN( 168)																int this129 = ((this128 >> 24) & 255);
HXDLIN( 168)																if ((this129 == 0)) {
HXLINE( 168)																	a110 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	a110 = (( (Float)(this129) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float r17;
HXDLIN( 168)																int this130 = ((this128 >> 16) & 255);
HXDLIN( 168)																if ((this130 == 0)) {
HXLINE( 168)																	r17 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	r17 = (( (Float)(this130) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float g17;
HXDLIN( 168)																int this131 = ((this128 >> 8) & 255);
HXDLIN( 168)																if ((this131 == 0)) {
HXLINE( 168)																	g17 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	g17 = (( (Float)(this131) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float b111;
HXDLIN( 168)																int this132 = (this128 & 255);
HXDLIN( 168)																if ((this132 == 0)) {
HXLINE( 168)																	b111 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	b111 = (( (Float)(this132) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float a27;
HXDLIN( 168)																int this133 = ((-13795390 >> 24) & 255);
HXDLIN( 168)																if ((this133 == 0)) {
HXLINE( 168)																	a27 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	a27 = (( (Float)(this133) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float r27;
HXDLIN( 168)																int this134 = ((-13795390 >> 16) & 255);
HXDLIN( 168)																if ((this134 == 0)) {
HXLINE( 168)																	r27 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	r27 = (( (Float)(this134) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float g27;
HXDLIN( 168)																int this135 = ((-13795390 >> 8) & 255);
HXDLIN( 168)																if ((this135 == 0)) {
HXLINE( 168)																	g27 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	g27 = (( (Float)(this135) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float b211;
HXDLIN( 168)																int this136 = (-13795390 & 255);
HXDLIN( 168)																if ((this136 == 0)) {
HXLINE( 168)																	b211 = ((Float)0.);
            																}
            																else {
HXLINE( 168)																	b211 = (( (Float)(this136) ) / ( (Float)(255) ));
            																}
HXDLIN( 168)																Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN( 168)																int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN( 168)																int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN( 168)																int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b211 * a27))));
HXDLIN( 168)																int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN( 168)																int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b31);
HXDLIN( 168)																{
HXLINE( 168)																	int _hx_tmp30;
HXDLIN( 168)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																		_hx_tmp30 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																	}
            																	else {
HXLINE( 168)																		_hx_tmp30 = blended7;
            																	}
HXDLIN( 168)																	::iterMagic::Iimg_obj::set(this104->image,location7,_hx_tmp30);
            																}
            															}
            															else {
HXLINE( 168)																::Dynamic this137 = this104->image;
HXDLIN( 168)																int index19;
HXDLIN( 168)																if (this104->useVirtualPos) {
HXLINE( 168)																	index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this104->virtualY) * ( (Float)(this104->width) )) + x15) - this104->virtualX));
            																}
            																else {
HXLINE( 168)																	index19 = ::Std_obj::_hx_int(( (Float)(((y15 * this104->width) + x15)) ));
            																}
HXDLIN( 168)																int _hx_tmp31;
HXDLIN( 168)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)																	_hx_tmp31 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            																}
            																else {
HXLINE( 168)																	_hx_tmp31 = c15;
            																}
HXDLIN( 168)																::iterMagic::Iimg_obj::set(this137,index19,_hx_tmp31);
            															}
            														}
HXLINE(  73)														found3 = true;
            													}
            													else {
HXLINE( 168)														if (found3) {
HXLINE( 168)															goto _hx_goto_320;
            														}
            													}
            												}
            											}
            											_hx_goto_320:;
            										}
            									}
            								}
HXDLIN( 168)								if ((hasHit3 == true)) {
HXLINE( 168)									 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx3,by3,cx4,cy4,true);
HXDLIN( 168)									if (hasUndo3) {
HXLINE( 168)										v11->undoImage = undoImage9;
HXDLIN( 168)										v11->undoX = xIter33->start;
HXDLIN( 168)										v11->undoY = yIter33->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  46)					lastX3 = nextX3;
HXLINE(  47)					lastY3 = nextY3;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FillShape_Impl__obj,simonSays,(void))

void FillShape_Impl__obj::circle( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float r,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_176_circle)
HXDLIN( 176)		 ::Dynamic phi1 = phi;
HXLINE( 179)		if (::hx::IsNull( phi1 )) {
HXLINE( 179)			phi1 = 0;
            		}
HXLINE( 176)		Float rSmall;
HXDLIN( 176)		if ((r > r)) {
HXDLIN( 176)			rSmall = r;
            		}
            		else {
HXDLIN( 176)			rSmall = r;
            		}
HXDLIN( 176)		 ::Dynamic targetE = ((Float)1.05);
HXDLIN( 176)		if (::hx::IsNull( targetE )) {
HXLINE( 534)			targetE = ((Float)1.05);
            		}
HXLINE( 176)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 176)		int noSides;
HXDLIN( 176)		if ((result < 12)) {
HXDLIN( 176)			noSides = 12;
            		}
            		else {
HXDLIN( 176)			if ((result > 500)) {
HXDLIN( 176)				noSides = 500;
            			}
            			else {
HXDLIN( 176)				noSides = result;
            			}
            		}
HXDLIN( 176)		{
HXDLIN( 176)			 ::Dynamic phi2 = phi1;
HXDLIN( 176)			 ::Dynamic sides = noSides;
HXDLIN( 176)			if (::hx::IsNull( sides )) {
HXLINE( 540)				sides = 36;
            			}
HXLINE( 176)			if (::hx::IsNull( phi2 )) {
HXLINE( 539)				phi2 = ((Float)0.);
            			}
HXLINE( 176)			{
HXDLIN( 176)				 ::Dynamic phi3 = phi2;
HXDLIN( 176)				 ::Dynamic sides1 = sides;
HXDLIN( 176)				if (::hx::IsNull( sides1 )) {
HXLINE( 212)					sides1 = 36;
            				}
HXLINE( 176)				if (::hx::IsNull( phi3 )) {
HXLINE( 211)					phi3 = ((Float)0.);
            				}
HXLINE( 176)				Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 176)				Float omega;
HXDLIN( 176)				omega = ((Float)0.);
HXDLIN( 176)				Float lastX = ((Float)0.);
HXDLIN( 176)				Float lastY = ((Float)0.);
HXDLIN( 176)				if (::hx::IsNotEq( phi3,0 )) {
HXLINE(  35)					lastX = ((((r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) ))) - ((r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) )))) + cx);
HXLINE(  36)					lastY = ((((r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) ))) + ((r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) )))) + cy);
            				}
            				else {
HXLINE(  38)					lastX = (cx + (r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)					lastY = (cy + (r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            				}
HXLINE( 176)				if (::hx::IsNotEq( phi3,0 )) {
HXDLIN( 176)					Float cphi = ::Math_obj::cos(( (Float)(phi3) ));
HXDLIN( 176)					Float sphi = ::Math_obj::sin(( (Float)(phi3) ));
HXDLIN( 176)					{
HXDLIN( 176)						int _g = 0;
HXDLIN( 176)						int _g1 = (sides1 + 1);
HXDLIN( 176)						while((_g < _g1)){
HXDLIN( 176)							_g = (_g + 1);
HXDLIN( 176)							int i = (_g - 1);
HXDLIN( 176)							Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 176)							Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 176)							Float nextX = ((((r * ctheta) * cphi) - ((r * stheta) * sphi)) + cx);
HXDLIN( 176)							Float nextY = ((((r * ctheta) * sphi) + ((r * stheta) * cphi)) + cy);
HXDLIN( 176)							{
HXDLIN( 176)								 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 176)								bool hasHit = false;
HXDLIN( 176)								bool hasUndo = false;
HXDLIN( 176)								{
HXDLIN( 176)									Float bx = lastX;
HXDLIN( 176)									Float by = lastY;
HXDLIN( 176)									Float cx1 = nextX;
HXDLIN( 176)									Float cy1 = nextY;
HXDLIN( 176)									bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 176)									if (!(adjustWinding)) {
HXDLIN( 176)										Float bx_ = bx;
HXDLIN( 176)										Float by_ = by;
HXLINE(  25)										bx = cx1;
HXLINE(  26)										by = cy1;
HXLINE(  27)										cx1 = bx_;
HXLINE(  28)										cy1 = by_;
            									}
HXLINE( 176)									{
HXDLIN( 176)										Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 176)										Float sx = (cy1 - cy);
HXDLIN( 176)										Float sy = (cx - cx1);
HXDLIN( 176)										Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 176)										Float tx = (cy - by);
HXDLIN( 176)										Float ty = (bx - cx);
HXDLIN( 176)										Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 176)										 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 176)										if ((cx > bx)) {
HXDLIN( 176)											if ((cx > cx1)) {
HXDLIN( 176)												int min;
HXDLIN( 176)												if ((bx > cx1)) {
HXDLIN( 176)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXDLIN( 176)													min = ::Math_obj::floor(bx);
            												}
HXDLIN( 176)												int ii_min = min;
HXDLIN( 176)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 176)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            											}
            											else {
HXDLIN( 176)												int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 176)												int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 176)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            											}
            										}
            										else {
HXDLIN( 176)											if ((bx > cx1)) {
HXDLIN( 176)												int min1;
HXDLIN( 176)												if ((cx > cx1)) {
HXDLIN( 176)													min1 = ::Math_obj::floor(cx1);
            												}
            												else {
HXDLIN( 176)													min1 = ::Math_obj::ceil(cx);
            												}
HXDLIN( 176)												int ii_min2 = min1;
HXDLIN( 176)												int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 176)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            											}
            											else {
HXDLIN( 176)												int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 176)												int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 176)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            											}
            										}
HXDLIN( 176)										 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 176)										if ((cy > by)) {
HXDLIN( 176)											if ((cy > cy1)) {
HXDLIN( 176)												int min2;
HXDLIN( 176)												if ((by > cy1)) {
HXDLIN( 176)													min2 = ::Math_obj::floor(cy1);
            												}
            												else {
HXDLIN( 176)													min2 = ::Math_obj::floor(by);
            												}
HXDLIN( 176)												int ii_min4 = min2;
HXDLIN( 176)												int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 176)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            											}
            											else {
HXDLIN( 176)												int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 176)												int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 176)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            											}
            										}
            										else {
HXDLIN( 176)											if ((by > cy1)) {
HXDLIN( 176)												int min3;
HXDLIN( 176)												if ((cy > cy1)) {
HXDLIN( 176)													min3 = ::Math_obj::floor(cy1);
            												}
            												else {
HXDLIN( 176)													min3 = ::Math_obj::ceil(cy);
            												}
HXDLIN( 176)												int ii_min6 = min3;
HXDLIN( 176)												int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 176)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            											}
            											else {
HXDLIN( 176)												int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 176)												int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 176)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            											}
            										}
HXDLIN( 176)										 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 176)										if (hasUndo) {
HXDLIN( 176)											int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 176)											int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 176)											 ::Dynamic imageType = null();
HXDLIN( 176)											 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 176)											if (::hx::IsNull( imageType )) {
HXLINE(  54)												imageType = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 176)											::Dynamic undoImage1;
HXDLIN( 176)											switch((int)(( (int)(imageType) ))){
            												case (int)0: {
HXDLIN( 176)													 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 176)													 ::iterMagic::BytesImg b = byt;
HXDLIN( 176)													{
HXDLIN( 176)														b->width = width;
HXDLIN( 176)														b->height = height;
HXDLIN( 176)														b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 176)														b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 176)														{
HXDLIN( 176)															int len = b->length;
HXDLIN( 176)															int w = 0;
HXDLIN( 176)															{
HXDLIN( 176)																int _g2 = 0;
HXDLIN( 176)																int _g3 = b->height;
HXDLIN( 176)																while((_g2 < _g3)){
HXDLIN( 176)																	_g2 = (_g2 + 1);
HXDLIN( 176)																	int y = (_g2 - 1);
HXDLIN( 176)																	{
HXDLIN( 176)																		int _g4 = 0;
HXDLIN( 176)																		int _g5 = b->width;
HXDLIN( 176)																		while((_g4 < _g5)){
HXDLIN( 176)																			_g4 = (_g4 + 1);
HXDLIN( 176)																			int x = (_g4 - 1);
HXDLIN( 176)																			{
HXDLIN( 176)																				w = (w + 1);
HXDLIN( 176)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 176)																			{
HXDLIN( 176)																				w = (w + 1);
HXDLIN( 176)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 176)																			{
HXDLIN( 176)																				w = (w + 1);
HXDLIN( 176)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 176)																			{
HXDLIN( 176)																				w = (w + 1);
HXDLIN( 176)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 176)													undoImage1 = b;
            												}
            												break;
            												case (int)1: {
HXDLIN( 176)													 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)													 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 176)													{
HXDLIN( 176)														a->width = width;
HXDLIN( 176)														a->height = height;
HXDLIN( 176)														a->data = ::Array_obj< int >::__new(0);
HXDLIN( 176)														a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 176)														{
HXDLIN( 176)															int _g6 = 0;
HXDLIN( 176)															int _g7 = a->length;
HXDLIN( 176)															while((_g6 < _g7)){
HXDLIN( 176)																_g6 = (_g6 + 1);
HXDLIN( 176)																int i1 = (_g6 - 1);
HXDLIN( 176)																a->data[i1] = 0;
            															}
            														}
            													}
HXDLIN( 176)													undoImage1 = a;
            												}
            												break;
            												case (int)2: {
HXDLIN( 176)													 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 176)													 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 176)													{
HXDLIN( 176)														b1->width = width;
HXDLIN( 176)														b1->height = height;
HXDLIN( 176)														b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 176)														int size = (b1->length * 4);
HXDLIN( 176)														b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 176)														{
HXDLIN( 176)															int _g8 = 0;
HXDLIN( 176)															int _g9 = b1->length;
HXDLIN( 176)															while((_g8 < _g9)){
HXDLIN( 176)																_g8 = (_g8 + 1);
HXDLIN( 176)																int i2 = (_g8 - 1);
HXDLIN( 176)																{
HXDLIN( 176)																	 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 176)																	bool undoImage2;
HXDLIN( 176)																	if ((i2 >= 0)) {
HXDLIN( 176)																		undoImage2 = (i2 < (this4->byteLength >> 2));
            																	}
            																	else {
HXDLIN( 176)																		undoImage2 = false;
            																	}
HXDLIN( 176)																	if (undoImage2) {
HXDLIN( 176)																		 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 176)																		int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 176)																		_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 176)																		_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 176)																		_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 176)																		_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 176)													undoImage1 = b1;
            												}
            												break;
            												case (int)3: {
HXDLIN( 176)													 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)													 ::iterMagic::VecIntImg v = vec;
HXDLIN( 176)													{
HXDLIN( 176)														v->width = width;
HXDLIN( 176)														v->height = height;
HXDLIN( 176)														v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 176)														v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 176)														{
HXDLIN( 176)															int _g10 = 0;
HXDLIN( 176)															int _g11 = v->length;
HXDLIN( 176)															while((_g10 < _g11)){
HXDLIN( 176)																_g10 = (_g10 + 1);
HXDLIN( 176)																int i3 = (_g10 - 1);
HXDLIN( 176)																v->data->__unsafe_set(i3,0);
            															}
            														}
            													}
HXDLIN( 176)													undoImage1 = v;
            												}
            												break;
            												case (int)4: {
HXDLIN( 176)													 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)													 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 176)													{
HXDLIN( 176)														b2->width = width;
HXDLIN( 176)														b2->height = height;
HXDLIN( 176)														b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 176)														b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 176)														{
HXDLIN( 176)															int len1 = b2->length;
HXDLIN( 176)															 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 176)															if (::hx::IsNull( d->head )) {
HXDLIN( 176)																int _g12 = 0;
HXDLIN( 176)																int _g13 = len1;
HXDLIN( 176)																while((_g12 < _g13)){
HXDLIN( 176)																	_g12 = (_g12 + 1);
HXDLIN( 176)																	int i4 = (_g12 - 1);
HXDLIN( 176)																	d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            																}
            															}
            															else {
HXDLIN( 176)																int _g14 = 0;
HXDLIN( 176)																int _g15 = len1;
HXDLIN( 176)																while((_g14 < _g15)){
HXDLIN( 176)																	_g14 = (_g14 + 1);
HXDLIN( 176)																	int i5 = (_g14 - 1);
HXDLIN( 176)																	{
HXDLIN( 176)																		 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 176)																		 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 176)																		{
HXDLIN( 176)																			int _g16 = 0;
HXDLIN( 176)																			int _g17 = i5;
HXDLIN( 176)																			while((_g16 < _g17)){
HXDLIN( 176)																				_g16 = (_g16 + 1);
HXDLIN( 176)																				int i6 = (_g16 - 1);
HXLINE( 345)																				prev = l;
HXLINE( 346)																				l = l->next;
            																			}
            																		}
HXLINE( 176)																		if (::hx::IsNull( prev )) {
HXDLIN( 176)																			b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 176)																			l = null();
            																		}
            																		else {
HXDLIN( 176)																			prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 176)																			l = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 176)													undoImage1 = b2;
            												}
            												break;
            											}
HXDLIN( 176)											this3->image = undoImage1;
HXDLIN( 176)											this3->width = width;
HXDLIN( 176)											this3->height = height;
HXDLIN( 176)											this3->imageType = ( (int)(imageType) );
HXDLIN( 176)											undoImage = this3;
HXDLIN( 176)											{
HXDLIN( 176)												int rectLeft = xIter3->start;
HXDLIN( 176)												int rectTop = yIter3->start;
HXDLIN( 176)												int rectRight = xIter3->max;
HXDLIN( 176)												bool forceClear = false;
HXDLIN( 176)												{
HXDLIN( 176)													int _g18 = rectTop;
HXDLIN( 176)													int _g19 = yIter3->max;
HXDLIN( 176)													while((_g18 < _g19)){
HXDLIN( 176)														_g18 = (_g18 + 1);
HXDLIN( 176)														int dy = (_g18 - 1);
HXDLIN( 176)														{
HXDLIN( 176)															int _g20 = rectLeft;
HXDLIN( 176)															int _g21 = rectRight;
HXDLIN( 176)															while((_g20 < _g21)){
HXDLIN( 176)																_g20 = (_g20 + 1);
HXDLIN( 176)																int dx = (_g20 - 1);
HXDLIN( 176)																::Dynamic this5 = this2->image;
HXDLIN( 176)																int index;
HXDLIN( 176)																if (this2->useVirtualPos) {
HXDLIN( 176)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            																}
            																else {
HXDLIN( 176)																	index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            																}
HXDLIN( 176)																int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 176)																int col;
HXDLIN( 176)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXDLIN( 176)																	col = c;
            																}
HXDLIN( 176)																bool _hx_tmp;
HXDLIN( 176)																if (this2->useMask) {
HXDLIN( 176)																	_hx_tmp = ::hx::IsNotNull( this2->mask );
            																}
            																else {
HXDLIN( 176)																	_hx_tmp = false;
            																}
HXDLIN( 176)																if (_hx_tmp) {
HXDLIN( 176)																	 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 176)																	::Dynamic this7 = this6->image;
HXDLIN( 176)																	int index1;
HXDLIN( 176)																	if (this6->useVirtualPos) {
HXDLIN( 176)																		index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																	}
            																	else {
HXDLIN( 176)																		index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																	}
HXDLIN( 176)																	int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 176)																	int v1;
HXDLIN( 176)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																		v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 176)																		v1 = c1;
            																	}
HXDLIN( 176)																	int maskPixel = v1;
HXDLIN( 176)																	int this8 = col;
HXDLIN( 176)																	if ((maskPixel == 0)) {
HXDLIN( 176)																		col = this8;
            																	}
            																	else {
HXDLIN( 176)																		Float m0;
HXDLIN( 176)																		int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 176)																		if ((this9 == 0)) {
HXDLIN( 176)																			m0 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float m1;
HXDLIN( 176)																		int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 176)																		if ((this10 == 0)) {
HXDLIN( 176)																			m1 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float m2;
HXDLIN( 176)																		int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 176)																		if ((this11 == 0)) {
HXDLIN( 176)																			m2 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float m3;
HXDLIN( 176)																		int this12 = (maskPixel & 255);
HXDLIN( 176)																		if ((this12 == 0)) {
HXDLIN( 176)																			m3 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 176)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 176)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 176)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 176)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 176)																if ((col != 0)) {
HXDLIN( 176)																	int x1 = (dx - rectLeft);
HXDLIN( 176)																	int y1 = (dy - rectTop);
HXDLIN( 176)																	int c2 = col;
HXDLIN( 176)																	bool _hx_tmp1;
HXDLIN( 176)																	if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 176)																		_hx_tmp1 = undoImage->transparent;
            																	}
            																	else {
HXDLIN( 176)																		_hx_tmp1 = false;
            																	}
HXDLIN( 176)																	if (_hx_tmp1) {
HXDLIN( 176)																		int location;
HXDLIN( 176)																		if (undoImage->useVirtualPos) {
HXDLIN( 176)																			location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																		}
            																		else {
HXDLIN( 176)																			location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																		}
HXDLIN( 176)																		int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 176)																		int this14;
HXDLIN( 176)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																			this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 176)																			this14 = this13;
            																		}
HXDLIN( 176)																		Float a1;
HXDLIN( 176)																		int this15 = ((this14 >> 24) & 255);
HXDLIN( 176)																		if ((this15 == 0)) {
HXDLIN( 176)																			a1 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float r1;
HXDLIN( 176)																		int this16 = ((this14 >> 16) & 255);
HXDLIN( 176)																		if ((this16 == 0)) {
HXDLIN( 176)																			r1 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float g1;
HXDLIN( 176)																		int this17 = ((this14 >> 8) & 255);
HXDLIN( 176)																		if ((this17 == 0)) {
HXDLIN( 176)																			g1 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float b11;
HXDLIN( 176)																		int this18 = (this14 & 255);
HXDLIN( 176)																		if ((this18 == 0)) {
HXDLIN( 176)																			b11 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float a2;
HXDLIN( 176)																		int this19 = ((col >> 24) & 255);
HXDLIN( 176)																		if ((this19 == 0)) {
HXDLIN( 176)																			a2 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float r2;
HXDLIN( 176)																		int this20 = ((col >> 16) & 255);
HXDLIN( 176)																		if ((this20 == 0)) {
HXDLIN( 176)																			r2 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float g2;
HXDLIN( 176)																		int this21 = ((col >> 8) & 255);
HXDLIN( 176)																		if ((this21 == 0)) {
HXDLIN( 176)																			g2 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float b21;
HXDLIN( 176)																		int this22 = (col & 255);
HXDLIN( 176)																		if ((this22 == 0)) {
HXDLIN( 176)																			b21 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 176)																		int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 176)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 176)																		int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 176)																		int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 176)																		int blended = ((((a4 << 24) | (r3 << 16)) | (g << 8)) | b3);
HXDLIN( 176)																		{
HXDLIN( 176)																			int _hx_tmp2;
HXDLIN( 176)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																				_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXDLIN( 176)																				_hx_tmp2 = blended;
            																			}
HXDLIN( 176)																			::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																		}
            																	}
            																	else {
HXDLIN( 176)																		::Dynamic this23 = undoImage->image;
HXDLIN( 176)																		int index2;
HXDLIN( 176)																		if (undoImage->useVirtualPos) {
HXDLIN( 176)																			index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																		}
            																		else {
HXDLIN( 176)																			index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																		}
HXDLIN( 176)																		int _hx_tmp3;
HXDLIN( 176)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																			_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 176)																			_hx_tmp3 = c2;
            																		}
HXDLIN( 176)																		::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																	}
            																}
            																else {
HXDLIN( 176)																	if (forceClear) {
HXDLIN( 176)																		::Dynamic this24 = undoImage->image;
HXDLIN( 176)																		int x2 = (dx - rectLeft);
HXDLIN( 176)																		int y2 = (dy - rectTop);
HXDLIN( 176)																		int index3;
HXDLIN( 176)																		if (undoImage->useVirtualPos) {
HXDLIN( 176)																			index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																		}
            																		else {
HXDLIN( 176)																			index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																		}
HXDLIN( 176)																		::iterMagic::Iimg_obj::set(this24,index3,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 176)										bool found = false;
HXDLIN( 176)										Float s = ((Float)0.);
HXDLIN( 176)										Float t = ((Float)0.);
HXDLIN( 176)										Float sxx = ((Float)0.);
HXDLIN( 176)										Float txx = ((Float)0.);
HXDLIN( 176)										{
HXDLIN( 176)											int _g_min = xIter3->start;
HXDLIN( 176)											int _g_max = xIter3->max;
HXDLIN( 176)											while((_g_min < _g_max)){
HXDLIN( 176)												_g_min = (_g_min + 1);
HXDLIN( 176)												int x3 = (_g_min - 1);
HXLINE(  60)												sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)												txx = (tx * ( (Float)(x3) ));
HXLINE(  62)												found = false;
HXLINE( 176)												{
HXDLIN( 176)													int _g_min1 = yIter3->start;
HXDLIN( 176)													int _g_max1 = yIter3->max;
HXDLIN( 176)													while((_g_min1 < _g_max1)){
HXDLIN( 176)														_g_min1 = (_g_min1 + 1);
HXDLIN( 176)														int y3 = (_g_min1 - 1);
HXLINE(  64)														s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)														t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 176)														bool _hx_tmp4;
HXDLIN( 176)														if (!((s <= 0))) {
HXDLIN( 176)															_hx_tmp4 = (t <= 0);
            														}
            														else {
HXDLIN( 176)															_hx_tmp4 = true;
            														}
HXDLIN( 176)														if (_hx_tmp4) {
HXDLIN( 176)															if (found) {
HXDLIN( 176)																goto _hx_goto_334;
            															}
            														}
            														else {
HXDLIN( 176)															if (((s + t) < A)) {
HXDLIN( 176)																{
HXDLIN( 176)																	int c3 = color;
HXDLIN( 176)																	bool _hx_tmp5;
HXDLIN( 176)																	if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 176)																		_hx_tmp5 = this2->transparent;
            																	}
            																	else {
HXDLIN( 176)																		_hx_tmp5 = false;
            																	}
HXDLIN( 176)																	if (_hx_tmp5) {
HXDLIN( 176)																		int location1;
HXDLIN( 176)																		if (this2->useVirtualPos) {
HXDLIN( 176)																			location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																		}
            																		else {
HXDLIN( 176)																			location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																		}
HXDLIN( 176)																		int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 176)																		int this26;
HXDLIN( 176)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																			this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 176)																			this26 = this25;
            																		}
HXDLIN( 176)																		Float a11;
HXDLIN( 176)																		int this27 = ((this26 >> 24) & 255);
HXDLIN( 176)																		if ((this27 == 0)) {
HXDLIN( 176)																			a11 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float r11;
HXDLIN( 176)																		int this28 = ((this26 >> 16) & 255);
HXDLIN( 176)																		if ((this28 == 0)) {
HXDLIN( 176)																			r11 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float g11;
HXDLIN( 176)																		int this29 = ((this26 >> 8) & 255);
HXDLIN( 176)																		if ((this29 == 0)) {
HXDLIN( 176)																			g11 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float b12;
HXDLIN( 176)																		int this30 = (this26 & 255);
HXDLIN( 176)																		if ((this30 == 0)) {
HXDLIN( 176)																			b12 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float a21;
HXDLIN( 176)																		int this31 = ((color >> 24) & 255);
HXDLIN( 176)																		if ((this31 == 0)) {
HXDLIN( 176)																			a21 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float r21;
HXDLIN( 176)																		int this32 = ((color >> 16) & 255);
HXDLIN( 176)																		if ((this32 == 0)) {
HXDLIN( 176)																			r21 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float g21;
HXDLIN( 176)																		int this33 = ((color >> 8) & 255);
HXDLIN( 176)																		if ((this33 == 0)) {
HXDLIN( 176)																			g21 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float b22;
HXDLIN( 176)																		int this34 = (color & 255);
HXDLIN( 176)																		if ((this34 == 0)) {
HXDLIN( 176)																			b22 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 176)																			b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																		}
HXDLIN( 176)																		Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 176)																		int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 176)																		int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 176)																		int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 176)																		int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 176)																		int blended1 = ((((a5 << 24) | (r4 << 16)) | (g3 << 8)) | b4);
HXDLIN( 176)																		{
HXDLIN( 176)																			int _hx_tmp6;
HXDLIN( 176)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																				_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																			}
            																			else {
HXDLIN( 176)																				_hx_tmp6 = blended1;
            																			}
HXDLIN( 176)																			::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																		}
            																	}
            																	else {
HXDLIN( 176)																		::Dynamic this35 = this2->image;
HXDLIN( 176)																		int index4;
HXDLIN( 176)																		if (this2->useVirtualPos) {
HXDLIN( 176)																			index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																		}
            																		else {
HXDLIN( 176)																			index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																		}
HXDLIN( 176)																		int _hx_tmp7;
HXDLIN( 176)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																			_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 176)																			_hx_tmp7 = c3;
            																		}
HXDLIN( 176)																		::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																	}
            																}
HXLINE(  73)																found = true;
            															}
            															else {
HXDLIN( 176)																if (found) {
HXDLIN( 176)																	goto _hx_goto_334;
            																}
            															}
            														}
            													}
            													_hx_goto_334:;
            												}
            											}
            										}
HXDLIN( 176)										if ((hasHit == true)) {
HXDLIN( 176)											 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 176)											if (hasUndo) {
HXDLIN( 176)												v2->undoImage = undoImage;
HXDLIN( 176)												v2->undoX = xIter3->start;
HXDLIN( 176)												v2->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  51)							lastX = nextX;
HXLINE(  52)							lastY = nextY;
            						}
            					}
            				}
            				else {
HXDLIN( 176)					int _g22 = 0;
HXDLIN( 176)					int _g23 = (sides1 + 1);
HXDLIN( 176)					while((_g22 < _g23)){
HXDLIN( 176)						_g22 = (_g22 + 1);
HXDLIN( 176)						int i7 = (_g22 - 1);
HXDLIN( 176)						Float nextX1 = (cx + (r * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 176)						Float nextY1 = (cy + (r * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 176)						{
HXDLIN( 176)							 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 176)							bool hasHit1 = false;
HXDLIN( 176)							bool hasUndo1 = false;
HXDLIN( 176)							{
HXDLIN( 176)								Float bx1 = lastX;
HXDLIN( 176)								Float by1 = lastY;
HXDLIN( 176)								Float cx2 = nextX1;
HXDLIN( 176)								Float cy2 = nextY1;
HXDLIN( 176)								bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 176)								if (!(adjustWinding1)) {
HXDLIN( 176)									Float bx_1 = bx1;
HXDLIN( 176)									Float by_1 = by1;
HXLINE(  25)									bx1 = cx2;
HXLINE(  26)									by1 = cy2;
HXLINE(  27)									cx2 = bx_1;
HXLINE(  28)									cy2 = by_1;
            								}
HXLINE( 176)								{
HXDLIN( 176)									Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 176)									Float sx1 = (cy2 - cy);
HXDLIN( 176)									Float sy1 = (cx - cx2);
HXDLIN( 176)									Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 176)									Float tx1 = (cy - by1);
HXDLIN( 176)									Float ty1 = (bx1 - cx);
HXDLIN( 176)									Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 176)									 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 176)									if ((cx > bx1)) {
HXDLIN( 176)										if ((cx > cx2)) {
HXDLIN( 176)											int min4;
HXDLIN( 176)											if ((bx1 > cx2)) {
HXDLIN( 176)												min4 = ::Math_obj::floor(cx2);
            											}
            											else {
HXDLIN( 176)												min4 = ::Math_obj::floor(bx1);
            											}
HXDLIN( 176)											int ii_min8 = min4;
HXDLIN( 176)											int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 176)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            										}
            										else {
HXDLIN( 176)											int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 176)											int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 176)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            										}
            									}
            									else {
HXDLIN( 176)										if ((bx1 > cx2)) {
HXDLIN( 176)											int min5;
HXDLIN( 176)											if ((cx > cx2)) {
HXDLIN( 176)												min5 = ::Math_obj::floor(cx2);
            											}
            											else {
HXDLIN( 176)												min5 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 176)											int ii_min10 = min5;
HXDLIN( 176)											int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 176)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            										}
            										else {
HXDLIN( 176)											int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 176)											int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 176)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            										}
            									}
HXDLIN( 176)									 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 176)									if ((cy > by1)) {
HXDLIN( 176)										if ((cy > cy2)) {
HXDLIN( 176)											int min6;
HXDLIN( 176)											if ((by1 > cy2)) {
HXDLIN( 176)												min6 = ::Math_obj::floor(cy2);
            											}
            											else {
HXDLIN( 176)												min6 = ::Math_obj::floor(by1);
            											}
HXDLIN( 176)											int ii_min12 = min6;
HXDLIN( 176)											int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 176)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            										}
            										else {
HXDLIN( 176)											int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 176)											int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 176)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            										}
            									}
            									else {
HXDLIN( 176)										if ((by1 > cy2)) {
HXDLIN( 176)											int min7;
HXDLIN( 176)											if ((cy > cy2)) {
HXDLIN( 176)												min7 = ::Math_obj::floor(cy2);
            											}
            											else {
HXDLIN( 176)												min7 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 176)											int ii_min14 = min7;
HXDLIN( 176)											int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 176)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            										}
            										else {
HXDLIN( 176)											int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 176)											int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 176)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            										}
            									}
HXDLIN( 176)									 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 176)									if (hasUndo1) {
HXDLIN( 176)										int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 176)										int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 176)										 ::Dynamic imageType1 = null();
HXDLIN( 176)										 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 176)										if (::hx::IsNull( imageType1 )) {
HXLINE(  54)											imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 176)										::Dynamic undoImage4;
HXDLIN( 176)										switch((int)(( (int)(imageType1) ))){
            											case (int)0: {
HXDLIN( 176)												 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 176)												 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 176)												{
HXDLIN( 176)													b5->width = width1;
HXDLIN( 176)													b5->height = height1;
HXDLIN( 176)													b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)													b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 176)													{
HXDLIN( 176)														int len2 = b5->length;
HXDLIN( 176)														int w1 = 0;
HXDLIN( 176)														{
HXDLIN( 176)															int _g24 = 0;
HXDLIN( 176)															int _g25 = b5->height;
HXDLIN( 176)															while((_g24 < _g25)){
HXDLIN( 176)																_g24 = (_g24 + 1);
HXDLIN( 176)																int y4 = (_g24 - 1);
HXDLIN( 176)																{
HXDLIN( 176)																	int _g26 = 0;
HXDLIN( 176)																	int _g27 = b5->width;
HXDLIN( 176)																	while((_g26 < _g27)){
HXDLIN( 176)																		_g26 = (_g26 + 1);
HXDLIN( 176)																		int x4 = (_g26 - 1);
HXDLIN( 176)																		{
HXDLIN( 176)																			w1 = (w1 + 1);
HXDLIN( 176)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 176)																		{
HXDLIN( 176)																			w1 = (w1 + 1);
HXDLIN( 176)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 176)																		{
HXDLIN( 176)																			w1 = (w1 + 1);
HXDLIN( 176)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 176)																		{
HXDLIN( 176)																			w1 = (w1 + 1);
HXDLIN( 176)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 176)												undoImage4 = b5;
            											}
            											break;
            											case (int)1: {
HXDLIN( 176)												 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)												 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 176)												{
HXDLIN( 176)													a6->width = width1;
HXDLIN( 176)													a6->height = height1;
HXDLIN( 176)													a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 176)													a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)													{
HXDLIN( 176)														int _g28 = 0;
HXDLIN( 176)														int _g29 = a6->length;
HXDLIN( 176)														while((_g28 < _g29)){
HXDLIN( 176)															_g28 = (_g28 + 1);
HXDLIN( 176)															int i8 = (_g28 - 1);
HXDLIN( 176)															a6->data[i8] = 0;
            														}
            													}
            												}
HXDLIN( 176)												undoImage4 = a6;
            											}
            											break;
            											case (int)2: {
HXDLIN( 176)												 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 176)												 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 176)												{
HXDLIN( 176)													b6->width = width1;
HXDLIN( 176)													b6->height = height1;
HXDLIN( 176)													b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)													int size1 = (b6->length * 4);
HXDLIN( 176)													b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 176)													{
HXDLIN( 176)														int _g30 = 0;
HXDLIN( 176)														int _g31 = b6->length;
HXDLIN( 176)														while((_g30 < _g31)){
HXDLIN( 176)															_g30 = (_g30 + 1);
HXDLIN( 176)															int i9 = (_g30 - 1);
HXDLIN( 176)															{
HXDLIN( 176)																 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 176)																bool undoImage5;
HXDLIN( 176)																if ((i9 >= 0)) {
HXDLIN( 176)																	undoImage5 = (i9 < (this38->byteLength >> 2));
            																}
            																else {
HXDLIN( 176)																	undoImage5 = false;
            																}
HXDLIN( 176)																if (undoImage5) {
HXDLIN( 176)																	 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 176)																	int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 176)																	_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 176)																	_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 176)																	_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 176)																	_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 176)												undoImage4 = b6;
            											}
            											break;
            											case (int)3: {
HXDLIN( 176)												 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)												 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 176)												{
HXDLIN( 176)													v3->width = width1;
HXDLIN( 176)													v3->height = height1;
HXDLIN( 176)													v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)													v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 176)													{
HXDLIN( 176)														int _g32 = 0;
HXDLIN( 176)														int _g33 = v3->length;
HXDLIN( 176)														while((_g32 < _g33)){
HXDLIN( 176)															_g32 = (_g32 + 1);
HXDLIN( 176)															int i10 = (_g32 - 1);
HXDLIN( 176)															v3->data->__unsafe_set(i10,0);
            														}
            													}
            												}
HXDLIN( 176)												undoImage4 = v3;
            											}
            											break;
            											case (int)4: {
HXDLIN( 176)												 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 176)												 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 176)												{
HXDLIN( 176)													b7->width = width1;
HXDLIN( 176)													b7->height = height1;
HXDLIN( 176)													b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 176)													b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 176)													{
HXDLIN( 176)														int len3 = b7->length;
HXDLIN( 176)														 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 176)														if (::hx::IsNull( d1->head )) {
HXDLIN( 176)															int _g34 = 0;
HXDLIN( 176)															int _g35 = len3;
HXDLIN( 176)															while((_g34 < _g35)){
HXDLIN( 176)																_g34 = (_g34 + 1);
HXDLIN( 176)																int i11 = (_g34 - 1);
HXDLIN( 176)																d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            															}
            														}
            														else {
HXDLIN( 176)															int _g36 = 0;
HXDLIN( 176)															int _g37 = len3;
HXDLIN( 176)															while((_g36 < _g37)){
HXDLIN( 176)																_g36 = (_g36 + 1);
HXDLIN( 176)																int i12 = (_g36 - 1);
HXDLIN( 176)																{
HXDLIN( 176)																	 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 176)																	 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 176)																	{
HXDLIN( 176)																		int _g38 = 0;
HXDLIN( 176)																		int _g39 = i12;
HXDLIN( 176)																		while((_g38 < _g39)){
HXDLIN( 176)																			_g38 = (_g38 + 1);
HXDLIN( 176)																			int i13 = (_g38 - 1);
HXLINE( 345)																			prev1 = l1;
HXLINE( 346)																			l1 = l1->next;
            																		}
            																	}
HXLINE( 176)																	if (::hx::IsNull( prev1 )) {
HXDLIN( 176)																		b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 176)																		l1 = null();
            																	}
            																	else {
HXDLIN( 176)																		prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 176)																		l1 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 176)												undoImage4 = b7;
            											}
            											break;
            										}
HXDLIN( 176)										this37->image = undoImage4;
HXDLIN( 176)										this37->width = width1;
HXDLIN( 176)										this37->height = height1;
HXDLIN( 176)										this37->imageType = ( (int)(imageType1) );
HXDLIN( 176)										undoImage3 = this37;
HXDLIN( 176)										{
HXDLIN( 176)											int rectLeft1 = xIter31->start;
HXDLIN( 176)											int rectTop1 = yIter31->start;
HXDLIN( 176)											int rectRight1 = xIter31->max;
HXDLIN( 176)											bool forceClear1 = false;
HXDLIN( 176)											{
HXDLIN( 176)												int _g40 = rectTop1;
HXDLIN( 176)												int _g41 = yIter31->max;
HXDLIN( 176)												while((_g40 < _g41)){
HXDLIN( 176)													_g40 = (_g40 + 1);
HXDLIN( 176)													int dy1 = (_g40 - 1);
HXDLIN( 176)													{
HXDLIN( 176)														int _g42 = rectLeft1;
HXDLIN( 176)														int _g43 = rectRight1;
HXDLIN( 176)														while((_g42 < _g43)){
HXDLIN( 176)															_g42 = (_g42 + 1);
HXDLIN( 176)															int dx1 = (_g42 - 1);
HXDLIN( 176)															::Dynamic this39 = this36->image;
HXDLIN( 176)															int index5;
HXDLIN( 176)															if (this36->useVirtualPos) {
HXDLIN( 176)																index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            															}
            															else {
HXDLIN( 176)																index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            															}
HXDLIN( 176)															int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 176)															int col1;
HXDLIN( 176)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            															}
            															else {
HXDLIN( 176)																col1 = c4;
            															}
HXDLIN( 176)															bool _hx_tmp8;
HXDLIN( 176)															if (this36->useMask) {
HXDLIN( 176)																_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            															}
            															else {
HXDLIN( 176)																_hx_tmp8 = false;
            															}
HXDLIN( 176)															if (_hx_tmp8) {
HXDLIN( 176)																 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 176)																::Dynamic this41 = this40->image;
HXDLIN( 176)																int index6;
HXDLIN( 176)																if (this40->useVirtualPos) {
HXDLIN( 176)																	index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            																}
            																else {
HXDLIN( 176)																	index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            																}
HXDLIN( 176)																int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 176)																int v4;
HXDLIN( 176)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																	v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            																}
            																else {
HXDLIN( 176)																	v4 = c5;
            																}
HXDLIN( 176)																int maskPixel1 = v4;
HXDLIN( 176)																int this42 = col1;
HXDLIN( 176)																if ((maskPixel1 == 0)) {
HXDLIN( 176)																	col1 = this42;
            																}
            																else {
HXDLIN( 176)																	Float m01;
HXDLIN( 176)																	int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 176)																	if ((this43 == 0)) {
HXDLIN( 176)																		m01 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float m11;
HXDLIN( 176)																	int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 176)																	if ((this44 == 0)) {
HXDLIN( 176)																		m11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float m21;
HXDLIN( 176)																	int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 176)																	if ((this45 == 0)) {
HXDLIN( 176)																		m21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float m31;
HXDLIN( 176)																	int this46 = (maskPixel1 & 255);
HXDLIN( 176)																	if ((this46 == 0)) {
HXDLIN( 176)																		m31 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 176)																	int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 176)																	int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 176)																	int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 176)																	col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 176)															if ((col1 != 0)) {
HXDLIN( 176)																int x5 = (dx1 - rectLeft1);
HXDLIN( 176)																int y5 = (dy1 - rectTop1);
HXDLIN( 176)																int c6 = col1;
HXDLIN( 176)																bool _hx_tmp9;
HXDLIN( 176)																if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 176)																	_hx_tmp9 = undoImage3->transparent;
            																}
            																else {
HXDLIN( 176)																	_hx_tmp9 = false;
            																}
HXDLIN( 176)																if (_hx_tmp9) {
HXDLIN( 176)																	int location2;
HXDLIN( 176)																	if (undoImage3->useVirtualPos) {
HXDLIN( 176)																		location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN( 176)																		location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																	}
HXDLIN( 176)																	int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 176)																	int this48;
HXDLIN( 176)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																		this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 176)																		this48 = this47;
            																	}
HXDLIN( 176)																	Float a12;
HXDLIN( 176)																	int this49 = ((this48 >> 24) & 255);
HXDLIN( 176)																	if ((this49 == 0)) {
HXDLIN( 176)																		a12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float r12;
HXDLIN( 176)																	int this50 = ((this48 >> 16) & 255);
HXDLIN( 176)																	if ((this50 == 0)) {
HXDLIN( 176)																		r12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float g12;
HXDLIN( 176)																	int this51 = ((this48 >> 8) & 255);
HXDLIN( 176)																	if ((this51 == 0)) {
HXDLIN( 176)																		g12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float b13;
HXDLIN( 176)																	int this52 = (this48 & 255);
HXDLIN( 176)																	if ((this52 == 0)) {
HXDLIN( 176)																		b13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float a22;
HXDLIN( 176)																	int this53 = ((col1 >> 24) & 255);
HXDLIN( 176)																	if ((this53 == 0)) {
HXDLIN( 176)																		a22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float r22;
HXDLIN( 176)																	int this54 = ((col1 >> 16) & 255);
HXDLIN( 176)																	if ((this54 == 0)) {
HXDLIN( 176)																		r22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float g22;
HXDLIN( 176)																	int this55 = ((col1 >> 8) & 255);
HXDLIN( 176)																	if ((this55 == 0)) {
HXDLIN( 176)																		g22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float b23;
HXDLIN( 176)																	int this56 = (col1 & 255);
HXDLIN( 176)																	if ((this56 == 0)) {
HXDLIN( 176)																		b23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 176)																	int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 176)																	int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 176)																	int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 176)																	int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 176)																	int blended2 = ((((a7 << 24) | (r5 << 16)) | (g4 << 8)) | b8);
HXDLIN( 176)																	{
HXDLIN( 176)																		int _hx_tmp10;
HXDLIN( 176)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																			_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 176)																			_hx_tmp10 = blended2;
            																		}
HXDLIN( 176)																		::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																	}
            																}
            																else {
HXDLIN( 176)																	::Dynamic this57 = undoImage3->image;
HXDLIN( 176)																	int index7;
HXDLIN( 176)																	if (undoImage3->useVirtualPos) {
HXDLIN( 176)																		index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN( 176)																		index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																	}
HXDLIN( 176)																	int _hx_tmp11;
HXDLIN( 176)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																		_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 176)																		_hx_tmp11 = c6;
            																	}
HXDLIN( 176)																	::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            																}
            															}
            															else {
HXDLIN( 176)																if (forceClear1) {
HXDLIN( 176)																	::Dynamic this58 = undoImage3->image;
HXDLIN( 176)																	int x6 = (dx1 - rectLeft1);
HXDLIN( 176)																	int y6 = (dy1 - rectTop1);
HXDLIN( 176)																	int index8;
HXDLIN( 176)																	if (undoImage3->useVirtualPos) {
HXDLIN( 176)																		index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN( 176)																		index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																	}
HXDLIN( 176)																	::iterMagic::Iimg_obj::set(this58,index8,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 176)									bool found1 = false;
HXDLIN( 176)									Float s1 = ((Float)0.);
HXDLIN( 176)									Float t1 = ((Float)0.);
HXDLIN( 176)									Float sxx1 = ((Float)0.);
HXDLIN( 176)									Float txx1 = ((Float)0.);
HXDLIN( 176)									{
HXDLIN( 176)										int _g_min2 = xIter31->start;
HXDLIN( 176)										int _g_max2 = xIter31->max;
HXDLIN( 176)										while((_g_min2 < _g_max2)){
HXDLIN( 176)											_g_min2 = (_g_min2 + 1);
HXDLIN( 176)											int x7 = (_g_min2 - 1);
HXLINE(  60)											sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)											txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)											found1 = false;
HXLINE( 176)											{
HXDLIN( 176)												int _g_min3 = yIter31->start;
HXDLIN( 176)												int _g_max3 = yIter31->max;
HXDLIN( 176)												while((_g_min3 < _g_max3)){
HXDLIN( 176)													_g_min3 = (_g_min3 + 1);
HXDLIN( 176)													int y7 = (_g_min3 - 1);
HXLINE(  64)													s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)													t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 176)													bool _hx_tmp12;
HXDLIN( 176)													if (!((s1 <= 0))) {
HXDLIN( 176)														_hx_tmp12 = (t1 <= 0);
            													}
            													else {
HXDLIN( 176)														_hx_tmp12 = true;
            													}
HXDLIN( 176)													if (_hx_tmp12) {
HXDLIN( 176)														if (found1) {
HXDLIN( 176)															goto _hx_goto_347;
            														}
            													}
            													else {
HXDLIN( 176)														if (((s1 + t1) < A1)) {
HXDLIN( 176)															{
HXDLIN( 176)																int c7 = color;
HXDLIN( 176)																bool _hx_tmp13;
HXDLIN( 176)																if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 176)																	_hx_tmp13 = this36->transparent;
            																}
            																else {
HXDLIN( 176)																	_hx_tmp13 = false;
            																}
HXDLIN( 176)																if (_hx_tmp13) {
HXDLIN( 176)																	int location3;
HXDLIN( 176)																	if (this36->useVirtualPos) {
HXDLIN( 176)																		location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																	}
            																	else {
HXDLIN( 176)																		location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																	}
HXDLIN( 176)																	int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 176)																	int this60;
HXDLIN( 176)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																		this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 176)																		this60 = this59;
            																	}
HXDLIN( 176)																	Float a13;
HXDLIN( 176)																	int this61 = ((this60 >> 24) & 255);
HXDLIN( 176)																	if ((this61 == 0)) {
HXDLIN( 176)																		a13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float r13;
HXDLIN( 176)																	int this62 = ((this60 >> 16) & 255);
HXDLIN( 176)																	if ((this62 == 0)) {
HXDLIN( 176)																		r13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float g13;
HXDLIN( 176)																	int this63 = ((this60 >> 8) & 255);
HXDLIN( 176)																	if ((this63 == 0)) {
HXDLIN( 176)																		g13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float b14;
HXDLIN( 176)																	int this64 = (this60 & 255);
HXDLIN( 176)																	if ((this64 == 0)) {
HXDLIN( 176)																		b14 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float a23;
HXDLIN( 176)																	int this65 = ((color >> 24) & 255);
HXDLIN( 176)																	if ((this65 == 0)) {
HXDLIN( 176)																		a23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float r23;
HXDLIN( 176)																	int this66 = ((color >> 16) & 255);
HXDLIN( 176)																	if ((this66 == 0)) {
HXDLIN( 176)																		r23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float g23;
HXDLIN( 176)																	int this67 = ((color >> 8) & 255);
HXDLIN( 176)																	if ((this67 == 0)) {
HXDLIN( 176)																		g23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float b24;
HXDLIN( 176)																	int this68 = (color & 255);
HXDLIN( 176)																	if ((this68 == 0)) {
HXDLIN( 176)																		b24 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 176)																		b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																	}
HXDLIN( 176)																	Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 176)																	int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 176)																	int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 176)																	int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 176)																	int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 176)																	int blended3 = ((((a8 << 24) | (r6 << 16)) | (g5 << 8)) | b9);
HXDLIN( 176)																	{
HXDLIN( 176)																		int _hx_tmp14;
HXDLIN( 176)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																			_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 176)																			_hx_tmp14 = blended3;
            																		}
HXDLIN( 176)																		::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																	}
            																}
            																else {
HXDLIN( 176)																	::Dynamic this69 = this36->image;
HXDLIN( 176)																	int index9;
HXDLIN( 176)																	if (this36->useVirtualPos) {
HXDLIN( 176)																		index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																	}
            																	else {
HXDLIN( 176)																		index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																	}
HXDLIN( 176)																	int _hx_tmp15;
HXDLIN( 176)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 176)																		_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 176)																		_hx_tmp15 = c7;
            																	}
HXDLIN( 176)																	::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            																}
            															}
HXLINE(  73)															found1 = true;
            														}
            														else {
HXDLIN( 176)															if (found1) {
HXDLIN( 176)																goto _hx_goto_347;
            															}
            														}
            													}
            												}
            												_hx_goto_347:;
            											}
            										}
            									}
HXDLIN( 176)									if ((hasHit1 == true)) {
HXDLIN( 176)										 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 176)										if (hasUndo1) {
HXDLIN( 176)											v5->undoImage = undoImage3;
HXDLIN( 176)											v5->undoX = xIter31->start;
HXDLIN( 176)											v5->undoY = yIter31->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  59)						lastX = nextX1;
HXLINE(  60)						lastY = nextY1;
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(FillShape_Impl__obj,circle,(void))

void FillShape_Impl__obj::ellipse( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_187_ellipse)
HXDLIN( 187)		 ::Dynamic phi1 = phi;
HXLINE( 190)		if (::hx::IsNull( phi1 )) {
HXLINE( 190)			phi1 = 0;
            		}
HXLINE( 187)		Float rSmall;
HXDLIN( 187)		if ((rx > ry)) {
HXDLIN( 187)			rSmall = ry;
            		}
            		else {
HXDLIN( 187)			rSmall = rx;
            		}
HXDLIN( 187)		 ::Dynamic targetE = ((Float)1.05);
HXDLIN( 187)		if (::hx::IsNull( targetE )) {
HXLINE( 534)			targetE = ((Float)1.05);
            		}
HXLINE( 187)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 187)		int noSides;
HXDLIN( 187)		if ((result < 12)) {
HXDLIN( 187)			noSides = 12;
            		}
            		else {
HXDLIN( 187)			if ((result > 500)) {
HXDLIN( 187)				noSides = 500;
            			}
            			else {
HXDLIN( 187)				noSides = result;
            			}
            		}
HXDLIN( 187)		{
HXDLIN( 187)			 ::Dynamic phi2 = phi1;
HXDLIN( 187)			 ::Dynamic sides = noSides;
HXDLIN( 187)			if (::hx::IsNull( sides )) {
HXLINE( 540)				sides = 36;
            			}
HXLINE( 187)			if (::hx::IsNull( phi2 )) {
HXLINE( 539)				phi2 = ((Float)0.);
            			}
HXLINE( 187)			{
HXDLIN( 187)				 ::Dynamic phi3 = phi2;
HXDLIN( 187)				 ::Dynamic sides1 = sides;
HXDLIN( 187)				if (::hx::IsNull( sides1 )) {
HXLINE( 212)					sides1 = 36;
            				}
HXLINE( 187)				if (::hx::IsNull( phi3 )) {
HXLINE( 211)					phi3 = ((Float)0.);
            				}
HXLINE( 187)				Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 187)				Float omega;
HXDLIN( 187)				omega = ((Float)0.);
HXDLIN( 187)				Float lastX = ((Float)0.);
HXDLIN( 187)				Float lastY = ((Float)0.);
HXDLIN( 187)				if (::hx::IsNotEq( phi3,0 )) {
HXLINE(  35)					lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) )))) + cx);
HXLINE(  36)					lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) )))) + cy);
            				}
            				else {
HXLINE(  38)					lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)					lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            				}
HXLINE( 187)				if (::hx::IsNotEq( phi3,0 )) {
HXDLIN( 187)					Float cphi = ::Math_obj::cos(( (Float)(phi3) ));
HXDLIN( 187)					Float sphi = ::Math_obj::sin(( (Float)(phi3) ));
HXDLIN( 187)					{
HXDLIN( 187)						int _g = 0;
HXDLIN( 187)						int _g1 = (sides1 + 1);
HXDLIN( 187)						while((_g < _g1)){
HXDLIN( 187)							_g = (_g + 1);
HXDLIN( 187)							int i = (_g - 1);
HXDLIN( 187)							Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 187)							Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 187)							Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 187)							Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 187)							{
HXDLIN( 187)								 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 187)								bool hasHit = false;
HXDLIN( 187)								bool hasUndo = false;
HXDLIN( 187)								{
HXDLIN( 187)									Float bx = lastX;
HXDLIN( 187)									Float by = lastY;
HXDLIN( 187)									Float cx1 = nextX;
HXDLIN( 187)									Float cy1 = nextY;
HXDLIN( 187)									bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 187)									if (!(adjustWinding)) {
HXDLIN( 187)										Float bx_ = bx;
HXDLIN( 187)										Float by_ = by;
HXLINE(  25)										bx = cx1;
HXLINE(  26)										by = cy1;
HXLINE(  27)										cx1 = bx_;
HXLINE(  28)										cy1 = by_;
            									}
HXLINE( 187)									{
HXDLIN( 187)										Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 187)										Float sx = (cy1 - cy);
HXDLIN( 187)										Float sy = (cx - cx1);
HXDLIN( 187)										Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 187)										Float tx = (cy - by);
HXDLIN( 187)										Float ty = (bx - cx);
HXDLIN( 187)										Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 187)										 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 187)										if ((cx > bx)) {
HXDLIN( 187)											if ((cx > cx1)) {
HXDLIN( 187)												int min;
HXDLIN( 187)												if ((bx > cx1)) {
HXDLIN( 187)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXDLIN( 187)													min = ::Math_obj::floor(bx);
            												}
HXDLIN( 187)												int ii_min = min;
HXDLIN( 187)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 187)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            											}
            											else {
HXDLIN( 187)												int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 187)												int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 187)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            											}
            										}
            										else {
HXDLIN( 187)											if ((bx > cx1)) {
HXDLIN( 187)												int min1;
HXDLIN( 187)												if ((cx > cx1)) {
HXDLIN( 187)													min1 = ::Math_obj::floor(cx1);
            												}
            												else {
HXDLIN( 187)													min1 = ::Math_obj::ceil(cx);
            												}
HXDLIN( 187)												int ii_min2 = min1;
HXDLIN( 187)												int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 187)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            											}
            											else {
HXDLIN( 187)												int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 187)												int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 187)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            											}
            										}
HXDLIN( 187)										 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 187)										if ((cy > by)) {
HXDLIN( 187)											if ((cy > cy1)) {
HXDLIN( 187)												int min2;
HXDLIN( 187)												if ((by > cy1)) {
HXDLIN( 187)													min2 = ::Math_obj::floor(cy1);
            												}
            												else {
HXDLIN( 187)													min2 = ::Math_obj::floor(by);
            												}
HXDLIN( 187)												int ii_min4 = min2;
HXDLIN( 187)												int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 187)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            											}
            											else {
HXDLIN( 187)												int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 187)												int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 187)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            											}
            										}
            										else {
HXDLIN( 187)											if ((by > cy1)) {
HXDLIN( 187)												int min3;
HXDLIN( 187)												if ((cy > cy1)) {
HXDLIN( 187)													min3 = ::Math_obj::floor(cy1);
            												}
            												else {
HXDLIN( 187)													min3 = ::Math_obj::ceil(cy);
            												}
HXDLIN( 187)												int ii_min6 = min3;
HXDLIN( 187)												int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 187)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            											}
            											else {
HXDLIN( 187)												int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 187)												int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 187)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            											}
            										}
HXDLIN( 187)										 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 187)										if (hasUndo) {
HXDLIN( 187)											int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 187)											int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 187)											 ::Dynamic imageType = null();
HXDLIN( 187)											 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 187)											if (::hx::IsNull( imageType )) {
HXLINE(  54)												imageType = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 187)											::Dynamic undoImage1;
HXDLIN( 187)											switch((int)(( (int)(imageType) ))){
            												case (int)0: {
HXDLIN( 187)													 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 187)													 ::iterMagic::BytesImg b = byt;
HXDLIN( 187)													{
HXDLIN( 187)														b->width = width;
HXDLIN( 187)														b->height = height;
HXDLIN( 187)														b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 187)														b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 187)														{
HXDLIN( 187)															int len = b->length;
HXDLIN( 187)															int w = 0;
HXDLIN( 187)															{
HXDLIN( 187)																int _g2 = 0;
HXDLIN( 187)																int _g3 = b->height;
HXDLIN( 187)																while((_g2 < _g3)){
HXDLIN( 187)																	_g2 = (_g2 + 1);
HXDLIN( 187)																	int y = (_g2 - 1);
HXDLIN( 187)																	{
HXDLIN( 187)																		int _g4 = 0;
HXDLIN( 187)																		int _g5 = b->width;
HXDLIN( 187)																		while((_g4 < _g5)){
HXDLIN( 187)																			_g4 = (_g4 + 1);
HXDLIN( 187)																			int x = (_g4 - 1);
HXDLIN( 187)																			{
HXDLIN( 187)																				w = (w + 1);
HXDLIN( 187)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 187)																			{
HXDLIN( 187)																				w = (w + 1);
HXDLIN( 187)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 187)																			{
HXDLIN( 187)																				w = (w + 1);
HXDLIN( 187)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 187)																			{
HXDLIN( 187)																				w = (w + 1);
HXDLIN( 187)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 187)													undoImage1 = b;
            												}
            												break;
            												case (int)1: {
HXDLIN( 187)													 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)													 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 187)													{
HXDLIN( 187)														a->width = width;
HXDLIN( 187)														a->height = height;
HXDLIN( 187)														a->data = ::Array_obj< int >::__new(0);
HXDLIN( 187)														a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 187)														{
HXDLIN( 187)															int _g6 = 0;
HXDLIN( 187)															int _g7 = a->length;
HXDLIN( 187)															while((_g6 < _g7)){
HXDLIN( 187)																_g6 = (_g6 + 1);
HXDLIN( 187)																int i1 = (_g6 - 1);
HXDLIN( 187)																a->data[i1] = 0;
            															}
            														}
            													}
HXDLIN( 187)													undoImage1 = a;
            												}
            												break;
            												case (int)2: {
HXDLIN( 187)													 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 187)													 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 187)													{
HXDLIN( 187)														b1->width = width;
HXDLIN( 187)														b1->height = height;
HXDLIN( 187)														b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 187)														int size = (b1->length * 4);
HXDLIN( 187)														b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 187)														{
HXDLIN( 187)															int _g8 = 0;
HXDLIN( 187)															int _g9 = b1->length;
HXDLIN( 187)															while((_g8 < _g9)){
HXDLIN( 187)																_g8 = (_g8 + 1);
HXDLIN( 187)																int i2 = (_g8 - 1);
HXDLIN( 187)																{
HXDLIN( 187)																	 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 187)																	bool undoImage2;
HXDLIN( 187)																	if ((i2 >= 0)) {
HXDLIN( 187)																		undoImage2 = (i2 < (this4->byteLength >> 2));
            																	}
            																	else {
HXDLIN( 187)																		undoImage2 = false;
            																	}
HXDLIN( 187)																	if (undoImage2) {
HXDLIN( 187)																		 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 187)																		int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 187)																		_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 187)																		_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 187)																		_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 187)																		_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 187)													undoImage1 = b1;
            												}
            												break;
            												case (int)3: {
HXDLIN( 187)													 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)													 ::iterMagic::VecIntImg v = vec;
HXDLIN( 187)													{
HXDLIN( 187)														v->width = width;
HXDLIN( 187)														v->height = height;
HXDLIN( 187)														v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 187)														v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 187)														{
HXDLIN( 187)															int _g10 = 0;
HXDLIN( 187)															int _g11 = v->length;
HXDLIN( 187)															while((_g10 < _g11)){
HXDLIN( 187)																_g10 = (_g10 + 1);
HXDLIN( 187)																int i3 = (_g10 - 1);
HXDLIN( 187)																v->data->__unsafe_set(i3,0);
            															}
            														}
            													}
HXDLIN( 187)													undoImage1 = v;
            												}
            												break;
            												case (int)4: {
HXDLIN( 187)													 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)													 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 187)													{
HXDLIN( 187)														b2->width = width;
HXDLIN( 187)														b2->height = height;
HXDLIN( 187)														b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 187)														b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 187)														{
HXDLIN( 187)															int len1 = b2->length;
HXDLIN( 187)															 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 187)															if (::hx::IsNull( d->head )) {
HXDLIN( 187)																int _g12 = 0;
HXDLIN( 187)																int _g13 = len1;
HXDLIN( 187)																while((_g12 < _g13)){
HXDLIN( 187)																	_g12 = (_g12 + 1);
HXDLIN( 187)																	int i4 = (_g12 - 1);
HXDLIN( 187)																	d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            																}
            															}
            															else {
HXDLIN( 187)																int _g14 = 0;
HXDLIN( 187)																int _g15 = len1;
HXDLIN( 187)																while((_g14 < _g15)){
HXDLIN( 187)																	_g14 = (_g14 + 1);
HXDLIN( 187)																	int i5 = (_g14 - 1);
HXDLIN( 187)																	{
HXDLIN( 187)																		 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 187)																		 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 187)																		{
HXDLIN( 187)																			int _g16 = 0;
HXDLIN( 187)																			int _g17 = i5;
HXDLIN( 187)																			while((_g16 < _g17)){
HXDLIN( 187)																				_g16 = (_g16 + 1);
HXDLIN( 187)																				int i6 = (_g16 - 1);
HXLINE( 345)																				prev = l;
HXLINE( 346)																				l = l->next;
            																			}
            																		}
HXLINE( 187)																		if (::hx::IsNull( prev )) {
HXDLIN( 187)																			b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 187)																			l = null();
            																		}
            																		else {
HXDLIN( 187)																			prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 187)																			l = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 187)													undoImage1 = b2;
            												}
            												break;
            											}
HXDLIN( 187)											this3->image = undoImage1;
HXDLIN( 187)											this3->width = width;
HXDLIN( 187)											this3->height = height;
HXDLIN( 187)											this3->imageType = ( (int)(imageType) );
HXDLIN( 187)											undoImage = this3;
HXDLIN( 187)											{
HXDLIN( 187)												int rectLeft = xIter3->start;
HXDLIN( 187)												int rectTop = yIter3->start;
HXDLIN( 187)												int rectRight = xIter3->max;
HXDLIN( 187)												bool forceClear = false;
HXDLIN( 187)												{
HXDLIN( 187)													int _g18 = rectTop;
HXDLIN( 187)													int _g19 = yIter3->max;
HXDLIN( 187)													while((_g18 < _g19)){
HXDLIN( 187)														_g18 = (_g18 + 1);
HXDLIN( 187)														int dy = (_g18 - 1);
HXDLIN( 187)														{
HXDLIN( 187)															int _g20 = rectLeft;
HXDLIN( 187)															int _g21 = rectRight;
HXDLIN( 187)															while((_g20 < _g21)){
HXDLIN( 187)																_g20 = (_g20 + 1);
HXDLIN( 187)																int dx = (_g20 - 1);
HXDLIN( 187)																::Dynamic this5 = this2->image;
HXDLIN( 187)																int index;
HXDLIN( 187)																if (this2->useVirtualPos) {
HXDLIN( 187)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            																}
            																else {
HXDLIN( 187)																	index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            																}
HXDLIN( 187)																int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 187)																int col;
HXDLIN( 187)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXDLIN( 187)																	col = c;
            																}
HXDLIN( 187)																bool _hx_tmp;
HXDLIN( 187)																if (this2->useMask) {
HXDLIN( 187)																	_hx_tmp = ::hx::IsNotNull( this2->mask );
            																}
            																else {
HXDLIN( 187)																	_hx_tmp = false;
            																}
HXDLIN( 187)																if (_hx_tmp) {
HXDLIN( 187)																	 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 187)																	::Dynamic this7 = this6->image;
HXDLIN( 187)																	int index1;
HXDLIN( 187)																	if (this6->useVirtualPos) {
HXDLIN( 187)																		index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																	}
            																	else {
HXDLIN( 187)																		index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																	}
HXDLIN( 187)																	int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 187)																	int v1;
HXDLIN( 187)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																		v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 187)																		v1 = c1;
            																	}
HXDLIN( 187)																	int maskPixel = v1;
HXDLIN( 187)																	int this8 = col;
HXDLIN( 187)																	if ((maskPixel == 0)) {
HXDLIN( 187)																		col = this8;
            																	}
            																	else {
HXDLIN( 187)																		Float m0;
HXDLIN( 187)																		int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 187)																		if ((this9 == 0)) {
HXDLIN( 187)																			m0 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float m1;
HXDLIN( 187)																		int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 187)																		if ((this10 == 0)) {
HXDLIN( 187)																			m1 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float m2;
HXDLIN( 187)																		int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 187)																		if ((this11 == 0)) {
HXDLIN( 187)																			m2 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float m3;
HXDLIN( 187)																		int this12 = (maskPixel & 255);
HXDLIN( 187)																		if ((this12 == 0)) {
HXDLIN( 187)																			m3 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 187)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 187)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 187)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 187)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 187)																if ((col != 0)) {
HXDLIN( 187)																	int x1 = (dx - rectLeft);
HXDLIN( 187)																	int y1 = (dy - rectTop);
HXDLIN( 187)																	int c2 = col;
HXDLIN( 187)																	bool _hx_tmp1;
HXDLIN( 187)																	if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 187)																		_hx_tmp1 = undoImage->transparent;
            																	}
            																	else {
HXDLIN( 187)																		_hx_tmp1 = false;
            																	}
HXDLIN( 187)																	if (_hx_tmp1) {
HXDLIN( 187)																		int location;
HXDLIN( 187)																		if (undoImage->useVirtualPos) {
HXDLIN( 187)																			location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																		}
            																		else {
HXDLIN( 187)																			location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																		}
HXDLIN( 187)																		int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 187)																		int this14;
HXDLIN( 187)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																			this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 187)																			this14 = this13;
            																		}
HXDLIN( 187)																		Float a1;
HXDLIN( 187)																		int this15 = ((this14 >> 24) & 255);
HXDLIN( 187)																		if ((this15 == 0)) {
HXDLIN( 187)																			a1 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float r1;
HXDLIN( 187)																		int this16 = ((this14 >> 16) & 255);
HXDLIN( 187)																		if ((this16 == 0)) {
HXDLIN( 187)																			r1 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float g1;
HXDLIN( 187)																		int this17 = ((this14 >> 8) & 255);
HXDLIN( 187)																		if ((this17 == 0)) {
HXDLIN( 187)																			g1 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float b11;
HXDLIN( 187)																		int this18 = (this14 & 255);
HXDLIN( 187)																		if ((this18 == 0)) {
HXDLIN( 187)																			b11 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float a2;
HXDLIN( 187)																		int this19 = ((col >> 24) & 255);
HXDLIN( 187)																		if ((this19 == 0)) {
HXDLIN( 187)																			a2 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float r2;
HXDLIN( 187)																		int this20 = ((col >> 16) & 255);
HXDLIN( 187)																		if ((this20 == 0)) {
HXDLIN( 187)																			r2 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float g2;
HXDLIN( 187)																		int this21 = ((col >> 8) & 255);
HXDLIN( 187)																		if ((this21 == 0)) {
HXDLIN( 187)																			g2 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float b21;
HXDLIN( 187)																		int this22 = (col & 255);
HXDLIN( 187)																		if ((this22 == 0)) {
HXDLIN( 187)																			b21 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 187)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 187)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 187)																		int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 187)																		int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 187)																		int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 187)																		{
HXDLIN( 187)																			int _hx_tmp2;
HXDLIN( 187)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																				_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXDLIN( 187)																				_hx_tmp2 = blended;
            																			}
HXDLIN( 187)																			::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																		}
            																	}
            																	else {
HXDLIN( 187)																		::Dynamic this23 = undoImage->image;
HXDLIN( 187)																		int index2;
HXDLIN( 187)																		if (undoImage->useVirtualPos) {
HXDLIN( 187)																			index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																		}
            																		else {
HXDLIN( 187)																			index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																		}
HXDLIN( 187)																		int _hx_tmp3;
HXDLIN( 187)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																			_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 187)																			_hx_tmp3 = c2;
            																		}
HXDLIN( 187)																		::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																	}
            																}
            																else {
HXDLIN( 187)																	if (forceClear) {
HXDLIN( 187)																		::Dynamic this24 = undoImage->image;
HXDLIN( 187)																		int x2 = (dx - rectLeft);
HXDLIN( 187)																		int y2 = (dy - rectTop);
HXDLIN( 187)																		int index3;
HXDLIN( 187)																		if (undoImage->useVirtualPos) {
HXDLIN( 187)																			index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																		}
            																		else {
HXDLIN( 187)																			index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																		}
HXDLIN( 187)																		::iterMagic::Iimg_obj::set(this24,index3,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 187)										bool found = false;
HXDLIN( 187)										Float s = ((Float)0.);
HXDLIN( 187)										Float t = ((Float)0.);
HXDLIN( 187)										Float sxx = ((Float)0.);
HXDLIN( 187)										Float txx = ((Float)0.);
HXDLIN( 187)										{
HXDLIN( 187)											int _g_min = xIter3->start;
HXDLIN( 187)											int _g_max = xIter3->max;
HXDLIN( 187)											while((_g_min < _g_max)){
HXDLIN( 187)												_g_min = (_g_min + 1);
HXDLIN( 187)												int x3 = (_g_min - 1);
HXLINE(  60)												sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)												txx = (tx * ( (Float)(x3) ));
HXLINE(  62)												found = false;
HXLINE( 187)												{
HXDLIN( 187)													int _g_min1 = yIter3->start;
HXDLIN( 187)													int _g_max1 = yIter3->max;
HXDLIN( 187)													while((_g_min1 < _g_max1)){
HXDLIN( 187)														_g_min1 = (_g_min1 + 1);
HXDLIN( 187)														int y3 = (_g_min1 - 1);
HXLINE(  64)														s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)														t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 187)														bool _hx_tmp4;
HXDLIN( 187)														if (!((s <= 0))) {
HXDLIN( 187)															_hx_tmp4 = (t <= 0);
            														}
            														else {
HXDLIN( 187)															_hx_tmp4 = true;
            														}
HXDLIN( 187)														if (_hx_tmp4) {
HXDLIN( 187)															if (found) {
HXDLIN( 187)																goto _hx_goto_361;
            															}
            														}
            														else {
HXDLIN( 187)															if (((s + t) < A)) {
HXDLIN( 187)																{
HXDLIN( 187)																	int c3 = color;
HXDLIN( 187)																	bool _hx_tmp5;
HXDLIN( 187)																	if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 187)																		_hx_tmp5 = this2->transparent;
            																	}
            																	else {
HXDLIN( 187)																		_hx_tmp5 = false;
            																	}
HXDLIN( 187)																	if (_hx_tmp5) {
HXDLIN( 187)																		int location1;
HXDLIN( 187)																		if (this2->useVirtualPos) {
HXDLIN( 187)																			location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																		}
            																		else {
HXDLIN( 187)																			location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																		}
HXDLIN( 187)																		int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 187)																		int this26;
HXDLIN( 187)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																			this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 187)																			this26 = this25;
            																		}
HXDLIN( 187)																		Float a11;
HXDLIN( 187)																		int this27 = ((this26 >> 24) & 255);
HXDLIN( 187)																		if ((this27 == 0)) {
HXDLIN( 187)																			a11 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float r11;
HXDLIN( 187)																		int this28 = ((this26 >> 16) & 255);
HXDLIN( 187)																		if ((this28 == 0)) {
HXDLIN( 187)																			r11 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float g11;
HXDLIN( 187)																		int this29 = ((this26 >> 8) & 255);
HXDLIN( 187)																		if ((this29 == 0)) {
HXDLIN( 187)																			g11 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float b12;
HXDLIN( 187)																		int this30 = (this26 & 255);
HXDLIN( 187)																		if ((this30 == 0)) {
HXDLIN( 187)																			b12 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float a21;
HXDLIN( 187)																		int this31 = ((color >> 24) & 255);
HXDLIN( 187)																		if ((this31 == 0)) {
HXDLIN( 187)																			a21 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float r21;
HXDLIN( 187)																		int this32 = ((color >> 16) & 255);
HXDLIN( 187)																		if ((this32 == 0)) {
HXDLIN( 187)																			r21 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float g21;
HXDLIN( 187)																		int this33 = ((color >> 8) & 255);
HXDLIN( 187)																		if ((this33 == 0)) {
HXDLIN( 187)																			g21 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float b22;
HXDLIN( 187)																		int this34 = (color & 255);
HXDLIN( 187)																		if ((this34 == 0)) {
HXDLIN( 187)																			b22 = ((Float)0.);
            																		}
            																		else {
HXDLIN( 187)																			b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																		}
HXDLIN( 187)																		Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 187)																		int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 187)																		int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 187)																		int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 187)																		int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 187)																		int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 187)																		{
HXDLIN( 187)																			int _hx_tmp6;
HXDLIN( 187)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																				_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																			}
            																			else {
HXDLIN( 187)																				_hx_tmp6 = blended1;
            																			}
HXDLIN( 187)																			::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																		}
            																	}
            																	else {
HXDLIN( 187)																		::Dynamic this35 = this2->image;
HXDLIN( 187)																		int index4;
HXDLIN( 187)																		if (this2->useVirtualPos) {
HXDLIN( 187)																			index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																		}
            																		else {
HXDLIN( 187)																			index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																		}
HXDLIN( 187)																		int _hx_tmp7;
HXDLIN( 187)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																			_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 187)																			_hx_tmp7 = c3;
            																		}
HXDLIN( 187)																		::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																	}
            																}
HXLINE(  73)																found = true;
            															}
            															else {
HXDLIN( 187)																if (found) {
HXDLIN( 187)																	goto _hx_goto_361;
            																}
            															}
            														}
            													}
            													_hx_goto_361:;
            												}
            											}
            										}
HXDLIN( 187)										if ((hasHit == true)) {
HXDLIN( 187)											 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 187)											if (hasUndo) {
HXDLIN( 187)												v2->undoImage = undoImage;
HXDLIN( 187)												v2->undoX = xIter3->start;
HXDLIN( 187)												v2->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  51)							lastX = nextX;
HXLINE(  52)							lastY = nextY;
            						}
            					}
            				}
            				else {
HXDLIN( 187)					int _g22 = 0;
HXDLIN( 187)					int _g23 = (sides1 + 1);
HXDLIN( 187)					while((_g22 < _g23)){
HXDLIN( 187)						_g22 = (_g22 + 1);
HXDLIN( 187)						int i7 = (_g22 - 1);
HXDLIN( 187)						Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 187)						Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 187)						{
HXDLIN( 187)							 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 187)							bool hasHit1 = false;
HXDLIN( 187)							bool hasUndo1 = false;
HXDLIN( 187)							{
HXDLIN( 187)								Float bx1 = lastX;
HXDLIN( 187)								Float by1 = lastY;
HXDLIN( 187)								Float cx2 = nextX1;
HXDLIN( 187)								Float cy2 = nextY1;
HXDLIN( 187)								bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 187)								if (!(adjustWinding1)) {
HXDLIN( 187)									Float bx_1 = bx1;
HXDLIN( 187)									Float by_1 = by1;
HXLINE(  25)									bx1 = cx2;
HXLINE(  26)									by1 = cy2;
HXLINE(  27)									cx2 = bx_1;
HXLINE(  28)									cy2 = by_1;
            								}
HXLINE( 187)								{
HXDLIN( 187)									Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 187)									Float sx1 = (cy2 - cy);
HXDLIN( 187)									Float sy1 = (cx - cx2);
HXDLIN( 187)									Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 187)									Float tx1 = (cy - by1);
HXDLIN( 187)									Float ty1 = (bx1 - cx);
HXDLIN( 187)									Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 187)									 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 187)									if ((cx > bx1)) {
HXDLIN( 187)										if ((cx > cx2)) {
HXDLIN( 187)											int min4;
HXDLIN( 187)											if ((bx1 > cx2)) {
HXDLIN( 187)												min4 = ::Math_obj::floor(cx2);
            											}
            											else {
HXDLIN( 187)												min4 = ::Math_obj::floor(bx1);
            											}
HXDLIN( 187)											int ii_min8 = min4;
HXDLIN( 187)											int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 187)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            										}
            										else {
HXDLIN( 187)											int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 187)											int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 187)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            										}
            									}
            									else {
HXDLIN( 187)										if ((bx1 > cx2)) {
HXDLIN( 187)											int min5;
HXDLIN( 187)											if ((cx > cx2)) {
HXDLIN( 187)												min5 = ::Math_obj::floor(cx2);
            											}
            											else {
HXDLIN( 187)												min5 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 187)											int ii_min10 = min5;
HXDLIN( 187)											int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 187)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            										}
            										else {
HXDLIN( 187)											int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 187)											int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 187)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            										}
            									}
HXDLIN( 187)									 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 187)									if ((cy > by1)) {
HXDLIN( 187)										if ((cy > cy2)) {
HXDLIN( 187)											int min6;
HXDLIN( 187)											if ((by1 > cy2)) {
HXDLIN( 187)												min6 = ::Math_obj::floor(cy2);
            											}
            											else {
HXDLIN( 187)												min6 = ::Math_obj::floor(by1);
            											}
HXDLIN( 187)											int ii_min12 = min6;
HXDLIN( 187)											int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 187)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            										}
            										else {
HXDLIN( 187)											int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 187)											int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 187)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            										}
            									}
            									else {
HXDLIN( 187)										if ((by1 > cy2)) {
HXDLIN( 187)											int min7;
HXDLIN( 187)											if ((cy > cy2)) {
HXDLIN( 187)												min7 = ::Math_obj::floor(cy2);
            											}
            											else {
HXDLIN( 187)												min7 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 187)											int ii_min14 = min7;
HXDLIN( 187)											int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 187)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            										}
            										else {
HXDLIN( 187)											int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 187)											int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 187)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            										}
            									}
HXDLIN( 187)									 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 187)									if (hasUndo1) {
HXDLIN( 187)										int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 187)										int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 187)										 ::Dynamic imageType1 = null();
HXDLIN( 187)										 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 187)										if (::hx::IsNull( imageType1 )) {
HXLINE(  54)											imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 187)										::Dynamic undoImage4;
HXDLIN( 187)										switch((int)(( (int)(imageType1) ))){
            											case (int)0: {
HXDLIN( 187)												 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 187)												 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 187)												{
HXDLIN( 187)													b5->width = width1;
HXDLIN( 187)													b5->height = height1;
HXDLIN( 187)													b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)													b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 187)													{
HXDLIN( 187)														int len2 = b5->length;
HXDLIN( 187)														int w1 = 0;
HXDLIN( 187)														{
HXDLIN( 187)															int _g24 = 0;
HXDLIN( 187)															int _g25 = b5->height;
HXDLIN( 187)															while((_g24 < _g25)){
HXDLIN( 187)																_g24 = (_g24 + 1);
HXDLIN( 187)																int y4 = (_g24 - 1);
HXDLIN( 187)																{
HXDLIN( 187)																	int _g26 = 0;
HXDLIN( 187)																	int _g27 = b5->width;
HXDLIN( 187)																	while((_g26 < _g27)){
HXDLIN( 187)																		_g26 = (_g26 + 1);
HXDLIN( 187)																		int x4 = (_g26 - 1);
HXDLIN( 187)																		{
HXDLIN( 187)																			w1 = (w1 + 1);
HXDLIN( 187)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 187)																		{
HXDLIN( 187)																			w1 = (w1 + 1);
HXDLIN( 187)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 187)																		{
HXDLIN( 187)																			w1 = (w1 + 1);
HXDLIN( 187)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 187)																		{
HXDLIN( 187)																			w1 = (w1 + 1);
HXDLIN( 187)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 187)												undoImage4 = b5;
            											}
            											break;
            											case (int)1: {
HXDLIN( 187)												 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)												 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 187)												{
HXDLIN( 187)													a6->width = width1;
HXDLIN( 187)													a6->height = height1;
HXDLIN( 187)													a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 187)													a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)													{
HXDLIN( 187)														int _g28 = 0;
HXDLIN( 187)														int _g29 = a6->length;
HXDLIN( 187)														while((_g28 < _g29)){
HXDLIN( 187)															_g28 = (_g28 + 1);
HXDLIN( 187)															int i8 = (_g28 - 1);
HXDLIN( 187)															a6->data[i8] = 0;
            														}
            													}
            												}
HXDLIN( 187)												undoImage4 = a6;
            											}
            											break;
            											case (int)2: {
HXDLIN( 187)												 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 187)												 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 187)												{
HXDLIN( 187)													b6->width = width1;
HXDLIN( 187)													b6->height = height1;
HXDLIN( 187)													b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)													int size1 = (b6->length * 4);
HXDLIN( 187)													b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 187)													{
HXDLIN( 187)														int _g30 = 0;
HXDLIN( 187)														int _g31 = b6->length;
HXDLIN( 187)														while((_g30 < _g31)){
HXDLIN( 187)															_g30 = (_g30 + 1);
HXDLIN( 187)															int i9 = (_g30 - 1);
HXDLIN( 187)															{
HXDLIN( 187)																 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 187)																bool undoImage5;
HXDLIN( 187)																if ((i9 >= 0)) {
HXDLIN( 187)																	undoImage5 = (i9 < (this38->byteLength >> 2));
            																}
            																else {
HXDLIN( 187)																	undoImage5 = false;
            																}
HXDLIN( 187)																if (undoImage5) {
HXDLIN( 187)																	 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 187)																	int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 187)																	_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 187)																	_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 187)																	_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 187)																	_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 187)												undoImage4 = b6;
            											}
            											break;
            											case (int)3: {
HXDLIN( 187)												 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)												 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 187)												{
HXDLIN( 187)													v3->width = width1;
HXDLIN( 187)													v3->height = height1;
HXDLIN( 187)													v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)													v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 187)													{
HXDLIN( 187)														int _g32 = 0;
HXDLIN( 187)														int _g33 = v3->length;
HXDLIN( 187)														while((_g32 < _g33)){
HXDLIN( 187)															_g32 = (_g32 + 1);
HXDLIN( 187)															int i10 = (_g32 - 1);
HXDLIN( 187)															v3->data->__unsafe_set(i10,0);
            														}
            													}
            												}
HXDLIN( 187)												undoImage4 = v3;
            											}
            											break;
            											case (int)4: {
HXDLIN( 187)												 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 187)												 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 187)												{
HXDLIN( 187)													b7->width = width1;
HXDLIN( 187)													b7->height = height1;
HXDLIN( 187)													b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 187)													b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 187)													{
HXDLIN( 187)														int len3 = b7->length;
HXDLIN( 187)														 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 187)														if (::hx::IsNull( d1->head )) {
HXDLIN( 187)															int _g34 = 0;
HXDLIN( 187)															int _g35 = len3;
HXDLIN( 187)															while((_g34 < _g35)){
HXDLIN( 187)																_g34 = (_g34 + 1);
HXDLIN( 187)																int i11 = (_g34 - 1);
HXDLIN( 187)																d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            															}
            														}
            														else {
HXDLIN( 187)															int _g36 = 0;
HXDLIN( 187)															int _g37 = len3;
HXDLIN( 187)															while((_g36 < _g37)){
HXDLIN( 187)																_g36 = (_g36 + 1);
HXDLIN( 187)																int i12 = (_g36 - 1);
HXDLIN( 187)																{
HXDLIN( 187)																	 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 187)																	 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 187)																	{
HXDLIN( 187)																		int _g38 = 0;
HXDLIN( 187)																		int _g39 = i12;
HXDLIN( 187)																		while((_g38 < _g39)){
HXDLIN( 187)																			_g38 = (_g38 + 1);
HXDLIN( 187)																			int i13 = (_g38 - 1);
HXLINE( 345)																			prev1 = l1;
HXLINE( 346)																			l1 = l1->next;
            																		}
            																	}
HXLINE( 187)																	if (::hx::IsNull( prev1 )) {
HXDLIN( 187)																		b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 187)																		l1 = null();
            																	}
            																	else {
HXDLIN( 187)																		prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 187)																		l1 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 187)												undoImage4 = b7;
            											}
            											break;
            										}
HXDLIN( 187)										this37->image = undoImage4;
HXDLIN( 187)										this37->width = width1;
HXDLIN( 187)										this37->height = height1;
HXDLIN( 187)										this37->imageType = ( (int)(imageType1) );
HXDLIN( 187)										undoImage3 = this37;
HXDLIN( 187)										{
HXDLIN( 187)											int rectLeft1 = xIter31->start;
HXDLIN( 187)											int rectTop1 = yIter31->start;
HXDLIN( 187)											int rectRight1 = xIter31->max;
HXDLIN( 187)											bool forceClear1 = false;
HXDLIN( 187)											{
HXDLIN( 187)												int _g40 = rectTop1;
HXDLIN( 187)												int _g41 = yIter31->max;
HXDLIN( 187)												while((_g40 < _g41)){
HXDLIN( 187)													_g40 = (_g40 + 1);
HXDLIN( 187)													int dy1 = (_g40 - 1);
HXDLIN( 187)													{
HXDLIN( 187)														int _g42 = rectLeft1;
HXDLIN( 187)														int _g43 = rectRight1;
HXDLIN( 187)														while((_g42 < _g43)){
HXDLIN( 187)															_g42 = (_g42 + 1);
HXDLIN( 187)															int dx1 = (_g42 - 1);
HXDLIN( 187)															::Dynamic this39 = this36->image;
HXDLIN( 187)															int index5;
HXDLIN( 187)															if (this36->useVirtualPos) {
HXDLIN( 187)																index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            															}
            															else {
HXDLIN( 187)																index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            															}
HXDLIN( 187)															int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 187)															int col1;
HXDLIN( 187)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            															}
            															else {
HXDLIN( 187)																col1 = c4;
            															}
HXDLIN( 187)															bool _hx_tmp8;
HXDLIN( 187)															if (this36->useMask) {
HXDLIN( 187)																_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            															}
            															else {
HXDLIN( 187)																_hx_tmp8 = false;
            															}
HXDLIN( 187)															if (_hx_tmp8) {
HXDLIN( 187)																 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 187)																::Dynamic this41 = this40->image;
HXDLIN( 187)																int index6;
HXDLIN( 187)																if (this40->useVirtualPos) {
HXDLIN( 187)																	index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            																}
            																else {
HXDLIN( 187)																	index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            																}
HXDLIN( 187)																int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 187)																int v4;
HXDLIN( 187)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																	v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            																}
            																else {
HXDLIN( 187)																	v4 = c5;
            																}
HXDLIN( 187)																int maskPixel1 = v4;
HXDLIN( 187)																int this42 = col1;
HXDLIN( 187)																if ((maskPixel1 == 0)) {
HXDLIN( 187)																	col1 = this42;
            																}
            																else {
HXDLIN( 187)																	Float m01;
HXDLIN( 187)																	int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 187)																	if ((this43 == 0)) {
HXDLIN( 187)																		m01 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float m11;
HXDLIN( 187)																	int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 187)																	if ((this44 == 0)) {
HXDLIN( 187)																		m11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float m21;
HXDLIN( 187)																	int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 187)																	if ((this45 == 0)) {
HXDLIN( 187)																		m21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float m31;
HXDLIN( 187)																	int this46 = (maskPixel1 & 255);
HXDLIN( 187)																	if ((this46 == 0)) {
HXDLIN( 187)																		m31 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 187)																	int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 187)																	int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 187)																	int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 187)																	col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 187)															if ((col1 != 0)) {
HXDLIN( 187)																int x5 = (dx1 - rectLeft1);
HXDLIN( 187)																int y5 = (dy1 - rectTop1);
HXDLIN( 187)																int c6 = col1;
HXDLIN( 187)																bool _hx_tmp9;
HXDLIN( 187)																if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 187)																	_hx_tmp9 = undoImage3->transparent;
            																}
            																else {
HXDLIN( 187)																	_hx_tmp9 = false;
            																}
HXDLIN( 187)																if (_hx_tmp9) {
HXDLIN( 187)																	int location2;
HXDLIN( 187)																	if (undoImage3->useVirtualPos) {
HXDLIN( 187)																		location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN( 187)																		location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																	}
HXDLIN( 187)																	int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 187)																	int this48;
HXDLIN( 187)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																		this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 187)																		this48 = this47;
            																	}
HXDLIN( 187)																	Float a12;
HXDLIN( 187)																	int this49 = ((this48 >> 24) & 255);
HXDLIN( 187)																	if ((this49 == 0)) {
HXDLIN( 187)																		a12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float r12;
HXDLIN( 187)																	int this50 = ((this48 >> 16) & 255);
HXDLIN( 187)																	if ((this50 == 0)) {
HXDLIN( 187)																		r12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float g12;
HXDLIN( 187)																	int this51 = ((this48 >> 8) & 255);
HXDLIN( 187)																	if ((this51 == 0)) {
HXDLIN( 187)																		g12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float b13;
HXDLIN( 187)																	int this52 = (this48 & 255);
HXDLIN( 187)																	if ((this52 == 0)) {
HXDLIN( 187)																		b13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float a22;
HXDLIN( 187)																	int this53 = ((col1 >> 24) & 255);
HXDLIN( 187)																	if ((this53 == 0)) {
HXDLIN( 187)																		a22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float r22;
HXDLIN( 187)																	int this54 = ((col1 >> 16) & 255);
HXDLIN( 187)																	if ((this54 == 0)) {
HXDLIN( 187)																		r22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float g22;
HXDLIN( 187)																	int this55 = ((col1 >> 8) & 255);
HXDLIN( 187)																	if ((this55 == 0)) {
HXDLIN( 187)																		g22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float b23;
HXDLIN( 187)																	int this56 = (col1 & 255);
HXDLIN( 187)																	if ((this56 == 0)) {
HXDLIN( 187)																		b23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 187)																	int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 187)																	int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 187)																	int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 187)																	int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 187)																	int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 187)																	{
HXDLIN( 187)																		int _hx_tmp10;
HXDLIN( 187)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																			_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 187)																			_hx_tmp10 = blended2;
            																		}
HXDLIN( 187)																		::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																	}
            																}
            																else {
HXDLIN( 187)																	::Dynamic this57 = undoImage3->image;
HXDLIN( 187)																	int index7;
HXDLIN( 187)																	if (undoImage3->useVirtualPos) {
HXDLIN( 187)																		index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN( 187)																		index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																	}
HXDLIN( 187)																	int _hx_tmp11;
HXDLIN( 187)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																		_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 187)																		_hx_tmp11 = c6;
            																	}
HXDLIN( 187)																	::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            																}
            															}
            															else {
HXDLIN( 187)																if (forceClear1) {
HXDLIN( 187)																	::Dynamic this58 = undoImage3->image;
HXDLIN( 187)																	int x6 = (dx1 - rectLeft1);
HXDLIN( 187)																	int y6 = (dy1 - rectTop1);
HXDLIN( 187)																	int index8;
HXDLIN( 187)																	if (undoImage3->useVirtualPos) {
HXDLIN( 187)																		index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																	}
            																	else {
HXDLIN( 187)																		index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																	}
HXDLIN( 187)																	::iterMagic::Iimg_obj::set(this58,index8,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 187)									bool found1 = false;
HXDLIN( 187)									Float s1 = ((Float)0.);
HXDLIN( 187)									Float t1 = ((Float)0.);
HXDLIN( 187)									Float sxx1 = ((Float)0.);
HXDLIN( 187)									Float txx1 = ((Float)0.);
HXDLIN( 187)									{
HXDLIN( 187)										int _g_min2 = xIter31->start;
HXDLIN( 187)										int _g_max2 = xIter31->max;
HXDLIN( 187)										while((_g_min2 < _g_max2)){
HXDLIN( 187)											_g_min2 = (_g_min2 + 1);
HXDLIN( 187)											int x7 = (_g_min2 - 1);
HXLINE(  60)											sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)											txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)											found1 = false;
HXLINE( 187)											{
HXDLIN( 187)												int _g_min3 = yIter31->start;
HXDLIN( 187)												int _g_max3 = yIter31->max;
HXDLIN( 187)												while((_g_min3 < _g_max3)){
HXDLIN( 187)													_g_min3 = (_g_min3 + 1);
HXDLIN( 187)													int y7 = (_g_min3 - 1);
HXLINE(  64)													s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)													t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 187)													bool _hx_tmp12;
HXDLIN( 187)													if (!((s1 <= 0))) {
HXDLIN( 187)														_hx_tmp12 = (t1 <= 0);
            													}
            													else {
HXDLIN( 187)														_hx_tmp12 = true;
            													}
HXDLIN( 187)													if (_hx_tmp12) {
HXDLIN( 187)														if (found1) {
HXDLIN( 187)															goto _hx_goto_374;
            														}
            													}
            													else {
HXDLIN( 187)														if (((s1 + t1) < A1)) {
HXDLIN( 187)															{
HXDLIN( 187)																int c7 = color;
HXDLIN( 187)																bool _hx_tmp13;
HXDLIN( 187)																if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 187)																	_hx_tmp13 = this36->transparent;
            																}
            																else {
HXDLIN( 187)																	_hx_tmp13 = false;
            																}
HXDLIN( 187)																if (_hx_tmp13) {
HXDLIN( 187)																	int location3;
HXDLIN( 187)																	if (this36->useVirtualPos) {
HXDLIN( 187)																		location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																	}
            																	else {
HXDLIN( 187)																		location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																	}
HXDLIN( 187)																	int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 187)																	int this60;
HXDLIN( 187)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																		this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 187)																		this60 = this59;
            																	}
HXDLIN( 187)																	Float a13;
HXDLIN( 187)																	int this61 = ((this60 >> 24) & 255);
HXDLIN( 187)																	if ((this61 == 0)) {
HXDLIN( 187)																		a13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float r13;
HXDLIN( 187)																	int this62 = ((this60 >> 16) & 255);
HXDLIN( 187)																	if ((this62 == 0)) {
HXDLIN( 187)																		r13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float g13;
HXDLIN( 187)																	int this63 = ((this60 >> 8) & 255);
HXDLIN( 187)																	if ((this63 == 0)) {
HXDLIN( 187)																		g13 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float b14;
HXDLIN( 187)																	int this64 = (this60 & 255);
HXDLIN( 187)																	if ((this64 == 0)) {
HXDLIN( 187)																		b14 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float a23;
HXDLIN( 187)																	int this65 = ((color >> 24) & 255);
HXDLIN( 187)																	if ((this65 == 0)) {
HXDLIN( 187)																		a23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float r23;
HXDLIN( 187)																	int this66 = ((color >> 16) & 255);
HXDLIN( 187)																	if ((this66 == 0)) {
HXDLIN( 187)																		r23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float g23;
HXDLIN( 187)																	int this67 = ((color >> 8) & 255);
HXDLIN( 187)																	if ((this67 == 0)) {
HXDLIN( 187)																		g23 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float b24;
HXDLIN( 187)																	int this68 = (color & 255);
HXDLIN( 187)																	if ((this68 == 0)) {
HXDLIN( 187)																		b24 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 187)																		b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																	}
HXDLIN( 187)																	Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 187)																	int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 187)																	int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 187)																	int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 187)																	int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 187)																	int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 187)																	{
HXDLIN( 187)																		int _hx_tmp14;
HXDLIN( 187)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																			_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 187)																			_hx_tmp14 = blended3;
            																		}
HXDLIN( 187)																		::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																	}
            																}
            																else {
HXDLIN( 187)																	::Dynamic this69 = this36->image;
HXDLIN( 187)																	int index9;
HXDLIN( 187)																	if (this36->useVirtualPos) {
HXDLIN( 187)																		index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																	}
            																	else {
HXDLIN( 187)																		index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																	}
HXDLIN( 187)																	int _hx_tmp15;
HXDLIN( 187)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 187)																		_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 187)																		_hx_tmp15 = c7;
            																	}
HXDLIN( 187)																	::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            																}
            															}
HXLINE(  73)															found1 = true;
            														}
            														else {
HXDLIN( 187)															if (found1) {
HXDLIN( 187)																goto _hx_goto_374;
            															}
            														}
            													}
            												}
            												_hx_goto_374:;
            											}
            										}
            									}
HXDLIN( 187)									if ((hasHit1 == true)) {
HXDLIN( 187)										 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 187)										if (hasUndo1) {
HXDLIN( 187)											v5->undoImage = undoImage3;
HXDLIN( 187)											v5->undoX = xIter31->start;
HXDLIN( 187)											v5->undoY = yIter31->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  59)						lastX = nextX1;
HXLINE(  60)						lastY = nextY1;
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,ellipse,(void))

void FillShape_Impl__obj::polyBuild( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi, ::Dynamic __o_sides,::hx::Null< bool >  __o_cornerUp){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		bool cornerUp = __o_cornerUp.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_207_polyBuild)
HXDLIN( 207)		 ::Dynamic phi1 = phi;
HXDLIN( 207)		 ::Dynamic sides1 = sides;
HXLINE( 212)		if (::hx::IsNull( sides1 )) {
HXLINE( 212)			sides1 = 36;
            		}
HXLINE( 211)		if (::hx::IsNull( phi1 )) {
HXLINE( 211)			phi1 = ((Float)0.);
            		}
HXLINE( 207)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 207)		Float omega;
HXDLIN( 207)		if (cornerUp) {
HXDLIN( 207)			omega = ((Float)0.);
            		}
            		else {
HXDLIN( 207)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 207)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 207)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 207)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 207)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 207)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
            		}
HXDLIN( 207)		Float lastX = ((Float)0.);
HXDLIN( 207)		Float lastY = ((Float)0.);
HXDLIN( 207)		if (::hx::IsNotEq( phi1,0 )) {
HXLINE(  35)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi1) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi1) )))) + cx);
HXLINE(  36)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi1) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi1) )))) + cy);
            		}
            		else {
HXLINE(  38)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            		}
HXLINE( 207)		if (::hx::IsNotEq( phi1,0 )) {
HXDLIN( 207)			Float cphi = ::Math_obj::cos(( (Float)(phi1) ));
HXDLIN( 207)			Float sphi = ::Math_obj::sin(( (Float)(phi1) ));
HXDLIN( 207)			{
HXDLIN( 207)				int _g = 0;
HXDLIN( 207)				int _g1 = (sides1 + 1);
HXDLIN( 207)				while((_g < _g1)){
HXDLIN( 207)					_g = (_g + 1);
HXDLIN( 207)					int i = (_g - 1);
HXDLIN( 207)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 207)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 207)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 207)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 207)					{
HXDLIN( 207)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 207)						bool hasHit = false;
HXDLIN( 207)						bool hasUndo = false;
HXDLIN( 207)						{
HXDLIN( 207)							Float bx = lastX;
HXDLIN( 207)							Float by = lastY;
HXDLIN( 207)							Float cx1 = nextX;
HXDLIN( 207)							Float cy1 = nextY;
HXDLIN( 207)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 207)							if (!(adjustWinding)) {
HXDLIN( 207)								Float bx_ = bx;
HXDLIN( 207)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE( 207)							{
HXDLIN( 207)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 207)								Float sx = (cy1 - cy);
HXDLIN( 207)								Float sy = (cx - cx1);
HXDLIN( 207)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 207)								Float tx = (cy - by);
HXDLIN( 207)								Float ty = (bx - cx);
HXDLIN( 207)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 207)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 207)								if ((cx > bx)) {
HXDLIN( 207)									if ((cx > cx1)) {
HXDLIN( 207)										int min;
HXDLIN( 207)										if ((bx > cx1)) {
HXDLIN( 207)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 207)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 207)										int ii_min = min;
HXDLIN( 207)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 207)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 207)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 207)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 207)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 207)									if ((bx > cx1)) {
HXDLIN( 207)										int min1;
HXDLIN( 207)										if ((cx > cx1)) {
HXDLIN( 207)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 207)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 207)										int ii_min2 = min1;
HXDLIN( 207)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 207)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 207)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 207)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 207)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 207)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 207)								if ((cy > by)) {
HXDLIN( 207)									if ((cy > cy1)) {
HXDLIN( 207)										int min2;
HXDLIN( 207)										if ((by > cy1)) {
HXDLIN( 207)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 207)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 207)										int ii_min4 = min2;
HXDLIN( 207)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 207)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 207)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 207)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 207)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 207)									if ((by > cy1)) {
HXDLIN( 207)										int min3;
HXDLIN( 207)										if ((cy > cy1)) {
HXDLIN( 207)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 207)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 207)										int ii_min6 = min3;
HXDLIN( 207)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 207)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 207)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 207)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 207)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 207)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 207)								if (hasUndo) {
HXDLIN( 207)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 207)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 207)									 ::Dynamic imageType = null();
HXDLIN( 207)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 207)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 207)									::Dynamic undoImage1;
HXDLIN( 207)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 207)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 207)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 207)											{
HXDLIN( 207)												b->width = width;
HXDLIN( 207)												b->height = height;
HXDLIN( 207)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 207)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 207)												{
HXDLIN( 207)													int len = b->length;
HXDLIN( 207)													int w = 0;
HXDLIN( 207)													{
HXDLIN( 207)														int _g2 = 0;
HXDLIN( 207)														int _g3 = b->height;
HXDLIN( 207)														while((_g2 < _g3)){
HXDLIN( 207)															_g2 = (_g2 + 1);
HXDLIN( 207)															int y = (_g2 - 1);
HXDLIN( 207)															{
HXDLIN( 207)																int _g4 = 0;
HXDLIN( 207)																int _g5 = b->width;
HXDLIN( 207)																while((_g4 < _g5)){
HXDLIN( 207)																	_g4 = (_g4 + 1);
HXDLIN( 207)																	int x = (_g4 - 1);
HXDLIN( 207)																	{
HXDLIN( 207)																		w = (w + 1);
HXDLIN( 207)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 207)																	{
HXDLIN( 207)																		w = (w + 1);
HXDLIN( 207)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 207)																	{
HXDLIN( 207)																		w = (w + 1);
HXDLIN( 207)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 207)																	{
HXDLIN( 207)																		w = (w + 1);
HXDLIN( 207)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 207)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 207)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 207)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 207)											{
HXDLIN( 207)												a->width = width;
HXDLIN( 207)												a->height = height;
HXDLIN( 207)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 207)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 207)												{
HXDLIN( 207)													int _g6 = 0;
HXDLIN( 207)													int _g7 = a->length;
HXDLIN( 207)													while((_g6 < _g7)){
HXDLIN( 207)														_g6 = (_g6 + 1);
HXDLIN( 207)														int i1 = (_g6 - 1);
HXDLIN( 207)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 207)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 207)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 207)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 207)											{
HXDLIN( 207)												b1->width = width;
HXDLIN( 207)												b1->height = height;
HXDLIN( 207)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 207)												int size = (b1->length * 4);
HXDLIN( 207)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 207)												{
HXDLIN( 207)													int _g8 = 0;
HXDLIN( 207)													int _g9 = b1->length;
HXDLIN( 207)													while((_g8 < _g9)){
HXDLIN( 207)														_g8 = (_g8 + 1);
HXDLIN( 207)														int i2 = (_g8 - 1);
HXDLIN( 207)														{
HXDLIN( 207)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 207)															bool undoImage2;
HXDLIN( 207)															if ((i2 >= 0)) {
HXDLIN( 207)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 207)																undoImage2 = false;
            															}
HXDLIN( 207)															if (undoImage2) {
HXDLIN( 207)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 207)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 207)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 207)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 207)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 207)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 207)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 207)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 207)											 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 207)											{
HXDLIN( 207)												v1->width = width;
HXDLIN( 207)												v1->height = height;
HXDLIN( 207)												v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 207)												v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 207)												{
HXDLIN( 207)													int _g10 = 0;
HXDLIN( 207)													int _g11 = v1->length;
HXDLIN( 207)													while((_g10 < _g11)){
HXDLIN( 207)														_g10 = (_g10 + 1);
HXDLIN( 207)														int i3 = (_g10 - 1);
HXDLIN( 207)														v1->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 207)											undoImage1 = v1;
            										}
            										break;
            										case (int)4: {
HXDLIN( 207)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 207)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 207)											{
HXDLIN( 207)												b2->width = width;
HXDLIN( 207)												b2->height = height;
HXDLIN( 207)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 207)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 207)												{
HXDLIN( 207)													int len1 = b2->length;
HXDLIN( 207)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 207)													if (::hx::IsNull( d->head )) {
HXDLIN( 207)														int _g12 = 0;
HXDLIN( 207)														int _g13 = len1;
HXDLIN( 207)														while((_g12 < _g13)){
HXDLIN( 207)															_g12 = (_g12 + 1);
HXDLIN( 207)															int i4 = (_g12 - 1);
HXDLIN( 207)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 207)														int _g14 = 0;
HXDLIN( 207)														int _g15 = len1;
HXDLIN( 207)														while((_g14 < _g15)){
HXDLIN( 207)															_g14 = (_g14 + 1);
HXDLIN( 207)															int i5 = (_g14 - 1);
HXDLIN( 207)															{
HXDLIN( 207)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 207)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 207)																{
HXDLIN( 207)																	int _g16 = 0;
HXDLIN( 207)																	int _g17 = i5;
HXDLIN( 207)																	while((_g16 < _g17)){
HXDLIN( 207)																		_g16 = (_g16 + 1);
HXDLIN( 207)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 207)																if (::hx::IsNull( prev )) {
HXDLIN( 207)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 207)																	l = null();
            																}
            																else {
HXDLIN( 207)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 207)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 207)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 207)									this3->image = undoImage1;
HXDLIN( 207)									this3->width = width;
HXDLIN( 207)									this3->height = height;
HXDLIN( 207)									this3->imageType = ( (int)(imageType) );
HXDLIN( 207)									undoImage = this3;
HXDLIN( 207)									{
HXDLIN( 207)										int rectLeft = xIter3->start;
HXDLIN( 207)										int rectTop = yIter3->start;
HXDLIN( 207)										int rectRight = xIter3->max;
HXDLIN( 207)										bool forceClear = false;
HXDLIN( 207)										{
HXDLIN( 207)											int _g18 = rectTop;
HXDLIN( 207)											int _g19 = yIter3->max;
HXDLIN( 207)											while((_g18 < _g19)){
HXDLIN( 207)												_g18 = (_g18 + 1);
HXDLIN( 207)												int dy = (_g18 - 1);
HXDLIN( 207)												{
HXDLIN( 207)													int _g20 = rectLeft;
HXDLIN( 207)													int _g21 = rectRight;
HXDLIN( 207)													while((_g20 < _g21)){
HXDLIN( 207)														_g20 = (_g20 + 1);
HXDLIN( 207)														int dx = (_g20 - 1);
HXDLIN( 207)														::Dynamic this5 = this2->image;
HXDLIN( 207)														int index;
HXDLIN( 207)														if (this2->useVirtualPos) {
HXDLIN( 207)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 207)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 207)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 207)														int col;
HXDLIN( 207)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 207)															col = c;
            														}
HXDLIN( 207)														bool _hx_tmp;
HXDLIN( 207)														if (this2->useMask) {
HXDLIN( 207)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 207)															_hx_tmp = false;
            														}
HXDLIN( 207)														if (_hx_tmp) {
HXDLIN( 207)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 207)															::Dynamic this7 = this6->image;
HXDLIN( 207)															int index1;
HXDLIN( 207)															if (this6->useVirtualPos) {
HXDLIN( 207)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 207)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 207)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 207)															int v2;
HXDLIN( 207)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 207)																v2 = c1;
            															}
HXDLIN( 207)															int maskPixel = v2;
HXDLIN( 207)															int this8 = col;
HXDLIN( 207)															if ((maskPixel == 0)) {
HXDLIN( 207)																col = this8;
            															}
            															else {
HXDLIN( 207)																Float m0;
HXDLIN( 207)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 207)																if ((this9 == 0)) {
HXDLIN( 207)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float m1;
HXDLIN( 207)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 207)																if ((this10 == 0)) {
HXDLIN( 207)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float m2;
HXDLIN( 207)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 207)																if ((this11 == 0)) {
HXDLIN( 207)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float m3;
HXDLIN( 207)																int this12 = (maskPixel & 255);
HXDLIN( 207)																if ((this12 == 0)) {
HXDLIN( 207)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 207)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 207)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 207)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 207)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 207)														if ((col != 0)) {
HXDLIN( 207)															int x1 = (dx - rectLeft);
HXDLIN( 207)															int y1 = (dy - rectTop);
HXDLIN( 207)															int c2 = col;
HXDLIN( 207)															bool _hx_tmp1;
HXDLIN( 207)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 207)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 207)																_hx_tmp1 = false;
            															}
HXDLIN( 207)															if (_hx_tmp1) {
HXDLIN( 207)																int location;
HXDLIN( 207)																if (undoImage->useVirtualPos) {
HXDLIN( 207)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 207)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 207)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 207)																int this14;
HXDLIN( 207)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 207)																	this14 = this13;
            																}
HXDLIN( 207)																Float a1;
HXDLIN( 207)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 207)																if ((this15 == 0)) {
HXDLIN( 207)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float r1;
HXDLIN( 207)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 207)																if ((this16 == 0)) {
HXDLIN( 207)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float g1;
HXDLIN( 207)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 207)																if ((this17 == 0)) {
HXDLIN( 207)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float b11;
HXDLIN( 207)																int this18 = (this14 & 255);
HXDLIN( 207)																if ((this18 == 0)) {
HXDLIN( 207)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float a2;
HXDLIN( 207)																int this19 = ((col >> 24) & 255);
HXDLIN( 207)																if ((this19 == 0)) {
HXDLIN( 207)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float r2;
HXDLIN( 207)																int this20 = ((col >> 16) & 255);
HXDLIN( 207)																if ((this20 == 0)) {
HXDLIN( 207)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float g2;
HXDLIN( 207)																int this21 = ((col >> 8) & 255);
HXDLIN( 207)																if ((this21 == 0)) {
HXDLIN( 207)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float b21;
HXDLIN( 207)																int this22 = (col & 255);
HXDLIN( 207)																if ((this22 == 0)) {
HXDLIN( 207)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 207)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 207)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 207)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 207)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 207)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 207)																{
HXDLIN( 207)																	int _hx_tmp2;
HXDLIN( 207)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 207)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 207)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 207)																::Dynamic this23 = undoImage->image;
HXDLIN( 207)																int index2;
HXDLIN( 207)																if (undoImage->useVirtualPos) {
HXDLIN( 207)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 207)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 207)																int _hx_tmp3;
HXDLIN( 207)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 207)																	_hx_tmp3 = c2;
            																}
HXDLIN( 207)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 207)															if (forceClear) {
HXDLIN( 207)																::Dynamic this24 = undoImage->image;
HXDLIN( 207)																int x2 = (dx - rectLeft);
HXDLIN( 207)																int y2 = (dy - rectTop);
HXDLIN( 207)																int index3;
HXDLIN( 207)																if (undoImage->useVirtualPos) {
HXDLIN( 207)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 207)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 207)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 207)								bool found = false;
HXDLIN( 207)								Float s = ((Float)0.);
HXDLIN( 207)								Float t = ((Float)0.);
HXDLIN( 207)								Float sxx = ((Float)0.);
HXDLIN( 207)								Float txx = ((Float)0.);
HXDLIN( 207)								{
HXDLIN( 207)									int _g_min = xIter3->start;
HXDLIN( 207)									int _g_max = xIter3->max;
HXDLIN( 207)									while((_g_min < _g_max)){
HXDLIN( 207)										_g_min = (_g_min + 1);
HXDLIN( 207)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE( 207)										{
HXDLIN( 207)											int _g_min1 = yIter3->start;
HXDLIN( 207)											int _g_max1 = yIter3->max;
HXDLIN( 207)											while((_g_min1 < _g_max1)){
HXDLIN( 207)												_g_min1 = (_g_min1 + 1);
HXDLIN( 207)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 207)												bool _hx_tmp4;
HXDLIN( 207)												if (!((s <= 0))) {
HXDLIN( 207)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 207)													_hx_tmp4 = true;
            												}
HXDLIN( 207)												if (_hx_tmp4) {
HXDLIN( 207)													if (found) {
HXDLIN( 207)														goto _hx_goto_388;
            													}
            												}
            												else {
HXDLIN( 207)													if (((s + t) < A)) {
HXDLIN( 207)														{
HXDLIN( 207)															int c3 = color;
HXDLIN( 207)															bool _hx_tmp5;
HXDLIN( 207)															if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 207)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 207)																_hx_tmp5 = false;
            															}
HXDLIN( 207)															if (_hx_tmp5) {
HXDLIN( 207)																int location1;
HXDLIN( 207)																if (this2->useVirtualPos) {
HXDLIN( 207)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 207)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 207)																int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 207)																int this26;
HXDLIN( 207)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXDLIN( 207)																	this26 = this25;
            																}
HXDLIN( 207)																Float a11;
HXDLIN( 207)																int this27 = ((this26 >> 24) & 255);
HXDLIN( 207)																if ((this27 == 0)) {
HXDLIN( 207)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float r11;
HXDLIN( 207)																int this28 = ((this26 >> 16) & 255);
HXDLIN( 207)																if ((this28 == 0)) {
HXDLIN( 207)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float g11;
HXDLIN( 207)																int this29 = ((this26 >> 8) & 255);
HXDLIN( 207)																if ((this29 == 0)) {
HXDLIN( 207)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float b12;
HXDLIN( 207)																int this30 = (this26 & 255);
HXDLIN( 207)																if ((this30 == 0)) {
HXDLIN( 207)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float a21;
HXDLIN( 207)																int this31 = ((color >> 24) & 255);
HXDLIN( 207)																if ((this31 == 0)) {
HXDLIN( 207)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float r21;
HXDLIN( 207)																int this32 = ((color >> 16) & 255);
HXDLIN( 207)																if ((this32 == 0)) {
HXDLIN( 207)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float g21;
HXDLIN( 207)																int this33 = ((color >> 8) & 255);
HXDLIN( 207)																if ((this33 == 0)) {
HXDLIN( 207)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float b22;
HXDLIN( 207)																int this34 = (color & 255);
HXDLIN( 207)																if ((this34 == 0)) {
HXDLIN( 207)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 207)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 207)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 207)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 207)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 207)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 207)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 207)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 207)																{
HXDLIN( 207)																	int _hx_tmp6;
HXDLIN( 207)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 207)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 207)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 207)																::Dynamic this35 = this2->image;
HXDLIN( 207)																int index4;
HXDLIN( 207)																if (this2->useVirtualPos) {
HXDLIN( 207)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 207)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 207)																int _hx_tmp7;
HXDLIN( 207)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXDLIN( 207)																	_hx_tmp7 = c3;
            																}
HXDLIN( 207)																::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXDLIN( 207)														if (found) {
HXDLIN( 207)															goto _hx_goto_388;
            														}
            													}
            												}
            											}
            											_hx_goto_388:;
            										}
            									}
            								}
HXDLIN( 207)								if ((hasHit == true)) {
HXDLIN( 207)									 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 207)									if (hasUndo) {
HXDLIN( 207)										v3->undoImage = undoImage;
HXDLIN( 207)										v3->undoX = xIter3->start;
HXDLIN( 207)										v3->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  51)					lastX = nextX;
HXLINE(  52)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 207)			int _g22 = 0;
HXDLIN( 207)			int _g23 = (sides1 + 1);
HXDLIN( 207)			while((_g22 < _g23)){
HXDLIN( 207)				_g22 = (_g22 + 1);
HXDLIN( 207)				int i7 = (_g22 - 1);
HXDLIN( 207)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 207)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 207)				{
HXDLIN( 207)					 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 207)					bool hasHit1 = false;
HXDLIN( 207)					bool hasUndo1 = false;
HXDLIN( 207)					{
HXDLIN( 207)						Float bx1 = lastX;
HXDLIN( 207)						Float by1 = lastY;
HXDLIN( 207)						Float cx2 = nextX1;
HXDLIN( 207)						Float cy2 = nextY1;
HXDLIN( 207)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 207)						if (!(adjustWinding1)) {
HXDLIN( 207)							Float bx_1 = bx1;
HXDLIN( 207)							Float by_1 = by1;
HXLINE(  25)							bx1 = cx2;
HXLINE(  26)							by1 = cy2;
HXLINE(  27)							cx2 = bx_1;
HXLINE(  28)							cy2 = by_1;
            						}
HXLINE( 207)						{
HXDLIN( 207)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 207)							Float sx1 = (cy2 - cy);
HXDLIN( 207)							Float sy1 = (cx - cx2);
HXDLIN( 207)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 207)							Float tx1 = (cy - by1);
HXDLIN( 207)							Float ty1 = (bx1 - cx);
HXDLIN( 207)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 207)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 207)							if ((cx > bx1)) {
HXDLIN( 207)								if ((cx > cx2)) {
HXDLIN( 207)									int min4;
HXDLIN( 207)									if ((bx1 > cx2)) {
HXDLIN( 207)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 207)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 207)									int ii_min8 = min4;
HXDLIN( 207)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 207)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 207)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 207)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 207)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 207)								if ((bx1 > cx2)) {
HXDLIN( 207)									int min5;
HXDLIN( 207)									if ((cx > cx2)) {
HXDLIN( 207)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 207)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 207)									int ii_min10 = min5;
HXDLIN( 207)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 207)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 207)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 207)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 207)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 207)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 207)							if ((cy > by1)) {
HXDLIN( 207)								if ((cy > cy2)) {
HXDLIN( 207)									int min6;
HXDLIN( 207)									if ((by1 > cy2)) {
HXDLIN( 207)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 207)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 207)									int ii_min12 = min6;
HXDLIN( 207)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 207)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 207)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 207)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 207)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 207)								if ((by1 > cy2)) {
HXDLIN( 207)									int min7;
HXDLIN( 207)									if ((cy > cy2)) {
HXDLIN( 207)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 207)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 207)									int ii_min14 = min7;
HXDLIN( 207)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 207)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 207)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 207)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 207)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 207)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 207)							if (hasUndo1) {
HXDLIN( 207)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 207)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 207)								 ::Dynamic imageType1 = null();
HXDLIN( 207)								 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 207)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 207)								::Dynamic undoImage4;
HXDLIN( 207)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 207)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 207)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 207)										{
HXDLIN( 207)											b5->width = width1;
HXDLIN( 207)											b5->height = height1;
HXDLIN( 207)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 207)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 207)											{
HXDLIN( 207)												int len2 = b5->length;
HXDLIN( 207)												int w1 = 0;
HXDLIN( 207)												{
HXDLIN( 207)													int _g24 = 0;
HXDLIN( 207)													int _g25 = b5->height;
HXDLIN( 207)													while((_g24 < _g25)){
HXDLIN( 207)														_g24 = (_g24 + 1);
HXDLIN( 207)														int y4 = (_g24 - 1);
HXDLIN( 207)														{
HXDLIN( 207)															int _g26 = 0;
HXDLIN( 207)															int _g27 = b5->width;
HXDLIN( 207)															while((_g26 < _g27)){
HXDLIN( 207)																_g26 = (_g26 + 1);
HXDLIN( 207)																int x4 = (_g26 - 1);
HXDLIN( 207)																{
HXDLIN( 207)																	w1 = (w1 + 1);
HXDLIN( 207)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 207)																{
HXDLIN( 207)																	w1 = (w1 + 1);
HXDLIN( 207)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 207)																{
HXDLIN( 207)																	w1 = (w1 + 1);
HXDLIN( 207)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 207)																{
HXDLIN( 207)																	w1 = (w1 + 1);
HXDLIN( 207)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 207)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 207)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 207)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 207)										{
HXDLIN( 207)											a6->width = width1;
HXDLIN( 207)											a6->height = height1;
HXDLIN( 207)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 207)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 207)											{
HXDLIN( 207)												int _g28 = 0;
HXDLIN( 207)												int _g29 = a6->length;
HXDLIN( 207)												while((_g28 < _g29)){
HXDLIN( 207)													_g28 = (_g28 + 1);
HXDLIN( 207)													int i8 = (_g28 - 1);
HXDLIN( 207)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 207)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 207)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 207)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 207)										{
HXDLIN( 207)											b6->width = width1;
HXDLIN( 207)											b6->height = height1;
HXDLIN( 207)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 207)											int size1 = (b6->length * 4);
HXDLIN( 207)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 207)											{
HXDLIN( 207)												int _g30 = 0;
HXDLIN( 207)												int _g31 = b6->length;
HXDLIN( 207)												while((_g30 < _g31)){
HXDLIN( 207)													_g30 = (_g30 + 1);
HXDLIN( 207)													int i9 = (_g30 - 1);
HXDLIN( 207)													{
HXDLIN( 207)														 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 207)														bool undoImage5;
HXDLIN( 207)														if ((i9 >= 0)) {
HXDLIN( 207)															undoImage5 = (i9 < (this38->byteLength >> 2));
            														}
            														else {
HXDLIN( 207)															undoImage5 = false;
            														}
HXDLIN( 207)														if (undoImage5) {
HXDLIN( 207)															 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 207)															int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 207)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 207)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 207)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 207)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 207)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 207)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 207)										 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 207)										{
HXDLIN( 207)											v4->width = width1;
HXDLIN( 207)											v4->height = height1;
HXDLIN( 207)											v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 207)											v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 207)											{
HXDLIN( 207)												int _g32 = 0;
HXDLIN( 207)												int _g33 = v4->length;
HXDLIN( 207)												while((_g32 < _g33)){
HXDLIN( 207)													_g32 = (_g32 + 1);
HXDLIN( 207)													int i10 = (_g32 - 1);
HXDLIN( 207)													v4->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 207)										undoImage4 = v4;
            									}
            									break;
            									case (int)4: {
HXDLIN( 207)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 207)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 207)										{
HXDLIN( 207)											b7->width = width1;
HXDLIN( 207)											b7->height = height1;
HXDLIN( 207)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 207)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 207)											{
HXDLIN( 207)												int len3 = b7->length;
HXDLIN( 207)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 207)												if (::hx::IsNull( d1->head )) {
HXDLIN( 207)													int _g34 = 0;
HXDLIN( 207)													int _g35 = len3;
HXDLIN( 207)													while((_g34 < _g35)){
HXDLIN( 207)														_g34 = (_g34 + 1);
HXDLIN( 207)														int i11 = (_g34 - 1);
HXDLIN( 207)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 207)													int _g36 = 0;
HXDLIN( 207)													int _g37 = len3;
HXDLIN( 207)													while((_g36 < _g37)){
HXDLIN( 207)														_g36 = (_g36 + 1);
HXDLIN( 207)														int i12 = (_g36 - 1);
HXDLIN( 207)														{
HXDLIN( 207)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 207)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 207)															{
HXDLIN( 207)																int _g38 = 0;
HXDLIN( 207)																int _g39 = i12;
HXDLIN( 207)																while((_g38 < _g39)){
HXDLIN( 207)																	_g38 = (_g38 + 1);
HXDLIN( 207)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 207)															if (::hx::IsNull( prev1 )) {
HXDLIN( 207)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 207)																l1 = null();
            															}
            															else {
HXDLIN( 207)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 207)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 207)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 207)								this37->image = undoImage4;
HXDLIN( 207)								this37->width = width1;
HXDLIN( 207)								this37->height = height1;
HXDLIN( 207)								this37->imageType = ( (int)(imageType1) );
HXDLIN( 207)								undoImage3 = this37;
HXDLIN( 207)								{
HXDLIN( 207)									int rectLeft1 = xIter31->start;
HXDLIN( 207)									int rectTop1 = yIter31->start;
HXDLIN( 207)									int rectRight1 = xIter31->max;
HXDLIN( 207)									bool forceClear1 = false;
HXDLIN( 207)									{
HXDLIN( 207)										int _g40 = rectTop1;
HXDLIN( 207)										int _g41 = yIter31->max;
HXDLIN( 207)										while((_g40 < _g41)){
HXDLIN( 207)											_g40 = (_g40 + 1);
HXDLIN( 207)											int dy1 = (_g40 - 1);
HXDLIN( 207)											{
HXDLIN( 207)												int _g42 = rectLeft1;
HXDLIN( 207)												int _g43 = rectRight1;
HXDLIN( 207)												while((_g42 < _g43)){
HXDLIN( 207)													_g42 = (_g42 + 1);
HXDLIN( 207)													int dx1 = (_g42 - 1);
HXDLIN( 207)													::Dynamic this39 = this36->image;
HXDLIN( 207)													int index5;
HXDLIN( 207)													if (this36->useVirtualPos) {
HXDLIN( 207)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            													}
            													else {
HXDLIN( 207)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            													}
HXDLIN( 207)													int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 207)													int col1;
HXDLIN( 207)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)														col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXDLIN( 207)														col1 = c4;
            													}
HXDLIN( 207)													bool _hx_tmp8;
HXDLIN( 207)													if (this36->useMask) {
HXDLIN( 207)														_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            													}
            													else {
HXDLIN( 207)														_hx_tmp8 = false;
            													}
HXDLIN( 207)													if (_hx_tmp8) {
HXDLIN( 207)														 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 207)														::Dynamic this41 = this40->image;
HXDLIN( 207)														int index6;
HXDLIN( 207)														if (this40->useVirtualPos) {
HXDLIN( 207)															index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            														}
            														else {
HXDLIN( 207)															index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            														}
HXDLIN( 207)														int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 207)														int v5;
HXDLIN( 207)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)															v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXDLIN( 207)															v5 = c5;
            														}
HXDLIN( 207)														int maskPixel1 = v5;
HXDLIN( 207)														int this42 = col1;
HXDLIN( 207)														if ((maskPixel1 == 0)) {
HXDLIN( 207)															col1 = this42;
            														}
            														else {
HXDLIN( 207)															Float m01;
HXDLIN( 207)															int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 207)															if ((this43 == 0)) {
HXDLIN( 207)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float m11;
HXDLIN( 207)															int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 207)															if ((this44 == 0)) {
HXDLIN( 207)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float m21;
HXDLIN( 207)															int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 207)															if ((this45 == 0)) {
HXDLIN( 207)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float m31;
HXDLIN( 207)															int this46 = (maskPixel1 & 255);
HXDLIN( 207)															if ((this46 == 0)) {
HXDLIN( 207)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 207)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 207)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 207)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 207)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 207)													if ((col1 != 0)) {
HXDLIN( 207)														int x5 = (dx1 - rectLeft1);
HXDLIN( 207)														int y5 = (dy1 - rectTop1);
HXDLIN( 207)														int c6 = col1;
HXDLIN( 207)														bool _hx_tmp9;
HXDLIN( 207)														if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 207)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 207)															_hx_tmp9 = false;
            														}
HXDLIN( 207)														if (_hx_tmp9) {
HXDLIN( 207)															int location2;
HXDLIN( 207)															if (undoImage3->useVirtualPos) {
HXDLIN( 207)																location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 207)																location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 207)															int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 207)															int this48;
HXDLIN( 207)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            															}
            															else {
HXDLIN( 207)																this48 = this47;
            															}
HXDLIN( 207)															Float a12;
HXDLIN( 207)															int this49 = ((this48 >> 24) & 255);
HXDLIN( 207)															if ((this49 == 0)) {
HXDLIN( 207)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float r12;
HXDLIN( 207)															int this50 = ((this48 >> 16) & 255);
HXDLIN( 207)															if ((this50 == 0)) {
HXDLIN( 207)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float g12;
HXDLIN( 207)															int this51 = ((this48 >> 8) & 255);
HXDLIN( 207)															if ((this51 == 0)) {
HXDLIN( 207)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float b13;
HXDLIN( 207)															int this52 = (this48 & 255);
HXDLIN( 207)															if ((this52 == 0)) {
HXDLIN( 207)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float a22;
HXDLIN( 207)															int this53 = ((col1 >> 24) & 255);
HXDLIN( 207)															if ((this53 == 0)) {
HXDLIN( 207)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float r22;
HXDLIN( 207)															int this54 = ((col1 >> 16) & 255);
HXDLIN( 207)															if ((this54 == 0)) {
HXDLIN( 207)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float g22;
HXDLIN( 207)															int this55 = ((col1 >> 8) & 255);
HXDLIN( 207)															if ((this55 == 0)) {
HXDLIN( 207)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float b23;
HXDLIN( 207)															int this56 = (col1 & 255);
HXDLIN( 207)															if ((this56 == 0)) {
HXDLIN( 207)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 207)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 207)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 207)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 207)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 207)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 207)															{
HXDLIN( 207)																int _hx_tmp10;
HXDLIN( 207)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 207)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 207)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 207)															::Dynamic this57 = undoImage3->image;
HXDLIN( 207)															int index7;
HXDLIN( 207)															if (undoImage3->useVirtualPos) {
HXDLIN( 207)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 207)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN( 207)															int _hx_tmp11;
HXDLIN( 207)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXDLIN( 207)																_hx_tmp11 = c6;
            															}
HXDLIN( 207)															::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 207)														if (forceClear1) {
HXDLIN( 207)															::Dynamic this58 = undoImage3->image;
HXDLIN( 207)															int x6 = (dx1 - rectLeft1);
HXDLIN( 207)															int y6 = (dy1 - rectTop1);
HXDLIN( 207)															int index8;
HXDLIN( 207)															if (undoImage3->useVirtualPos) {
HXDLIN( 207)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 207)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 207)															::iterMagic::Iimg_obj::set(this58,index8,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 207)							bool found1 = false;
HXDLIN( 207)							Float s1 = ((Float)0.);
HXDLIN( 207)							Float t1 = ((Float)0.);
HXDLIN( 207)							Float sxx1 = ((Float)0.);
HXDLIN( 207)							Float txx1 = ((Float)0.);
HXDLIN( 207)							{
HXDLIN( 207)								int _g_min2 = xIter31->start;
HXDLIN( 207)								int _g_max2 = xIter31->max;
HXDLIN( 207)								while((_g_min2 < _g_max2)){
HXDLIN( 207)									_g_min2 = (_g_min2 + 1);
HXDLIN( 207)									int x7 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)									found1 = false;
HXLINE( 207)									{
HXDLIN( 207)										int _g_min3 = yIter31->start;
HXDLIN( 207)										int _g_max3 = yIter31->max;
HXDLIN( 207)										while((_g_min3 < _g_max3)){
HXDLIN( 207)											_g_min3 = (_g_min3 + 1);
HXDLIN( 207)											int y7 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 207)											bool _hx_tmp12;
HXDLIN( 207)											if (!((s1 <= 0))) {
HXDLIN( 207)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 207)												_hx_tmp12 = true;
            											}
HXDLIN( 207)											if (_hx_tmp12) {
HXDLIN( 207)												if (found1) {
HXDLIN( 207)													goto _hx_goto_401;
            												}
            											}
            											else {
HXDLIN( 207)												if (((s1 + t1) < A1)) {
HXDLIN( 207)													{
HXDLIN( 207)														int c7 = color;
HXDLIN( 207)														bool _hx_tmp13;
HXDLIN( 207)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 207)															_hx_tmp13 = this36->transparent;
            														}
            														else {
HXDLIN( 207)															_hx_tmp13 = false;
            														}
HXDLIN( 207)														if (_hx_tmp13) {
HXDLIN( 207)															int location3;
HXDLIN( 207)															if (this36->useVirtualPos) {
HXDLIN( 207)																location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 207)																location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 207)															int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 207)															int this60;
HXDLIN( 207)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            															}
            															else {
HXDLIN( 207)																this60 = this59;
            															}
HXDLIN( 207)															Float a13;
HXDLIN( 207)															int this61 = ((this60 >> 24) & 255);
HXDLIN( 207)															if ((this61 == 0)) {
HXDLIN( 207)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float r13;
HXDLIN( 207)															int this62 = ((this60 >> 16) & 255);
HXDLIN( 207)															if ((this62 == 0)) {
HXDLIN( 207)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float g13;
HXDLIN( 207)															int this63 = ((this60 >> 8) & 255);
HXDLIN( 207)															if ((this63 == 0)) {
HXDLIN( 207)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float b14;
HXDLIN( 207)															int this64 = (this60 & 255);
HXDLIN( 207)															if ((this64 == 0)) {
HXDLIN( 207)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float a23;
HXDLIN( 207)															int this65 = ((color >> 24) & 255);
HXDLIN( 207)															if ((this65 == 0)) {
HXDLIN( 207)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float r23;
HXDLIN( 207)															int this66 = ((color >> 16) & 255);
HXDLIN( 207)															if ((this66 == 0)) {
HXDLIN( 207)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float g23;
HXDLIN( 207)															int this67 = ((color >> 8) & 255);
HXDLIN( 207)															if ((this67 == 0)) {
HXDLIN( 207)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float b24;
HXDLIN( 207)															int this68 = (color & 255);
HXDLIN( 207)															if ((this68 == 0)) {
HXDLIN( 207)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 207)																b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 207)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 207)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 207)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 207)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 207)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 207)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 207)															{
HXDLIN( 207)																int _hx_tmp14;
HXDLIN( 207)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 207)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 207)																::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 207)															::Dynamic this69 = this36->image;
HXDLIN( 207)															int index9;
HXDLIN( 207)															if (this36->useVirtualPos) {
HXDLIN( 207)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            															}
            															else {
HXDLIN( 207)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            															}
HXDLIN( 207)															int _hx_tmp15;
HXDLIN( 207)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 207)																_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 207)																_hx_tmp15 = c7;
            															}
HXDLIN( 207)															::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXDLIN( 207)													if (found1) {
HXDLIN( 207)														goto _hx_goto_401;
            													}
            												}
            											}
            										}
            										_hx_goto_401:;
            									}
            								}
            							}
HXDLIN( 207)							if ((hasHit1 == true)) {
HXDLIN( 207)								 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 207)								if (hasUndo1) {
HXDLIN( 207)									v6->undoImage = undoImage3;
HXDLIN( 207)									v6->undoX = xIter31->start;
HXDLIN( 207)									v6->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  59)				lastX = nextX1;
HXLINE(  60)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FillShape_Impl__obj,polyBuild,(void))

void FillShape_Impl__obj::arrowHead( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_222_arrowHead)
HXDLIN( 222)		 ::Dynamic phi1 = phi;
HXDLIN( 222)		 ::Dynamic sides = 3;
HXLINE( 226)		if (::hx::IsNull( sides )) {
HXLINE( 226)			sides = 36;
            		}
HXLINE( 225)		if (::hx::IsNull( phi1 )) {
HXLINE( 225)			phi1 = ((Float)0.);
            		}
HXLINE( 222)		{
HXDLIN( 222)			 ::Dynamic phi2 = phi1;
HXDLIN( 222)			 ::Dynamic sides1 = sides;
HXDLIN( 222)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 222)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 222)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 222)			Float omega;
HXDLIN( 222)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 222)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 222)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 222)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 222)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 222)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 222)			Float lastX = ((Float)0.);
HXDLIN( 222)			Float lastY = ((Float)0.);
HXDLIN( 222)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 222)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 222)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 222)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 222)				{
HXDLIN( 222)					int _g = 0;
HXDLIN( 222)					int _g1 = (sides1 + 1);
HXDLIN( 222)					while((_g < _g1)){
HXDLIN( 222)						_g = (_g + 1);
HXDLIN( 222)						int i = (_g - 1);
HXDLIN( 222)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 222)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 222)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 222)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 222)						{
HXDLIN( 222)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 222)							bool hasHit = false;
HXDLIN( 222)							bool hasUndo = false;
HXDLIN( 222)							{
HXDLIN( 222)								Float bx = lastX;
HXDLIN( 222)								Float by = lastY;
HXDLIN( 222)								Float cx1 = nextX;
HXDLIN( 222)								Float cy1 = nextY;
HXDLIN( 222)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 222)								if (!(adjustWinding)) {
HXDLIN( 222)									Float bx_ = bx;
HXDLIN( 222)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 222)								{
HXDLIN( 222)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 222)									Float sx = (cy1 - cy);
HXDLIN( 222)									Float sy = (cx - cx1);
HXDLIN( 222)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 222)									Float tx = (cy - by);
HXDLIN( 222)									Float ty = (bx - cx);
HXDLIN( 222)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 222)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 222)									if ((cx > bx)) {
HXDLIN( 222)										if ((cx > cx1)) {
HXDLIN( 222)											int min;
HXDLIN( 222)											if ((bx > cx1)) {
HXDLIN( 222)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 222)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 222)											int ii_min = min;
HXDLIN( 222)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 222)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 222)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 222)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 222)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 222)										if ((bx > cx1)) {
HXDLIN( 222)											int min1;
HXDLIN( 222)											if ((cx > cx1)) {
HXDLIN( 222)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 222)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 222)											int ii_min2 = min1;
HXDLIN( 222)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 222)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 222)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 222)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 222)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 222)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 222)									if ((cy > by)) {
HXDLIN( 222)										if ((cy > cy1)) {
HXDLIN( 222)											int min2;
HXDLIN( 222)											if ((by > cy1)) {
HXDLIN( 222)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 222)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 222)											int ii_min4 = min2;
HXDLIN( 222)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 222)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 222)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 222)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 222)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 222)										if ((by > cy1)) {
HXDLIN( 222)											int min3;
HXDLIN( 222)											if ((cy > cy1)) {
HXDLIN( 222)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 222)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 222)											int ii_min6 = min3;
HXDLIN( 222)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 222)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 222)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 222)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 222)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 222)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 222)									if (hasUndo) {
HXDLIN( 222)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 222)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 222)										 ::Dynamic imageType = null();
HXDLIN( 222)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 222)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 222)										::Dynamic undoImage1;
HXDLIN( 222)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 222)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 222)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 222)												{
HXDLIN( 222)													b->width = width;
HXDLIN( 222)													b->height = height;
HXDLIN( 222)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 222)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 222)													{
HXDLIN( 222)														int len = b->length;
HXDLIN( 222)														int w = 0;
HXDLIN( 222)														{
HXDLIN( 222)															int _g2 = 0;
HXDLIN( 222)															int _g3 = b->height;
HXDLIN( 222)															while((_g2 < _g3)){
HXDLIN( 222)																_g2 = (_g2 + 1);
HXDLIN( 222)																int y = (_g2 - 1);
HXDLIN( 222)																{
HXDLIN( 222)																	int _g4 = 0;
HXDLIN( 222)																	int _g5 = b->width;
HXDLIN( 222)																	while((_g4 < _g5)){
HXDLIN( 222)																		_g4 = (_g4 + 1);
HXDLIN( 222)																		int x = (_g4 - 1);
HXDLIN( 222)																		{
HXDLIN( 222)																			w = (w + 1);
HXDLIN( 222)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 222)																		{
HXDLIN( 222)																			w = (w + 1);
HXDLIN( 222)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 222)																		{
HXDLIN( 222)																			w = (w + 1);
HXDLIN( 222)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 222)																		{
HXDLIN( 222)																			w = (w + 1);
HXDLIN( 222)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 222)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 222)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 222)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 222)												{
HXDLIN( 222)													a->width = width;
HXDLIN( 222)													a->height = height;
HXDLIN( 222)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 222)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 222)													{
HXDLIN( 222)														int _g6 = 0;
HXDLIN( 222)														int _g7 = a->length;
HXDLIN( 222)														while((_g6 < _g7)){
HXDLIN( 222)															_g6 = (_g6 + 1);
HXDLIN( 222)															int i1 = (_g6 - 1);
HXDLIN( 222)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 222)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 222)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 222)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 222)												{
HXDLIN( 222)													b1->width = width;
HXDLIN( 222)													b1->height = height;
HXDLIN( 222)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 222)													int size = (b1->length * 4);
HXDLIN( 222)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 222)													{
HXDLIN( 222)														int _g8 = 0;
HXDLIN( 222)														int _g9 = b1->length;
HXDLIN( 222)														while((_g8 < _g9)){
HXDLIN( 222)															_g8 = (_g8 + 1);
HXDLIN( 222)															int i2 = (_g8 - 1);
HXDLIN( 222)															{
HXDLIN( 222)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 222)																bool undoImage2;
HXDLIN( 222)																if ((i2 >= 0)) {
HXDLIN( 222)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 222)																	undoImage2 = false;
            																}
HXDLIN( 222)																if (undoImage2) {
HXDLIN( 222)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 222)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 222)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 222)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 222)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 222)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 222)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 222)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 222)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 222)												{
HXDLIN( 222)													v1->width = width;
HXDLIN( 222)													v1->height = height;
HXDLIN( 222)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 222)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 222)													{
HXDLIN( 222)														int _g10 = 0;
HXDLIN( 222)														int _g11 = v1->length;
HXDLIN( 222)														while((_g10 < _g11)){
HXDLIN( 222)															_g10 = (_g10 + 1);
HXDLIN( 222)															int i3 = (_g10 - 1);
HXDLIN( 222)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 222)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 222)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 222)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 222)												{
HXDLIN( 222)													b2->width = width;
HXDLIN( 222)													b2->height = height;
HXDLIN( 222)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 222)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 222)													{
HXDLIN( 222)														int len1 = b2->length;
HXDLIN( 222)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 222)														if (::hx::IsNull( d->head )) {
HXDLIN( 222)															int _g12 = 0;
HXDLIN( 222)															int _g13 = len1;
HXDLIN( 222)															while((_g12 < _g13)){
HXDLIN( 222)																_g12 = (_g12 + 1);
HXDLIN( 222)																int i4 = (_g12 - 1);
HXDLIN( 222)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 222)															int _g14 = 0;
HXDLIN( 222)															int _g15 = len1;
HXDLIN( 222)															while((_g14 < _g15)){
HXDLIN( 222)																_g14 = (_g14 + 1);
HXDLIN( 222)																int i5 = (_g14 - 1);
HXDLIN( 222)																{
HXDLIN( 222)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 222)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 222)																	{
HXDLIN( 222)																		int _g16 = 0;
HXDLIN( 222)																		int _g17 = i5;
HXDLIN( 222)																		while((_g16 < _g17)){
HXDLIN( 222)																			_g16 = (_g16 + 1);
HXDLIN( 222)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 222)																	if (::hx::IsNull( prev )) {
HXDLIN( 222)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 222)																		l = null();
            																	}
            																	else {
HXDLIN( 222)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 222)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 222)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 222)										this3->image = undoImage1;
HXDLIN( 222)										this3->width = width;
HXDLIN( 222)										this3->height = height;
HXDLIN( 222)										this3->imageType = ( (int)(imageType) );
HXDLIN( 222)										undoImage = this3;
HXDLIN( 222)										{
HXDLIN( 222)											int rectLeft = xIter3->start;
HXDLIN( 222)											int rectTop = yIter3->start;
HXDLIN( 222)											int rectRight = xIter3->max;
HXDLIN( 222)											bool forceClear = false;
HXDLIN( 222)											{
HXDLIN( 222)												int _g18 = rectTop;
HXDLIN( 222)												int _g19 = yIter3->max;
HXDLIN( 222)												while((_g18 < _g19)){
HXDLIN( 222)													_g18 = (_g18 + 1);
HXDLIN( 222)													int dy = (_g18 - 1);
HXDLIN( 222)													{
HXDLIN( 222)														int _g20 = rectLeft;
HXDLIN( 222)														int _g21 = rectRight;
HXDLIN( 222)														while((_g20 < _g21)){
HXDLIN( 222)															_g20 = (_g20 + 1);
HXDLIN( 222)															int dx = (_g20 - 1);
HXDLIN( 222)															::Dynamic this5 = this2->image;
HXDLIN( 222)															int index;
HXDLIN( 222)															if (this2->useVirtualPos) {
HXDLIN( 222)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 222)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 222)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 222)															int col;
HXDLIN( 222)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 222)																col = c;
            															}
HXDLIN( 222)															bool _hx_tmp;
HXDLIN( 222)															if (this2->useMask) {
HXDLIN( 222)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 222)																_hx_tmp = false;
            															}
HXDLIN( 222)															if (_hx_tmp) {
HXDLIN( 222)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 222)																::Dynamic this7 = this6->image;
HXDLIN( 222)																int index1;
HXDLIN( 222)																if (this6->useVirtualPos) {
HXDLIN( 222)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 222)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 222)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 222)																int v2;
HXDLIN( 222)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 222)																	v2 = c1;
            																}
HXDLIN( 222)																int maskPixel = v2;
HXDLIN( 222)																int this8 = col;
HXDLIN( 222)																if ((maskPixel == 0)) {
HXDLIN( 222)																	col = this8;
            																}
            																else {
HXDLIN( 222)																	Float m0;
HXDLIN( 222)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 222)																	if ((this9 == 0)) {
HXDLIN( 222)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float m1;
HXDLIN( 222)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 222)																	if ((this10 == 0)) {
HXDLIN( 222)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float m2;
HXDLIN( 222)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 222)																	if ((this11 == 0)) {
HXDLIN( 222)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float m3;
HXDLIN( 222)																	int this12 = (maskPixel & 255);
HXDLIN( 222)																	if ((this12 == 0)) {
HXDLIN( 222)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 222)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 222)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 222)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 222)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 222)															if ((col != 0)) {
HXDLIN( 222)																int x1 = (dx - rectLeft);
HXDLIN( 222)																int y1 = (dy - rectTop);
HXDLIN( 222)																int c2 = col;
HXDLIN( 222)																bool _hx_tmp1;
HXDLIN( 222)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 222)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 222)																	_hx_tmp1 = false;
            																}
HXDLIN( 222)																if (_hx_tmp1) {
HXDLIN( 222)																	int location;
HXDLIN( 222)																	if (undoImage->useVirtualPos) {
HXDLIN( 222)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 222)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 222)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 222)																	int this14;
HXDLIN( 222)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 222)																		this14 = this13;
            																	}
HXDLIN( 222)																	Float a1;
HXDLIN( 222)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 222)																	if ((this15 == 0)) {
HXDLIN( 222)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float r1;
HXDLIN( 222)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 222)																	if ((this16 == 0)) {
HXDLIN( 222)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float g1;
HXDLIN( 222)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 222)																	if ((this17 == 0)) {
HXDLIN( 222)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float b11;
HXDLIN( 222)																	int this18 = (this14 & 255);
HXDLIN( 222)																	if ((this18 == 0)) {
HXDLIN( 222)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float a2;
HXDLIN( 222)																	int this19 = ((col >> 24) & 255);
HXDLIN( 222)																	if ((this19 == 0)) {
HXDLIN( 222)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float r2;
HXDLIN( 222)																	int this20 = ((col >> 16) & 255);
HXDLIN( 222)																	if ((this20 == 0)) {
HXDLIN( 222)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float g2;
HXDLIN( 222)																	int this21 = ((col >> 8) & 255);
HXDLIN( 222)																	if ((this21 == 0)) {
HXDLIN( 222)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float b21;
HXDLIN( 222)																	int this22 = (col & 255);
HXDLIN( 222)																	if ((this22 == 0)) {
HXDLIN( 222)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 222)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 222)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 222)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 222)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 222)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 222)																	{
HXDLIN( 222)																		int _hx_tmp2;
HXDLIN( 222)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 222)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 222)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 222)																	::Dynamic this23 = undoImage->image;
HXDLIN( 222)																	int index2;
HXDLIN( 222)																	if (undoImage->useVirtualPos) {
HXDLIN( 222)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 222)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 222)																	int _hx_tmp3;
HXDLIN( 222)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 222)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 222)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 222)																if (forceClear) {
HXDLIN( 222)																	::Dynamic this24 = undoImage->image;
HXDLIN( 222)																	int x2 = (dx - rectLeft);
HXDLIN( 222)																	int y2 = (dy - rectTop);
HXDLIN( 222)																	int index3;
HXDLIN( 222)																	if (undoImage->useVirtualPos) {
HXDLIN( 222)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 222)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 222)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 222)									bool found = false;
HXDLIN( 222)									Float s = ((Float)0.);
HXDLIN( 222)									Float t = ((Float)0.);
HXDLIN( 222)									Float sxx = ((Float)0.);
HXDLIN( 222)									Float txx = ((Float)0.);
HXDLIN( 222)									{
HXDLIN( 222)										int _g_min = xIter3->start;
HXDLIN( 222)										int _g_max = xIter3->max;
HXDLIN( 222)										while((_g_min < _g_max)){
HXDLIN( 222)											_g_min = (_g_min + 1);
HXDLIN( 222)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 222)											{
HXDLIN( 222)												int _g_min1 = yIter3->start;
HXDLIN( 222)												int _g_max1 = yIter3->max;
HXDLIN( 222)												while((_g_min1 < _g_max1)){
HXDLIN( 222)													_g_min1 = (_g_min1 + 1);
HXDLIN( 222)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 222)													bool _hx_tmp4;
HXDLIN( 222)													if (!((s <= 0))) {
HXDLIN( 222)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 222)														_hx_tmp4 = true;
            													}
HXDLIN( 222)													if (_hx_tmp4) {
HXDLIN( 222)														if (found) {
HXDLIN( 222)															goto _hx_goto_415;
            														}
            													}
            													else {
HXDLIN( 222)														if (((s + t) < A)) {
HXDLIN( 222)															{
HXDLIN( 222)																int c3 = color;
HXDLIN( 222)																bool _hx_tmp5;
HXDLIN( 222)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 222)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 222)																	_hx_tmp5 = false;
            																}
HXDLIN( 222)																if (_hx_tmp5) {
HXDLIN( 222)																	int location1;
HXDLIN( 222)																	if (this2->useVirtualPos) {
HXDLIN( 222)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 222)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 222)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 222)																	int this26;
HXDLIN( 222)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 222)																		this26 = this25;
            																	}
HXDLIN( 222)																	Float a11;
HXDLIN( 222)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 222)																	if ((this27 == 0)) {
HXDLIN( 222)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float r11;
HXDLIN( 222)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 222)																	if ((this28 == 0)) {
HXDLIN( 222)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float g11;
HXDLIN( 222)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 222)																	if ((this29 == 0)) {
HXDLIN( 222)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float b12;
HXDLIN( 222)																	int this30 = (this26 & 255);
HXDLIN( 222)																	if ((this30 == 0)) {
HXDLIN( 222)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float a21;
HXDLIN( 222)																	int this31 = ((color >> 24) & 255);
HXDLIN( 222)																	if ((this31 == 0)) {
HXDLIN( 222)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float r21;
HXDLIN( 222)																	int this32 = ((color >> 16) & 255);
HXDLIN( 222)																	if ((this32 == 0)) {
HXDLIN( 222)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float g21;
HXDLIN( 222)																	int this33 = ((color >> 8) & 255);
HXDLIN( 222)																	if ((this33 == 0)) {
HXDLIN( 222)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float b22;
HXDLIN( 222)																	int this34 = (color & 255);
HXDLIN( 222)																	if ((this34 == 0)) {
HXDLIN( 222)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 222)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 222)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 222)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 222)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 222)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 222)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 222)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 222)																	{
HXDLIN( 222)																		int _hx_tmp6;
HXDLIN( 222)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 222)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 222)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 222)																	::Dynamic this35 = this2->image;
HXDLIN( 222)																	int index4;
HXDLIN( 222)																	if (this2->useVirtualPos) {
HXDLIN( 222)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 222)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 222)																	int _hx_tmp7;
HXDLIN( 222)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 222)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 222)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 222)															if (found) {
HXDLIN( 222)																goto _hx_goto_415;
            															}
            														}
            													}
            												}
            												_hx_goto_415:;
            											}
            										}
            									}
HXDLIN( 222)									if ((hasHit == true)) {
HXDLIN( 222)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 222)										if (hasUndo) {
HXDLIN( 222)											v3->undoImage = undoImage;
HXDLIN( 222)											v3->undoX = xIter3->start;
HXDLIN( 222)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 222)				int _g22 = 0;
HXDLIN( 222)				int _g23 = (sides1 + 1);
HXDLIN( 222)				while((_g22 < _g23)){
HXDLIN( 222)					_g22 = (_g22 + 1);
HXDLIN( 222)					int i7 = (_g22 - 1);
HXDLIN( 222)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 222)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 222)					{
HXDLIN( 222)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 222)						bool hasHit1 = false;
HXDLIN( 222)						bool hasUndo1 = false;
HXDLIN( 222)						{
HXDLIN( 222)							Float bx1 = lastX;
HXDLIN( 222)							Float by1 = lastY;
HXDLIN( 222)							Float cx2 = nextX1;
HXDLIN( 222)							Float cy2 = nextY1;
HXDLIN( 222)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 222)							if (!(adjustWinding1)) {
HXDLIN( 222)								Float bx_1 = bx1;
HXDLIN( 222)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 222)							{
HXDLIN( 222)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 222)								Float sx1 = (cy2 - cy);
HXDLIN( 222)								Float sy1 = (cx - cx2);
HXDLIN( 222)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 222)								Float tx1 = (cy - by1);
HXDLIN( 222)								Float ty1 = (bx1 - cx);
HXDLIN( 222)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 222)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 222)								if ((cx > bx1)) {
HXDLIN( 222)									if ((cx > cx2)) {
HXDLIN( 222)										int min4;
HXDLIN( 222)										if ((bx1 > cx2)) {
HXDLIN( 222)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 222)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 222)										int ii_min8 = min4;
HXDLIN( 222)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 222)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 222)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 222)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 222)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 222)									if ((bx1 > cx2)) {
HXDLIN( 222)										int min5;
HXDLIN( 222)										if ((cx > cx2)) {
HXDLIN( 222)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 222)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 222)										int ii_min10 = min5;
HXDLIN( 222)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 222)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 222)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 222)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 222)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 222)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 222)								if ((cy > by1)) {
HXDLIN( 222)									if ((cy > cy2)) {
HXDLIN( 222)										int min6;
HXDLIN( 222)										if ((by1 > cy2)) {
HXDLIN( 222)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 222)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 222)										int ii_min12 = min6;
HXDLIN( 222)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 222)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 222)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 222)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 222)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 222)									if ((by1 > cy2)) {
HXDLIN( 222)										int min7;
HXDLIN( 222)										if ((cy > cy2)) {
HXDLIN( 222)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 222)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 222)										int ii_min14 = min7;
HXDLIN( 222)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 222)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 222)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 222)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 222)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 222)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 222)								if (hasUndo1) {
HXDLIN( 222)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 222)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 222)									 ::Dynamic imageType1 = null();
HXDLIN( 222)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 222)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 222)									::Dynamic undoImage4;
HXDLIN( 222)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 222)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 222)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 222)											{
HXDLIN( 222)												b5->width = width1;
HXDLIN( 222)												b5->height = height1;
HXDLIN( 222)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 222)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 222)												{
HXDLIN( 222)													int len2 = b5->length;
HXDLIN( 222)													int w1 = 0;
HXDLIN( 222)													{
HXDLIN( 222)														int _g24 = 0;
HXDLIN( 222)														int _g25 = b5->height;
HXDLIN( 222)														while((_g24 < _g25)){
HXDLIN( 222)															_g24 = (_g24 + 1);
HXDLIN( 222)															int y4 = (_g24 - 1);
HXDLIN( 222)															{
HXDLIN( 222)																int _g26 = 0;
HXDLIN( 222)																int _g27 = b5->width;
HXDLIN( 222)																while((_g26 < _g27)){
HXDLIN( 222)																	_g26 = (_g26 + 1);
HXDLIN( 222)																	int x4 = (_g26 - 1);
HXDLIN( 222)																	{
HXDLIN( 222)																		w1 = (w1 + 1);
HXDLIN( 222)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 222)																	{
HXDLIN( 222)																		w1 = (w1 + 1);
HXDLIN( 222)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 222)																	{
HXDLIN( 222)																		w1 = (w1 + 1);
HXDLIN( 222)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 222)																	{
HXDLIN( 222)																		w1 = (w1 + 1);
HXDLIN( 222)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 222)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 222)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 222)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 222)											{
HXDLIN( 222)												a6->width = width1;
HXDLIN( 222)												a6->height = height1;
HXDLIN( 222)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 222)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 222)												{
HXDLIN( 222)													int _g28 = 0;
HXDLIN( 222)													int _g29 = a6->length;
HXDLIN( 222)													while((_g28 < _g29)){
HXDLIN( 222)														_g28 = (_g28 + 1);
HXDLIN( 222)														int i8 = (_g28 - 1);
HXDLIN( 222)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 222)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 222)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 222)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 222)											{
HXDLIN( 222)												b6->width = width1;
HXDLIN( 222)												b6->height = height1;
HXDLIN( 222)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 222)												int size1 = (b6->length * 4);
HXDLIN( 222)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 222)												{
HXDLIN( 222)													int _g30 = 0;
HXDLIN( 222)													int _g31 = b6->length;
HXDLIN( 222)													while((_g30 < _g31)){
HXDLIN( 222)														_g30 = (_g30 + 1);
HXDLIN( 222)														int i9 = (_g30 - 1);
HXDLIN( 222)														{
HXDLIN( 222)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 222)															bool undoImage5;
HXDLIN( 222)															if ((i9 >= 0)) {
HXDLIN( 222)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 222)																undoImage5 = false;
            															}
HXDLIN( 222)															if (undoImage5) {
HXDLIN( 222)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 222)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 222)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 222)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 222)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 222)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 222)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 222)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 222)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 222)											{
HXDLIN( 222)												v4->width = width1;
HXDLIN( 222)												v4->height = height1;
HXDLIN( 222)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 222)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 222)												{
HXDLIN( 222)													int _g32 = 0;
HXDLIN( 222)													int _g33 = v4->length;
HXDLIN( 222)													while((_g32 < _g33)){
HXDLIN( 222)														_g32 = (_g32 + 1);
HXDLIN( 222)														int i10 = (_g32 - 1);
HXDLIN( 222)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 222)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 222)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 222)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 222)											{
HXDLIN( 222)												b7->width = width1;
HXDLIN( 222)												b7->height = height1;
HXDLIN( 222)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 222)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 222)												{
HXDLIN( 222)													int len3 = b7->length;
HXDLIN( 222)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 222)													if (::hx::IsNull( d1->head )) {
HXDLIN( 222)														int _g34 = 0;
HXDLIN( 222)														int _g35 = len3;
HXDLIN( 222)														while((_g34 < _g35)){
HXDLIN( 222)															_g34 = (_g34 + 1);
HXDLIN( 222)															int i11 = (_g34 - 1);
HXDLIN( 222)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 222)														int _g36 = 0;
HXDLIN( 222)														int _g37 = len3;
HXDLIN( 222)														while((_g36 < _g37)){
HXDLIN( 222)															_g36 = (_g36 + 1);
HXDLIN( 222)															int i12 = (_g36 - 1);
HXDLIN( 222)															{
HXDLIN( 222)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 222)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 222)																{
HXDLIN( 222)																	int _g38 = 0;
HXDLIN( 222)																	int _g39 = i12;
HXDLIN( 222)																	while((_g38 < _g39)){
HXDLIN( 222)																		_g38 = (_g38 + 1);
HXDLIN( 222)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 222)																if (::hx::IsNull( prev1 )) {
HXDLIN( 222)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 222)																	l1 = null();
            																}
            																else {
HXDLIN( 222)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 222)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 222)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 222)									this37->image = undoImage4;
HXDLIN( 222)									this37->width = width1;
HXDLIN( 222)									this37->height = height1;
HXDLIN( 222)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 222)									undoImage3 = this37;
HXDLIN( 222)									{
HXDLIN( 222)										int rectLeft1 = xIter31->start;
HXDLIN( 222)										int rectTop1 = yIter31->start;
HXDLIN( 222)										int rectRight1 = xIter31->max;
HXDLIN( 222)										bool forceClear1 = false;
HXDLIN( 222)										{
HXDLIN( 222)											int _g40 = rectTop1;
HXDLIN( 222)											int _g41 = yIter31->max;
HXDLIN( 222)											while((_g40 < _g41)){
HXDLIN( 222)												_g40 = (_g40 + 1);
HXDLIN( 222)												int dy1 = (_g40 - 1);
HXDLIN( 222)												{
HXDLIN( 222)													int _g42 = rectLeft1;
HXDLIN( 222)													int _g43 = rectRight1;
HXDLIN( 222)													while((_g42 < _g43)){
HXDLIN( 222)														_g42 = (_g42 + 1);
HXDLIN( 222)														int dx1 = (_g42 - 1);
HXDLIN( 222)														::Dynamic this39 = this36->image;
HXDLIN( 222)														int index5;
HXDLIN( 222)														if (this36->useVirtualPos) {
HXDLIN( 222)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 222)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 222)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 222)														int col1;
HXDLIN( 222)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 222)															col1 = c4;
            														}
HXDLIN( 222)														bool _hx_tmp8;
HXDLIN( 222)														if (this36->useMask) {
HXDLIN( 222)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 222)															_hx_tmp8 = false;
            														}
HXDLIN( 222)														if (_hx_tmp8) {
HXDLIN( 222)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 222)															::Dynamic this41 = this40->image;
HXDLIN( 222)															int index6;
HXDLIN( 222)															if (this40->useVirtualPos) {
HXDLIN( 222)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 222)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 222)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 222)															int v5;
HXDLIN( 222)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 222)																v5 = c5;
            															}
HXDLIN( 222)															int maskPixel1 = v5;
HXDLIN( 222)															int this42 = col1;
HXDLIN( 222)															if ((maskPixel1 == 0)) {
HXDLIN( 222)																col1 = this42;
            															}
            															else {
HXDLIN( 222)																Float m01;
HXDLIN( 222)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 222)																if ((this43 == 0)) {
HXDLIN( 222)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float m11;
HXDLIN( 222)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 222)																if ((this44 == 0)) {
HXDLIN( 222)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float m21;
HXDLIN( 222)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 222)																if ((this45 == 0)) {
HXDLIN( 222)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float m31;
HXDLIN( 222)																int this46 = (maskPixel1 & 255);
HXDLIN( 222)																if ((this46 == 0)) {
HXDLIN( 222)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 222)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 222)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 222)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 222)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 222)														if ((col1 != 0)) {
HXDLIN( 222)															int x5 = (dx1 - rectLeft1);
HXDLIN( 222)															int y5 = (dy1 - rectTop1);
HXDLIN( 222)															int c6 = col1;
HXDLIN( 222)															bool _hx_tmp9;
HXDLIN( 222)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 222)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 222)																_hx_tmp9 = false;
            															}
HXDLIN( 222)															if (_hx_tmp9) {
HXDLIN( 222)																int location2;
HXDLIN( 222)																if (undoImage3->useVirtualPos) {
HXDLIN( 222)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 222)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 222)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 222)																int this48;
HXDLIN( 222)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 222)																	this48 = this47;
            																}
HXDLIN( 222)																Float a12;
HXDLIN( 222)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 222)																if ((this49 == 0)) {
HXDLIN( 222)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float r12;
HXDLIN( 222)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 222)																if ((this50 == 0)) {
HXDLIN( 222)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float g12;
HXDLIN( 222)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 222)																if ((this51 == 0)) {
HXDLIN( 222)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float b13;
HXDLIN( 222)																int this52 = (this48 & 255);
HXDLIN( 222)																if ((this52 == 0)) {
HXDLIN( 222)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float a22;
HXDLIN( 222)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 222)																if ((this53 == 0)) {
HXDLIN( 222)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float r22;
HXDLIN( 222)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 222)																if ((this54 == 0)) {
HXDLIN( 222)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float g22;
HXDLIN( 222)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 222)																if ((this55 == 0)) {
HXDLIN( 222)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float b23;
HXDLIN( 222)																int this56 = (col1 & 255);
HXDLIN( 222)																if ((this56 == 0)) {
HXDLIN( 222)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 222)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 222)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 222)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 222)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 222)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 222)																{
HXDLIN( 222)																	int _hx_tmp10;
HXDLIN( 222)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 222)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 222)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 222)																::Dynamic this57 = undoImage3->image;
HXDLIN( 222)																int index7;
HXDLIN( 222)																if (undoImage3->useVirtualPos) {
HXDLIN( 222)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 222)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 222)																int _hx_tmp11;
HXDLIN( 222)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 222)																	_hx_tmp11 = c6;
            																}
HXDLIN( 222)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 222)															if (forceClear1) {
HXDLIN( 222)																::Dynamic this58 = undoImage3->image;
HXDLIN( 222)																int x6 = (dx1 - rectLeft1);
HXDLIN( 222)																int y6 = (dy1 - rectTop1);
HXDLIN( 222)																int index8;
HXDLIN( 222)																if (undoImage3->useVirtualPos) {
HXDLIN( 222)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 222)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 222)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 222)								bool found1 = false;
HXDLIN( 222)								Float s1 = ((Float)0.);
HXDLIN( 222)								Float t1 = ((Float)0.);
HXDLIN( 222)								Float sxx1 = ((Float)0.);
HXDLIN( 222)								Float txx1 = ((Float)0.);
HXDLIN( 222)								{
HXDLIN( 222)									int _g_min2 = xIter31->start;
HXDLIN( 222)									int _g_max2 = xIter31->max;
HXDLIN( 222)									while((_g_min2 < _g_max2)){
HXDLIN( 222)										_g_min2 = (_g_min2 + 1);
HXDLIN( 222)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 222)										{
HXDLIN( 222)											int _g_min3 = yIter31->start;
HXDLIN( 222)											int _g_max3 = yIter31->max;
HXDLIN( 222)											while((_g_min3 < _g_max3)){
HXDLIN( 222)												_g_min3 = (_g_min3 + 1);
HXDLIN( 222)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 222)												bool _hx_tmp12;
HXDLIN( 222)												if (!((s1 <= 0))) {
HXDLIN( 222)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 222)													_hx_tmp12 = true;
            												}
HXDLIN( 222)												if (_hx_tmp12) {
HXDLIN( 222)													if (found1) {
HXDLIN( 222)														goto _hx_goto_428;
            													}
            												}
            												else {
HXDLIN( 222)													if (((s1 + t1) < A1)) {
HXDLIN( 222)														{
HXDLIN( 222)															int c7 = color;
HXDLIN( 222)															bool _hx_tmp13;
HXDLIN( 222)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 222)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 222)																_hx_tmp13 = false;
            															}
HXDLIN( 222)															if (_hx_tmp13) {
HXDLIN( 222)																int location3;
HXDLIN( 222)																if (this36->useVirtualPos) {
HXDLIN( 222)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 222)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 222)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 222)																int this60;
HXDLIN( 222)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 222)																	this60 = this59;
            																}
HXDLIN( 222)																Float a13;
HXDLIN( 222)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 222)																if ((this61 == 0)) {
HXDLIN( 222)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float r13;
HXDLIN( 222)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 222)																if ((this62 == 0)) {
HXDLIN( 222)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float g13;
HXDLIN( 222)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 222)																if ((this63 == 0)) {
HXDLIN( 222)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float b14;
HXDLIN( 222)																int this64 = (this60 & 255);
HXDLIN( 222)																if ((this64 == 0)) {
HXDLIN( 222)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float a23;
HXDLIN( 222)																int this65 = ((color >> 24) & 255);
HXDLIN( 222)																if ((this65 == 0)) {
HXDLIN( 222)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float r23;
HXDLIN( 222)																int this66 = ((color >> 16) & 255);
HXDLIN( 222)																if ((this66 == 0)) {
HXDLIN( 222)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float g23;
HXDLIN( 222)																int this67 = ((color >> 8) & 255);
HXDLIN( 222)																if ((this67 == 0)) {
HXDLIN( 222)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float b24;
HXDLIN( 222)																int this68 = (color & 255);
HXDLIN( 222)																if ((this68 == 0)) {
HXDLIN( 222)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 222)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 222)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 222)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 222)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 222)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 222)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 222)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 222)																{
HXDLIN( 222)																	int _hx_tmp14;
HXDLIN( 222)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 222)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 222)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 222)																::Dynamic this69 = this36->image;
HXDLIN( 222)																int index9;
HXDLIN( 222)																if (this36->useVirtualPos) {
HXDLIN( 222)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 222)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 222)																int _hx_tmp15;
HXDLIN( 222)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 222)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 222)																	_hx_tmp15 = c7;
            																}
HXDLIN( 222)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 222)														if (found1) {
HXDLIN( 222)															goto _hx_goto_428;
            														}
            													}
            												}
            											}
            											_hx_goto_428:;
            										}
            									}
            								}
HXDLIN( 222)								if ((hasHit1 == true)) {
HXDLIN( 222)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 222)									if (hasUndo1) {
HXDLIN( 222)										v6->undoImage = undoImage3;
HXDLIN( 222)										v6->undoX = xIter31->start;
HXDLIN( 222)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,arrowHead,(void))

void FillShape_Impl__obj::pentagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_235_pentagon)
HXDLIN( 235)		 ::Dynamic phi1 = phi;
HXDLIN( 235)		 ::Dynamic sides = 5;
HXLINE( 239)		if (::hx::IsNull( sides )) {
HXLINE( 239)			sides = 36;
            		}
HXLINE( 238)		if (::hx::IsNull( phi1 )) {
HXLINE( 238)			phi1 = ((Float)0.);
            		}
HXLINE( 235)		{
HXDLIN( 235)			 ::Dynamic phi2 = phi1;
HXDLIN( 235)			 ::Dynamic sides1 = sides;
HXDLIN( 235)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 235)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 235)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 235)			Float omega;
HXDLIN( 235)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 235)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 235)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 235)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 235)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 235)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 235)			Float lastX = ((Float)0.);
HXDLIN( 235)			Float lastY = ((Float)0.);
HXDLIN( 235)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 235)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 235)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 235)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 235)				{
HXDLIN( 235)					int _g = 0;
HXDLIN( 235)					int _g1 = (sides1 + 1);
HXDLIN( 235)					while((_g < _g1)){
HXDLIN( 235)						_g = (_g + 1);
HXDLIN( 235)						int i = (_g - 1);
HXDLIN( 235)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 235)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 235)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 235)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 235)						{
HXDLIN( 235)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 235)							bool hasHit = false;
HXDLIN( 235)							bool hasUndo = false;
HXDLIN( 235)							{
HXDLIN( 235)								Float bx = lastX;
HXDLIN( 235)								Float by = lastY;
HXDLIN( 235)								Float cx1 = nextX;
HXDLIN( 235)								Float cy1 = nextY;
HXDLIN( 235)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 235)								if (!(adjustWinding)) {
HXDLIN( 235)									Float bx_ = bx;
HXDLIN( 235)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 235)								{
HXDLIN( 235)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 235)									Float sx = (cy1 - cy);
HXDLIN( 235)									Float sy = (cx - cx1);
HXDLIN( 235)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 235)									Float tx = (cy - by);
HXDLIN( 235)									Float ty = (bx - cx);
HXDLIN( 235)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 235)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 235)									if ((cx > bx)) {
HXDLIN( 235)										if ((cx > cx1)) {
HXDLIN( 235)											int min;
HXDLIN( 235)											if ((bx > cx1)) {
HXDLIN( 235)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 235)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 235)											int ii_min = min;
HXDLIN( 235)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 235)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 235)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 235)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 235)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 235)										if ((bx > cx1)) {
HXDLIN( 235)											int min1;
HXDLIN( 235)											if ((cx > cx1)) {
HXDLIN( 235)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 235)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 235)											int ii_min2 = min1;
HXDLIN( 235)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 235)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 235)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 235)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 235)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 235)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 235)									if ((cy > by)) {
HXDLIN( 235)										if ((cy > cy1)) {
HXDLIN( 235)											int min2;
HXDLIN( 235)											if ((by > cy1)) {
HXDLIN( 235)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 235)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 235)											int ii_min4 = min2;
HXDLIN( 235)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 235)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 235)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 235)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 235)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 235)										if ((by > cy1)) {
HXDLIN( 235)											int min3;
HXDLIN( 235)											if ((cy > cy1)) {
HXDLIN( 235)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 235)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 235)											int ii_min6 = min3;
HXDLIN( 235)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 235)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 235)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 235)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 235)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 235)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 235)									if (hasUndo) {
HXDLIN( 235)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 235)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 235)										 ::Dynamic imageType = null();
HXDLIN( 235)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 235)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 235)										::Dynamic undoImage1;
HXDLIN( 235)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 235)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 235)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 235)												{
HXDLIN( 235)													b->width = width;
HXDLIN( 235)													b->height = height;
HXDLIN( 235)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 235)													{
HXDLIN( 235)														int len = b->length;
HXDLIN( 235)														int w = 0;
HXDLIN( 235)														{
HXDLIN( 235)															int _g2 = 0;
HXDLIN( 235)															int _g3 = b->height;
HXDLIN( 235)															while((_g2 < _g3)){
HXDLIN( 235)																_g2 = (_g2 + 1);
HXDLIN( 235)																int y = (_g2 - 1);
HXDLIN( 235)																{
HXDLIN( 235)																	int _g4 = 0;
HXDLIN( 235)																	int _g5 = b->width;
HXDLIN( 235)																	while((_g4 < _g5)){
HXDLIN( 235)																		_g4 = (_g4 + 1);
HXDLIN( 235)																		int x = (_g4 - 1);
HXDLIN( 235)																		{
HXDLIN( 235)																			w = (w + 1);
HXDLIN( 235)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 235)																		{
HXDLIN( 235)																			w = (w + 1);
HXDLIN( 235)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 235)																		{
HXDLIN( 235)																			w = (w + 1);
HXDLIN( 235)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 235)																		{
HXDLIN( 235)																			w = (w + 1);
HXDLIN( 235)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 235)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 235)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 235)												{
HXDLIN( 235)													a->width = width;
HXDLIN( 235)													a->height = height;
HXDLIN( 235)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 235)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)													{
HXDLIN( 235)														int _g6 = 0;
HXDLIN( 235)														int _g7 = a->length;
HXDLIN( 235)														while((_g6 < _g7)){
HXDLIN( 235)															_g6 = (_g6 + 1);
HXDLIN( 235)															int i1 = (_g6 - 1);
HXDLIN( 235)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 235)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 235)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 235)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 235)												{
HXDLIN( 235)													b1->width = width;
HXDLIN( 235)													b1->height = height;
HXDLIN( 235)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)													int size = (b1->length * 4);
HXDLIN( 235)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 235)													{
HXDLIN( 235)														int _g8 = 0;
HXDLIN( 235)														int _g9 = b1->length;
HXDLIN( 235)														while((_g8 < _g9)){
HXDLIN( 235)															_g8 = (_g8 + 1);
HXDLIN( 235)															int i2 = (_g8 - 1);
HXDLIN( 235)															{
HXDLIN( 235)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 235)																bool undoImage2;
HXDLIN( 235)																if ((i2 >= 0)) {
HXDLIN( 235)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 235)																	undoImage2 = false;
            																}
HXDLIN( 235)																if (undoImage2) {
HXDLIN( 235)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 235)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 235)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 235)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 235)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 235)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 235)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 235)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 235)												{
HXDLIN( 235)													v1->width = width;
HXDLIN( 235)													v1->height = height;
HXDLIN( 235)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 235)													{
HXDLIN( 235)														int _g10 = 0;
HXDLIN( 235)														int _g11 = v1->length;
HXDLIN( 235)														while((_g10 < _g11)){
HXDLIN( 235)															_g10 = (_g10 + 1);
HXDLIN( 235)															int i3 = (_g10 - 1);
HXDLIN( 235)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 235)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 235)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 235)												{
HXDLIN( 235)													b2->width = width;
HXDLIN( 235)													b2->height = height;
HXDLIN( 235)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 235)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 235)													{
HXDLIN( 235)														int len1 = b2->length;
HXDLIN( 235)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 235)														if (::hx::IsNull( d->head )) {
HXDLIN( 235)															int _g12 = 0;
HXDLIN( 235)															int _g13 = len1;
HXDLIN( 235)															while((_g12 < _g13)){
HXDLIN( 235)																_g12 = (_g12 + 1);
HXDLIN( 235)																int i4 = (_g12 - 1);
HXDLIN( 235)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 235)															int _g14 = 0;
HXDLIN( 235)															int _g15 = len1;
HXDLIN( 235)															while((_g14 < _g15)){
HXDLIN( 235)																_g14 = (_g14 + 1);
HXDLIN( 235)																int i5 = (_g14 - 1);
HXDLIN( 235)																{
HXDLIN( 235)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 235)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 235)																	{
HXDLIN( 235)																		int _g16 = 0;
HXDLIN( 235)																		int _g17 = i5;
HXDLIN( 235)																		while((_g16 < _g17)){
HXDLIN( 235)																			_g16 = (_g16 + 1);
HXDLIN( 235)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 235)																	if (::hx::IsNull( prev )) {
HXDLIN( 235)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 235)																		l = null();
            																	}
            																	else {
HXDLIN( 235)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 235)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 235)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 235)										this3->image = undoImage1;
HXDLIN( 235)										this3->width = width;
HXDLIN( 235)										this3->height = height;
HXDLIN( 235)										this3->imageType = ( (int)(imageType) );
HXDLIN( 235)										undoImage = this3;
HXDLIN( 235)										{
HXDLIN( 235)											int rectLeft = xIter3->start;
HXDLIN( 235)											int rectTop = yIter3->start;
HXDLIN( 235)											int rectRight = xIter3->max;
HXDLIN( 235)											bool forceClear = false;
HXDLIN( 235)											{
HXDLIN( 235)												int _g18 = rectTop;
HXDLIN( 235)												int _g19 = yIter3->max;
HXDLIN( 235)												while((_g18 < _g19)){
HXDLIN( 235)													_g18 = (_g18 + 1);
HXDLIN( 235)													int dy = (_g18 - 1);
HXDLIN( 235)													{
HXDLIN( 235)														int _g20 = rectLeft;
HXDLIN( 235)														int _g21 = rectRight;
HXDLIN( 235)														while((_g20 < _g21)){
HXDLIN( 235)															_g20 = (_g20 + 1);
HXDLIN( 235)															int dx = (_g20 - 1);
HXDLIN( 235)															::Dynamic this5 = this2->image;
HXDLIN( 235)															int index;
HXDLIN( 235)															if (this2->useVirtualPos) {
HXDLIN( 235)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 235)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 235)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 235)															int col;
HXDLIN( 235)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 235)																col = c;
            															}
HXDLIN( 235)															bool _hx_tmp;
HXDLIN( 235)															if (this2->useMask) {
HXDLIN( 235)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 235)																_hx_tmp = false;
            															}
HXDLIN( 235)															if (_hx_tmp) {
HXDLIN( 235)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 235)																::Dynamic this7 = this6->image;
HXDLIN( 235)																int index1;
HXDLIN( 235)																if (this6->useVirtualPos) {
HXDLIN( 235)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 235)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 235)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 235)																int v2;
HXDLIN( 235)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 235)																	v2 = c1;
            																}
HXDLIN( 235)																int maskPixel = v2;
HXDLIN( 235)																int this8 = col;
HXDLIN( 235)																if ((maskPixel == 0)) {
HXDLIN( 235)																	col = this8;
            																}
            																else {
HXDLIN( 235)																	Float m0;
HXDLIN( 235)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 235)																	if ((this9 == 0)) {
HXDLIN( 235)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float m1;
HXDLIN( 235)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 235)																	if ((this10 == 0)) {
HXDLIN( 235)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float m2;
HXDLIN( 235)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 235)																	if ((this11 == 0)) {
HXDLIN( 235)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float m3;
HXDLIN( 235)																	int this12 = (maskPixel & 255);
HXDLIN( 235)																	if ((this12 == 0)) {
HXDLIN( 235)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 235)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 235)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 235)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 235)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 235)															if ((col != 0)) {
HXDLIN( 235)																int x1 = (dx - rectLeft);
HXDLIN( 235)																int y1 = (dy - rectTop);
HXDLIN( 235)																int c2 = col;
HXDLIN( 235)																bool _hx_tmp1;
HXDLIN( 235)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 235)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 235)																	_hx_tmp1 = false;
            																}
HXDLIN( 235)																if (_hx_tmp1) {
HXDLIN( 235)																	int location;
HXDLIN( 235)																	if (undoImage->useVirtualPos) {
HXDLIN( 235)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 235)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 235)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 235)																	int this14;
HXDLIN( 235)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 235)																		this14 = this13;
            																	}
HXDLIN( 235)																	Float a1;
HXDLIN( 235)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 235)																	if ((this15 == 0)) {
HXDLIN( 235)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float r1;
HXDLIN( 235)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 235)																	if ((this16 == 0)) {
HXDLIN( 235)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float g1;
HXDLIN( 235)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 235)																	if ((this17 == 0)) {
HXDLIN( 235)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float b11;
HXDLIN( 235)																	int this18 = (this14 & 255);
HXDLIN( 235)																	if ((this18 == 0)) {
HXDLIN( 235)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float a2;
HXDLIN( 235)																	int this19 = ((col >> 24) & 255);
HXDLIN( 235)																	if ((this19 == 0)) {
HXDLIN( 235)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float r2;
HXDLIN( 235)																	int this20 = ((col >> 16) & 255);
HXDLIN( 235)																	if ((this20 == 0)) {
HXDLIN( 235)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float g2;
HXDLIN( 235)																	int this21 = ((col >> 8) & 255);
HXDLIN( 235)																	if ((this21 == 0)) {
HXDLIN( 235)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float b21;
HXDLIN( 235)																	int this22 = (col & 255);
HXDLIN( 235)																	if ((this22 == 0)) {
HXDLIN( 235)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 235)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 235)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 235)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 235)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 235)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 235)																	{
HXDLIN( 235)																		int _hx_tmp2;
HXDLIN( 235)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 235)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 235)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 235)																	::Dynamic this23 = undoImage->image;
HXDLIN( 235)																	int index2;
HXDLIN( 235)																	if (undoImage->useVirtualPos) {
HXDLIN( 235)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 235)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 235)																	int _hx_tmp3;
HXDLIN( 235)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 235)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 235)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 235)																if (forceClear) {
HXDLIN( 235)																	::Dynamic this24 = undoImage->image;
HXDLIN( 235)																	int x2 = (dx - rectLeft);
HXDLIN( 235)																	int y2 = (dy - rectTop);
HXDLIN( 235)																	int index3;
HXDLIN( 235)																	if (undoImage->useVirtualPos) {
HXDLIN( 235)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 235)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 235)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 235)									bool found = false;
HXDLIN( 235)									Float s = ((Float)0.);
HXDLIN( 235)									Float t = ((Float)0.);
HXDLIN( 235)									Float sxx = ((Float)0.);
HXDLIN( 235)									Float txx = ((Float)0.);
HXDLIN( 235)									{
HXDLIN( 235)										int _g_min = xIter3->start;
HXDLIN( 235)										int _g_max = xIter3->max;
HXDLIN( 235)										while((_g_min < _g_max)){
HXDLIN( 235)											_g_min = (_g_min + 1);
HXDLIN( 235)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 235)											{
HXDLIN( 235)												int _g_min1 = yIter3->start;
HXDLIN( 235)												int _g_max1 = yIter3->max;
HXDLIN( 235)												while((_g_min1 < _g_max1)){
HXDLIN( 235)													_g_min1 = (_g_min1 + 1);
HXDLIN( 235)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 235)													bool _hx_tmp4;
HXDLIN( 235)													if (!((s <= 0))) {
HXDLIN( 235)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 235)														_hx_tmp4 = true;
            													}
HXDLIN( 235)													if (_hx_tmp4) {
HXDLIN( 235)														if (found) {
HXDLIN( 235)															goto _hx_goto_442;
            														}
            													}
            													else {
HXDLIN( 235)														if (((s + t) < A)) {
HXDLIN( 235)															{
HXDLIN( 235)																int c3 = color;
HXDLIN( 235)																bool _hx_tmp5;
HXDLIN( 235)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 235)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 235)																	_hx_tmp5 = false;
            																}
HXDLIN( 235)																if (_hx_tmp5) {
HXDLIN( 235)																	int location1;
HXDLIN( 235)																	if (this2->useVirtualPos) {
HXDLIN( 235)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 235)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 235)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 235)																	int this26;
HXDLIN( 235)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 235)																		this26 = this25;
            																	}
HXDLIN( 235)																	Float a11;
HXDLIN( 235)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 235)																	if ((this27 == 0)) {
HXDLIN( 235)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float r11;
HXDLIN( 235)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 235)																	if ((this28 == 0)) {
HXDLIN( 235)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float g11;
HXDLIN( 235)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 235)																	if ((this29 == 0)) {
HXDLIN( 235)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float b12;
HXDLIN( 235)																	int this30 = (this26 & 255);
HXDLIN( 235)																	if ((this30 == 0)) {
HXDLIN( 235)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float a21;
HXDLIN( 235)																	int this31 = ((color >> 24) & 255);
HXDLIN( 235)																	if ((this31 == 0)) {
HXDLIN( 235)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float r21;
HXDLIN( 235)																	int this32 = ((color >> 16) & 255);
HXDLIN( 235)																	if ((this32 == 0)) {
HXDLIN( 235)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float g21;
HXDLIN( 235)																	int this33 = ((color >> 8) & 255);
HXDLIN( 235)																	if ((this33 == 0)) {
HXDLIN( 235)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float b22;
HXDLIN( 235)																	int this34 = (color & 255);
HXDLIN( 235)																	if ((this34 == 0)) {
HXDLIN( 235)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 235)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 235)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 235)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 235)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 235)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 235)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 235)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 235)																	{
HXDLIN( 235)																		int _hx_tmp6;
HXDLIN( 235)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 235)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 235)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 235)																	::Dynamic this35 = this2->image;
HXDLIN( 235)																	int index4;
HXDLIN( 235)																	if (this2->useVirtualPos) {
HXDLIN( 235)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 235)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 235)																	int _hx_tmp7;
HXDLIN( 235)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 235)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 235)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 235)															if (found) {
HXDLIN( 235)																goto _hx_goto_442;
            															}
            														}
            													}
            												}
            												_hx_goto_442:;
            											}
            										}
            									}
HXDLIN( 235)									if ((hasHit == true)) {
HXDLIN( 235)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 235)										if (hasUndo) {
HXDLIN( 235)											v3->undoImage = undoImage;
HXDLIN( 235)											v3->undoX = xIter3->start;
HXDLIN( 235)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 235)				int _g22 = 0;
HXDLIN( 235)				int _g23 = (sides1 + 1);
HXDLIN( 235)				while((_g22 < _g23)){
HXDLIN( 235)					_g22 = (_g22 + 1);
HXDLIN( 235)					int i7 = (_g22 - 1);
HXDLIN( 235)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 235)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 235)					{
HXDLIN( 235)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 235)						bool hasHit1 = false;
HXDLIN( 235)						bool hasUndo1 = false;
HXDLIN( 235)						{
HXDLIN( 235)							Float bx1 = lastX;
HXDLIN( 235)							Float by1 = lastY;
HXDLIN( 235)							Float cx2 = nextX1;
HXDLIN( 235)							Float cy2 = nextY1;
HXDLIN( 235)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 235)							if (!(adjustWinding1)) {
HXDLIN( 235)								Float bx_1 = bx1;
HXDLIN( 235)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 235)							{
HXDLIN( 235)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 235)								Float sx1 = (cy2 - cy);
HXDLIN( 235)								Float sy1 = (cx - cx2);
HXDLIN( 235)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 235)								Float tx1 = (cy - by1);
HXDLIN( 235)								Float ty1 = (bx1 - cx);
HXDLIN( 235)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 235)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 235)								if ((cx > bx1)) {
HXDLIN( 235)									if ((cx > cx2)) {
HXDLIN( 235)										int min4;
HXDLIN( 235)										if ((bx1 > cx2)) {
HXDLIN( 235)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 235)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 235)										int ii_min8 = min4;
HXDLIN( 235)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 235)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 235)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 235)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 235)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 235)									if ((bx1 > cx2)) {
HXDLIN( 235)										int min5;
HXDLIN( 235)										if ((cx > cx2)) {
HXDLIN( 235)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 235)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 235)										int ii_min10 = min5;
HXDLIN( 235)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 235)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 235)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 235)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 235)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 235)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 235)								if ((cy > by1)) {
HXDLIN( 235)									if ((cy > cy2)) {
HXDLIN( 235)										int min6;
HXDLIN( 235)										if ((by1 > cy2)) {
HXDLIN( 235)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 235)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 235)										int ii_min12 = min6;
HXDLIN( 235)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 235)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 235)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 235)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 235)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 235)									if ((by1 > cy2)) {
HXDLIN( 235)										int min7;
HXDLIN( 235)										if ((cy > cy2)) {
HXDLIN( 235)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 235)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 235)										int ii_min14 = min7;
HXDLIN( 235)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 235)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 235)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 235)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 235)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 235)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 235)								if (hasUndo1) {
HXDLIN( 235)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 235)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 235)									 ::Dynamic imageType1 = null();
HXDLIN( 235)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 235)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 235)									::Dynamic undoImage4;
HXDLIN( 235)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 235)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 235)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 235)											{
HXDLIN( 235)												b5->width = width1;
HXDLIN( 235)												b5->height = height1;
HXDLIN( 235)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 235)												{
HXDLIN( 235)													int len2 = b5->length;
HXDLIN( 235)													int w1 = 0;
HXDLIN( 235)													{
HXDLIN( 235)														int _g24 = 0;
HXDLIN( 235)														int _g25 = b5->height;
HXDLIN( 235)														while((_g24 < _g25)){
HXDLIN( 235)															_g24 = (_g24 + 1);
HXDLIN( 235)															int y4 = (_g24 - 1);
HXDLIN( 235)															{
HXDLIN( 235)																int _g26 = 0;
HXDLIN( 235)																int _g27 = b5->width;
HXDLIN( 235)																while((_g26 < _g27)){
HXDLIN( 235)																	_g26 = (_g26 + 1);
HXDLIN( 235)																	int x4 = (_g26 - 1);
HXDLIN( 235)																	{
HXDLIN( 235)																		w1 = (w1 + 1);
HXDLIN( 235)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 235)																	{
HXDLIN( 235)																		w1 = (w1 + 1);
HXDLIN( 235)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 235)																	{
HXDLIN( 235)																		w1 = (w1 + 1);
HXDLIN( 235)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 235)																	{
HXDLIN( 235)																		w1 = (w1 + 1);
HXDLIN( 235)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 235)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 235)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 235)											{
HXDLIN( 235)												a6->width = width1;
HXDLIN( 235)												a6->height = height1;
HXDLIN( 235)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 235)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)												{
HXDLIN( 235)													int _g28 = 0;
HXDLIN( 235)													int _g29 = a6->length;
HXDLIN( 235)													while((_g28 < _g29)){
HXDLIN( 235)														_g28 = (_g28 + 1);
HXDLIN( 235)														int i8 = (_g28 - 1);
HXDLIN( 235)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 235)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 235)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 235)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 235)											{
HXDLIN( 235)												b6->width = width1;
HXDLIN( 235)												b6->height = height1;
HXDLIN( 235)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)												int size1 = (b6->length * 4);
HXDLIN( 235)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 235)												{
HXDLIN( 235)													int _g30 = 0;
HXDLIN( 235)													int _g31 = b6->length;
HXDLIN( 235)													while((_g30 < _g31)){
HXDLIN( 235)														_g30 = (_g30 + 1);
HXDLIN( 235)														int i9 = (_g30 - 1);
HXDLIN( 235)														{
HXDLIN( 235)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 235)															bool undoImage5;
HXDLIN( 235)															if ((i9 >= 0)) {
HXDLIN( 235)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 235)																undoImage5 = false;
            															}
HXDLIN( 235)															if (undoImage5) {
HXDLIN( 235)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 235)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 235)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 235)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 235)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 235)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 235)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 235)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 235)											{
HXDLIN( 235)												v4->width = width1;
HXDLIN( 235)												v4->height = height1;
HXDLIN( 235)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 235)												{
HXDLIN( 235)													int _g32 = 0;
HXDLIN( 235)													int _g33 = v4->length;
HXDLIN( 235)													while((_g32 < _g33)){
HXDLIN( 235)														_g32 = (_g32 + 1);
HXDLIN( 235)														int i10 = (_g32 - 1);
HXDLIN( 235)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 235)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 235)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 235)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 235)											{
HXDLIN( 235)												b7->width = width1;
HXDLIN( 235)												b7->height = height1;
HXDLIN( 235)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 235)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 235)												{
HXDLIN( 235)													int len3 = b7->length;
HXDLIN( 235)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 235)													if (::hx::IsNull( d1->head )) {
HXDLIN( 235)														int _g34 = 0;
HXDLIN( 235)														int _g35 = len3;
HXDLIN( 235)														while((_g34 < _g35)){
HXDLIN( 235)															_g34 = (_g34 + 1);
HXDLIN( 235)															int i11 = (_g34 - 1);
HXDLIN( 235)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 235)														int _g36 = 0;
HXDLIN( 235)														int _g37 = len3;
HXDLIN( 235)														while((_g36 < _g37)){
HXDLIN( 235)															_g36 = (_g36 + 1);
HXDLIN( 235)															int i12 = (_g36 - 1);
HXDLIN( 235)															{
HXDLIN( 235)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 235)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 235)																{
HXDLIN( 235)																	int _g38 = 0;
HXDLIN( 235)																	int _g39 = i12;
HXDLIN( 235)																	while((_g38 < _g39)){
HXDLIN( 235)																		_g38 = (_g38 + 1);
HXDLIN( 235)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 235)																if (::hx::IsNull( prev1 )) {
HXDLIN( 235)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 235)																	l1 = null();
            																}
            																else {
HXDLIN( 235)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 235)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 235)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 235)									this37->image = undoImage4;
HXDLIN( 235)									this37->width = width1;
HXDLIN( 235)									this37->height = height1;
HXDLIN( 235)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 235)									undoImage3 = this37;
HXDLIN( 235)									{
HXDLIN( 235)										int rectLeft1 = xIter31->start;
HXDLIN( 235)										int rectTop1 = yIter31->start;
HXDLIN( 235)										int rectRight1 = xIter31->max;
HXDLIN( 235)										bool forceClear1 = false;
HXDLIN( 235)										{
HXDLIN( 235)											int _g40 = rectTop1;
HXDLIN( 235)											int _g41 = yIter31->max;
HXDLIN( 235)											while((_g40 < _g41)){
HXDLIN( 235)												_g40 = (_g40 + 1);
HXDLIN( 235)												int dy1 = (_g40 - 1);
HXDLIN( 235)												{
HXDLIN( 235)													int _g42 = rectLeft1;
HXDLIN( 235)													int _g43 = rectRight1;
HXDLIN( 235)													while((_g42 < _g43)){
HXDLIN( 235)														_g42 = (_g42 + 1);
HXDLIN( 235)														int dx1 = (_g42 - 1);
HXDLIN( 235)														::Dynamic this39 = this36->image;
HXDLIN( 235)														int index5;
HXDLIN( 235)														if (this36->useVirtualPos) {
HXDLIN( 235)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 235)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 235)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 235)														int col1;
HXDLIN( 235)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 235)															col1 = c4;
            														}
HXDLIN( 235)														bool _hx_tmp8;
HXDLIN( 235)														if (this36->useMask) {
HXDLIN( 235)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 235)															_hx_tmp8 = false;
            														}
HXDLIN( 235)														if (_hx_tmp8) {
HXDLIN( 235)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 235)															::Dynamic this41 = this40->image;
HXDLIN( 235)															int index6;
HXDLIN( 235)															if (this40->useVirtualPos) {
HXDLIN( 235)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 235)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 235)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 235)															int v5;
HXDLIN( 235)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 235)																v5 = c5;
            															}
HXDLIN( 235)															int maskPixel1 = v5;
HXDLIN( 235)															int this42 = col1;
HXDLIN( 235)															if ((maskPixel1 == 0)) {
HXDLIN( 235)																col1 = this42;
            															}
            															else {
HXDLIN( 235)																Float m01;
HXDLIN( 235)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 235)																if ((this43 == 0)) {
HXDLIN( 235)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float m11;
HXDLIN( 235)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 235)																if ((this44 == 0)) {
HXDLIN( 235)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float m21;
HXDLIN( 235)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 235)																if ((this45 == 0)) {
HXDLIN( 235)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float m31;
HXDLIN( 235)																int this46 = (maskPixel1 & 255);
HXDLIN( 235)																if ((this46 == 0)) {
HXDLIN( 235)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 235)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 235)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 235)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 235)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 235)														if ((col1 != 0)) {
HXDLIN( 235)															int x5 = (dx1 - rectLeft1);
HXDLIN( 235)															int y5 = (dy1 - rectTop1);
HXDLIN( 235)															int c6 = col1;
HXDLIN( 235)															bool _hx_tmp9;
HXDLIN( 235)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 235)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 235)																_hx_tmp9 = false;
            															}
HXDLIN( 235)															if (_hx_tmp9) {
HXDLIN( 235)																int location2;
HXDLIN( 235)																if (undoImage3->useVirtualPos) {
HXDLIN( 235)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 235)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 235)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 235)																int this48;
HXDLIN( 235)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 235)																	this48 = this47;
            																}
HXDLIN( 235)																Float a12;
HXDLIN( 235)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 235)																if ((this49 == 0)) {
HXDLIN( 235)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float r12;
HXDLIN( 235)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 235)																if ((this50 == 0)) {
HXDLIN( 235)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float g12;
HXDLIN( 235)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 235)																if ((this51 == 0)) {
HXDLIN( 235)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float b13;
HXDLIN( 235)																int this52 = (this48 & 255);
HXDLIN( 235)																if ((this52 == 0)) {
HXDLIN( 235)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float a22;
HXDLIN( 235)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 235)																if ((this53 == 0)) {
HXDLIN( 235)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float r22;
HXDLIN( 235)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 235)																if ((this54 == 0)) {
HXDLIN( 235)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float g22;
HXDLIN( 235)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 235)																if ((this55 == 0)) {
HXDLIN( 235)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float b23;
HXDLIN( 235)																int this56 = (col1 & 255);
HXDLIN( 235)																if ((this56 == 0)) {
HXDLIN( 235)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 235)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 235)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 235)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 235)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 235)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 235)																{
HXDLIN( 235)																	int _hx_tmp10;
HXDLIN( 235)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 235)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 235)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 235)																::Dynamic this57 = undoImage3->image;
HXDLIN( 235)																int index7;
HXDLIN( 235)																if (undoImage3->useVirtualPos) {
HXDLIN( 235)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 235)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 235)																int _hx_tmp11;
HXDLIN( 235)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 235)																	_hx_tmp11 = c6;
            																}
HXDLIN( 235)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 235)															if (forceClear1) {
HXDLIN( 235)																::Dynamic this58 = undoImage3->image;
HXDLIN( 235)																int x6 = (dx1 - rectLeft1);
HXDLIN( 235)																int y6 = (dy1 - rectTop1);
HXDLIN( 235)																int index8;
HXDLIN( 235)																if (undoImage3->useVirtualPos) {
HXDLIN( 235)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 235)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 235)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 235)								bool found1 = false;
HXDLIN( 235)								Float s1 = ((Float)0.);
HXDLIN( 235)								Float t1 = ((Float)0.);
HXDLIN( 235)								Float sxx1 = ((Float)0.);
HXDLIN( 235)								Float txx1 = ((Float)0.);
HXDLIN( 235)								{
HXDLIN( 235)									int _g_min2 = xIter31->start;
HXDLIN( 235)									int _g_max2 = xIter31->max;
HXDLIN( 235)									while((_g_min2 < _g_max2)){
HXDLIN( 235)										_g_min2 = (_g_min2 + 1);
HXDLIN( 235)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 235)										{
HXDLIN( 235)											int _g_min3 = yIter31->start;
HXDLIN( 235)											int _g_max3 = yIter31->max;
HXDLIN( 235)											while((_g_min3 < _g_max3)){
HXDLIN( 235)												_g_min3 = (_g_min3 + 1);
HXDLIN( 235)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 235)												bool _hx_tmp12;
HXDLIN( 235)												if (!((s1 <= 0))) {
HXDLIN( 235)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 235)													_hx_tmp12 = true;
            												}
HXDLIN( 235)												if (_hx_tmp12) {
HXDLIN( 235)													if (found1) {
HXDLIN( 235)														goto _hx_goto_455;
            													}
            												}
            												else {
HXDLIN( 235)													if (((s1 + t1) < A1)) {
HXDLIN( 235)														{
HXDLIN( 235)															int c7 = color;
HXDLIN( 235)															bool _hx_tmp13;
HXDLIN( 235)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 235)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 235)																_hx_tmp13 = false;
            															}
HXDLIN( 235)															if (_hx_tmp13) {
HXDLIN( 235)																int location3;
HXDLIN( 235)																if (this36->useVirtualPos) {
HXDLIN( 235)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 235)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 235)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 235)																int this60;
HXDLIN( 235)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 235)																	this60 = this59;
            																}
HXDLIN( 235)																Float a13;
HXDLIN( 235)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 235)																if ((this61 == 0)) {
HXDLIN( 235)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float r13;
HXDLIN( 235)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 235)																if ((this62 == 0)) {
HXDLIN( 235)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float g13;
HXDLIN( 235)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 235)																if ((this63 == 0)) {
HXDLIN( 235)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float b14;
HXDLIN( 235)																int this64 = (this60 & 255);
HXDLIN( 235)																if ((this64 == 0)) {
HXDLIN( 235)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float a23;
HXDLIN( 235)																int this65 = ((color >> 24) & 255);
HXDLIN( 235)																if ((this65 == 0)) {
HXDLIN( 235)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float r23;
HXDLIN( 235)																int this66 = ((color >> 16) & 255);
HXDLIN( 235)																if ((this66 == 0)) {
HXDLIN( 235)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float g23;
HXDLIN( 235)																int this67 = ((color >> 8) & 255);
HXDLIN( 235)																if ((this67 == 0)) {
HXDLIN( 235)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float b24;
HXDLIN( 235)																int this68 = (color & 255);
HXDLIN( 235)																if ((this68 == 0)) {
HXDLIN( 235)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 235)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 235)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 235)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 235)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 235)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 235)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 235)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 235)																{
HXDLIN( 235)																	int _hx_tmp14;
HXDLIN( 235)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 235)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 235)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 235)																::Dynamic this69 = this36->image;
HXDLIN( 235)																int index9;
HXDLIN( 235)																if (this36->useVirtualPos) {
HXDLIN( 235)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 235)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 235)																int _hx_tmp15;
HXDLIN( 235)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 235)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 235)																	_hx_tmp15 = c7;
            																}
HXDLIN( 235)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 235)														if (found1) {
HXDLIN( 235)															goto _hx_goto_455;
            														}
            													}
            												}
            											}
            											_hx_goto_455:;
            										}
            									}
            								}
HXDLIN( 235)								if ((hasHit1 == true)) {
HXDLIN( 235)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 235)									if (hasUndo1) {
HXDLIN( 235)										v6->undoImage = undoImage3;
HXDLIN( 235)										v6->undoX = xIter31->start;
HXDLIN( 235)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,pentagon,(void))

void FillShape_Impl__obj::hexagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_248_hexagon)
HXDLIN( 248)		 ::Dynamic phi1 = phi;
HXDLIN( 248)		 ::Dynamic sides = 6;
HXLINE( 252)		if (::hx::IsNull( sides )) {
HXLINE( 252)			sides = 36;
            		}
HXLINE( 251)		if (::hx::IsNull( phi1 )) {
HXLINE( 251)			phi1 = ((Float)0.);
            		}
HXLINE( 248)		{
HXDLIN( 248)			 ::Dynamic phi2 = phi1;
HXDLIN( 248)			 ::Dynamic sides1 = sides;
HXDLIN( 248)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 248)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 248)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 248)			Float omega;
HXDLIN( 248)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 248)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 248)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 248)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 248)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 248)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 248)			Float lastX = ((Float)0.);
HXDLIN( 248)			Float lastY = ((Float)0.);
HXDLIN( 248)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 248)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 248)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 248)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 248)				{
HXDLIN( 248)					int _g = 0;
HXDLIN( 248)					int _g1 = (sides1 + 1);
HXDLIN( 248)					while((_g < _g1)){
HXDLIN( 248)						_g = (_g + 1);
HXDLIN( 248)						int i = (_g - 1);
HXDLIN( 248)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 248)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 248)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 248)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 248)						{
HXDLIN( 248)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 248)							bool hasHit = false;
HXDLIN( 248)							bool hasUndo = false;
HXDLIN( 248)							{
HXDLIN( 248)								Float bx = lastX;
HXDLIN( 248)								Float by = lastY;
HXDLIN( 248)								Float cx1 = nextX;
HXDLIN( 248)								Float cy1 = nextY;
HXDLIN( 248)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 248)								if (!(adjustWinding)) {
HXDLIN( 248)									Float bx_ = bx;
HXDLIN( 248)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 248)								{
HXDLIN( 248)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 248)									Float sx = (cy1 - cy);
HXDLIN( 248)									Float sy = (cx - cx1);
HXDLIN( 248)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 248)									Float tx = (cy - by);
HXDLIN( 248)									Float ty = (bx - cx);
HXDLIN( 248)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 248)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 248)									if ((cx > bx)) {
HXDLIN( 248)										if ((cx > cx1)) {
HXDLIN( 248)											int min;
HXDLIN( 248)											if ((bx > cx1)) {
HXDLIN( 248)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 248)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 248)											int ii_min = min;
HXDLIN( 248)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 248)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 248)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 248)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 248)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 248)										if ((bx > cx1)) {
HXDLIN( 248)											int min1;
HXDLIN( 248)											if ((cx > cx1)) {
HXDLIN( 248)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 248)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 248)											int ii_min2 = min1;
HXDLIN( 248)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 248)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 248)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 248)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 248)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 248)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 248)									if ((cy > by)) {
HXDLIN( 248)										if ((cy > cy1)) {
HXDLIN( 248)											int min2;
HXDLIN( 248)											if ((by > cy1)) {
HXDLIN( 248)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 248)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 248)											int ii_min4 = min2;
HXDLIN( 248)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 248)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 248)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 248)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 248)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 248)										if ((by > cy1)) {
HXDLIN( 248)											int min3;
HXDLIN( 248)											if ((cy > cy1)) {
HXDLIN( 248)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 248)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 248)											int ii_min6 = min3;
HXDLIN( 248)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 248)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 248)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 248)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 248)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 248)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 248)									if (hasUndo) {
HXDLIN( 248)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 248)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 248)										 ::Dynamic imageType = null();
HXDLIN( 248)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 248)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 248)										::Dynamic undoImage1;
HXDLIN( 248)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 248)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 248)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 248)												{
HXDLIN( 248)													b->width = width;
HXDLIN( 248)													b->height = height;
HXDLIN( 248)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 248)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 248)													{
HXDLIN( 248)														int len = b->length;
HXDLIN( 248)														int w = 0;
HXDLIN( 248)														{
HXDLIN( 248)															int _g2 = 0;
HXDLIN( 248)															int _g3 = b->height;
HXDLIN( 248)															while((_g2 < _g3)){
HXDLIN( 248)																_g2 = (_g2 + 1);
HXDLIN( 248)																int y = (_g2 - 1);
HXDLIN( 248)																{
HXDLIN( 248)																	int _g4 = 0;
HXDLIN( 248)																	int _g5 = b->width;
HXDLIN( 248)																	while((_g4 < _g5)){
HXDLIN( 248)																		_g4 = (_g4 + 1);
HXDLIN( 248)																		int x = (_g4 - 1);
HXDLIN( 248)																		{
HXDLIN( 248)																			w = (w + 1);
HXDLIN( 248)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 248)																		{
HXDLIN( 248)																			w = (w + 1);
HXDLIN( 248)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 248)																		{
HXDLIN( 248)																			w = (w + 1);
HXDLIN( 248)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 248)																		{
HXDLIN( 248)																			w = (w + 1);
HXDLIN( 248)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 248)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 248)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 248)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 248)												{
HXDLIN( 248)													a->width = width;
HXDLIN( 248)													a->height = height;
HXDLIN( 248)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 248)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 248)													{
HXDLIN( 248)														int _g6 = 0;
HXDLIN( 248)														int _g7 = a->length;
HXDLIN( 248)														while((_g6 < _g7)){
HXDLIN( 248)															_g6 = (_g6 + 1);
HXDLIN( 248)															int i1 = (_g6 - 1);
HXDLIN( 248)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 248)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 248)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 248)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 248)												{
HXDLIN( 248)													b1->width = width;
HXDLIN( 248)													b1->height = height;
HXDLIN( 248)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 248)													int size = (b1->length * 4);
HXDLIN( 248)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 248)													{
HXDLIN( 248)														int _g8 = 0;
HXDLIN( 248)														int _g9 = b1->length;
HXDLIN( 248)														while((_g8 < _g9)){
HXDLIN( 248)															_g8 = (_g8 + 1);
HXDLIN( 248)															int i2 = (_g8 - 1);
HXDLIN( 248)															{
HXDLIN( 248)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 248)																bool undoImage2;
HXDLIN( 248)																if ((i2 >= 0)) {
HXDLIN( 248)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 248)																	undoImage2 = false;
            																}
HXDLIN( 248)																if (undoImage2) {
HXDLIN( 248)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 248)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 248)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 248)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 248)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 248)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 248)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 248)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 248)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 248)												{
HXDLIN( 248)													v1->width = width;
HXDLIN( 248)													v1->height = height;
HXDLIN( 248)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 248)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 248)													{
HXDLIN( 248)														int _g10 = 0;
HXDLIN( 248)														int _g11 = v1->length;
HXDLIN( 248)														while((_g10 < _g11)){
HXDLIN( 248)															_g10 = (_g10 + 1);
HXDLIN( 248)															int i3 = (_g10 - 1);
HXDLIN( 248)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 248)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 248)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 248)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 248)												{
HXDLIN( 248)													b2->width = width;
HXDLIN( 248)													b2->height = height;
HXDLIN( 248)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 248)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 248)													{
HXDLIN( 248)														int len1 = b2->length;
HXDLIN( 248)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 248)														if (::hx::IsNull( d->head )) {
HXDLIN( 248)															int _g12 = 0;
HXDLIN( 248)															int _g13 = len1;
HXDLIN( 248)															while((_g12 < _g13)){
HXDLIN( 248)																_g12 = (_g12 + 1);
HXDLIN( 248)																int i4 = (_g12 - 1);
HXDLIN( 248)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 248)															int _g14 = 0;
HXDLIN( 248)															int _g15 = len1;
HXDLIN( 248)															while((_g14 < _g15)){
HXDLIN( 248)																_g14 = (_g14 + 1);
HXDLIN( 248)																int i5 = (_g14 - 1);
HXDLIN( 248)																{
HXDLIN( 248)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 248)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 248)																	{
HXDLIN( 248)																		int _g16 = 0;
HXDLIN( 248)																		int _g17 = i5;
HXDLIN( 248)																		while((_g16 < _g17)){
HXDLIN( 248)																			_g16 = (_g16 + 1);
HXDLIN( 248)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 248)																	if (::hx::IsNull( prev )) {
HXDLIN( 248)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 248)																		l = null();
            																	}
            																	else {
HXDLIN( 248)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 248)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 248)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 248)										this3->image = undoImage1;
HXDLIN( 248)										this3->width = width;
HXDLIN( 248)										this3->height = height;
HXDLIN( 248)										this3->imageType = ( (int)(imageType) );
HXDLIN( 248)										undoImage = this3;
HXDLIN( 248)										{
HXDLIN( 248)											int rectLeft = xIter3->start;
HXDLIN( 248)											int rectTop = yIter3->start;
HXDLIN( 248)											int rectRight = xIter3->max;
HXDLIN( 248)											bool forceClear = false;
HXDLIN( 248)											{
HXDLIN( 248)												int _g18 = rectTop;
HXDLIN( 248)												int _g19 = yIter3->max;
HXDLIN( 248)												while((_g18 < _g19)){
HXDLIN( 248)													_g18 = (_g18 + 1);
HXDLIN( 248)													int dy = (_g18 - 1);
HXDLIN( 248)													{
HXDLIN( 248)														int _g20 = rectLeft;
HXDLIN( 248)														int _g21 = rectRight;
HXDLIN( 248)														while((_g20 < _g21)){
HXDLIN( 248)															_g20 = (_g20 + 1);
HXDLIN( 248)															int dx = (_g20 - 1);
HXDLIN( 248)															::Dynamic this5 = this2->image;
HXDLIN( 248)															int index;
HXDLIN( 248)															if (this2->useVirtualPos) {
HXDLIN( 248)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 248)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 248)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 248)															int col;
HXDLIN( 248)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 248)																col = c;
            															}
HXDLIN( 248)															bool _hx_tmp;
HXDLIN( 248)															if (this2->useMask) {
HXDLIN( 248)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 248)																_hx_tmp = false;
            															}
HXDLIN( 248)															if (_hx_tmp) {
HXDLIN( 248)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 248)																::Dynamic this7 = this6->image;
HXDLIN( 248)																int index1;
HXDLIN( 248)																if (this6->useVirtualPos) {
HXDLIN( 248)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 248)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 248)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 248)																int v2;
HXDLIN( 248)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 248)																	v2 = c1;
            																}
HXDLIN( 248)																int maskPixel = v2;
HXDLIN( 248)																int this8 = col;
HXDLIN( 248)																if ((maskPixel == 0)) {
HXDLIN( 248)																	col = this8;
            																}
            																else {
HXDLIN( 248)																	Float m0;
HXDLIN( 248)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 248)																	if ((this9 == 0)) {
HXDLIN( 248)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float m1;
HXDLIN( 248)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 248)																	if ((this10 == 0)) {
HXDLIN( 248)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float m2;
HXDLIN( 248)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 248)																	if ((this11 == 0)) {
HXDLIN( 248)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float m3;
HXDLIN( 248)																	int this12 = (maskPixel & 255);
HXDLIN( 248)																	if ((this12 == 0)) {
HXDLIN( 248)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 248)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 248)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 248)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 248)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 248)															if ((col != 0)) {
HXDLIN( 248)																int x1 = (dx - rectLeft);
HXDLIN( 248)																int y1 = (dy - rectTop);
HXDLIN( 248)																int c2 = col;
HXDLIN( 248)																bool _hx_tmp1;
HXDLIN( 248)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 248)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 248)																	_hx_tmp1 = false;
            																}
HXDLIN( 248)																if (_hx_tmp1) {
HXDLIN( 248)																	int location;
HXDLIN( 248)																	if (undoImage->useVirtualPos) {
HXDLIN( 248)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 248)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 248)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 248)																	int this14;
HXDLIN( 248)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 248)																		this14 = this13;
            																	}
HXDLIN( 248)																	Float a1;
HXDLIN( 248)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 248)																	if ((this15 == 0)) {
HXDLIN( 248)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float r1;
HXDLIN( 248)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 248)																	if ((this16 == 0)) {
HXDLIN( 248)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float g1;
HXDLIN( 248)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 248)																	if ((this17 == 0)) {
HXDLIN( 248)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float b11;
HXDLIN( 248)																	int this18 = (this14 & 255);
HXDLIN( 248)																	if ((this18 == 0)) {
HXDLIN( 248)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float a2;
HXDLIN( 248)																	int this19 = ((col >> 24) & 255);
HXDLIN( 248)																	if ((this19 == 0)) {
HXDLIN( 248)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float r2;
HXDLIN( 248)																	int this20 = ((col >> 16) & 255);
HXDLIN( 248)																	if ((this20 == 0)) {
HXDLIN( 248)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float g2;
HXDLIN( 248)																	int this21 = ((col >> 8) & 255);
HXDLIN( 248)																	if ((this21 == 0)) {
HXDLIN( 248)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float b21;
HXDLIN( 248)																	int this22 = (col & 255);
HXDLIN( 248)																	if ((this22 == 0)) {
HXDLIN( 248)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 248)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 248)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 248)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 248)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 248)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 248)																	{
HXDLIN( 248)																		int _hx_tmp2;
HXDLIN( 248)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 248)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 248)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 248)																	::Dynamic this23 = undoImage->image;
HXDLIN( 248)																	int index2;
HXDLIN( 248)																	if (undoImage->useVirtualPos) {
HXDLIN( 248)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 248)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 248)																	int _hx_tmp3;
HXDLIN( 248)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 248)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 248)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 248)																if (forceClear) {
HXDLIN( 248)																	::Dynamic this24 = undoImage->image;
HXDLIN( 248)																	int x2 = (dx - rectLeft);
HXDLIN( 248)																	int y2 = (dy - rectTop);
HXDLIN( 248)																	int index3;
HXDLIN( 248)																	if (undoImage->useVirtualPos) {
HXDLIN( 248)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 248)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 248)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 248)									bool found = false;
HXDLIN( 248)									Float s = ((Float)0.);
HXDLIN( 248)									Float t = ((Float)0.);
HXDLIN( 248)									Float sxx = ((Float)0.);
HXDLIN( 248)									Float txx = ((Float)0.);
HXDLIN( 248)									{
HXDLIN( 248)										int _g_min = xIter3->start;
HXDLIN( 248)										int _g_max = xIter3->max;
HXDLIN( 248)										while((_g_min < _g_max)){
HXDLIN( 248)											_g_min = (_g_min + 1);
HXDLIN( 248)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 248)											{
HXDLIN( 248)												int _g_min1 = yIter3->start;
HXDLIN( 248)												int _g_max1 = yIter3->max;
HXDLIN( 248)												while((_g_min1 < _g_max1)){
HXDLIN( 248)													_g_min1 = (_g_min1 + 1);
HXDLIN( 248)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 248)													bool _hx_tmp4;
HXDLIN( 248)													if (!((s <= 0))) {
HXDLIN( 248)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 248)														_hx_tmp4 = true;
            													}
HXDLIN( 248)													if (_hx_tmp4) {
HXDLIN( 248)														if (found) {
HXDLIN( 248)															goto _hx_goto_469;
            														}
            													}
            													else {
HXDLIN( 248)														if (((s + t) < A)) {
HXDLIN( 248)															{
HXDLIN( 248)																int c3 = color;
HXDLIN( 248)																bool _hx_tmp5;
HXDLIN( 248)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 248)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 248)																	_hx_tmp5 = false;
            																}
HXDLIN( 248)																if (_hx_tmp5) {
HXDLIN( 248)																	int location1;
HXDLIN( 248)																	if (this2->useVirtualPos) {
HXDLIN( 248)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 248)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 248)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 248)																	int this26;
HXDLIN( 248)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 248)																		this26 = this25;
            																	}
HXDLIN( 248)																	Float a11;
HXDLIN( 248)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 248)																	if ((this27 == 0)) {
HXDLIN( 248)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float r11;
HXDLIN( 248)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 248)																	if ((this28 == 0)) {
HXDLIN( 248)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float g11;
HXDLIN( 248)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 248)																	if ((this29 == 0)) {
HXDLIN( 248)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float b12;
HXDLIN( 248)																	int this30 = (this26 & 255);
HXDLIN( 248)																	if ((this30 == 0)) {
HXDLIN( 248)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float a21;
HXDLIN( 248)																	int this31 = ((color >> 24) & 255);
HXDLIN( 248)																	if ((this31 == 0)) {
HXDLIN( 248)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float r21;
HXDLIN( 248)																	int this32 = ((color >> 16) & 255);
HXDLIN( 248)																	if ((this32 == 0)) {
HXDLIN( 248)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float g21;
HXDLIN( 248)																	int this33 = ((color >> 8) & 255);
HXDLIN( 248)																	if ((this33 == 0)) {
HXDLIN( 248)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float b22;
HXDLIN( 248)																	int this34 = (color & 255);
HXDLIN( 248)																	if ((this34 == 0)) {
HXDLIN( 248)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 248)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 248)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 248)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 248)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 248)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 248)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 248)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 248)																	{
HXDLIN( 248)																		int _hx_tmp6;
HXDLIN( 248)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 248)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 248)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 248)																	::Dynamic this35 = this2->image;
HXDLIN( 248)																	int index4;
HXDLIN( 248)																	if (this2->useVirtualPos) {
HXDLIN( 248)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 248)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 248)																	int _hx_tmp7;
HXDLIN( 248)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 248)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 248)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 248)															if (found) {
HXDLIN( 248)																goto _hx_goto_469;
            															}
            														}
            													}
            												}
            												_hx_goto_469:;
            											}
            										}
            									}
HXDLIN( 248)									if ((hasHit == true)) {
HXDLIN( 248)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 248)										if (hasUndo) {
HXDLIN( 248)											v3->undoImage = undoImage;
HXDLIN( 248)											v3->undoX = xIter3->start;
HXDLIN( 248)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 248)				int _g22 = 0;
HXDLIN( 248)				int _g23 = (sides1 + 1);
HXDLIN( 248)				while((_g22 < _g23)){
HXDLIN( 248)					_g22 = (_g22 + 1);
HXDLIN( 248)					int i7 = (_g22 - 1);
HXDLIN( 248)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 248)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 248)					{
HXDLIN( 248)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 248)						bool hasHit1 = false;
HXDLIN( 248)						bool hasUndo1 = false;
HXDLIN( 248)						{
HXDLIN( 248)							Float bx1 = lastX;
HXDLIN( 248)							Float by1 = lastY;
HXDLIN( 248)							Float cx2 = nextX1;
HXDLIN( 248)							Float cy2 = nextY1;
HXDLIN( 248)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 248)							if (!(adjustWinding1)) {
HXDLIN( 248)								Float bx_1 = bx1;
HXDLIN( 248)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 248)							{
HXDLIN( 248)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 248)								Float sx1 = (cy2 - cy);
HXDLIN( 248)								Float sy1 = (cx - cx2);
HXDLIN( 248)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 248)								Float tx1 = (cy - by1);
HXDLIN( 248)								Float ty1 = (bx1 - cx);
HXDLIN( 248)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 248)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 248)								if ((cx > bx1)) {
HXDLIN( 248)									if ((cx > cx2)) {
HXDLIN( 248)										int min4;
HXDLIN( 248)										if ((bx1 > cx2)) {
HXDLIN( 248)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 248)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 248)										int ii_min8 = min4;
HXDLIN( 248)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 248)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 248)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 248)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 248)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 248)									if ((bx1 > cx2)) {
HXDLIN( 248)										int min5;
HXDLIN( 248)										if ((cx > cx2)) {
HXDLIN( 248)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 248)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 248)										int ii_min10 = min5;
HXDLIN( 248)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 248)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 248)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 248)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 248)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 248)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 248)								if ((cy > by1)) {
HXDLIN( 248)									if ((cy > cy2)) {
HXDLIN( 248)										int min6;
HXDLIN( 248)										if ((by1 > cy2)) {
HXDLIN( 248)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 248)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 248)										int ii_min12 = min6;
HXDLIN( 248)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 248)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 248)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 248)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 248)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 248)									if ((by1 > cy2)) {
HXDLIN( 248)										int min7;
HXDLIN( 248)										if ((cy > cy2)) {
HXDLIN( 248)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 248)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 248)										int ii_min14 = min7;
HXDLIN( 248)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 248)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 248)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 248)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 248)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 248)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 248)								if (hasUndo1) {
HXDLIN( 248)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 248)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 248)									 ::Dynamic imageType1 = null();
HXDLIN( 248)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 248)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 248)									::Dynamic undoImage4;
HXDLIN( 248)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 248)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 248)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 248)											{
HXDLIN( 248)												b5->width = width1;
HXDLIN( 248)												b5->height = height1;
HXDLIN( 248)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 248)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 248)												{
HXDLIN( 248)													int len2 = b5->length;
HXDLIN( 248)													int w1 = 0;
HXDLIN( 248)													{
HXDLIN( 248)														int _g24 = 0;
HXDLIN( 248)														int _g25 = b5->height;
HXDLIN( 248)														while((_g24 < _g25)){
HXDLIN( 248)															_g24 = (_g24 + 1);
HXDLIN( 248)															int y4 = (_g24 - 1);
HXDLIN( 248)															{
HXDLIN( 248)																int _g26 = 0;
HXDLIN( 248)																int _g27 = b5->width;
HXDLIN( 248)																while((_g26 < _g27)){
HXDLIN( 248)																	_g26 = (_g26 + 1);
HXDLIN( 248)																	int x4 = (_g26 - 1);
HXDLIN( 248)																	{
HXDLIN( 248)																		w1 = (w1 + 1);
HXDLIN( 248)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 248)																	{
HXDLIN( 248)																		w1 = (w1 + 1);
HXDLIN( 248)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 248)																	{
HXDLIN( 248)																		w1 = (w1 + 1);
HXDLIN( 248)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 248)																	{
HXDLIN( 248)																		w1 = (w1 + 1);
HXDLIN( 248)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 248)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 248)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 248)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 248)											{
HXDLIN( 248)												a6->width = width1;
HXDLIN( 248)												a6->height = height1;
HXDLIN( 248)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 248)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 248)												{
HXDLIN( 248)													int _g28 = 0;
HXDLIN( 248)													int _g29 = a6->length;
HXDLIN( 248)													while((_g28 < _g29)){
HXDLIN( 248)														_g28 = (_g28 + 1);
HXDLIN( 248)														int i8 = (_g28 - 1);
HXDLIN( 248)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 248)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 248)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 248)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 248)											{
HXDLIN( 248)												b6->width = width1;
HXDLIN( 248)												b6->height = height1;
HXDLIN( 248)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 248)												int size1 = (b6->length * 4);
HXDLIN( 248)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 248)												{
HXDLIN( 248)													int _g30 = 0;
HXDLIN( 248)													int _g31 = b6->length;
HXDLIN( 248)													while((_g30 < _g31)){
HXDLIN( 248)														_g30 = (_g30 + 1);
HXDLIN( 248)														int i9 = (_g30 - 1);
HXDLIN( 248)														{
HXDLIN( 248)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 248)															bool undoImage5;
HXDLIN( 248)															if ((i9 >= 0)) {
HXDLIN( 248)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 248)																undoImage5 = false;
            															}
HXDLIN( 248)															if (undoImage5) {
HXDLIN( 248)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 248)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 248)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 248)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 248)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 248)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 248)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 248)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 248)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 248)											{
HXDLIN( 248)												v4->width = width1;
HXDLIN( 248)												v4->height = height1;
HXDLIN( 248)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 248)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 248)												{
HXDLIN( 248)													int _g32 = 0;
HXDLIN( 248)													int _g33 = v4->length;
HXDLIN( 248)													while((_g32 < _g33)){
HXDLIN( 248)														_g32 = (_g32 + 1);
HXDLIN( 248)														int i10 = (_g32 - 1);
HXDLIN( 248)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 248)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 248)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 248)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 248)											{
HXDLIN( 248)												b7->width = width1;
HXDLIN( 248)												b7->height = height1;
HXDLIN( 248)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 248)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 248)												{
HXDLIN( 248)													int len3 = b7->length;
HXDLIN( 248)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 248)													if (::hx::IsNull( d1->head )) {
HXDLIN( 248)														int _g34 = 0;
HXDLIN( 248)														int _g35 = len3;
HXDLIN( 248)														while((_g34 < _g35)){
HXDLIN( 248)															_g34 = (_g34 + 1);
HXDLIN( 248)															int i11 = (_g34 - 1);
HXDLIN( 248)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 248)														int _g36 = 0;
HXDLIN( 248)														int _g37 = len3;
HXDLIN( 248)														while((_g36 < _g37)){
HXDLIN( 248)															_g36 = (_g36 + 1);
HXDLIN( 248)															int i12 = (_g36 - 1);
HXDLIN( 248)															{
HXDLIN( 248)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 248)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 248)																{
HXDLIN( 248)																	int _g38 = 0;
HXDLIN( 248)																	int _g39 = i12;
HXDLIN( 248)																	while((_g38 < _g39)){
HXDLIN( 248)																		_g38 = (_g38 + 1);
HXDLIN( 248)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 248)																if (::hx::IsNull( prev1 )) {
HXDLIN( 248)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 248)																	l1 = null();
            																}
            																else {
HXDLIN( 248)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 248)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 248)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 248)									this37->image = undoImage4;
HXDLIN( 248)									this37->width = width1;
HXDLIN( 248)									this37->height = height1;
HXDLIN( 248)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 248)									undoImage3 = this37;
HXDLIN( 248)									{
HXDLIN( 248)										int rectLeft1 = xIter31->start;
HXDLIN( 248)										int rectTop1 = yIter31->start;
HXDLIN( 248)										int rectRight1 = xIter31->max;
HXDLIN( 248)										bool forceClear1 = false;
HXDLIN( 248)										{
HXDLIN( 248)											int _g40 = rectTop1;
HXDLIN( 248)											int _g41 = yIter31->max;
HXDLIN( 248)											while((_g40 < _g41)){
HXDLIN( 248)												_g40 = (_g40 + 1);
HXDLIN( 248)												int dy1 = (_g40 - 1);
HXDLIN( 248)												{
HXDLIN( 248)													int _g42 = rectLeft1;
HXDLIN( 248)													int _g43 = rectRight1;
HXDLIN( 248)													while((_g42 < _g43)){
HXDLIN( 248)														_g42 = (_g42 + 1);
HXDLIN( 248)														int dx1 = (_g42 - 1);
HXDLIN( 248)														::Dynamic this39 = this36->image;
HXDLIN( 248)														int index5;
HXDLIN( 248)														if (this36->useVirtualPos) {
HXDLIN( 248)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 248)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 248)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 248)														int col1;
HXDLIN( 248)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 248)															col1 = c4;
            														}
HXDLIN( 248)														bool _hx_tmp8;
HXDLIN( 248)														if (this36->useMask) {
HXDLIN( 248)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 248)															_hx_tmp8 = false;
            														}
HXDLIN( 248)														if (_hx_tmp8) {
HXDLIN( 248)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 248)															::Dynamic this41 = this40->image;
HXDLIN( 248)															int index6;
HXDLIN( 248)															if (this40->useVirtualPos) {
HXDLIN( 248)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 248)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 248)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 248)															int v5;
HXDLIN( 248)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 248)																v5 = c5;
            															}
HXDLIN( 248)															int maskPixel1 = v5;
HXDLIN( 248)															int this42 = col1;
HXDLIN( 248)															if ((maskPixel1 == 0)) {
HXDLIN( 248)																col1 = this42;
            															}
            															else {
HXDLIN( 248)																Float m01;
HXDLIN( 248)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 248)																if ((this43 == 0)) {
HXDLIN( 248)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float m11;
HXDLIN( 248)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 248)																if ((this44 == 0)) {
HXDLIN( 248)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float m21;
HXDLIN( 248)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 248)																if ((this45 == 0)) {
HXDLIN( 248)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float m31;
HXDLIN( 248)																int this46 = (maskPixel1 & 255);
HXDLIN( 248)																if ((this46 == 0)) {
HXDLIN( 248)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 248)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 248)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 248)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 248)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 248)														if ((col1 != 0)) {
HXDLIN( 248)															int x5 = (dx1 - rectLeft1);
HXDLIN( 248)															int y5 = (dy1 - rectTop1);
HXDLIN( 248)															int c6 = col1;
HXDLIN( 248)															bool _hx_tmp9;
HXDLIN( 248)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 248)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 248)																_hx_tmp9 = false;
            															}
HXDLIN( 248)															if (_hx_tmp9) {
HXDLIN( 248)																int location2;
HXDLIN( 248)																if (undoImage3->useVirtualPos) {
HXDLIN( 248)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 248)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 248)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 248)																int this48;
HXDLIN( 248)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 248)																	this48 = this47;
            																}
HXDLIN( 248)																Float a12;
HXDLIN( 248)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 248)																if ((this49 == 0)) {
HXDLIN( 248)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float r12;
HXDLIN( 248)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 248)																if ((this50 == 0)) {
HXDLIN( 248)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float g12;
HXDLIN( 248)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 248)																if ((this51 == 0)) {
HXDLIN( 248)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float b13;
HXDLIN( 248)																int this52 = (this48 & 255);
HXDLIN( 248)																if ((this52 == 0)) {
HXDLIN( 248)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float a22;
HXDLIN( 248)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 248)																if ((this53 == 0)) {
HXDLIN( 248)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float r22;
HXDLIN( 248)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 248)																if ((this54 == 0)) {
HXDLIN( 248)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float g22;
HXDLIN( 248)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 248)																if ((this55 == 0)) {
HXDLIN( 248)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float b23;
HXDLIN( 248)																int this56 = (col1 & 255);
HXDLIN( 248)																if ((this56 == 0)) {
HXDLIN( 248)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 248)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 248)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 248)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 248)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 248)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 248)																{
HXDLIN( 248)																	int _hx_tmp10;
HXDLIN( 248)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 248)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 248)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 248)																::Dynamic this57 = undoImage3->image;
HXDLIN( 248)																int index7;
HXDLIN( 248)																if (undoImage3->useVirtualPos) {
HXDLIN( 248)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 248)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 248)																int _hx_tmp11;
HXDLIN( 248)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 248)																	_hx_tmp11 = c6;
            																}
HXDLIN( 248)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 248)															if (forceClear1) {
HXDLIN( 248)																::Dynamic this58 = undoImage3->image;
HXDLIN( 248)																int x6 = (dx1 - rectLeft1);
HXDLIN( 248)																int y6 = (dy1 - rectTop1);
HXDLIN( 248)																int index8;
HXDLIN( 248)																if (undoImage3->useVirtualPos) {
HXDLIN( 248)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 248)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 248)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 248)								bool found1 = false;
HXDLIN( 248)								Float s1 = ((Float)0.);
HXDLIN( 248)								Float t1 = ((Float)0.);
HXDLIN( 248)								Float sxx1 = ((Float)0.);
HXDLIN( 248)								Float txx1 = ((Float)0.);
HXDLIN( 248)								{
HXDLIN( 248)									int _g_min2 = xIter31->start;
HXDLIN( 248)									int _g_max2 = xIter31->max;
HXDLIN( 248)									while((_g_min2 < _g_max2)){
HXDLIN( 248)										_g_min2 = (_g_min2 + 1);
HXDLIN( 248)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 248)										{
HXDLIN( 248)											int _g_min3 = yIter31->start;
HXDLIN( 248)											int _g_max3 = yIter31->max;
HXDLIN( 248)											while((_g_min3 < _g_max3)){
HXDLIN( 248)												_g_min3 = (_g_min3 + 1);
HXDLIN( 248)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 248)												bool _hx_tmp12;
HXDLIN( 248)												if (!((s1 <= 0))) {
HXDLIN( 248)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 248)													_hx_tmp12 = true;
            												}
HXDLIN( 248)												if (_hx_tmp12) {
HXDLIN( 248)													if (found1) {
HXDLIN( 248)														goto _hx_goto_482;
            													}
            												}
            												else {
HXDLIN( 248)													if (((s1 + t1) < A1)) {
HXDLIN( 248)														{
HXDLIN( 248)															int c7 = color;
HXDLIN( 248)															bool _hx_tmp13;
HXDLIN( 248)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 248)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 248)																_hx_tmp13 = false;
            															}
HXDLIN( 248)															if (_hx_tmp13) {
HXDLIN( 248)																int location3;
HXDLIN( 248)																if (this36->useVirtualPos) {
HXDLIN( 248)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 248)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 248)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 248)																int this60;
HXDLIN( 248)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 248)																	this60 = this59;
            																}
HXDLIN( 248)																Float a13;
HXDLIN( 248)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 248)																if ((this61 == 0)) {
HXDLIN( 248)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float r13;
HXDLIN( 248)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 248)																if ((this62 == 0)) {
HXDLIN( 248)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float g13;
HXDLIN( 248)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 248)																if ((this63 == 0)) {
HXDLIN( 248)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float b14;
HXDLIN( 248)																int this64 = (this60 & 255);
HXDLIN( 248)																if ((this64 == 0)) {
HXDLIN( 248)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float a23;
HXDLIN( 248)																int this65 = ((color >> 24) & 255);
HXDLIN( 248)																if ((this65 == 0)) {
HXDLIN( 248)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float r23;
HXDLIN( 248)																int this66 = ((color >> 16) & 255);
HXDLIN( 248)																if ((this66 == 0)) {
HXDLIN( 248)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float g23;
HXDLIN( 248)																int this67 = ((color >> 8) & 255);
HXDLIN( 248)																if ((this67 == 0)) {
HXDLIN( 248)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float b24;
HXDLIN( 248)																int this68 = (color & 255);
HXDLIN( 248)																if ((this68 == 0)) {
HXDLIN( 248)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 248)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 248)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 248)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 248)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 248)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 248)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 248)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 248)																{
HXDLIN( 248)																	int _hx_tmp14;
HXDLIN( 248)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 248)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 248)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 248)																::Dynamic this69 = this36->image;
HXDLIN( 248)																int index9;
HXDLIN( 248)																if (this36->useVirtualPos) {
HXDLIN( 248)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 248)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 248)																int _hx_tmp15;
HXDLIN( 248)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 248)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 248)																	_hx_tmp15 = c7;
            																}
HXDLIN( 248)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 248)														if (found1) {
HXDLIN( 248)															goto _hx_goto_482;
            														}
            													}
            												}
            											}
            											_hx_goto_482:;
            										}
            									}
            								}
HXDLIN( 248)								if ((hasHit1 == true)) {
HXDLIN( 248)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 248)									if (hasUndo1) {
HXDLIN( 248)										v6->undoImage = undoImage3;
HXDLIN( 248)										v6->undoX = xIter31->start;
HXDLIN( 248)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,hexagon,(void))

void FillShape_Impl__obj::heptagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_261_heptagon)
HXDLIN( 261)		 ::Dynamic phi1 = phi;
HXDLIN( 261)		 ::Dynamic sides = 7;
HXLINE( 265)		if (::hx::IsNull( sides )) {
HXLINE( 265)			sides = 36;
            		}
HXLINE( 264)		if (::hx::IsNull( phi1 )) {
HXLINE( 264)			phi1 = ((Float)0.);
            		}
HXLINE( 261)		{
HXDLIN( 261)			 ::Dynamic phi2 = phi1;
HXDLIN( 261)			 ::Dynamic sides1 = sides;
HXDLIN( 261)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 261)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 261)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 261)			Float omega;
HXDLIN( 261)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 261)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 261)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 261)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 261)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 261)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 261)			Float lastX = ((Float)0.);
HXDLIN( 261)			Float lastY = ((Float)0.);
HXDLIN( 261)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 261)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 261)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 261)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 261)				{
HXDLIN( 261)					int _g = 0;
HXDLIN( 261)					int _g1 = (sides1 + 1);
HXDLIN( 261)					while((_g < _g1)){
HXDLIN( 261)						_g = (_g + 1);
HXDLIN( 261)						int i = (_g - 1);
HXDLIN( 261)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 261)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 261)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 261)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 261)						{
HXDLIN( 261)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 261)							bool hasHit = false;
HXDLIN( 261)							bool hasUndo = false;
HXDLIN( 261)							{
HXDLIN( 261)								Float bx = lastX;
HXDLIN( 261)								Float by = lastY;
HXDLIN( 261)								Float cx1 = nextX;
HXDLIN( 261)								Float cy1 = nextY;
HXDLIN( 261)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 261)								if (!(adjustWinding)) {
HXDLIN( 261)									Float bx_ = bx;
HXDLIN( 261)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 261)								{
HXDLIN( 261)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 261)									Float sx = (cy1 - cy);
HXDLIN( 261)									Float sy = (cx - cx1);
HXDLIN( 261)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 261)									Float tx = (cy - by);
HXDLIN( 261)									Float ty = (bx - cx);
HXDLIN( 261)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 261)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 261)									if ((cx > bx)) {
HXDLIN( 261)										if ((cx > cx1)) {
HXDLIN( 261)											int min;
HXDLIN( 261)											if ((bx > cx1)) {
HXDLIN( 261)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 261)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 261)											int ii_min = min;
HXDLIN( 261)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 261)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 261)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 261)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 261)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 261)										if ((bx > cx1)) {
HXDLIN( 261)											int min1;
HXDLIN( 261)											if ((cx > cx1)) {
HXDLIN( 261)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 261)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 261)											int ii_min2 = min1;
HXDLIN( 261)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 261)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 261)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 261)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 261)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 261)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 261)									if ((cy > by)) {
HXDLIN( 261)										if ((cy > cy1)) {
HXDLIN( 261)											int min2;
HXDLIN( 261)											if ((by > cy1)) {
HXDLIN( 261)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 261)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 261)											int ii_min4 = min2;
HXDLIN( 261)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 261)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 261)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 261)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 261)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 261)										if ((by > cy1)) {
HXDLIN( 261)											int min3;
HXDLIN( 261)											if ((cy > cy1)) {
HXDLIN( 261)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 261)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 261)											int ii_min6 = min3;
HXDLIN( 261)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 261)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 261)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 261)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 261)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 261)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 261)									if (hasUndo) {
HXDLIN( 261)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 261)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 261)										 ::Dynamic imageType = null();
HXDLIN( 261)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 261)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 261)										::Dynamic undoImage1;
HXDLIN( 261)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 261)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 261)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 261)												{
HXDLIN( 261)													b->width = width;
HXDLIN( 261)													b->height = height;
HXDLIN( 261)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 261)													{
HXDLIN( 261)														int len = b->length;
HXDLIN( 261)														int w = 0;
HXDLIN( 261)														{
HXDLIN( 261)															int _g2 = 0;
HXDLIN( 261)															int _g3 = b->height;
HXDLIN( 261)															while((_g2 < _g3)){
HXDLIN( 261)																_g2 = (_g2 + 1);
HXDLIN( 261)																int y = (_g2 - 1);
HXDLIN( 261)																{
HXDLIN( 261)																	int _g4 = 0;
HXDLIN( 261)																	int _g5 = b->width;
HXDLIN( 261)																	while((_g4 < _g5)){
HXDLIN( 261)																		_g4 = (_g4 + 1);
HXDLIN( 261)																		int x = (_g4 - 1);
HXDLIN( 261)																		{
HXDLIN( 261)																			w = (w + 1);
HXDLIN( 261)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 261)																		{
HXDLIN( 261)																			w = (w + 1);
HXDLIN( 261)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 261)																		{
HXDLIN( 261)																			w = (w + 1);
HXDLIN( 261)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 261)																		{
HXDLIN( 261)																			w = (w + 1);
HXDLIN( 261)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 261)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 261)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 261)												{
HXDLIN( 261)													a->width = width;
HXDLIN( 261)													a->height = height;
HXDLIN( 261)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 261)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)													{
HXDLIN( 261)														int _g6 = 0;
HXDLIN( 261)														int _g7 = a->length;
HXDLIN( 261)														while((_g6 < _g7)){
HXDLIN( 261)															_g6 = (_g6 + 1);
HXDLIN( 261)															int i1 = (_g6 - 1);
HXDLIN( 261)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 261)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 261)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 261)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 261)												{
HXDLIN( 261)													b1->width = width;
HXDLIN( 261)													b1->height = height;
HXDLIN( 261)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)													int size = (b1->length * 4);
HXDLIN( 261)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 261)													{
HXDLIN( 261)														int _g8 = 0;
HXDLIN( 261)														int _g9 = b1->length;
HXDLIN( 261)														while((_g8 < _g9)){
HXDLIN( 261)															_g8 = (_g8 + 1);
HXDLIN( 261)															int i2 = (_g8 - 1);
HXDLIN( 261)															{
HXDLIN( 261)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 261)																bool undoImage2;
HXDLIN( 261)																if ((i2 >= 0)) {
HXDLIN( 261)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 261)																	undoImage2 = false;
            																}
HXDLIN( 261)																if (undoImage2) {
HXDLIN( 261)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 261)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 261)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 261)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 261)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 261)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 261)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 261)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 261)												{
HXDLIN( 261)													v1->width = width;
HXDLIN( 261)													v1->height = height;
HXDLIN( 261)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 261)													{
HXDLIN( 261)														int _g10 = 0;
HXDLIN( 261)														int _g11 = v1->length;
HXDLIN( 261)														while((_g10 < _g11)){
HXDLIN( 261)															_g10 = (_g10 + 1);
HXDLIN( 261)															int i3 = (_g10 - 1);
HXDLIN( 261)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 261)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 261)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 261)												{
HXDLIN( 261)													b2->width = width;
HXDLIN( 261)													b2->height = height;
HXDLIN( 261)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 261)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 261)													{
HXDLIN( 261)														int len1 = b2->length;
HXDLIN( 261)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 261)														if (::hx::IsNull( d->head )) {
HXDLIN( 261)															int _g12 = 0;
HXDLIN( 261)															int _g13 = len1;
HXDLIN( 261)															while((_g12 < _g13)){
HXDLIN( 261)																_g12 = (_g12 + 1);
HXDLIN( 261)																int i4 = (_g12 - 1);
HXDLIN( 261)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 261)															int _g14 = 0;
HXDLIN( 261)															int _g15 = len1;
HXDLIN( 261)															while((_g14 < _g15)){
HXDLIN( 261)																_g14 = (_g14 + 1);
HXDLIN( 261)																int i5 = (_g14 - 1);
HXDLIN( 261)																{
HXDLIN( 261)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 261)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 261)																	{
HXDLIN( 261)																		int _g16 = 0;
HXDLIN( 261)																		int _g17 = i5;
HXDLIN( 261)																		while((_g16 < _g17)){
HXDLIN( 261)																			_g16 = (_g16 + 1);
HXDLIN( 261)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 261)																	if (::hx::IsNull( prev )) {
HXDLIN( 261)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 261)																		l = null();
            																	}
            																	else {
HXDLIN( 261)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 261)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 261)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 261)										this3->image = undoImage1;
HXDLIN( 261)										this3->width = width;
HXDLIN( 261)										this3->height = height;
HXDLIN( 261)										this3->imageType = ( (int)(imageType) );
HXDLIN( 261)										undoImage = this3;
HXDLIN( 261)										{
HXDLIN( 261)											int rectLeft = xIter3->start;
HXDLIN( 261)											int rectTop = yIter3->start;
HXDLIN( 261)											int rectRight = xIter3->max;
HXDLIN( 261)											bool forceClear = false;
HXDLIN( 261)											{
HXDLIN( 261)												int _g18 = rectTop;
HXDLIN( 261)												int _g19 = yIter3->max;
HXDLIN( 261)												while((_g18 < _g19)){
HXDLIN( 261)													_g18 = (_g18 + 1);
HXDLIN( 261)													int dy = (_g18 - 1);
HXDLIN( 261)													{
HXDLIN( 261)														int _g20 = rectLeft;
HXDLIN( 261)														int _g21 = rectRight;
HXDLIN( 261)														while((_g20 < _g21)){
HXDLIN( 261)															_g20 = (_g20 + 1);
HXDLIN( 261)															int dx = (_g20 - 1);
HXDLIN( 261)															::Dynamic this5 = this2->image;
HXDLIN( 261)															int index;
HXDLIN( 261)															if (this2->useVirtualPos) {
HXDLIN( 261)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 261)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 261)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 261)															int col;
HXDLIN( 261)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 261)																col = c;
            															}
HXDLIN( 261)															bool _hx_tmp;
HXDLIN( 261)															if (this2->useMask) {
HXDLIN( 261)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 261)																_hx_tmp = false;
            															}
HXDLIN( 261)															if (_hx_tmp) {
HXDLIN( 261)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 261)																::Dynamic this7 = this6->image;
HXDLIN( 261)																int index1;
HXDLIN( 261)																if (this6->useVirtualPos) {
HXDLIN( 261)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 261)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 261)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 261)																int v2;
HXDLIN( 261)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 261)																	v2 = c1;
            																}
HXDLIN( 261)																int maskPixel = v2;
HXDLIN( 261)																int this8 = col;
HXDLIN( 261)																if ((maskPixel == 0)) {
HXDLIN( 261)																	col = this8;
            																}
            																else {
HXDLIN( 261)																	Float m0;
HXDLIN( 261)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 261)																	if ((this9 == 0)) {
HXDLIN( 261)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float m1;
HXDLIN( 261)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 261)																	if ((this10 == 0)) {
HXDLIN( 261)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float m2;
HXDLIN( 261)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 261)																	if ((this11 == 0)) {
HXDLIN( 261)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float m3;
HXDLIN( 261)																	int this12 = (maskPixel & 255);
HXDLIN( 261)																	if ((this12 == 0)) {
HXDLIN( 261)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 261)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 261)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 261)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 261)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 261)															if ((col != 0)) {
HXDLIN( 261)																int x1 = (dx - rectLeft);
HXDLIN( 261)																int y1 = (dy - rectTop);
HXDLIN( 261)																int c2 = col;
HXDLIN( 261)																bool _hx_tmp1;
HXDLIN( 261)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 261)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 261)																	_hx_tmp1 = false;
            																}
HXDLIN( 261)																if (_hx_tmp1) {
HXDLIN( 261)																	int location;
HXDLIN( 261)																	if (undoImage->useVirtualPos) {
HXDLIN( 261)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 261)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 261)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 261)																	int this14;
HXDLIN( 261)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 261)																		this14 = this13;
            																	}
HXDLIN( 261)																	Float a1;
HXDLIN( 261)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 261)																	if ((this15 == 0)) {
HXDLIN( 261)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float r1;
HXDLIN( 261)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 261)																	if ((this16 == 0)) {
HXDLIN( 261)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float g1;
HXDLIN( 261)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 261)																	if ((this17 == 0)) {
HXDLIN( 261)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float b11;
HXDLIN( 261)																	int this18 = (this14 & 255);
HXDLIN( 261)																	if ((this18 == 0)) {
HXDLIN( 261)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float a2;
HXDLIN( 261)																	int this19 = ((col >> 24) & 255);
HXDLIN( 261)																	if ((this19 == 0)) {
HXDLIN( 261)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float r2;
HXDLIN( 261)																	int this20 = ((col >> 16) & 255);
HXDLIN( 261)																	if ((this20 == 0)) {
HXDLIN( 261)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float g2;
HXDLIN( 261)																	int this21 = ((col >> 8) & 255);
HXDLIN( 261)																	if ((this21 == 0)) {
HXDLIN( 261)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float b21;
HXDLIN( 261)																	int this22 = (col & 255);
HXDLIN( 261)																	if ((this22 == 0)) {
HXDLIN( 261)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 261)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 261)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 261)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 261)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 261)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 261)																	{
HXDLIN( 261)																		int _hx_tmp2;
HXDLIN( 261)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 261)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 261)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 261)																	::Dynamic this23 = undoImage->image;
HXDLIN( 261)																	int index2;
HXDLIN( 261)																	if (undoImage->useVirtualPos) {
HXDLIN( 261)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 261)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 261)																	int _hx_tmp3;
HXDLIN( 261)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 261)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 261)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 261)																if (forceClear) {
HXDLIN( 261)																	::Dynamic this24 = undoImage->image;
HXDLIN( 261)																	int x2 = (dx - rectLeft);
HXDLIN( 261)																	int y2 = (dy - rectTop);
HXDLIN( 261)																	int index3;
HXDLIN( 261)																	if (undoImage->useVirtualPos) {
HXDLIN( 261)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 261)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 261)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 261)									bool found = false;
HXDLIN( 261)									Float s = ((Float)0.);
HXDLIN( 261)									Float t = ((Float)0.);
HXDLIN( 261)									Float sxx = ((Float)0.);
HXDLIN( 261)									Float txx = ((Float)0.);
HXDLIN( 261)									{
HXDLIN( 261)										int _g_min = xIter3->start;
HXDLIN( 261)										int _g_max = xIter3->max;
HXDLIN( 261)										while((_g_min < _g_max)){
HXDLIN( 261)											_g_min = (_g_min + 1);
HXDLIN( 261)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 261)											{
HXDLIN( 261)												int _g_min1 = yIter3->start;
HXDLIN( 261)												int _g_max1 = yIter3->max;
HXDLIN( 261)												while((_g_min1 < _g_max1)){
HXDLIN( 261)													_g_min1 = (_g_min1 + 1);
HXDLIN( 261)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 261)													bool _hx_tmp4;
HXDLIN( 261)													if (!((s <= 0))) {
HXDLIN( 261)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 261)														_hx_tmp4 = true;
            													}
HXDLIN( 261)													if (_hx_tmp4) {
HXDLIN( 261)														if (found) {
HXDLIN( 261)															goto _hx_goto_496;
            														}
            													}
            													else {
HXDLIN( 261)														if (((s + t) < A)) {
HXDLIN( 261)															{
HXDLIN( 261)																int c3 = color;
HXDLIN( 261)																bool _hx_tmp5;
HXDLIN( 261)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 261)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 261)																	_hx_tmp5 = false;
            																}
HXDLIN( 261)																if (_hx_tmp5) {
HXDLIN( 261)																	int location1;
HXDLIN( 261)																	if (this2->useVirtualPos) {
HXDLIN( 261)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 261)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 261)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 261)																	int this26;
HXDLIN( 261)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 261)																		this26 = this25;
            																	}
HXDLIN( 261)																	Float a11;
HXDLIN( 261)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 261)																	if ((this27 == 0)) {
HXDLIN( 261)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float r11;
HXDLIN( 261)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 261)																	if ((this28 == 0)) {
HXDLIN( 261)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float g11;
HXDLIN( 261)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 261)																	if ((this29 == 0)) {
HXDLIN( 261)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float b12;
HXDLIN( 261)																	int this30 = (this26 & 255);
HXDLIN( 261)																	if ((this30 == 0)) {
HXDLIN( 261)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float a21;
HXDLIN( 261)																	int this31 = ((color >> 24) & 255);
HXDLIN( 261)																	if ((this31 == 0)) {
HXDLIN( 261)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float r21;
HXDLIN( 261)																	int this32 = ((color >> 16) & 255);
HXDLIN( 261)																	if ((this32 == 0)) {
HXDLIN( 261)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float g21;
HXDLIN( 261)																	int this33 = ((color >> 8) & 255);
HXDLIN( 261)																	if ((this33 == 0)) {
HXDLIN( 261)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float b22;
HXDLIN( 261)																	int this34 = (color & 255);
HXDLIN( 261)																	if ((this34 == 0)) {
HXDLIN( 261)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 261)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 261)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 261)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 261)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 261)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 261)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 261)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 261)																	{
HXDLIN( 261)																		int _hx_tmp6;
HXDLIN( 261)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 261)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 261)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 261)																	::Dynamic this35 = this2->image;
HXDLIN( 261)																	int index4;
HXDLIN( 261)																	if (this2->useVirtualPos) {
HXDLIN( 261)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 261)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 261)																	int _hx_tmp7;
HXDLIN( 261)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 261)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 261)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 261)															if (found) {
HXDLIN( 261)																goto _hx_goto_496;
            															}
            														}
            													}
            												}
            												_hx_goto_496:;
            											}
            										}
            									}
HXDLIN( 261)									if ((hasHit == true)) {
HXDLIN( 261)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 261)										if (hasUndo) {
HXDLIN( 261)											v3->undoImage = undoImage;
HXDLIN( 261)											v3->undoX = xIter3->start;
HXDLIN( 261)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 261)				int _g22 = 0;
HXDLIN( 261)				int _g23 = (sides1 + 1);
HXDLIN( 261)				while((_g22 < _g23)){
HXDLIN( 261)					_g22 = (_g22 + 1);
HXDLIN( 261)					int i7 = (_g22 - 1);
HXDLIN( 261)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 261)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 261)					{
HXDLIN( 261)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 261)						bool hasHit1 = false;
HXDLIN( 261)						bool hasUndo1 = false;
HXDLIN( 261)						{
HXDLIN( 261)							Float bx1 = lastX;
HXDLIN( 261)							Float by1 = lastY;
HXDLIN( 261)							Float cx2 = nextX1;
HXDLIN( 261)							Float cy2 = nextY1;
HXDLIN( 261)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 261)							if (!(adjustWinding1)) {
HXDLIN( 261)								Float bx_1 = bx1;
HXDLIN( 261)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 261)							{
HXDLIN( 261)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 261)								Float sx1 = (cy2 - cy);
HXDLIN( 261)								Float sy1 = (cx - cx2);
HXDLIN( 261)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 261)								Float tx1 = (cy - by1);
HXDLIN( 261)								Float ty1 = (bx1 - cx);
HXDLIN( 261)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 261)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 261)								if ((cx > bx1)) {
HXDLIN( 261)									if ((cx > cx2)) {
HXDLIN( 261)										int min4;
HXDLIN( 261)										if ((bx1 > cx2)) {
HXDLIN( 261)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 261)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 261)										int ii_min8 = min4;
HXDLIN( 261)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 261)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 261)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 261)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 261)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 261)									if ((bx1 > cx2)) {
HXDLIN( 261)										int min5;
HXDLIN( 261)										if ((cx > cx2)) {
HXDLIN( 261)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 261)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 261)										int ii_min10 = min5;
HXDLIN( 261)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 261)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 261)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 261)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 261)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 261)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 261)								if ((cy > by1)) {
HXDLIN( 261)									if ((cy > cy2)) {
HXDLIN( 261)										int min6;
HXDLIN( 261)										if ((by1 > cy2)) {
HXDLIN( 261)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 261)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 261)										int ii_min12 = min6;
HXDLIN( 261)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 261)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 261)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 261)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 261)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 261)									if ((by1 > cy2)) {
HXDLIN( 261)										int min7;
HXDLIN( 261)										if ((cy > cy2)) {
HXDLIN( 261)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 261)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 261)										int ii_min14 = min7;
HXDLIN( 261)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 261)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 261)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 261)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 261)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 261)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 261)								if (hasUndo1) {
HXDLIN( 261)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 261)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 261)									 ::Dynamic imageType1 = null();
HXDLIN( 261)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 261)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 261)									::Dynamic undoImage4;
HXDLIN( 261)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 261)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 261)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 261)											{
HXDLIN( 261)												b5->width = width1;
HXDLIN( 261)												b5->height = height1;
HXDLIN( 261)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 261)												{
HXDLIN( 261)													int len2 = b5->length;
HXDLIN( 261)													int w1 = 0;
HXDLIN( 261)													{
HXDLIN( 261)														int _g24 = 0;
HXDLIN( 261)														int _g25 = b5->height;
HXDLIN( 261)														while((_g24 < _g25)){
HXDLIN( 261)															_g24 = (_g24 + 1);
HXDLIN( 261)															int y4 = (_g24 - 1);
HXDLIN( 261)															{
HXDLIN( 261)																int _g26 = 0;
HXDLIN( 261)																int _g27 = b5->width;
HXDLIN( 261)																while((_g26 < _g27)){
HXDLIN( 261)																	_g26 = (_g26 + 1);
HXDLIN( 261)																	int x4 = (_g26 - 1);
HXDLIN( 261)																	{
HXDLIN( 261)																		w1 = (w1 + 1);
HXDLIN( 261)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 261)																	{
HXDLIN( 261)																		w1 = (w1 + 1);
HXDLIN( 261)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 261)																	{
HXDLIN( 261)																		w1 = (w1 + 1);
HXDLIN( 261)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 261)																	{
HXDLIN( 261)																		w1 = (w1 + 1);
HXDLIN( 261)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 261)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 261)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 261)											{
HXDLIN( 261)												a6->width = width1;
HXDLIN( 261)												a6->height = height1;
HXDLIN( 261)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 261)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)												{
HXDLIN( 261)													int _g28 = 0;
HXDLIN( 261)													int _g29 = a6->length;
HXDLIN( 261)													while((_g28 < _g29)){
HXDLIN( 261)														_g28 = (_g28 + 1);
HXDLIN( 261)														int i8 = (_g28 - 1);
HXDLIN( 261)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 261)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 261)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 261)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 261)											{
HXDLIN( 261)												b6->width = width1;
HXDLIN( 261)												b6->height = height1;
HXDLIN( 261)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)												int size1 = (b6->length * 4);
HXDLIN( 261)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 261)												{
HXDLIN( 261)													int _g30 = 0;
HXDLIN( 261)													int _g31 = b6->length;
HXDLIN( 261)													while((_g30 < _g31)){
HXDLIN( 261)														_g30 = (_g30 + 1);
HXDLIN( 261)														int i9 = (_g30 - 1);
HXDLIN( 261)														{
HXDLIN( 261)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 261)															bool undoImage5;
HXDLIN( 261)															if ((i9 >= 0)) {
HXDLIN( 261)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 261)																undoImage5 = false;
            															}
HXDLIN( 261)															if (undoImage5) {
HXDLIN( 261)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 261)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 261)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 261)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 261)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 261)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 261)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 261)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 261)											{
HXDLIN( 261)												v4->width = width1;
HXDLIN( 261)												v4->height = height1;
HXDLIN( 261)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 261)												{
HXDLIN( 261)													int _g32 = 0;
HXDLIN( 261)													int _g33 = v4->length;
HXDLIN( 261)													while((_g32 < _g33)){
HXDLIN( 261)														_g32 = (_g32 + 1);
HXDLIN( 261)														int i10 = (_g32 - 1);
HXDLIN( 261)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 261)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 261)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 261)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 261)											{
HXDLIN( 261)												b7->width = width1;
HXDLIN( 261)												b7->height = height1;
HXDLIN( 261)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 261)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 261)												{
HXDLIN( 261)													int len3 = b7->length;
HXDLIN( 261)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 261)													if (::hx::IsNull( d1->head )) {
HXDLIN( 261)														int _g34 = 0;
HXDLIN( 261)														int _g35 = len3;
HXDLIN( 261)														while((_g34 < _g35)){
HXDLIN( 261)															_g34 = (_g34 + 1);
HXDLIN( 261)															int i11 = (_g34 - 1);
HXDLIN( 261)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 261)														int _g36 = 0;
HXDLIN( 261)														int _g37 = len3;
HXDLIN( 261)														while((_g36 < _g37)){
HXDLIN( 261)															_g36 = (_g36 + 1);
HXDLIN( 261)															int i12 = (_g36 - 1);
HXDLIN( 261)															{
HXDLIN( 261)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 261)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 261)																{
HXDLIN( 261)																	int _g38 = 0;
HXDLIN( 261)																	int _g39 = i12;
HXDLIN( 261)																	while((_g38 < _g39)){
HXDLIN( 261)																		_g38 = (_g38 + 1);
HXDLIN( 261)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 261)																if (::hx::IsNull( prev1 )) {
HXDLIN( 261)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 261)																	l1 = null();
            																}
            																else {
HXDLIN( 261)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 261)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 261)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 261)									this37->image = undoImage4;
HXDLIN( 261)									this37->width = width1;
HXDLIN( 261)									this37->height = height1;
HXDLIN( 261)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 261)									undoImage3 = this37;
HXDLIN( 261)									{
HXDLIN( 261)										int rectLeft1 = xIter31->start;
HXDLIN( 261)										int rectTop1 = yIter31->start;
HXDLIN( 261)										int rectRight1 = xIter31->max;
HXDLIN( 261)										bool forceClear1 = false;
HXDLIN( 261)										{
HXDLIN( 261)											int _g40 = rectTop1;
HXDLIN( 261)											int _g41 = yIter31->max;
HXDLIN( 261)											while((_g40 < _g41)){
HXDLIN( 261)												_g40 = (_g40 + 1);
HXDLIN( 261)												int dy1 = (_g40 - 1);
HXDLIN( 261)												{
HXDLIN( 261)													int _g42 = rectLeft1;
HXDLIN( 261)													int _g43 = rectRight1;
HXDLIN( 261)													while((_g42 < _g43)){
HXDLIN( 261)														_g42 = (_g42 + 1);
HXDLIN( 261)														int dx1 = (_g42 - 1);
HXDLIN( 261)														::Dynamic this39 = this36->image;
HXDLIN( 261)														int index5;
HXDLIN( 261)														if (this36->useVirtualPos) {
HXDLIN( 261)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 261)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 261)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 261)														int col1;
HXDLIN( 261)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 261)															col1 = c4;
            														}
HXDLIN( 261)														bool _hx_tmp8;
HXDLIN( 261)														if (this36->useMask) {
HXDLIN( 261)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 261)															_hx_tmp8 = false;
            														}
HXDLIN( 261)														if (_hx_tmp8) {
HXDLIN( 261)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 261)															::Dynamic this41 = this40->image;
HXDLIN( 261)															int index6;
HXDLIN( 261)															if (this40->useVirtualPos) {
HXDLIN( 261)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 261)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 261)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 261)															int v5;
HXDLIN( 261)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 261)																v5 = c5;
            															}
HXDLIN( 261)															int maskPixel1 = v5;
HXDLIN( 261)															int this42 = col1;
HXDLIN( 261)															if ((maskPixel1 == 0)) {
HXDLIN( 261)																col1 = this42;
            															}
            															else {
HXDLIN( 261)																Float m01;
HXDLIN( 261)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 261)																if ((this43 == 0)) {
HXDLIN( 261)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float m11;
HXDLIN( 261)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 261)																if ((this44 == 0)) {
HXDLIN( 261)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float m21;
HXDLIN( 261)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 261)																if ((this45 == 0)) {
HXDLIN( 261)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float m31;
HXDLIN( 261)																int this46 = (maskPixel1 & 255);
HXDLIN( 261)																if ((this46 == 0)) {
HXDLIN( 261)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 261)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 261)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 261)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 261)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 261)														if ((col1 != 0)) {
HXDLIN( 261)															int x5 = (dx1 - rectLeft1);
HXDLIN( 261)															int y5 = (dy1 - rectTop1);
HXDLIN( 261)															int c6 = col1;
HXDLIN( 261)															bool _hx_tmp9;
HXDLIN( 261)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 261)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 261)																_hx_tmp9 = false;
            															}
HXDLIN( 261)															if (_hx_tmp9) {
HXDLIN( 261)																int location2;
HXDLIN( 261)																if (undoImage3->useVirtualPos) {
HXDLIN( 261)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 261)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 261)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 261)																int this48;
HXDLIN( 261)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 261)																	this48 = this47;
            																}
HXDLIN( 261)																Float a12;
HXDLIN( 261)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 261)																if ((this49 == 0)) {
HXDLIN( 261)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float r12;
HXDLIN( 261)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 261)																if ((this50 == 0)) {
HXDLIN( 261)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float g12;
HXDLIN( 261)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 261)																if ((this51 == 0)) {
HXDLIN( 261)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float b13;
HXDLIN( 261)																int this52 = (this48 & 255);
HXDLIN( 261)																if ((this52 == 0)) {
HXDLIN( 261)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float a22;
HXDLIN( 261)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 261)																if ((this53 == 0)) {
HXDLIN( 261)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float r22;
HXDLIN( 261)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 261)																if ((this54 == 0)) {
HXDLIN( 261)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float g22;
HXDLIN( 261)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 261)																if ((this55 == 0)) {
HXDLIN( 261)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float b23;
HXDLIN( 261)																int this56 = (col1 & 255);
HXDLIN( 261)																if ((this56 == 0)) {
HXDLIN( 261)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 261)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 261)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 261)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 261)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 261)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 261)																{
HXDLIN( 261)																	int _hx_tmp10;
HXDLIN( 261)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 261)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 261)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 261)																::Dynamic this57 = undoImage3->image;
HXDLIN( 261)																int index7;
HXDLIN( 261)																if (undoImage3->useVirtualPos) {
HXDLIN( 261)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 261)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 261)																int _hx_tmp11;
HXDLIN( 261)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 261)																	_hx_tmp11 = c6;
            																}
HXDLIN( 261)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 261)															if (forceClear1) {
HXDLIN( 261)																::Dynamic this58 = undoImage3->image;
HXDLIN( 261)																int x6 = (dx1 - rectLeft1);
HXDLIN( 261)																int y6 = (dy1 - rectTop1);
HXDLIN( 261)																int index8;
HXDLIN( 261)																if (undoImage3->useVirtualPos) {
HXDLIN( 261)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 261)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 261)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 261)								bool found1 = false;
HXDLIN( 261)								Float s1 = ((Float)0.);
HXDLIN( 261)								Float t1 = ((Float)0.);
HXDLIN( 261)								Float sxx1 = ((Float)0.);
HXDLIN( 261)								Float txx1 = ((Float)0.);
HXDLIN( 261)								{
HXDLIN( 261)									int _g_min2 = xIter31->start;
HXDLIN( 261)									int _g_max2 = xIter31->max;
HXDLIN( 261)									while((_g_min2 < _g_max2)){
HXDLIN( 261)										_g_min2 = (_g_min2 + 1);
HXDLIN( 261)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 261)										{
HXDLIN( 261)											int _g_min3 = yIter31->start;
HXDLIN( 261)											int _g_max3 = yIter31->max;
HXDLIN( 261)											while((_g_min3 < _g_max3)){
HXDLIN( 261)												_g_min3 = (_g_min3 + 1);
HXDLIN( 261)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 261)												bool _hx_tmp12;
HXDLIN( 261)												if (!((s1 <= 0))) {
HXDLIN( 261)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 261)													_hx_tmp12 = true;
            												}
HXDLIN( 261)												if (_hx_tmp12) {
HXDLIN( 261)													if (found1) {
HXDLIN( 261)														goto _hx_goto_509;
            													}
            												}
            												else {
HXDLIN( 261)													if (((s1 + t1) < A1)) {
HXDLIN( 261)														{
HXDLIN( 261)															int c7 = color;
HXDLIN( 261)															bool _hx_tmp13;
HXDLIN( 261)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 261)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 261)																_hx_tmp13 = false;
            															}
HXDLIN( 261)															if (_hx_tmp13) {
HXDLIN( 261)																int location3;
HXDLIN( 261)																if (this36->useVirtualPos) {
HXDLIN( 261)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 261)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 261)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 261)																int this60;
HXDLIN( 261)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 261)																	this60 = this59;
            																}
HXDLIN( 261)																Float a13;
HXDLIN( 261)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 261)																if ((this61 == 0)) {
HXDLIN( 261)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float r13;
HXDLIN( 261)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 261)																if ((this62 == 0)) {
HXDLIN( 261)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float g13;
HXDLIN( 261)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 261)																if ((this63 == 0)) {
HXDLIN( 261)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float b14;
HXDLIN( 261)																int this64 = (this60 & 255);
HXDLIN( 261)																if ((this64 == 0)) {
HXDLIN( 261)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float a23;
HXDLIN( 261)																int this65 = ((color >> 24) & 255);
HXDLIN( 261)																if ((this65 == 0)) {
HXDLIN( 261)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float r23;
HXDLIN( 261)																int this66 = ((color >> 16) & 255);
HXDLIN( 261)																if ((this66 == 0)) {
HXDLIN( 261)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float g23;
HXDLIN( 261)																int this67 = ((color >> 8) & 255);
HXDLIN( 261)																if ((this67 == 0)) {
HXDLIN( 261)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float b24;
HXDLIN( 261)																int this68 = (color & 255);
HXDLIN( 261)																if ((this68 == 0)) {
HXDLIN( 261)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 261)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 261)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 261)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 261)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 261)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 261)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 261)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 261)																{
HXDLIN( 261)																	int _hx_tmp14;
HXDLIN( 261)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 261)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 261)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 261)																::Dynamic this69 = this36->image;
HXDLIN( 261)																int index9;
HXDLIN( 261)																if (this36->useVirtualPos) {
HXDLIN( 261)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 261)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 261)																int _hx_tmp15;
HXDLIN( 261)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 261)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 261)																	_hx_tmp15 = c7;
            																}
HXDLIN( 261)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 261)														if (found1) {
HXDLIN( 261)															goto _hx_goto_509;
            														}
            													}
            												}
            											}
            											_hx_goto_509:;
            										}
            									}
            								}
HXDLIN( 261)								if ((hasHit1 == true)) {
HXDLIN( 261)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 261)									if (hasUndo1) {
HXDLIN( 261)										v6->undoImage = undoImage3;
HXDLIN( 261)										v6->undoX = xIter31->start;
HXDLIN( 261)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,heptagon,(void))

void FillShape_Impl__obj::septagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_274_septagon)
HXDLIN( 274)		 ::Dynamic phi1 = phi;
HXDLIN( 274)		 ::Dynamic sides = 7;
HXLINE( 278)		if (::hx::IsNull( sides )) {
HXLINE( 278)			sides = 36;
            		}
HXLINE( 277)		if (::hx::IsNull( phi1 )) {
HXLINE( 277)			phi1 = ((Float)0.);
            		}
HXLINE( 274)		{
HXDLIN( 274)			 ::Dynamic phi2 = phi1;
HXDLIN( 274)			 ::Dynamic sides1 = sides;
HXDLIN( 274)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 274)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 274)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 274)			Float omega;
HXDLIN( 274)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 274)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 274)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 274)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 274)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 274)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 274)			Float lastX = ((Float)0.);
HXDLIN( 274)			Float lastY = ((Float)0.);
HXDLIN( 274)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 274)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 274)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 274)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 274)				{
HXDLIN( 274)					int _g = 0;
HXDLIN( 274)					int _g1 = (sides1 + 1);
HXDLIN( 274)					while((_g < _g1)){
HXDLIN( 274)						_g = (_g + 1);
HXDLIN( 274)						int i = (_g - 1);
HXDLIN( 274)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 274)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 274)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 274)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 274)						{
HXDLIN( 274)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 274)							bool hasHit = false;
HXDLIN( 274)							bool hasUndo = false;
HXDLIN( 274)							{
HXDLIN( 274)								Float bx = lastX;
HXDLIN( 274)								Float by = lastY;
HXDLIN( 274)								Float cx1 = nextX;
HXDLIN( 274)								Float cy1 = nextY;
HXDLIN( 274)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 274)								if (!(adjustWinding)) {
HXDLIN( 274)									Float bx_ = bx;
HXDLIN( 274)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 274)								{
HXDLIN( 274)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 274)									Float sx = (cy1 - cy);
HXDLIN( 274)									Float sy = (cx - cx1);
HXDLIN( 274)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 274)									Float tx = (cy - by);
HXDLIN( 274)									Float ty = (bx - cx);
HXDLIN( 274)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 274)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 274)									if ((cx > bx)) {
HXDLIN( 274)										if ((cx > cx1)) {
HXDLIN( 274)											int min;
HXDLIN( 274)											if ((bx > cx1)) {
HXDLIN( 274)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 274)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 274)											int ii_min = min;
HXDLIN( 274)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 274)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 274)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 274)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 274)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 274)										if ((bx > cx1)) {
HXDLIN( 274)											int min1;
HXDLIN( 274)											if ((cx > cx1)) {
HXDLIN( 274)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 274)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 274)											int ii_min2 = min1;
HXDLIN( 274)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 274)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 274)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 274)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 274)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 274)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 274)									if ((cy > by)) {
HXDLIN( 274)										if ((cy > cy1)) {
HXDLIN( 274)											int min2;
HXDLIN( 274)											if ((by > cy1)) {
HXDLIN( 274)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 274)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 274)											int ii_min4 = min2;
HXDLIN( 274)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 274)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 274)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 274)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 274)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 274)										if ((by > cy1)) {
HXDLIN( 274)											int min3;
HXDLIN( 274)											if ((cy > cy1)) {
HXDLIN( 274)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 274)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 274)											int ii_min6 = min3;
HXDLIN( 274)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 274)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 274)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 274)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 274)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 274)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 274)									if (hasUndo) {
HXDLIN( 274)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 274)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 274)										 ::Dynamic imageType = null();
HXDLIN( 274)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 274)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 274)										::Dynamic undoImage1;
HXDLIN( 274)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 274)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 274)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 274)												{
HXDLIN( 274)													b->width = width;
HXDLIN( 274)													b->height = height;
HXDLIN( 274)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 274)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 274)													{
HXDLIN( 274)														int len = b->length;
HXDLIN( 274)														int w = 0;
HXDLIN( 274)														{
HXDLIN( 274)															int _g2 = 0;
HXDLIN( 274)															int _g3 = b->height;
HXDLIN( 274)															while((_g2 < _g3)){
HXDLIN( 274)																_g2 = (_g2 + 1);
HXDLIN( 274)																int y = (_g2 - 1);
HXDLIN( 274)																{
HXDLIN( 274)																	int _g4 = 0;
HXDLIN( 274)																	int _g5 = b->width;
HXDLIN( 274)																	while((_g4 < _g5)){
HXDLIN( 274)																		_g4 = (_g4 + 1);
HXDLIN( 274)																		int x = (_g4 - 1);
HXDLIN( 274)																		{
HXDLIN( 274)																			w = (w + 1);
HXDLIN( 274)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 274)																		{
HXDLIN( 274)																			w = (w + 1);
HXDLIN( 274)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 274)																		{
HXDLIN( 274)																			w = (w + 1);
HXDLIN( 274)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 274)																		{
HXDLIN( 274)																			w = (w + 1);
HXDLIN( 274)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 274)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 274)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 274)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 274)												{
HXDLIN( 274)													a->width = width;
HXDLIN( 274)													a->height = height;
HXDLIN( 274)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 274)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 274)													{
HXDLIN( 274)														int _g6 = 0;
HXDLIN( 274)														int _g7 = a->length;
HXDLIN( 274)														while((_g6 < _g7)){
HXDLIN( 274)															_g6 = (_g6 + 1);
HXDLIN( 274)															int i1 = (_g6 - 1);
HXDLIN( 274)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 274)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 274)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 274)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 274)												{
HXDLIN( 274)													b1->width = width;
HXDLIN( 274)													b1->height = height;
HXDLIN( 274)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 274)													int size = (b1->length * 4);
HXDLIN( 274)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 274)													{
HXDLIN( 274)														int _g8 = 0;
HXDLIN( 274)														int _g9 = b1->length;
HXDLIN( 274)														while((_g8 < _g9)){
HXDLIN( 274)															_g8 = (_g8 + 1);
HXDLIN( 274)															int i2 = (_g8 - 1);
HXDLIN( 274)															{
HXDLIN( 274)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 274)																bool undoImage2;
HXDLIN( 274)																if ((i2 >= 0)) {
HXDLIN( 274)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 274)																	undoImage2 = false;
            																}
HXDLIN( 274)																if (undoImage2) {
HXDLIN( 274)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 274)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 274)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 274)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 274)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 274)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 274)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 274)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 274)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 274)												{
HXDLIN( 274)													v1->width = width;
HXDLIN( 274)													v1->height = height;
HXDLIN( 274)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 274)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 274)													{
HXDLIN( 274)														int _g10 = 0;
HXDLIN( 274)														int _g11 = v1->length;
HXDLIN( 274)														while((_g10 < _g11)){
HXDLIN( 274)															_g10 = (_g10 + 1);
HXDLIN( 274)															int i3 = (_g10 - 1);
HXDLIN( 274)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 274)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 274)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 274)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 274)												{
HXDLIN( 274)													b2->width = width;
HXDLIN( 274)													b2->height = height;
HXDLIN( 274)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 274)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 274)													{
HXDLIN( 274)														int len1 = b2->length;
HXDLIN( 274)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 274)														if (::hx::IsNull( d->head )) {
HXDLIN( 274)															int _g12 = 0;
HXDLIN( 274)															int _g13 = len1;
HXDLIN( 274)															while((_g12 < _g13)){
HXDLIN( 274)																_g12 = (_g12 + 1);
HXDLIN( 274)																int i4 = (_g12 - 1);
HXDLIN( 274)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 274)															int _g14 = 0;
HXDLIN( 274)															int _g15 = len1;
HXDLIN( 274)															while((_g14 < _g15)){
HXDLIN( 274)																_g14 = (_g14 + 1);
HXDLIN( 274)																int i5 = (_g14 - 1);
HXDLIN( 274)																{
HXDLIN( 274)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 274)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 274)																	{
HXDLIN( 274)																		int _g16 = 0;
HXDLIN( 274)																		int _g17 = i5;
HXDLIN( 274)																		while((_g16 < _g17)){
HXDLIN( 274)																			_g16 = (_g16 + 1);
HXDLIN( 274)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 274)																	if (::hx::IsNull( prev )) {
HXDLIN( 274)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 274)																		l = null();
            																	}
            																	else {
HXDLIN( 274)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 274)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 274)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 274)										this3->image = undoImage1;
HXDLIN( 274)										this3->width = width;
HXDLIN( 274)										this3->height = height;
HXDLIN( 274)										this3->imageType = ( (int)(imageType) );
HXDLIN( 274)										undoImage = this3;
HXDLIN( 274)										{
HXDLIN( 274)											int rectLeft = xIter3->start;
HXDLIN( 274)											int rectTop = yIter3->start;
HXDLIN( 274)											int rectRight = xIter3->max;
HXDLIN( 274)											bool forceClear = false;
HXDLIN( 274)											{
HXDLIN( 274)												int _g18 = rectTop;
HXDLIN( 274)												int _g19 = yIter3->max;
HXDLIN( 274)												while((_g18 < _g19)){
HXDLIN( 274)													_g18 = (_g18 + 1);
HXDLIN( 274)													int dy = (_g18 - 1);
HXDLIN( 274)													{
HXDLIN( 274)														int _g20 = rectLeft;
HXDLIN( 274)														int _g21 = rectRight;
HXDLIN( 274)														while((_g20 < _g21)){
HXDLIN( 274)															_g20 = (_g20 + 1);
HXDLIN( 274)															int dx = (_g20 - 1);
HXDLIN( 274)															::Dynamic this5 = this2->image;
HXDLIN( 274)															int index;
HXDLIN( 274)															if (this2->useVirtualPos) {
HXDLIN( 274)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 274)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 274)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 274)															int col;
HXDLIN( 274)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 274)																col = c;
            															}
HXDLIN( 274)															bool _hx_tmp;
HXDLIN( 274)															if (this2->useMask) {
HXDLIN( 274)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 274)																_hx_tmp = false;
            															}
HXDLIN( 274)															if (_hx_tmp) {
HXDLIN( 274)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 274)																::Dynamic this7 = this6->image;
HXDLIN( 274)																int index1;
HXDLIN( 274)																if (this6->useVirtualPos) {
HXDLIN( 274)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 274)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 274)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 274)																int v2;
HXDLIN( 274)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 274)																	v2 = c1;
            																}
HXDLIN( 274)																int maskPixel = v2;
HXDLIN( 274)																int this8 = col;
HXDLIN( 274)																if ((maskPixel == 0)) {
HXDLIN( 274)																	col = this8;
            																}
            																else {
HXDLIN( 274)																	Float m0;
HXDLIN( 274)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 274)																	if ((this9 == 0)) {
HXDLIN( 274)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float m1;
HXDLIN( 274)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 274)																	if ((this10 == 0)) {
HXDLIN( 274)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float m2;
HXDLIN( 274)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 274)																	if ((this11 == 0)) {
HXDLIN( 274)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float m3;
HXDLIN( 274)																	int this12 = (maskPixel & 255);
HXDLIN( 274)																	if ((this12 == 0)) {
HXDLIN( 274)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 274)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 274)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 274)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 274)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 274)															if ((col != 0)) {
HXDLIN( 274)																int x1 = (dx - rectLeft);
HXDLIN( 274)																int y1 = (dy - rectTop);
HXDLIN( 274)																int c2 = col;
HXDLIN( 274)																bool _hx_tmp1;
HXDLIN( 274)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 274)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 274)																	_hx_tmp1 = false;
            																}
HXDLIN( 274)																if (_hx_tmp1) {
HXDLIN( 274)																	int location;
HXDLIN( 274)																	if (undoImage->useVirtualPos) {
HXDLIN( 274)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 274)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 274)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 274)																	int this14;
HXDLIN( 274)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 274)																		this14 = this13;
            																	}
HXDLIN( 274)																	Float a1;
HXDLIN( 274)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 274)																	if ((this15 == 0)) {
HXDLIN( 274)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float r1;
HXDLIN( 274)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 274)																	if ((this16 == 0)) {
HXDLIN( 274)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float g1;
HXDLIN( 274)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 274)																	if ((this17 == 0)) {
HXDLIN( 274)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float b11;
HXDLIN( 274)																	int this18 = (this14 & 255);
HXDLIN( 274)																	if ((this18 == 0)) {
HXDLIN( 274)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float a2;
HXDLIN( 274)																	int this19 = ((col >> 24) & 255);
HXDLIN( 274)																	if ((this19 == 0)) {
HXDLIN( 274)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float r2;
HXDLIN( 274)																	int this20 = ((col >> 16) & 255);
HXDLIN( 274)																	if ((this20 == 0)) {
HXDLIN( 274)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float g2;
HXDLIN( 274)																	int this21 = ((col >> 8) & 255);
HXDLIN( 274)																	if ((this21 == 0)) {
HXDLIN( 274)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float b21;
HXDLIN( 274)																	int this22 = (col & 255);
HXDLIN( 274)																	if ((this22 == 0)) {
HXDLIN( 274)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 274)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 274)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 274)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 274)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 274)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 274)																	{
HXDLIN( 274)																		int _hx_tmp2;
HXDLIN( 274)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 274)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 274)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 274)																	::Dynamic this23 = undoImage->image;
HXDLIN( 274)																	int index2;
HXDLIN( 274)																	if (undoImage->useVirtualPos) {
HXDLIN( 274)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 274)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 274)																	int _hx_tmp3;
HXDLIN( 274)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 274)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 274)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 274)																if (forceClear) {
HXDLIN( 274)																	::Dynamic this24 = undoImage->image;
HXDLIN( 274)																	int x2 = (dx - rectLeft);
HXDLIN( 274)																	int y2 = (dy - rectTop);
HXDLIN( 274)																	int index3;
HXDLIN( 274)																	if (undoImage->useVirtualPos) {
HXDLIN( 274)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 274)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 274)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 274)									bool found = false;
HXDLIN( 274)									Float s = ((Float)0.);
HXDLIN( 274)									Float t = ((Float)0.);
HXDLIN( 274)									Float sxx = ((Float)0.);
HXDLIN( 274)									Float txx = ((Float)0.);
HXDLIN( 274)									{
HXDLIN( 274)										int _g_min = xIter3->start;
HXDLIN( 274)										int _g_max = xIter3->max;
HXDLIN( 274)										while((_g_min < _g_max)){
HXDLIN( 274)											_g_min = (_g_min + 1);
HXDLIN( 274)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 274)											{
HXDLIN( 274)												int _g_min1 = yIter3->start;
HXDLIN( 274)												int _g_max1 = yIter3->max;
HXDLIN( 274)												while((_g_min1 < _g_max1)){
HXDLIN( 274)													_g_min1 = (_g_min1 + 1);
HXDLIN( 274)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 274)													bool _hx_tmp4;
HXDLIN( 274)													if (!((s <= 0))) {
HXDLIN( 274)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 274)														_hx_tmp4 = true;
            													}
HXDLIN( 274)													if (_hx_tmp4) {
HXDLIN( 274)														if (found) {
HXDLIN( 274)															goto _hx_goto_523;
            														}
            													}
            													else {
HXDLIN( 274)														if (((s + t) < A)) {
HXDLIN( 274)															{
HXDLIN( 274)																int c3 = color;
HXDLIN( 274)																bool _hx_tmp5;
HXDLIN( 274)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 274)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 274)																	_hx_tmp5 = false;
            																}
HXDLIN( 274)																if (_hx_tmp5) {
HXDLIN( 274)																	int location1;
HXDLIN( 274)																	if (this2->useVirtualPos) {
HXDLIN( 274)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 274)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 274)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 274)																	int this26;
HXDLIN( 274)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 274)																		this26 = this25;
            																	}
HXDLIN( 274)																	Float a11;
HXDLIN( 274)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 274)																	if ((this27 == 0)) {
HXDLIN( 274)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float r11;
HXDLIN( 274)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 274)																	if ((this28 == 0)) {
HXDLIN( 274)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float g11;
HXDLIN( 274)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 274)																	if ((this29 == 0)) {
HXDLIN( 274)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float b12;
HXDLIN( 274)																	int this30 = (this26 & 255);
HXDLIN( 274)																	if ((this30 == 0)) {
HXDLIN( 274)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float a21;
HXDLIN( 274)																	int this31 = ((color >> 24) & 255);
HXDLIN( 274)																	if ((this31 == 0)) {
HXDLIN( 274)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float r21;
HXDLIN( 274)																	int this32 = ((color >> 16) & 255);
HXDLIN( 274)																	if ((this32 == 0)) {
HXDLIN( 274)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float g21;
HXDLIN( 274)																	int this33 = ((color >> 8) & 255);
HXDLIN( 274)																	if ((this33 == 0)) {
HXDLIN( 274)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float b22;
HXDLIN( 274)																	int this34 = (color & 255);
HXDLIN( 274)																	if ((this34 == 0)) {
HXDLIN( 274)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 274)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 274)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 274)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 274)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 274)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 274)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 274)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 274)																	{
HXDLIN( 274)																		int _hx_tmp6;
HXDLIN( 274)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 274)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 274)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 274)																	::Dynamic this35 = this2->image;
HXDLIN( 274)																	int index4;
HXDLIN( 274)																	if (this2->useVirtualPos) {
HXDLIN( 274)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 274)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 274)																	int _hx_tmp7;
HXDLIN( 274)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 274)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 274)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 274)															if (found) {
HXDLIN( 274)																goto _hx_goto_523;
            															}
            														}
            													}
            												}
            												_hx_goto_523:;
            											}
            										}
            									}
HXDLIN( 274)									if ((hasHit == true)) {
HXDLIN( 274)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 274)										if (hasUndo) {
HXDLIN( 274)											v3->undoImage = undoImage;
HXDLIN( 274)											v3->undoX = xIter3->start;
HXDLIN( 274)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 274)				int _g22 = 0;
HXDLIN( 274)				int _g23 = (sides1 + 1);
HXDLIN( 274)				while((_g22 < _g23)){
HXDLIN( 274)					_g22 = (_g22 + 1);
HXDLIN( 274)					int i7 = (_g22 - 1);
HXDLIN( 274)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 274)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 274)					{
HXDLIN( 274)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 274)						bool hasHit1 = false;
HXDLIN( 274)						bool hasUndo1 = false;
HXDLIN( 274)						{
HXDLIN( 274)							Float bx1 = lastX;
HXDLIN( 274)							Float by1 = lastY;
HXDLIN( 274)							Float cx2 = nextX1;
HXDLIN( 274)							Float cy2 = nextY1;
HXDLIN( 274)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 274)							if (!(adjustWinding1)) {
HXDLIN( 274)								Float bx_1 = bx1;
HXDLIN( 274)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 274)							{
HXDLIN( 274)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 274)								Float sx1 = (cy2 - cy);
HXDLIN( 274)								Float sy1 = (cx - cx2);
HXDLIN( 274)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 274)								Float tx1 = (cy - by1);
HXDLIN( 274)								Float ty1 = (bx1 - cx);
HXDLIN( 274)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 274)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 274)								if ((cx > bx1)) {
HXDLIN( 274)									if ((cx > cx2)) {
HXDLIN( 274)										int min4;
HXDLIN( 274)										if ((bx1 > cx2)) {
HXDLIN( 274)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 274)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 274)										int ii_min8 = min4;
HXDLIN( 274)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 274)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 274)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 274)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 274)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 274)									if ((bx1 > cx2)) {
HXDLIN( 274)										int min5;
HXDLIN( 274)										if ((cx > cx2)) {
HXDLIN( 274)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 274)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 274)										int ii_min10 = min5;
HXDLIN( 274)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 274)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 274)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 274)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 274)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 274)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 274)								if ((cy > by1)) {
HXDLIN( 274)									if ((cy > cy2)) {
HXDLIN( 274)										int min6;
HXDLIN( 274)										if ((by1 > cy2)) {
HXDLIN( 274)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 274)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 274)										int ii_min12 = min6;
HXDLIN( 274)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 274)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 274)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 274)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 274)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 274)									if ((by1 > cy2)) {
HXDLIN( 274)										int min7;
HXDLIN( 274)										if ((cy > cy2)) {
HXDLIN( 274)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 274)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 274)										int ii_min14 = min7;
HXDLIN( 274)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 274)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 274)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 274)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 274)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 274)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 274)								if (hasUndo1) {
HXDLIN( 274)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 274)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 274)									 ::Dynamic imageType1 = null();
HXDLIN( 274)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 274)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 274)									::Dynamic undoImage4;
HXDLIN( 274)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 274)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 274)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 274)											{
HXDLIN( 274)												b5->width = width1;
HXDLIN( 274)												b5->height = height1;
HXDLIN( 274)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 274)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 274)												{
HXDLIN( 274)													int len2 = b5->length;
HXDLIN( 274)													int w1 = 0;
HXDLIN( 274)													{
HXDLIN( 274)														int _g24 = 0;
HXDLIN( 274)														int _g25 = b5->height;
HXDLIN( 274)														while((_g24 < _g25)){
HXDLIN( 274)															_g24 = (_g24 + 1);
HXDLIN( 274)															int y4 = (_g24 - 1);
HXDLIN( 274)															{
HXDLIN( 274)																int _g26 = 0;
HXDLIN( 274)																int _g27 = b5->width;
HXDLIN( 274)																while((_g26 < _g27)){
HXDLIN( 274)																	_g26 = (_g26 + 1);
HXDLIN( 274)																	int x4 = (_g26 - 1);
HXDLIN( 274)																	{
HXDLIN( 274)																		w1 = (w1 + 1);
HXDLIN( 274)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 274)																	{
HXDLIN( 274)																		w1 = (w1 + 1);
HXDLIN( 274)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 274)																	{
HXDLIN( 274)																		w1 = (w1 + 1);
HXDLIN( 274)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 274)																	{
HXDLIN( 274)																		w1 = (w1 + 1);
HXDLIN( 274)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 274)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 274)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 274)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 274)											{
HXDLIN( 274)												a6->width = width1;
HXDLIN( 274)												a6->height = height1;
HXDLIN( 274)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 274)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 274)												{
HXDLIN( 274)													int _g28 = 0;
HXDLIN( 274)													int _g29 = a6->length;
HXDLIN( 274)													while((_g28 < _g29)){
HXDLIN( 274)														_g28 = (_g28 + 1);
HXDLIN( 274)														int i8 = (_g28 - 1);
HXDLIN( 274)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 274)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 274)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 274)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 274)											{
HXDLIN( 274)												b6->width = width1;
HXDLIN( 274)												b6->height = height1;
HXDLIN( 274)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 274)												int size1 = (b6->length * 4);
HXDLIN( 274)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 274)												{
HXDLIN( 274)													int _g30 = 0;
HXDLIN( 274)													int _g31 = b6->length;
HXDLIN( 274)													while((_g30 < _g31)){
HXDLIN( 274)														_g30 = (_g30 + 1);
HXDLIN( 274)														int i9 = (_g30 - 1);
HXDLIN( 274)														{
HXDLIN( 274)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 274)															bool undoImage5;
HXDLIN( 274)															if ((i9 >= 0)) {
HXDLIN( 274)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 274)																undoImage5 = false;
            															}
HXDLIN( 274)															if (undoImage5) {
HXDLIN( 274)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 274)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 274)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 274)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 274)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 274)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 274)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 274)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 274)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 274)											{
HXDLIN( 274)												v4->width = width1;
HXDLIN( 274)												v4->height = height1;
HXDLIN( 274)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 274)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 274)												{
HXDLIN( 274)													int _g32 = 0;
HXDLIN( 274)													int _g33 = v4->length;
HXDLIN( 274)													while((_g32 < _g33)){
HXDLIN( 274)														_g32 = (_g32 + 1);
HXDLIN( 274)														int i10 = (_g32 - 1);
HXDLIN( 274)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 274)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 274)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 274)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 274)											{
HXDLIN( 274)												b7->width = width1;
HXDLIN( 274)												b7->height = height1;
HXDLIN( 274)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 274)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 274)												{
HXDLIN( 274)													int len3 = b7->length;
HXDLIN( 274)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 274)													if (::hx::IsNull( d1->head )) {
HXDLIN( 274)														int _g34 = 0;
HXDLIN( 274)														int _g35 = len3;
HXDLIN( 274)														while((_g34 < _g35)){
HXDLIN( 274)															_g34 = (_g34 + 1);
HXDLIN( 274)															int i11 = (_g34 - 1);
HXDLIN( 274)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 274)														int _g36 = 0;
HXDLIN( 274)														int _g37 = len3;
HXDLIN( 274)														while((_g36 < _g37)){
HXDLIN( 274)															_g36 = (_g36 + 1);
HXDLIN( 274)															int i12 = (_g36 - 1);
HXDLIN( 274)															{
HXDLIN( 274)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 274)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 274)																{
HXDLIN( 274)																	int _g38 = 0;
HXDLIN( 274)																	int _g39 = i12;
HXDLIN( 274)																	while((_g38 < _g39)){
HXDLIN( 274)																		_g38 = (_g38 + 1);
HXDLIN( 274)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 274)																if (::hx::IsNull( prev1 )) {
HXDLIN( 274)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 274)																	l1 = null();
            																}
            																else {
HXDLIN( 274)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 274)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 274)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 274)									this37->image = undoImage4;
HXDLIN( 274)									this37->width = width1;
HXDLIN( 274)									this37->height = height1;
HXDLIN( 274)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 274)									undoImage3 = this37;
HXDLIN( 274)									{
HXDLIN( 274)										int rectLeft1 = xIter31->start;
HXDLIN( 274)										int rectTop1 = yIter31->start;
HXDLIN( 274)										int rectRight1 = xIter31->max;
HXDLIN( 274)										bool forceClear1 = false;
HXDLIN( 274)										{
HXDLIN( 274)											int _g40 = rectTop1;
HXDLIN( 274)											int _g41 = yIter31->max;
HXDLIN( 274)											while((_g40 < _g41)){
HXDLIN( 274)												_g40 = (_g40 + 1);
HXDLIN( 274)												int dy1 = (_g40 - 1);
HXDLIN( 274)												{
HXDLIN( 274)													int _g42 = rectLeft1;
HXDLIN( 274)													int _g43 = rectRight1;
HXDLIN( 274)													while((_g42 < _g43)){
HXDLIN( 274)														_g42 = (_g42 + 1);
HXDLIN( 274)														int dx1 = (_g42 - 1);
HXDLIN( 274)														::Dynamic this39 = this36->image;
HXDLIN( 274)														int index5;
HXDLIN( 274)														if (this36->useVirtualPos) {
HXDLIN( 274)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 274)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 274)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 274)														int col1;
HXDLIN( 274)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 274)															col1 = c4;
            														}
HXDLIN( 274)														bool _hx_tmp8;
HXDLIN( 274)														if (this36->useMask) {
HXDLIN( 274)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 274)															_hx_tmp8 = false;
            														}
HXDLIN( 274)														if (_hx_tmp8) {
HXDLIN( 274)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 274)															::Dynamic this41 = this40->image;
HXDLIN( 274)															int index6;
HXDLIN( 274)															if (this40->useVirtualPos) {
HXDLIN( 274)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 274)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 274)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 274)															int v5;
HXDLIN( 274)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 274)																v5 = c5;
            															}
HXDLIN( 274)															int maskPixel1 = v5;
HXDLIN( 274)															int this42 = col1;
HXDLIN( 274)															if ((maskPixel1 == 0)) {
HXDLIN( 274)																col1 = this42;
            															}
            															else {
HXDLIN( 274)																Float m01;
HXDLIN( 274)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 274)																if ((this43 == 0)) {
HXDLIN( 274)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float m11;
HXDLIN( 274)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 274)																if ((this44 == 0)) {
HXDLIN( 274)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float m21;
HXDLIN( 274)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 274)																if ((this45 == 0)) {
HXDLIN( 274)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float m31;
HXDLIN( 274)																int this46 = (maskPixel1 & 255);
HXDLIN( 274)																if ((this46 == 0)) {
HXDLIN( 274)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 274)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 274)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 274)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 274)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 274)														if ((col1 != 0)) {
HXDLIN( 274)															int x5 = (dx1 - rectLeft1);
HXDLIN( 274)															int y5 = (dy1 - rectTop1);
HXDLIN( 274)															int c6 = col1;
HXDLIN( 274)															bool _hx_tmp9;
HXDLIN( 274)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 274)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 274)																_hx_tmp9 = false;
            															}
HXDLIN( 274)															if (_hx_tmp9) {
HXDLIN( 274)																int location2;
HXDLIN( 274)																if (undoImage3->useVirtualPos) {
HXDLIN( 274)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 274)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 274)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 274)																int this48;
HXDLIN( 274)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 274)																	this48 = this47;
            																}
HXDLIN( 274)																Float a12;
HXDLIN( 274)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 274)																if ((this49 == 0)) {
HXDLIN( 274)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float r12;
HXDLIN( 274)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 274)																if ((this50 == 0)) {
HXDLIN( 274)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float g12;
HXDLIN( 274)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 274)																if ((this51 == 0)) {
HXDLIN( 274)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float b13;
HXDLIN( 274)																int this52 = (this48 & 255);
HXDLIN( 274)																if ((this52 == 0)) {
HXDLIN( 274)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float a22;
HXDLIN( 274)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 274)																if ((this53 == 0)) {
HXDLIN( 274)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float r22;
HXDLIN( 274)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 274)																if ((this54 == 0)) {
HXDLIN( 274)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float g22;
HXDLIN( 274)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 274)																if ((this55 == 0)) {
HXDLIN( 274)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float b23;
HXDLIN( 274)																int this56 = (col1 & 255);
HXDLIN( 274)																if ((this56 == 0)) {
HXDLIN( 274)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 274)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 274)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 274)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 274)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 274)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 274)																{
HXDLIN( 274)																	int _hx_tmp10;
HXDLIN( 274)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 274)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 274)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 274)																::Dynamic this57 = undoImage3->image;
HXDLIN( 274)																int index7;
HXDLIN( 274)																if (undoImage3->useVirtualPos) {
HXDLIN( 274)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 274)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 274)																int _hx_tmp11;
HXDLIN( 274)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 274)																	_hx_tmp11 = c6;
            																}
HXDLIN( 274)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 274)															if (forceClear1) {
HXDLIN( 274)																::Dynamic this58 = undoImage3->image;
HXDLIN( 274)																int x6 = (dx1 - rectLeft1);
HXDLIN( 274)																int y6 = (dy1 - rectTop1);
HXDLIN( 274)																int index8;
HXDLIN( 274)																if (undoImage3->useVirtualPos) {
HXDLIN( 274)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 274)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 274)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 274)								bool found1 = false;
HXDLIN( 274)								Float s1 = ((Float)0.);
HXDLIN( 274)								Float t1 = ((Float)0.);
HXDLIN( 274)								Float sxx1 = ((Float)0.);
HXDLIN( 274)								Float txx1 = ((Float)0.);
HXDLIN( 274)								{
HXDLIN( 274)									int _g_min2 = xIter31->start;
HXDLIN( 274)									int _g_max2 = xIter31->max;
HXDLIN( 274)									while((_g_min2 < _g_max2)){
HXDLIN( 274)										_g_min2 = (_g_min2 + 1);
HXDLIN( 274)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 274)										{
HXDLIN( 274)											int _g_min3 = yIter31->start;
HXDLIN( 274)											int _g_max3 = yIter31->max;
HXDLIN( 274)											while((_g_min3 < _g_max3)){
HXDLIN( 274)												_g_min3 = (_g_min3 + 1);
HXDLIN( 274)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 274)												bool _hx_tmp12;
HXDLIN( 274)												if (!((s1 <= 0))) {
HXDLIN( 274)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 274)													_hx_tmp12 = true;
            												}
HXDLIN( 274)												if (_hx_tmp12) {
HXDLIN( 274)													if (found1) {
HXDLIN( 274)														goto _hx_goto_536;
            													}
            												}
            												else {
HXDLIN( 274)													if (((s1 + t1) < A1)) {
HXDLIN( 274)														{
HXDLIN( 274)															int c7 = color;
HXDLIN( 274)															bool _hx_tmp13;
HXDLIN( 274)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 274)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 274)																_hx_tmp13 = false;
            															}
HXDLIN( 274)															if (_hx_tmp13) {
HXDLIN( 274)																int location3;
HXDLIN( 274)																if (this36->useVirtualPos) {
HXDLIN( 274)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 274)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 274)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 274)																int this60;
HXDLIN( 274)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 274)																	this60 = this59;
            																}
HXDLIN( 274)																Float a13;
HXDLIN( 274)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 274)																if ((this61 == 0)) {
HXDLIN( 274)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float r13;
HXDLIN( 274)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 274)																if ((this62 == 0)) {
HXDLIN( 274)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float g13;
HXDLIN( 274)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 274)																if ((this63 == 0)) {
HXDLIN( 274)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float b14;
HXDLIN( 274)																int this64 = (this60 & 255);
HXDLIN( 274)																if ((this64 == 0)) {
HXDLIN( 274)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float a23;
HXDLIN( 274)																int this65 = ((color >> 24) & 255);
HXDLIN( 274)																if ((this65 == 0)) {
HXDLIN( 274)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float r23;
HXDLIN( 274)																int this66 = ((color >> 16) & 255);
HXDLIN( 274)																if ((this66 == 0)) {
HXDLIN( 274)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float g23;
HXDLIN( 274)																int this67 = ((color >> 8) & 255);
HXDLIN( 274)																if ((this67 == 0)) {
HXDLIN( 274)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float b24;
HXDLIN( 274)																int this68 = (color & 255);
HXDLIN( 274)																if ((this68 == 0)) {
HXDLIN( 274)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 274)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 274)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 274)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 274)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 274)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 274)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 274)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 274)																{
HXDLIN( 274)																	int _hx_tmp14;
HXDLIN( 274)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 274)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 274)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 274)																::Dynamic this69 = this36->image;
HXDLIN( 274)																int index9;
HXDLIN( 274)																if (this36->useVirtualPos) {
HXDLIN( 274)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 274)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 274)																int _hx_tmp15;
HXDLIN( 274)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 274)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 274)																	_hx_tmp15 = c7;
            																}
HXDLIN( 274)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 274)														if (found1) {
HXDLIN( 274)															goto _hx_goto_536;
            														}
            													}
            												}
            											}
            											_hx_goto_536:;
            										}
            									}
            								}
HXDLIN( 274)								if ((hasHit1 == true)) {
HXDLIN( 274)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 274)									if (hasUndo1) {
HXDLIN( 274)										v6->undoImage = undoImage3;
HXDLIN( 274)										v6->undoX = xIter31->start;
HXDLIN( 274)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,septagon,(void))

void FillShape_Impl__obj::octagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_287_octagon)
HXDLIN( 287)		 ::Dynamic phi1 = phi;
HXDLIN( 287)		 ::Dynamic sides = 8;
HXLINE( 291)		if (::hx::IsNull( sides )) {
HXLINE( 291)			sides = 36;
            		}
HXLINE( 290)		if (::hx::IsNull( phi1 )) {
HXLINE( 290)			phi1 = ((Float)0.);
            		}
HXLINE( 287)		{
HXDLIN( 287)			 ::Dynamic phi2 = phi1;
HXDLIN( 287)			 ::Dynamic sides1 = sides;
HXDLIN( 287)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 287)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 287)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 287)			Float omega;
HXDLIN( 287)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 287)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 287)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 287)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 287)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 287)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 287)			Float lastX = ((Float)0.);
HXDLIN( 287)			Float lastY = ((Float)0.);
HXDLIN( 287)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 287)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 287)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 287)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 287)				{
HXDLIN( 287)					int _g = 0;
HXDLIN( 287)					int _g1 = (sides1 + 1);
HXDLIN( 287)					while((_g < _g1)){
HXDLIN( 287)						_g = (_g + 1);
HXDLIN( 287)						int i = (_g - 1);
HXDLIN( 287)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 287)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 287)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 287)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 287)						{
HXDLIN( 287)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 287)							bool hasHit = false;
HXDLIN( 287)							bool hasUndo = false;
HXDLIN( 287)							{
HXDLIN( 287)								Float bx = lastX;
HXDLIN( 287)								Float by = lastY;
HXDLIN( 287)								Float cx1 = nextX;
HXDLIN( 287)								Float cy1 = nextY;
HXDLIN( 287)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 287)								if (!(adjustWinding)) {
HXDLIN( 287)									Float bx_ = bx;
HXDLIN( 287)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 287)								{
HXDLIN( 287)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 287)									Float sx = (cy1 - cy);
HXDLIN( 287)									Float sy = (cx - cx1);
HXDLIN( 287)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 287)									Float tx = (cy - by);
HXDLIN( 287)									Float ty = (bx - cx);
HXDLIN( 287)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 287)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 287)									if ((cx > bx)) {
HXDLIN( 287)										if ((cx > cx1)) {
HXDLIN( 287)											int min;
HXDLIN( 287)											if ((bx > cx1)) {
HXDLIN( 287)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 287)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 287)											int ii_min = min;
HXDLIN( 287)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 287)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 287)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 287)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 287)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 287)										if ((bx > cx1)) {
HXDLIN( 287)											int min1;
HXDLIN( 287)											if ((cx > cx1)) {
HXDLIN( 287)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 287)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 287)											int ii_min2 = min1;
HXDLIN( 287)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 287)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 287)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 287)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 287)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 287)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 287)									if ((cy > by)) {
HXDLIN( 287)										if ((cy > cy1)) {
HXDLIN( 287)											int min2;
HXDLIN( 287)											if ((by > cy1)) {
HXDLIN( 287)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 287)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 287)											int ii_min4 = min2;
HXDLIN( 287)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 287)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 287)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 287)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 287)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 287)										if ((by > cy1)) {
HXDLIN( 287)											int min3;
HXDLIN( 287)											if ((cy > cy1)) {
HXDLIN( 287)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 287)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 287)											int ii_min6 = min3;
HXDLIN( 287)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 287)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 287)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 287)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 287)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 287)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 287)									if (hasUndo) {
HXDLIN( 287)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 287)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 287)										 ::Dynamic imageType = null();
HXDLIN( 287)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 287)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 287)										::Dynamic undoImage1;
HXDLIN( 287)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 287)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 287)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 287)												{
HXDLIN( 287)													b->width = width;
HXDLIN( 287)													b->height = height;
HXDLIN( 287)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 287)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 287)													{
HXDLIN( 287)														int len = b->length;
HXDLIN( 287)														int w = 0;
HXDLIN( 287)														{
HXDLIN( 287)															int _g2 = 0;
HXDLIN( 287)															int _g3 = b->height;
HXDLIN( 287)															while((_g2 < _g3)){
HXDLIN( 287)																_g2 = (_g2 + 1);
HXDLIN( 287)																int y = (_g2 - 1);
HXDLIN( 287)																{
HXDLIN( 287)																	int _g4 = 0;
HXDLIN( 287)																	int _g5 = b->width;
HXDLIN( 287)																	while((_g4 < _g5)){
HXDLIN( 287)																		_g4 = (_g4 + 1);
HXDLIN( 287)																		int x = (_g4 - 1);
HXDLIN( 287)																		{
HXDLIN( 287)																			w = (w + 1);
HXDLIN( 287)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 287)																		{
HXDLIN( 287)																			w = (w + 1);
HXDLIN( 287)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 287)																		{
HXDLIN( 287)																			w = (w + 1);
HXDLIN( 287)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 287)																		{
HXDLIN( 287)																			w = (w + 1);
HXDLIN( 287)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 287)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 287)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 287)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 287)												{
HXDLIN( 287)													a->width = width;
HXDLIN( 287)													a->height = height;
HXDLIN( 287)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 287)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 287)													{
HXDLIN( 287)														int _g6 = 0;
HXDLIN( 287)														int _g7 = a->length;
HXDLIN( 287)														while((_g6 < _g7)){
HXDLIN( 287)															_g6 = (_g6 + 1);
HXDLIN( 287)															int i1 = (_g6 - 1);
HXDLIN( 287)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 287)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 287)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 287)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 287)												{
HXDLIN( 287)													b1->width = width;
HXDLIN( 287)													b1->height = height;
HXDLIN( 287)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 287)													int size = (b1->length * 4);
HXDLIN( 287)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 287)													{
HXDLIN( 287)														int _g8 = 0;
HXDLIN( 287)														int _g9 = b1->length;
HXDLIN( 287)														while((_g8 < _g9)){
HXDLIN( 287)															_g8 = (_g8 + 1);
HXDLIN( 287)															int i2 = (_g8 - 1);
HXDLIN( 287)															{
HXDLIN( 287)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 287)																bool undoImage2;
HXDLIN( 287)																if ((i2 >= 0)) {
HXDLIN( 287)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 287)																	undoImage2 = false;
            																}
HXDLIN( 287)																if (undoImage2) {
HXDLIN( 287)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 287)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 287)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 287)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 287)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 287)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 287)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 287)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 287)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 287)												{
HXDLIN( 287)													v1->width = width;
HXDLIN( 287)													v1->height = height;
HXDLIN( 287)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 287)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 287)													{
HXDLIN( 287)														int _g10 = 0;
HXDLIN( 287)														int _g11 = v1->length;
HXDLIN( 287)														while((_g10 < _g11)){
HXDLIN( 287)															_g10 = (_g10 + 1);
HXDLIN( 287)															int i3 = (_g10 - 1);
HXDLIN( 287)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 287)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 287)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 287)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 287)												{
HXDLIN( 287)													b2->width = width;
HXDLIN( 287)													b2->height = height;
HXDLIN( 287)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 287)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 287)													{
HXDLIN( 287)														int len1 = b2->length;
HXDLIN( 287)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 287)														if (::hx::IsNull( d->head )) {
HXDLIN( 287)															int _g12 = 0;
HXDLIN( 287)															int _g13 = len1;
HXDLIN( 287)															while((_g12 < _g13)){
HXDLIN( 287)																_g12 = (_g12 + 1);
HXDLIN( 287)																int i4 = (_g12 - 1);
HXDLIN( 287)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 287)															int _g14 = 0;
HXDLIN( 287)															int _g15 = len1;
HXDLIN( 287)															while((_g14 < _g15)){
HXDLIN( 287)																_g14 = (_g14 + 1);
HXDLIN( 287)																int i5 = (_g14 - 1);
HXDLIN( 287)																{
HXDLIN( 287)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 287)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 287)																	{
HXDLIN( 287)																		int _g16 = 0;
HXDLIN( 287)																		int _g17 = i5;
HXDLIN( 287)																		while((_g16 < _g17)){
HXDLIN( 287)																			_g16 = (_g16 + 1);
HXDLIN( 287)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 287)																	if (::hx::IsNull( prev )) {
HXDLIN( 287)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 287)																		l = null();
            																	}
            																	else {
HXDLIN( 287)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 287)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 287)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 287)										this3->image = undoImage1;
HXDLIN( 287)										this3->width = width;
HXDLIN( 287)										this3->height = height;
HXDLIN( 287)										this3->imageType = ( (int)(imageType) );
HXDLIN( 287)										undoImage = this3;
HXDLIN( 287)										{
HXDLIN( 287)											int rectLeft = xIter3->start;
HXDLIN( 287)											int rectTop = yIter3->start;
HXDLIN( 287)											int rectRight = xIter3->max;
HXDLIN( 287)											bool forceClear = false;
HXDLIN( 287)											{
HXDLIN( 287)												int _g18 = rectTop;
HXDLIN( 287)												int _g19 = yIter3->max;
HXDLIN( 287)												while((_g18 < _g19)){
HXDLIN( 287)													_g18 = (_g18 + 1);
HXDLIN( 287)													int dy = (_g18 - 1);
HXDLIN( 287)													{
HXDLIN( 287)														int _g20 = rectLeft;
HXDLIN( 287)														int _g21 = rectRight;
HXDLIN( 287)														while((_g20 < _g21)){
HXDLIN( 287)															_g20 = (_g20 + 1);
HXDLIN( 287)															int dx = (_g20 - 1);
HXDLIN( 287)															::Dynamic this5 = this2->image;
HXDLIN( 287)															int index;
HXDLIN( 287)															if (this2->useVirtualPos) {
HXDLIN( 287)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 287)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 287)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 287)															int col;
HXDLIN( 287)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 287)																col = c;
            															}
HXDLIN( 287)															bool _hx_tmp;
HXDLIN( 287)															if (this2->useMask) {
HXDLIN( 287)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 287)																_hx_tmp = false;
            															}
HXDLIN( 287)															if (_hx_tmp) {
HXDLIN( 287)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 287)																::Dynamic this7 = this6->image;
HXDLIN( 287)																int index1;
HXDLIN( 287)																if (this6->useVirtualPos) {
HXDLIN( 287)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 287)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 287)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 287)																int v2;
HXDLIN( 287)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 287)																	v2 = c1;
            																}
HXDLIN( 287)																int maskPixel = v2;
HXDLIN( 287)																int this8 = col;
HXDLIN( 287)																if ((maskPixel == 0)) {
HXDLIN( 287)																	col = this8;
            																}
            																else {
HXDLIN( 287)																	Float m0;
HXDLIN( 287)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 287)																	if ((this9 == 0)) {
HXDLIN( 287)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float m1;
HXDLIN( 287)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 287)																	if ((this10 == 0)) {
HXDLIN( 287)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float m2;
HXDLIN( 287)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 287)																	if ((this11 == 0)) {
HXDLIN( 287)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float m3;
HXDLIN( 287)																	int this12 = (maskPixel & 255);
HXDLIN( 287)																	if ((this12 == 0)) {
HXDLIN( 287)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 287)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 287)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 287)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 287)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 287)															if ((col != 0)) {
HXDLIN( 287)																int x1 = (dx - rectLeft);
HXDLIN( 287)																int y1 = (dy - rectTop);
HXDLIN( 287)																int c2 = col;
HXDLIN( 287)																bool _hx_tmp1;
HXDLIN( 287)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 287)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 287)																	_hx_tmp1 = false;
            																}
HXDLIN( 287)																if (_hx_tmp1) {
HXDLIN( 287)																	int location;
HXDLIN( 287)																	if (undoImage->useVirtualPos) {
HXDLIN( 287)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 287)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 287)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 287)																	int this14;
HXDLIN( 287)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 287)																		this14 = this13;
            																	}
HXDLIN( 287)																	Float a1;
HXDLIN( 287)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 287)																	if ((this15 == 0)) {
HXDLIN( 287)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float r1;
HXDLIN( 287)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 287)																	if ((this16 == 0)) {
HXDLIN( 287)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float g1;
HXDLIN( 287)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 287)																	if ((this17 == 0)) {
HXDLIN( 287)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float b11;
HXDLIN( 287)																	int this18 = (this14 & 255);
HXDLIN( 287)																	if ((this18 == 0)) {
HXDLIN( 287)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float a2;
HXDLIN( 287)																	int this19 = ((col >> 24) & 255);
HXDLIN( 287)																	if ((this19 == 0)) {
HXDLIN( 287)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float r2;
HXDLIN( 287)																	int this20 = ((col >> 16) & 255);
HXDLIN( 287)																	if ((this20 == 0)) {
HXDLIN( 287)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float g2;
HXDLIN( 287)																	int this21 = ((col >> 8) & 255);
HXDLIN( 287)																	if ((this21 == 0)) {
HXDLIN( 287)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float b21;
HXDLIN( 287)																	int this22 = (col & 255);
HXDLIN( 287)																	if ((this22 == 0)) {
HXDLIN( 287)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 287)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 287)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 287)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 287)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 287)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 287)																	{
HXDLIN( 287)																		int _hx_tmp2;
HXDLIN( 287)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 287)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 287)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 287)																	::Dynamic this23 = undoImage->image;
HXDLIN( 287)																	int index2;
HXDLIN( 287)																	if (undoImage->useVirtualPos) {
HXDLIN( 287)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 287)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 287)																	int _hx_tmp3;
HXDLIN( 287)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 287)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 287)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 287)																if (forceClear) {
HXDLIN( 287)																	::Dynamic this24 = undoImage->image;
HXDLIN( 287)																	int x2 = (dx - rectLeft);
HXDLIN( 287)																	int y2 = (dy - rectTop);
HXDLIN( 287)																	int index3;
HXDLIN( 287)																	if (undoImage->useVirtualPos) {
HXDLIN( 287)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 287)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 287)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 287)									bool found = false;
HXDLIN( 287)									Float s = ((Float)0.);
HXDLIN( 287)									Float t = ((Float)0.);
HXDLIN( 287)									Float sxx = ((Float)0.);
HXDLIN( 287)									Float txx = ((Float)0.);
HXDLIN( 287)									{
HXDLIN( 287)										int _g_min = xIter3->start;
HXDLIN( 287)										int _g_max = xIter3->max;
HXDLIN( 287)										while((_g_min < _g_max)){
HXDLIN( 287)											_g_min = (_g_min + 1);
HXDLIN( 287)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 287)											{
HXDLIN( 287)												int _g_min1 = yIter3->start;
HXDLIN( 287)												int _g_max1 = yIter3->max;
HXDLIN( 287)												while((_g_min1 < _g_max1)){
HXDLIN( 287)													_g_min1 = (_g_min1 + 1);
HXDLIN( 287)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 287)													bool _hx_tmp4;
HXDLIN( 287)													if (!((s <= 0))) {
HXDLIN( 287)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 287)														_hx_tmp4 = true;
            													}
HXDLIN( 287)													if (_hx_tmp4) {
HXDLIN( 287)														if (found) {
HXDLIN( 287)															goto _hx_goto_550;
            														}
            													}
            													else {
HXDLIN( 287)														if (((s + t) < A)) {
HXDLIN( 287)															{
HXDLIN( 287)																int c3 = color;
HXDLIN( 287)																bool _hx_tmp5;
HXDLIN( 287)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 287)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 287)																	_hx_tmp5 = false;
            																}
HXDLIN( 287)																if (_hx_tmp5) {
HXDLIN( 287)																	int location1;
HXDLIN( 287)																	if (this2->useVirtualPos) {
HXDLIN( 287)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 287)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 287)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 287)																	int this26;
HXDLIN( 287)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 287)																		this26 = this25;
            																	}
HXDLIN( 287)																	Float a11;
HXDLIN( 287)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 287)																	if ((this27 == 0)) {
HXDLIN( 287)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float r11;
HXDLIN( 287)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 287)																	if ((this28 == 0)) {
HXDLIN( 287)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float g11;
HXDLIN( 287)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 287)																	if ((this29 == 0)) {
HXDLIN( 287)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float b12;
HXDLIN( 287)																	int this30 = (this26 & 255);
HXDLIN( 287)																	if ((this30 == 0)) {
HXDLIN( 287)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float a21;
HXDLIN( 287)																	int this31 = ((color >> 24) & 255);
HXDLIN( 287)																	if ((this31 == 0)) {
HXDLIN( 287)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float r21;
HXDLIN( 287)																	int this32 = ((color >> 16) & 255);
HXDLIN( 287)																	if ((this32 == 0)) {
HXDLIN( 287)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float g21;
HXDLIN( 287)																	int this33 = ((color >> 8) & 255);
HXDLIN( 287)																	if ((this33 == 0)) {
HXDLIN( 287)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float b22;
HXDLIN( 287)																	int this34 = (color & 255);
HXDLIN( 287)																	if ((this34 == 0)) {
HXDLIN( 287)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 287)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 287)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 287)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 287)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 287)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 287)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 287)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 287)																	{
HXDLIN( 287)																		int _hx_tmp6;
HXDLIN( 287)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 287)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 287)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 287)																	::Dynamic this35 = this2->image;
HXDLIN( 287)																	int index4;
HXDLIN( 287)																	if (this2->useVirtualPos) {
HXDLIN( 287)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 287)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 287)																	int _hx_tmp7;
HXDLIN( 287)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 287)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 287)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 287)															if (found) {
HXDLIN( 287)																goto _hx_goto_550;
            															}
            														}
            													}
            												}
            												_hx_goto_550:;
            											}
            										}
            									}
HXDLIN( 287)									if ((hasHit == true)) {
HXDLIN( 287)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 287)										if (hasUndo) {
HXDLIN( 287)											v3->undoImage = undoImage;
HXDLIN( 287)											v3->undoX = xIter3->start;
HXDLIN( 287)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 287)				int _g22 = 0;
HXDLIN( 287)				int _g23 = (sides1 + 1);
HXDLIN( 287)				while((_g22 < _g23)){
HXDLIN( 287)					_g22 = (_g22 + 1);
HXDLIN( 287)					int i7 = (_g22 - 1);
HXDLIN( 287)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 287)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 287)					{
HXDLIN( 287)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 287)						bool hasHit1 = false;
HXDLIN( 287)						bool hasUndo1 = false;
HXDLIN( 287)						{
HXDLIN( 287)							Float bx1 = lastX;
HXDLIN( 287)							Float by1 = lastY;
HXDLIN( 287)							Float cx2 = nextX1;
HXDLIN( 287)							Float cy2 = nextY1;
HXDLIN( 287)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 287)							if (!(adjustWinding1)) {
HXDLIN( 287)								Float bx_1 = bx1;
HXDLIN( 287)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 287)							{
HXDLIN( 287)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 287)								Float sx1 = (cy2 - cy);
HXDLIN( 287)								Float sy1 = (cx - cx2);
HXDLIN( 287)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 287)								Float tx1 = (cy - by1);
HXDLIN( 287)								Float ty1 = (bx1 - cx);
HXDLIN( 287)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 287)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 287)								if ((cx > bx1)) {
HXDLIN( 287)									if ((cx > cx2)) {
HXDLIN( 287)										int min4;
HXDLIN( 287)										if ((bx1 > cx2)) {
HXDLIN( 287)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 287)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 287)										int ii_min8 = min4;
HXDLIN( 287)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 287)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 287)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 287)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 287)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 287)									if ((bx1 > cx2)) {
HXDLIN( 287)										int min5;
HXDLIN( 287)										if ((cx > cx2)) {
HXDLIN( 287)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 287)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 287)										int ii_min10 = min5;
HXDLIN( 287)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 287)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 287)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 287)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 287)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 287)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 287)								if ((cy > by1)) {
HXDLIN( 287)									if ((cy > cy2)) {
HXDLIN( 287)										int min6;
HXDLIN( 287)										if ((by1 > cy2)) {
HXDLIN( 287)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 287)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 287)										int ii_min12 = min6;
HXDLIN( 287)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 287)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 287)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 287)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 287)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 287)									if ((by1 > cy2)) {
HXDLIN( 287)										int min7;
HXDLIN( 287)										if ((cy > cy2)) {
HXDLIN( 287)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 287)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 287)										int ii_min14 = min7;
HXDLIN( 287)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 287)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 287)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 287)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 287)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 287)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 287)								if (hasUndo1) {
HXDLIN( 287)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 287)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 287)									 ::Dynamic imageType1 = null();
HXDLIN( 287)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 287)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 287)									::Dynamic undoImage4;
HXDLIN( 287)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 287)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 287)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 287)											{
HXDLIN( 287)												b5->width = width1;
HXDLIN( 287)												b5->height = height1;
HXDLIN( 287)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 287)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 287)												{
HXDLIN( 287)													int len2 = b5->length;
HXDLIN( 287)													int w1 = 0;
HXDLIN( 287)													{
HXDLIN( 287)														int _g24 = 0;
HXDLIN( 287)														int _g25 = b5->height;
HXDLIN( 287)														while((_g24 < _g25)){
HXDLIN( 287)															_g24 = (_g24 + 1);
HXDLIN( 287)															int y4 = (_g24 - 1);
HXDLIN( 287)															{
HXDLIN( 287)																int _g26 = 0;
HXDLIN( 287)																int _g27 = b5->width;
HXDLIN( 287)																while((_g26 < _g27)){
HXDLIN( 287)																	_g26 = (_g26 + 1);
HXDLIN( 287)																	int x4 = (_g26 - 1);
HXDLIN( 287)																	{
HXDLIN( 287)																		w1 = (w1 + 1);
HXDLIN( 287)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 287)																	{
HXDLIN( 287)																		w1 = (w1 + 1);
HXDLIN( 287)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 287)																	{
HXDLIN( 287)																		w1 = (w1 + 1);
HXDLIN( 287)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 287)																	{
HXDLIN( 287)																		w1 = (w1 + 1);
HXDLIN( 287)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 287)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 287)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 287)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 287)											{
HXDLIN( 287)												a6->width = width1;
HXDLIN( 287)												a6->height = height1;
HXDLIN( 287)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 287)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 287)												{
HXDLIN( 287)													int _g28 = 0;
HXDLIN( 287)													int _g29 = a6->length;
HXDLIN( 287)													while((_g28 < _g29)){
HXDLIN( 287)														_g28 = (_g28 + 1);
HXDLIN( 287)														int i8 = (_g28 - 1);
HXDLIN( 287)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 287)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 287)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 287)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 287)											{
HXDLIN( 287)												b6->width = width1;
HXDLIN( 287)												b6->height = height1;
HXDLIN( 287)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 287)												int size1 = (b6->length * 4);
HXDLIN( 287)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 287)												{
HXDLIN( 287)													int _g30 = 0;
HXDLIN( 287)													int _g31 = b6->length;
HXDLIN( 287)													while((_g30 < _g31)){
HXDLIN( 287)														_g30 = (_g30 + 1);
HXDLIN( 287)														int i9 = (_g30 - 1);
HXDLIN( 287)														{
HXDLIN( 287)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 287)															bool undoImage5;
HXDLIN( 287)															if ((i9 >= 0)) {
HXDLIN( 287)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 287)																undoImage5 = false;
            															}
HXDLIN( 287)															if (undoImage5) {
HXDLIN( 287)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 287)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 287)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 287)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 287)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 287)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 287)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 287)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 287)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 287)											{
HXDLIN( 287)												v4->width = width1;
HXDLIN( 287)												v4->height = height1;
HXDLIN( 287)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 287)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 287)												{
HXDLIN( 287)													int _g32 = 0;
HXDLIN( 287)													int _g33 = v4->length;
HXDLIN( 287)													while((_g32 < _g33)){
HXDLIN( 287)														_g32 = (_g32 + 1);
HXDLIN( 287)														int i10 = (_g32 - 1);
HXDLIN( 287)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 287)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 287)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 287)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 287)											{
HXDLIN( 287)												b7->width = width1;
HXDLIN( 287)												b7->height = height1;
HXDLIN( 287)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 287)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 287)												{
HXDLIN( 287)													int len3 = b7->length;
HXDLIN( 287)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 287)													if (::hx::IsNull( d1->head )) {
HXDLIN( 287)														int _g34 = 0;
HXDLIN( 287)														int _g35 = len3;
HXDLIN( 287)														while((_g34 < _g35)){
HXDLIN( 287)															_g34 = (_g34 + 1);
HXDLIN( 287)															int i11 = (_g34 - 1);
HXDLIN( 287)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 287)														int _g36 = 0;
HXDLIN( 287)														int _g37 = len3;
HXDLIN( 287)														while((_g36 < _g37)){
HXDLIN( 287)															_g36 = (_g36 + 1);
HXDLIN( 287)															int i12 = (_g36 - 1);
HXDLIN( 287)															{
HXDLIN( 287)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 287)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 287)																{
HXDLIN( 287)																	int _g38 = 0;
HXDLIN( 287)																	int _g39 = i12;
HXDLIN( 287)																	while((_g38 < _g39)){
HXDLIN( 287)																		_g38 = (_g38 + 1);
HXDLIN( 287)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 287)																if (::hx::IsNull( prev1 )) {
HXDLIN( 287)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 287)																	l1 = null();
            																}
            																else {
HXDLIN( 287)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 287)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 287)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 287)									this37->image = undoImage4;
HXDLIN( 287)									this37->width = width1;
HXDLIN( 287)									this37->height = height1;
HXDLIN( 287)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 287)									undoImage3 = this37;
HXDLIN( 287)									{
HXDLIN( 287)										int rectLeft1 = xIter31->start;
HXDLIN( 287)										int rectTop1 = yIter31->start;
HXDLIN( 287)										int rectRight1 = xIter31->max;
HXDLIN( 287)										bool forceClear1 = false;
HXDLIN( 287)										{
HXDLIN( 287)											int _g40 = rectTop1;
HXDLIN( 287)											int _g41 = yIter31->max;
HXDLIN( 287)											while((_g40 < _g41)){
HXDLIN( 287)												_g40 = (_g40 + 1);
HXDLIN( 287)												int dy1 = (_g40 - 1);
HXDLIN( 287)												{
HXDLIN( 287)													int _g42 = rectLeft1;
HXDLIN( 287)													int _g43 = rectRight1;
HXDLIN( 287)													while((_g42 < _g43)){
HXDLIN( 287)														_g42 = (_g42 + 1);
HXDLIN( 287)														int dx1 = (_g42 - 1);
HXDLIN( 287)														::Dynamic this39 = this36->image;
HXDLIN( 287)														int index5;
HXDLIN( 287)														if (this36->useVirtualPos) {
HXDLIN( 287)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 287)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 287)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 287)														int col1;
HXDLIN( 287)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 287)															col1 = c4;
            														}
HXDLIN( 287)														bool _hx_tmp8;
HXDLIN( 287)														if (this36->useMask) {
HXDLIN( 287)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 287)															_hx_tmp8 = false;
            														}
HXDLIN( 287)														if (_hx_tmp8) {
HXDLIN( 287)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 287)															::Dynamic this41 = this40->image;
HXDLIN( 287)															int index6;
HXDLIN( 287)															if (this40->useVirtualPos) {
HXDLIN( 287)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 287)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 287)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 287)															int v5;
HXDLIN( 287)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 287)																v5 = c5;
            															}
HXDLIN( 287)															int maskPixel1 = v5;
HXDLIN( 287)															int this42 = col1;
HXDLIN( 287)															if ((maskPixel1 == 0)) {
HXDLIN( 287)																col1 = this42;
            															}
            															else {
HXDLIN( 287)																Float m01;
HXDLIN( 287)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 287)																if ((this43 == 0)) {
HXDLIN( 287)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float m11;
HXDLIN( 287)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 287)																if ((this44 == 0)) {
HXDLIN( 287)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float m21;
HXDLIN( 287)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 287)																if ((this45 == 0)) {
HXDLIN( 287)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float m31;
HXDLIN( 287)																int this46 = (maskPixel1 & 255);
HXDLIN( 287)																if ((this46 == 0)) {
HXDLIN( 287)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 287)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 287)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 287)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 287)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 287)														if ((col1 != 0)) {
HXDLIN( 287)															int x5 = (dx1 - rectLeft1);
HXDLIN( 287)															int y5 = (dy1 - rectTop1);
HXDLIN( 287)															int c6 = col1;
HXDLIN( 287)															bool _hx_tmp9;
HXDLIN( 287)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 287)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 287)																_hx_tmp9 = false;
            															}
HXDLIN( 287)															if (_hx_tmp9) {
HXDLIN( 287)																int location2;
HXDLIN( 287)																if (undoImage3->useVirtualPos) {
HXDLIN( 287)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 287)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 287)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 287)																int this48;
HXDLIN( 287)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 287)																	this48 = this47;
            																}
HXDLIN( 287)																Float a12;
HXDLIN( 287)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 287)																if ((this49 == 0)) {
HXDLIN( 287)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float r12;
HXDLIN( 287)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 287)																if ((this50 == 0)) {
HXDLIN( 287)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float g12;
HXDLIN( 287)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 287)																if ((this51 == 0)) {
HXDLIN( 287)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float b13;
HXDLIN( 287)																int this52 = (this48 & 255);
HXDLIN( 287)																if ((this52 == 0)) {
HXDLIN( 287)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float a22;
HXDLIN( 287)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 287)																if ((this53 == 0)) {
HXDLIN( 287)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float r22;
HXDLIN( 287)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 287)																if ((this54 == 0)) {
HXDLIN( 287)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float g22;
HXDLIN( 287)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 287)																if ((this55 == 0)) {
HXDLIN( 287)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float b23;
HXDLIN( 287)																int this56 = (col1 & 255);
HXDLIN( 287)																if ((this56 == 0)) {
HXDLIN( 287)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 287)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 287)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 287)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 287)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 287)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 287)																{
HXDLIN( 287)																	int _hx_tmp10;
HXDLIN( 287)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 287)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 287)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 287)																::Dynamic this57 = undoImage3->image;
HXDLIN( 287)																int index7;
HXDLIN( 287)																if (undoImage3->useVirtualPos) {
HXDLIN( 287)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 287)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 287)																int _hx_tmp11;
HXDLIN( 287)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 287)																	_hx_tmp11 = c6;
            																}
HXDLIN( 287)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 287)															if (forceClear1) {
HXDLIN( 287)																::Dynamic this58 = undoImage3->image;
HXDLIN( 287)																int x6 = (dx1 - rectLeft1);
HXDLIN( 287)																int y6 = (dy1 - rectTop1);
HXDLIN( 287)																int index8;
HXDLIN( 287)																if (undoImage3->useVirtualPos) {
HXDLIN( 287)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 287)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 287)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 287)								bool found1 = false;
HXDLIN( 287)								Float s1 = ((Float)0.);
HXDLIN( 287)								Float t1 = ((Float)0.);
HXDLIN( 287)								Float sxx1 = ((Float)0.);
HXDLIN( 287)								Float txx1 = ((Float)0.);
HXDLIN( 287)								{
HXDLIN( 287)									int _g_min2 = xIter31->start;
HXDLIN( 287)									int _g_max2 = xIter31->max;
HXDLIN( 287)									while((_g_min2 < _g_max2)){
HXDLIN( 287)										_g_min2 = (_g_min2 + 1);
HXDLIN( 287)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 287)										{
HXDLIN( 287)											int _g_min3 = yIter31->start;
HXDLIN( 287)											int _g_max3 = yIter31->max;
HXDLIN( 287)											while((_g_min3 < _g_max3)){
HXDLIN( 287)												_g_min3 = (_g_min3 + 1);
HXDLIN( 287)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 287)												bool _hx_tmp12;
HXDLIN( 287)												if (!((s1 <= 0))) {
HXDLIN( 287)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 287)													_hx_tmp12 = true;
            												}
HXDLIN( 287)												if (_hx_tmp12) {
HXDLIN( 287)													if (found1) {
HXDLIN( 287)														goto _hx_goto_563;
            													}
            												}
            												else {
HXDLIN( 287)													if (((s1 + t1) < A1)) {
HXDLIN( 287)														{
HXDLIN( 287)															int c7 = color;
HXDLIN( 287)															bool _hx_tmp13;
HXDLIN( 287)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 287)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 287)																_hx_tmp13 = false;
            															}
HXDLIN( 287)															if (_hx_tmp13) {
HXDLIN( 287)																int location3;
HXDLIN( 287)																if (this36->useVirtualPos) {
HXDLIN( 287)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 287)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 287)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 287)																int this60;
HXDLIN( 287)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 287)																	this60 = this59;
            																}
HXDLIN( 287)																Float a13;
HXDLIN( 287)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 287)																if ((this61 == 0)) {
HXDLIN( 287)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float r13;
HXDLIN( 287)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 287)																if ((this62 == 0)) {
HXDLIN( 287)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float g13;
HXDLIN( 287)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 287)																if ((this63 == 0)) {
HXDLIN( 287)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float b14;
HXDLIN( 287)																int this64 = (this60 & 255);
HXDLIN( 287)																if ((this64 == 0)) {
HXDLIN( 287)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float a23;
HXDLIN( 287)																int this65 = ((color >> 24) & 255);
HXDLIN( 287)																if ((this65 == 0)) {
HXDLIN( 287)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float r23;
HXDLIN( 287)																int this66 = ((color >> 16) & 255);
HXDLIN( 287)																if ((this66 == 0)) {
HXDLIN( 287)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float g23;
HXDLIN( 287)																int this67 = ((color >> 8) & 255);
HXDLIN( 287)																if ((this67 == 0)) {
HXDLIN( 287)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float b24;
HXDLIN( 287)																int this68 = (color & 255);
HXDLIN( 287)																if ((this68 == 0)) {
HXDLIN( 287)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 287)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 287)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 287)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 287)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 287)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 287)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 287)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 287)																{
HXDLIN( 287)																	int _hx_tmp14;
HXDLIN( 287)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 287)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 287)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 287)																::Dynamic this69 = this36->image;
HXDLIN( 287)																int index9;
HXDLIN( 287)																if (this36->useVirtualPos) {
HXDLIN( 287)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 287)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 287)																int _hx_tmp15;
HXDLIN( 287)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 287)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 287)																	_hx_tmp15 = c7;
            																}
HXDLIN( 287)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 287)														if (found1) {
HXDLIN( 287)															goto _hx_goto_563;
            														}
            													}
            												}
            											}
            											_hx_goto_563:;
            										}
            									}
            								}
HXDLIN( 287)								if ((hasHit1 == true)) {
HXDLIN( 287)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 287)									if (hasUndo1) {
HXDLIN( 287)										v6->undoImage = undoImage3;
HXDLIN( 287)										v6->undoX = xIter31->start;
HXDLIN( 287)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,octagon,(void))

void FillShape_Impl__obj::nonagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_300_nonagon)
HXDLIN( 300)		 ::Dynamic phi1 = phi;
HXDLIN( 300)		 ::Dynamic sides = 9;
HXLINE( 304)		if (::hx::IsNull( sides )) {
HXLINE( 304)			sides = 36;
            		}
HXLINE( 303)		if (::hx::IsNull( phi1 )) {
HXLINE( 303)			phi1 = ((Float)0.);
            		}
HXLINE( 300)		{
HXDLIN( 300)			 ::Dynamic phi2 = phi1;
HXDLIN( 300)			 ::Dynamic sides1 = sides;
HXDLIN( 300)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 300)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 300)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 300)			Float omega;
HXDLIN( 300)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 300)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 300)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 300)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 300)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 300)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 300)			Float lastX = ((Float)0.);
HXDLIN( 300)			Float lastY = ((Float)0.);
HXDLIN( 300)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 300)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 300)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 300)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 300)				{
HXDLIN( 300)					int _g = 0;
HXDLIN( 300)					int _g1 = (sides1 + 1);
HXDLIN( 300)					while((_g < _g1)){
HXDLIN( 300)						_g = (_g + 1);
HXDLIN( 300)						int i = (_g - 1);
HXDLIN( 300)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 300)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 300)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 300)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 300)						{
HXDLIN( 300)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 300)							bool hasHit = false;
HXDLIN( 300)							bool hasUndo = false;
HXDLIN( 300)							{
HXDLIN( 300)								Float bx = lastX;
HXDLIN( 300)								Float by = lastY;
HXDLIN( 300)								Float cx1 = nextX;
HXDLIN( 300)								Float cy1 = nextY;
HXDLIN( 300)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 300)								if (!(adjustWinding)) {
HXDLIN( 300)									Float bx_ = bx;
HXDLIN( 300)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 300)								{
HXDLIN( 300)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 300)									Float sx = (cy1 - cy);
HXDLIN( 300)									Float sy = (cx - cx1);
HXDLIN( 300)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 300)									Float tx = (cy - by);
HXDLIN( 300)									Float ty = (bx - cx);
HXDLIN( 300)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 300)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 300)									if ((cx > bx)) {
HXDLIN( 300)										if ((cx > cx1)) {
HXDLIN( 300)											int min;
HXDLIN( 300)											if ((bx > cx1)) {
HXDLIN( 300)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 300)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 300)											int ii_min = min;
HXDLIN( 300)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 300)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 300)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 300)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 300)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 300)										if ((bx > cx1)) {
HXDLIN( 300)											int min1;
HXDLIN( 300)											if ((cx > cx1)) {
HXDLIN( 300)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 300)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 300)											int ii_min2 = min1;
HXDLIN( 300)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 300)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 300)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 300)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 300)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 300)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 300)									if ((cy > by)) {
HXDLIN( 300)										if ((cy > cy1)) {
HXDLIN( 300)											int min2;
HXDLIN( 300)											if ((by > cy1)) {
HXDLIN( 300)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 300)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 300)											int ii_min4 = min2;
HXDLIN( 300)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 300)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 300)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 300)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 300)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 300)										if ((by > cy1)) {
HXDLIN( 300)											int min3;
HXDLIN( 300)											if ((cy > cy1)) {
HXDLIN( 300)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 300)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 300)											int ii_min6 = min3;
HXDLIN( 300)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 300)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 300)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 300)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 300)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 300)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 300)									if (hasUndo) {
HXDLIN( 300)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 300)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 300)										 ::Dynamic imageType = null();
HXDLIN( 300)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 300)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 300)										::Dynamic undoImage1;
HXDLIN( 300)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 300)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 300)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 300)												{
HXDLIN( 300)													b->width = width;
HXDLIN( 300)													b->height = height;
HXDLIN( 300)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 300)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 300)													{
HXDLIN( 300)														int len = b->length;
HXDLIN( 300)														int w = 0;
HXDLIN( 300)														{
HXDLIN( 300)															int _g2 = 0;
HXDLIN( 300)															int _g3 = b->height;
HXDLIN( 300)															while((_g2 < _g3)){
HXDLIN( 300)																_g2 = (_g2 + 1);
HXDLIN( 300)																int y = (_g2 - 1);
HXDLIN( 300)																{
HXDLIN( 300)																	int _g4 = 0;
HXDLIN( 300)																	int _g5 = b->width;
HXDLIN( 300)																	while((_g4 < _g5)){
HXDLIN( 300)																		_g4 = (_g4 + 1);
HXDLIN( 300)																		int x = (_g4 - 1);
HXDLIN( 300)																		{
HXDLIN( 300)																			w = (w + 1);
HXDLIN( 300)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 300)																		{
HXDLIN( 300)																			w = (w + 1);
HXDLIN( 300)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 300)																		{
HXDLIN( 300)																			w = (w + 1);
HXDLIN( 300)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 300)																		{
HXDLIN( 300)																			w = (w + 1);
HXDLIN( 300)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 300)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 300)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 300)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 300)												{
HXDLIN( 300)													a->width = width;
HXDLIN( 300)													a->height = height;
HXDLIN( 300)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 300)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 300)													{
HXDLIN( 300)														int _g6 = 0;
HXDLIN( 300)														int _g7 = a->length;
HXDLIN( 300)														while((_g6 < _g7)){
HXDLIN( 300)															_g6 = (_g6 + 1);
HXDLIN( 300)															int i1 = (_g6 - 1);
HXDLIN( 300)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 300)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 300)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 300)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 300)												{
HXDLIN( 300)													b1->width = width;
HXDLIN( 300)													b1->height = height;
HXDLIN( 300)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 300)													int size = (b1->length * 4);
HXDLIN( 300)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 300)													{
HXDLIN( 300)														int _g8 = 0;
HXDLIN( 300)														int _g9 = b1->length;
HXDLIN( 300)														while((_g8 < _g9)){
HXDLIN( 300)															_g8 = (_g8 + 1);
HXDLIN( 300)															int i2 = (_g8 - 1);
HXDLIN( 300)															{
HXDLIN( 300)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 300)																bool undoImage2;
HXDLIN( 300)																if ((i2 >= 0)) {
HXDLIN( 300)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 300)																	undoImage2 = false;
            																}
HXDLIN( 300)																if (undoImage2) {
HXDLIN( 300)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 300)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 300)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 300)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 300)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 300)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 300)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 300)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 300)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 300)												{
HXDLIN( 300)													v1->width = width;
HXDLIN( 300)													v1->height = height;
HXDLIN( 300)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 300)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 300)													{
HXDLIN( 300)														int _g10 = 0;
HXDLIN( 300)														int _g11 = v1->length;
HXDLIN( 300)														while((_g10 < _g11)){
HXDLIN( 300)															_g10 = (_g10 + 1);
HXDLIN( 300)															int i3 = (_g10 - 1);
HXDLIN( 300)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 300)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 300)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 300)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 300)												{
HXDLIN( 300)													b2->width = width;
HXDLIN( 300)													b2->height = height;
HXDLIN( 300)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 300)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 300)													{
HXDLIN( 300)														int len1 = b2->length;
HXDLIN( 300)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 300)														if (::hx::IsNull( d->head )) {
HXDLIN( 300)															int _g12 = 0;
HXDLIN( 300)															int _g13 = len1;
HXDLIN( 300)															while((_g12 < _g13)){
HXDLIN( 300)																_g12 = (_g12 + 1);
HXDLIN( 300)																int i4 = (_g12 - 1);
HXDLIN( 300)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 300)															int _g14 = 0;
HXDLIN( 300)															int _g15 = len1;
HXDLIN( 300)															while((_g14 < _g15)){
HXDLIN( 300)																_g14 = (_g14 + 1);
HXDLIN( 300)																int i5 = (_g14 - 1);
HXDLIN( 300)																{
HXDLIN( 300)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 300)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 300)																	{
HXDLIN( 300)																		int _g16 = 0;
HXDLIN( 300)																		int _g17 = i5;
HXDLIN( 300)																		while((_g16 < _g17)){
HXDLIN( 300)																			_g16 = (_g16 + 1);
HXDLIN( 300)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 300)																	if (::hx::IsNull( prev )) {
HXDLIN( 300)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 300)																		l = null();
            																	}
            																	else {
HXDLIN( 300)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 300)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 300)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 300)										this3->image = undoImage1;
HXDLIN( 300)										this3->width = width;
HXDLIN( 300)										this3->height = height;
HXDLIN( 300)										this3->imageType = ( (int)(imageType) );
HXDLIN( 300)										undoImage = this3;
HXDLIN( 300)										{
HXDLIN( 300)											int rectLeft = xIter3->start;
HXDLIN( 300)											int rectTop = yIter3->start;
HXDLIN( 300)											int rectRight = xIter3->max;
HXDLIN( 300)											bool forceClear = false;
HXDLIN( 300)											{
HXDLIN( 300)												int _g18 = rectTop;
HXDLIN( 300)												int _g19 = yIter3->max;
HXDLIN( 300)												while((_g18 < _g19)){
HXDLIN( 300)													_g18 = (_g18 + 1);
HXDLIN( 300)													int dy = (_g18 - 1);
HXDLIN( 300)													{
HXDLIN( 300)														int _g20 = rectLeft;
HXDLIN( 300)														int _g21 = rectRight;
HXDLIN( 300)														while((_g20 < _g21)){
HXDLIN( 300)															_g20 = (_g20 + 1);
HXDLIN( 300)															int dx = (_g20 - 1);
HXDLIN( 300)															::Dynamic this5 = this2->image;
HXDLIN( 300)															int index;
HXDLIN( 300)															if (this2->useVirtualPos) {
HXDLIN( 300)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 300)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 300)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 300)															int col;
HXDLIN( 300)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 300)																col = c;
            															}
HXDLIN( 300)															bool _hx_tmp;
HXDLIN( 300)															if (this2->useMask) {
HXDLIN( 300)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 300)																_hx_tmp = false;
            															}
HXDLIN( 300)															if (_hx_tmp) {
HXDLIN( 300)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 300)																::Dynamic this7 = this6->image;
HXDLIN( 300)																int index1;
HXDLIN( 300)																if (this6->useVirtualPos) {
HXDLIN( 300)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 300)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 300)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 300)																int v2;
HXDLIN( 300)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 300)																	v2 = c1;
            																}
HXDLIN( 300)																int maskPixel = v2;
HXDLIN( 300)																int this8 = col;
HXDLIN( 300)																if ((maskPixel == 0)) {
HXDLIN( 300)																	col = this8;
            																}
            																else {
HXDLIN( 300)																	Float m0;
HXDLIN( 300)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 300)																	if ((this9 == 0)) {
HXDLIN( 300)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float m1;
HXDLIN( 300)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 300)																	if ((this10 == 0)) {
HXDLIN( 300)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float m2;
HXDLIN( 300)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 300)																	if ((this11 == 0)) {
HXDLIN( 300)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float m3;
HXDLIN( 300)																	int this12 = (maskPixel & 255);
HXDLIN( 300)																	if ((this12 == 0)) {
HXDLIN( 300)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 300)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 300)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 300)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 300)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 300)															if ((col != 0)) {
HXDLIN( 300)																int x1 = (dx - rectLeft);
HXDLIN( 300)																int y1 = (dy - rectTop);
HXDLIN( 300)																int c2 = col;
HXDLIN( 300)																bool _hx_tmp1;
HXDLIN( 300)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 300)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 300)																	_hx_tmp1 = false;
            																}
HXDLIN( 300)																if (_hx_tmp1) {
HXDLIN( 300)																	int location;
HXDLIN( 300)																	if (undoImage->useVirtualPos) {
HXDLIN( 300)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 300)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 300)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 300)																	int this14;
HXDLIN( 300)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 300)																		this14 = this13;
            																	}
HXDLIN( 300)																	Float a1;
HXDLIN( 300)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 300)																	if ((this15 == 0)) {
HXDLIN( 300)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float r1;
HXDLIN( 300)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 300)																	if ((this16 == 0)) {
HXDLIN( 300)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float g1;
HXDLIN( 300)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 300)																	if ((this17 == 0)) {
HXDLIN( 300)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float b11;
HXDLIN( 300)																	int this18 = (this14 & 255);
HXDLIN( 300)																	if ((this18 == 0)) {
HXDLIN( 300)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float a2;
HXDLIN( 300)																	int this19 = ((col >> 24) & 255);
HXDLIN( 300)																	if ((this19 == 0)) {
HXDLIN( 300)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float r2;
HXDLIN( 300)																	int this20 = ((col >> 16) & 255);
HXDLIN( 300)																	if ((this20 == 0)) {
HXDLIN( 300)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float g2;
HXDLIN( 300)																	int this21 = ((col >> 8) & 255);
HXDLIN( 300)																	if ((this21 == 0)) {
HXDLIN( 300)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float b21;
HXDLIN( 300)																	int this22 = (col & 255);
HXDLIN( 300)																	if ((this22 == 0)) {
HXDLIN( 300)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 300)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 300)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 300)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 300)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 300)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 300)																	{
HXDLIN( 300)																		int _hx_tmp2;
HXDLIN( 300)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 300)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 300)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 300)																	::Dynamic this23 = undoImage->image;
HXDLIN( 300)																	int index2;
HXDLIN( 300)																	if (undoImage->useVirtualPos) {
HXDLIN( 300)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 300)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 300)																	int _hx_tmp3;
HXDLIN( 300)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 300)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 300)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 300)																if (forceClear) {
HXDLIN( 300)																	::Dynamic this24 = undoImage->image;
HXDLIN( 300)																	int x2 = (dx - rectLeft);
HXDLIN( 300)																	int y2 = (dy - rectTop);
HXDLIN( 300)																	int index3;
HXDLIN( 300)																	if (undoImage->useVirtualPos) {
HXDLIN( 300)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 300)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 300)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 300)									bool found = false;
HXDLIN( 300)									Float s = ((Float)0.);
HXDLIN( 300)									Float t = ((Float)0.);
HXDLIN( 300)									Float sxx = ((Float)0.);
HXDLIN( 300)									Float txx = ((Float)0.);
HXDLIN( 300)									{
HXDLIN( 300)										int _g_min = xIter3->start;
HXDLIN( 300)										int _g_max = xIter3->max;
HXDLIN( 300)										while((_g_min < _g_max)){
HXDLIN( 300)											_g_min = (_g_min + 1);
HXDLIN( 300)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 300)											{
HXDLIN( 300)												int _g_min1 = yIter3->start;
HXDLIN( 300)												int _g_max1 = yIter3->max;
HXDLIN( 300)												while((_g_min1 < _g_max1)){
HXDLIN( 300)													_g_min1 = (_g_min1 + 1);
HXDLIN( 300)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 300)													bool _hx_tmp4;
HXDLIN( 300)													if (!((s <= 0))) {
HXDLIN( 300)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 300)														_hx_tmp4 = true;
            													}
HXDLIN( 300)													if (_hx_tmp4) {
HXDLIN( 300)														if (found) {
HXDLIN( 300)															goto _hx_goto_577;
            														}
            													}
            													else {
HXDLIN( 300)														if (((s + t) < A)) {
HXDLIN( 300)															{
HXDLIN( 300)																int c3 = color;
HXDLIN( 300)																bool _hx_tmp5;
HXDLIN( 300)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 300)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 300)																	_hx_tmp5 = false;
            																}
HXDLIN( 300)																if (_hx_tmp5) {
HXDLIN( 300)																	int location1;
HXDLIN( 300)																	if (this2->useVirtualPos) {
HXDLIN( 300)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 300)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 300)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 300)																	int this26;
HXDLIN( 300)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 300)																		this26 = this25;
            																	}
HXDLIN( 300)																	Float a11;
HXDLIN( 300)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 300)																	if ((this27 == 0)) {
HXDLIN( 300)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float r11;
HXDLIN( 300)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 300)																	if ((this28 == 0)) {
HXDLIN( 300)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float g11;
HXDLIN( 300)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 300)																	if ((this29 == 0)) {
HXDLIN( 300)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float b12;
HXDLIN( 300)																	int this30 = (this26 & 255);
HXDLIN( 300)																	if ((this30 == 0)) {
HXDLIN( 300)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float a21;
HXDLIN( 300)																	int this31 = ((color >> 24) & 255);
HXDLIN( 300)																	if ((this31 == 0)) {
HXDLIN( 300)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float r21;
HXDLIN( 300)																	int this32 = ((color >> 16) & 255);
HXDLIN( 300)																	if ((this32 == 0)) {
HXDLIN( 300)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float g21;
HXDLIN( 300)																	int this33 = ((color >> 8) & 255);
HXDLIN( 300)																	if ((this33 == 0)) {
HXDLIN( 300)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float b22;
HXDLIN( 300)																	int this34 = (color & 255);
HXDLIN( 300)																	if ((this34 == 0)) {
HXDLIN( 300)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 300)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 300)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 300)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 300)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 300)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 300)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 300)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 300)																	{
HXDLIN( 300)																		int _hx_tmp6;
HXDLIN( 300)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 300)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 300)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 300)																	::Dynamic this35 = this2->image;
HXDLIN( 300)																	int index4;
HXDLIN( 300)																	if (this2->useVirtualPos) {
HXDLIN( 300)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 300)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 300)																	int _hx_tmp7;
HXDLIN( 300)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 300)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 300)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 300)															if (found) {
HXDLIN( 300)																goto _hx_goto_577;
            															}
            														}
            													}
            												}
            												_hx_goto_577:;
            											}
            										}
            									}
HXDLIN( 300)									if ((hasHit == true)) {
HXDLIN( 300)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 300)										if (hasUndo) {
HXDLIN( 300)											v3->undoImage = undoImage;
HXDLIN( 300)											v3->undoX = xIter3->start;
HXDLIN( 300)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 300)				int _g22 = 0;
HXDLIN( 300)				int _g23 = (sides1 + 1);
HXDLIN( 300)				while((_g22 < _g23)){
HXDLIN( 300)					_g22 = (_g22 + 1);
HXDLIN( 300)					int i7 = (_g22 - 1);
HXDLIN( 300)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 300)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 300)					{
HXDLIN( 300)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 300)						bool hasHit1 = false;
HXDLIN( 300)						bool hasUndo1 = false;
HXDLIN( 300)						{
HXDLIN( 300)							Float bx1 = lastX;
HXDLIN( 300)							Float by1 = lastY;
HXDLIN( 300)							Float cx2 = nextX1;
HXDLIN( 300)							Float cy2 = nextY1;
HXDLIN( 300)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 300)							if (!(adjustWinding1)) {
HXDLIN( 300)								Float bx_1 = bx1;
HXDLIN( 300)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 300)							{
HXDLIN( 300)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 300)								Float sx1 = (cy2 - cy);
HXDLIN( 300)								Float sy1 = (cx - cx2);
HXDLIN( 300)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 300)								Float tx1 = (cy - by1);
HXDLIN( 300)								Float ty1 = (bx1 - cx);
HXDLIN( 300)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 300)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 300)								if ((cx > bx1)) {
HXDLIN( 300)									if ((cx > cx2)) {
HXDLIN( 300)										int min4;
HXDLIN( 300)										if ((bx1 > cx2)) {
HXDLIN( 300)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 300)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 300)										int ii_min8 = min4;
HXDLIN( 300)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 300)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 300)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 300)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 300)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 300)									if ((bx1 > cx2)) {
HXDLIN( 300)										int min5;
HXDLIN( 300)										if ((cx > cx2)) {
HXDLIN( 300)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 300)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 300)										int ii_min10 = min5;
HXDLIN( 300)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 300)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 300)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 300)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 300)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 300)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 300)								if ((cy > by1)) {
HXDLIN( 300)									if ((cy > cy2)) {
HXDLIN( 300)										int min6;
HXDLIN( 300)										if ((by1 > cy2)) {
HXDLIN( 300)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 300)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 300)										int ii_min12 = min6;
HXDLIN( 300)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 300)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 300)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 300)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 300)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 300)									if ((by1 > cy2)) {
HXDLIN( 300)										int min7;
HXDLIN( 300)										if ((cy > cy2)) {
HXDLIN( 300)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 300)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 300)										int ii_min14 = min7;
HXDLIN( 300)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 300)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 300)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 300)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 300)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 300)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 300)								if (hasUndo1) {
HXDLIN( 300)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 300)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 300)									 ::Dynamic imageType1 = null();
HXDLIN( 300)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 300)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 300)									::Dynamic undoImage4;
HXDLIN( 300)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 300)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 300)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 300)											{
HXDLIN( 300)												b5->width = width1;
HXDLIN( 300)												b5->height = height1;
HXDLIN( 300)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 300)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 300)												{
HXDLIN( 300)													int len2 = b5->length;
HXDLIN( 300)													int w1 = 0;
HXDLIN( 300)													{
HXDLIN( 300)														int _g24 = 0;
HXDLIN( 300)														int _g25 = b5->height;
HXDLIN( 300)														while((_g24 < _g25)){
HXDLIN( 300)															_g24 = (_g24 + 1);
HXDLIN( 300)															int y4 = (_g24 - 1);
HXDLIN( 300)															{
HXDLIN( 300)																int _g26 = 0;
HXDLIN( 300)																int _g27 = b5->width;
HXDLIN( 300)																while((_g26 < _g27)){
HXDLIN( 300)																	_g26 = (_g26 + 1);
HXDLIN( 300)																	int x4 = (_g26 - 1);
HXDLIN( 300)																	{
HXDLIN( 300)																		w1 = (w1 + 1);
HXDLIN( 300)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 300)																	{
HXDLIN( 300)																		w1 = (w1 + 1);
HXDLIN( 300)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 300)																	{
HXDLIN( 300)																		w1 = (w1 + 1);
HXDLIN( 300)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 300)																	{
HXDLIN( 300)																		w1 = (w1 + 1);
HXDLIN( 300)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 300)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 300)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 300)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 300)											{
HXDLIN( 300)												a6->width = width1;
HXDLIN( 300)												a6->height = height1;
HXDLIN( 300)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 300)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 300)												{
HXDLIN( 300)													int _g28 = 0;
HXDLIN( 300)													int _g29 = a6->length;
HXDLIN( 300)													while((_g28 < _g29)){
HXDLIN( 300)														_g28 = (_g28 + 1);
HXDLIN( 300)														int i8 = (_g28 - 1);
HXDLIN( 300)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 300)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 300)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 300)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 300)											{
HXDLIN( 300)												b6->width = width1;
HXDLIN( 300)												b6->height = height1;
HXDLIN( 300)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 300)												int size1 = (b6->length * 4);
HXDLIN( 300)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 300)												{
HXDLIN( 300)													int _g30 = 0;
HXDLIN( 300)													int _g31 = b6->length;
HXDLIN( 300)													while((_g30 < _g31)){
HXDLIN( 300)														_g30 = (_g30 + 1);
HXDLIN( 300)														int i9 = (_g30 - 1);
HXDLIN( 300)														{
HXDLIN( 300)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 300)															bool undoImage5;
HXDLIN( 300)															if ((i9 >= 0)) {
HXDLIN( 300)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 300)																undoImage5 = false;
            															}
HXDLIN( 300)															if (undoImage5) {
HXDLIN( 300)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 300)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 300)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 300)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 300)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 300)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 300)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 300)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 300)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 300)											{
HXDLIN( 300)												v4->width = width1;
HXDLIN( 300)												v4->height = height1;
HXDLIN( 300)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 300)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 300)												{
HXDLIN( 300)													int _g32 = 0;
HXDLIN( 300)													int _g33 = v4->length;
HXDLIN( 300)													while((_g32 < _g33)){
HXDLIN( 300)														_g32 = (_g32 + 1);
HXDLIN( 300)														int i10 = (_g32 - 1);
HXDLIN( 300)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 300)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 300)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 300)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 300)											{
HXDLIN( 300)												b7->width = width1;
HXDLIN( 300)												b7->height = height1;
HXDLIN( 300)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 300)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 300)												{
HXDLIN( 300)													int len3 = b7->length;
HXDLIN( 300)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 300)													if (::hx::IsNull( d1->head )) {
HXDLIN( 300)														int _g34 = 0;
HXDLIN( 300)														int _g35 = len3;
HXDLIN( 300)														while((_g34 < _g35)){
HXDLIN( 300)															_g34 = (_g34 + 1);
HXDLIN( 300)															int i11 = (_g34 - 1);
HXDLIN( 300)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 300)														int _g36 = 0;
HXDLIN( 300)														int _g37 = len3;
HXDLIN( 300)														while((_g36 < _g37)){
HXDLIN( 300)															_g36 = (_g36 + 1);
HXDLIN( 300)															int i12 = (_g36 - 1);
HXDLIN( 300)															{
HXDLIN( 300)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 300)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 300)																{
HXDLIN( 300)																	int _g38 = 0;
HXDLIN( 300)																	int _g39 = i12;
HXDLIN( 300)																	while((_g38 < _g39)){
HXDLIN( 300)																		_g38 = (_g38 + 1);
HXDLIN( 300)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 300)																if (::hx::IsNull( prev1 )) {
HXDLIN( 300)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 300)																	l1 = null();
            																}
            																else {
HXDLIN( 300)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 300)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 300)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 300)									this37->image = undoImage4;
HXDLIN( 300)									this37->width = width1;
HXDLIN( 300)									this37->height = height1;
HXDLIN( 300)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 300)									undoImage3 = this37;
HXDLIN( 300)									{
HXDLIN( 300)										int rectLeft1 = xIter31->start;
HXDLIN( 300)										int rectTop1 = yIter31->start;
HXDLIN( 300)										int rectRight1 = xIter31->max;
HXDLIN( 300)										bool forceClear1 = false;
HXDLIN( 300)										{
HXDLIN( 300)											int _g40 = rectTop1;
HXDLIN( 300)											int _g41 = yIter31->max;
HXDLIN( 300)											while((_g40 < _g41)){
HXDLIN( 300)												_g40 = (_g40 + 1);
HXDLIN( 300)												int dy1 = (_g40 - 1);
HXDLIN( 300)												{
HXDLIN( 300)													int _g42 = rectLeft1;
HXDLIN( 300)													int _g43 = rectRight1;
HXDLIN( 300)													while((_g42 < _g43)){
HXDLIN( 300)														_g42 = (_g42 + 1);
HXDLIN( 300)														int dx1 = (_g42 - 1);
HXDLIN( 300)														::Dynamic this39 = this36->image;
HXDLIN( 300)														int index5;
HXDLIN( 300)														if (this36->useVirtualPos) {
HXDLIN( 300)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 300)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 300)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 300)														int col1;
HXDLIN( 300)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 300)															col1 = c4;
            														}
HXDLIN( 300)														bool _hx_tmp8;
HXDLIN( 300)														if (this36->useMask) {
HXDLIN( 300)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 300)															_hx_tmp8 = false;
            														}
HXDLIN( 300)														if (_hx_tmp8) {
HXDLIN( 300)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 300)															::Dynamic this41 = this40->image;
HXDLIN( 300)															int index6;
HXDLIN( 300)															if (this40->useVirtualPos) {
HXDLIN( 300)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 300)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 300)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 300)															int v5;
HXDLIN( 300)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 300)																v5 = c5;
            															}
HXDLIN( 300)															int maskPixel1 = v5;
HXDLIN( 300)															int this42 = col1;
HXDLIN( 300)															if ((maskPixel1 == 0)) {
HXDLIN( 300)																col1 = this42;
            															}
            															else {
HXDLIN( 300)																Float m01;
HXDLIN( 300)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 300)																if ((this43 == 0)) {
HXDLIN( 300)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float m11;
HXDLIN( 300)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 300)																if ((this44 == 0)) {
HXDLIN( 300)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float m21;
HXDLIN( 300)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 300)																if ((this45 == 0)) {
HXDLIN( 300)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float m31;
HXDLIN( 300)																int this46 = (maskPixel1 & 255);
HXDLIN( 300)																if ((this46 == 0)) {
HXDLIN( 300)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 300)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 300)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 300)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 300)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 300)														if ((col1 != 0)) {
HXDLIN( 300)															int x5 = (dx1 - rectLeft1);
HXDLIN( 300)															int y5 = (dy1 - rectTop1);
HXDLIN( 300)															int c6 = col1;
HXDLIN( 300)															bool _hx_tmp9;
HXDLIN( 300)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 300)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 300)																_hx_tmp9 = false;
            															}
HXDLIN( 300)															if (_hx_tmp9) {
HXDLIN( 300)																int location2;
HXDLIN( 300)																if (undoImage3->useVirtualPos) {
HXDLIN( 300)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 300)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 300)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 300)																int this48;
HXDLIN( 300)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 300)																	this48 = this47;
            																}
HXDLIN( 300)																Float a12;
HXDLIN( 300)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 300)																if ((this49 == 0)) {
HXDLIN( 300)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float r12;
HXDLIN( 300)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 300)																if ((this50 == 0)) {
HXDLIN( 300)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float g12;
HXDLIN( 300)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 300)																if ((this51 == 0)) {
HXDLIN( 300)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float b13;
HXDLIN( 300)																int this52 = (this48 & 255);
HXDLIN( 300)																if ((this52 == 0)) {
HXDLIN( 300)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float a22;
HXDLIN( 300)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 300)																if ((this53 == 0)) {
HXDLIN( 300)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float r22;
HXDLIN( 300)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 300)																if ((this54 == 0)) {
HXDLIN( 300)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float g22;
HXDLIN( 300)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 300)																if ((this55 == 0)) {
HXDLIN( 300)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float b23;
HXDLIN( 300)																int this56 = (col1 & 255);
HXDLIN( 300)																if ((this56 == 0)) {
HXDLIN( 300)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 300)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 300)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 300)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 300)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 300)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 300)																{
HXDLIN( 300)																	int _hx_tmp10;
HXDLIN( 300)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 300)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 300)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 300)																::Dynamic this57 = undoImage3->image;
HXDLIN( 300)																int index7;
HXDLIN( 300)																if (undoImage3->useVirtualPos) {
HXDLIN( 300)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 300)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 300)																int _hx_tmp11;
HXDLIN( 300)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 300)																	_hx_tmp11 = c6;
            																}
HXDLIN( 300)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 300)															if (forceClear1) {
HXDLIN( 300)																::Dynamic this58 = undoImage3->image;
HXDLIN( 300)																int x6 = (dx1 - rectLeft1);
HXDLIN( 300)																int y6 = (dy1 - rectTop1);
HXDLIN( 300)																int index8;
HXDLIN( 300)																if (undoImage3->useVirtualPos) {
HXDLIN( 300)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 300)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 300)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 300)								bool found1 = false;
HXDLIN( 300)								Float s1 = ((Float)0.);
HXDLIN( 300)								Float t1 = ((Float)0.);
HXDLIN( 300)								Float sxx1 = ((Float)0.);
HXDLIN( 300)								Float txx1 = ((Float)0.);
HXDLIN( 300)								{
HXDLIN( 300)									int _g_min2 = xIter31->start;
HXDLIN( 300)									int _g_max2 = xIter31->max;
HXDLIN( 300)									while((_g_min2 < _g_max2)){
HXDLIN( 300)										_g_min2 = (_g_min2 + 1);
HXDLIN( 300)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 300)										{
HXDLIN( 300)											int _g_min3 = yIter31->start;
HXDLIN( 300)											int _g_max3 = yIter31->max;
HXDLIN( 300)											while((_g_min3 < _g_max3)){
HXDLIN( 300)												_g_min3 = (_g_min3 + 1);
HXDLIN( 300)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 300)												bool _hx_tmp12;
HXDLIN( 300)												if (!((s1 <= 0))) {
HXDLIN( 300)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 300)													_hx_tmp12 = true;
            												}
HXDLIN( 300)												if (_hx_tmp12) {
HXDLIN( 300)													if (found1) {
HXDLIN( 300)														goto _hx_goto_590;
            													}
            												}
            												else {
HXDLIN( 300)													if (((s1 + t1) < A1)) {
HXDLIN( 300)														{
HXDLIN( 300)															int c7 = color;
HXDLIN( 300)															bool _hx_tmp13;
HXDLIN( 300)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 300)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 300)																_hx_tmp13 = false;
            															}
HXDLIN( 300)															if (_hx_tmp13) {
HXDLIN( 300)																int location3;
HXDLIN( 300)																if (this36->useVirtualPos) {
HXDLIN( 300)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 300)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 300)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 300)																int this60;
HXDLIN( 300)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 300)																	this60 = this59;
            																}
HXDLIN( 300)																Float a13;
HXDLIN( 300)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 300)																if ((this61 == 0)) {
HXDLIN( 300)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float r13;
HXDLIN( 300)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 300)																if ((this62 == 0)) {
HXDLIN( 300)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float g13;
HXDLIN( 300)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 300)																if ((this63 == 0)) {
HXDLIN( 300)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float b14;
HXDLIN( 300)																int this64 = (this60 & 255);
HXDLIN( 300)																if ((this64 == 0)) {
HXDLIN( 300)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float a23;
HXDLIN( 300)																int this65 = ((color >> 24) & 255);
HXDLIN( 300)																if ((this65 == 0)) {
HXDLIN( 300)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float r23;
HXDLIN( 300)																int this66 = ((color >> 16) & 255);
HXDLIN( 300)																if ((this66 == 0)) {
HXDLIN( 300)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float g23;
HXDLIN( 300)																int this67 = ((color >> 8) & 255);
HXDLIN( 300)																if ((this67 == 0)) {
HXDLIN( 300)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float b24;
HXDLIN( 300)																int this68 = (color & 255);
HXDLIN( 300)																if ((this68 == 0)) {
HXDLIN( 300)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 300)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 300)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 300)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 300)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 300)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 300)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 300)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 300)																{
HXDLIN( 300)																	int _hx_tmp14;
HXDLIN( 300)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 300)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 300)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 300)																::Dynamic this69 = this36->image;
HXDLIN( 300)																int index9;
HXDLIN( 300)																if (this36->useVirtualPos) {
HXDLIN( 300)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 300)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 300)																int _hx_tmp15;
HXDLIN( 300)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 300)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 300)																	_hx_tmp15 = c7;
            																}
HXDLIN( 300)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 300)														if (found1) {
HXDLIN( 300)															goto _hx_goto_590;
            														}
            													}
            												}
            											}
            											_hx_goto_590:;
            										}
            									}
            								}
HXDLIN( 300)								if ((hasHit1 == true)) {
HXDLIN( 300)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 300)									if (hasUndo1) {
HXDLIN( 300)										v6->undoImage = undoImage3;
HXDLIN( 300)										v6->undoX = xIter31->start;
HXDLIN( 300)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,nonagon,(void))

void FillShape_Impl__obj::enneagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_313_enneagon)
HXDLIN( 313)		 ::Dynamic phi1 = phi;
HXDLIN( 313)		 ::Dynamic sides = 9;
HXLINE( 317)		if (::hx::IsNull( sides )) {
HXLINE( 317)			sides = 36;
            		}
HXLINE( 316)		if (::hx::IsNull( phi1 )) {
HXLINE( 316)			phi1 = ((Float)0.);
            		}
HXLINE( 313)		{
HXDLIN( 313)			 ::Dynamic phi2 = phi1;
HXDLIN( 313)			 ::Dynamic sides1 = sides;
HXDLIN( 313)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 313)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 313)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 313)			Float omega;
HXDLIN( 313)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 313)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 313)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 313)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 313)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 313)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 313)			Float lastX = ((Float)0.);
HXDLIN( 313)			Float lastY = ((Float)0.);
HXDLIN( 313)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 313)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 313)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 313)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 313)				{
HXDLIN( 313)					int _g = 0;
HXDLIN( 313)					int _g1 = (sides1 + 1);
HXDLIN( 313)					while((_g < _g1)){
HXDLIN( 313)						_g = (_g + 1);
HXDLIN( 313)						int i = (_g - 1);
HXDLIN( 313)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 313)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 313)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 313)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 313)						{
HXDLIN( 313)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 313)							bool hasHit = false;
HXDLIN( 313)							bool hasUndo = false;
HXDLIN( 313)							{
HXDLIN( 313)								Float bx = lastX;
HXDLIN( 313)								Float by = lastY;
HXDLIN( 313)								Float cx1 = nextX;
HXDLIN( 313)								Float cy1 = nextY;
HXDLIN( 313)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 313)								if (!(adjustWinding)) {
HXDLIN( 313)									Float bx_ = bx;
HXDLIN( 313)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 313)								{
HXDLIN( 313)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 313)									Float sx = (cy1 - cy);
HXDLIN( 313)									Float sy = (cx - cx1);
HXDLIN( 313)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 313)									Float tx = (cy - by);
HXDLIN( 313)									Float ty = (bx - cx);
HXDLIN( 313)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 313)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 313)									if ((cx > bx)) {
HXDLIN( 313)										if ((cx > cx1)) {
HXDLIN( 313)											int min;
HXDLIN( 313)											if ((bx > cx1)) {
HXDLIN( 313)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 313)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 313)											int ii_min = min;
HXDLIN( 313)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 313)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 313)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 313)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 313)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 313)										if ((bx > cx1)) {
HXDLIN( 313)											int min1;
HXDLIN( 313)											if ((cx > cx1)) {
HXDLIN( 313)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 313)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 313)											int ii_min2 = min1;
HXDLIN( 313)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 313)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 313)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 313)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 313)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 313)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 313)									if ((cy > by)) {
HXDLIN( 313)										if ((cy > cy1)) {
HXDLIN( 313)											int min2;
HXDLIN( 313)											if ((by > cy1)) {
HXDLIN( 313)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 313)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 313)											int ii_min4 = min2;
HXDLIN( 313)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 313)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 313)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 313)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 313)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 313)										if ((by > cy1)) {
HXDLIN( 313)											int min3;
HXDLIN( 313)											if ((cy > cy1)) {
HXDLIN( 313)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 313)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 313)											int ii_min6 = min3;
HXDLIN( 313)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 313)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 313)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 313)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 313)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 313)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 313)									if (hasUndo) {
HXDLIN( 313)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 313)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 313)										 ::Dynamic imageType = null();
HXDLIN( 313)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 313)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 313)										::Dynamic undoImage1;
HXDLIN( 313)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 313)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 313)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 313)												{
HXDLIN( 313)													b->width = width;
HXDLIN( 313)													b->height = height;
HXDLIN( 313)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 313)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 313)													{
HXDLIN( 313)														int len = b->length;
HXDLIN( 313)														int w = 0;
HXDLIN( 313)														{
HXDLIN( 313)															int _g2 = 0;
HXDLIN( 313)															int _g3 = b->height;
HXDLIN( 313)															while((_g2 < _g3)){
HXDLIN( 313)																_g2 = (_g2 + 1);
HXDLIN( 313)																int y = (_g2 - 1);
HXDLIN( 313)																{
HXDLIN( 313)																	int _g4 = 0;
HXDLIN( 313)																	int _g5 = b->width;
HXDLIN( 313)																	while((_g4 < _g5)){
HXDLIN( 313)																		_g4 = (_g4 + 1);
HXDLIN( 313)																		int x = (_g4 - 1);
HXDLIN( 313)																		{
HXDLIN( 313)																			w = (w + 1);
HXDLIN( 313)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 313)																		{
HXDLIN( 313)																			w = (w + 1);
HXDLIN( 313)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 313)																		{
HXDLIN( 313)																			w = (w + 1);
HXDLIN( 313)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 313)																		{
HXDLIN( 313)																			w = (w + 1);
HXDLIN( 313)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 313)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 313)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 313)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 313)												{
HXDLIN( 313)													a->width = width;
HXDLIN( 313)													a->height = height;
HXDLIN( 313)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 313)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 313)													{
HXDLIN( 313)														int _g6 = 0;
HXDLIN( 313)														int _g7 = a->length;
HXDLIN( 313)														while((_g6 < _g7)){
HXDLIN( 313)															_g6 = (_g6 + 1);
HXDLIN( 313)															int i1 = (_g6 - 1);
HXDLIN( 313)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 313)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 313)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 313)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 313)												{
HXDLIN( 313)													b1->width = width;
HXDLIN( 313)													b1->height = height;
HXDLIN( 313)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 313)													int size = (b1->length * 4);
HXDLIN( 313)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 313)													{
HXDLIN( 313)														int _g8 = 0;
HXDLIN( 313)														int _g9 = b1->length;
HXDLIN( 313)														while((_g8 < _g9)){
HXDLIN( 313)															_g8 = (_g8 + 1);
HXDLIN( 313)															int i2 = (_g8 - 1);
HXDLIN( 313)															{
HXDLIN( 313)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 313)																bool undoImage2;
HXDLIN( 313)																if ((i2 >= 0)) {
HXDLIN( 313)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 313)																	undoImage2 = false;
            																}
HXDLIN( 313)																if (undoImage2) {
HXDLIN( 313)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 313)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 313)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 313)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 313)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 313)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 313)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 313)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 313)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 313)												{
HXDLIN( 313)													v1->width = width;
HXDLIN( 313)													v1->height = height;
HXDLIN( 313)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 313)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 313)													{
HXDLIN( 313)														int _g10 = 0;
HXDLIN( 313)														int _g11 = v1->length;
HXDLIN( 313)														while((_g10 < _g11)){
HXDLIN( 313)															_g10 = (_g10 + 1);
HXDLIN( 313)															int i3 = (_g10 - 1);
HXDLIN( 313)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 313)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 313)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 313)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 313)												{
HXDLIN( 313)													b2->width = width;
HXDLIN( 313)													b2->height = height;
HXDLIN( 313)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 313)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 313)													{
HXDLIN( 313)														int len1 = b2->length;
HXDLIN( 313)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 313)														if (::hx::IsNull( d->head )) {
HXDLIN( 313)															int _g12 = 0;
HXDLIN( 313)															int _g13 = len1;
HXDLIN( 313)															while((_g12 < _g13)){
HXDLIN( 313)																_g12 = (_g12 + 1);
HXDLIN( 313)																int i4 = (_g12 - 1);
HXDLIN( 313)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 313)															int _g14 = 0;
HXDLIN( 313)															int _g15 = len1;
HXDLIN( 313)															while((_g14 < _g15)){
HXDLIN( 313)																_g14 = (_g14 + 1);
HXDLIN( 313)																int i5 = (_g14 - 1);
HXDLIN( 313)																{
HXDLIN( 313)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 313)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 313)																	{
HXDLIN( 313)																		int _g16 = 0;
HXDLIN( 313)																		int _g17 = i5;
HXDLIN( 313)																		while((_g16 < _g17)){
HXDLIN( 313)																			_g16 = (_g16 + 1);
HXDLIN( 313)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 313)																	if (::hx::IsNull( prev )) {
HXDLIN( 313)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 313)																		l = null();
            																	}
            																	else {
HXDLIN( 313)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 313)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 313)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 313)										this3->image = undoImage1;
HXDLIN( 313)										this3->width = width;
HXDLIN( 313)										this3->height = height;
HXDLIN( 313)										this3->imageType = ( (int)(imageType) );
HXDLIN( 313)										undoImage = this3;
HXDLIN( 313)										{
HXDLIN( 313)											int rectLeft = xIter3->start;
HXDLIN( 313)											int rectTop = yIter3->start;
HXDLIN( 313)											int rectRight = xIter3->max;
HXDLIN( 313)											bool forceClear = false;
HXDLIN( 313)											{
HXDLIN( 313)												int _g18 = rectTop;
HXDLIN( 313)												int _g19 = yIter3->max;
HXDLIN( 313)												while((_g18 < _g19)){
HXDLIN( 313)													_g18 = (_g18 + 1);
HXDLIN( 313)													int dy = (_g18 - 1);
HXDLIN( 313)													{
HXDLIN( 313)														int _g20 = rectLeft;
HXDLIN( 313)														int _g21 = rectRight;
HXDLIN( 313)														while((_g20 < _g21)){
HXDLIN( 313)															_g20 = (_g20 + 1);
HXDLIN( 313)															int dx = (_g20 - 1);
HXDLIN( 313)															::Dynamic this5 = this2->image;
HXDLIN( 313)															int index;
HXDLIN( 313)															if (this2->useVirtualPos) {
HXDLIN( 313)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 313)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 313)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 313)															int col;
HXDLIN( 313)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 313)																col = c;
            															}
HXDLIN( 313)															bool _hx_tmp;
HXDLIN( 313)															if (this2->useMask) {
HXDLIN( 313)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 313)																_hx_tmp = false;
            															}
HXDLIN( 313)															if (_hx_tmp) {
HXDLIN( 313)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 313)																::Dynamic this7 = this6->image;
HXDLIN( 313)																int index1;
HXDLIN( 313)																if (this6->useVirtualPos) {
HXDLIN( 313)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 313)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 313)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 313)																int v2;
HXDLIN( 313)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 313)																	v2 = c1;
            																}
HXDLIN( 313)																int maskPixel = v2;
HXDLIN( 313)																int this8 = col;
HXDLIN( 313)																if ((maskPixel == 0)) {
HXDLIN( 313)																	col = this8;
            																}
            																else {
HXDLIN( 313)																	Float m0;
HXDLIN( 313)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 313)																	if ((this9 == 0)) {
HXDLIN( 313)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float m1;
HXDLIN( 313)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 313)																	if ((this10 == 0)) {
HXDLIN( 313)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float m2;
HXDLIN( 313)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 313)																	if ((this11 == 0)) {
HXDLIN( 313)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float m3;
HXDLIN( 313)																	int this12 = (maskPixel & 255);
HXDLIN( 313)																	if ((this12 == 0)) {
HXDLIN( 313)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 313)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 313)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 313)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 313)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 313)															if ((col != 0)) {
HXDLIN( 313)																int x1 = (dx - rectLeft);
HXDLIN( 313)																int y1 = (dy - rectTop);
HXDLIN( 313)																int c2 = col;
HXDLIN( 313)																bool _hx_tmp1;
HXDLIN( 313)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 313)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 313)																	_hx_tmp1 = false;
            																}
HXDLIN( 313)																if (_hx_tmp1) {
HXDLIN( 313)																	int location;
HXDLIN( 313)																	if (undoImage->useVirtualPos) {
HXDLIN( 313)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 313)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 313)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 313)																	int this14;
HXDLIN( 313)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 313)																		this14 = this13;
            																	}
HXDLIN( 313)																	Float a1;
HXDLIN( 313)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 313)																	if ((this15 == 0)) {
HXDLIN( 313)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float r1;
HXDLIN( 313)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 313)																	if ((this16 == 0)) {
HXDLIN( 313)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float g1;
HXDLIN( 313)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 313)																	if ((this17 == 0)) {
HXDLIN( 313)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float b11;
HXDLIN( 313)																	int this18 = (this14 & 255);
HXDLIN( 313)																	if ((this18 == 0)) {
HXDLIN( 313)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float a2;
HXDLIN( 313)																	int this19 = ((col >> 24) & 255);
HXDLIN( 313)																	if ((this19 == 0)) {
HXDLIN( 313)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float r2;
HXDLIN( 313)																	int this20 = ((col >> 16) & 255);
HXDLIN( 313)																	if ((this20 == 0)) {
HXDLIN( 313)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float g2;
HXDLIN( 313)																	int this21 = ((col >> 8) & 255);
HXDLIN( 313)																	if ((this21 == 0)) {
HXDLIN( 313)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float b21;
HXDLIN( 313)																	int this22 = (col & 255);
HXDLIN( 313)																	if ((this22 == 0)) {
HXDLIN( 313)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 313)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 313)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 313)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 313)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 313)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 313)																	{
HXDLIN( 313)																		int _hx_tmp2;
HXDLIN( 313)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 313)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 313)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 313)																	::Dynamic this23 = undoImage->image;
HXDLIN( 313)																	int index2;
HXDLIN( 313)																	if (undoImage->useVirtualPos) {
HXDLIN( 313)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 313)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 313)																	int _hx_tmp3;
HXDLIN( 313)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 313)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 313)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 313)																if (forceClear) {
HXDLIN( 313)																	::Dynamic this24 = undoImage->image;
HXDLIN( 313)																	int x2 = (dx - rectLeft);
HXDLIN( 313)																	int y2 = (dy - rectTop);
HXDLIN( 313)																	int index3;
HXDLIN( 313)																	if (undoImage->useVirtualPos) {
HXDLIN( 313)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 313)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 313)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 313)									bool found = false;
HXDLIN( 313)									Float s = ((Float)0.);
HXDLIN( 313)									Float t = ((Float)0.);
HXDLIN( 313)									Float sxx = ((Float)0.);
HXDLIN( 313)									Float txx = ((Float)0.);
HXDLIN( 313)									{
HXDLIN( 313)										int _g_min = xIter3->start;
HXDLIN( 313)										int _g_max = xIter3->max;
HXDLIN( 313)										while((_g_min < _g_max)){
HXDLIN( 313)											_g_min = (_g_min + 1);
HXDLIN( 313)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 313)											{
HXDLIN( 313)												int _g_min1 = yIter3->start;
HXDLIN( 313)												int _g_max1 = yIter3->max;
HXDLIN( 313)												while((_g_min1 < _g_max1)){
HXDLIN( 313)													_g_min1 = (_g_min1 + 1);
HXDLIN( 313)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 313)													bool _hx_tmp4;
HXDLIN( 313)													if (!((s <= 0))) {
HXDLIN( 313)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 313)														_hx_tmp4 = true;
            													}
HXDLIN( 313)													if (_hx_tmp4) {
HXDLIN( 313)														if (found) {
HXDLIN( 313)															goto _hx_goto_604;
            														}
            													}
            													else {
HXDLIN( 313)														if (((s + t) < A)) {
HXDLIN( 313)															{
HXDLIN( 313)																int c3 = color;
HXDLIN( 313)																bool _hx_tmp5;
HXDLIN( 313)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 313)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 313)																	_hx_tmp5 = false;
            																}
HXDLIN( 313)																if (_hx_tmp5) {
HXDLIN( 313)																	int location1;
HXDLIN( 313)																	if (this2->useVirtualPos) {
HXDLIN( 313)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 313)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 313)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 313)																	int this26;
HXDLIN( 313)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 313)																		this26 = this25;
            																	}
HXDLIN( 313)																	Float a11;
HXDLIN( 313)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 313)																	if ((this27 == 0)) {
HXDLIN( 313)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float r11;
HXDLIN( 313)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 313)																	if ((this28 == 0)) {
HXDLIN( 313)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float g11;
HXDLIN( 313)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 313)																	if ((this29 == 0)) {
HXDLIN( 313)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float b12;
HXDLIN( 313)																	int this30 = (this26 & 255);
HXDLIN( 313)																	if ((this30 == 0)) {
HXDLIN( 313)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float a21;
HXDLIN( 313)																	int this31 = ((color >> 24) & 255);
HXDLIN( 313)																	if ((this31 == 0)) {
HXDLIN( 313)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float r21;
HXDLIN( 313)																	int this32 = ((color >> 16) & 255);
HXDLIN( 313)																	if ((this32 == 0)) {
HXDLIN( 313)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float g21;
HXDLIN( 313)																	int this33 = ((color >> 8) & 255);
HXDLIN( 313)																	if ((this33 == 0)) {
HXDLIN( 313)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float b22;
HXDLIN( 313)																	int this34 = (color & 255);
HXDLIN( 313)																	if ((this34 == 0)) {
HXDLIN( 313)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 313)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 313)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 313)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 313)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 313)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 313)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 313)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 313)																	{
HXDLIN( 313)																		int _hx_tmp6;
HXDLIN( 313)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 313)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 313)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 313)																	::Dynamic this35 = this2->image;
HXDLIN( 313)																	int index4;
HXDLIN( 313)																	if (this2->useVirtualPos) {
HXDLIN( 313)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 313)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 313)																	int _hx_tmp7;
HXDLIN( 313)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 313)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 313)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 313)															if (found) {
HXDLIN( 313)																goto _hx_goto_604;
            															}
            														}
            													}
            												}
            												_hx_goto_604:;
            											}
            										}
            									}
HXDLIN( 313)									if ((hasHit == true)) {
HXDLIN( 313)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 313)										if (hasUndo) {
HXDLIN( 313)											v3->undoImage = undoImage;
HXDLIN( 313)											v3->undoX = xIter3->start;
HXDLIN( 313)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 313)				int _g22 = 0;
HXDLIN( 313)				int _g23 = (sides1 + 1);
HXDLIN( 313)				while((_g22 < _g23)){
HXDLIN( 313)					_g22 = (_g22 + 1);
HXDLIN( 313)					int i7 = (_g22 - 1);
HXDLIN( 313)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 313)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 313)					{
HXDLIN( 313)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 313)						bool hasHit1 = false;
HXDLIN( 313)						bool hasUndo1 = false;
HXDLIN( 313)						{
HXDLIN( 313)							Float bx1 = lastX;
HXDLIN( 313)							Float by1 = lastY;
HXDLIN( 313)							Float cx2 = nextX1;
HXDLIN( 313)							Float cy2 = nextY1;
HXDLIN( 313)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 313)							if (!(adjustWinding1)) {
HXDLIN( 313)								Float bx_1 = bx1;
HXDLIN( 313)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 313)							{
HXDLIN( 313)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 313)								Float sx1 = (cy2 - cy);
HXDLIN( 313)								Float sy1 = (cx - cx2);
HXDLIN( 313)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 313)								Float tx1 = (cy - by1);
HXDLIN( 313)								Float ty1 = (bx1 - cx);
HXDLIN( 313)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 313)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 313)								if ((cx > bx1)) {
HXDLIN( 313)									if ((cx > cx2)) {
HXDLIN( 313)										int min4;
HXDLIN( 313)										if ((bx1 > cx2)) {
HXDLIN( 313)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 313)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 313)										int ii_min8 = min4;
HXDLIN( 313)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 313)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 313)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 313)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 313)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 313)									if ((bx1 > cx2)) {
HXDLIN( 313)										int min5;
HXDLIN( 313)										if ((cx > cx2)) {
HXDLIN( 313)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 313)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 313)										int ii_min10 = min5;
HXDLIN( 313)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 313)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 313)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 313)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 313)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 313)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 313)								if ((cy > by1)) {
HXDLIN( 313)									if ((cy > cy2)) {
HXDLIN( 313)										int min6;
HXDLIN( 313)										if ((by1 > cy2)) {
HXDLIN( 313)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 313)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 313)										int ii_min12 = min6;
HXDLIN( 313)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 313)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 313)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 313)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 313)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 313)									if ((by1 > cy2)) {
HXDLIN( 313)										int min7;
HXDLIN( 313)										if ((cy > cy2)) {
HXDLIN( 313)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 313)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 313)										int ii_min14 = min7;
HXDLIN( 313)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 313)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 313)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 313)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 313)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 313)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 313)								if (hasUndo1) {
HXDLIN( 313)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 313)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 313)									 ::Dynamic imageType1 = null();
HXDLIN( 313)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 313)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 313)									::Dynamic undoImage4;
HXDLIN( 313)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 313)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 313)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 313)											{
HXDLIN( 313)												b5->width = width1;
HXDLIN( 313)												b5->height = height1;
HXDLIN( 313)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 313)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 313)												{
HXDLIN( 313)													int len2 = b5->length;
HXDLIN( 313)													int w1 = 0;
HXDLIN( 313)													{
HXDLIN( 313)														int _g24 = 0;
HXDLIN( 313)														int _g25 = b5->height;
HXDLIN( 313)														while((_g24 < _g25)){
HXDLIN( 313)															_g24 = (_g24 + 1);
HXDLIN( 313)															int y4 = (_g24 - 1);
HXDLIN( 313)															{
HXDLIN( 313)																int _g26 = 0;
HXDLIN( 313)																int _g27 = b5->width;
HXDLIN( 313)																while((_g26 < _g27)){
HXDLIN( 313)																	_g26 = (_g26 + 1);
HXDLIN( 313)																	int x4 = (_g26 - 1);
HXDLIN( 313)																	{
HXDLIN( 313)																		w1 = (w1 + 1);
HXDLIN( 313)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 313)																	{
HXDLIN( 313)																		w1 = (w1 + 1);
HXDLIN( 313)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 313)																	{
HXDLIN( 313)																		w1 = (w1 + 1);
HXDLIN( 313)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 313)																	{
HXDLIN( 313)																		w1 = (w1 + 1);
HXDLIN( 313)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 313)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 313)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 313)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 313)											{
HXDLIN( 313)												a6->width = width1;
HXDLIN( 313)												a6->height = height1;
HXDLIN( 313)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 313)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 313)												{
HXDLIN( 313)													int _g28 = 0;
HXDLIN( 313)													int _g29 = a6->length;
HXDLIN( 313)													while((_g28 < _g29)){
HXDLIN( 313)														_g28 = (_g28 + 1);
HXDLIN( 313)														int i8 = (_g28 - 1);
HXDLIN( 313)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 313)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 313)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 313)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 313)											{
HXDLIN( 313)												b6->width = width1;
HXDLIN( 313)												b6->height = height1;
HXDLIN( 313)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 313)												int size1 = (b6->length * 4);
HXDLIN( 313)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 313)												{
HXDLIN( 313)													int _g30 = 0;
HXDLIN( 313)													int _g31 = b6->length;
HXDLIN( 313)													while((_g30 < _g31)){
HXDLIN( 313)														_g30 = (_g30 + 1);
HXDLIN( 313)														int i9 = (_g30 - 1);
HXDLIN( 313)														{
HXDLIN( 313)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 313)															bool undoImage5;
HXDLIN( 313)															if ((i9 >= 0)) {
HXDLIN( 313)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 313)																undoImage5 = false;
            															}
HXDLIN( 313)															if (undoImage5) {
HXDLIN( 313)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 313)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 313)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 313)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 313)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 313)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 313)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 313)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 313)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 313)											{
HXDLIN( 313)												v4->width = width1;
HXDLIN( 313)												v4->height = height1;
HXDLIN( 313)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 313)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 313)												{
HXDLIN( 313)													int _g32 = 0;
HXDLIN( 313)													int _g33 = v4->length;
HXDLIN( 313)													while((_g32 < _g33)){
HXDLIN( 313)														_g32 = (_g32 + 1);
HXDLIN( 313)														int i10 = (_g32 - 1);
HXDLIN( 313)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 313)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 313)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 313)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 313)											{
HXDLIN( 313)												b7->width = width1;
HXDLIN( 313)												b7->height = height1;
HXDLIN( 313)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 313)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 313)												{
HXDLIN( 313)													int len3 = b7->length;
HXDLIN( 313)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 313)													if (::hx::IsNull( d1->head )) {
HXDLIN( 313)														int _g34 = 0;
HXDLIN( 313)														int _g35 = len3;
HXDLIN( 313)														while((_g34 < _g35)){
HXDLIN( 313)															_g34 = (_g34 + 1);
HXDLIN( 313)															int i11 = (_g34 - 1);
HXDLIN( 313)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 313)														int _g36 = 0;
HXDLIN( 313)														int _g37 = len3;
HXDLIN( 313)														while((_g36 < _g37)){
HXDLIN( 313)															_g36 = (_g36 + 1);
HXDLIN( 313)															int i12 = (_g36 - 1);
HXDLIN( 313)															{
HXDLIN( 313)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 313)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 313)																{
HXDLIN( 313)																	int _g38 = 0;
HXDLIN( 313)																	int _g39 = i12;
HXDLIN( 313)																	while((_g38 < _g39)){
HXDLIN( 313)																		_g38 = (_g38 + 1);
HXDLIN( 313)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 313)																if (::hx::IsNull( prev1 )) {
HXDLIN( 313)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 313)																	l1 = null();
            																}
            																else {
HXDLIN( 313)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 313)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 313)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 313)									this37->image = undoImage4;
HXDLIN( 313)									this37->width = width1;
HXDLIN( 313)									this37->height = height1;
HXDLIN( 313)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 313)									undoImage3 = this37;
HXDLIN( 313)									{
HXDLIN( 313)										int rectLeft1 = xIter31->start;
HXDLIN( 313)										int rectTop1 = yIter31->start;
HXDLIN( 313)										int rectRight1 = xIter31->max;
HXDLIN( 313)										bool forceClear1 = false;
HXDLIN( 313)										{
HXDLIN( 313)											int _g40 = rectTop1;
HXDLIN( 313)											int _g41 = yIter31->max;
HXDLIN( 313)											while((_g40 < _g41)){
HXDLIN( 313)												_g40 = (_g40 + 1);
HXDLIN( 313)												int dy1 = (_g40 - 1);
HXDLIN( 313)												{
HXDLIN( 313)													int _g42 = rectLeft1;
HXDLIN( 313)													int _g43 = rectRight1;
HXDLIN( 313)													while((_g42 < _g43)){
HXDLIN( 313)														_g42 = (_g42 + 1);
HXDLIN( 313)														int dx1 = (_g42 - 1);
HXDLIN( 313)														::Dynamic this39 = this36->image;
HXDLIN( 313)														int index5;
HXDLIN( 313)														if (this36->useVirtualPos) {
HXDLIN( 313)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 313)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 313)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 313)														int col1;
HXDLIN( 313)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 313)															col1 = c4;
            														}
HXDLIN( 313)														bool _hx_tmp8;
HXDLIN( 313)														if (this36->useMask) {
HXDLIN( 313)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 313)															_hx_tmp8 = false;
            														}
HXDLIN( 313)														if (_hx_tmp8) {
HXDLIN( 313)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 313)															::Dynamic this41 = this40->image;
HXDLIN( 313)															int index6;
HXDLIN( 313)															if (this40->useVirtualPos) {
HXDLIN( 313)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 313)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 313)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 313)															int v5;
HXDLIN( 313)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 313)																v5 = c5;
            															}
HXDLIN( 313)															int maskPixel1 = v5;
HXDLIN( 313)															int this42 = col1;
HXDLIN( 313)															if ((maskPixel1 == 0)) {
HXDLIN( 313)																col1 = this42;
            															}
            															else {
HXDLIN( 313)																Float m01;
HXDLIN( 313)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 313)																if ((this43 == 0)) {
HXDLIN( 313)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float m11;
HXDLIN( 313)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 313)																if ((this44 == 0)) {
HXDLIN( 313)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float m21;
HXDLIN( 313)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 313)																if ((this45 == 0)) {
HXDLIN( 313)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float m31;
HXDLIN( 313)																int this46 = (maskPixel1 & 255);
HXDLIN( 313)																if ((this46 == 0)) {
HXDLIN( 313)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 313)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 313)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 313)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 313)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 313)														if ((col1 != 0)) {
HXDLIN( 313)															int x5 = (dx1 - rectLeft1);
HXDLIN( 313)															int y5 = (dy1 - rectTop1);
HXDLIN( 313)															int c6 = col1;
HXDLIN( 313)															bool _hx_tmp9;
HXDLIN( 313)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 313)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 313)																_hx_tmp9 = false;
            															}
HXDLIN( 313)															if (_hx_tmp9) {
HXDLIN( 313)																int location2;
HXDLIN( 313)																if (undoImage3->useVirtualPos) {
HXDLIN( 313)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 313)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 313)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 313)																int this48;
HXDLIN( 313)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 313)																	this48 = this47;
            																}
HXDLIN( 313)																Float a12;
HXDLIN( 313)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 313)																if ((this49 == 0)) {
HXDLIN( 313)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float r12;
HXDLIN( 313)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 313)																if ((this50 == 0)) {
HXDLIN( 313)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float g12;
HXDLIN( 313)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 313)																if ((this51 == 0)) {
HXDLIN( 313)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float b13;
HXDLIN( 313)																int this52 = (this48 & 255);
HXDLIN( 313)																if ((this52 == 0)) {
HXDLIN( 313)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float a22;
HXDLIN( 313)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 313)																if ((this53 == 0)) {
HXDLIN( 313)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float r22;
HXDLIN( 313)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 313)																if ((this54 == 0)) {
HXDLIN( 313)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float g22;
HXDLIN( 313)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 313)																if ((this55 == 0)) {
HXDLIN( 313)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float b23;
HXDLIN( 313)																int this56 = (col1 & 255);
HXDLIN( 313)																if ((this56 == 0)) {
HXDLIN( 313)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 313)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 313)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 313)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 313)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 313)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 313)																{
HXDLIN( 313)																	int _hx_tmp10;
HXDLIN( 313)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 313)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 313)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 313)																::Dynamic this57 = undoImage3->image;
HXDLIN( 313)																int index7;
HXDLIN( 313)																if (undoImage3->useVirtualPos) {
HXDLIN( 313)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 313)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 313)																int _hx_tmp11;
HXDLIN( 313)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 313)																	_hx_tmp11 = c6;
            																}
HXDLIN( 313)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 313)															if (forceClear1) {
HXDLIN( 313)																::Dynamic this58 = undoImage3->image;
HXDLIN( 313)																int x6 = (dx1 - rectLeft1);
HXDLIN( 313)																int y6 = (dy1 - rectTop1);
HXDLIN( 313)																int index8;
HXDLIN( 313)																if (undoImage3->useVirtualPos) {
HXDLIN( 313)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 313)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 313)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 313)								bool found1 = false;
HXDLIN( 313)								Float s1 = ((Float)0.);
HXDLIN( 313)								Float t1 = ((Float)0.);
HXDLIN( 313)								Float sxx1 = ((Float)0.);
HXDLIN( 313)								Float txx1 = ((Float)0.);
HXDLIN( 313)								{
HXDLIN( 313)									int _g_min2 = xIter31->start;
HXDLIN( 313)									int _g_max2 = xIter31->max;
HXDLIN( 313)									while((_g_min2 < _g_max2)){
HXDLIN( 313)										_g_min2 = (_g_min2 + 1);
HXDLIN( 313)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 313)										{
HXDLIN( 313)											int _g_min3 = yIter31->start;
HXDLIN( 313)											int _g_max3 = yIter31->max;
HXDLIN( 313)											while((_g_min3 < _g_max3)){
HXDLIN( 313)												_g_min3 = (_g_min3 + 1);
HXDLIN( 313)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 313)												bool _hx_tmp12;
HXDLIN( 313)												if (!((s1 <= 0))) {
HXDLIN( 313)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 313)													_hx_tmp12 = true;
            												}
HXDLIN( 313)												if (_hx_tmp12) {
HXDLIN( 313)													if (found1) {
HXDLIN( 313)														goto _hx_goto_617;
            													}
            												}
            												else {
HXDLIN( 313)													if (((s1 + t1) < A1)) {
HXDLIN( 313)														{
HXDLIN( 313)															int c7 = color;
HXDLIN( 313)															bool _hx_tmp13;
HXDLIN( 313)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 313)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 313)																_hx_tmp13 = false;
            															}
HXDLIN( 313)															if (_hx_tmp13) {
HXDLIN( 313)																int location3;
HXDLIN( 313)																if (this36->useVirtualPos) {
HXDLIN( 313)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 313)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 313)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 313)																int this60;
HXDLIN( 313)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 313)																	this60 = this59;
            																}
HXDLIN( 313)																Float a13;
HXDLIN( 313)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 313)																if ((this61 == 0)) {
HXDLIN( 313)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float r13;
HXDLIN( 313)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 313)																if ((this62 == 0)) {
HXDLIN( 313)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float g13;
HXDLIN( 313)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 313)																if ((this63 == 0)) {
HXDLIN( 313)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float b14;
HXDLIN( 313)																int this64 = (this60 & 255);
HXDLIN( 313)																if ((this64 == 0)) {
HXDLIN( 313)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float a23;
HXDLIN( 313)																int this65 = ((color >> 24) & 255);
HXDLIN( 313)																if ((this65 == 0)) {
HXDLIN( 313)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float r23;
HXDLIN( 313)																int this66 = ((color >> 16) & 255);
HXDLIN( 313)																if ((this66 == 0)) {
HXDLIN( 313)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float g23;
HXDLIN( 313)																int this67 = ((color >> 8) & 255);
HXDLIN( 313)																if ((this67 == 0)) {
HXDLIN( 313)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float b24;
HXDLIN( 313)																int this68 = (color & 255);
HXDLIN( 313)																if ((this68 == 0)) {
HXDLIN( 313)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 313)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 313)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 313)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 313)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 313)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 313)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 313)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 313)																{
HXDLIN( 313)																	int _hx_tmp14;
HXDLIN( 313)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 313)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 313)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 313)																::Dynamic this69 = this36->image;
HXDLIN( 313)																int index9;
HXDLIN( 313)																if (this36->useVirtualPos) {
HXDLIN( 313)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 313)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 313)																int _hx_tmp15;
HXDLIN( 313)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 313)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 313)																	_hx_tmp15 = c7;
            																}
HXDLIN( 313)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 313)														if (found1) {
HXDLIN( 313)															goto _hx_goto_617;
            														}
            													}
            												}
            											}
            											_hx_goto_617:;
            										}
            									}
            								}
HXDLIN( 313)								if ((hasHit1 == true)) {
HXDLIN( 313)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 313)									if (hasUndo1) {
HXDLIN( 313)										v6->undoImage = undoImage3;
HXDLIN( 313)										v6->undoX = xIter31->start;
HXDLIN( 313)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,enneagon,(void))

void FillShape_Impl__obj::decagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_326_decagon)
HXDLIN( 326)		 ::Dynamic phi1 = phi;
HXDLIN( 326)		 ::Dynamic sides = 10;
HXLINE( 330)		if (::hx::IsNull( sides )) {
HXLINE( 330)			sides = 36;
            		}
HXLINE( 329)		if (::hx::IsNull( phi1 )) {
HXLINE( 329)			phi1 = ((Float)0.);
            		}
HXLINE( 326)		{
HXDLIN( 326)			 ::Dynamic phi2 = phi1;
HXDLIN( 326)			 ::Dynamic sides1 = sides;
HXDLIN( 326)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 326)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 326)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 326)			Float omega;
HXDLIN( 326)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 326)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 326)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 326)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 326)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 326)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 326)			Float lastX = ((Float)0.);
HXDLIN( 326)			Float lastY = ((Float)0.);
HXDLIN( 326)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 326)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 326)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 326)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 326)				{
HXDLIN( 326)					int _g = 0;
HXDLIN( 326)					int _g1 = (sides1 + 1);
HXDLIN( 326)					while((_g < _g1)){
HXDLIN( 326)						_g = (_g + 1);
HXDLIN( 326)						int i = (_g - 1);
HXDLIN( 326)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 326)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 326)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 326)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 326)						{
HXDLIN( 326)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 326)							bool hasHit = false;
HXDLIN( 326)							bool hasUndo = false;
HXDLIN( 326)							{
HXDLIN( 326)								Float bx = lastX;
HXDLIN( 326)								Float by = lastY;
HXDLIN( 326)								Float cx1 = nextX;
HXDLIN( 326)								Float cy1 = nextY;
HXDLIN( 326)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 326)								if (!(adjustWinding)) {
HXDLIN( 326)									Float bx_ = bx;
HXDLIN( 326)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 326)								{
HXDLIN( 326)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 326)									Float sx = (cy1 - cy);
HXDLIN( 326)									Float sy = (cx - cx1);
HXDLIN( 326)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 326)									Float tx = (cy - by);
HXDLIN( 326)									Float ty = (bx - cx);
HXDLIN( 326)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 326)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 326)									if ((cx > bx)) {
HXDLIN( 326)										if ((cx > cx1)) {
HXDLIN( 326)											int min;
HXDLIN( 326)											if ((bx > cx1)) {
HXDLIN( 326)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 326)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 326)											int ii_min = min;
HXDLIN( 326)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 326)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 326)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 326)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 326)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 326)										if ((bx > cx1)) {
HXDLIN( 326)											int min1;
HXDLIN( 326)											if ((cx > cx1)) {
HXDLIN( 326)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 326)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 326)											int ii_min2 = min1;
HXDLIN( 326)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 326)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 326)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 326)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 326)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 326)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 326)									if ((cy > by)) {
HXDLIN( 326)										if ((cy > cy1)) {
HXDLIN( 326)											int min2;
HXDLIN( 326)											if ((by > cy1)) {
HXDLIN( 326)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 326)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 326)											int ii_min4 = min2;
HXDLIN( 326)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 326)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 326)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 326)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 326)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 326)										if ((by > cy1)) {
HXDLIN( 326)											int min3;
HXDLIN( 326)											if ((cy > cy1)) {
HXDLIN( 326)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 326)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 326)											int ii_min6 = min3;
HXDLIN( 326)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 326)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 326)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 326)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 326)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 326)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 326)									if (hasUndo) {
HXDLIN( 326)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 326)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 326)										 ::Dynamic imageType = null();
HXDLIN( 326)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 326)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 326)										::Dynamic undoImage1;
HXDLIN( 326)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 326)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 326)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 326)												{
HXDLIN( 326)													b->width = width;
HXDLIN( 326)													b->height = height;
HXDLIN( 326)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 326)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 326)													{
HXDLIN( 326)														int len = b->length;
HXDLIN( 326)														int w = 0;
HXDLIN( 326)														{
HXDLIN( 326)															int _g2 = 0;
HXDLIN( 326)															int _g3 = b->height;
HXDLIN( 326)															while((_g2 < _g3)){
HXDLIN( 326)																_g2 = (_g2 + 1);
HXDLIN( 326)																int y = (_g2 - 1);
HXDLIN( 326)																{
HXDLIN( 326)																	int _g4 = 0;
HXDLIN( 326)																	int _g5 = b->width;
HXDLIN( 326)																	while((_g4 < _g5)){
HXDLIN( 326)																		_g4 = (_g4 + 1);
HXDLIN( 326)																		int x = (_g4 - 1);
HXDLIN( 326)																		{
HXDLIN( 326)																			w = (w + 1);
HXDLIN( 326)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 326)																		{
HXDLIN( 326)																			w = (w + 1);
HXDLIN( 326)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 326)																		{
HXDLIN( 326)																			w = (w + 1);
HXDLIN( 326)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 326)																		{
HXDLIN( 326)																			w = (w + 1);
HXDLIN( 326)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 326)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 326)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 326)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 326)												{
HXDLIN( 326)													a->width = width;
HXDLIN( 326)													a->height = height;
HXDLIN( 326)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 326)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 326)													{
HXDLIN( 326)														int _g6 = 0;
HXDLIN( 326)														int _g7 = a->length;
HXDLIN( 326)														while((_g6 < _g7)){
HXDLIN( 326)															_g6 = (_g6 + 1);
HXDLIN( 326)															int i1 = (_g6 - 1);
HXDLIN( 326)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 326)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 326)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 326)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 326)												{
HXDLIN( 326)													b1->width = width;
HXDLIN( 326)													b1->height = height;
HXDLIN( 326)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 326)													int size = (b1->length * 4);
HXDLIN( 326)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 326)													{
HXDLIN( 326)														int _g8 = 0;
HXDLIN( 326)														int _g9 = b1->length;
HXDLIN( 326)														while((_g8 < _g9)){
HXDLIN( 326)															_g8 = (_g8 + 1);
HXDLIN( 326)															int i2 = (_g8 - 1);
HXDLIN( 326)															{
HXDLIN( 326)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 326)																bool undoImage2;
HXDLIN( 326)																if ((i2 >= 0)) {
HXDLIN( 326)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 326)																	undoImage2 = false;
            																}
HXDLIN( 326)																if (undoImage2) {
HXDLIN( 326)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 326)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 326)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 326)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 326)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 326)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 326)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 326)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 326)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 326)												{
HXDLIN( 326)													v1->width = width;
HXDLIN( 326)													v1->height = height;
HXDLIN( 326)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 326)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 326)													{
HXDLIN( 326)														int _g10 = 0;
HXDLIN( 326)														int _g11 = v1->length;
HXDLIN( 326)														while((_g10 < _g11)){
HXDLIN( 326)															_g10 = (_g10 + 1);
HXDLIN( 326)															int i3 = (_g10 - 1);
HXDLIN( 326)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 326)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 326)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 326)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 326)												{
HXDLIN( 326)													b2->width = width;
HXDLIN( 326)													b2->height = height;
HXDLIN( 326)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 326)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 326)													{
HXDLIN( 326)														int len1 = b2->length;
HXDLIN( 326)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 326)														if (::hx::IsNull( d->head )) {
HXDLIN( 326)															int _g12 = 0;
HXDLIN( 326)															int _g13 = len1;
HXDLIN( 326)															while((_g12 < _g13)){
HXDLIN( 326)																_g12 = (_g12 + 1);
HXDLIN( 326)																int i4 = (_g12 - 1);
HXDLIN( 326)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 326)															int _g14 = 0;
HXDLIN( 326)															int _g15 = len1;
HXDLIN( 326)															while((_g14 < _g15)){
HXDLIN( 326)																_g14 = (_g14 + 1);
HXDLIN( 326)																int i5 = (_g14 - 1);
HXDLIN( 326)																{
HXDLIN( 326)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 326)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 326)																	{
HXDLIN( 326)																		int _g16 = 0;
HXDLIN( 326)																		int _g17 = i5;
HXDLIN( 326)																		while((_g16 < _g17)){
HXDLIN( 326)																			_g16 = (_g16 + 1);
HXDLIN( 326)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 326)																	if (::hx::IsNull( prev )) {
HXDLIN( 326)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 326)																		l = null();
            																	}
            																	else {
HXDLIN( 326)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 326)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 326)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 326)										this3->image = undoImage1;
HXDLIN( 326)										this3->width = width;
HXDLIN( 326)										this3->height = height;
HXDLIN( 326)										this3->imageType = ( (int)(imageType) );
HXDLIN( 326)										undoImage = this3;
HXDLIN( 326)										{
HXDLIN( 326)											int rectLeft = xIter3->start;
HXDLIN( 326)											int rectTop = yIter3->start;
HXDLIN( 326)											int rectRight = xIter3->max;
HXDLIN( 326)											bool forceClear = false;
HXDLIN( 326)											{
HXDLIN( 326)												int _g18 = rectTop;
HXDLIN( 326)												int _g19 = yIter3->max;
HXDLIN( 326)												while((_g18 < _g19)){
HXDLIN( 326)													_g18 = (_g18 + 1);
HXDLIN( 326)													int dy = (_g18 - 1);
HXDLIN( 326)													{
HXDLIN( 326)														int _g20 = rectLeft;
HXDLIN( 326)														int _g21 = rectRight;
HXDLIN( 326)														while((_g20 < _g21)){
HXDLIN( 326)															_g20 = (_g20 + 1);
HXDLIN( 326)															int dx = (_g20 - 1);
HXDLIN( 326)															::Dynamic this5 = this2->image;
HXDLIN( 326)															int index;
HXDLIN( 326)															if (this2->useVirtualPos) {
HXDLIN( 326)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 326)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 326)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 326)															int col;
HXDLIN( 326)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 326)																col = c;
            															}
HXDLIN( 326)															bool _hx_tmp;
HXDLIN( 326)															if (this2->useMask) {
HXDLIN( 326)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 326)																_hx_tmp = false;
            															}
HXDLIN( 326)															if (_hx_tmp) {
HXDLIN( 326)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 326)																::Dynamic this7 = this6->image;
HXDLIN( 326)																int index1;
HXDLIN( 326)																if (this6->useVirtualPos) {
HXDLIN( 326)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 326)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 326)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 326)																int v2;
HXDLIN( 326)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 326)																	v2 = c1;
            																}
HXDLIN( 326)																int maskPixel = v2;
HXDLIN( 326)																int this8 = col;
HXDLIN( 326)																if ((maskPixel == 0)) {
HXDLIN( 326)																	col = this8;
            																}
            																else {
HXDLIN( 326)																	Float m0;
HXDLIN( 326)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 326)																	if ((this9 == 0)) {
HXDLIN( 326)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float m1;
HXDLIN( 326)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 326)																	if ((this10 == 0)) {
HXDLIN( 326)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float m2;
HXDLIN( 326)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 326)																	if ((this11 == 0)) {
HXDLIN( 326)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float m3;
HXDLIN( 326)																	int this12 = (maskPixel & 255);
HXDLIN( 326)																	if ((this12 == 0)) {
HXDLIN( 326)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 326)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 326)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 326)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 326)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 326)															if ((col != 0)) {
HXDLIN( 326)																int x1 = (dx - rectLeft);
HXDLIN( 326)																int y1 = (dy - rectTop);
HXDLIN( 326)																int c2 = col;
HXDLIN( 326)																bool _hx_tmp1;
HXDLIN( 326)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 326)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 326)																	_hx_tmp1 = false;
            																}
HXDLIN( 326)																if (_hx_tmp1) {
HXDLIN( 326)																	int location;
HXDLIN( 326)																	if (undoImage->useVirtualPos) {
HXDLIN( 326)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 326)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 326)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 326)																	int this14;
HXDLIN( 326)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 326)																		this14 = this13;
            																	}
HXDLIN( 326)																	Float a1;
HXDLIN( 326)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 326)																	if ((this15 == 0)) {
HXDLIN( 326)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float r1;
HXDLIN( 326)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 326)																	if ((this16 == 0)) {
HXDLIN( 326)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float g1;
HXDLIN( 326)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 326)																	if ((this17 == 0)) {
HXDLIN( 326)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float b11;
HXDLIN( 326)																	int this18 = (this14 & 255);
HXDLIN( 326)																	if ((this18 == 0)) {
HXDLIN( 326)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float a2;
HXDLIN( 326)																	int this19 = ((col >> 24) & 255);
HXDLIN( 326)																	if ((this19 == 0)) {
HXDLIN( 326)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float r2;
HXDLIN( 326)																	int this20 = ((col >> 16) & 255);
HXDLIN( 326)																	if ((this20 == 0)) {
HXDLIN( 326)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float g2;
HXDLIN( 326)																	int this21 = ((col >> 8) & 255);
HXDLIN( 326)																	if ((this21 == 0)) {
HXDLIN( 326)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float b21;
HXDLIN( 326)																	int this22 = (col & 255);
HXDLIN( 326)																	if ((this22 == 0)) {
HXDLIN( 326)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 326)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 326)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 326)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 326)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 326)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 326)																	{
HXDLIN( 326)																		int _hx_tmp2;
HXDLIN( 326)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 326)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 326)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 326)																	::Dynamic this23 = undoImage->image;
HXDLIN( 326)																	int index2;
HXDLIN( 326)																	if (undoImage->useVirtualPos) {
HXDLIN( 326)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 326)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 326)																	int _hx_tmp3;
HXDLIN( 326)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 326)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 326)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 326)																if (forceClear) {
HXDLIN( 326)																	::Dynamic this24 = undoImage->image;
HXDLIN( 326)																	int x2 = (dx - rectLeft);
HXDLIN( 326)																	int y2 = (dy - rectTop);
HXDLIN( 326)																	int index3;
HXDLIN( 326)																	if (undoImage->useVirtualPos) {
HXDLIN( 326)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 326)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 326)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 326)									bool found = false;
HXDLIN( 326)									Float s = ((Float)0.);
HXDLIN( 326)									Float t = ((Float)0.);
HXDLIN( 326)									Float sxx = ((Float)0.);
HXDLIN( 326)									Float txx = ((Float)0.);
HXDLIN( 326)									{
HXDLIN( 326)										int _g_min = xIter3->start;
HXDLIN( 326)										int _g_max = xIter3->max;
HXDLIN( 326)										while((_g_min < _g_max)){
HXDLIN( 326)											_g_min = (_g_min + 1);
HXDLIN( 326)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 326)											{
HXDLIN( 326)												int _g_min1 = yIter3->start;
HXDLIN( 326)												int _g_max1 = yIter3->max;
HXDLIN( 326)												while((_g_min1 < _g_max1)){
HXDLIN( 326)													_g_min1 = (_g_min1 + 1);
HXDLIN( 326)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 326)													bool _hx_tmp4;
HXDLIN( 326)													if (!((s <= 0))) {
HXDLIN( 326)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 326)														_hx_tmp4 = true;
            													}
HXDLIN( 326)													if (_hx_tmp4) {
HXDLIN( 326)														if (found) {
HXDLIN( 326)															goto _hx_goto_631;
            														}
            													}
            													else {
HXDLIN( 326)														if (((s + t) < A)) {
HXDLIN( 326)															{
HXDLIN( 326)																int c3 = color;
HXDLIN( 326)																bool _hx_tmp5;
HXDLIN( 326)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 326)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 326)																	_hx_tmp5 = false;
            																}
HXDLIN( 326)																if (_hx_tmp5) {
HXDLIN( 326)																	int location1;
HXDLIN( 326)																	if (this2->useVirtualPos) {
HXDLIN( 326)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 326)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 326)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 326)																	int this26;
HXDLIN( 326)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 326)																		this26 = this25;
            																	}
HXDLIN( 326)																	Float a11;
HXDLIN( 326)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 326)																	if ((this27 == 0)) {
HXDLIN( 326)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float r11;
HXDLIN( 326)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 326)																	if ((this28 == 0)) {
HXDLIN( 326)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float g11;
HXDLIN( 326)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 326)																	if ((this29 == 0)) {
HXDLIN( 326)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float b12;
HXDLIN( 326)																	int this30 = (this26 & 255);
HXDLIN( 326)																	if ((this30 == 0)) {
HXDLIN( 326)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float a21;
HXDLIN( 326)																	int this31 = ((color >> 24) & 255);
HXDLIN( 326)																	if ((this31 == 0)) {
HXDLIN( 326)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float r21;
HXDLIN( 326)																	int this32 = ((color >> 16) & 255);
HXDLIN( 326)																	if ((this32 == 0)) {
HXDLIN( 326)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float g21;
HXDLIN( 326)																	int this33 = ((color >> 8) & 255);
HXDLIN( 326)																	if ((this33 == 0)) {
HXDLIN( 326)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float b22;
HXDLIN( 326)																	int this34 = (color & 255);
HXDLIN( 326)																	if ((this34 == 0)) {
HXDLIN( 326)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 326)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 326)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 326)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 326)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 326)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 326)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 326)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 326)																	{
HXDLIN( 326)																		int _hx_tmp6;
HXDLIN( 326)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 326)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 326)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 326)																	::Dynamic this35 = this2->image;
HXDLIN( 326)																	int index4;
HXDLIN( 326)																	if (this2->useVirtualPos) {
HXDLIN( 326)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 326)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 326)																	int _hx_tmp7;
HXDLIN( 326)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 326)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 326)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 326)															if (found) {
HXDLIN( 326)																goto _hx_goto_631;
            															}
            														}
            													}
            												}
            												_hx_goto_631:;
            											}
            										}
            									}
HXDLIN( 326)									if ((hasHit == true)) {
HXDLIN( 326)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 326)										if (hasUndo) {
HXDLIN( 326)											v3->undoImage = undoImage;
HXDLIN( 326)											v3->undoX = xIter3->start;
HXDLIN( 326)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 326)				int _g22 = 0;
HXDLIN( 326)				int _g23 = (sides1 + 1);
HXDLIN( 326)				while((_g22 < _g23)){
HXDLIN( 326)					_g22 = (_g22 + 1);
HXDLIN( 326)					int i7 = (_g22 - 1);
HXDLIN( 326)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 326)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 326)					{
HXDLIN( 326)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 326)						bool hasHit1 = false;
HXDLIN( 326)						bool hasUndo1 = false;
HXDLIN( 326)						{
HXDLIN( 326)							Float bx1 = lastX;
HXDLIN( 326)							Float by1 = lastY;
HXDLIN( 326)							Float cx2 = nextX1;
HXDLIN( 326)							Float cy2 = nextY1;
HXDLIN( 326)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 326)							if (!(adjustWinding1)) {
HXDLIN( 326)								Float bx_1 = bx1;
HXDLIN( 326)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 326)							{
HXDLIN( 326)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 326)								Float sx1 = (cy2 - cy);
HXDLIN( 326)								Float sy1 = (cx - cx2);
HXDLIN( 326)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 326)								Float tx1 = (cy - by1);
HXDLIN( 326)								Float ty1 = (bx1 - cx);
HXDLIN( 326)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 326)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 326)								if ((cx > bx1)) {
HXDLIN( 326)									if ((cx > cx2)) {
HXDLIN( 326)										int min4;
HXDLIN( 326)										if ((bx1 > cx2)) {
HXDLIN( 326)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 326)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 326)										int ii_min8 = min4;
HXDLIN( 326)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 326)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 326)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 326)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 326)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 326)									if ((bx1 > cx2)) {
HXDLIN( 326)										int min5;
HXDLIN( 326)										if ((cx > cx2)) {
HXDLIN( 326)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 326)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 326)										int ii_min10 = min5;
HXDLIN( 326)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 326)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 326)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 326)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 326)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 326)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 326)								if ((cy > by1)) {
HXDLIN( 326)									if ((cy > cy2)) {
HXDLIN( 326)										int min6;
HXDLIN( 326)										if ((by1 > cy2)) {
HXDLIN( 326)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 326)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 326)										int ii_min12 = min6;
HXDLIN( 326)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 326)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 326)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 326)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 326)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 326)									if ((by1 > cy2)) {
HXDLIN( 326)										int min7;
HXDLIN( 326)										if ((cy > cy2)) {
HXDLIN( 326)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 326)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 326)										int ii_min14 = min7;
HXDLIN( 326)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 326)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 326)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 326)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 326)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 326)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 326)								if (hasUndo1) {
HXDLIN( 326)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 326)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 326)									 ::Dynamic imageType1 = null();
HXDLIN( 326)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 326)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 326)									::Dynamic undoImage4;
HXDLIN( 326)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 326)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 326)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 326)											{
HXDLIN( 326)												b5->width = width1;
HXDLIN( 326)												b5->height = height1;
HXDLIN( 326)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 326)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 326)												{
HXDLIN( 326)													int len2 = b5->length;
HXDLIN( 326)													int w1 = 0;
HXDLIN( 326)													{
HXDLIN( 326)														int _g24 = 0;
HXDLIN( 326)														int _g25 = b5->height;
HXDLIN( 326)														while((_g24 < _g25)){
HXDLIN( 326)															_g24 = (_g24 + 1);
HXDLIN( 326)															int y4 = (_g24 - 1);
HXDLIN( 326)															{
HXDLIN( 326)																int _g26 = 0;
HXDLIN( 326)																int _g27 = b5->width;
HXDLIN( 326)																while((_g26 < _g27)){
HXDLIN( 326)																	_g26 = (_g26 + 1);
HXDLIN( 326)																	int x4 = (_g26 - 1);
HXDLIN( 326)																	{
HXDLIN( 326)																		w1 = (w1 + 1);
HXDLIN( 326)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 326)																	{
HXDLIN( 326)																		w1 = (w1 + 1);
HXDLIN( 326)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 326)																	{
HXDLIN( 326)																		w1 = (w1 + 1);
HXDLIN( 326)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 326)																	{
HXDLIN( 326)																		w1 = (w1 + 1);
HXDLIN( 326)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 326)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 326)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 326)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 326)											{
HXDLIN( 326)												a6->width = width1;
HXDLIN( 326)												a6->height = height1;
HXDLIN( 326)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 326)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 326)												{
HXDLIN( 326)													int _g28 = 0;
HXDLIN( 326)													int _g29 = a6->length;
HXDLIN( 326)													while((_g28 < _g29)){
HXDLIN( 326)														_g28 = (_g28 + 1);
HXDLIN( 326)														int i8 = (_g28 - 1);
HXDLIN( 326)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 326)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 326)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 326)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 326)											{
HXDLIN( 326)												b6->width = width1;
HXDLIN( 326)												b6->height = height1;
HXDLIN( 326)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 326)												int size1 = (b6->length * 4);
HXDLIN( 326)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 326)												{
HXDLIN( 326)													int _g30 = 0;
HXDLIN( 326)													int _g31 = b6->length;
HXDLIN( 326)													while((_g30 < _g31)){
HXDLIN( 326)														_g30 = (_g30 + 1);
HXDLIN( 326)														int i9 = (_g30 - 1);
HXDLIN( 326)														{
HXDLIN( 326)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 326)															bool undoImage5;
HXDLIN( 326)															if ((i9 >= 0)) {
HXDLIN( 326)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 326)																undoImage5 = false;
            															}
HXDLIN( 326)															if (undoImage5) {
HXDLIN( 326)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 326)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 326)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 326)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 326)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 326)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 326)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 326)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 326)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 326)											{
HXDLIN( 326)												v4->width = width1;
HXDLIN( 326)												v4->height = height1;
HXDLIN( 326)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 326)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 326)												{
HXDLIN( 326)													int _g32 = 0;
HXDLIN( 326)													int _g33 = v4->length;
HXDLIN( 326)													while((_g32 < _g33)){
HXDLIN( 326)														_g32 = (_g32 + 1);
HXDLIN( 326)														int i10 = (_g32 - 1);
HXDLIN( 326)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 326)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 326)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 326)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 326)											{
HXDLIN( 326)												b7->width = width1;
HXDLIN( 326)												b7->height = height1;
HXDLIN( 326)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 326)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 326)												{
HXDLIN( 326)													int len3 = b7->length;
HXDLIN( 326)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 326)													if (::hx::IsNull( d1->head )) {
HXDLIN( 326)														int _g34 = 0;
HXDLIN( 326)														int _g35 = len3;
HXDLIN( 326)														while((_g34 < _g35)){
HXDLIN( 326)															_g34 = (_g34 + 1);
HXDLIN( 326)															int i11 = (_g34 - 1);
HXDLIN( 326)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 326)														int _g36 = 0;
HXDLIN( 326)														int _g37 = len3;
HXDLIN( 326)														while((_g36 < _g37)){
HXDLIN( 326)															_g36 = (_g36 + 1);
HXDLIN( 326)															int i12 = (_g36 - 1);
HXDLIN( 326)															{
HXDLIN( 326)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 326)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 326)																{
HXDLIN( 326)																	int _g38 = 0;
HXDLIN( 326)																	int _g39 = i12;
HXDLIN( 326)																	while((_g38 < _g39)){
HXDLIN( 326)																		_g38 = (_g38 + 1);
HXDLIN( 326)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 326)																if (::hx::IsNull( prev1 )) {
HXDLIN( 326)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 326)																	l1 = null();
            																}
            																else {
HXDLIN( 326)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 326)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 326)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 326)									this37->image = undoImage4;
HXDLIN( 326)									this37->width = width1;
HXDLIN( 326)									this37->height = height1;
HXDLIN( 326)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 326)									undoImage3 = this37;
HXDLIN( 326)									{
HXDLIN( 326)										int rectLeft1 = xIter31->start;
HXDLIN( 326)										int rectTop1 = yIter31->start;
HXDLIN( 326)										int rectRight1 = xIter31->max;
HXDLIN( 326)										bool forceClear1 = false;
HXDLIN( 326)										{
HXDLIN( 326)											int _g40 = rectTop1;
HXDLIN( 326)											int _g41 = yIter31->max;
HXDLIN( 326)											while((_g40 < _g41)){
HXDLIN( 326)												_g40 = (_g40 + 1);
HXDLIN( 326)												int dy1 = (_g40 - 1);
HXDLIN( 326)												{
HXDLIN( 326)													int _g42 = rectLeft1;
HXDLIN( 326)													int _g43 = rectRight1;
HXDLIN( 326)													while((_g42 < _g43)){
HXDLIN( 326)														_g42 = (_g42 + 1);
HXDLIN( 326)														int dx1 = (_g42 - 1);
HXDLIN( 326)														::Dynamic this39 = this36->image;
HXDLIN( 326)														int index5;
HXDLIN( 326)														if (this36->useVirtualPos) {
HXDLIN( 326)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 326)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 326)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 326)														int col1;
HXDLIN( 326)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 326)															col1 = c4;
            														}
HXDLIN( 326)														bool _hx_tmp8;
HXDLIN( 326)														if (this36->useMask) {
HXDLIN( 326)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 326)															_hx_tmp8 = false;
            														}
HXDLIN( 326)														if (_hx_tmp8) {
HXDLIN( 326)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 326)															::Dynamic this41 = this40->image;
HXDLIN( 326)															int index6;
HXDLIN( 326)															if (this40->useVirtualPos) {
HXDLIN( 326)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 326)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 326)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 326)															int v5;
HXDLIN( 326)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 326)																v5 = c5;
            															}
HXDLIN( 326)															int maskPixel1 = v5;
HXDLIN( 326)															int this42 = col1;
HXDLIN( 326)															if ((maskPixel1 == 0)) {
HXDLIN( 326)																col1 = this42;
            															}
            															else {
HXDLIN( 326)																Float m01;
HXDLIN( 326)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 326)																if ((this43 == 0)) {
HXDLIN( 326)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float m11;
HXDLIN( 326)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 326)																if ((this44 == 0)) {
HXDLIN( 326)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float m21;
HXDLIN( 326)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 326)																if ((this45 == 0)) {
HXDLIN( 326)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float m31;
HXDLIN( 326)																int this46 = (maskPixel1 & 255);
HXDLIN( 326)																if ((this46 == 0)) {
HXDLIN( 326)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 326)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 326)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 326)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 326)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 326)														if ((col1 != 0)) {
HXDLIN( 326)															int x5 = (dx1 - rectLeft1);
HXDLIN( 326)															int y5 = (dy1 - rectTop1);
HXDLIN( 326)															int c6 = col1;
HXDLIN( 326)															bool _hx_tmp9;
HXDLIN( 326)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 326)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 326)																_hx_tmp9 = false;
            															}
HXDLIN( 326)															if (_hx_tmp9) {
HXDLIN( 326)																int location2;
HXDLIN( 326)																if (undoImage3->useVirtualPos) {
HXDLIN( 326)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 326)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 326)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 326)																int this48;
HXDLIN( 326)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 326)																	this48 = this47;
            																}
HXDLIN( 326)																Float a12;
HXDLIN( 326)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 326)																if ((this49 == 0)) {
HXDLIN( 326)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float r12;
HXDLIN( 326)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 326)																if ((this50 == 0)) {
HXDLIN( 326)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float g12;
HXDLIN( 326)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 326)																if ((this51 == 0)) {
HXDLIN( 326)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float b13;
HXDLIN( 326)																int this52 = (this48 & 255);
HXDLIN( 326)																if ((this52 == 0)) {
HXDLIN( 326)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float a22;
HXDLIN( 326)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 326)																if ((this53 == 0)) {
HXDLIN( 326)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float r22;
HXDLIN( 326)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 326)																if ((this54 == 0)) {
HXDLIN( 326)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float g22;
HXDLIN( 326)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 326)																if ((this55 == 0)) {
HXDLIN( 326)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float b23;
HXDLIN( 326)																int this56 = (col1 & 255);
HXDLIN( 326)																if ((this56 == 0)) {
HXDLIN( 326)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 326)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 326)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 326)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 326)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 326)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 326)																{
HXDLIN( 326)																	int _hx_tmp10;
HXDLIN( 326)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 326)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 326)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 326)																::Dynamic this57 = undoImage3->image;
HXDLIN( 326)																int index7;
HXDLIN( 326)																if (undoImage3->useVirtualPos) {
HXDLIN( 326)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 326)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 326)																int _hx_tmp11;
HXDLIN( 326)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 326)																	_hx_tmp11 = c6;
            																}
HXDLIN( 326)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 326)															if (forceClear1) {
HXDLIN( 326)																::Dynamic this58 = undoImage3->image;
HXDLIN( 326)																int x6 = (dx1 - rectLeft1);
HXDLIN( 326)																int y6 = (dy1 - rectTop1);
HXDLIN( 326)																int index8;
HXDLIN( 326)																if (undoImage3->useVirtualPos) {
HXDLIN( 326)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 326)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 326)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 326)								bool found1 = false;
HXDLIN( 326)								Float s1 = ((Float)0.);
HXDLIN( 326)								Float t1 = ((Float)0.);
HXDLIN( 326)								Float sxx1 = ((Float)0.);
HXDLIN( 326)								Float txx1 = ((Float)0.);
HXDLIN( 326)								{
HXDLIN( 326)									int _g_min2 = xIter31->start;
HXDLIN( 326)									int _g_max2 = xIter31->max;
HXDLIN( 326)									while((_g_min2 < _g_max2)){
HXDLIN( 326)										_g_min2 = (_g_min2 + 1);
HXDLIN( 326)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 326)										{
HXDLIN( 326)											int _g_min3 = yIter31->start;
HXDLIN( 326)											int _g_max3 = yIter31->max;
HXDLIN( 326)											while((_g_min3 < _g_max3)){
HXDLIN( 326)												_g_min3 = (_g_min3 + 1);
HXDLIN( 326)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 326)												bool _hx_tmp12;
HXDLIN( 326)												if (!((s1 <= 0))) {
HXDLIN( 326)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 326)													_hx_tmp12 = true;
            												}
HXDLIN( 326)												if (_hx_tmp12) {
HXDLIN( 326)													if (found1) {
HXDLIN( 326)														goto _hx_goto_644;
            													}
            												}
            												else {
HXDLIN( 326)													if (((s1 + t1) < A1)) {
HXDLIN( 326)														{
HXDLIN( 326)															int c7 = color;
HXDLIN( 326)															bool _hx_tmp13;
HXDLIN( 326)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 326)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 326)																_hx_tmp13 = false;
            															}
HXDLIN( 326)															if (_hx_tmp13) {
HXDLIN( 326)																int location3;
HXDLIN( 326)																if (this36->useVirtualPos) {
HXDLIN( 326)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 326)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 326)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 326)																int this60;
HXDLIN( 326)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 326)																	this60 = this59;
            																}
HXDLIN( 326)																Float a13;
HXDLIN( 326)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 326)																if ((this61 == 0)) {
HXDLIN( 326)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float r13;
HXDLIN( 326)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 326)																if ((this62 == 0)) {
HXDLIN( 326)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float g13;
HXDLIN( 326)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 326)																if ((this63 == 0)) {
HXDLIN( 326)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float b14;
HXDLIN( 326)																int this64 = (this60 & 255);
HXDLIN( 326)																if ((this64 == 0)) {
HXDLIN( 326)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float a23;
HXDLIN( 326)																int this65 = ((color >> 24) & 255);
HXDLIN( 326)																if ((this65 == 0)) {
HXDLIN( 326)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float r23;
HXDLIN( 326)																int this66 = ((color >> 16) & 255);
HXDLIN( 326)																if ((this66 == 0)) {
HXDLIN( 326)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float g23;
HXDLIN( 326)																int this67 = ((color >> 8) & 255);
HXDLIN( 326)																if ((this67 == 0)) {
HXDLIN( 326)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float b24;
HXDLIN( 326)																int this68 = (color & 255);
HXDLIN( 326)																if ((this68 == 0)) {
HXDLIN( 326)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 326)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 326)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 326)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 326)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 326)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 326)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 326)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 326)																{
HXDLIN( 326)																	int _hx_tmp14;
HXDLIN( 326)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 326)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 326)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 326)																::Dynamic this69 = this36->image;
HXDLIN( 326)																int index9;
HXDLIN( 326)																if (this36->useVirtualPos) {
HXDLIN( 326)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 326)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 326)																int _hx_tmp15;
HXDLIN( 326)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 326)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 326)																	_hx_tmp15 = c7;
            																}
HXDLIN( 326)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 326)														if (found1) {
HXDLIN( 326)															goto _hx_goto_644;
            														}
            													}
            												}
            											}
            											_hx_goto_644:;
            										}
            									}
            								}
HXDLIN( 326)								if ((hasHit1 == true)) {
HXDLIN( 326)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 326)									if (hasUndo1) {
HXDLIN( 326)										v6->undoImage = undoImage3;
HXDLIN( 326)										v6->undoX = xIter31->start;
HXDLIN( 326)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,decagon,(void))

void FillShape_Impl__obj::hendecagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_339_hendecagon)
HXDLIN( 339)		 ::Dynamic phi1 = phi;
HXDLIN( 339)		 ::Dynamic sides = 11;
HXLINE( 343)		if (::hx::IsNull( sides )) {
HXLINE( 343)			sides = 36;
            		}
HXLINE( 342)		if (::hx::IsNull( phi1 )) {
HXLINE( 342)			phi1 = ((Float)0.);
            		}
HXLINE( 339)		{
HXDLIN( 339)			 ::Dynamic phi2 = phi1;
HXDLIN( 339)			 ::Dynamic sides1 = sides;
HXDLIN( 339)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 339)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 339)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 339)			Float omega;
HXDLIN( 339)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 339)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 339)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 339)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 339)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 339)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 339)			Float lastX = ((Float)0.);
HXDLIN( 339)			Float lastY = ((Float)0.);
HXDLIN( 339)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 339)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 339)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 339)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 339)				{
HXDLIN( 339)					int _g = 0;
HXDLIN( 339)					int _g1 = (sides1 + 1);
HXDLIN( 339)					while((_g < _g1)){
HXDLIN( 339)						_g = (_g + 1);
HXDLIN( 339)						int i = (_g - 1);
HXDLIN( 339)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 339)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 339)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 339)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 339)						{
HXDLIN( 339)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 339)							bool hasHit = false;
HXDLIN( 339)							bool hasUndo = false;
HXDLIN( 339)							{
HXDLIN( 339)								Float bx = lastX;
HXDLIN( 339)								Float by = lastY;
HXDLIN( 339)								Float cx1 = nextX;
HXDLIN( 339)								Float cy1 = nextY;
HXDLIN( 339)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 339)								if (!(adjustWinding)) {
HXDLIN( 339)									Float bx_ = bx;
HXDLIN( 339)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 339)								{
HXDLIN( 339)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 339)									Float sx = (cy1 - cy);
HXDLIN( 339)									Float sy = (cx - cx1);
HXDLIN( 339)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 339)									Float tx = (cy - by);
HXDLIN( 339)									Float ty = (bx - cx);
HXDLIN( 339)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 339)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 339)									if ((cx > bx)) {
HXDLIN( 339)										if ((cx > cx1)) {
HXDLIN( 339)											int min;
HXDLIN( 339)											if ((bx > cx1)) {
HXDLIN( 339)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 339)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 339)											int ii_min = min;
HXDLIN( 339)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 339)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 339)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 339)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 339)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 339)										if ((bx > cx1)) {
HXDLIN( 339)											int min1;
HXDLIN( 339)											if ((cx > cx1)) {
HXDLIN( 339)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 339)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 339)											int ii_min2 = min1;
HXDLIN( 339)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 339)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 339)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 339)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 339)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 339)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 339)									if ((cy > by)) {
HXDLIN( 339)										if ((cy > cy1)) {
HXDLIN( 339)											int min2;
HXDLIN( 339)											if ((by > cy1)) {
HXDLIN( 339)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 339)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 339)											int ii_min4 = min2;
HXDLIN( 339)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 339)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 339)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 339)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 339)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 339)										if ((by > cy1)) {
HXDLIN( 339)											int min3;
HXDLIN( 339)											if ((cy > cy1)) {
HXDLIN( 339)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 339)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 339)											int ii_min6 = min3;
HXDLIN( 339)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 339)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 339)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 339)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 339)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 339)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 339)									if (hasUndo) {
HXDLIN( 339)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 339)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 339)										 ::Dynamic imageType = null();
HXDLIN( 339)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 339)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 339)										::Dynamic undoImage1;
HXDLIN( 339)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 339)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 339)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 339)												{
HXDLIN( 339)													b->width = width;
HXDLIN( 339)													b->height = height;
HXDLIN( 339)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 339)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 339)													{
HXDLIN( 339)														int len = b->length;
HXDLIN( 339)														int w = 0;
HXDLIN( 339)														{
HXDLIN( 339)															int _g2 = 0;
HXDLIN( 339)															int _g3 = b->height;
HXDLIN( 339)															while((_g2 < _g3)){
HXDLIN( 339)																_g2 = (_g2 + 1);
HXDLIN( 339)																int y = (_g2 - 1);
HXDLIN( 339)																{
HXDLIN( 339)																	int _g4 = 0;
HXDLIN( 339)																	int _g5 = b->width;
HXDLIN( 339)																	while((_g4 < _g5)){
HXDLIN( 339)																		_g4 = (_g4 + 1);
HXDLIN( 339)																		int x = (_g4 - 1);
HXDLIN( 339)																		{
HXDLIN( 339)																			w = (w + 1);
HXDLIN( 339)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 339)																		{
HXDLIN( 339)																			w = (w + 1);
HXDLIN( 339)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 339)																		{
HXDLIN( 339)																			w = (w + 1);
HXDLIN( 339)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 339)																		{
HXDLIN( 339)																			w = (w + 1);
HXDLIN( 339)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 339)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 339)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 339)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 339)												{
HXDLIN( 339)													a->width = width;
HXDLIN( 339)													a->height = height;
HXDLIN( 339)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 339)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 339)													{
HXDLIN( 339)														int _g6 = 0;
HXDLIN( 339)														int _g7 = a->length;
HXDLIN( 339)														while((_g6 < _g7)){
HXDLIN( 339)															_g6 = (_g6 + 1);
HXDLIN( 339)															int i1 = (_g6 - 1);
HXDLIN( 339)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 339)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 339)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 339)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 339)												{
HXDLIN( 339)													b1->width = width;
HXDLIN( 339)													b1->height = height;
HXDLIN( 339)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 339)													int size = (b1->length * 4);
HXDLIN( 339)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 339)													{
HXDLIN( 339)														int _g8 = 0;
HXDLIN( 339)														int _g9 = b1->length;
HXDLIN( 339)														while((_g8 < _g9)){
HXDLIN( 339)															_g8 = (_g8 + 1);
HXDLIN( 339)															int i2 = (_g8 - 1);
HXDLIN( 339)															{
HXDLIN( 339)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 339)																bool undoImage2;
HXDLIN( 339)																if ((i2 >= 0)) {
HXDLIN( 339)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 339)																	undoImage2 = false;
            																}
HXDLIN( 339)																if (undoImage2) {
HXDLIN( 339)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 339)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 339)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 339)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 339)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 339)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 339)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 339)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 339)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 339)												{
HXDLIN( 339)													v1->width = width;
HXDLIN( 339)													v1->height = height;
HXDLIN( 339)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 339)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 339)													{
HXDLIN( 339)														int _g10 = 0;
HXDLIN( 339)														int _g11 = v1->length;
HXDLIN( 339)														while((_g10 < _g11)){
HXDLIN( 339)															_g10 = (_g10 + 1);
HXDLIN( 339)															int i3 = (_g10 - 1);
HXDLIN( 339)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 339)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 339)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 339)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 339)												{
HXDLIN( 339)													b2->width = width;
HXDLIN( 339)													b2->height = height;
HXDLIN( 339)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 339)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 339)													{
HXDLIN( 339)														int len1 = b2->length;
HXDLIN( 339)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 339)														if (::hx::IsNull( d->head )) {
HXDLIN( 339)															int _g12 = 0;
HXDLIN( 339)															int _g13 = len1;
HXDLIN( 339)															while((_g12 < _g13)){
HXDLIN( 339)																_g12 = (_g12 + 1);
HXDLIN( 339)																int i4 = (_g12 - 1);
HXDLIN( 339)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 339)															int _g14 = 0;
HXDLIN( 339)															int _g15 = len1;
HXDLIN( 339)															while((_g14 < _g15)){
HXDLIN( 339)																_g14 = (_g14 + 1);
HXDLIN( 339)																int i5 = (_g14 - 1);
HXDLIN( 339)																{
HXDLIN( 339)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 339)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 339)																	{
HXDLIN( 339)																		int _g16 = 0;
HXDLIN( 339)																		int _g17 = i5;
HXDLIN( 339)																		while((_g16 < _g17)){
HXDLIN( 339)																			_g16 = (_g16 + 1);
HXDLIN( 339)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 339)																	if (::hx::IsNull( prev )) {
HXDLIN( 339)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 339)																		l = null();
            																	}
            																	else {
HXDLIN( 339)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 339)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 339)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 339)										this3->image = undoImage1;
HXDLIN( 339)										this3->width = width;
HXDLIN( 339)										this3->height = height;
HXDLIN( 339)										this3->imageType = ( (int)(imageType) );
HXDLIN( 339)										undoImage = this3;
HXDLIN( 339)										{
HXDLIN( 339)											int rectLeft = xIter3->start;
HXDLIN( 339)											int rectTop = yIter3->start;
HXDLIN( 339)											int rectRight = xIter3->max;
HXDLIN( 339)											bool forceClear = false;
HXDLIN( 339)											{
HXDLIN( 339)												int _g18 = rectTop;
HXDLIN( 339)												int _g19 = yIter3->max;
HXDLIN( 339)												while((_g18 < _g19)){
HXDLIN( 339)													_g18 = (_g18 + 1);
HXDLIN( 339)													int dy = (_g18 - 1);
HXDLIN( 339)													{
HXDLIN( 339)														int _g20 = rectLeft;
HXDLIN( 339)														int _g21 = rectRight;
HXDLIN( 339)														while((_g20 < _g21)){
HXDLIN( 339)															_g20 = (_g20 + 1);
HXDLIN( 339)															int dx = (_g20 - 1);
HXDLIN( 339)															::Dynamic this5 = this2->image;
HXDLIN( 339)															int index;
HXDLIN( 339)															if (this2->useVirtualPos) {
HXDLIN( 339)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 339)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 339)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 339)															int col;
HXDLIN( 339)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 339)																col = c;
            															}
HXDLIN( 339)															bool _hx_tmp;
HXDLIN( 339)															if (this2->useMask) {
HXDLIN( 339)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 339)																_hx_tmp = false;
            															}
HXDLIN( 339)															if (_hx_tmp) {
HXDLIN( 339)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 339)																::Dynamic this7 = this6->image;
HXDLIN( 339)																int index1;
HXDLIN( 339)																if (this6->useVirtualPos) {
HXDLIN( 339)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 339)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 339)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 339)																int v2;
HXDLIN( 339)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 339)																	v2 = c1;
            																}
HXDLIN( 339)																int maskPixel = v2;
HXDLIN( 339)																int this8 = col;
HXDLIN( 339)																if ((maskPixel == 0)) {
HXDLIN( 339)																	col = this8;
            																}
            																else {
HXDLIN( 339)																	Float m0;
HXDLIN( 339)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 339)																	if ((this9 == 0)) {
HXDLIN( 339)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float m1;
HXDLIN( 339)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 339)																	if ((this10 == 0)) {
HXDLIN( 339)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float m2;
HXDLIN( 339)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 339)																	if ((this11 == 0)) {
HXDLIN( 339)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float m3;
HXDLIN( 339)																	int this12 = (maskPixel & 255);
HXDLIN( 339)																	if ((this12 == 0)) {
HXDLIN( 339)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 339)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 339)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 339)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 339)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 339)															if ((col != 0)) {
HXDLIN( 339)																int x1 = (dx - rectLeft);
HXDLIN( 339)																int y1 = (dy - rectTop);
HXDLIN( 339)																int c2 = col;
HXDLIN( 339)																bool _hx_tmp1;
HXDLIN( 339)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 339)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 339)																	_hx_tmp1 = false;
            																}
HXDLIN( 339)																if (_hx_tmp1) {
HXDLIN( 339)																	int location;
HXDLIN( 339)																	if (undoImage->useVirtualPos) {
HXDLIN( 339)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 339)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 339)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 339)																	int this14;
HXDLIN( 339)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 339)																		this14 = this13;
            																	}
HXDLIN( 339)																	Float a1;
HXDLIN( 339)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 339)																	if ((this15 == 0)) {
HXDLIN( 339)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float r1;
HXDLIN( 339)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 339)																	if ((this16 == 0)) {
HXDLIN( 339)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float g1;
HXDLIN( 339)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 339)																	if ((this17 == 0)) {
HXDLIN( 339)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float b11;
HXDLIN( 339)																	int this18 = (this14 & 255);
HXDLIN( 339)																	if ((this18 == 0)) {
HXDLIN( 339)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float a2;
HXDLIN( 339)																	int this19 = ((col >> 24) & 255);
HXDLIN( 339)																	if ((this19 == 0)) {
HXDLIN( 339)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float r2;
HXDLIN( 339)																	int this20 = ((col >> 16) & 255);
HXDLIN( 339)																	if ((this20 == 0)) {
HXDLIN( 339)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float g2;
HXDLIN( 339)																	int this21 = ((col >> 8) & 255);
HXDLIN( 339)																	if ((this21 == 0)) {
HXDLIN( 339)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float b21;
HXDLIN( 339)																	int this22 = (col & 255);
HXDLIN( 339)																	if ((this22 == 0)) {
HXDLIN( 339)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 339)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 339)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 339)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 339)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 339)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 339)																	{
HXDLIN( 339)																		int _hx_tmp2;
HXDLIN( 339)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 339)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 339)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 339)																	::Dynamic this23 = undoImage->image;
HXDLIN( 339)																	int index2;
HXDLIN( 339)																	if (undoImage->useVirtualPos) {
HXDLIN( 339)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 339)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 339)																	int _hx_tmp3;
HXDLIN( 339)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 339)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 339)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 339)																if (forceClear) {
HXDLIN( 339)																	::Dynamic this24 = undoImage->image;
HXDLIN( 339)																	int x2 = (dx - rectLeft);
HXDLIN( 339)																	int y2 = (dy - rectTop);
HXDLIN( 339)																	int index3;
HXDLIN( 339)																	if (undoImage->useVirtualPos) {
HXDLIN( 339)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 339)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 339)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 339)									bool found = false;
HXDLIN( 339)									Float s = ((Float)0.);
HXDLIN( 339)									Float t = ((Float)0.);
HXDLIN( 339)									Float sxx = ((Float)0.);
HXDLIN( 339)									Float txx = ((Float)0.);
HXDLIN( 339)									{
HXDLIN( 339)										int _g_min = xIter3->start;
HXDLIN( 339)										int _g_max = xIter3->max;
HXDLIN( 339)										while((_g_min < _g_max)){
HXDLIN( 339)											_g_min = (_g_min + 1);
HXDLIN( 339)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 339)											{
HXDLIN( 339)												int _g_min1 = yIter3->start;
HXDLIN( 339)												int _g_max1 = yIter3->max;
HXDLIN( 339)												while((_g_min1 < _g_max1)){
HXDLIN( 339)													_g_min1 = (_g_min1 + 1);
HXDLIN( 339)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 339)													bool _hx_tmp4;
HXDLIN( 339)													if (!((s <= 0))) {
HXDLIN( 339)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 339)														_hx_tmp4 = true;
            													}
HXDLIN( 339)													if (_hx_tmp4) {
HXDLIN( 339)														if (found) {
HXDLIN( 339)															goto _hx_goto_658;
            														}
            													}
            													else {
HXDLIN( 339)														if (((s + t) < A)) {
HXDLIN( 339)															{
HXDLIN( 339)																int c3 = color;
HXDLIN( 339)																bool _hx_tmp5;
HXDLIN( 339)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 339)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 339)																	_hx_tmp5 = false;
            																}
HXDLIN( 339)																if (_hx_tmp5) {
HXDLIN( 339)																	int location1;
HXDLIN( 339)																	if (this2->useVirtualPos) {
HXDLIN( 339)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 339)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 339)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 339)																	int this26;
HXDLIN( 339)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 339)																		this26 = this25;
            																	}
HXDLIN( 339)																	Float a11;
HXDLIN( 339)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 339)																	if ((this27 == 0)) {
HXDLIN( 339)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float r11;
HXDLIN( 339)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 339)																	if ((this28 == 0)) {
HXDLIN( 339)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float g11;
HXDLIN( 339)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 339)																	if ((this29 == 0)) {
HXDLIN( 339)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float b12;
HXDLIN( 339)																	int this30 = (this26 & 255);
HXDLIN( 339)																	if ((this30 == 0)) {
HXDLIN( 339)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float a21;
HXDLIN( 339)																	int this31 = ((color >> 24) & 255);
HXDLIN( 339)																	if ((this31 == 0)) {
HXDLIN( 339)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float r21;
HXDLIN( 339)																	int this32 = ((color >> 16) & 255);
HXDLIN( 339)																	if ((this32 == 0)) {
HXDLIN( 339)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float g21;
HXDLIN( 339)																	int this33 = ((color >> 8) & 255);
HXDLIN( 339)																	if ((this33 == 0)) {
HXDLIN( 339)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float b22;
HXDLIN( 339)																	int this34 = (color & 255);
HXDLIN( 339)																	if ((this34 == 0)) {
HXDLIN( 339)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 339)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 339)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 339)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 339)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 339)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 339)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 339)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 339)																	{
HXDLIN( 339)																		int _hx_tmp6;
HXDLIN( 339)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 339)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 339)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 339)																	::Dynamic this35 = this2->image;
HXDLIN( 339)																	int index4;
HXDLIN( 339)																	if (this2->useVirtualPos) {
HXDLIN( 339)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 339)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 339)																	int _hx_tmp7;
HXDLIN( 339)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 339)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 339)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 339)															if (found) {
HXDLIN( 339)																goto _hx_goto_658;
            															}
            														}
            													}
            												}
            												_hx_goto_658:;
            											}
            										}
            									}
HXDLIN( 339)									if ((hasHit == true)) {
HXDLIN( 339)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 339)										if (hasUndo) {
HXDLIN( 339)											v3->undoImage = undoImage;
HXDLIN( 339)											v3->undoX = xIter3->start;
HXDLIN( 339)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 339)				int _g22 = 0;
HXDLIN( 339)				int _g23 = (sides1 + 1);
HXDLIN( 339)				while((_g22 < _g23)){
HXDLIN( 339)					_g22 = (_g22 + 1);
HXDLIN( 339)					int i7 = (_g22 - 1);
HXDLIN( 339)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 339)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 339)					{
HXDLIN( 339)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 339)						bool hasHit1 = false;
HXDLIN( 339)						bool hasUndo1 = false;
HXDLIN( 339)						{
HXDLIN( 339)							Float bx1 = lastX;
HXDLIN( 339)							Float by1 = lastY;
HXDLIN( 339)							Float cx2 = nextX1;
HXDLIN( 339)							Float cy2 = nextY1;
HXDLIN( 339)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 339)							if (!(adjustWinding1)) {
HXDLIN( 339)								Float bx_1 = bx1;
HXDLIN( 339)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 339)							{
HXDLIN( 339)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 339)								Float sx1 = (cy2 - cy);
HXDLIN( 339)								Float sy1 = (cx - cx2);
HXDLIN( 339)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 339)								Float tx1 = (cy - by1);
HXDLIN( 339)								Float ty1 = (bx1 - cx);
HXDLIN( 339)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 339)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 339)								if ((cx > bx1)) {
HXDLIN( 339)									if ((cx > cx2)) {
HXDLIN( 339)										int min4;
HXDLIN( 339)										if ((bx1 > cx2)) {
HXDLIN( 339)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 339)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 339)										int ii_min8 = min4;
HXDLIN( 339)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 339)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 339)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 339)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 339)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 339)									if ((bx1 > cx2)) {
HXDLIN( 339)										int min5;
HXDLIN( 339)										if ((cx > cx2)) {
HXDLIN( 339)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 339)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 339)										int ii_min10 = min5;
HXDLIN( 339)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 339)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 339)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 339)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 339)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 339)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 339)								if ((cy > by1)) {
HXDLIN( 339)									if ((cy > cy2)) {
HXDLIN( 339)										int min6;
HXDLIN( 339)										if ((by1 > cy2)) {
HXDLIN( 339)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 339)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 339)										int ii_min12 = min6;
HXDLIN( 339)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 339)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 339)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 339)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 339)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 339)									if ((by1 > cy2)) {
HXDLIN( 339)										int min7;
HXDLIN( 339)										if ((cy > cy2)) {
HXDLIN( 339)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 339)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 339)										int ii_min14 = min7;
HXDLIN( 339)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 339)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 339)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 339)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 339)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 339)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 339)								if (hasUndo1) {
HXDLIN( 339)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 339)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 339)									 ::Dynamic imageType1 = null();
HXDLIN( 339)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 339)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 339)									::Dynamic undoImage4;
HXDLIN( 339)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 339)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 339)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 339)											{
HXDLIN( 339)												b5->width = width1;
HXDLIN( 339)												b5->height = height1;
HXDLIN( 339)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 339)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 339)												{
HXDLIN( 339)													int len2 = b5->length;
HXDLIN( 339)													int w1 = 0;
HXDLIN( 339)													{
HXDLIN( 339)														int _g24 = 0;
HXDLIN( 339)														int _g25 = b5->height;
HXDLIN( 339)														while((_g24 < _g25)){
HXDLIN( 339)															_g24 = (_g24 + 1);
HXDLIN( 339)															int y4 = (_g24 - 1);
HXDLIN( 339)															{
HXDLIN( 339)																int _g26 = 0;
HXDLIN( 339)																int _g27 = b5->width;
HXDLIN( 339)																while((_g26 < _g27)){
HXDLIN( 339)																	_g26 = (_g26 + 1);
HXDLIN( 339)																	int x4 = (_g26 - 1);
HXDLIN( 339)																	{
HXDLIN( 339)																		w1 = (w1 + 1);
HXDLIN( 339)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 339)																	{
HXDLIN( 339)																		w1 = (w1 + 1);
HXDLIN( 339)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 339)																	{
HXDLIN( 339)																		w1 = (w1 + 1);
HXDLIN( 339)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 339)																	{
HXDLIN( 339)																		w1 = (w1 + 1);
HXDLIN( 339)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 339)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 339)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 339)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 339)											{
HXDLIN( 339)												a6->width = width1;
HXDLIN( 339)												a6->height = height1;
HXDLIN( 339)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 339)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 339)												{
HXDLIN( 339)													int _g28 = 0;
HXDLIN( 339)													int _g29 = a6->length;
HXDLIN( 339)													while((_g28 < _g29)){
HXDLIN( 339)														_g28 = (_g28 + 1);
HXDLIN( 339)														int i8 = (_g28 - 1);
HXDLIN( 339)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 339)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 339)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 339)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 339)											{
HXDLIN( 339)												b6->width = width1;
HXDLIN( 339)												b6->height = height1;
HXDLIN( 339)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 339)												int size1 = (b6->length * 4);
HXDLIN( 339)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 339)												{
HXDLIN( 339)													int _g30 = 0;
HXDLIN( 339)													int _g31 = b6->length;
HXDLIN( 339)													while((_g30 < _g31)){
HXDLIN( 339)														_g30 = (_g30 + 1);
HXDLIN( 339)														int i9 = (_g30 - 1);
HXDLIN( 339)														{
HXDLIN( 339)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 339)															bool undoImage5;
HXDLIN( 339)															if ((i9 >= 0)) {
HXDLIN( 339)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 339)																undoImage5 = false;
            															}
HXDLIN( 339)															if (undoImage5) {
HXDLIN( 339)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 339)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 339)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 339)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 339)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 339)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 339)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 339)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 339)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 339)											{
HXDLIN( 339)												v4->width = width1;
HXDLIN( 339)												v4->height = height1;
HXDLIN( 339)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 339)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 339)												{
HXDLIN( 339)													int _g32 = 0;
HXDLIN( 339)													int _g33 = v4->length;
HXDLIN( 339)													while((_g32 < _g33)){
HXDLIN( 339)														_g32 = (_g32 + 1);
HXDLIN( 339)														int i10 = (_g32 - 1);
HXDLIN( 339)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 339)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 339)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 339)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 339)											{
HXDLIN( 339)												b7->width = width1;
HXDLIN( 339)												b7->height = height1;
HXDLIN( 339)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 339)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 339)												{
HXDLIN( 339)													int len3 = b7->length;
HXDLIN( 339)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 339)													if (::hx::IsNull( d1->head )) {
HXDLIN( 339)														int _g34 = 0;
HXDLIN( 339)														int _g35 = len3;
HXDLIN( 339)														while((_g34 < _g35)){
HXDLIN( 339)															_g34 = (_g34 + 1);
HXDLIN( 339)															int i11 = (_g34 - 1);
HXDLIN( 339)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 339)														int _g36 = 0;
HXDLIN( 339)														int _g37 = len3;
HXDLIN( 339)														while((_g36 < _g37)){
HXDLIN( 339)															_g36 = (_g36 + 1);
HXDLIN( 339)															int i12 = (_g36 - 1);
HXDLIN( 339)															{
HXDLIN( 339)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 339)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 339)																{
HXDLIN( 339)																	int _g38 = 0;
HXDLIN( 339)																	int _g39 = i12;
HXDLIN( 339)																	while((_g38 < _g39)){
HXDLIN( 339)																		_g38 = (_g38 + 1);
HXDLIN( 339)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 339)																if (::hx::IsNull( prev1 )) {
HXDLIN( 339)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 339)																	l1 = null();
            																}
            																else {
HXDLIN( 339)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 339)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 339)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 339)									this37->image = undoImage4;
HXDLIN( 339)									this37->width = width1;
HXDLIN( 339)									this37->height = height1;
HXDLIN( 339)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 339)									undoImage3 = this37;
HXDLIN( 339)									{
HXDLIN( 339)										int rectLeft1 = xIter31->start;
HXDLIN( 339)										int rectTop1 = yIter31->start;
HXDLIN( 339)										int rectRight1 = xIter31->max;
HXDLIN( 339)										bool forceClear1 = false;
HXDLIN( 339)										{
HXDLIN( 339)											int _g40 = rectTop1;
HXDLIN( 339)											int _g41 = yIter31->max;
HXDLIN( 339)											while((_g40 < _g41)){
HXDLIN( 339)												_g40 = (_g40 + 1);
HXDLIN( 339)												int dy1 = (_g40 - 1);
HXDLIN( 339)												{
HXDLIN( 339)													int _g42 = rectLeft1;
HXDLIN( 339)													int _g43 = rectRight1;
HXDLIN( 339)													while((_g42 < _g43)){
HXDLIN( 339)														_g42 = (_g42 + 1);
HXDLIN( 339)														int dx1 = (_g42 - 1);
HXDLIN( 339)														::Dynamic this39 = this36->image;
HXDLIN( 339)														int index5;
HXDLIN( 339)														if (this36->useVirtualPos) {
HXDLIN( 339)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 339)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 339)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 339)														int col1;
HXDLIN( 339)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 339)															col1 = c4;
            														}
HXDLIN( 339)														bool _hx_tmp8;
HXDLIN( 339)														if (this36->useMask) {
HXDLIN( 339)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 339)															_hx_tmp8 = false;
            														}
HXDLIN( 339)														if (_hx_tmp8) {
HXDLIN( 339)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 339)															::Dynamic this41 = this40->image;
HXDLIN( 339)															int index6;
HXDLIN( 339)															if (this40->useVirtualPos) {
HXDLIN( 339)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 339)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 339)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 339)															int v5;
HXDLIN( 339)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 339)																v5 = c5;
            															}
HXDLIN( 339)															int maskPixel1 = v5;
HXDLIN( 339)															int this42 = col1;
HXDLIN( 339)															if ((maskPixel1 == 0)) {
HXDLIN( 339)																col1 = this42;
            															}
            															else {
HXDLIN( 339)																Float m01;
HXDLIN( 339)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 339)																if ((this43 == 0)) {
HXDLIN( 339)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float m11;
HXDLIN( 339)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 339)																if ((this44 == 0)) {
HXDLIN( 339)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float m21;
HXDLIN( 339)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 339)																if ((this45 == 0)) {
HXDLIN( 339)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float m31;
HXDLIN( 339)																int this46 = (maskPixel1 & 255);
HXDLIN( 339)																if ((this46 == 0)) {
HXDLIN( 339)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 339)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 339)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 339)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 339)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 339)														if ((col1 != 0)) {
HXDLIN( 339)															int x5 = (dx1 - rectLeft1);
HXDLIN( 339)															int y5 = (dy1 - rectTop1);
HXDLIN( 339)															int c6 = col1;
HXDLIN( 339)															bool _hx_tmp9;
HXDLIN( 339)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 339)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 339)																_hx_tmp9 = false;
            															}
HXDLIN( 339)															if (_hx_tmp9) {
HXDLIN( 339)																int location2;
HXDLIN( 339)																if (undoImage3->useVirtualPos) {
HXDLIN( 339)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 339)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 339)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 339)																int this48;
HXDLIN( 339)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 339)																	this48 = this47;
            																}
HXDLIN( 339)																Float a12;
HXDLIN( 339)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 339)																if ((this49 == 0)) {
HXDLIN( 339)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float r12;
HXDLIN( 339)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 339)																if ((this50 == 0)) {
HXDLIN( 339)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float g12;
HXDLIN( 339)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 339)																if ((this51 == 0)) {
HXDLIN( 339)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float b13;
HXDLIN( 339)																int this52 = (this48 & 255);
HXDLIN( 339)																if ((this52 == 0)) {
HXDLIN( 339)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float a22;
HXDLIN( 339)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 339)																if ((this53 == 0)) {
HXDLIN( 339)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float r22;
HXDLIN( 339)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 339)																if ((this54 == 0)) {
HXDLIN( 339)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float g22;
HXDLIN( 339)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 339)																if ((this55 == 0)) {
HXDLIN( 339)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float b23;
HXDLIN( 339)																int this56 = (col1 & 255);
HXDLIN( 339)																if ((this56 == 0)) {
HXDLIN( 339)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 339)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 339)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 339)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 339)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 339)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 339)																{
HXDLIN( 339)																	int _hx_tmp10;
HXDLIN( 339)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 339)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 339)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 339)																::Dynamic this57 = undoImage3->image;
HXDLIN( 339)																int index7;
HXDLIN( 339)																if (undoImage3->useVirtualPos) {
HXDLIN( 339)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 339)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 339)																int _hx_tmp11;
HXDLIN( 339)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 339)																	_hx_tmp11 = c6;
            																}
HXDLIN( 339)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 339)															if (forceClear1) {
HXDLIN( 339)																::Dynamic this58 = undoImage3->image;
HXDLIN( 339)																int x6 = (dx1 - rectLeft1);
HXDLIN( 339)																int y6 = (dy1 - rectTop1);
HXDLIN( 339)																int index8;
HXDLIN( 339)																if (undoImage3->useVirtualPos) {
HXDLIN( 339)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 339)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 339)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 339)								bool found1 = false;
HXDLIN( 339)								Float s1 = ((Float)0.);
HXDLIN( 339)								Float t1 = ((Float)0.);
HXDLIN( 339)								Float sxx1 = ((Float)0.);
HXDLIN( 339)								Float txx1 = ((Float)0.);
HXDLIN( 339)								{
HXDLIN( 339)									int _g_min2 = xIter31->start;
HXDLIN( 339)									int _g_max2 = xIter31->max;
HXDLIN( 339)									while((_g_min2 < _g_max2)){
HXDLIN( 339)										_g_min2 = (_g_min2 + 1);
HXDLIN( 339)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 339)										{
HXDLIN( 339)											int _g_min3 = yIter31->start;
HXDLIN( 339)											int _g_max3 = yIter31->max;
HXDLIN( 339)											while((_g_min3 < _g_max3)){
HXDLIN( 339)												_g_min3 = (_g_min3 + 1);
HXDLIN( 339)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 339)												bool _hx_tmp12;
HXDLIN( 339)												if (!((s1 <= 0))) {
HXDLIN( 339)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 339)													_hx_tmp12 = true;
            												}
HXDLIN( 339)												if (_hx_tmp12) {
HXDLIN( 339)													if (found1) {
HXDLIN( 339)														goto _hx_goto_671;
            													}
            												}
            												else {
HXDLIN( 339)													if (((s1 + t1) < A1)) {
HXDLIN( 339)														{
HXDLIN( 339)															int c7 = color;
HXDLIN( 339)															bool _hx_tmp13;
HXDLIN( 339)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 339)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 339)																_hx_tmp13 = false;
            															}
HXDLIN( 339)															if (_hx_tmp13) {
HXDLIN( 339)																int location3;
HXDLIN( 339)																if (this36->useVirtualPos) {
HXDLIN( 339)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 339)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 339)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 339)																int this60;
HXDLIN( 339)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 339)																	this60 = this59;
            																}
HXDLIN( 339)																Float a13;
HXDLIN( 339)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 339)																if ((this61 == 0)) {
HXDLIN( 339)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float r13;
HXDLIN( 339)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 339)																if ((this62 == 0)) {
HXDLIN( 339)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float g13;
HXDLIN( 339)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 339)																if ((this63 == 0)) {
HXDLIN( 339)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float b14;
HXDLIN( 339)																int this64 = (this60 & 255);
HXDLIN( 339)																if ((this64 == 0)) {
HXDLIN( 339)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float a23;
HXDLIN( 339)																int this65 = ((color >> 24) & 255);
HXDLIN( 339)																if ((this65 == 0)) {
HXDLIN( 339)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float r23;
HXDLIN( 339)																int this66 = ((color >> 16) & 255);
HXDLIN( 339)																if ((this66 == 0)) {
HXDLIN( 339)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float g23;
HXDLIN( 339)																int this67 = ((color >> 8) & 255);
HXDLIN( 339)																if ((this67 == 0)) {
HXDLIN( 339)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float b24;
HXDLIN( 339)																int this68 = (color & 255);
HXDLIN( 339)																if ((this68 == 0)) {
HXDLIN( 339)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 339)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 339)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 339)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 339)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 339)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 339)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 339)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 339)																{
HXDLIN( 339)																	int _hx_tmp14;
HXDLIN( 339)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 339)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 339)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 339)																::Dynamic this69 = this36->image;
HXDLIN( 339)																int index9;
HXDLIN( 339)																if (this36->useVirtualPos) {
HXDLIN( 339)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 339)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 339)																int _hx_tmp15;
HXDLIN( 339)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 339)																	_hx_tmp15 = c7;
            																}
HXDLIN( 339)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 339)														if (found1) {
HXDLIN( 339)															goto _hx_goto_671;
            														}
            													}
            												}
            											}
            											_hx_goto_671:;
            										}
            									}
            								}
HXDLIN( 339)								if ((hasHit1 == true)) {
HXDLIN( 339)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 339)									if (hasUndo1) {
HXDLIN( 339)										v6->undoImage = undoImage3;
HXDLIN( 339)										v6->undoX = xIter31->start;
HXDLIN( 339)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,hendecagon,(void))

void FillShape_Impl__obj::undecagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_352_undecagon)
HXDLIN( 352)		 ::Dynamic phi1 = phi;
HXDLIN( 352)		 ::Dynamic sides = 11;
HXLINE( 356)		if (::hx::IsNull( sides )) {
HXLINE( 356)			sides = 36;
            		}
HXLINE( 355)		if (::hx::IsNull( phi1 )) {
HXLINE( 355)			phi1 = ((Float)0.);
            		}
HXLINE( 352)		{
HXDLIN( 352)			 ::Dynamic phi2 = phi1;
HXDLIN( 352)			 ::Dynamic sides1 = sides;
HXDLIN( 352)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 352)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 352)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 352)			Float omega;
HXDLIN( 352)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 352)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 352)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 352)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 352)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 352)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 352)			Float lastX = ((Float)0.);
HXDLIN( 352)			Float lastY = ((Float)0.);
HXDLIN( 352)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 352)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 352)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 352)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 352)				{
HXDLIN( 352)					int _g = 0;
HXDLIN( 352)					int _g1 = (sides1 + 1);
HXDLIN( 352)					while((_g < _g1)){
HXDLIN( 352)						_g = (_g + 1);
HXDLIN( 352)						int i = (_g - 1);
HXDLIN( 352)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 352)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 352)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 352)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 352)						{
HXDLIN( 352)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 352)							bool hasHit = false;
HXDLIN( 352)							bool hasUndo = false;
HXDLIN( 352)							{
HXDLIN( 352)								Float bx = lastX;
HXDLIN( 352)								Float by = lastY;
HXDLIN( 352)								Float cx1 = nextX;
HXDLIN( 352)								Float cy1 = nextY;
HXDLIN( 352)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 352)								if (!(adjustWinding)) {
HXDLIN( 352)									Float bx_ = bx;
HXDLIN( 352)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 352)								{
HXDLIN( 352)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 352)									Float sx = (cy1 - cy);
HXDLIN( 352)									Float sy = (cx - cx1);
HXDLIN( 352)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 352)									Float tx = (cy - by);
HXDLIN( 352)									Float ty = (bx - cx);
HXDLIN( 352)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 352)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 352)									if ((cx > bx)) {
HXDLIN( 352)										if ((cx > cx1)) {
HXDLIN( 352)											int min;
HXDLIN( 352)											if ((bx > cx1)) {
HXDLIN( 352)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 352)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 352)											int ii_min = min;
HXDLIN( 352)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 352)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 352)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 352)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 352)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 352)										if ((bx > cx1)) {
HXDLIN( 352)											int min1;
HXDLIN( 352)											if ((cx > cx1)) {
HXDLIN( 352)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 352)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 352)											int ii_min2 = min1;
HXDLIN( 352)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 352)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 352)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 352)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 352)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 352)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 352)									if ((cy > by)) {
HXDLIN( 352)										if ((cy > cy1)) {
HXDLIN( 352)											int min2;
HXDLIN( 352)											if ((by > cy1)) {
HXDLIN( 352)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 352)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 352)											int ii_min4 = min2;
HXDLIN( 352)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 352)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 352)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 352)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 352)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 352)										if ((by > cy1)) {
HXDLIN( 352)											int min3;
HXDLIN( 352)											if ((cy > cy1)) {
HXDLIN( 352)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 352)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 352)											int ii_min6 = min3;
HXDLIN( 352)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 352)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 352)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 352)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 352)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 352)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 352)									if (hasUndo) {
HXDLIN( 352)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 352)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 352)										 ::Dynamic imageType = null();
HXDLIN( 352)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 352)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 352)										::Dynamic undoImage1;
HXDLIN( 352)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 352)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 352)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 352)												{
HXDLIN( 352)													b->width = width;
HXDLIN( 352)													b->height = height;
HXDLIN( 352)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 352)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 352)													{
HXDLIN( 352)														int len = b->length;
HXDLIN( 352)														int w = 0;
HXDLIN( 352)														{
HXDLIN( 352)															int _g2 = 0;
HXDLIN( 352)															int _g3 = b->height;
HXDLIN( 352)															while((_g2 < _g3)){
HXDLIN( 352)																_g2 = (_g2 + 1);
HXDLIN( 352)																int y = (_g2 - 1);
HXDLIN( 352)																{
HXDLIN( 352)																	int _g4 = 0;
HXDLIN( 352)																	int _g5 = b->width;
HXDLIN( 352)																	while((_g4 < _g5)){
HXDLIN( 352)																		_g4 = (_g4 + 1);
HXDLIN( 352)																		int x = (_g4 - 1);
HXDLIN( 352)																		{
HXDLIN( 352)																			w = (w + 1);
HXDLIN( 352)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 352)																		{
HXDLIN( 352)																			w = (w + 1);
HXDLIN( 352)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 352)																		{
HXDLIN( 352)																			w = (w + 1);
HXDLIN( 352)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 352)																		{
HXDLIN( 352)																			w = (w + 1);
HXDLIN( 352)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 352)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 352)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 352)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 352)												{
HXDLIN( 352)													a->width = width;
HXDLIN( 352)													a->height = height;
HXDLIN( 352)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 352)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 352)													{
HXDLIN( 352)														int _g6 = 0;
HXDLIN( 352)														int _g7 = a->length;
HXDLIN( 352)														while((_g6 < _g7)){
HXDLIN( 352)															_g6 = (_g6 + 1);
HXDLIN( 352)															int i1 = (_g6 - 1);
HXDLIN( 352)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 352)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 352)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 352)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 352)												{
HXDLIN( 352)													b1->width = width;
HXDLIN( 352)													b1->height = height;
HXDLIN( 352)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 352)													int size = (b1->length * 4);
HXDLIN( 352)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 352)													{
HXDLIN( 352)														int _g8 = 0;
HXDLIN( 352)														int _g9 = b1->length;
HXDLIN( 352)														while((_g8 < _g9)){
HXDLIN( 352)															_g8 = (_g8 + 1);
HXDLIN( 352)															int i2 = (_g8 - 1);
HXDLIN( 352)															{
HXDLIN( 352)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 352)																bool undoImage2;
HXDLIN( 352)																if ((i2 >= 0)) {
HXDLIN( 352)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 352)																	undoImage2 = false;
            																}
HXDLIN( 352)																if (undoImage2) {
HXDLIN( 352)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 352)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 352)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 352)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 352)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 352)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 352)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 352)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 352)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 352)												{
HXDLIN( 352)													v1->width = width;
HXDLIN( 352)													v1->height = height;
HXDLIN( 352)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 352)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 352)													{
HXDLIN( 352)														int _g10 = 0;
HXDLIN( 352)														int _g11 = v1->length;
HXDLIN( 352)														while((_g10 < _g11)){
HXDLIN( 352)															_g10 = (_g10 + 1);
HXDLIN( 352)															int i3 = (_g10 - 1);
HXDLIN( 352)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 352)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 352)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 352)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 352)												{
HXDLIN( 352)													b2->width = width;
HXDLIN( 352)													b2->height = height;
HXDLIN( 352)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 352)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 352)													{
HXDLIN( 352)														int len1 = b2->length;
HXDLIN( 352)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 352)														if (::hx::IsNull( d->head )) {
HXDLIN( 352)															int _g12 = 0;
HXDLIN( 352)															int _g13 = len1;
HXDLIN( 352)															while((_g12 < _g13)){
HXDLIN( 352)																_g12 = (_g12 + 1);
HXDLIN( 352)																int i4 = (_g12 - 1);
HXDLIN( 352)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 352)															int _g14 = 0;
HXDLIN( 352)															int _g15 = len1;
HXDLIN( 352)															while((_g14 < _g15)){
HXDLIN( 352)																_g14 = (_g14 + 1);
HXDLIN( 352)																int i5 = (_g14 - 1);
HXDLIN( 352)																{
HXDLIN( 352)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 352)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 352)																	{
HXDLIN( 352)																		int _g16 = 0;
HXDLIN( 352)																		int _g17 = i5;
HXDLIN( 352)																		while((_g16 < _g17)){
HXDLIN( 352)																			_g16 = (_g16 + 1);
HXDLIN( 352)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 352)																	if (::hx::IsNull( prev )) {
HXDLIN( 352)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 352)																		l = null();
            																	}
            																	else {
HXDLIN( 352)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 352)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 352)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 352)										this3->image = undoImage1;
HXDLIN( 352)										this3->width = width;
HXDLIN( 352)										this3->height = height;
HXDLIN( 352)										this3->imageType = ( (int)(imageType) );
HXDLIN( 352)										undoImage = this3;
HXDLIN( 352)										{
HXDLIN( 352)											int rectLeft = xIter3->start;
HXDLIN( 352)											int rectTop = yIter3->start;
HXDLIN( 352)											int rectRight = xIter3->max;
HXDLIN( 352)											bool forceClear = false;
HXDLIN( 352)											{
HXDLIN( 352)												int _g18 = rectTop;
HXDLIN( 352)												int _g19 = yIter3->max;
HXDLIN( 352)												while((_g18 < _g19)){
HXDLIN( 352)													_g18 = (_g18 + 1);
HXDLIN( 352)													int dy = (_g18 - 1);
HXDLIN( 352)													{
HXDLIN( 352)														int _g20 = rectLeft;
HXDLIN( 352)														int _g21 = rectRight;
HXDLIN( 352)														while((_g20 < _g21)){
HXDLIN( 352)															_g20 = (_g20 + 1);
HXDLIN( 352)															int dx = (_g20 - 1);
HXDLIN( 352)															::Dynamic this5 = this2->image;
HXDLIN( 352)															int index;
HXDLIN( 352)															if (this2->useVirtualPos) {
HXDLIN( 352)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 352)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 352)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 352)															int col;
HXDLIN( 352)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 352)																col = c;
            															}
HXDLIN( 352)															bool _hx_tmp;
HXDLIN( 352)															if (this2->useMask) {
HXDLIN( 352)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 352)																_hx_tmp = false;
            															}
HXDLIN( 352)															if (_hx_tmp) {
HXDLIN( 352)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 352)																::Dynamic this7 = this6->image;
HXDLIN( 352)																int index1;
HXDLIN( 352)																if (this6->useVirtualPos) {
HXDLIN( 352)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 352)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 352)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 352)																int v2;
HXDLIN( 352)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 352)																	v2 = c1;
            																}
HXDLIN( 352)																int maskPixel = v2;
HXDLIN( 352)																int this8 = col;
HXDLIN( 352)																if ((maskPixel == 0)) {
HXDLIN( 352)																	col = this8;
            																}
            																else {
HXDLIN( 352)																	Float m0;
HXDLIN( 352)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 352)																	if ((this9 == 0)) {
HXDLIN( 352)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float m1;
HXDLIN( 352)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 352)																	if ((this10 == 0)) {
HXDLIN( 352)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float m2;
HXDLIN( 352)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 352)																	if ((this11 == 0)) {
HXDLIN( 352)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float m3;
HXDLIN( 352)																	int this12 = (maskPixel & 255);
HXDLIN( 352)																	if ((this12 == 0)) {
HXDLIN( 352)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 352)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 352)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 352)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 352)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 352)															if ((col != 0)) {
HXDLIN( 352)																int x1 = (dx - rectLeft);
HXDLIN( 352)																int y1 = (dy - rectTop);
HXDLIN( 352)																int c2 = col;
HXDLIN( 352)																bool _hx_tmp1;
HXDLIN( 352)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 352)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 352)																	_hx_tmp1 = false;
            																}
HXDLIN( 352)																if (_hx_tmp1) {
HXDLIN( 352)																	int location;
HXDLIN( 352)																	if (undoImage->useVirtualPos) {
HXDLIN( 352)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 352)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 352)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 352)																	int this14;
HXDLIN( 352)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 352)																		this14 = this13;
            																	}
HXDLIN( 352)																	Float a1;
HXDLIN( 352)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 352)																	if ((this15 == 0)) {
HXDLIN( 352)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float r1;
HXDLIN( 352)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 352)																	if ((this16 == 0)) {
HXDLIN( 352)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float g1;
HXDLIN( 352)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 352)																	if ((this17 == 0)) {
HXDLIN( 352)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float b11;
HXDLIN( 352)																	int this18 = (this14 & 255);
HXDLIN( 352)																	if ((this18 == 0)) {
HXDLIN( 352)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float a2;
HXDLIN( 352)																	int this19 = ((col >> 24) & 255);
HXDLIN( 352)																	if ((this19 == 0)) {
HXDLIN( 352)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float r2;
HXDLIN( 352)																	int this20 = ((col >> 16) & 255);
HXDLIN( 352)																	if ((this20 == 0)) {
HXDLIN( 352)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float g2;
HXDLIN( 352)																	int this21 = ((col >> 8) & 255);
HXDLIN( 352)																	if ((this21 == 0)) {
HXDLIN( 352)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float b21;
HXDLIN( 352)																	int this22 = (col & 255);
HXDLIN( 352)																	if ((this22 == 0)) {
HXDLIN( 352)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 352)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 352)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 352)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 352)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 352)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 352)																	{
HXDLIN( 352)																		int _hx_tmp2;
HXDLIN( 352)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 352)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 352)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 352)																	::Dynamic this23 = undoImage->image;
HXDLIN( 352)																	int index2;
HXDLIN( 352)																	if (undoImage->useVirtualPos) {
HXDLIN( 352)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 352)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 352)																	int _hx_tmp3;
HXDLIN( 352)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 352)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 352)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 352)																if (forceClear) {
HXDLIN( 352)																	::Dynamic this24 = undoImage->image;
HXDLIN( 352)																	int x2 = (dx - rectLeft);
HXDLIN( 352)																	int y2 = (dy - rectTop);
HXDLIN( 352)																	int index3;
HXDLIN( 352)																	if (undoImage->useVirtualPos) {
HXDLIN( 352)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 352)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 352)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 352)									bool found = false;
HXDLIN( 352)									Float s = ((Float)0.);
HXDLIN( 352)									Float t = ((Float)0.);
HXDLIN( 352)									Float sxx = ((Float)0.);
HXDLIN( 352)									Float txx = ((Float)0.);
HXDLIN( 352)									{
HXDLIN( 352)										int _g_min = xIter3->start;
HXDLIN( 352)										int _g_max = xIter3->max;
HXDLIN( 352)										while((_g_min < _g_max)){
HXDLIN( 352)											_g_min = (_g_min + 1);
HXDLIN( 352)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 352)											{
HXDLIN( 352)												int _g_min1 = yIter3->start;
HXDLIN( 352)												int _g_max1 = yIter3->max;
HXDLIN( 352)												while((_g_min1 < _g_max1)){
HXDLIN( 352)													_g_min1 = (_g_min1 + 1);
HXDLIN( 352)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 352)													bool _hx_tmp4;
HXDLIN( 352)													if (!((s <= 0))) {
HXDLIN( 352)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 352)														_hx_tmp4 = true;
            													}
HXDLIN( 352)													if (_hx_tmp4) {
HXDLIN( 352)														if (found) {
HXDLIN( 352)															goto _hx_goto_685;
            														}
            													}
            													else {
HXDLIN( 352)														if (((s + t) < A)) {
HXDLIN( 352)															{
HXDLIN( 352)																int c3 = color;
HXDLIN( 352)																bool _hx_tmp5;
HXDLIN( 352)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 352)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 352)																	_hx_tmp5 = false;
            																}
HXDLIN( 352)																if (_hx_tmp5) {
HXDLIN( 352)																	int location1;
HXDLIN( 352)																	if (this2->useVirtualPos) {
HXDLIN( 352)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 352)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 352)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 352)																	int this26;
HXDLIN( 352)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 352)																		this26 = this25;
            																	}
HXDLIN( 352)																	Float a11;
HXDLIN( 352)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 352)																	if ((this27 == 0)) {
HXDLIN( 352)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float r11;
HXDLIN( 352)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 352)																	if ((this28 == 0)) {
HXDLIN( 352)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float g11;
HXDLIN( 352)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 352)																	if ((this29 == 0)) {
HXDLIN( 352)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float b12;
HXDLIN( 352)																	int this30 = (this26 & 255);
HXDLIN( 352)																	if ((this30 == 0)) {
HXDLIN( 352)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float a21;
HXDLIN( 352)																	int this31 = ((color >> 24) & 255);
HXDLIN( 352)																	if ((this31 == 0)) {
HXDLIN( 352)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float r21;
HXDLIN( 352)																	int this32 = ((color >> 16) & 255);
HXDLIN( 352)																	if ((this32 == 0)) {
HXDLIN( 352)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float g21;
HXDLIN( 352)																	int this33 = ((color >> 8) & 255);
HXDLIN( 352)																	if ((this33 == 0)) {
HXDLIN( 352)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float b22;
HXDLIN( 352)																	int this34 = (color & 255);
HXDLIN( 352)																	if ((this34 == 0)) {
HXDLIN( 352)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 352)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 352)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 352)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 352)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 352)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 352)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 352)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 352)																	{
HXDLIN( 352)																		int _hx_tmp6;
HXDLIN( 352)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 352)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 352)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 352)																	::Dynamic this35 = this2->image;
HXDLIN( 352)																	int index4;
HXDLIN( 352)																	if (this2->useVirtualPos) {
HXDLIN( 352)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 352)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 352)																	int _hx_tmp7;
HXDLIN( 352)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 352)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 352)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 352)															if (found) {
HXDLIN( 352)																goto _hx_goto_685;
            															}
            														}
            													}
            												}
            												_hx_goto_685:;
            											}
            										}
            									}
HXDLIN( 352)									if ((hasHit == true)) {
HXDLIN( 352)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 352)										if (hasUndo) {
HXDLIN( 352)											v3->undoImage = undoImage;
HXDLIN( 352)											v3->undoX = xIter3->start;
HXDLIN( 352)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 352)				int _g22 = 0;
HXDLIN( 352)				int _g23 = (sides1 + 1);
HXDLIN( 352)				while((_g22 < _g23)){
HXDLIN( 352)					_g22 = (_g22 + 1);
HXDLIN( 352)					int i7 = (_g22 - 1);
HXDLIN( 352)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 352)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 352)					{
HXDLIN( 352)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 352)						bool hasHit1 = false;
HXDLIN( 352)						bool hasUndo1 = false;
HXDLIN( 352)						{
HXDLIN( 352)							Float bx1 = lastX;
HXDLIN( 352)							Float by1 = lastY;
HXDLIN( 352)							Float cx2 = nextX1;
HXDLIN( 352)							Float cy2 = nextY1;
HXDLIN( 352)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 352)							if (!(adjustWinding1)) {
HXDLIN( 352)								Float bx_1 = bx1;
HXDLIN( 352)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 352)							{
HXDLIN( 352)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 352)								Float sx1 = (cy2 - cy);
HXDLIN( 352)								Float sy1 = (cx - cx2);
HXDLIN( 352)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 352)								Float tx1 = (cy - by1);
HXDLIN( 352)								Float ty1 = (bx1 - cx);
HXDLIN( 352)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 352)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 352)								if ((cx > bx1)) {
HXDLIN( 352)									if ((cx > cx2)) {
HXDLIN( 352)										int min4;
HXDLIN( 352)										if ((bx1 > cx2)) {
HXDLIN( 352)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 352)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 352)										int ii_min8 = min4;
HXDLIN( 352)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 352)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 352)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 352)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 352)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 352)									if ((bx1 > cx2)) {
HXDLIN( 352)										int min5;
HXDLIN( 352)										if ((cx > cx2)) {
HXDLIN( 352)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 352)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 352)										int ii_min10 = min5;
HXDLIN( 352)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 352)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 352)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 352)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 352)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 352)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 352)								if ((cy > by1)) {
HXDLIN( 352)									if ((cy > cy2)) {
HXDLIN( 352)										int min6;
HXDLIN( 352)										if ((by1 > cy2)) {
HXDLIN( 352)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 352)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 352)										int ii_min12 = min6;
HXDLIN( 352)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 352)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 352)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 352)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 352)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 352)									if ((by1 > cy2)) {
HXDLIN( 352)										int min7;
HXDLIN( 352)										if ((cy > cy2)) {
HXDLIN( 352)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 352)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 352)										int ii_min14 = min7;
HXDLIN( 352)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 352)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 352)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 352)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 352)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 352)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 352)								if (hasUndo1) {
HXDLIN( 352)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 352)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 352)									 ::Dynamic imageType1 = null();
HXDLIN( 352)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 352)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 352)									::Dynamic undoImage4;
HXDLIN( 352)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 352)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 352)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 352)											{
HXDLIN( 352)												b5->width = width1;
HXDLIN( 352)												b5->height = height1;
HXDLIN( 352)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 352)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 352)												{
HXDLIN( 352)													int len2 = b5->length;
HXDLIN( 352)													int w1 = 0;
HXDLIN( 352)													{
HXDLIN( 352)														int _g24 = 0;
HXDLIN( 352)														int _g25 = b5->height;
HXDLIN( 352)														while((_g24 < _g25)){
HXDLIN( 352)															_g24 = (_g24 + 1);
HXDLIN( 352)															int y4 = (_g24 - 1);
HXDLIN( 352)															{
HXDLIN( 352)																int _g26 = 0;
HXDLIN( 352)																int _g27 = b5->width;
HXDLIN( 352)																while((_g26 < _g27)){
HXDLIN( 352)																	_g26 = (_g26 + 1);
HXDLIN( 352)																	int x4 = (_g26 - 1);
HXDLIN( 352)																	{
HXDLIN( 352)																		w1 = (w1 + 1);
HXDLIN( 352)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 352)																	{
HXDLIN( 352)																		w1 = (w1 + 1);
HXDLIN( 352)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 352)																	{
HXDLIN( 352)																		w1 = (w1 + 1);
HXDLIN( 352)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 352)																	{
HXDLIN( 352)																		w1 = (w1 + 1);
HXDLIN( 352)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 352)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 352)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 352)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 352)											{
HXDLIN( 352)												a6->width = width1;
HXDLIN( 352)												a6->height = height1;
HXDLIN( 352)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 352)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 352)												{
HXDLIN( 352)													int _g28 = 0;
HXDLIN( 352)													int _g29 = a6->length;
HXDLIN( 352)													while((_g28 < _g29)){
HXDLIN( 352)														_g28 = (_g28 + 1);
HXDLIN( 352)														int i8 = (_g28 - 1);
HXDLIN( 352)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 352)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 352)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 352)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 352)											{
HXDLIN( 352)												b6->width = width1;
HXDLIN( 352)												b6->height = height1;
HXDLIN( 352)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 352)												int size1 = (b6->length * 4);
HXDLIN( 352)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 352)												{
HXDLIN( 352)													int _g30 = 0;
HXDLIN( 352)													int _g31 = b6->length;
HXDLIN( 352)													while((_g30 < _g31)){
HXDLIN( 352)														_g30 = (_g30 + 1);
HXDLIN( 352)														int i9 = (_g30 - 1);
HXDLIN( 352)														{
HXDLIN( 352)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 352)															bool undoImage5;
HXDLIN( 352)															if ((i9 >= 0)) {
HXDLIN( 352)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 352)																undoImage5 = false;
            															}
HXDLIN( 352)															if (undoImage5) {
HXDLIN( 352)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 352)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 352)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 352)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 352)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 352)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 352)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 352)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 352)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 352)											{
HXDLIN( 352)												v4->width = width1;
HXDLIN( 352)												v4->height = height1;
HXDLIN( 352)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 352)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 352)												{
HXDLIN( 352)													int _g32 = 0;
HXDLIN( 352)													int _g33 = v4->length;
HXDLIN( 352)													while((_g32 < _g33)){
HXDLIN( 352)														_g32 = (_g32 + 1);
HXDLIN( 352)														int i10 = (_g32 - 1);
HXDLIN( 352)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 352)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 352)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 352)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 352)											{
HXDLIN( 352)												b7->width = width1;
HXDLIN( 352)												b7->height = height1;
HXDLIN( 352)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 352)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 352)												{
HXDLIN( 352)													int len3 = b7->length;
HXDLIN( 352)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 352)													if (::hx::IsNull( d1->head )) {
HXDLIN( 352)														int _g34 = 0;
HXDLIN( 352)														int _g35 = len3;
HXDLIN( 352)														while((_g34 < _g35)){
HXDLIN( 352)															_g34 = (_g34 + 1);
HXDLIN( 352)															int i11 = (_g34 - 1);
HXDLIN( 352)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 352)														int _g36 = 0;
HXDLIN( 352)														int _g37 = len3;
HXDLIN( 352)														while((_g36 < _g37)){
HXDLIN( 352)															_g36 = (_g36 + 1);
HXDLIN( 352)															int i12 = (_g36 - 1);
HXDLIN( 352)															{
HXDLIN( 352)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 352)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 352)																{
HXDLIN( 352)																	int _g38 = 0;
HXDLIN( 352)																	int _g39 = i12;
HXDLIN( 352)																	while((_g38 < _g39)){
HXDLIN( 352)																		_g38 = (_g38 + 1);
HXDLIN( 352)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 352)																if (::hx::IsNull( prev1 )) {
HXDLIN( 352)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 352)																	l1 = null();
            																}
            																else {
HXDLIN( 352)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 352)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 352)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 352)									this37->image = undoImage4;
HXDLIN( 352)									this37->width = width1;
HXDLIN( 352)									this37->height = height1;
HXDLIN( 352)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 352)									undoImage3 = this37;
HXDLIN( 352)									{
HXDLIN( 352)										int rectLeft1 = xIter31->start;
HXDLIN( 352)										int rectTop1 = yIter31->start;
HXDLIN( 352)										int rectRight1 = xIter31->max;
HXDLIN( 352)										bool forceClear1 = false;
HXDLIN( 352)										{
HXDLIN( 352)											int _g40 = rectTop1;
HXDLIN( 352)											int _g41 = yIter31->max;
HXDLIN( 352)											while((_g40 < _g41)){
HXDLIN( 352)												_g40 = (_g40 + 1);
HXDLIN( 352)												int dy1 = (_g40 - 1);
HXDLIN( 352)												{
HXDLIN( 352)													int _g42 = rectLeft1;
HXDLIN( 352)													int _g43 = rectRight1;
HXDLIN( 352)													while((_g42 < _g43)){
HXDLIN( 352)														_g42 = (_g42 + 1);
HXDLIN( 352)														int dx1 = (_g42 - 1);
HXDLIN( 352)														::Dynamic this39 = this36->image;
HXDLIN( 352)														int index5;
HXDLIN( 352)														if (this36->useVirtualPos) {
HXDLIN( 352)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 352)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 352)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 352)														int col1;
HXDLIN( 352)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 352)															col1 = c4;
            														}
HXDLIN( 352)														bool _hx_tmp8;
HXDLIN( 352)														if (this36->useMask) {
HXDLIN( 352)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 352)															_hx_tmp8 = false;
            														}
HXDLIN( 352)														if (_hx_tmp8) {
HXDLIN( 352)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 352)															::Dynamic this41 = this40->image;
HXDLIN( 352)															int index6;
HXDLIN( 352)															if (this40->useVirtualPos) {
HXDLIN( 352)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 352)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 352)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 352)															int v5;
HXDLIN( 352)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 352)																v5 = c5;
            															}
HXDLIN( 352)															int maskPixel1 = v5;
HXDLIN( 352)															int this42 = col1;
HXDLIN( 352)															if ((maskPixel1 == 0)) {
HXDLIN( 352)																col1 = this42;
            															}
            															else {
HXDLIN( 352)																Float m01;
HXDLIN( 352)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 352)																if ((this43 == 0)) {
HXDLIN( 352)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float m11;
HXDLIN( 352)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 352)																if ((this44 == 0)) {
HXDLIN( 352)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float m21;
HXDLIN( 352)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 352)																if ((this45 == 0)) {
HXDLIN( 352)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float m31;
HXDLIN( 352)																int this46 = (maskPixel1 & 255);
HXDLIN( 352)																if ((this46 == 0)) {
HXDLIN( 352)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 352)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 352)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 352)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 352)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 352)														if ((col1 != 0)) {
HXDLIN( 352)															int x5 = (dx1 - rectLeft1);
HXDLIN( 352)															int y5 = (dy1 - rectTop1);
HXDLIN( 352)															int c6 = col1;
HXDLIN( 352)															bool _hx_tmp9;
HXDLIN( 352)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 352)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 352)																_hx_tmp9 = false;
            															}
HXDLIN( 352)															if (_hx_tmp9) {
HXDLIN( 352)																int location2;
HXDLIN( 352)																if (undoImage3->useVirtualPos) {
HXDLIN( 352)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 352)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 352)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 352)																int this48;
HXDLIN( 352)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 352)																	this48 = this47;
            																}
HXDLIN( 352)																Float a12;
HXDLIN( 352)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 352)																if ((this49 == 0)) {
HXDLIN( 352)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float r12;
HXDLIN( 352)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 352)																if ((this50 == 0)) {
HXDLIN( 352)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float g12;
HXDLIN( 352)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 352)																if ((this51 == 0)) {
HXDLIN( 352)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float b13;
HXDLIN( 352)																int this52 = (this48 & 255);
HXDLIN( 352)																if ((this52 == 0)) {
HXDLIN( 352)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float a22;
HXDLIN( 352)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 352)																if ((this53 == 0)) {
HXDLIN( 352)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float r22;
HXDLIN( 352)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 352)																if ((this54 == 0)) {
HXDLIN( 352)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float g22;
HXDLIN( 352)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 352)																if ((this55 == 0)) {
HXDLIN( 352)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float b23;
HXDLIN( 352)																int this56 = (col1 & 255);
HXDLIN( 352)																if ((this56 == 0)) {
HXDLIN( 352)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 352)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 352)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 352)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 352)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 352)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 352)																{
HXDLIN( 352)																	int _hx_tmp10;
HXDLIN( 352)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 352)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 352)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 352)																::Dynamic this57 = undoImage3->image;
HXDLIN( 352)																int index7;
HXDLIN( 352)																if (undoImage3->useVirtualPos) {
HXDLIN( 352)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 352)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 352)																int _hx_tmp11;
HXDLIN( 352)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 352)																	_hx_tmp11 = c6;
            																}
HXDLIN( 352)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 352)															if (forceClear1) {
HXDLIN( 352)																::Dynamic this58 = undoImage3->image;
HXDLIN( 352)																int x6 = (dx1 - rectLeft1);
HXDLIN( 352)																int y6 = (dy1 - rectTop1);
HXDLIN( 352)																int index8;
HXDLIN( 352)																if (undoImage3->useVirtualPos) {
HXDLIN( 352)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 352)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 352)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 352)								bool found1 = false;
HXDLIN( 352)								Float s1 = ((Float)0.);
HXDLIN( 352)								Float t1 = ((Float)0.);
HXDLIN( 352)								Float sxx1 = ((Float)0.);
HXDLIN( 352)								Float txx1 = ((Float)0.);
HXDLIN( 352)								{
HXDLIN( 352)									int _g_min2 = xIter31->start;
HXDLIN( 352)									int _g_max2 = xIter31->max;
HXDLIN( 352)									while((_g_min2 < _g_max2)){
HXDLIN( 352)										_g_min2 = (_g_min2 + 1);
HXDLIN( 352)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 352)										{
HXDLIN( 352)											int _g_min3 = yIter31->start;
HXDLIN( 352)											int _g_max3 = yIter31->max;
HXDLIN( 352)											while((_g_min3 < _g_max3)){
HXDLIN( 352)												_g_min3 = (_g_min3 + 1);
HXDLIN( 352)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 352)												bool _hx_tmp12;
HXDLIN( 352)												if (!((s1 <= 0))) {
HXDLIN( 352)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 352)													_hx_tmp12 = true;
            												}
HXDLIN( 352)												if (_hx_tmp12) {
HXDLIN( 352)													if (found1) {
HXDLIN( 352)														goto _hx_goto_698;
            													}
            												}
            												else {
HXDLIN( 352)													if (((s1 + t1) < A1)) {
HXDLIN( 352)														{
HXDLIN( 352)															int c7 = color;
HXDLIN( 352)															bool _hx_tmp13;
HXDLIN( 352)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 352)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 352)																_hx_tmp13 = false;
            															}
HXDLIN( 352)															if (_hx_tmp13) {
HXDLIN( 352)																int location3;
HXDLIN( 352)																if (this36->useVirtualPos) {
HXDLIN( 352)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 352)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 352)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 352)																int this60;
HXDLIN( 352)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 352)																	this60 = this59;
            																}
HXDLIN( 352)																Float a13;
HXDLIN( 352)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 352)																if ((this61 == 0)) {
HXDLIN( 352)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float r13;
HXDLIN( 352)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 352)																if ((this62 == 0)) {
HXDLIN( 352)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float g13;
HXDLIN( 352)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 352)																if ((this63 == 0)) {
HXDLIN( 352)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float b14;
HXDLIN( 352)																int this64 = (this60 & 255);
HXDLIN( 352)																if ((this64 == 0)) {
HXDLIN( 352)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float a23;
HXDLIN( 352)																int this65 = ((color >> 24) & 255);
HXDLIN( 352)																if ((this65 == 0)) {
HXDLIN( 352)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float r23;
HXDLIN( 352)																int this66 = ((color >> 16) & 255);
HXDLIN( 352)																if ((this66 == 0)) {
HXDLIN( 352)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float g23;
HXDLIN( 352)																int this67 = ((color >> 8) & 255);
HXDLIN( 352)																if ((this67 == 0)) {
HXDLIN( 352)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float b24;
HXDLIN( 352)																int this68 = (color & 255);
HXDLIN( 352)																if ((this68 == 0)) {
HXDLIN( 352)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 352)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 352)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 352)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 352)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 352)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 352)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 352)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 352)																{
HXDLIN( 352)																	int _hx_tmp14;
HXDLIN( 352)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 352)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 352)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 352)																::Dynamic this69 = this36->image;
HXDLIN( 352)																int index9;
HXDLIN( 352)																if (this36->useVirtualPos) {
HXDLIN( 352)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 352)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 352)																int _hx_tmp15;
HXDLIN( 352)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 352)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 352)																	_hx_tmp15 = c7;
            																}
HXDLIN( 352)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 352)														if (found1) {
HXDLIN( 352)															goto _hx_goto_698;
            														}
            													}
            												}
            											}
            											_hx_goto_698:;
            										}
            									}
            								}
HXDLIN( 352)								if ((hasHit1 == true)) {
HXDLIN( 352)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 352)									if (hasUndo1) {
HXDLIN( 352)										v6->undoImage = undoImage3;
HXDLIN( 352)										v6->undoX = xIter31->start;
HXDLIN( 352)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,undecagon,(void))

void FillShape_Impl__obj::dodecagon( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_365_dodecagon)
HXDLIN( 365)		 ::Dynamic phi1 = phi;
HXDLIN( 365)		 ::Dynamic sides = 12;
HXLINE( 369)		if (::hx::IsNull( sides )) {
HXLINE( 369)			sides = 36;
            		}
HXLINE( 368)		if (::hx::IsNull( phi1 )) {
HXLINE( 368)			phi1 = ((Float)0.);
            		}
HXLINE( 365)		{
HXDLIN( 365)			 ::Dynamic phi2 = phi1;
HXDLIN( 365)			 ::Dynamic sides1 = sides;
HXDLIN( 365)			if (::hx::IsNull( sides1 )) {
HXLINE( 212)				sides1 = 36;
            			}
HXLINE( 365)			if (::hx::IsNull( phi2 )) {
HXLINE( 211)				phi2 = ((Float)0.);
            			}
HXLINE( 365)			Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 365)			Float omega;
HXDLIN( 365)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN( 365)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN( 365)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN( 365)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN( 365)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN( 365)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
HXDLIN( 365)			Float lastX = ((Float)0.);
HXDLIN( 365)			Float lastY = ((Float)0.);
HXDLIN( 365)			if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)				lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)				lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            			}
            			else {
HXLINE(  38)				lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)				lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            			}
HXLINE( 365)			if (::hx::IsNotEq( phi2,0 )) {
HXDLIN( 365)				Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 365)				Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 365)				{
HXDLIN( 365)					int _g = 0;
HXDLIN( 365)					int _g1 = (sides1 + 1);
HXDLIN( 365)					while((_g < _g1)){
HXDLIN( 365)						_g = (_g + 1);
HXDLIN( 365)						int i = (_g - 1);
HXDLIN( 365)						Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 365)						Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 365)						Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 365)						Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 365)						{
HXDLIN( 365)							 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 365)							bool hasHit = false;
HXDLIN( 365)							bool hasUndo = false;
HXDLIN( 365)							{
HXDLIN( 365)								Float bx = lastX;
HXDLIN( 365)								Float by = lastY;
HXDLIN( 365)								Float cx1 = nextX;
HXDLIN( 365)								Float cy1 = nextY;
HXDLIN( 365)								bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 365)								if (!(adjustWinding)) {
HXDLIN( 365)									Float bx_ = bx;
HXDLIN( 365)									Float by_ = by;
HXLINE(  25)									bx = cx1;
HXLINE(  26)									by = cy1;
HXLINE(  27)									cx1 = bx_;
HXLINE(  28)									cy1 = by_;
            								}
HXLINE( 365)								{
HXDLIN( 365)									Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 365)									Float sx = (cy1 - cy);
HXDLIN( 365)									Float sy = (cx - cx1);
HXDLIN( 365)									Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 365)									Float tx = (cy - by);
HXDLIN( 365)									Float ty = (bx - cx);
HXDLIN( 365)									Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 365)									 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 365)									if ((cx > bx)) {
HXDLIN( 365)										if ((cx > cx1)) {
HXDLIN( 365)											int min;
HXDLIN( 365)											if ((bx > cx1)) {
HXDLIN( 365)												min = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 365)												min = ::Math_obj::floor(bx);
            											}
HXDLIN( 365)											int ii_min = min;
HXDLIN( 365)											int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 365)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            										}
            										else {
HXDLIN( 365)											int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 365)											int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 365)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            										}
            									}
            									else {
HXDLIN( 365)										if ((bx > cx1)) {
HXDLIN( 365)											int min1;
HXDLIN( 365)											if ((cx > cx1)) {
HXDLIN( 365)												min1 = ::Math_obj::floor(cx1);
            											}
            											else {
HXDLIN( 365)												min1 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 365)											int ii_min2 = min1;
HXDLIN( 365)											int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 365)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            										}
            										else {
HXDLIN( 365)											int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 365)											int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 365)											xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            										}
            									}
HXDLIN( 365)									 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 365)									if ((cy > by)) {
HXDLIN( 365)										if ((cy > cy1)) {
HXDLIN( 365)											int min2;
HXDLIN( 365)											if ((by > cy1)) {
HXDLIN( 365)												min2 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 365)												min2 = ::Math_obj::floor(by);
            											}
HXDLIN( 365)											int ii_min4 = min2;
HXDLIN( 365)											int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 365)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            										}
            										else {
HXDLIN( 365)											int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 365)											int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 365)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            										}
            									}
            									else {
HXDLIN( 365)										if ((by > cy1)) {
HXDLIN( 365)											int min3;
HXDLIN( 365)											if ((cy > cy1)) {
HXDLIN( 365)												min3 = ::Math_obj::floor(cy1);
            											}
            											else {
HXDLIN( 365)												min3 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 365)											int ii_min6 = min3;
HXDLIN( 365)											int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 365)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            										}
            										else {
HXDLIN( 365)											int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 365)											int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 365)											yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            										}
            									}
HXDLIN( 365)									 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 365)									if (hasUndo) {
HXDLIN( 365)										int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 365)										int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 365)										 ::Dynamic imageType = null();
HXDLIN( 365)										 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 365)										if (::hx::IsNull( imageType )) {
HXLINE(  54)											imageType = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 365)										::Dynamic undoImage1;
HXDLIN( 365)										switch((int)(( (int)(imageType) ))){
            											case (int)0: {
HXDLIN( 365)												 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 365)												 ::iterMagic::BytesImg b = byt;
HXDLIN( 365)												{
HXDLIN( 365)													b->width = width;
HXDLIN( 365)													b->height = height;
HXDLIN( 365)													b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 365)													b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 365)													{
HXDLIN( 365)														int len = b->length;
HXDLIN( 365)														int w = 0;
HXDLIN( 365)														{
HXDLIN( 365)															int _g2 = 0;
HXDLIN( 365)															int _g3 = b->height;
HXDLIN( 365)															while((_g2 < _g3)){
HXDLIN( 365)																_g2 = (_g2 + 1);
HXDLIN( 365)																int y = (_g2 - 1);
HXDLIN( 365)																{
HXDLIN( 365)																	int _g4 = 0;
HXDLIN( 365)																	int _g5 = b->width;
HXDLIN( 365)																	while((_g4 < _g5)){
HXDLIN( 365)																		_g4 = (_g4 + 1);
HXDLIN( 365)																		int x = (_g4 - 1);
HXDLIN( 365)																		{
HXDLIN( 365)																			w = (w + 1);
HXDLIN( 365)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 365)																		{
HXDLIN( 365)																			w = (w + 1);
HXDLIN( 365)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 365)																		{
HXDLIN( 365)																			w = (w + 1);
HXDLIN( 365)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 365)																		{
HXDLIN( 365)																			w = (w + 1);
HXDLIN( 365)																			b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 365)												undoImage1 = b;
            											}
            											break;
            											case (int)1: {
HXDLIN( 365)												 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 365)												 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 365)												{
HXDLIN( 365)													a->width = width;
HXDLIN( 365)													a->height = height;
HXDLIN( 365)													a->data = ::Array_obj< int >::__new(0);
HXDLIN( 365)													a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 365)													{
HXDLIN( 365)														int _g6 = 0;
HXDLIN( 365)														int _g7 = a->length;
HXDLIN( 365)														while((_g6 < _g7)){
HXDLIN( 365)															_g6 = (_g6 + 1);
HXDLIN( 365)															int i1 = (_g6 - 1);
HXDLIN( 365)															a->data[i1] = 0;
            														}
            													}
            												}
HXDLIN( 365)												undoImage1 = a;
            											}
            											break;
            											case (int)2: {
HXDLIN( 365)												 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 365)												 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 365)												{
HXDLIN( 365)													b1->width = width;
HXDLIN( 365)													b1->height = height;
HXDLIN( 365)													b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 365)													int size = (b1->length * 4);
HXDLIN( 365)													b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 365)													{
HXDLIN( 365)														int _g8 = 0;
HXDLIN( 365)														int _g9 = b1->length;
HXDLIN( 365)														while((_g8 < _g9)){
HXDLIN( 365)															_g8 = (_g8 + 1);
HXDLIN( 365)															int i2 = (_g8 - 1);
HXDLIN( 365)															{
HXDLIN( 365)																 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 365)																bool undoImage2;
HXDLIN( 365)																if ((i2 >= 0)) {
HXDLIN( 365)																	undoImage2 = (i2 < (this4->byteLength >> 2));
            																}
            																else {
HXDLIN( 365)																	undoImage2 = false;
            																}
HXDLIN( 365)																if (undoImage2) {
HXDLIN( 365)																	 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 365)																	int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 365)																	_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 365)																	_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 365)																	_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 365)																	_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 365)												undoImage1 = b1;
            											}
            											break;
            											case (int)3: {
HXDLIN( 365)												 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 365)												 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 365)												{
HXDLIN( 365)													v1->width = width;
HXDLIN( 365)													v1->height = height;
HXDLIN( 365)													v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 365)													v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 365)													{
HXDLIN( 365)														int _g10 = 0;
HXDLIN( 365)														int _g11 = v1->length;
HXDLIN( 365)														while((_g10 < _g11)){
HXDLIN( 365)															_g10 = (_g10 + 1);
HXDLIN( 365)															int i3 = (_g10 - 1);
HXDLIN( 365)															v1->data->__unsafe_set(i3,0);
            														}
            													}
            												}
HXDLIN( 365)												undoImage1 = v1;
            											}
            											break;
            											case (int)4: {
HXDLIN( 365)												 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 365)												 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 365)												{
HXDLIN( 365)													b2->width = width;
HXDLIN( 365)													b2->height = height;
HXDLIN( 365)													b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 365)													b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 365)													{
HXDLIN( 365)														int len1 = b2->length;
HXDLIN( 365)														 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 365)														if (::hx::IsNull( d->head )) {
HXDLIN( 365)															int _g12 = 0;
HXDLIN( 365)															int _g13 = len1;
HXDLIN( 365)															while((_g12 < _g13)){
HXDLIN( 365)																_g12 = (_g12 + 1);
HXDLIN( 365)																int i4 = (_g12 - 1);
HXDLIN( 365)																d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            															}
            														}
            														else {
HXDLIN( 365)															int _g14 = 0;
HXDLIN( 365)															int _g15 = len1;
HXDLIN( 365)															while((_g14 < _g15)){
HXDLIN( 365)																_g14 = (_g14 + 1);
HXDLIN( 365)																int i5 = (_g14 - 1);
HXDLIN( 365)																{
HXDLIN( 365)																	 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 365)																	 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 365)																	{
HXDLIN( 365)																		int _g16 = 0;
HXDLIN( 365)																		int _g17 = i5;
HXDLIN( 365)																		while((_g16 < _g17)){
HXDLIN( 365)																			_g16 = (_g16 + 1);
HXDLIN( 365)																			int i6 = (_g16 - 1);
HXLINE( 345)																			prev = l;
HXLINE( 346)																			l = l->next;
            																		}
            																	}
HXLINE( 365)																	if (::hx::IsNull( prev )) {
HXDLIN( 365)																		b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 365)																		l = null();
            																	}
            																	else {
HXDLIN( 365)																		prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 365)																		l = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 365)												undoImage1 = b2;
            											}
            											break;
            										}
HXDLIN( 365)										this3->image = undoImage1;
HXDLIN( 365)										this3->width = width;
HXDLIN( 365)										this3->height = height;
HXDLIN( 365)										this3->imageType = ( (int)(imageType) );
HXDLIN( 365)										undoImage = this3;
HXDLIN( 365)										{
HXDLIN( 365)											int rectLeft = xIter3->start;
HXDLIN( 365)											int rectTop = yIter3->start;
HXDLIN( 365)											int rectRight = xIter3->max;
HXDLIN( 365)											bool forceClear = false;
HXDLIN( 365)											{
HXDLIN( 365)												int _g18 = rectTop;
HXDLIN( 365)												int _g19 = yIter3->max;
HXDLIN( 365)												while((_g18 < _g19)){
HXDLIN( 365)													_g18 = (_g18 + 1);
HXDLIN( 365)													int dy = (_g18 - 1);
HXDLIN( 365)													{
HXDLIN( 365)														int _g20 = rectLeft;
HXDLIN( 365)														int _g21 = rectRight;
HXDLIN( 365)														while((_g20 < _g21)){
HXDLIN( 365)															_g20 = (_g20 + 1);
HXDLIN( 365)															int dx = (_g20 - 1);
HXDLIN( 365)															::Dynamic this5 = this2->image;
HXDLIN( 365)															int index;
HXDLIN( 365)															if (this2->useVirtualPos) {
HXDLIN( 365)																index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            															}
            															else {
HXDLIN( 365)																index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            															}
HXDLIN( 365)															int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 365)															int col;
HXDLIN( 365)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            															}
            															else {
HXDLIN( 365)																col = c;
            															}
HXDLIN( 365)															bool _hx_tmp;
HXDLIN( 365)															if (this2->useMask) {
HXDLIN( 365)																_hx_tmp = ::hx::IsNotNull( this2->mask );
            															}
            															else {
HXDLIN( 365)																_hx_tmp = false;
            															}
HXDLIN( 365)															if (_hx_tmp) {
HXDLIN( 365)																 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 365)																::Dynamic this7 = this6->image;
HXDLIN( 365)																int index1;
HXDLIN( 365)																if (this6->useVirtualPos) {
HXDLIN( 365)																	index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																}
            																else {
HXDLIN( 365)																	index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																}
HXDLIN( 365)																int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 365)																int v2;
HXDLIN( 365)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																	v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																}
            																else {
HXDLIN( 365)																	v2 = c1;
            																}
HXDLIN( 365)																int maskPixel = v2;
HXDLIN( 365)																int this8 = col;
HXDLIN( 365)																if ((maskPixel == 0)) {
HXDLIN( 365)																	col = this8;
            																}
            																else {
HXDLIN( 365)																	Float m0;
HXDLIN( 365)																	int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 365)																	if ((this9 == 0)) {
HXDLIN( 365)																		m0 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float m1;
HXDLIN( 365)																	int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 365)																	if ((this10 == 0)) {
HXDLIN( 365)																		m1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float m2;
HXDLIN( 365)																	int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 365)																	if ((this11 == 0)) {
HXDLIN( 365)																		m2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float m3;
HXDLIN( 365)																	int this12 = (maskPixel & 255);
HXDLIN( 365)																	if ((this12 == 0)) {
HXDLIN( 365)																		m3 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 365)																	int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 365)																	int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 365)																	int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 365)																	col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 365)															if ((col != 0)) {
HXDLIN( 365)																int x1 = (dx - rectLeft);
HXDLIN( 365)																int y1 = (dy - rectTop);
HXDLIN( 365)																int c2 = col;
HXDLIN( 365)																bool _hx_tmp1;
HXDLIN( 365)																if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 365)																	_hx_tmp1 = undoImage->transparent;
            																}
            																else {
HXDLIN( 365)																	_hx_tmp1 = false;
            																}
HXDLIN( 365)																if (_hx_tmp1) {
HXDLIN( 365)																	int location;
HXDLIN( 365)																	if (undoImage->useVirtualPos) {
HXDLIN( 365)																		location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 365)																		location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 365)																	int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 365)																	int this14;
HXDLIN( 365)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																		this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 365)																		this14 = this13;
            																	}
HXDLIN( 365)																	Float a1;
HXDLIN( 365)																	int this15 = ((this14 >> 24) & 255);
HXDLIN( 365)																	if ((this15 == 0)) {
HXDLIN( 365)																		a1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float r1;
HXDLIN( 365)																	int this16 = ((this14 >> 16) & 255);
HXDLIN( 365)																	if ((this16 == 0)) {
HXDLIN( 365)																		r1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float g1;
HXDLIN( 365)																	int this17 = ((this14 >> 8) & 255);
HXDLIN( 365)																	if ((this17 == 0)) {
HXDLIN( 365)																		g1 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float b11;
HXDLIN( 365)																	int this18 = (this14 & 255);
HXDLIN( 365)																	if ((this18 == 0)) {
HXDLIN( 365)																		b11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float a2;
HXDLIN( 365)																	int this19 = ((col >> 24) & 255);
HXDLIN( 365)																	if ((this19 == 0)) {
HXDLIN( 365)																		a2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float r2;
HXDLIN( 365)																	int this20 = ((col >> 16) & 255);
HXDLIN( 365)																	if ((this20 == 0)) {
HXDLIN( 365)																		r2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float g2;
HXDLIN( 365)																	int this21 = ((col >> 8) & 255);
HXDLIN( 365)																	if ((this21 == 0)) {
HXDLIN( 365)																		g2 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float b21;
HXDLIN( 365)																	int this22 = (col & 255);
HXDLIN( 365)																	if ((this22 == 0)) {
HXDLIN( 365)																		b21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 365)																	int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 365)																	int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 365)																	int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 365)																	int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 365)																	int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 365)																	{
HXDLIN( 365)																		int _hx_tmp2;
HXDLIN( 365)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																			_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																		}
            																		else {
HXDLIN( 365)																			_hx_tmp2 = blended;
            																		}
HXDLIN( 365)																		::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																	}
            																}
            																else {
HXDLIN( 365)																	::Dynamic this23 = undoImage->image;
HXDLIN( 365)																	int index2;
HXDLIN( 365)																	if (undoImage->useVirtualPos) {
HXDLIN( 365)																		index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 365)																		index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																	}
HXDLIN( 365)																	int _hx_tmp3;
HXDLIN( 365)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																		_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 365)																		_hx_tmp3 = c2;
            																	}
HXDLIN( 365)																	::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																}
            															}
            															else {
HXDLIN( 365)																if (forceClear) {
HXDLIN( 365)																	::Dynamic this24 = undoImage->image;
HXDLIN( 365)																	int x2 = (dx - rectLeft);
HXDLIN( 365)																	int y2 = (dy - rectTop);
HXDLIN( 365)																	int index3;
HXDLIN( 365)																	if (undoImage->useVirtualPos) {
HXDLIN( 365)																		index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																	}
            																	else {
HXDLIN( 365)																		index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																	}
HXDLIN( 365)																	::iterMagic::Iimg_obj::set(this24,index3,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 365)									bool found = false;
HXDLIN( 365)									Float s = ((Float)0.);
HXDLIN( 365)									Float t = ((Float)0.);
HXDLIN( 365)									Float sxx = ((Float)0.);
HXDLIN( 365)									Float txx = ((Float)0.);
HXDLIN( 365)									{
HXDLIN( 365)										int _g_min = xIter3->start;
HXDLIN( 365)										int _g_max = xIter3->max;
HXDLIN( 365)										while((_g_min < _g_max)){
HXDLIN( 365)											_g_min = (_g_min + 1);
HXDLIN( 365)											int x3 = (_g_min - 1);
HXLINE(  60)											sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)											txx = (tx * ( (Float)(x3) ));
HXLINE(  62)											found = false;
HXLINE( 365)											{
HXDLIN( 365)												int _g_min1 = yIter3->start;
HXDLIN( 365)												int _g_max1 = yIter3->max;
HXDLIN( 365)												while((_g_min1 < _g_max1)){
HXDLIN( 365)													_g_min1 = (_g_min1 + 1);
HXDLIN( 365)													int y3 = (_g_min1 - 1);
HXLINE(  64)													s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)													t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 365)													bool _hx_tmp4;
HXDLIN( 365)													if (!((s <= 0))) {
HXDLIN( 365)														_hx_tmp4 = (t <= 0);
            													}
            													else {
HXDLIN( 365)														_hx_tmp4 = true;
            													}
HXDLIN( 365)													if (_hx_tmp4) {
HXDLIN( 365)														if (found) {
HXDLIN( 365)															goto _hx_goto_712;
            														}
            													}
            													else {
HXDLIN( 365)														if (((s + t) < A)) {
HXDLIN( 365)															{
HXDLIN( 365)																int c3 = color;
HXDLIN( 365)																bool _hx_tmp5;
HXDLIN( 365)																if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 365)																	_hx_tmp5 = this2->transparent;
            																}
            																else {
HXDLIN( 365)																	_hx_tmp5 = false;
            																}
HXDLIN( 365)																if (_hx_tmp5) {
HXDLIN( 365)																	int location1;
HXDLIN( 365)																	if (this2->useVirtualPos) {
HXDLIN( 365)																		location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 365)																		location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 365)																	int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 365)																	int this26;
HXDLIN( 365)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																		this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 365)																		this26 = this25;
            																	}
HXDLIN( 365)																	Float a11;
HXDLIN( 365)																	int this27 = ((this26 >> 24) & 255);
HXDLIN( 365)																	if ((this27 == 0)) {
HXDLIN( 365)																		a11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float r11;
HXDLIN( 365)																	int this28 = ((this26 >> 16) & 255);
HXDLIN( 365)																	if ((this28 == 0)) {
HXDLIN( 365)																		r11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float g11;
HXDLIN( 365)																	int this29 = ((this26 >> 8) & 255);
HXDLIN( 365)																	if ((this29 == 0)) {
HXDLIN( 365)																		g11 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float b12;
HXDLIN( 365)																	int this30 = (this26 & 255);
HXDLIN( 365)																	if ((this30 == 0)) {
HXDLIN( 365)																		b12 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float a21;
HXDLIN( 365)																	int this31 = ((color >> 24) & 255);
HXDLIN( 365)																	if ((this31 == 0)) {
HXDLIN( 365)																		a21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float r21;
HXDLIN( 365)																	int this32 = ((color >> 16) & 255);
HXDLIN( 365)																	if ((this32 == 0)) {
HXDLIN( 365)																		r21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float g21;
HXDLIN( 365)																	int this33 = ((color >> 8) & 255);
HXDLIN( 365)																	if ((this33 == 0)) {
HXDLIN( 365)																		g21 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float b22;
HXDLIN( 365)																	int this34 = (color & 255);
HXDLIN( 365)																	if ((this34 == 0)) {
HXDLIN( 365)																		b22 = ((Float)0.);
            																	}
            																	else {
HXDLIN( 365)																		b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																	}
HXDLIN( 365)																	Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 365)																	int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 365)																	int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 365)																	int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 365)																	int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 365)																	int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 365)																	{
HXDLIN( 365)																		int _hx_tmp6;
HXDLIN( 365)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																			_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																		}
            																		else {
HXDLIN( 365)																			_hx_tmp6 = blended1;
            																		}
HXDLIN( 365)																		::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																	}
            																}
            																else {
HXDLIN( 365)																	::Dynamic this35 = this2->image;
HXDLIN( 365)																	int index4;
HXDLIN( 365)																	if (this2->useVirtualPos) {
HXDLIN( 365)																		index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																	}
            																	else {
HXDLIN( 365)																		index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																	}
HXDLIN( 365)																	int _hx_tmp7;
HXDLIN( 365)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																		_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 365)																		_hx_tmp7 = c3;
            																	}
HXDLIN( 365)																	::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																}
            															}
HXLINE(  73)															found = true;
            														}
            														else {
HXDLIN( 365)															if (found) {
HXDLIN( 365)																goto _hx_goto_712;
            															}
            														}
            													}
            												}
            												_hx_goto_712:;
            											}
            										}
            									}
HXDLIN( 365)									if ((hasHit == true)) {
HXDLIN( 365)										 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 365)										if (hasUndo) {
HXDLIN( 365)											v3->undoImage = undoImage;
HXDLIN( 365)											v3->undoX = xIter3->start;
HXDLIN( 365)											v3->undoY = yIter3->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  51)						lastX = nextX;
HXLINE(  52)						lastY = nextY;
            					}
            				}
            			}
            			else {
HXDLIN( 365)				int _g22 = 0;
HXDLIN( 365)				int _g23 = (sides1 + 1);
HXDLIN( 365)				while((_g22 < _g23)){
HXDLIN( 365)					_g22 = (_g22 + 1);
HXDLIN( 365)					int i7 = (_g22 - 1);
HXDLIN( 365)					Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 365)					Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 365)					{
HXDLIN( 365)						 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 365)						bool hasHit1 = false;
HXDLIN( 365)						bool hasUndo1 = false;
HXDLIN( 365)						{
HXDLIN( 365)							Float bx1 = lastX;
HXDLIN( 365)							Float by1 = lastY;
HXDLIN( 365)							Float cx2 = nextX1;
HXDLIN( 365)							Float cy2 = nextY1;
HXDLIN( 365)							bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 365)							if (!(adjustWinding1)) {
HXDLIN( 365)								Float bx_1 = bx1;
HXDLIN( 365)								Float by_1 = by1;
HXLINE(  25)								bx1 = cx2;
HXLINE(  26)								by1 = cy2;
HXLINE(  27)								cx2 = bx_1;
HXLINE(  28)								cy2 = by_1;
            							}
HXLINE( 365)							{
HXDLIN( 365)								Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 365)								Float sx1 = (cy2 - cy);
HXDLIN( 365)								Float sy1 = (cx - cx2);
HXDLIN( 365)								Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 365)								Float tx1 = (cy - by1);
HXDLIN( 365)								Float ty1 = (bx1 - cx);
HXDLIN( 365)								Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 365)								 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 365)								if ((cx > bx1)) {
HXDLIN( 365)									if ((cx > cx2)) {
HXDLIN( 365)										int min4;
HXDLIN( 365)										if ((bx1 > cx2)) {
HXDLIN( 365)											min4 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 365)											min4 = ::Math_obj::floor(bx1);
            										}
HXDLIN( 365)										int ii_min8 = min4;
HXDLIN( 365)										int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 365)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            									}
            									else {
HXDLIN( 365)										int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 365)										int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 365)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            									}
            								}
            								else {
HXDLIN( 365)									if ((bx1 > cx2)) {
HXDLIN( 365)										int min5;
HXDLIN( 365)										if ((cx > cx2)) {
HXDLIN( 365)											min5 = ::Math_obj::floor(cx2);
            										}
            										else {
HXDLIN( 365)											min5 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 365)										int ii_min10 = min5;
HXDLIN( 365)										int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 365)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            									}
            									else {
HXDLIN( 365)										int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 365)										int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 365)										xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            									}
            								}
HXDLIN( 365)								 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 365)								if ((cy > by1)) {
HXDLIN( 365)									if ((cy > cy2)) {
HXDLIN( 365)										int min6;
HXDLIN( 365)										if ((by1 > cy2)) {
HXDLIN( 365)											min6 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 365)											min6 = ::Math_obj::floor(by1);
            										}
HXDLIN( 365)										int ii_min12 = min6;
HXDLIN( 365)										int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 365)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            									}
            									else {
HXDLIN( 365)										int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 365)										int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 365)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            									}
            								}
            								else {
HXDLIN( 365)									if ((by1 > cy2)) {
HXDLIN( 365)										int min7;
HXDLIN( 365)										if ((cy > cy2)) {
HXDLIN( 365)											min7 = ::Math_obj::floor(cy2);
            										}
            										else {
HXDLIN( 365)											min7 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 365)										int ii_min14 = min7;
HXDLIN( 365)										int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 365)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            									}
            									else {
HXDLIN( 365)										int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 365)										int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 365)										yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            									}
            								}
HXDLIN( 365)								 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 365)								if (hasUndo1) {
HXDLIN( 365)									int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 365)									int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 365)									 ::Dynamic imageType1 = null();
HXDLIN( 365)									 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 365)									if (::hx::IsNull( imageType1 )) {
HXLINE(  54)										imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 365)									::Dynamic undoImage4;
HXDLIN( 365)									switch((int)(( (int)(imageType1) ))){
            										case (int)0: {
HXDLIN( 365)											 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 365)											 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 365)											{
HXDLIN( 365)												b5->width = width1;
HXDLIN( 365)												b5->height = height1;
HXDLIN( 365)												b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 365)												b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 365)												{
HXDLIN( 365)													int len2 = b5->length;
HXDLIN( 365)													int w1 = 0;
HXDLIN( 365)													{
HXDLIN( 365)														int _g24 = 0;
HXDLIN( 365)														int _g25 = b5->height;
HXDLIN( 365)														while((_g24 < _g25)){
HXDLIN( 365)															_g24 = (_g24 + 1);
HXDLIN( 365)															int y4 = (_g24 - 1);
HXDLIN( 365)															{
HXDLIN( 365)																int _g26 = 0;
HXDLIN( 365)																int _g27 = b5->width;
HXDLIN( 365)																while((_g26 < _g27)){
HXDLIN( 365)																	_g26 = (_g26 + 1);
HXDLIN( 365)																	int x4 = (_g26 - 1);
HXDLIN( 365)																	{
HXDLIN( 365)																		w1 = (w1 + 1);
HXDLIN( 365)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 365)																	{
HXDLIN( 365)																		w1 = (w1 + 1);
HXDLIN( 365)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 365)																	{
HXDLIN( 365)																		w1 = (w1 + 1);
HXDLIN( 365)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 365)																	{
HXDLIN( 365)																		w1 = (w1 + 1);
HXDLIN( 365)																		b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 365)											undoImage4 = b5;
            										}
            										break;
            										case (int)1: {
HXDLIN( 365)											 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 365)											 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 365)											{
HXDLIN( 365)												a6->width = width1;
HXDLIN( 365)												a6->height = height1;
HXDLIN( 365)												a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 365)												a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 365)												{
HXDLIN( 365)													int _g28 = 0;
HXDLIN( 365)													int _g29 = a6->length;
HXDLIN( 365)													while((_g28 < _g29)){
HXDLIN( 365)														_g28 = (_g28 + 1);
HXDLIN( 365)														int i8 = (_g28 - 1);
HXDLIN( 365)														a6->data[i8] = 0;
            													}
            												}
            											}
HXDLIN( 365)											undoImage4 = a6;
            										}
            										break;
            										case (int)2: {
HXDLIN( 365)											 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 365)											 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 365)											{
HXDLIN( 365)												b6->width = width1;
HXDLIN( 365)												b6->height = height1;
HXDLIN( 365)												b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 365)												int size1 = (b6->length * 4);
HXDLIN( 365)												b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 365)												{
HXDLIN( 365)													int _g30 = 0;
HXDLIN( 365)													int _g31 = b6->length;
HXDLIN( 365)													while((_g30 < _g31)){
HXDLIN( 365)														_g30 = (_g30 + 1);
HXDLIN( 365)														int i9 = (_g30 - 1);
HXDLIN( 365)														{
HXDLIN( 365)															 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 365)															bool undoImage5;
HXDLIN( 365)															if ((i9 >= 0)) {
HXDLIN( 365)																undoImage5 = (i9 < (this38->byteLength >> 2));
            															}
            															else {
HXDLIN( 365)																undoImage5 = false;
            															}
HXDLIN( 365)															if (undoImage5) {
HXDLIN( 365)																 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 365)																int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 365)																_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 365)																_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 365)																_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 365)																_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 365)											undoImage4 = b6;
            										}
            										break;
            										case (int)3: {
HXDLIN( 365)											 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 365)											 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN( 365)											{
HXDLIN( 365)												v4->width = width1;
HXDLIN( 365)												v4->height = height1;
HXDLIN( 365)												v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 365)												v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 365)												{
HXDLIN( 365)													int _g32 = 0;
HXDLIN( 365)													int _g33 = v4->length;
HXDLIN( 365)													while((_g32 < _g33)){
HXDLIN( 365)														_g32 = (_g32 + 1);
HXDLIN( 365)														int i10 = (_g32 - 1);
HXDLIN( 365)														v4->data->__unsafe_set(i10,0);
            													}
            												}
            											}
HXDLIN( 365)											undoImage4 = v4;
            										}
            										break;
            										case (int)4: {
HXDLIN( 365)											 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 365)											 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 365)											{
HXDLIN( 365)												b7->width = width1;
HXDLIN( 365)												b7->height = height1;
HXDLIN( 365)												b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 365)												b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 365)												{
HXDLIN( 365)													int len3 = b7->length;
HXDLIN( 365)													 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 365)													if (::hx::IsNull( d1->head )) {
HXDLIN( 365)														int _g34 = 0;
HXDLIN( 365)														int _g35 = len3;
HXDLIN( 365)														while((_g34 < _g35)){
HXDLIN( 365)															_g34 = (_g34 + 1);
HXDLIN( 365)															int i11 = (_g34 - 1);
HXDLIN( 365)															d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            														}
            													}
            													else {
HXDLIN( 365)														int _g36 = 0;
HXDLIN( 365)														int _g37 = len3;
HXDLIN( 365)														while((_g36 < _g37)){
HXDLIN( 365)															_g36 = (_g36 + 1);
HXDLIN( 365)															int i12 = (_g36 - 1);
HXDLIN( 365)															{
HXDLIN( 365)																 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 365)																 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 365)																{
HXDLIN( 365)																	int _g38 = 0;
HXDLIN( 365)																	int _g39 = i12;
HXDLIN( 365)																	while((_g38 < _g39)){
HXDLIN( 365)																		_g38 = (_g38 + 1);
HXDLIN( 365)																		int i13 = (_g38 - 1);
HXLINE( 345)																		prev1 = l1;
HXLINE( 346)																		l1 = l1->next;
            																	}
            																}
HXLINE( 365)																if (::hx::IsNull( prev1 )) {
HXDLIN( 365)																	b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 365)																	l1 = null();
            																}
            																else {
HXDLIN( 365)																	prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 365)																	l1 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 365)											undoImage4 = b7;
            										}
            										break;
            									}
HXDLIN( 365)									this37->image = undoImage4;
HXDLIN( 365)									this37->width = width1;
HXDLIN( 365)									this37->height = height1;
HXDLIN( 365)									this37->imageType = ( (int)(imageType1) );
HXDLIN( 365)									undoImage3 = this37;
HXDLIN( 365)									{
HXDLIN( 365)										int rectLeft1 = xIter31->start;
HXDLIN( 365)										int rectTop1 = yIter31->start;
HXDLIN( 365)										int rectRight1 = xIter31->max;
HXDLIN( 365)										bool forceClear1 = false;
HXDLIN( 365)										{
HXDLIN( 365)											int _g40 = rectTop1;
HXDLIN( 365)											int _g41 = yIter31->max;
HXDLIN( 365)											while((_g40 < _g41)){
HXDLIN( 365)												_g40 = (_g40 + 1);
HXDLIN( 365)												int dy1 = (_g40 - 1);
HXDLIN( 365)												{
HXDLIN( 365)													int _g42 = rectLeft1;
HXDLIN( 365)													int _g43 = rectRight1;
HXDLIN( 365)													while((_g42 < _g43)){
HXDLIN( 365)														_g42 = (_g42 + 1);
HXDLIN( 365)														int dx1 = (_g42 - 1);
HXDLIN( 365)														::Dynamic this39 = this36->image;
HXDLIN( 365)														int index5;
HXDLIN( 365)														if (this36->useVirtualPos) {
HXDLIN( 365)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            														}
            														else {
HXDLIN( 365)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            														}
HXDLIN( 365)														int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 365)														int col1;
HXDLIN( 365)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)															col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXDLIN( 365)															col1 = c4;
            														}
HXDLIN( 365)														bool _hx_tmp8;
HXDLIN( 365)														if (this36->useMask) {
HXDLIN( 365)															_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            														}
            														else {
HXDLIN( 365)															_hx_tmp8 = false;
            														}
HXDLIN( 365)														if (_hx_tmp8) {
HXDLIN( 365)															 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 365)															::Dynamic this41 = this40->image;
HXDLIN( 365)															int index6;
HXDLIN( 365)															if (this40->useVirtualPos) {
HXDLIN( 365)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            															}
            															else {
HXDLIN( 365)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            															}
HXDLIN( 365)															int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 365)															int v5;
HXDLIN( 365)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																v5 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXDLIN( 365)																v5 = c5;
            															}
HXDLIN( 365)															int maskPixel1 = v5;
HXDLIN( 365)															int this42 = col1;
HXDLIN( 365)															if ((maskPixel1 == 0)) {
HXDLIN( 365)																col1 = this42;
            															}
            															else {
HXDLIN( 365)																Float m01;
HXDLIN( 365)																int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 365)																if ((this43 == 0)) {
HXDLIN( 365)																	m01 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float m11;
HXDLIN( 365)																int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 365)																if ((this44 == 0)) {
HXDLIN( 365)																	m11 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float m21;
HXDLIN( 365)																int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 365)																if ((this45 == 0)) {
HXDLIN( 365)																	m21 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float m31;
HXDLIN( 365)																int this46 = (maskPixel1 & 255);
HXDLIN( 365)																if ((this46 == 0)) {
HXDLIN( 365)																	m31 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 365)																int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 365)																int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 365)																int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 365)																col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 365)														if ((col1 != 0)) {
HXDLIN( 365)															int x5 = (dx1 - rectLeft1);
HXDLIN( 365)															int y5 = (dy1 - rectTop1);
HXDLIN( 365)															int c6 = col1;
HXDLIN( 365)															bool _hx_tmp9;
HXDLIN( 365)															if ((((c6 >> 24) & 255) < 254)) {
HXDLIN( 365)																_hx_tmp9 = undoImage3->transparent;
            															}
            															else {
HXDLIN( 365)																_hx_tmp9 = false;
            															}
HXDLIN( 365)															if (_hx_tmp9) {
HXDLIN( 365)																int location2;
HXDLIN( 365)																if (undoImage3->useVirtualPos) {
HXDLIN( 365)																	location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 365)																	location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 365)																int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 365)																int this48;
HXDLIN( 365)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																	this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																}
            																else {
HXDLIN( 365)																	this48 = this47;
            																}
HXDLIN( 365)																Float a12;
HXDLIN( 365)																int this49 = ((this48 >> 24) & 255);
HXDLIN( 365)																if ((this49 == 0)) {
HXDLIN( 365)																	a12 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float r12;
HXDLIN( 365)																int this50 = ((this48 >> 16) & 255);
HXDLIN( 365)																if ((this50 == 0)) {
HXDLIN( 365)																	r12 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float g12;
HXDLIN( 365)																int this51 = ((this48 >> 8) & 255);
HXDLIN( 365)																if ((this51 == 0)) {
HXDLIN( 365)																	g12 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float b13;
HXDLIN( 365)																int this52 = (this48 & 255);
HXDLIN( 365)																if ((this52 == 0)) {
HXDLIN( 365)																	b13 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float a22;
HXDLIN( 365)																int this53 = ((col1 >> 24) & 255);
HXDLIN( 365)																if ((this53 == 0)) {
HXDLIN( 365)																	a22 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float r22;
HXDLIN( 365)																int this54 = ((col1 >> 16) & 255);
HXDLIN( 365)																if ((this54 == 0)) {
HXDLIN( 365)																	r22 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float g22;
HXDLIN( 365)																int this55 = ((col1 >> 8) & 255);
HXDLIN( 365)																if ((this55 == 0)) {
HXDLIN( 365)																	g22 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float b23;
HXDLIN( 365)																int this56 = (col1 & 255);
HXDLIN( 365)																if ((this56 == 0)) {
HXDLIN( 365)																	b23 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 365)																int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 365)																int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 365)																int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 365)																int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 365)																int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 365)																{
HXDLIN( 365)																	int _hx_tmp10;
HXDLIN( 365)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																		_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 365)																		_hx_tmp10 = blended2;
            																	}
HXDLIN( 365)																	::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																}
            															}
            															else {
HXDLIN( 365)																::Dynamic this57 = undoImage3->image;
HXDLIN( 365)																int index7;
HXDLIN( 365)																if (undoImage3->useVirtualPos) {
HXDLIN( 365)																	index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 365)																	index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																}
HXDLIN( 365)																int _hx_tmp11;
HXDLIN( 365)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																	_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXDLIN( 365)																	_hx_tmp11 = c6;
            																}
HXDLIN( 365)																::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            															}
            														}
            														else {
HXDLIN( 365)															if (forceClear1) {
HXDLIN( 365)																::Dynamic this58 = undoImage3->image;
HXDLIN( 365)																int x6 = (dx1 - rectLeft1);
HXDLIN( 365)																int y6 = (dy1 - rectTop1);
HXDLIN( 365)																int index8;
HXDLIN( 365)																if (undoImage3->useVirtualPos) {
HXDLIN( 365)																	index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																}
            																else {
HXDLIN( 365)																	index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																}
HXDLIN( 365)																::iterMagic::Iimg_obj::set(this58,index8,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 365)								bool found1 = false;
HXDLIN( 365)								Float s1 = ((Float)0.);
HXDLIN( 365)								Float t1 = ((Float)0.);
HXDLIN( 365)								Float sxx1 = ((Float)0.);
HXDLIN( 365)								Float txx1 = ((Float)0.);
HXDLIN( 365)								{
HXDLIN( 365)									int _g_min2 = xIter31->start;
HXDLIN( 365)									int _g_max2 = xIter31->max;
HXDLIN( 365)									while((_g_min2 < _g_max2)){
HXDLIN( 365)										_g_min2 = (_g_min2 + 1);
HXDLIN( 365)										int x7 = (_g_min2 - 1);
HXLINE(  60)										sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)										txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)										found1 = false;
HXLINE( 365)										{
HXDLIN( 365)											int _g_min3 = yIter31->start;
HXDLIN( 365)											int _g_max3 = yIter31->max;
HXDLIN( 365)											while((_g_min3 < _g_max3)){
HXDLIN( 365)												_g_min3 = (_g_min3 + 1);
HXDLIN( 365)												int y7 = (_g_min3 - 1);
HXLINE(  64)												s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)												t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 365)												bool _hx_tmp12;
HXDLIN( 365)												if (!((s1 <= 0))) {
HXDLIN( 365)													_hx_tmp12 = (t1 <= 0);
            												}
            												else {
HXDLIN( 365)													_hx_tmp12 = true;
            												}
HXDLIN( 365)												if (_hx_tmp12) {
HXDLIN( 365)													if (found1) {
HXDLIN( 365)														goto _hx_goto_725;
            													}
            												}
            												else {
HXDLIN( 365)													if (((s1 + t1) < A1)) {
HXDLIN( 365)														{
HXDLIN( 365)															int c7 = color;
HXDLIN( 365)															bool _hx_tmp13;
HXDLIN( 365)															if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 365)																_hx_tmp13 = this36->transparent;
            															}
            															else {
HXDLIN( 365)																_hx_tmp13 = false;
            															}
HXDLIN( 365)															if (_hx_tmp13) {
HXDLIN( 365)																int location3;
HXDLIN( 365)																if (this36->useVirtualPos) {
HXDLIN( 365)																	location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 365)																	location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 365)																int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 365)																int this60;
HXDLIN( 365)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																	this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																}
            																else {
HXDLIN( 365)																	this60 = this59;
            																}
HXDLIN( 365)																Float a13;
HXDLIN( 365)																int this61 = ((this60 >> 24) & 255);
HXDLIN( 365)																if ((this61 == 0)) {
HXDLIN( 365)																	a13 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float r13;
HXDLIN( 365)																int this62 = ((this60 >> 16) & 255);
HXDLIN( 365)																if ((this62 == 0)) {
HXDLIN( 365)																	r13 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float g13;
HXDLIN( 365)																int this63 = ((this60 >> 8) & 255);
HXDLIN( 365)																if ((this63 == 0)) {
HXDLIN( 365)																	g13 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float b14;
HXDLIN( 365)																int this64 = (this60 & 255);
HXDLIN( 365)																if ((this64 == 0)) {
HXDLIN( 365)																	b14 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float a23;
HXDLIN( 365)																int this65 = ((color >> 24) & 255);
HXDLIN( 365)																if ((this65 == 0)) {
HXDLIN( 365)																	a23 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float r23;
HXDLIN( 365)																int this66 = ((color >> 16) & 255);
HXDLIN( 365)																if ((this66 == 0)) {
HXDLIN( 365)																	r23 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float g23;
HXDLIN( 365)																int this67 = ((color >> 8) & 255);
HXDLIN( 365)																if ((this67 == 0)) {
HXDLIN( 365)																	g23 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float b24;
HXDLIN( 365)																int this68 = (color & 255);
HXDLIN( 365)																if ((this68 == 0)) {
HXDLIN( 365)																	b24 = ((Float)0.);
            																}
            																else {
HXDLIN( 365)																	b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																}
HXDLIN( 365)																Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 365)																int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 365)																int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 365)																int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 365)																int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 365)																int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 365)																{
HXDLIN( 365)																	int _hx_tmp14;
HXDLIN( 365)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																		_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 365)																		_hx_tmp14 = blended3;
            																	}
HXDLIN( 365)																	::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																}
            															}
            															else {
HXDLIN( 365)																::Dynamic this69 = this36->image;
HXDLIN( 365)																int index9;
HXDLIN( 365)																if (this36->useVirtualPos) {
HXDLIN( 365)																	index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																}
            																else {
HXDLIN( 365)																	index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																}
HXDLIN( 365)																int _hx_tmp15;
HXDLIN( 365)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 365)																	_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																}
            																else {
HXDLIN( 365)																	_hx_tmp15 = c7;
            																}
HXDLIN( 365)																::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            															}
            														}
HXLINE(  73)														found1 = true;
            													}
            													else {
HXDLIN( 365)														if (found1) {
HXDLIN( 365)															goto _hx_goto_725;
            														}
            													}
            												}
            											}
            											_hx_goto_725:;
            										}
            									}
            								}
HXDLIN( 365)								if ((hasHit1 == true)) {
HXDLIN( 365)									 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 365)									if (hasUndo1) {
HXDLIN( 365)										v6->undoImage = undoImage3;
HXDLIN( 365)										v6->undoX = xIter31->start;
HXDLIN( 365)										v6->undoY = yIter31->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  59)					lastX = nextX1;
HXLINE(  60)					lastY = nextY1;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(FillShape_Impl__obj,dodecagon,(void))

 ::pi_xy::algo::HitTriArray FillShape_Impl__obj::pie( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float rx,Float ry,Float startRadian,Float sweepRadian,int color,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_targetError){
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_379_pie)
HXLINE( 380)		Float rSmall;
HXDLIN( 380)		if ((rx > ry)) {
HXLINE( 380)			rSmall = ry;
            		}
            		else {
HXLINE( 380)			rSmall = rx;
            		}
HXLINE( 381)		 ::Dynamic targetE = targetError;
HXDLIN( 381)		if (::hx::IsNull( targetE )) {
HXLINE( 381)			targetE = ((Float)1.05);
            		}
HXDLIN( 381)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 381)		int noSides;
HXDLIN( 381)		if ((result < 12)) {
HXLINE( 381)			noSides = 12;
            		}
            		else {
HXLINE( 381)			if ((result > 500)) {
HXLINE( 381)				noSides = 500;
            			}
            			else {
HXLINE( 381)				noSides = result;
            			}
            		}
HXLINE( 382)		Float theta = ((((Float)1.41213) * ::Math_obj::PI) / ( (Float)(noSides) ));
HXLINE( 383)		Float currAngle = startRadian;
HXLINE( 384)		int tot = ::Math_obj::floor((sweepRadian / theta));
HXLINE( 385)		theta = (theta + (((sweepRadian / theta) - ( (Float)(tot) )) / ( (Float)(noSides) )));
HXLINE( 386)		tot = ::Math_obj::floor((sweepRadian / theta));
HXLINE( 387)		Float bx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 388)		Float by = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 389)		Float cx = ((Float)0.);
HXLINE( 390)		Float cy = ((Float)0.);
HXLINE( 391)		::Array< ::Dynamic> arrTri = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 392)		{
HXLINE( 392)			int _g = 1;
HXDLIN( 392)			int _g1 = (tot + 1);
HXDLIN( 392)			while((_g < _g1)){
HXLINE( 392)				_g = (_g + 1);
HXDLIN( 392)				int i = (_g - 1);
HXLINE( 393)				currAngle = (startRadian + (( (Float)(i) ) * theta));
HXLINE( 394)				cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 395)				cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 396)				bool hasUndo = false;
HXDLIN( 396)				Float bx1 = bx;
HXDLIN( 396)				Float by1 = by;
HXDLIN( 396)				Float cx1 = cx;
HXDLIN( 396)				Float cy1 = cy;
HXDLIN( 396)				bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 396)				if (!(adjustWinding)) {
HXLINE( 396)					Float bx_ = bx1;
HXDLIN( 396)					Float by_ = by1;
HXLINE(  25)					bx1 = cx1;
HXLINE(  26)					by1 = cy1;
HXLINE(  27)					cx1 = bx_;
HXLINE(  28)					cy1 = by_;
            				}
HXLINE( 396)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 396)				Float sx = (cy1 - ay);
HXDLIN( 396)				Float sy = (ax - cx1);
HXDLIN( 396)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 396)				Float tx = (ay - by1);
HXDLIN( 396)				Float ty = (bx1 - ax);
HXDLIN( 396)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 396)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 396)				if ((ax > bx1)) {
HXLINE( 396)					if ((ax > cx1)) {
HXLINE( 396)						int min;
HXDLIN( 396)						if ((bx1 > cx1)) {
HXLINE( 396)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 396)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN( 396)						int ii_min = min;
HXDLIN( 396)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 396)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE( 396)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 396)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 396)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE( 396)					if ((bx1 > cx1)) {
HXLINE( 396)						int min1;
HXDLIN( 396)						if ((ax > cx1)) {
HXLINE( 396)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 396)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 396)						int ii_min2 = min1;
HXDLIN( 396)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 396)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 396)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 396)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 396)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 396)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 396)				if ((ay > by1)) {
HXLINE( 396)					if ((ay > cy1)) {
HXLINE( 396)						int min2;
HXDLIN( 396)						if ((by1 > cy1)) {
HXLINE( 396)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 396)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN( 396)						int ii_min4 = min2;
HXDLIN( 396)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 396)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 396)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 396)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 396)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE( 396)					if ((by1 > cy1)) {
HXLINE( 396)						int min3;
HXDLIN( 396)						if ((ay > cy1)) {
HXLINE( 396)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 396)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 396)						int ii_min6 = min3;
HXDLIN( 396)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 396)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 396)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 396)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 396)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 396)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 396)				if (hasUndo) {
HXLINE( 396)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 396)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 396)					 ::Dynamic imageType = null();
HXDLIN( 396)					 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 396)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 396)					::Dynamic undoImage1;
HXDLIN( 396)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 396)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 396)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 396)							{
HXLINE( 396)								b->width = width;
HXDLIN( 396)								b->height = height;
HXDLIN( 396)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 396)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 396)								{
HXLINE( 396)									int len = b->length;
HXDLIN( 396)									int w = 0;
HXDLIN( 396)									{
HXLINE( 396)										int _g2 = 0;
HXDLIN( 396)										int _g3 = b->height;
HXDLIN( 396)										while((_g2 < _g3)){
HXLINE( 396)											_g2 = (_g2 + 1);
HXDLIN( 396)											int y = (_g2 - 1);
HXDLIN( 396)											{
HXLINE( 396)												int _g4 = 0;
HXDLIN( 396)												int _g5 = b->width;
HXDLIN( 396)												while((_g4 < _g5)){
HXLINE( 396)													_g4 = (_g4 + 1);
HXDLIN( 396)													int x = (_g4 - 1);
HXDLIN( 396)													{
HXLINE( 396)														w = (w + 1);
HXDLIN( 396)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 396)													{
HXLINE( 396)														w = (w + 1);
HXDLIN( 396)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 396)													{
HXLINE( 396)														w = (w + 1);
HXDLIN( 396)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 396)													{
HXLINE( 396)														w = (w + 1);
HXDLIN( 396)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 396)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE( 396)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 396)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 396)							{
HXLINE( 396)								a->width = width;
HXDLIN( 396)								a->height = height;
HXDLIN( 396)								a->data = ::Array_obj< int >::__new(0);
HXDLIN( 396)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 396)								{
HXLINE( 396)									int _g6 = 0;
HXDLIN( 396)									int _g7 = a->length;
HXDLIN( 396)									while((_g6 < _g7)){
HXLINE( 396)										_g6 = (_g6 + 1);
HXDLIN( 396)										int i1 = (_g6 - 1);
HXDLIN( 396)										a->data[i1] = 0;
            									}
            								}
            							}
HXDLIN( 396)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE( 396)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 396)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 396)							{
HXLINE( 396)								b1->width = width;
HXDLIN( 396)								b1->height = height;
HXDLIN( 396)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 396)								int size = (b1->length * 4);
HXDLIN( 396)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 396)								{
HXLINE( 396)									int _g8 = 0;
HXDLIN( 396)									int _g9 = b1->length;
HXDLIN( 396)									while((_g8 < _g9)){
HXLINE( 396)										_g8 = (_g8 + 1);
HXDLIN( 396)										int i2 = (_g8 - 1);
HXDLIN( 396)										{
HXLINE( 396)											 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 396)											bool undoImage2;
HXDLIN( 396)											if ((i2 >= 0)) {
HXLINE( 396)												undoImage2 = (i2 < (this3->byteLength >> 2));
            											}
            											else {
HXLINE( 396)												undoImage2 = false;
            											}
HXDLIN( 396)											if (undoImage2) {
HXLINE( 396)												 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 396)												int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN( 396)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 396)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 396)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 396)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 396)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE( 396)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 396)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 396)							{
HXLINE( 396)								v->width = width;
HXDLIN( 396)								v->height = height;
HXDLIN( 396)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 396)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 396)								{
HXLINE( 396)									int _g10 = 0;
HXDLIN( 396)									int _g11 = v->length;
HXDLIN( 396)									while((_g10 < _g11)){
HXLINE( 396)										_g10 = (_g10 + 1);
HXDLIN( 396)										int i3 = (_g10 - 1);
HXDLIN( 396)										v->data->__unsafe_set(i3,0);
            									}
            								}
            							}
HXDLIN( 396)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 396)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 396)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 396)							{
HXLINE( 396)								b2->width = width;
HXDLIN( 396)								b2->height = height;
HXDLIN( 396)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 396)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 396)								{
HXLINE( 396)									int len1 = b2->length;
HXDLIN( 396)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 396)									if (::hx::IsNull( d->head )) {
HXLINE( 396)										int _g12 = 0;
HXDLIN( 396)										int _g13 = len1;
HXDLIN( 396)										while((_g12 < _g13)){
HXLINE( 396)											_g12 = (_g12 + 1);
HXDLIN( 396)											int i4 = (_g12 - 1);
HXDLIN( 396)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 396)										int _g14 = 0;
HXDLIN( 396)										int _g15 = len1;
HXDLIN( 396)										while((_g14 < _g15)){
HXLINE( 396)											_g14 = (_g14 + 1);
HXDLIN( 396)											int i5 = (_g14 - 1);
HXDLIN( 396)											{
HXLINE( 396)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 396)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 396)												{
HXLINE( 396)													int _g16 = 0;
HXDLIN( 396)													int _g17 = i5;
HXDLIN( 396)													while((_g16 < _g17)){
HXLINE( 396)														_g16 = (_g16 + 1);
HXDLIN( 396)														int i6 = (_g16 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 396)												if (::hx::IsNull( prev )) {
HXLINE( 396)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 396)													l = null();
            												}
            												else {
HXLINE( 396)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 396)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 396)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 396)					this2->image = undoImage1;
HXDLIN( 396)					this2->width = width;
HXDLIN( 396)					this2->height = height;
HXDLIN( 396)					this2->imageType = ( (int)(imageType) );
HXDLIN( 396)					undoImage = this2;
HXDLIN( 396)					{
HXLINE( 396)						int rectLeft = xIter3->start;
HXDLIN( 396)						int rectTop = yIter3->start;
HXDLIN( 396)						int rectRight = xIter3->max;
HXDLIN( 396)						bool forceClear = false;
HXDLIN( 396)						{
HXLINE( 396)							int _g18 = rectTop;
HXDLIN( 396)							int _g19 = yIter3->max;
HXDLIN( 396)							while((_g18 < _g19)){
HXLINE( 396)								_g18 = (_g18 + 1);
HXDLIN( 396)								int dy = (_g18 - 1);
HXDLIN( 396)								{
HXLINE( 396)									int _g20 = rectLeft;
HXDLIN( 396)									int _g21 = rectRight;
HXDLIN( 396)									while((_g20 < _g21)){
HXLINE( 396)										_g20 = (_g20 + 1);
HXDLIN( 396)										int dx = (_g20 - 1);
HXDLIN( 396)										::Dynamic this4 = this1->image;
HXDLIN( 396)										int index;
HXDLIN( 396)										if (this1->useVirtualPos) {
HXLINE( 396)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            										}
            										else {
HXLINE( 396)											index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            										}
HXDLIN( 396)										int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 396)										int col;
HXDLIN( 396)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 396)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 396)											col = c;
            										}
HXDLIN( 396)										bool _hx_tmp;
HXDLIN( 396)										if (this1->useMask) {
HXLINE( 396)											_hx_tmp = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE( 396)											_hx_tmp = false;
            										}
HXDLIN( 396)										if (_hx_tmp) {
HXLINE( 396)											 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 396)											::Dynamic this6 = this5->image;
HXDLIN( 396)											int index1;
HXDLIN( 396)											if (this5->useVirtualPos) {
HXLINE( 396)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            											}
            											else {
HXLINE( 396)												index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            											}
HXDLIN( 396)											int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 396)											int v1;
HXDLIN( 396)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 396)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 396)												v1 = c1;
            											}
HXDLIN( 396)											int maskPixel = v1;
HXDLIN( 396)											int this7 = col;
HXDLIN( 396)											if ((maskPixel == 0)) {
HXLINE( 396)												col = this7;
            											}
            											else {
HXLINE( 396)												Float m0;
HXDLIN( 396)												int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 396)												if ((this8 == 0)) {
HXLINE( 396)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float m1;
HXDLIN( 396)												int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 396)												if ((this9 == 0)) {
HXLINE( 396)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float m2;
HXDLIN( 396)												int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 396)												if ((this10 == 0)) {
HXLINE( 396)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float m3;
HXDLIN( 396)												int this11 = (maskPixel & 255);
HXDLIN( 396)												if ((this11 == 0)) {
HXLINE( 396)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 396)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 396)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 396)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 396)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 396)										if ((col != 0)) {
HXLINE( 396)											int x1 = (dx - rectLeft);
HXDLIN( 396)											int y1 = (dy - rectTop);
HXDLIN( 396)											int c2 = col;
HXDLIN( 396)											bool _hx_tmp1;
HXDLIN( 396)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 396)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE( 396)												_hx_tmp1 = false;
            											}
HXDLIN( 396)											if (_hx_tmp1) {
HXLINE( 396)												int location;
HXDLIN( 396)												if (undoImage->useVirtualPos) {
HXLINE( 396)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 396)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 396)												int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 396)												int this13;
HXDLIN( 396)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 396)													this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            												}
            												else {
HXLINE( 396)													this13 = this12;
            												}
HXDLIN( 396)												Float a1;
HXDLIN( 396)												int this14 = ((this13 >> 24) & 255);
HXDLIN( 396)												if ((this14 == 0)) {
HXLINE( 396)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float r1;
HXDLIN( 396)												int this15 = ((this13 >> 16) & 255);
HXDLIN( 396)												if ((this15 == 0)) {
HXLINE( 396)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float g1;
HXDLIN( 396)												int this16 = ((this13 >> 8) & 255);
HXDLIN( 396)												if ((this16 == 0)) {
HXLINE( 396)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float b11;
HXDLIN( 396)												int this17 = (this13 & 255);
HXDLIN( 396)												if ((this17 == 0)) {
HXLINE( 396)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float a2;
HXDLIN( 396)												int this18 = ((col >> 24) & 255);
HXDLIN( 396)												if ((this18 == 0)) {
HXLINE( 396)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float r2;
HXDLIN( 396)												int this19 = ((col >> 16) & 255);
HXDLIN( 396)												if ((this19 == 0)) {
HXLINE( 396)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float g2;
HXDLIN( 396)												int this20 = ((col >> 8) & 255);
HXDLIN( 396)												if ((this20 == 0)) {
HXLINE( 396)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float b21;
HXDLIN( 396)												int this21 = (col & 255);
HXDLIN( 396)												if ((this21 == 0)) {
HXLINE( 396)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 396)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 396)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 396)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 396)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 396)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 396)												{
HXLINE( 396)													int _hx_tmp2;
HXDLIN( 396)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 396)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 396)														_hx_tmp2 = blended;
            													}
HXDLIN( 396)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE( 396)												::Dynamic this22 = undoImage->image;
HXDLIN( 396)												int index2;
HXDLIN( 396)												if (undoImage->useVirtualPos) {
HXLINE( 396)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 396)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 396)												int _hx_tmp3;
HXDLIN( 396)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 396)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 396)													_hx_tmp3 = c2;
            												}
HXDLIN( 396)												::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE( 396)											if (forceClear) {
HXLINE( 396)												::Dynamic this23 = undoImage->image;
HXDLIN( 396)												int x2 = (dx - rectLeft);
HXDLIN( 396)												int y2 = (dy - rectTop);
HXDLIN( 396)												int index3;
HXDLIN( 396)												if (undoImage->useVirtualPos) {
HXLINE( 396)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 396)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 396)												::iterMagic::Iimg_obj::set(this23,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 396)				bool found = false;
HXDLIN( 396)				Float s = ((Float)0.);
HXDLIN( 396)				Float t = ((Float)0.);
HXDLIN( 396)				Float sxx = ((Float)0.);
HXDLIN( 396)				Float txx = ((Float)0.);
HXDLIN( 396)				{
HXLINE( 396)					int _g_min = xIter3->start;
HXDLIN( 396)					int _g_max = xIter3->max;
HXDLIN( 396)					while((_g_min < _g_max)){
HXLINE( 396)						_g_min = (_g_min + 1);
HXDLIN( 396)						int x3 = (_g_min - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)						txx = (tx * ( (Float)(x3) ));
HXLINE(  62)						found = false;
HXLINE( 396)						{
HXLINE( 396)							int _g_min1 = yIter3->start;
HXDLIN( 396)							int _g_max1 = yIter3->max;
HXDLIN( 396)							while((_g_min1 < _g_max1)){
HXLINE( 396)								_g_min1 = (_g_min1 + 1);
HXDLIN( 396)								int y3 = (_g_min1 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 396)								bool _hx_tmp4;
HXDLIN( 396)								if (!((s <= 0))) {
HXLINE( 396)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXLINE( 396)									_hx_tmp4 = true;
            								}
HXDLIN( 396)								if (_hx_tmp4) {
HXLINE( 396)									if (found) {
HXLINE( 396)										goto _hx_goto_739;
            									}
            								}
            								else {
HXLINE( 396)									if (((s + t) < A)) {
HXLINE( 396)										{
HXLINE( 396)											int c3 = color;
HXDLIN( 396)											bool _hx_tmp5;
HXDLIN( 396)											if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 396)												_hx_tmp5 = this1->transparent;
            											}
            											else {
HXLINE( 396)												_hx_tmp5 = false;
            											}
HXDLIN( 396)											if (_hx_tmp5) {
HXLINE( 396)												int location1;
HXDLIN( 396)												if (this1->useVirtualPos) {
HXLINE( 396)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXLINE( 396)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN( 396)												int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 396)												int this25;
HXDLIN( 396)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 396)													this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXLINE( 396)													this25 = this24;
            												}
HXDLIN( 396)												Float a11;
HXDLIN( 396)												int this26 = ((this25 >> 24) & 255);
HXDLIN( 396)												if ((this26 == 0)) {
HXLINE( 396)													a11 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float r11;
HXDLIN( 396)												int this27 = ((this25 >> 16) & 255);
HXDLIN( 396)												if ((this27 == 0)) {
HXLINE( 396)													r11 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float g11;
HXDLIN( 396)												int this28 = ((this25 >> 8) & 255);
HXDLIN( 396)												if ((this28 == 0)) {
HXLINE( 396)													g11 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float b12;
HXDLIN( 396)												int this29 = (this25 & 255);
HXDLIN( 396)												if ((this29 == 0)) {
HXLINE( 396)													b12 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float a21;
HXDLIN( 396)												int this30 = ((color >> 24) & 255);
HXDLIN( 396)												if ((this30 == 0)) {
HXLINE( 396)													a21 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float r21;
HXDLIN( 396)												int this31 = ((color >> 16) & 255);
HXDLIN( 396)												if ((this31 == 0)) {
HXLINE( 396)													r21 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float g21;
HXDLIN( 396)												int this32 = ((color >> 8) & 255);
HXDLIN( 396)												if ((this32 == 0)) {
HXLINE( 396)													g21 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float b22;
HXDLIN( 396)												int this33 = (color & 255);
HXDLIN( 396)												if ((this33 == 0)) {
HXLINE( 396)													b22 = ((Float)0.);
            												}
            												else {
HXLINE( 396)													b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN( 396)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 396)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 396)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 396)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 396)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 396)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 396)												{
HXLINE( 396)													int _hx_tmp6;
HXDLIN( 396)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 396)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE( 396)														_hx_tmp6 = blended1;
            													}
HXDLIN( 396)													::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXLINE( 396)												::Dynamic this34 = this1->image;
HXDLIN( 396)												int index4;
HXDLIN( 396)												if (this1->useVirtualPos) {
HXLINE( 396)													index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXLINE( 396)													index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN( 396)												int _hx_tmp7;
HXDLIN( 396)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 396)													_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXLINE( 396)													_hx_tmp7 = c3;
            												}
HXDLIN( 396)												::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            											}
            										}
HXLINE(  73)										found = true;
            									}
            									else {
HXLINE( 396)										if (found) {
HXLINE( 396)											goto _hx_goto_739;
            										}
            									}
            								}
            							}
            							_hx_goto_739:;
            						}
            					}
            				}
HXDLIN( 396)				 ::pi_xy::algo::HitTri triHit;
HXDLIN( 396)				if ((hasHit == true)) {
HXLINE( 396)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 396)					if (hasUndo) {
HXLINE( 396)						v2->undoImage = undoImage;
HXDLIN( 396)						v2->undoX = xIter3->start;
HXDLIN( 396)						v2->undoY = yIter3->start;
            					}
HXDLIN( 396)					triHit = v2;
            				}
            				else {
HXLINE( 396)					triHit = null();
            				}
HXLINE( 397)				if (hasHit) {
HXLINE( 397)					arrTri[arrTri->length] = triHit;
            				}
HXLINE( 398)				bx = cx;
HXLINE( 399)				by = cy;
            			}
            		}
HXLINE( 402)		currAngle = (startRadian + sweepRadian);
HXLINE( 403)		cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 404)		cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 405)		bool hasUndo1 = false;
HXDLIN( 405)		Float bx2 = bx;
HXDLIN( 405)		Float by2 = by;
HXDLIN( 405)		Float cx2 = cx;
HXDLIN( 405)		Float cy2 = cy;
HXDLIN( 405)		bool adjustWinding1 = (((((ax * by2) - (bx2 * ay)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay) - (ax * cy2))) > 0);
HXDLIN( 405)		if (!(adjustWinding1)) {
HXLINE( 405)			Float bx_1 = bx2;
HXDLIN( 405)			Float by_1 = by2;
HXLINE(  25)			bx2 = cx2;
HXLINE(  26)			by2 = cy2;
HXLINE(  27)			cx2 = bx_1;
HXLINE(  28)			cy2 = by_1;
            		}
HXLINE( 405)		Float s01 = ((ay * cx2) - (ax * cy2));
HXDLIN( 405)		Float sx1 = (cy2 - ay);
HXDLIN( 405)		Float sy1 = (ax - cx2);
HXDLIN( 405)		Float t01 = ((ax * by2) - (ay * bx2));
HXDLIN( 405)		Float tx1 = (ay - by2);
HXDLIN( 405)		Float ty1 = (bx2 - ax);
HXDLIN( 405)		Float A1 = ((((-(by2) * cx2) + (ay * (-(bx2) + cx2))) + (ax * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 405)		 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 405)		if ((ax > bx2)) {
HXLINE( 405)			if ((ax > cx2)) {
HXLINE( 405)				int min4;
HXDLIN( 405)				if ((bx2 > cx2)) {
HXLINE( 405)					min4 = ::Math_obj::floor(cx2);
            				}
            				else {
HXLINE( 405)					min4 = ::Math_obj::floor(bx2);
            				}
HXDLIN( 405)				int ii_min8 = min4;
HXDLIN( 405)				int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 405)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            			}
            			else {
HXLINE( 405)				int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN( 405)				int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 405)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            			}
            		}
            		else {
HXLINE( 405)			if ((bx2 > cx2)) {
HXLINE( 405)				int min5;
HXDLIN( 405)				if ((ax > cx2)) {
HXLINE( 405)					min5 = ::Math_obj::floor(cx2);
            				}
            				else {
HXLINE( 405)					min5 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 405)				int ii_min10 = min5;
HXDLIN( 405)				int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN( 405)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            			}
            			else {
HXLINE( 405)				int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 405)				int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 405)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            			}
            		}
HXDLIN( 405)		 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 405)		if ((ay > by2)) {
HXLINE( 405)			if ((ay > cy2)) {
HXLINE( 405)				int min6;
HXDLIN( 405)				if ((by2 > cy2)) {
HXLINE( 405)					min6 = ::Math_obj::floor(cy2);
            				}
            				else {
HXLINE( 405)					min6 = ::Math_obj::floor(by2);
            				}
HXDLIN( 405)				int ii_min12 = min6;
HXDLIN( 405)				int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 405)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            			}
            			else {
HXLINE( 405)				int ii_min13 = ::Math_obj::floor(by2);
HXDLIN( 405)				int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 405)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            			}
            		}
            		else {
HXLINE( 405)			if ((by2 > cy2)) {
HXLINE( 405)				int min7;
HXDLIN( 405)				if ((ay > cy2)) {
HXLINE( 405)					min7 = ::Math_obj::floor(cy2);
            				}
            				else {
HXLINE( 405)					min7 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 405)				int ii_min14 = min7;
HXDLIN( 405)				int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN( 405)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            			}
            			else {
HXLINE( 405)				int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 405)				int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 405)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            			}
            		}
HXDLIN( 405)		 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 405)		if (hasUndo1) {
HXLINE( 405)			int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 405)			int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 405)			 ::Dynamic imageType1 = null();
HXDLIN( 405)			 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 405)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 405)			::Dynamic undoImage4;
HXDLIN( 405)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXLINE( 405)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 405)					 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 405)					{
HXLINE( 405)						b5->width = width1;
HXDLIN( 405)						b5->height = height1;
HXDLIN( 405)						b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 405)						b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 405)						{
HXLINE( 405)							int len2 = b5->length;
HXDLIN( 405)							int w1 = 0;
HXDLIN( 405)							{
HXLINE( 405)								int _g22 = 0;
HXDLIN( 405)								int _g23 = b5->height;
HXDLIN( 405)								while((_g22 < _g23)){
HXLINE( 405)									_g22 = (_g22 + 1);
HXDLIN( 405)									int y4 = (_g22 - 1);
HXDLIN( 405)									{
HXLINE( 405)										int _g24 = 0;
HXDLIN( 405)										int _g25 = b5->width;
HXDLIN( 405)										while((_g24 < _g25)){
HXLINE( 405)											_g24 = (_g24 + 1);
HXDLIN( 405)											int x4 = (_g24 - 1);
HXDLIN( 405)											{
HXLINE( 405)												w1 = (w1 + 1);
HXDLIN( 405)												b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 405)											{
HXLINE( 405)												w1 = (w1 + 1);
HXDLIN( 405)												b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 405)											{
HXLINE( 405)												w1 = (w1 + 1);
HXDLIN( 405)												b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 405)											{
HXLINE( 405)												w1 = (w1 + 1);
HXDLIN( 405)												b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 405)					undoImage4 = b5;
            				}
            				break;
            				case (int)1: {
HXLINE( 405)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 405)					 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 405)					{
HXLINE( 405)						a6->width = width1;
HXDLIN( 405)						a6->height = height1;
HXDLIN( 405)						a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 405)						a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 405)						{
HXLINE( 405)							int _g26 = 0;
HXDLIN( 405)							int _g27 = a6->length;
HXDLIN( 405)							while((_g26 < _g27)){
HXLINE( 405)								_g26 = (_g26 + 1);
HXDLIN( 405)								int i7 = (_g26 - 1);
HXDLIN( 405)								a6->data[i7] = 0;
            							}
            						}
            					}
HXDLIN( 405)					undoImage4 = a6;
            				}
            				break;
            				case (int)2: {
HXLINE( 405)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 405)					 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 405)					{
HXLINE( 405)						b6->width = width1;
HXDLIN( 405)						b6->height = height1;
HXDLIN( 405)						b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 405)						int size1 = (b6->length * 4);
HXDLIN( 405)						b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 405)						{
HXLINE( 405)							int _g28 = 0;
HXDLIN( 405)							int _g29 = b6->length;
HXDLIN( 405)							while((_g28 < _g29)){
HXLINE( 405)								_g28 = (_g28 + 1);
HXDLIN( 405)								int i8 = (_g28 - 1);
HXDLIN( 405)								{
HXLINE( 405)									 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN( 405)									bool undoImage5;
HXDLIN( 405)									if ((i8 >= 0)) {
HXLINE( 405)										undoImage5 = (i8 < (this36->byteLength >> 2));
            									}
            									else {
HXLINE( 405)										undoImage5 = false;
            									}
HXDLIN( 405)									if (undoImage5) {
HXLINE( 405)										 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 405)										int pos1 = ((i8 << 2) + this36->byteOffset);
HXDLIN( 405)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 405)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 405)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 405)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 405)					undoImage4 = b6;
            				}
            				break;
            				case (int)3: {
HXLINE( 405)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 405)					 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 405)					{
HXLINE( 405)						v3->width = width1;
HXDLIN( 405)						v3->height = height1;
HXDLIN( 405)						v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 405)						v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 405)						{
HXLINE( 405)							int _g30 = 0;
HXDLIN( 405)							int _g31 = v3->length;
HXDLIN( 405)							while((_g30 < _g31)){
HXLINE( 405)								_g30 = (_g30 + 1);
HXDLIN( 405)								int i9 = (_g30 - 1);
HXDLIN( 405)								v3->data->__unsafe_set(i9,0);
            							}
            						}
            					}
HXDLIN( 405)					undoImage4 = v3;
            				}
            				break;
            				case (int)4: {
HXLINE( 405)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 405)					 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 405)					{
HXLINE( 405)						b7->width = width1;
HXDLIN( 405)						b7->height = height1;
HXDLIN( 405)						b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 405)						b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 405)						{
HXLINE( 405)							int len3 = b7->length;
HXDLIN( 405)							 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 405)							if (::hx::IsNull( d1->head )) {
HXLINE( 405)								int _g32 = 0;
HXDLIN( 405)								int _g33 = len3;
HXDLIN( 405)								while((_g32 < _g33)){
HXLINE( 405)									_g32 = (_g32 + 1);
HXDLIN( 405)									int i10 = (_g32 - 1);
HXDLIN( 405)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXLINE( 405)								int _g34 = 0;
HXDLIN( 405)								int _g35 = len3;
HXDLIN( 405)								while((_g34 < _g35)){
HXLINE( 405)									_g34 = (_g34 + 1);
HXDLIN( 405)									int i11 = (_g34 - 1);
HXDLIN( 405)									{
HXLINE( 405)										 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 405)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 405)										{
HXLINE( 405)											int _g36 = 0;
HXDLIN( 405)											int _g37 = i11;
HXDLIN( 405)											while((_g36 < _g37)){
HXLINE( 405)												_g36 = (_g36 + 1);
HXDLIN( 405)												int i12 = (_g36 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE( 405)										if (::hx::IsNull( prev1 )) {
HXLINE( 405)											b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 405)											l1 = null();
            										}
            										else {
HXLINE( 405)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 405)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 405)					undoImage4 = b7;
            				}
            				break;
            			}
HXDLIN( 405)			this35->image = undoImage4;
HXDLIN( 405)			this35->width = width1;
HXDLIN( 405)			this35->height = height1;
HXDLIN( 405)			this35->imageType = ( (int)(imageType1) );
HXDLIN( 405)			undoImage3 = this35;
HXDLIN( 405)			{
HXLINE( 405)				int rectLeft1 = xIter31->start;
HXDLIN( 405)				int rectTop1 = yIter31->start;
HXDLIN( 405)				int rectRight1 = xIter31->max;
HXDLIN( 405)				bool forceClear1 = false;
HXDLIN( 405)				{
HXLINE( 405)					int _g38 = rectTop1;
HXDLIN( 405)					int _g39 = yIter31->max;
HXDLIN( 405)					while((_g38 < _g39)){
HXLINE( 405)						_g38 = (_g38 + 1);
HXDLIN( 405)						int dy1 = (_g38 - 1);
HXDLIN( 405)						{
HXLINE( 405)							int _g40 = rectLeft1;
HXDLIN( 405)							int _g41 = rectRight1;
HXDLIN( 405)							while((_g40 < _g41)){
HXLINE( 405)								_g40 = (_g40 + 1);
HXDLIN( 405)								int dx1 = (_g40 - 1);
HXDLIN( 405)								::Dynamic this37 = this1->image;
HXDLIN( 405)								int index5;
HXDLIN( 405)								if (this1->useVirtualPos) {
HXLINE( 405)									index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            								}
            								else {
HXLINE( 405)									index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            								}
HXDLIN( 405)								int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 405)								int col1;
HXDLIN( 405)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)									col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            								}
            								else {
HXLINE( 405)									col1 = c4;
            								}
HXDLIN( 405)								bool _hx_tmp8;
HXDLIN( 405)								if (this1->useMask) {
HXLINE( 405)									_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE( 405)									_hx_tmp8 = false;
            								}
HXDLIN( 405)								if (_hx_tmp8) {
HXLINE( 405)									 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN( 405)									::Dynamic this39 = this38->image;
HXDLIN( 405)									int index6;
HXDLIN( 405)									if (this38->useVirtualPos) {
HXLINE( 405)										index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx1) - this38->virtualX));
            									}
            									else {
HXLINE( 405)										index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this38->width) + dx1)) ));
            									}
HXDLIN( 405)									int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 405)									int v4;
HXDLIN( 405)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)										v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            									}
            									else {
HXLINE( 405)										v4 = c5;
            									}
HXDLIN( 405)									int maskPixel1 = v4;
HXDLIN( 405)									int this40 = col1;
HXDLIN( 405)									if ((maskPixel1 == 0)) {
HXLINE( 405)										col1 = this40;
            									}
            									else {
HXLINE( 405)										Float m01;
HXDLIN( 405)										int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 405)										if ((this41 == 0)) {
HXLINE( 405)											m01 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float m11;
HXDLIN( 405)										int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 405)										if ((this42 == 0)) {
HXLINE( 405)											m11 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float m21;
HXDLIN( 405)										int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 405)										if ((this43 == 0)) {
HXLINE( 405)											m21 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float m31;
HXDLIN( 405)										int this44 = (maskPixel1 & 255);
HXDLIN( 405)										if ((this44 == 0)) {
HXLINE( 405)											m31 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 405)										int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 405)										int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 405)										int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 405)										col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 405)								if ((col1 != 0)) {
HXLINE( 405)									int x5 = (dx1 - rectLeft1);
HXDLIN( 405)									int y5 = (dy1 - rectTop1);
HXDLIN( 405)									int c6 = col1;
HXDLIN( 405)									bool _hx_tmp9;
HXDLIN( 405)									if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 405)										_hx_tmp9 = undoImage3->transparent;
            									}
            									else {
HXLINE( 405)										_hx_tmp9 = false;
            									}
HXDLIN( 405)									if (_hx_tmp9) {
HXLINE( 405)										int location2;
HXDLIN( 405)										if (undoImage3->useVirtualPos) {
HXLINE( 405)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 405)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            										}
HXDLIN( 405)										int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 405)										int this46;
HXDLIN( 405)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)											this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            										}
            										else {
HXLINE( 405)											this46 = this45;
            										}
HXDLIN( 405)										Float a12;
HXDLIN( 405)										int this47 = ((this46 >> 24) & 255);
HXDLIN( 405)										if ((this47 == 0)) {
HXLINE( 405)											a12 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float r12;
HXDLIN( 405)										int this48 = ((this46 >> 16) & 255);
HXDLIN( 405)										if ((this48 == 0)) {
HXLINE( 405)											r12 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float g12;
HXDLIN( 405)										int this49 = ((this46 >> 8) & 255);
HXDLIN( 405)										if ((this49 == 0)) {
HXLINE( 405)											g12 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float b13;
HXDLIN( 405)										int this50 = (this46 & 255);
HXDLIN( 405)										if ((this50 == 0)) {
HXLINE( 405)											b13 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float a22;
HXDLIN( 405)										int this51 = ((col1 >> 24) & 255);
HXDLIN( 405)										if ((this51 == 0)) {
HXLINE( 405)											a22 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float r22;
HXDLIN( 405)										int this52 = ((col1 >> 16) & 255);
HXDLIN( 405)										if ((this52 == 0)) {
HXLINE( 405)											r22 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float g22;
HXDLIN( 405)										int this53 = ((col1 >> 8) & 255);
HXDLIN( 405)										if ((this53 == 0)) {
HXLINE( 405)											g22 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float b23;
HXDLIN( 405)										int this54 = (col1 & 255);
HXDLIN( 405)										if ((this54 == 0)) {
HXLINE( 405)											b23 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 405)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 405)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 405)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 405)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 405)										int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 405)										{
HXLINE( 405)											int _hx_tmp10;
HXDLIN( 405)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)												_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE( 405)												_hx_tmp10 = blended2;
            											}
HXDLIN( 405)											::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            										}
            									}
            									else {
HXLINE( 405)										::Dynamic this55 = undoImage3->image;
HXDLIN( 405)										int index7;
HXDLIN( 405)										if (undoImage3->useVirtualPos) {
HXLINE( 405)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 405)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            										}
HXDLIN( 405)										int _hx_tmp11;
HXDLIN( 405)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)											_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXLINE( 405)											_hx_tmp11 = c6;
            										}
HXDLIN( 405)										::iterMagic::Iimg_obj::set(this55,index7,_hx_tmp11);
            									}
            								}
            								else {
HXLINE( 405)									if (forceClear1) {
HXLINE( 405)										::Dynamic this56 = undoImage3->image;
HXDLIN( 405)										int x6 = (dx1 - rectLeft1);
HXDLIN( 405)										int y6 = (dy1 - rectTop1);
HXDLIN( 405)										int index8;
HXDLIN( 405)										if (undoImage3->useVirtualPos) {
HXLINE( 405)											index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 405)											index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            										}
HXDLIN( 405)										::iterMagic::Iimg_obj::set(this56,index8,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 405)		bool found1 = false;
HXDLIN( 405)		Float s1 = ((Float)0.);
HXDLIN( 405)		Float t1 = ((Float)0.);
HXDLIN( 405)		Float sxx1 = ((Float)0.);
HXDLIN( 405)		Float txx1 = ((Float)0.);
HXDLIN( 405)		{
HXLINE( 405)			int _g_min2 = xIter31->start;
HXDLIN( 405)			int _g_max2 = xIter31->max;
HXDLIN( 405)			while((_g_min2 < _g_max2)){
HXLINE( 405)				_g_min2 = (_g_min2 + 1);
HXDLIN( 405)				int x7 = (_g_min2 - 1);
HXLINE(  60)				sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)				txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)				found1 = false;
HXLINE( 405)				{
HXLINE( 405)					int _g_min3 = yIter31->start;
HXDLIN( 405)					int _g_max3 = yIter31->max;
HXDLIN( 405)					while((_g_min3 < _g_max3)){
HXLINE( 405)						_g_min3 = (_g_min3 + 1);
HXDLIN( 405)						int y7 = (_g_min3 - 1);
HXLINE(  64)						s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)						t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 405)						bool _hx_tmp12;
HXDLIN( 405)						if (!((s1 <= 0))) {
HXLINE( 405)							_hx_tmp12 = (t1 <= 0);
            						}
            						else {
HXLINE( 405)							_hx_tmp12 = true;
            						}
HXDLIN( 405)						if (_hx_tmp12) {
HXLINE( 405)							if (found1) {
HXLINE( 405)								goto _hx_goto_751;
            							}
            						}
            						else {
HXLINE( 405)							if (((s1 + t1) < A1)) {
HXLINE( 405)								{
HXLINE( 405)									int c7 = color;
HXDLIN( 405)									bool _hx_tmp13;
HXDLIN( 405)									if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 405)										_hx_tmp13 = this1->transparent;
            									}
            									else {
HXLINE( 405)										_hx_tmp13 = false;
            									}
HXDLIN( 405)									if (_hx_tmp13) {
HXLINE( 405)										int location3;
HXDLIN( 405)										if (this1->useVirtualPos) {
HXLINE( 405)											location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            										}
            										else {
HXLINE( 405)											location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            										}
HXDLIN( 405)										int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 405)										int this58;
HXDLIN( 405)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)											this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            										}
            										else {
HXLINE( 405)											this58 = this57;
            										}
HXDLIN( 405)										Float a13;
HXDLIN( 405)										int this59 = ((this58 >> 24) & 255);
HXDLIN( 405)										if ((this59 == 0)) {
HXLINE( 405)											a13 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											a13 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float r13;
HXDLIN( 405)										int this60 = ((this58 >> 16) & 255);
HXDLIN( 405)										if ((this60 == 0)) {
HXLINE( 405)											r13 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float g13;
HXDLIN( 405)										int this61 = ((this58 >> 8) & 255);
HXDLIN( 405)										if ((this61 == 0)) {
HXLINE( 405)											g13 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float b14;
HXDLIN( 405)										int this62 = (this58 & 255);
HXDLIN( 405)										if ((this62 == 0)) {
HXLINE( 405)											b14 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float a23;
HXDLIN( 405)										int this63 = ((color >> 24) & 255);
HXDLIN( 405)										if ((this63 == 0)) {
HXLINE( 405)											a23 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float r23;
HXDLIN( 405)										int this64 = ((color >> 16) & 255);
HXDLIN( 405)										if ((this64 == 0)) {
HXLINE( 405)											r23 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float g23;
HXDLIN( 405)										int this65 = ((color >> 8) & 255);
HXDLIN( 405)										if ((this65 == 0)) {
HXLINE( 405)											g23 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float b24;
HXDLIN( 405)										int this66 = (color & 255);
HXDLIN( 405)										if ((this66 == 0)) {
HXLINE( 405)											b24 = ((Float)0.);
            										}
            										else {
HXLINE( 405)											b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 405)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 405)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 405)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 405)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 405)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 405)										int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 405)										{
HXLINE( 405)											int _hx_tmp14;
HXDLIN( 405)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)												_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE( 405)												_hx_tmp14 = blended3;
            											}
HXDLIN( 405)											::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            										}
            									}
            									else {
HXLINE( 405)										::Dynamic this67 = this1->image;
HXDLIN( 405)										int index9;
HXDLIN( 405)										if (this1->useVirtualPos) {
HXLINE( 405)											index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            										}
            										else {
HXLINE( 405)											index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            										}
HXDLIN( 405)										int _hx_tmp15;
HXDLIN( 405)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 405)											_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE( 405)											_hx_tmp15 = c7;
            										}
HXDLIN( 405)										::iterMagic::Iimg_obj::set(this67,index9,_hx_tmp15);
            									}
            								}
HXLINE(  73)								found1 = true;
            							}
            							else {
HXLINE( 405)								if (found1) {
HXLINE( 405)									goto _hx_goto_751;
            								}
            							}
            						}
            					}
            					_hx_goto_751:;
            				}
            			}
            		}
HXDLIN( 405)		 ::pi_xy::algo::HitTri triHit1;
HXDLIN( 405)		if ((hasHit == true)) {
HXLINE( 405)			 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx2,by2,cx2,cy2,true);
HXDLIN( 405)			if (hasUndo1) {
HXLINE( 405)				v5->undoImage = undoImage3;
HXDLIN( 405)				v5->undoX = xIter31->start;
HXDLIN( 405)				v5->undoY = yIter31->start;
            			}
HXDLIN( 405)			triHit1 = v5;
            		}
            		else {
HXLINE( 405)			triHit1 = null();
            		}
HXLINE( 406)		if (hasHit) {
HXLINE( 406)			arrTri[arrTri->length] = triHit1;
            		}
HXLINE( 407)		if (hasHit) {
HXLINE( 408)			return  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,arrTri);
            		}
            		else {
HXLINE( 410)			arrTri = null();
HXLINE( 411)			return null();
            		}
HXLINE( 407)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(FillShape_Impl__obj,pie,return )

 ::pi_xy::algo::HitTri FillShape_Impl__obj::sweepTri( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float rx,Float ry,Float startRadian,Float sweepRadian,int color,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_419_sweepTri)
HXLINE( 420)		Float currAngle = startRadian;
HXLINE( 421)		Float bx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 422)		Float by = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 424)		currAngle = (startRadian + sweepRadian);
HXLINE( 425)		Float cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 426)		Float cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 427)		bool hasUndo = false;
HXDLIN( 427)		Float bx1 = bx;
HXDLIN( 427)		Float by1 = by;
HXDLIN( 427)		Float cx1 = cx;
HXDLIN( 427)		Float cy1 = cy;
HXDLIN( 427)		bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 427)		if (!(adjustWinding)) {
HXLINE( 427)			Float bx_ = bx1;
HXDLIN( 427)			Float by_ = by1;
HXLINE(  25)			bx1 = cx1;
HXLINE(  26)			by1 = cy1;
HXLINE(  27)			cx1 = bx_;
HXLINE(  28)			cy1 = by_;
            		}
HXLINE( 427)		Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 427)		Float sx = (cy1 - ay);
HXDLIN( 427)		Float sy = (ax - cx1);
HXDLIN( 427)		Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 427)		Float tx = (ay - by1);
HXDLIN( 427)		Float ty = (bx1 - ax);
HXDLIN( 427)		Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 427)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 427)		if ((ax > bx1)) {
HXLINE( 427)			if ((ax > cx1)) {
HXLINE( 427)				int min;
HXDLIN( 427)				if ((bx1 > cx1)) {
HXLINE( 427)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXLINE( 427)					min = ::Math_obj::floor(bx1);
            				}
HXDLIN( 427)				int ii_min = min;
HXDLIN( 427)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 427)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 427)				int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 427)				int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 427)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 427)			if ((bx1 > cx1)) {
HXLINE( 427)				int min1;
HXDLIN( 427)				if ((ax > cx1)) {
HXLINE( 427)					min1 = ::Math_obj::floor(cx1);
            				}
            				else {
HXLINE( 427)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 427)				int ii_min2 = min1;
HXDLIN( 427)				int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 427)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 427)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 427)				int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 427)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 427)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 427)		if ((ay > by1)) {
HXLINE( 427)			if ((ay > cy1)) {
HXLINE( 427)				int min2;
HXDLIN( 427)				if ((by1 > cy1)) {
HXLINE( 427)					min2 = ::Math_obj::floor(cy1);
            				}
            				else {
HXLINE( 427)					min2 = ::Math_obj::floor(by1);
            				}
HXDLIN( 427)				int ii_min4 = min2;
HXDLIN( 427)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 427)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 427)				int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 427)				int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 427)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 427)			if ((by1 > cy1)) {
HXLINE( 427)				int min3;
HXDLIN( 427)				if ((ay > cy1)) {
HXLINE( 427)					min3 = ::Math_obj::floor(cy1);
            				}
            				else {
HXLINE( 427)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 427)				int ii_min6 = min3;
HXDLIN( 427)				int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 427)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 427)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 427)				int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 427)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 427)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 427)		if (hasUndo) {
HXLINE( 427)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 427)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 427)			 ::Dynamic imageType = null();
HXDLIN( 427)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 427)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 427)			::Dynamic undoImage1;
HXDLIN( 427)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 427)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 427)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 427)					{
HXLINE( 427)						b->width = width;
HXDLIN( 427)						b->height = height;
HXDLIN( 427)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 427)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 427)						{
HXLINE( 427)							int len = b->length;
HXDLIN( 427)							int w = 0;
HXDLIN( 427)							{
HXLINE( 427)								int _g = 0;
HXDLIN( 427)								int _g1 = b->height;
HXDLIN( 427)								while((_g < _g1)){
HXLINE( 427)									_g = (_g + 1);
HXDLIN( 427)									int y = (_g - 1);
HXDLIN( 427)									{
HXLINE( 427)										int _g2 = 0;
HXDLIN( 427)										int _g3 = b->width;
HXDLIN( 427)										while((_g2 < _g3)){
HXLINE( 427)											_g2 = (_g2 + 1);
HXDLIN( 427)											int x = (_g2 - 1);
HXDLIN( 427)											{
HXLINE( 427)												w = (w + 1);
HXDLIN( 427)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 427)											{
HXLINE( 427)												w = (w + 1);
HXDLIN( 427)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 427)											{
HXLINE( 427)												w = (w + 1);
HXDLIN( 427)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 427)											{
HXLINE( 427)												w = (w + 1);
HXDLIN( 427)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 427)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 427)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 427)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 427)					{
HXLINE( 427)						a->width = width;
HXDLIN( 427)						a->height = height;
HXDLIN( 427)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 427)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 427)						{
HXLINE( 427)							int _g4 = 0;
HXDLIN( 427)							int _g5 = a->length;
HXDLIN( 427)							while((_g4 < _g5)){
HXLINE( 427)								_g4 = (_g4 + 1);
HXDLIN( 427)								int i = (_g4 - 1);
HXDLIN( 427)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 427)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 427)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 427)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 427)					{
HXLINE( 427)						b1->width = width;
HXDLIN( 427)						b1->height = height;
HXDLIN( 427)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 427)						int size = (b1->length * 4);
HXDLIN( 427)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 427)						{
HXLINE( 427)							int _g6 = 0;
HXDLIN( 427)							int _g7 = b1->length;
HXDLIN( 427)							while((_g6 < _g7)){
HXLINE( 427)								_g6 = (_g6 + 1);
HXDLIN( 427)								int i1 = (_g6 - 1);
HXDLIN( 427)								{
HXLINE( 427)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 427)									bool undoImage2;
HXDLIN( 427)									if ((i1 >= 0)) {
HXLINE( 427)										undoImage2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXLINE( 427)										undoImage2 = false;
            									}
HXDLIN( 427)									if (undoImage2) {
HXLINE( 427)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 427)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 427)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 427)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 427)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 427)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 427)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 427)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 427)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 427)					{
HXLINE( 427)						v->width = width;
HXDLIN( 427)						v->height = height;
HXDLIN( 427)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 427)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 427)						{
HXLINE( 427)							int _g8 = 0;
HXDLIN( 427)							int _g9 = v->length;
HXDLIN( 427)							while((_g8 < _g9)){
HXLINE( 427)								_g8 = (_g8 + 1);
HXDLIN( 427)								int i2 = (_g8 - 1);
HXDLIN( 427)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 427)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 427)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 427)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 427)					{
HXLINE( 427)						b2->width = width;
HXDLIN( 427)						b2->height = height;
HXDLIN( 427)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 427)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 427)						{
HXLINE( 427)							int len1 = b2->length;
HXDLIN( 427)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 427)							if (::hx::IsNull( d->head )) {
HXLINE( 427)								int _g10 = 0;
HXDLIN( 427)								int _g11 = len1;
HXDLIN( 427)								while((_g10 < _g11)){
HXLINE( 427)									_g10 = (_g10 + 1);
HXDLIN( 427)									int i3 = (_g10 - 1);
HXDLIN( 427)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 427)								int _g12 = 0;
HXDLIN( 427)								int _g13 = len1;
HXDLIN( 427)								while((_g12 < _g13)){
HXLINE( 427)									_g12 = (_g12 + 1);
HXDLIN( 427)									int i4 = (_g12 - 1);
HXDLIN( 427)									{
HXLINE( 427)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 427)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 427)										{
HXLINE( 427)											int _g14 = 0;
HXDLIN( 427)											int _g15 = i4;
HXDLIN( 427)											while((_g14 < _g15)){
HXLINE( 427)												_g14 = (_g14 + 1);
HXDLIN( 427)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 427)										if (::hx::IsNull( prev )) {
HXLINE( 427)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 427)											l = null();
            										}
            										else {
HXLINE( 427)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 427)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 427)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 427)			this2->image = undoImage1;
HXDLIN( 427)			this2->width = width;
HXDLIN( 427)			this2->height = height;
HXDLIN( 427)			this2->imageType = ( (int)(imageType) );
HXDLIN( 427)			undoImage = this2;
HXDLIN( 427)			{
HXLINE( 427)				int rectLeft = xIter3->start;
HXDLIN( 427)				int rectTop = yIter3->start;
HXDLIN( 427)				int rectRight = xIter3->max;
HXDLIN( 427)				bool forceClear = false;
HXDLIN( 427)				{
HXLINE( 427)					int _g16 = rectTop;
HXDLIN( 427)					int _g17 = yIter3->max;
HXDLIN( 427)					while((_g16 < _g17)){
HXLINE( 427)						_g16 = (_g16 + 1);
HXDLIN( 427)						int dy = (_g16 - 1);
HXDLIN( 427)						{
HXLINE( 427)							int _g18 = rectLeft;
HXDLIN( 427)							int _g19 = rectRight;
HXDLIN( 427)							while((_g18 < _g19)){
HXLINE( 427)								_g18 = (_g18 + 1);
HXDLIN( 427)								int dx = (_g18 - 1);
HXDLIN( 427)								::Dynamic this4 = this1->image;
HXDLIN( 427)								int index;
HXDLIN( 427)								if (this1->useVirtualPos) {
HXLINE( 427)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE( 427)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN( 427)								int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 427)								int col;
HXDLIN( 427)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 427)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 427)									col = c;
            								}
HXDLIN( 427)								bool _hx_tmp;
HXDLIN( 427)								if (this1->useMask) {
HXLINE( 427)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE( 427)									_hx_tmp = false;
            								}
HXDLIN( 427)								if (_hx_tmp) {
HXLINE( 427)									 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 427)									::Dynamic this6 = this5->image;
HXDLIN( 427)									int index1;
HXDLIN( 427)									if (this5->useVirtualPos) {
HXLINE( 427)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            									}
            									else {
HXLINE( 427)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            									}
HXDLIN( 427)									int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 427)									int v1;
HXDLIN( 427)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 427)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 427)										v1 = c1;
            									}
HXDLIN( 427)									int maskPixel = v1;
HXDLIN( 427)									int this7 = col;
HXDLIN( 427)									if ((maskPixel == 0)) {
HXLINE( 427)										col = this7;
            									}
            									else {
HXLINE( 427)										Float m0;
HXDLIN( 427)										int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 427)										if ((this8 == 0)) {
HXLINE( 427)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float m1;
HXDLIN( 427)										int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 427)										if ((this9 == 0)) {
HXLINE( 427)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float m2;
HXDLIN( 427)										int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 427)										if ((this10 == 0)) {
HXLINE( 427)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float m3;
HXDLIN( 427)										int this11 = (maskPixel & 255);
HXDLIN( 427)										if ((this11 == 0)) {
HXLINE( 427)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 427)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 427)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 427)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 427)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 427)								if ((col != 0)) {
HXLINE( 427)									int x1 = (dx - rectLeft);
HXDLIN( 427)									int y1 = (dy - rectTop);
HXDLIN( 427)									int c2 = col;
HXDLIN( 427)									bool _hx_tmp1;
HXDLIN( 427)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 427)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 427)										_hx_tmp1 = false;
            									}
HXDLIN( 427)									if (_hx_tmp1) {
HXLINE( 427)										int location;
HXDLIN( 427)										if (undoImage->useVirtualPos) {
HXLINE( 427)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 427)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 427)										int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 427)										int this13;
HXDLIN( 427)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 427)											this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            										}
            										else {
HXLINE( 427)											this13 = this12;
            										}
HXDLIN( 427)										Float a1;
HXDLIN( 427)										int this14 = ((this13 >> 24) & 255);
HXDLIN( 427)										if ((this14 == 0)) {
HXLINE( 427)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float r1;
HXDLIN( 427)										int this15 = ((this13 >> 16) & 255);
HXDLIN( 427)										if ((this15 == 0)) {
HXLINE( 427)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float g1;
HXDLIN( 427)										int this16 = ((this13 >> 8) & 255);
HXDLIN( 427)										if ((this16 == 0)) {
HXLINE( 427)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float b11;
HXDLIN( 427)										int this17 = (this13 & 255);
HXDLIN( 427)										if ((this17 == 0)) {
HXLINE( 427)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float a2;
HXDLIN( 427)										int this18 = ((col >> 24) & 255);
HXDLIN( 427)										if ((this18 == 0)) {
HXLINE( 427)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float r2;
HXDLIN( 427)										int this19 = ((col >> 16) & 255);
HXDLIN( 427)										if ((this19 == 0)) {
HXLINE( 427)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float g2;
HXDLIN( 427)										int this20 = ((col >> 8) & 255);
HXDLIN( 427)										if ((this20 == 0)) {
HXLINE( 427)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float b21;
HXDLIN( 427)										int this21 = (col & 255);
HXDLIN( 427)										if ((this21 == 0)) {
HXLINE( 427)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 427)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 427)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 427)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 427)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 427)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 427)										{
HXLINE( 427)											int _hx_tmp2;
HXDLIN( 427)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 427)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 427)												_hx_tmp2 = blended;
            											}
HXDLIN( 427)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 427)										::Dynamic this22 = undoImage->image;
HXDLIN( 427)										int index2;
HXDLIN( 427)										if (undoImage->useVirtualPos) {
HXLINE( 427)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 427)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 427)										int _hx_tmp3;
HXDLIN( 427)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 427)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 427)											_hx_tmp3 = c2;
            										}
HXDLIN( 427)										::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 427)									if (forceClear) {
HXLINE( 427)										::Dynamic this23 = undoImage->image;
HXDLIN( 427)										int x2 = (dx - rectLeft);
HXDLIN( 427)										int y2 = (dy - rectTop);
HXDLIN( 427)										int index3;
HXDLIN( 427)										if (undoImage->useVirtualPos) {
HXLINE( 427)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 427)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 427)										::iterMagic::Iimg_obj::set(this23,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 427)		bool found = false;
HXDLIN( 427)		Float s = ((Float)0.);
HXDLIN( 427)		Float t = ((Float)0.);
HXDLIN( 427)		Float sxx = ((Float)0.);
HXDLIN( 427)		Float txx = ((Float)0.);
HXDLIN( 427)		{
HXLINE( 427)			int _g_min = xIter3->start;
HXDLIN( 427)			int _g_max = xIter3->max;
HXDLIN( 427)			while((_g_min < _g_max)){
HXLINE( 427)				_g_min = (_g_min + 1);
HXDLIN( 427)				int x3 = (_g_min - 1);
HXLINE(  60)				sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)				txx = (tx * ( (Float)(x3) ));
HXLINE(  62)				found = false;
HXLINE( 427)				{
HXLINE( 427)					int _g_min1 = yIter3->start;
HXDLIN( 427)					int _g_max1 = yIter3->max;
HXDLIN( 427)					while((_g_min1 < _g_max1)){
HXLINE( 427)						_g_min1 = (_g_min1 + 1);
HXDLIN( 427)						int y3 = (_g_min1 - 1);
HXLINE(  64)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 427)						bool _hx_tmp4;
HXDLIN( 427)						if (!((s <= 0))) {
HXLINE( 427)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXLINE( 427)							_hx_tmp4 = true;
            						}
HXDLIN( 427)						if (_hx_tmp4) {
HXLINE( 427)							if (found) {
HXLINE( 427)								goto _hx_goto_764;
            							}
            						}
            						else {
HXLINE( 427)							if (((s + t) < A)) {
HXLINE( 427)								{
HXLINE( 427)									int c3 = color;
HXDLIN( 427)									bool _hx_tmp5;
HXDLIN( 427)									if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 427)										_hx_tmp5 = this1->transparent;
            									}
            									else {
HXLINE( 427)										_hx_tmp5 = false;
            									}
HXDLIN( 427)									if (_hx_tmp5) {
HXLINE( 427)										int location1;
HXDLIN( 427)										if (this1->useVirtualPos) {
HXLINE( 427)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXLINE( 427)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN( 427)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 427)										int this25;
HXDLIN( 427)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 427)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXLINE( 427)											this25 = this24;
            										}
HXDLIN( 427)										Float a11;
HXDLIN( 427)										int this26 = ((this25 >> 24) & 255);
HXDLIN( 427)										if ((this26 == 0)) {
HXLINE( 427)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float r11;
HXDLIN( 427)										int this27 = ((this25 >> 16) & 255);
HXDLIN( 427)										if ((this27 == 0)) {
HXLINE( 427)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float g11;
HXDLIN( 427)										int this28 = ((this25 >> 8) & 255);
HXDLIN( 427)										if ((this28 == 0)) {
HXLINE( 427)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float b12;
HXDLIN( 427)										int this29 = (this25 & 255);
HXDLIN( 427)										if ((this29 == 0)) {
HXLINE( 427)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float a21;
HXDLIN( 427)										int this30 = ((color >> 24) & 255);
HXDLIN( 427)										if ((this30 == 0)) {
HXLINE( 427)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float r21;
HXDLIN( 427)										int this31 = ((color >> 16) & 255);
HXDLIN( 427)										if ((this31 == 0)) {
HXLINE( 427)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float g21;
HXDLIN( 427)										int this32 = ((color >> 8) & 255);
HXDLIN( 427)										if ((this32 == 0)) {
HXLINE( 427)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float b22;
HXDLIN( 427)										int this33 = (color & 255);
HXDLIN( 427)										if ((this33 == 0)) {
HXLINE( 427)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 427)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 427)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 427)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 427)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 427)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 427)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 427)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 427)										{
HXLINE( 427)											int _hx_tmp6;
HXDLIN( 427)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 427)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 427)												_hx_tmp6 = blended1;
            											}
HXDLIN( 427)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXLINE( 427)										::Dynamic this34 = this1->image;
HXDLIN( 427)										int index4;
HXDLIN( 427)										if (this1->useVirtualPos) {
HXLINE( 427)											index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXLINE( 427)											index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN( 427)										int _hx_tmp7;
HXDLIN( 427)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 427)											_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE( 427)											_hx_tmp7 = c3;
            										}
HXDLIN( 427)										::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            									}
            								}
HXLINE(  73)								found = true;
            							}
            							else {
HXLINE( 427)								if (found) {
HXLINE( 427)									goto _hx_goto_764;
            								}
            							}
            						}
            					}
            					_hx_goto_764:;
            				}
            			}
            		}
HXDLIN( 427)		if ((hasHit == true)) {
HXLINE( 427)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 427)			if (hasUndo) {
HXLINE( 427)				v2->undoImage = undoImage;
HXDLIN( 427)				v2->undoX = xIter3->start;
HXDLIN( 427)				v2->undoY = yIter3->start;
            			}
HXDLIN( 427)			return v2;
            		}
            		else {
HXLINE( 427)			return null();
            		}
HXDLIN( 427)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FillShape_Impl__obj,sweepTri,return )

void FillShape_Impl__obj::lineGrid( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,Float delta,Float thick,int color){
            	HX_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_434_lineGrid)
HXLINE( 435)		Float h_ = (( (Float)(::Math_obj::floor((h / delta))) ) * delta);
HXLINE( 436)		Float w_ = (( (Float)(::Math_obj::floor((w / delta))) ) * delta);
HXLINE( 437)		{
HXLINE( 437)			int _g = 0;
HXDLIN( 437)			int _g1 = (::Math_obj::floor((w / delta)) + 1);
HXDLIN( 437)			while((_g < _g1)){
HXLINE( 437)				_g = (_g + 1);
HXDLIN( 437)				int i = (_g - 1);
HXLINE( 438)				{
HXLINE( 438)					int r_x = ::Std_obj::_hx_int(((x + (( (Float)(i) ) * delta)) - (thick / ( (Float)(2) ))));
HXDLIN( 438)					int r_y = ::Std_obj::_hx_int(y);
HXDLIN( 438)					int r_w = ::Std_obj::_hx_int(thick);
HXDLIN( 438)					int r_h = ::Std_obj::_hx_int(h_);
HXDLIN( 438)					int xmax = ((r_x + r_w) + 1);
HXDLIN( 438)					int ymax = ((r_y + r_h) + 1);
HXDLIN( 438)					int ii_min = r_x;
HXDLIN( 438)					int ii_max = xmax;
HXDLIN( 438)					int xRange__start = ii_min;
HXDLIN( 438)					int xRange__max = ii_max;
HXDLIN( 438)					int ii_min1 = r_y;
HXDLIN( 438)					int ii_max1 = ymax;
HXDLIN( 438)					int yRange__start = ii_min1;
HXDLIN( 438)					int yRange__max = ii_max1;
HXDLIN( 438)					int range_x = xRange__start;
HXDLIN( 438)					int range_y = (yRange__start - 1);
HXDLIN( 438)					int range_xReset = range_x;
HXDLIN( 438)					int range_yReset = range_y;
HXDLIN( 438)					int range_xMax = (xRange__max - 2);
HXDLIN( 438)					int range_yMax = (yRange__max - 2);
HXDLIN( 438)					int _this_min = 0;
HXDLIN( 438)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 438)					while((_this_min < _this_max)){
HXLINE( 438)						_this_min = (_this_min + 1);
HXDLIN( 438)						int i1 = (_this_min - 1);
HXDLIN( 438)						if ((range_y > range_yMax)) {
HXLINE( 438)							range_y = range_yReset;
HXDLIN( 438)							range_x = (range_x + 1);
            						}
HXDLIN( 438)						range_y = (range_y + 1);
HXDLIN( 438)						int i2 = i1;
HXDLIN( 438)						{
HXLINE( 438)							int x1 = range_x;
HXDLIN( 438)							int y1 = range_y;
HXDLIN( 438)							int c = color;
HXDLIN( 438)							bool _hx_tmp;
HXDLIN( 438)							if ((((c >> 24) & 255) < 254)) {
HXLINE( 438)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE( 438)								_hx_tmp = false;
            							}
HXDLIN( 438)							if (_hx_tmp) {
HXLINE( 438)								int location;
HXDLIN( 438)								if (this1->useVirtualPos) {
HXLINE( 438)									location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            								}
            								else {
HXLINE( 438)									location = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            								}
HXDLIN( 438)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 438)								int this3;
HXDLIN( 438)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 438)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE( 438)									this3 = this2;
            								}
HXDLIN( 438)								Float a1;
HXDLIN( 438)								int this4 = ((this3 >> 24) & 255);
HXDLIN( 438)								if ((this4 == 0)) {
HXLINE( 438)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 438)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN( 438)								Float r1;
HXDLIN( 438)								int this5 = ((this3 >> 16) & 255);
HXDLIN( 438)								if ((this5 == 0)) {
HXLINE( 438)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 438)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 438)								Float g1;
HXDLIN( 438)								int this6 = ((this3 >> 8) & 255);
HXDLIN( 438)								if ((this6 == 0)) {
HXLINE( 438)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 438)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 438)								Float b1;
HXDLIN( 438)								int this7 = (this3 & 255);
HXDLIN( 438)								if ((this7 == 0)) {
HXLINE( 438)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 438)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 438)								Float a2;
HXDLIN( 438)								int this8 = ((color >> 24) & 255);
HXDLIN( 438)								if ((this8 == 0)) {
HXLINE( 438)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 438)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 438)								Float r2;
HXDLIN( 438)								int this9 = ((color >> 16) & 255);
HXDLIN( 438)								if ((this9 == 0)) {
HXLINE( 438)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 438)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 438)								Float g2;
HXDLIN( 438)								int this10 = ((color >> 8) & 255);
HXDLIN( 438)								if ((this10 == 0)) {
HXLINE( 438)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 438)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 438)								Float b2;
HXDLIN( 438)								int this11 = (color & 255);
HXDLIN( 438)								if ((this11 == 0)) {
HXLINE( 438)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 438)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 438)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 438)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 438)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 438)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 438)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 438)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 438)								{
HXLINE( 438)									int _hx_tmp1;
HXDLIN( 438)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 438)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 438)										_hx_tmp1 = blended;
            									}
HXDLIN( 438)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE( 438)								::Dynamic this12 = this1->image;
HXDLIN( 438)								int index;
HXDLIN( 438)								if (this1->useVirtualPos) {
HXLINE( 438)									index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            								}
            								else {
HXLINE( 438)									index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            								}
HXDLIN( 438)								int _hx_tmp2;
HXDLIN( 438)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 438)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 438)									_hx_tmp2 = c;
            								}
HXDLIN( 438)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 440)		{
HXLINE( 440)			int _g2 = 0;
HXDLIN( 440)			int _g3 = (::Math_obj::floor((h / delta)) + 1);
HXDLIN( 440)			while((_g2 < _g3)){
HXLINE( 440)				_g2 = (_g2 + 1);
HXDLIN( 440)				int i3 = (_g2 - 1);
HXLINE( 441)				{
HXLINE( 441)					int r_x1 = ::Std_obj::_hx_int(x);
HXDLIN( 441)					int r_y1 = ::Std_obj::_hx_int(((y + (( (Float)(i3) ) * delta)) - (thick / ( (Float)(2) ))));
HXDLIN( 441)					int r_w1 = ::Std_obj::_hx_int(w_);
HXDLIN( 441)					int r_h1 = ::Std_obj::_hx_int(thick);
HXDLIN( 441)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN( 441)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN( 441)					int ii_min2 = r_x1;
HXDLIN( 441)					int ii_max2 = xmax1;
HXDLIN( 441)					int xRange__start1 = ii_min2;
HXDLIN( 441)					int xRange__max1 = ii_max2;
HXDLIN( 441)					int ii_min3 = r_y1;
HXDLIN( 441)					int ii_max3 = ymax1;
HXDLIN( 441)					int yRange__start1 = ii_min3;
HXDLIN( 441)					int yRange__max1 = ii_max3;
HXDLIN( 441)					int range_x1 = xRange__start1;
HXDLIN( 441)					int range_y1 = (yRange__start1 - 1);
HXDLIN( 441)					int range_xReset1 = range_x1;
HXDLIN( 441)					int range_yReset1 = range_y1;
HXDLIN( 441)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 441)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 441)					int _this_min1 = 0;
HXDLIN( 441)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 441)					while((_this_min1 < _this_max1)){
HXLINE( 441)						_this_min1 = (_this_min1 + 1);
HXDLIN( 441)						int i4 = (_this_min1 - 1);
HXDLIN( 441)						if ((range_y1 > range_yMax1)) {
HXLINE( 441)							range_y1 = range_yReset1;
HXDLIN( 441)							range_x1 = (range_x1 + 1);
            						}
HXDLIN( 441)						range_y1 = (range_y1 + 1);
HXDLIN( 441)						int i5 = i4;
HXDLIN( 441)						{
HXLINE( 441)							int x2 = range_x1;
HXDLIN( 441)							int y2 = range_y1;
HXDLIN( 441)							int c1 = color;
HXDLIN( 441)							bool _hx_tmp3;
HXDLIN( 441)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 441)								_hx_tmp3 = this1->transparent;
            							}
            							else {
HXLINE( 441)								_hx_tmp3 = false;
            							}
HXDLIN( 441)							if (_hx_tmp3) {
HXLINE( 441)								int location1;
HXDLIN( 441)								if (this1->useVirtualPos) {
HXLINE( 441)									location1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x2) - this1->virtualX));
            								}
            								else {
HXLINE( 441)									location1 = ::Std_obj::_hx_int(( (Float)(((y2 * this1->width) + x2)) ));
            								}
HXDLIN( 441)								int this13 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 441)								int this14;
HXDLIN( 441)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 441)									this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            								}
            								else {
HXLINE( 441)									this14 = this13;
            								}
HXDLIN( 441)								Float a11;
HXDLIN( 441)								int this15 = ((this14 >> 24) & 255);
HXDLIN( 441)								if ((this15 == 0)) {
HXLINE( 441)									a11 = ((Float)0.);
            								}
            								else {
HXLINE( 441)									a11 = (( (Float)(this15) ) / ( (Float)(255) ));
            								}
HXDLIN( 441)								Float r11;
HXDLIN( 441)								int this16 = ((this14 >> 16) & 255);
HXDLIN( 441)								if ((this16 == 0)) {
HXLINE( 441)									r11 = ((Float)0.);
            								}
            								else {
HXLINE( 441)									r11 = (( (Float)(this16) ) / ( (Float)(255) ));
            								}
HXDLIN( 441)								Float g11;
HXDLIN( 441)								int this17 = ((this14 >> 8) & 255);
HXDLIN( 441)								if ((this17 == 0)) {
HXLINE( 441)									g11 = ((Float)0.);
            								}
            								else {
HXLINE( 441)									g11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN( 441)								Float b11;
HXDLIN( 441)								int this18 = (this14 & 255);
HXDLIN( 441)								if ((this18 == 0)) {
HXLINE( 441)									b11 = ((Float)0.);
            								}
            								else {
HXLINE( 441)									b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN( 441)								Float a21;
HXDLIN( 441)								int this19 = ((color >> 24) & 255);
HXDLIN( 441)								if ((this19 == 0)) {
HXLINE( 441)									a21 = ((Float)0.);
            								}
            								else {
HXLINE( 441)									a21 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN( 441)								Float r21;
HXDLIN( 441)								int this20 = ((color >> 16) & 255);
HXDLIN( 441)								if ((this20 == 0)) {
HXLINE( 441)									r21 = ((Float)0.);
            								}
            								else {
HXLINE( 441)									r21 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN( 441)								Float g21;
HXDLIN( 441)								int this21 = ((color >> 8) & 255);
HXDLIN( 441)								if ((this21 == 0)) {
HXLINE( 441)									g21 = ((Float)0.);
            								}
            								else {
HXLINE( 441)									g21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN( 441)								Float b21;
HXDLIN( 441)								int this22 = (color & 255);
HXDLIN( 441)								if ((this22 == 0)) {
HXLINE( 441)									b21 = ((Float)0.);
            								}
            								else {
HXLINE( 441)									b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN( 441)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 441)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 441)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 441)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN( 441)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 441)								int blended1 = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 441)								{
HXLINE( 441)									int _hx_tmp4;
HXDLIN( 441)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 441)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE( 441)										_hx_tmp4 = blended1;
            									}
HXDLIN( 441)									::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE( 441)								::Dynamic this23 = this1->image;
HXDLIN( 441)								int index1;
HXDLIN( 441)								if (this1->useVirtualPos) {
HXLINE( 441)									index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x2) - this1->virtualX));
            								}
            								else {
HXLINE( 441)									index1 = ::Std_obj::_hx_int(( (Float)(((y2 * this1->width) + x2)) ));
            								}
HXDLIN( 441)								int _hx_tmp5;
HXDLIN( 441)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 441)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 441)									_hx_tmp5 = c1;
            								}
HXDLIN( 441)								::iterMagic::Iimg_obj::set(this23,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(FillShape_Impl__obj,lineGrid,(void))

void FillShape_Impl__obj::lineGridWH( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,Float deltaW,Float deltaH,Float thick,int color){
            	HX_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_449_lineGridWH)
HXLINE( 450)		Float h_ = (( (Float)(::Math_obj::floor((h / deltaH))) ) * deltaH);
HXLINE( 451)		Float w_ = (( (Float)(::Math_obj::floor((w / deltaW))) ) * deltaW);
HXLINE( 452)		{
HXLINE( 452)			int _g = 0;
HXDLIN( 452)			int _g1 = (::Math_obj::floor((w / deltaW)) + 1);
HXDLIN( 452)			while((_g < _g1)){
HXLINE( 452)				_g = (_g + 1);
HXDLIN( 452)				int i = (_g - 1);
HXLINE( 453)				{
HXLINE( 453)					int r_x = ::Std_obj::_hx_int(((x + (( (Float)(i) ) * deltaW)) - (thick / ( (Float)(2) ))));
HXDLIN( 453)					int r_y = ::Std_obj::_hx_int(y);
HXDLIN( 453)					int r_w = ::Std_obj::_hx_int(thick);
HXDLIN( 453)					int r_h = ::Std_obj::_hx_int(h_);
HXDLIN( 453)					int xmax = ((r_x + r_w) + 1);
HXDLIN( 453)					int ymax = ((r_y + r_h) + 1);
HXDLIN( 453)					int ii_min = r_x;
HXDLIN( 453)					int ii_max = xmax;
HXDLIN( 453)					int xRange__start = ii_min;
HXDLIN( 453)					int xRange__max = ii_max;
HXDLIN( 453)					int ii_min1 = r_y;
HXDLIN( 453)					int ii_max1 = ymax;
HXDLIN( 453)					int yRange__start = ii_min1;
HXDLIN( 453)					int yRange__max = ii_max1;
HXDLIN( 453)					int range_x = xRange__start;
HXDLIN( 453)					int range_y = (yRange__start - 1);
HXDLIN( 453)					int range_xReset = range_x;
HXDLIN( 453)					int range_yReset = range_y;
HXDLIN( 453)					int range_xMax = (xRange__max - 2);
HXDLIN( 453)					int range_yMax = (yRange__max - 2);
HXDLIN( 453)					int _this_min = 0;
HXDLIN( 453)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 453)					while((_this_min < _this_max)){
HXLINE( 453)						_this_min = (_this_min + 1);
HXDLIN( 453)						int i1 = (_this_min - 1);
HXDLIN( 453)						if ((range_y > range_yMax)) {
HXLINE( 453)							range_y = range_yReset;
HXDLIN( 453)							range_x = (range_x + 1);
            						}
HXDLIN( 453)						range_y = (range_y + 1);
HXDLIN( 453)						int i2 = i1;
HXDLIN( 453)						{
HXLINE( 453)							int x1 = range_x;
HXDLIN( 453)							int y1 = range_y;
HXDLIN( 453)							int c = color;
HXDLIN( 453)							bool _hx_tmp;
HXDLIN( 453)							if ((((c >> 24) & 255) < 254)) {
HXLINE( 453)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE( 453)								_hx_tmp = false;
            							}
HXDLIN( 453)							if (_hx_tmp) {
HXLINE( 453)								int location;
HXDLIN( 453)								if (this1->useVirtualPos) {
HXLINE( 453)									location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            								}
            								else {
HXLINE( 453)									location = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            								}
HXDLIN( 453)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 453)								int this3;
HXDLIN( 453)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 453)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE( 453)									this3 = this2;
            								}
HXDLIN( 453)								Float a1;
HXDLIN( 453)								int this4 = ((this3 >> 24) & 255);
HXDLIN( 453)								if ((this4 == 0)) {
HXLINE( 453)									a1 = ((Float)0.);
            								}
            								else {
HXLINE( 453)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN( 453)								Float r1;
HXDLIN( 453)								int this5 = ((this3 >> 16) & 255);
HXDLIN( 453)								if ((this5 == 0)) {
HXLINE( 453)									r1 = ((Float)0.);
            								}
            								else {
HXLINE( 453)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN( 453)								Float g1;
HXDLIN( 453)								int this6 = ((this3 >> 8) & 255);
HXDLIN( 453)								if ((this6 == 0)) {
HXLINE( 453)									g1 = ((Float)0.);
            								}
            								else {
HXLINE( 453)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN( 453)								Float b1;
HXDLIN( 453)								int this7 = (this3 & 255);
HXDLIN( 453)								if ((this7 == 0)) {
HXLINE( 453)									b1 = ((Float)0.);
            								}
            								else {
HXLINE( 453)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN( 453)								Float a2;
HXDLIN( 453)								int this8 = ((color >> 24) & 255);
HXDLIN( 453)								if ((this8 == 0)) {
HXLINE( 453)									a2 = ((Float)0.);
            								}
            								else {
HXLINE( 453)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN( 453)								Float r2;
HXDLIN( 453)								int this9 = ((color >> 16) & 255);
HXDLIN( 453)								if ((this9 == 0)) {
HXLINE( 453)									r2 = ((Float)0.);
            								}
            								else {
HXLINE( 453)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN( 453)								Float g2;
HXDLIN( 453)								int this10 = ((color >> 8) & 255);
HXDLIN( 453)								if ((this10 == 0)) {
HXLINE( 453)									g2 = ((Float)0.);
            								}
            								else {
HXLINE( 453)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN( 453)								Float b2;
HXDLIN( 453)								int this11 = (color & 255);
HXDLIN( 453)								if ((this11 == 0)) {
HXLINE( 453)									b2 = ((Float)0.);
            								}
            								else {
HXLINE( 453)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN( 453)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 453)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 453)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 453)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 453)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 453)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 453)								{
HXLINE( 453)									int _hx_tmp1;
HXDLIN( 453)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 453)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE( 453)										_hx_tmp1 = blended;
            									}
HXDLIN( 453)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE( 453)								::Dynamic this12 = this1->image;
HXDLIN( 453)								int index;
HXDLIN( 453)								if (this1->useVirtualPos) {
HXLINE( 453)									index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            								}
            								else {
HXLINE( 453)									index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            								}
HXDLIN( 453)								int _hx_tmp2;
HXDLIN( 453)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 453)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 453)									_hx_tmp2 = c;
            								}
HXDLIN( 453)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 455)		{
HXLINE( 455)			int _g2 = 0;
HXDLIN( 455)			int _g3 = (::Math_obj::floor((h / deltaH)) + 1);
HXDLIN( 455)			while((_g2 < _g3)){
HXLINE( 455)				_g2 = (_g2 + 1);
HXDLIN( 455)				int i3 = (_g2 - 1);
HXLINE( 456)				{
HXLINE( 456)					int r_x1 = ::Std_obj::_hx_int(x);
HXDLIN( 456)					int r_y1 = ::Std_obj::_hx_int(((y + (( (Float)(i3) ) * deltaH)) - (thick / ( (Float)(2) ))));
HXDLIN( 456)					int r_w1 = ::Std_obj::_hx_int(w_);
HXDLIN( 456)					int r_h1 = ::Std_obj::_hx_int(thick);
HXDLIN( 456)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN( 456)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN( 456)					int ii_min2 = r_x1;
HXDLIN( 456)					int ii_max2 = xmax1;
HXDLIN( 456)					int xRange__start1 = ii_min2;
HXDLIN( 456)					int xRange__max1 = ii_max2;
HXDLIN( 456)					int ii_min3 = r_y1;
HXDLIN( 456)					int ii_max3 = ymax1;
HXDLIN( 456)					int yRange__start1 = ii_min3;
HXDLIN( 456)					int yRange__max1 = ii_max3;
HXDLIN( 456)					int range_x1 = xRange__start1;
HXDLIN( 456)					int range_y1 = (yRange__start1 - 1);
HXDLIN( 456)					int range_xReset1 = range_x1;
HXDLIN( 456)					int range_yReset1 = range_y1;
HXDLIN( 456)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN( 456)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN( 456)					int _this_min1 = 0;
HXDLIN( 456)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN( 456)					while((_this_min1 < _this_max1)){
HXLINE( 456)						_this_min1 = (_this_min1 + 1);
HXDLIN( 456)						int i4 = (_this_min1 - 1);
HXDLIN( 456)						if ((range_y1 > range_yMax1)) {
HXLINE( 456)							range_y1 = range_yReset1;
HXDLIN( 456)							range_x1 = (range_x1 + 1);
            						}
HXDLIN( 456)						range_y1 = (range_y1 + 1);
HXDLIN( 456)						int i5 = i4;
HXDLIN( 456)						{
HXLINE( 456)							int x2 = range_x1;
HXDLIN( 456)							int y2 = range_y1;
HXDLIN( 456)							int c1 = color;
HXDLIN( 456)							bool _hx_tmp3;
HXDLIN( 456)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 456)								_hx_tmp3 = this1->transparent;
            							}
            							else {
HXLINE( 456)								_hx_tmp3 = false;
            							}
HXDLIN( 456)							if (_hx_tmp3) {
HXLINE( 456)								int location1;
HXDLIN( 456)								if (this1->useVirtualPos) {
HXLINE( 456)									location1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x2) - this1->virtualX));
            								}
            								else {
HXLINE( 456)									location1 = ::Std_obj::_hx_int(( (Float)(((y2 * this1->width) + x2)) ));
            								}
HXDLIN( 456)								int this13 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 456)								int this14;
HXDLIN( 456)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 456)									this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            								}
            								else {
HXLINE( 456)									this14 = this13;
            								}
HXDLIN( 456)								Float a11;
HXDLIN( 456)								int this15 = ((this14 >> 24) & 255);
HXDLIN( 456)								if ((this15 == 0)) {
HXLINE( 456)									a11 = ((Float)0.);
            								}
            								else {
HXLINE( 456)									a11 = (( (Float)(this15) ) / ( (Float)(255) ));
            								}
HXDLIN( 456)								Float r11;
HXDLIN( 456)								int this16 = ((this14 >> 16) & 255);
HXDLIN( 456)								if ((this16 == 0)) {
HXLINE( 456)									r11 = ((Float)0.);
            								}
            								else {
HXLINE( 456)									r11 = (( (Float)(this16) ) / ( (Float)(255) ));
            								}
HXDLIN( 456)								Float g11;
HXDLIN( 456)								int this17 = ((this14 >> 8) & 255);
HXDLIN( 456)								if ((this17 == 0)) {
HXLINE( 456)									g11 = ((Float)0.);
            								}
            								else {
HXLINE( 456)									g11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN( 456)								Float b11;
HXDLIN( 456)								int this18 = (this14 & 255);
HXDLIN( 456)								if ((this18 == 0)) {
HXLINE( 456)									b11 = ((Float)0.);
            								}
            								else {
HXLINE( 456)									b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN( 456)								Float a21;
HXDLIN( 456)								int this19 = ((color >> 24) & 255);
HXDLIN( 456)								if ((this19 == 0)) {
HXLINE( 456)									a21 = ((Float)0.);
            								}
            								else {
HXLINE( 456)									a21 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN( 456)								Float r21;
HXDLIN( 456)								int this20 = ((color >> 16) & 255);
HXDLIN( 456)								if ((this20 == 0)) {
HXLINE( 456)									r21 = ((Float)0.);
            								}
            								else {
HXLINE( 456)									r21 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN( 456)								Float g21;
HXDLIN( 456)								int this21 = ((color >> 8) & 255);
HXDLIN( 456)								if ((this21 == 0)) {
HXLINE( 456)									g21 = ((Float)0.);
            								}
            								else {
HXLINE( 456)									g21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN( 456)								Float b21;
HXDLIN( 456)								int this22 = (color & 255);
HXDLIN( 456)								if ((this22 == 0)) {
HXLINE( 456)									b21 = ((Float)0.);
            								}
            								else {
HXLINE( 456)									b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN( 456)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 456)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 456)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 456)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN( 456)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 456)								int blended1 = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 456)								{
HXLINE( 456)									int _hx_tmp4;
HXDLIN( 456)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 456)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE( 456)										_hx_tmp4 = blended1;
            									}
HXDLIN( 456)									::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE( 456)								::Dynamic this23 = this1->image;
HXDLIN( 456)								int index1;
HXDLIN( 456)								if (this1->useVirtualPos) {
HXLINE( 456)									index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x2) - this1->virtualX));
            								}
            								else {
HXLINE( 456)									index1 = ::Std_obj::_hx_int(( (Float)(((y2 * this1->width) + x2)) ));
            								}
HXDLIN( 456)								int _hx_tmp5;
HXDLIN( 456)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 456)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE( 456)									_hx_tmp5 = c1;
            								}
HXDLIN( 456)								::iterMagic::Iimg_obj::set(this23,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FillShape_Impl__obj,lineGridWH,(void))

 ::pi_xy::algo::HitTriArray FillShape_Impl__obj::arrow( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float thick,int color,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< bool >  __o_hasHit){
            		bool flare = __o_flare.Default(false);
            		bool reverseFlare = __o_reverseFlare.Default(false);
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_469_arrow)
HXDLIN( 469)		Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 469)		Float o = (qy - py);
HXDLIN( 469)		Float a = (qx - px);
HXDLIN( 469)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 469)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 469)		Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN( 469)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 469)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 469)		Float radius = (thick / ( (Float)(2) ));
HXDLIN( 469)		Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 469)		Float h2 = (h / goldenRatio);
HXDLIN( 469)		 ::pi_xy::algo::HitQuad hitQuad;
HXDLIN( 469)		if (flare) {
HXDLIN( 469)			if (reverseFlare) {
HXDLIN( 469)				Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 469)				Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 469)				Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 469)				Float radius21 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN( 469)				Float dx = ((Float)0.1);
HXDLIN( 469)				Float dy = radius1;
HXDLIN( 469)				Float cx = h2;
HXDLIN( 469)				Float cy = radius21;
HXDLIN( 469)				Float bx = h2;
HXDLIN( 469)				Float by = -(radius21);
HXDLIN( 469)				Float ax = ((Float)0.1);
HXDLIN( 469)				Float ay = -(radius1);
HXDLIN( 469)				Float temp = ((Float)0.);
HXLINE( 240)				temp = (px + ((ax * cos1) - (ay * sin1)));
HXLINE( 241)				ay = (py + ((ay * cos1) + (ax * sin1)));
HXLINE( 242)				ax = temp;
HXLINE( 244)				temp = (px + ((bx * cos1) - (by * sin1)));
HXLINE( 245)				by = (py + ((by * cos1) + (bx * sin1)));
HXLINE( 246)				bx = temp;
HXLINE( 248)				temp = (px + ((cx * cos1) - (cy * sin1)));
HXLINE( 249)				cy = (py + ((cy * cos1) + (cx * sin1)));
HXLINE( 250)				cx = temp;
HXLINE( 252)				temp = (px + ((dx * cos1) - (dy * sin1)));
HXLINE( 253)				dy = (py + ((dy * cos1) + (dx * sin1)));
HXLINE( 254)				dx = temp;
HXLINE( 469)				Float bx1 = bx;
HXDLIN( 469)				Float by1 = by;
HXDLIN( 469)				Float cx1 = dx;
HXDLIN( 469)				Float cy1 = dy;
HXDLIN( 469)				bool hasUndo = false;
HXDLIN( 469)				bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 469)				if (!(adjustWinding)) {
HXDLIN( 469)					Float bx_ = bx1;
HXDLIN( 469)					Float by_ = by1;
HXLINE(  25)					bx1 = cx1;
HXLINE(  26)					by1 = cy1;
HXLINE(  27)					cx1 = bx_;
HXLINE(  28)					cy1 = by_;
            				}
HXLINE( 469)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 469)				Float sx = (cy1 - ay);
HXDLIN( 469)				Float sy = (ax - cx1);
HXDLIN( 469)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 469)				Float tx = (ay - by1);
HXDLIN( 469)				Float ty = (bx1 - ax);
HXDLIN( 469)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 469)				if ((ax > bx1)) {
HXDLIN( 469)					if ((ax > cx1)) {
HXDLIN( 469)						int min;
HXDLIN( 469)						if ((bx1 > cx1)) {
HXDLIN( 469)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXDLIN( 469)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN( 469)						int ii_min = min;
HXDLIN( 469)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 469)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXDLIN( 469)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 469)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 469)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXDLIN( 469)					if ((bx1 > cx1)) {
HXDLIN( 469)						int min1;
HXDLIN( 469)						if ((ax > cx1)) {
HXDLIN( 469)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXDLIN( 469)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 469)						int ii_min2 = min1;
HXDLIN( 469)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 469)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXDLIN( 469)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 469)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 469)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 469)				if ((ay > by1)) {
HXDLIN( 469)					if ((ay > cy1)) {
HXDLIN( 469)						int min2;
HXDLIN( 469)						if ((by1 > cy1)) {
HXDLIN( 469)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXDLIN( 469)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN( 469)						int ii_min4 = min2;
HXDLIN( 469)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 469)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXDLIN( 469)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 469)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 469)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXDLIN( 469)					if ((by1 > cy1)) {
HXDLIN( 469)						int min3;
HXDLIN( 469)						if ((ay > cy1)) {
HXDLIN( 469)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXDLIN( 469)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 469)						int ii_min6 = min3;
HXDLIN( 469)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 469)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXDLIN( 469)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 469)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 469)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 469)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 469)				if (hasUndo) {
HXDLIN( 469)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 469)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 469)					 ::Dynamic imageType = null();
HXDLIN( 469)					 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 469)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 469)					::Dynamic undoImage1;
HXDLIN( 469)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXDLIN( 469)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 469)							{
HXDLIN( 469)								b->width = width;
HXDLIN( 469)								b->height = height;
HXDLIN( 469)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 469)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 469)								{
HXDLIN( 469)									int len = b->length;
HXDLIN( 469)									int w = 0;
HXDLIN( 469)									{
HXDLIN( 469)										int _g = 0;
HXDLIN( 469)										int _g1 = b->height;
HXDLIN( 469)										while((_g < _g1)){
HXDLIN( 469)											_g = (_g + 1);
HXDLIN( 469)											int y = (_g - 1);
HXDLIN( 469)											{
HXDLIN( 469)												int _g2 = 0;
HXDLIN( 469)												int _g3 = b->width;
HXDLIN( 469)												while((_g2 < _g3)){
HXDLIN( 469)													_g2 = (_g2 + 1);
HXDLIN( 469)													int x = (_g2 - 1);
HXDLIN( 469)													{
HXDLIN( 469)														w = (w + 1);
HXDLIN( 469)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w = (w + 1);
HXDLIN( 469)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w = (w + 1);
HXDLIN( 469)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w = (w + 1);
HXDLIN( 469)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXDLIN( 469)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 469)							{
HXDLIN( 469)								a1->width = width;
HXDLIN( 469)								a1->height = height;
HXDLIN( 469)								a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 469)								a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 469)								{
HXDLIN( 469)									int _g4 = 0;
HXDLIN( 469)									int _g5 = a1->length;
HXDLIN( 469)									while((_g4 < _g5)){
HXDLIN( 469)										_g4 = (_g4 + 1);
HXDLIN( 469)										int i = (_g4 - 1);
HXDLIN( 469)										a1->data[i] = 0;
            									}
            								}
            							}
HXDLIN( 469)							undoImage1 = a1;
            						}
            						break;
            						case (int)2: {
HXDLIN( 469)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 469)							{
HXDLIN( 469)								b1->width = width;
HXDLIN( 469)								b1->height = height;
HXDLIN( 469)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 469)								int size = (b1->length * 4);
HXDLIN( 469)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 469)								{
HXDLIN( 469)									int _g6 = 0;
HXDLIN( 469)									int _g7 = b1->length;
HXDLIN( 469)									while((_g6 < _g7)){
HXDLIN( 469)										_g6 = (_g6 + 1);
HXDLIN( 469)										int i1 = (_g6 - 1);
HXDLIN( 469)										{
HXDLIN( 469)											 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 469)											bool undoImage2;
HXDLIN( 469)											if ((i1 >= 0)) {
HXDLIN( 469)												undoImage2 = (i1 < (this3->byteLength >> 2));
            											}
            											else {
HXDLIN( 469)												undoImage2 = false;
            											}
HXDLIN( 469)											if (undoImage2) {
HXDLIN( 469)												 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 469)												int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 469)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 469)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 469)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 469)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXDLIN( 469)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 469)							{
HXDLIN( 469)								v->width = width;
HXDLIN( 469)								v->height = height;
HXDLIN( 469)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 469)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 469)								{
HXDLIN( 469)									int _g8 = 0;
HXDLIN( 469)									int _g9 = v->length;
HXDLIN( 469)									while((_g8 < _g9)){
HXDLIN( 469)										_g8 = (_g8 + 1);
HXDLIN( 469)										int i2 = (_g8 - 1);
HXDLIN( 469)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN( 469)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXDLIN( 469)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 469)							{
HXDLIN( 469)								b2->width = width;
HXDLIN( 469)								b2->height = height;
HXDLIN( 469)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 469)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 469)								{
HXDLIN( 469)									int len1 = b2->length;
HXDLIN( 469)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 469)									if (::hx::IsNull( d->head )) {
HXDLIN( 469)										int _g10 = 0;
HXDLIN( 469)										int _g11 = len1;
HXDLIN( 469)										while((_g10 < _g11)){
HXDLIN( 469)											_g10 = (_g10 + 1);
HXDLIN( 469)											int i3 = (_g10 - 1);
HXDLIN( 469)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXDLIN( 469)										int _g12 = 0;
HXDLIN( 469)										int _g13 = len1;
HXDLIN( 469)										while((_g12 < _g13)){
HXDLIN( 469)											_g12 = (_g12 + 1);
HXDLIN( 469)											int i4 = (_g12 - 1);
HXDLIN( 469)											{
HXDLIN( 469)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 469)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 469)												{
HXDLIN( 469)													int _g14 = 0;
HXDLIN( 469)													int _g15 = i4;
HXDLIN( 469)													while((_g14 < _g15)){
HXDLIN( 469)														_g14 = (_g14 + 1);
HXDLIN( 469)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 469)												if (::hx::IsNull( prev )) {
HXDLIN( 469)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 469)													l = null();
            												}
            												else {
HXDLIN( 469)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 469)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 469)					this2->image = undoImage1;
HXDLIN( 469)					this2->width = width;
HXDLIN( 469)					this2->height = height;
HXDLIN( 469)					this2->imageType = ( (int)(imageType) );
HXDLIN( 469)					undoImage = this2;
HXDLIN( 469)					{
HXDLIN( 469)						int rectLeft = xIter3->start;
HXDLIN( 469)						int rectTop = yIter3->start;
HXDLIN( 469)						int rectRight = xIter3->max;
HXDLIN( 469)						bool forceClear = false;
HXDLIN( 469)						{
HXDLIN( 469)							int _g16 = rectTop;
HXDLIN( 469)							int _g17 = yIter3->max;
HXDLIN( 469)							while((_g16 < _g17)){
HXDLIN( 469)								_g16 = (_g16 + 1);
HXDLIN( 469)								int dy1 = (_g16 - 1);
HXDLIN( 469)								{
HXDLIN( 469)									int _g18 = rectLeft;
HXDLIN( 469)									int _g19 = rectRight;
HXDLIN( 469)									while((_g18 < _g19)){
HXDLIN( 469)										_g18 = (_g18 + 1);
HXDLIN( 469)										int dx1 = (_g18 - 1);
HXDLIN( 469)										::Dynamic this4 = this1->image;
HXDLIN( 469)										int index;
HXDLIN( 469)										if (this1->useVirtualPos) {
HXDLIN( 469)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            										}
            										else {
HXDLIN( 469)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            										}
HXDLIN( 469)										int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 469)										int col;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											col = c;
            										}
HXDLIN( 469)										bool hitQuad1;
HXDLIN( 469)										if (this1->useMask) {
HXDLIN( 469)											hitQuad1 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 469)											hitQuad1 = false;
            										}
HXDLIN( 469)										if (hitQuad1) {
HXDLIN( 469)											 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 469)											::Dynamic this6 = this5->image;
HXDLIN( 469)											int index1;
HXDLIN( 469)											if (this5->useVirtualPos) {
HXDLIN( 469)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            											}
            											else {
HXDLIN( 469)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            											}
HXDLIN( 469)											int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 469)											int v1;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												v1 = c1;
            											}
HXDLIN( 469)											int maskPixel = v1;
HXDLIN( 469)											int this7 = col;
HXDLIN( 469)											if ((maskPixel == 0)) {
HXDLIN( 469)												col = this7;
            											}
            											else {
HXDLIN( 469)												Float m0;
HXDLIN( 469)												int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 469)												if ((this8 == 0)) {
HXDLIN( 469)													m0 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m1;
HXDLIN( 469)												int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 469)												if ((this9 == 0)) {
HXDLIN( 469)													m1 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m2;
HXDLIN( 469)												int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 469)												if ((this10 == 0)) {
HXDLIN( 469)													m2 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m3;
HXDLIN( 469)												int this11 = (maskPixel & 255);
HXDLIN( 469)												if ((this11 == 0)) {
HXDLIN( 469)													m3 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 469)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 469)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 469)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 469)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 469)										if ((col != 0)) {
HXDLIN( 469)											int x1 = (dx1 - rectLeft);
HXDLIN( 469)											int y1 = (dy1 - rectTop);
HXDLIN( 469)											int c2 = col;
HXDLIN( 469)											bool hitQuad2;
HXDLIN( 469)											if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 469)												hitQuad2 = undoImage->transparent;
            											}
            											else {
HXDLIN( 469)												hitQuad2 = false;
            											}
HXDLIN( 469)											if (hitQuad2) {
HXDLIN( 469)												int location;
HXDLIN( 469)												if (undoImage->useVirtualPos) {
HXDLIN( 469)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXDLIN( 469)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 469)												int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 469)												int this13;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													this13 = this12;
            												}
HXDLIN( 469)												Float a11;
HXDLIN( 469)												int this14 = ((this13 >> 24) & 255);
HXDLIN( 469)												if ((this14 == 0)) {
HXDLIN( 469)													a11 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r1;
HXDLIN( 469)												int this15 = ((this13 >> 16) & 255);
HXDLIN( 469)												if ((this15 == 0)) {
HXDLIN( 469)													r1 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g1;
HXDLIN( 469)												int this16 = ((this13 >> 8) & 255);
HXDLIN( 469)												if ((this16 == 0)) {
HXDLIN( 469)													g1 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b11;
HXDLIN( 469)												int this17 = (this13 & 255);
HXDLIN( 469)												if ((this17 == 0)) {
HXDLIN( 469)													b11 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a2;
HXDLIN( 469)												int this18 = ((col >> 24) & 255);
HXDLIN( 469)												if ((this18 == 0)) {
HXDLIN( 469)													a2 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r2;
HXDLIN( 469)												int this19 = ((col >> 16) & 255);
HXDLIN( 469)												if ((this19 == 0)) {
HXDLIN( 469)													r2 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g2;
HXDLIN( 469)												int this20 = ((col >> 8) & 255);
HXDLIN( 469)												if ((this20 == 0)) {
HXDLIN( 469)													g2 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b21;
HXDLIN( 469)												int this21 = (col & 255);
HXDLIN( 469)												if ((this21 == 0)) {
HXDLIN( 469)													b21 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 469)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 469)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 469)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 469)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 469)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 469)												{
HXDLIN( 469)													int hitQuad3;
HXDLIN( 469)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)														hitQuad3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXDLIN( 469)														hitQuad3 = blended;
            													}
HXDLIN( 469)													::iterMagic::Iimg_obj::set(undoImage->image,location,hitQuad3);
            												}
            											}
            											else {
HXDLIN( 469)												::Dynamic this22 = undoImage->image;
HXDLIN( 469)												int index2;
HXDLIN( 469)												if (undoImage->useVirtualPos) {
HXDLIN( 469)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXDLIN( 469)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 469)												int hitQuad4;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad4 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad4 = c2;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this22,index2,hitQuad4);
            											}
            										}
            										else {
HXDLIN( 469)											if (forceClear) {
HXDLIN( 469)												::Dynamic this23 = undoImage->image;
HXDLIN( 469)												int x2 = (dx1 - rectLeft);
HXDLIN( 469)												int y2 = (dy1 - rectTop);
HXDLIN( 469)												int index3;
HXDLIN( 469)												if (undoImage->useVirtualPos) {
HXDLIN( 469)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXDLIN( 469)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this23,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 469)				bool found = false;
HXDLIN( 469)				Float s = ((Float)0.);
HXDLIN( 469)				Float t = ((Float)0.);
HXDLIN( 469)				Float sxx = ((Float)0.);
HXDLIN( 469)				Float txx = ((Float)0.);
HXDLIN( 469)				{
HXDLIN( 469)					int _g_min = xIter3->start;
HXDLIN( 469)					int _g_max = xIter3->max;
HXDLIN( 469)					while((_g_min < _g_max)){
HXDLIN( 469)						_g_min = (_g_min + 1);
HXDLIN( 469)						int x3 = (_g_min - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)						txx = (tx * ( (Float)(x3) ));
HXLINE(  62)						found = false;
HXLINE( 469)						{
HXDLIN( 469)							int _g_min1 = yIter3->start;
HXDLIN( 469)							int _g_max1 = yIter3->max;
HXDLIN( 469)							while((_g_min1 < _g_max1)){
HXDLIN( 469)								_g_min1 = (_g_min1 + 1);
HXDLIN( 469)								int y3 = (_g_min1 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 469)								bool hitQuad5;
HXDLIN( 469)								if (!((s <= 0))) {
HXDLIN( 469)									hitQuad5 = (t <= 0);
            								}
            								else {
HXDLIN( 469)									hitQuad5 = true;
            								}
HXDLIN( 469)								if (hitQuad5) {
HXDLIN( 469)									if (found) {
HXDLIN( 469)										goto _hx_goto_787;
            									}
            								}
            								else {
HXDLIN( 469)									if (((s + t) < A)) {
HXDLIN( 469)										{
HXDLIN( 469)											int c3 = color;
HXDLIN( 469)											bool hitQuad6;
HXDLIN( 469)											if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 469)												hitQuad6 = this1->transparent;
            											}
            											else {
HXDLIN( 469)												hitQuad6 = false;
            											}
HXDLIN( 469)											if (hitQuad6) {
HXDLIN( 469)												int location1;
HXDLIN( 469)												if (this1->useVirtualPos) {
HXDLIN( 469)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXDLIN( 469)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN( 469)												int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 469)												int this25;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													this25 = this24;
            												}
HXDLIN( 469)												Float a12;
HXDLIN( 469)												int this26 = ((this25 >> 24) & 255);
HXDLIN( 469)												if ((this26 == 0)) {
HXDLIN( 469)													a12 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a12 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r11;
HXDLIN( 469)												int this27 = ((this25 >> 16) & 255);
HXDLIN( 469)												if ((this27 == 0)) {
HXDLIN( 469)													r11 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g11;
HXDLIN( 469)												int this28 = ((this25 >> 8) & 255);
HXDLIN( 469)												if ((this28 == 0)) {
HXDLIN( 469)													g11 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b12;
HXDLIN( 469)												int this29 = (this25 & 255);
HXDLIN( 469)												if ((this29 == 0)) {
HXDLIN( 469)													b12 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a21;
HXDLIN( 469)												int this30 = ((color >> 24) & 255);
HXDLIN( 469)												if ((this30 == 0)) {
HXDLIN( 469)													a21 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r21;
HXDLIN( 469)												int this31 = ((color >> 16) & 255);
HXDLIN( 469)												if ((this31 == 0)) {
HXDLIN( 469)													r21 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g21;
HXDLIN( 469)												int this32 = ((color >> 8) & 255);
HXDLIN( 469)												if ((this32 == 0)) {
HXDLIN( 469)													g21 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b22;
HXDLIN( 469)												int this33 = (color & 255);
HXDLIN( 469)												if ((this33 == 0)) {
HXDLIN( 469)													b22 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 469)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 469)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 469)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 469)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 469)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 469)												{
HXDLIN( 469)													int hitQuad7;
HXDLIN( 469)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)														hitQuad7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXDLIN( 469)														hitQuad7 = blended1;
            													}
HXDLIN( 469)													::iterMagic::Iimg_obj::set(this1->image,location1,hitQuad7);
            												}
            											}
            											else {
HXDLIN( 469)												::Dynamic this34 = this1->image;
HXDLIN( 469)												int index4;
HXDLIN( 469)												if (this1->useVirtualPos) {
HXDLIN( 469)													index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXDLIN( 469)													index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN( 469)												int hitQuad8;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad8 = c3;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this34,index4,hitQuad8);
            											}
            										}
HXLINE(  73)										found = true;
            									}
            									else {
HXDLIN( 469)										if (found) {
HXDLIN( 469)											goto _hx_goto_787;
            										}
            									}
            								}
            							}
            							_hx_goto_787:;
            						}
            					}
            				}
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 469)				int v_undoY;
HXDLIN( 469)				int v_undoX;
HXDLIN( 469)				Float v_ty;
HXDLIN( 469)				Float v_tx;
HXDLIN( 469)				Float v_t0;
HXDLIN( 469)				Float v_sy;
HXDLIN( 469)				Float v_sx;
HXDLIN( 469)				Float v_s0;
HXDLIN( 469)				Float v_A;
HXDLIN( 469)				Float ax1 = ax;
HXDLIN( 469)				Float ay1 = ay;
HXDLIN( 469)				 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 469)				Float bx2 = bx1;
HXDLIN( 469)				Float by2 = by1;
HXDLIN( 469)				Float cx2 = cx1;
HXDLIN( 469)				Float cy2 = cy1;
HXDLIN( 469)				bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN( 469)				if (!(adjustWinding1)) {
HXDLIN( 469)					Float bx_1 = bx2;
HXDLIN( 469)					Float by_1 = by2;
HXLINE(  24)					bx2 = cx2;
HXLINE(  25)					by2 = cy2;
HXLINE(  26)					cx2 = bx_1;
HXLINE(  27)					cy2 = by_1;
            				}
HXLINE( 469)				Float v_ax = ax1;
HXDLIN( 469)				Float v_ay = ay1;
HXDLIN( 469)				Float v_bx = bx2;
HXDLIN( 469)				Float v_by = by2;
HXDLIN( 469)				Float v_cx = cx2;
HXDLIN( 469)				Float v_cy = cy2;
HXDLIN( 469)				bool v_preCalculated = true;
HXDLIN( 469)				{
HXDLIN( 469)					v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 469)					v_sx = (v_cy - v_ay);
HXDLIN( 469)					v_sy = (v_ax - v_cx);
HXDLIN( 469)					v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 469)					v_tx = (v_ay - v_by);
HXDLIN( 469)					v_ty = (v_bx - v_ax);
HXDLIN( 469)					v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 469)					Float a6 = v_ax;
HXDLIN( 469)					Float b5 = v_bx;
HXDLIN( 469)					Float c4 = v_cx;
HXDLIN( 469)					if ((a6 > b5)) {
HXDLIN( 469)						if ((a6 > c4)) {
HXDLIN( 469)							int min4;
HXDLIN( 469)							if ((b5 > c4)) {
HXDLIN( 469)								min4 = ::Math_obj::floor(c4);
            							}
            							else {
HXDLIN( 469)								min4 = ::Math_obj::floor(b5);
            							}
HXDLIN( 469)							int ii_min8 = min4;
HXDLIN( 469)							int ii_max8 = ::Math_obj::ceil(a6);
HXDLIN( 469)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            						}
            						else {
HXDLIN( 469)							int ii_min9 = ::Math_obj::floor(b5);
HXDLIN( 469)							int ii_max9 = ::Math_obj::ceil(c4);
HXDLIN( 469)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            						}
            					}
            					else {
HXDLIN( 469)						if ((b5 > c4)) {
HXDLIN( 469)							int min5;
HXDLIN( 469)							if ((a6 > c4)) {
HXDLIN( 469)								min5 = ::Math_obj::floor(c4);
            							}
            							else {
HXDLIN( 469)								min5 = ::Math_obj::ceil(a6);
            							}
HXDLIN( 469)							int ii_min10 = min5;
HXDLIN( 469)							int ii_max10 = ::Math_obj::ceil(b5);
HXDLIN( 469)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXDLIN( 469)							int ii_min11 = ::Math_obj::floor(a6);
HXDLIN( 469)							int ii_max11 = ::Math_obj::ceil(c4);
HXDLIN( 469)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
HXDLIN( 469)					Float a7 = v_ay;
HXDLIN( 469)					Float b6 = v_by;
HXDLIN( 469)					Float c5 = v_cy;
HXDLIN( 469)					if ((a7 > b6)) {
HXDLIN( 469)						if ((a7 > c5)) {
HXDLIN( 469)							int min6;
HXDLIN( 469)							if ((b6 > c5)) {
HXDLIN( 469)								min6 = ::Math_obj::floor(c5);
            							}
            							else {
HXDLIN( 469)								min6 = ::Math_obj::floor(b6);
            							}
HXDLIN( 469)							int ii_min12 = min6;
HXDLIN( 469)							int ii_max12 = ::Math_obj::ceil(a7);
HXDLIN( 469)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXDLIN( 469)							int ii_min13 = ::Math_obj::floor(b6);
HXDLIN( 469)							int ii_max13 = ::Math_obj::ceil(c5);
HXDLIN( 469)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
            					else {
HXDLIN( 469)						if ((b6 > c5)) {
HXDLIN( 469)							int min7;
HXDLIN( 469)							if ((a7 > c5)) {
HXDLIN( 469)								min7 = ::Math_obj::floor(c5);
            							}
            							else {
HXDLIN( 469)								min7 = ::Math_obj::ceil(a7);
            							}
HXDLIN( 469)							int ii_min14 = min7;
HXDLIN( 469)							int ii_max14 = ::Math_obj::ceil(b6);
HXDLIN( 469)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXDLIN( 469)							int ii_min15 = ::Math_obj::floor(a7);
HXDLIN( 469)							int ii_max15 = ::Math_obj::ceil(c5);
HXDLIN( 469)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
            				}
HXDLIN( 469)				if (hasUndo) {
HXDLIN( 469)					v_undoImage = undoImage;
HXDLIN( 469)					v_undoX = xIter3->start;
HXDLIN( 469)					v_undoY = yIter3->start;
            				}
HXDLIN( 469)				Float bx3 = cx;
HXDLIN( 469)				Float by3 = cy;
HXDLIN( 469)				Float cx3 = dx;
HXDLIN( 469)				Float cy3 = dy;
HXDLIN( 469)				bool hasUndo1 = false;
HXDLIN( 469)				bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN( 469)				if (!(adjustWinding2)) {
HXDLIN( 469)					Float bx_2 = bx3;
HXDLIN( 469)					Float by_2 = by3;
HXLINE(  25)					bx3 = cx3;
HXLINE(  26)					by3 = cy3;
HXLINE(  27)					cx3 = bx_2;
HXLINE(  28)					cy3 = by_2;
            				}
HXLINE( 469)				Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN( 469)				Float sx1 = (cy3 - by);
HXDLIN( 469)				Float sy1 = (bx - cx3);
HXDLIN( 469)				Float t01 = ((bx * by3) - (by * bx3));
HXDLIN( 469)				Float tx1 = (by - by3);
HXDLIN( 469)				Float ty1 = (bx3 - bx);
HXDLIN( 469)				Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 469)				if ((bx > bx3)) {
HXDLIN( 469)					if ((bx > cx3)) {
HXDLIN( 469)						int min8;
HXDLIN( 469)						if ((bx3 > cx3)) {
HXDLIN( 469)							min8 = ::Math_obj::floor(cx3);
            						}
            						else {
HXDLIN( 469)							min8 = ::Math_obj::floor(bx3);
            						}
HXDLIN( 469)						int ii_min16 = min8;
HXDLIN( 469)						int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN( 469)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            					}
            					else {
HXDLIN( 469)						int ii_min17 = ::Math_obj::floor(bx3);
HXDLIN( 469)						int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN( 469)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            					}
            				}
            				else {
HXDLIN( 469)					if ((bx3 > cx3)) {
HXDLIN( 469)						int min9;
HXDLIN( 469)						if ((bx > cx3)) {
HXDLIN( 469)							min9 = ::Math_obj::floor(cx3);
            						}
            						else {
HXDLIN( 469)							min9 = ::Math_obj::ceil(bx);
            						}
HXDLIN( 469)						int ii_min18 = min9;
HXDLIN( 469)						int ii_max18 = ::Math_obj::ceil(bx3);
HXDLIN( 469)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXDLIN( 469)						int ii_min19 = ::Math_obj::floor(bx);
HXDLIN( 469)						int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN( 469)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 469)				if ((by > by3)) {
HXDLIN( 469)					if ((by > cy3)) {
HXDLIN( 469)						int min10;
HXDLIN( 469)						if ((by3 > cy3)) {
HXDLIN( 469)							min10 = ::Math_obj::floor(cy3);
            						}
            						else {
HXDLIN( 469)							min10 = ::Math_obj::floor(by3);
            						}
HXDLIN( 469)						int ii_min20 = min10;
HXDLIN( 469)						int ii_max20 = ::Math_obj::ceil(by);
HXDLIN( 469)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXDLIN( 469)						int ii_min21 = ::Math_obj::floor(by3);
HXDLIN( 469)						int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN( 469)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
            				else {
HXDLIN( 469)					if ((by3 > cy3)) {
HXDLIN( 469)						int min11;
HXDLIN( 469)						if ((by > cy3)) {
HXDLIN( 469)							min11 = ::Math_obj::floor(cy3);
            						}
            						else {
HXDLIN( 469)							min11 = ::Math_obj::ceil(by);
            						}
HXDLIN( 469)						int ii_min22 = min11;
HXDLIN( 469)						int ii_max22 = ::Math_obj::ceil(by3);
HXDLIN( 469)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXDLIN( 469)						int ii_min23 = ::Math_obj::floor(by);
HXDLIN( 469)						int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN( 469)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
HXDLIN( 469)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 469)				if (hasUndo1) {
HXDLIN( 469)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 469)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 469)					 ::Dynamic imageType1 = null();
HXDLIN( 469)					 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 469)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 469)					::Dynamic undoImage4;
HXDLIN( 469)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXDLIN( 469)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::BytesImg b7 = byt1;
HXDLIN( 469)							{
HXDLIN( 469)								b7->width = width1;
HXDLIN( 469)								b7->height = height1;
HXDLIN( 469)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 469)								b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN( 469)								{
HXDLIN( 469)									int len2 = b7->length;
HXDLIN( 469)									int w1 = 0;
HXDLIN( 469)									{
HXDLIN( 469)										int _g20 = 0;
HXDLIN( 469)										int _g21 = b7->height;
HXDLIN( 469)										while((_g20 < _g21)){
HXDLIN( 469)											_g20 = (_g20 + 1);
HXDLIN( 469)											int y4 = (_g20 - 1);
HXDLIN( 469)											{
HXDLIN( 469)												int _g22 = 0;
HXDLIN( 469)												int _g23 = b7->width;
HXDLIN( 469)												while((_g22 < _g23)){
HXDLIN( 469)													_g22 = (_g22 + 1);
HXDLIN( 469)													int x4 = (_g22 - 1);
HXDLIN( 469)													{
HXDLIN( 469)														w1 = (w1 + 1);
HXDLIN( 469)														b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w1 = (w1 + 1);
HXDLIN( 469)														b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w1 = (w1 + 1);
HXDLIN( 469)														b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w1 = (w1 + 1);
HXDLIN( 469)														b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage4 = b7;
            						}
            						break;
            						case (int)1: {
HXDLIN( 469)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::ArrIntImg a8 = arrI1;
HXDLIN( 469)							{
HXDLIN( 469)								a8->width = width1;
HXDLIN( 469)								a8->height = height1;
HXDLIN( 469)								a8->data = ::Array_obj< int >::__new(0);
HXDLIN( 469)								a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 469)								{
HXDLIN( 469)									int _g24 = 0;
HXDLIN( 469)									int _g25 = a8->length;
HXDLIN( 469)									while((_g24 < _g25)){
HXDLIN( 469)										_g24 = (_g24 + 1);
HXDLIN( 469)										int i6 = (_g24 - 1);
HXDLIN( 469)										a8->data[i6] = 0;
            									}
            								}
            							}
HXDLIN( 469)							undoImage4 = a8;
            						}
            						break;
            						case (int)2: {
HXDLIN( 469)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::U32ArrImg b8 = u32a1;
HXDLIN( 469)							{
HXDLIN( 469)								b8->width = width1;
HXDLIN( 469)								b8->height = height1;
HXDLIN( 469)								b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 469)								int size1 = (b8->length * 4);
HXDLIN( 469)								b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 469)								{
HXDLIN( 469)									int _g26 = 0;
HXDLIN( 469)									int _g27 = b8->length;
HXDLIN( 469)									while((_g26 < _g27)){
HXDLIN( 469)										_g26 = (_g26 + 1);
HXDLIN( 469)										int i7 = (_g26 - 1);
HXDLIN( 469)										{
HXDLIN( 469)											 ::haxe::io::ArrayBufferViewImpl this36 = b8->data;
HXDLIN( 469)											bool undoImage5;
HXDLIN( 469)											if ((i7 >= 0)) {
HXDLIN( 469)												undoImage5 = (i7 < (this36->byteLength >> 2));
            											}
            											else {
HXDLIN( 469)												undoImage5 = false;
            											}
HXDLIN( 469)											if (undoImage5) {
HXDLIN( 469)												 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 469)												int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 469)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 469)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 469)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 469)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage4 = b8;
            						}
            						break;
            						case (int)3: {
HXDLIN( 469)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 469)							{
HXDLIN( 469)								v2->width = width1;
HXDLIN( 469)								v2->height = height1;
HXDLIN( 469)								v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 469)								v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 469)								{
HXDLIN( 469)									int _g28 = 0;
HXDLIN( 469)									int _g29 = v2->length;
HXDLIN( 469)									while((_g28 < _g29)){
HXDLIN( 469)										_g28 = (_g28 + 1);
HXDLIN( 469)										int i8 = (_g28 - 1);
HXDLIN( 469)										v2->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN( 469)							undoImage4 = v2;
            						}
            						break;
            						case (int)4: {
HXDLIN( 469)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::StackIntImg b9 = sInt1;
HXDLIN( 469)							{
HXDLIN( 469)								b9->width = width1;
HXDLIN( 469)								b9->height = height1;
HXDLIN( 469)								b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 469)								b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 469)								{
HXDLIN( 469)									int len3 = b9->length;
HXDLIN( 469)									 ::haxe::ds::GenericStack_Int d1 = b9->data;
HXDLIN( 469)									if (::hx::IsNull( d1->head )) {
HXDLIN( 469)										int _g30 = 0;
HXDLIN( 469)										int _g31 = len3;
HXDLIN( 469)										while((_g30 < _g31)){
HXDLIN( 469)											_g30 = (_g30 + 1);
HXDLIN( 469)											int i9 = (_g30 - 1);
HXDLIN( 469)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXDLIN( 469)										int _g32 = 0;
HXDLIN( 469)										int _g33 = len3;
HXDLIN( 469)										while((_g32 < _g33)){
HXDLIN( 469)											_g32 = (_g32 + 1);
HXDLIN( 469)											int i10 = (_g32 - 1);
HXDLIN( 469)											{
HXDLIN( 469)												 ::haxe::ds::GenericCell_Int l1 = b9->data->head;
HXDLIN( 469)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 469)												{
HXDLIN( 469)													int _g34 = 0;
HXDLIN( 469)													int _g35 = i10;
HXDLIN( 469)													while((_g34 < _g35)){
HXDLIN( 469)														_g34 = (_g34 + 1);
HXDLIN( 469)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 469)												if (::hx::IsNull( prev1 )) {
HXDLIN( 469)													b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 469)													l1 = null();
            												}
            												else {
HXDLIN( 469)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 469)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage4 = b9;
            						}
            						break;
            					}
HXDLIN( 469)					this35->image = undoImage4;
HXDLIN( 469)					this35->width = width1;
HXDLIN( 469)					this35->height = height1;
HXDLIN( 469)					this35->imageType = ( (int)(imageType1) );
HXDLIN( 469)					undoImage3 = this35;
HXDLIN( 469)					{
HXDLIN( 469)						int rectLeft1 = xIter31->start;
HXDLIN( 469)						int rectTop1 = yIter31->start;
HXDLIN( 469)						int rectRight1 = xIter31->max;
HXDLIN( 469)						bool forceClear1 = false;
HXDLIN( 469)						{
HXDLIN( 469)							int _g36 = rectTop1;
HXDLIN( 469)							int _g37 = yIter31->max;
HXDLIN( 469)							while((_g36 < _g37)){
HXDLIN( 469)								_g36 = (_g36 + 1);
HXDLIN( 469)								int dy2 = (_g36 - 1);
HXDLIN( 469)								{
HXDLIN( 469)									int _g38 = rectLeft1;
HXDLIN( 469)									int _g39 = rectRight1;
HXDLIN( 469)									while((_g38 < _g39)){
HXDLIN( 469)										_g38 = (_g38 + 1);
HXDLIN( 469)										int dx2 = (_g38 - 1);
HXDLIN( 469)										::Dynamic this37 = this1->image;
HXDLIN( 469)										int index5;
HXDLIN( 469)										if (this1->useVirtualPos) {
HXDLIN( 469)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            										}
            										else {
HXDLIN( 469)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            										}
HXDLIN( 469)										int c6 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 469)										int col1;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											col1 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											col1 = c6;
            										}
HXDLIN( 469)										bool hitQuad9;
HXDLIN( 469)										if (this1->useMask) {
HXDLIN( 469)											hitQuad9 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 469)											hitQuad9 = false;
            										}
HXDLIN( 469)										if (hitQuad9) {
HXDLIN( 469)											 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN( 469)											::Dynamic this39 = this38->image;
HXDLIN( 469)											int index6;
HXDLIN( 469)											if (this38->useVirtualPos) {
HXDLIN( 469)												index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            											}
            											else {
HXDLIN( 469)												index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            											}
HXDLIN( 469)											int c7 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 469)											int v3;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												v3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												v3 = c7;
            											}
HXDLIN( 469)											int maskPixel1 = v3;
HXDLIN( 469)											int this40 = col1;
HXDLIN( 469)											if ((maskPixel1 == 0)) {
HXDLIN( 469)												col1 = this40;
            											}
            											else {
HXDLIN( 469)												Float m01;
HXDLIN( 469)												int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 469)												if ((this41 == 0)) {
HXDLIN( 469)													m01 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m11;
HXDLIN( 469)												int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 469)												if ((this42 == 0)) {
HXDLIN( 469)													m11 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m21;
HXDLIN( 469)												int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 469)												if ((this43 == 0)) {
HXDLIN( 469)													m21 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m31;
HXDLIN( 469)												int this44 = (maskPixel1 & 255);
HXDLIN( 469)												if ((this44 == 0)) {
HXDLIN( 469)													m31 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 469)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 469)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 469)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 469)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 469)										if ((col1 != 0)) {
HXDLIN( 469)											int x5 = (dx2 - rectLeft1);
HXDLIN( 469)											int y5 = (dy2 - rectTop1);
HXDLIN( 469)											int c8 = col1;
HXDLIN( 469)											bool hitQuad10;
HXDLIN( 469)											if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 469)												hitQuad10 = undoImage3->transparent;
            											}
            											else {
HXDLIN( 469)												hitQuad10 = false;
            											}
HXDLIN( 469)											if (hitQuad10) {
HXDLIN( 469)												int location2;
HXDLIN( 469)												if (undoImage3->useVirtualPos) {
HXDLIN( 469)													location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXDLIN( 469)													location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 469)												int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 469)												int this46;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													this46 = this45;
            												}
HXDLIN( 469)												Float a13;
HXDLIN( 469)												int this47 = ((this46 >> 24) & 255);
HXDLIN( 469)												if ((this47 == 0)) {
HXDLIN( 469)													a13 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a13 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r12;
HXDLIN( 469)												int this48 = ((this46 >> 16) & 255);
HXDLIN( 469)												if ((this48 == 0)) {
HXDLIN( 469)													r12 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g12;
HXDLIN( 469)												int this49 = ((this46 >> 8) & 255);
HXDLIN( 469)												if ((this49 == 0)) {
HXDLIN( 469)													g12 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b13;
HXDLIN( 469)												int this50 = (this46 & 255);
HXDLIN( 469)												if ((this50 == 0)) {
HXDLIN( 469)													b13 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a22;
HXDLIN( 469)												int this51 = ((col1 >> 24) & 255);
HXDLIN( 469)												if ((this51 == 0)) {
HXDLIN( 469)													a22 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r22;
HXDLIN( 469)												int this52 = ((col1 >> 16) & 255);
HXDLIN( 469)												if ((this52 == 0)) {
HXDLIN( 469)													r22 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g22;
HXDLIN( 469)												int this53 = ((col1 >> 8) & 255);
HXDLIN( 469)												if ((this53 == 0)) {
HXDLIN( 469)													g22 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b23;
HXDLIN( 469)												int this54 = (col1 & 255);
HXDLIN( 469)												if ((this54 == 0)) {
HXDLIN( 469)													b23 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 469)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 469)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 469)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 469)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 469)												int blended2 = ((((a9 << 24) | (r4 << 16)) | (g4 << 8)) | b10);
HXDLIN( 469)												{
HXDLIN( 469)													int hitQuad11;
HXDLIN( 469)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)														hitQuad11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXDLIN( 469)														hitQuad11 = blended2;
            													}
HXDLIN( 469)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,hitQuad11);
            												}
            											}
            											else {
HXDLIN( 469)												::Dynamic this55 = undoImage3->image;
HXDLIN( 469)												int index7;
HXDLIN( 469)												if (undoImage3->useVirtualPos) {
HXDLIN( 469)													index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXDLIN( 469)													index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 469)												int hitQuad12;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad12 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad12 = c8;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this55,index7,hitQuad12);
            											}
            										}
            										else {
HXDLIN( 469)											if (forceClear1) {
HXDLIN( 469)												::Dynamic this56 = undoImage3->image;
HXDLIN( 469)												int x6 = (dx2 - rectLeft1);
HXDLIN( 469)												int y6 = (dy2 - rectTop1);
HXDLIN( 469)												int index8;
HXDLIN( 469)												if (undoImage3->useVirtualPos) {
HXDLIN( 469)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXDLIN( 469)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this56,index8,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 469)				bool found1 = false;
HXDLIN( 469)				Float s1 = ((Float)0.);
HXDLIN( 469)				Float t1 = ((Float)0.);
HXDLIN( 469)				Float sxx1 = ((Float)0.);
HXDLIN( 469)				Float txx1 = ((Float)0.);
HXDLIN( 469)				{
HXDLIN( 469)					int _g_min2 = xIter31->start;
HXDLIN( 469)					int _g_max2 = xIter31->max;
HXDLIN( 469)					while((_g_min2 < _g_max2)){
HXDLIN( 469)						_g_min2 = (_g_min2 + 1);
HXDLIN( 469)						int x7 = (_g_min2 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)						found1 = false;
HXLINE( 469)						{
HXDLIN( 469)							int _g_min3 = yIter31->start;
HXDLIN( 469)							int _g_max3 = yIter31->max;
HXDLIN( 469)							while((_g_min3 < _g_max3)){
HXDLIN( 469)								_g_min3 = (_g_min3 + 1);
HXDLIN( 469)								int y7 = (_g_min3 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 469)								bool hitQuad13;
HXDLIN( 469)								if (!((s1 <= 0))) {
HXDLIN( 469)									hitQuad13 = (t1 <= 0);
            								}
            								else {
HXDLIN( 469)									hitQuad13 = true;
            								}
HXDLIN( 469)								if (hitQuad13) {
HXDLIN( 469)									if (found1) {
HXDLIN( 469)										goto _hx_goto_799;
            									}
            								}
            								else {
HXDLIN( 469)									if (((s1 + t1) < A1)) {
HXDLIN( 469)										{
HXDLIN( 469)											int c9 = color;
HXDLIN( 469)											bool hitQuad14;
HXDLIN( 469)											if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 469)												hitQuad14 = this1->transparent;
            											}
            											else {
HXDLIN( 469)												hitQuad14 = false;
            											}
HXDLIN( 469)											if (hitQuad14) {
HXDLIN( 469)												int location3;
HXDLIN( 469)												if (this1->useVirtualPos) {
HXDLIN( 469)													location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXDLIN( 469)													location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN( 469)												int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 469)												int this58;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													this58 = this57;
            												}
HXDLIN( 469)												Float a14;
HXDLIN( 469)												int this59 = ((this58 >> 24) & 255);
HXDLIN( 469)												if ((this59 == 0)) {
HXDLIN( 469)													a14 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a14 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r13;
HXDLIN( 469)												int this60 = ((this58 >> 16) & 255);
HXDLIN( 469)												if ((this60 == 0)) {
HXDLIN( 469)													r13 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g13;
HXDLIN( 469)												int this61 = ((this58 >> 8) & 255);
HXDLIN( 469)												if ((this61 == 0)) {
HXDLIN( 469)													g13 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b14;
HXDLIN( 469)												int this62 = (this58 & 255);
HXDLIN( 469)												if ((this62 == 0)) {
HXDLIN( 469)													b14 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a23;
HXDLIN( 469)												int this63 = ((color >> 24) & 255);
HXDLIN( 469)												if ((this63 == 0)) {
HXDLIN( 469)													a23 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r23;
HXDLIN( 469)												int this64 = ((color >> 16) & 255);
HXDLIN( 469)												if ((this64 == 0)) {
HXDLIN( 469)													r23 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g23;
HXDLIN( 469)												int this65 = ((color >> 8) & 255);
HXDLIN( 469)												if ((this65 == 0)) {
HXDLIN( 469)													g23 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b24;
HXDLIN( 469)												int this66 = (color & 255);
HXDLIN( 469)												if ((this66 == 0)) {
HXDLIN( 469)													b24 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 469)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 469)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 469)												int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 469)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 469)												int blended3 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b15);
HXDLIN( 469)												{
HXDLIN( 469)													int hitQuad15;
HXDLIN( 469)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)														hitQuad15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXDLIN( 469)														hitQuad15 = blended3;
            													}
HXDLIN( 469)													::iterMagic::Iimg_obj::set(this1->image,location3,hitQuad15);
            												}
            											}
            											else {
HXDLIN( 469)												::Dynamic this67 = this1->image;
HXDLIN( 469)												int index9;
HXDLIN( 469)												if (this1->useVirtualPos) {
HXDLIN( 469)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXDLIN( 469)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN( 469)												int hitQuad16;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad16 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad16 = c9;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this67,index9,hitQuad16);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXDLIN( 469)										if (found1) {
HXDLIN( 469)											goto _hx_goto_799;
            										}
            									}
            								}
            							}
            							_hx_goto_799:;
            						}
            					}
            				}
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 469)				int v_undoY1;
HXDLIN( 469)				int v_undoX1;
HXDLIN( 469)				Float v_ty1;
HXDLIN( 469)				Float v_tx1;
HXDLIN( 469)				Float v_t01;
HXDLIN( 469)				Float v_sy1;
HXDLIN( 469)				Float v_sx1;
HXDLIN( 469)				Float v_s01;
HXDLIN( 469)				Float v_A1;
HXDLIN( 469)				Float ax2 = bx;
HXDLIN( 469)				Float ay2 = by;
HXDLIN( 469)				 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 469)				Float bx4 = bx3;
HXDLIN( 469)				Float by4 = by3;
HXDLIN( 469)				Float cx4 = cx3;
HXDLIN( 469)				Float cy4 = cy3;
HXDLIN( 469)				bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN( 469)				if (!(adjustWinding3)) {
HXDLIN( 469)					Float bx_3 = bx4;
HXDLIN( 469)					Float by_3 = by4;
HXLINE(  24)					bx4 = cx4;
HXLINE(  25)					by4 = cy4;
HXLINE(  26)					cx4 = bx_3;
HXLINE(  27)					cy4 = by_3;
            				}
HXLINE( 469)				Float v_ax1 = ax2;
HXDLIN( 469)				Float v_ay1 = ay2;
HXDLIN( 469)				Float v_bx1 = bx4;
HXDLIN( 469)				Float v_by1 = by4;
HXDLIN( 469)				Float v_cx1 = cx4;
HXDLIN( 469)				Float v_cy1 = cy4;
HXDLIN( 469)				bool v_preCalculated1 = true;
HXDLIN( 469)				{
HXDLIN( 469)					v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 469)					v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 469)					v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 469)					v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 469)					v_tx1 = (v_ay1 - v_by1);
HXDLIN( 469)					v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 469)					v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 469)					Float a15 = v_ax1;
HXDLIN( 469)					Float b16 = v_bx1;
HXDLIN( 469)					Float c10 = v_cx1;
HXDLIN( 469)					if ((a15 > b16)) {
HXDLIN( 469)						if ((a15 > c10)) {
HXDLIN( 469)							int min12;
HXDLIN( 469)							if ((b16 > c10)) {
HXDLIN( 469)								min12 = ::Math_obj::floor(c10);
            							}
            							else {
HXDLIN( 469)								min12 = ::Math_obj::floor(b16);
            							}
HXDLIN( 469)							int ii_min24 = min12;
HXDLIN( 469)							int ii_max24 = ::Math_obj::ceil(a15);
HXDLIN( 469)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            						}
            						else {
HXDLIN( 469)							int ii_min25 = ::Math_obj::floor(b16);
HXDLIN( 469)							int ii_max25 = ::Math_obj::ceil(c10);
HXDLIN( 469)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            						}
            					}
            					else {
HXDLIN( 469)						if ((b16 > c10)) {
HXDLIN( 469)							int min13;
HXDLIN( 469)							if ((a15 > c10)) {
HXDLIN( 469)								min13 = ::Math_obj::floor(c10);
            							}
            							else {
HXDLIN( 469)								min13 = ::Math_obj::ceil(a15);
            							}
HXDLIN( 469)							int ii_min26 = min13;
HXDLIN( 469)							int ii_max26 = ::Math_obj::ceil(b16);
HXDLIN( 469)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            						}
            						else {
HXDLIN( 469)							int ii_min27 = ::Math_obj::floor(a15);
HXDLIN( 469)							int ii_max27 = ::Math_obj::ceil(c10);
HXDLIN( 469)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            						}
            					}
HXDLIN( 469)					Float a16 = v_ay1;
HXDLIN( 469)					Float b17 = v_by1;
HXDLIN( 469)					Float c11 = v_cy1;
HXDLIN( 469)					if ((a16 > b17)) {
HXDLIN( 469)						if ((a16 > c11)) {
HXDLIN( 469)							int min14;
HXDLIN( 469)							if ((b17 > c11)) {
HXDLIN( 469)								min14 = ::Math_obj::floor(c11);
            							}
            							else {
HXDLIN( 469)								min14 = ::Math_obj::floor(b17);
            							}
HXDLIN( 469)							int ii_min28 = min14;
HXDLIN( 469)							int ii_max28 = ::Math_obj::ceil(a16);
HXDLIN( 469)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            						}
            						else {
HXDLIN( 469)							int ii_min29 = ::Math_obj::floor(b17);
HXDLIN( 469)							int ii_max29 = ::Math_obj::ceil(c11);
HXDLIN( 469)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            						}
            					}
            					else {
HXDLIN( 469)						if ((b17 > c11)) {
HXDLIN( 469)							int min15;
HXDLIN( 469)							if ((a16 > c11)) {
HXDLIN( 469)								min15 = ::Math_obj::floor(c11);
            							}
            							else {
HXDLIN( 469)								min15 = ::Math_obj::ceil(a16);
            							}
HXDLIN( 469)							int ii_min30 = min15;
HXDLIN( 469)							int ii_max30 = ::Math_obj::ceil(b17);
HXDLIN( 469)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            						}
            						else {
HXDLIN( 469)							int ii_min31 = ::Math_obj::floor(a16);
HXDLIN( 469)							int ii_max31 = ::Math_obj::ceil(c11);
HXDLIN( 469)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            						}
            					}
            				}
HXDLIN( 469)				if (hasUndo1) {
HXDLIN( 469)					v_undoImage1 = undoImage3;
HXDLIN( 469)					v_undoX1 = xIter31->start;
HXDLIN( 469)					v_undoY1 = yIter31->start;
            				}
HXDLIN( 469)				 ::pi_xy::algo::HitQuad v4 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 469)				hitQuad = v4;
            			}
            			else {
HXDLIN( 469)				Float sin2 = ::Math_obj::sin(theta);
HXDLIN( 469)				Float cos2 = ::Math_obj::cos(theta);
HXDLIN( 469)				Float radius11 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN( 469)				Float radius22 = (thick / ( (Float)(2) ));
HXDLIN( 469)				Float dx3 = ((Float)0.1);
HXDLIN( 469)				Float dy3 = radius11;
HXDLIN( 469)				Float cx5 = h2;
HXDLIN( 469)				Float cy5 = radius22;
HXDLIN( 469)				Float bx5 = h2;
HXDLIN( 469)				Float by5 = -(radius22);
HXDLIN( 469)				Float ax3 = ((Float)0.1);
HXDLIN( 469)				Float ay3 = -(radius11);
HXDLIN( 469)				Float temp1 = ((Float)0.);
HXLINE( 240)				temp1 = (px + ((ax3 * cos2) - (ay3 * sin2)));
HXLINE( 241)				ay3 = (py + ((ay3 * cos2) + (ax3 * sin2)));
HXLINE( 242)				ax3 = temp1;
HXLINE( 244)				temp1 = (px + ((bx5 * cos2) - (by5 * sin2)));
HXLINE( 245)				by5 = (py + ((by5 * cos2) + (bx5 * sin2)));
HXLINE( 246)				bx5 = temp1;
HXLINE( 248)				temp1 = (px + ((cx5 * cos2) - (cy5 * sin2)));
HXLINE( 249)				cy5 = (py + ((cy5 * cos2) + (cx5 * sin2)));
HXLINE( 250)				cx5 = temp1;
HXLINE( 252)				temp1 = (px + ((dx3 * cos2) - (dy3 * sin2)));
HXLINE( 253)				dy3 = (py + ((dy3 * cos2) + (dx3 * sin2)));
HXLINE( 254)				dx3 = temp1;
HXLINE( 469)				Float bx6 = bx5;
HXDLIN( 469)				Float by6 = by5;
HXDLIN( 469)				Float cx6 = dx3;
HXDLIN( 469)				Float cy6 = dy3;
HXDLIN( 469)				bool hasUndo2 = false;
HXDLIN( 469)				bool adjustWinding4 = (((((ax3 * by6) - (bx6 * ay3)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * ay3) - (ax3 * cy6))) > 0);
HXDLIN( 469)				if (!(adjustWinding4)) {
HXDLIN( 469)					Float bx_4 = bx6;
HXDLIN( 469)					Float by_4 = by6;
HXLINE(  25)					bx6 = cx6;
HXLINE(  26)					by6 = cy6;
HXLINE(  27)					cx6 = bx_4;
HXLINE(  28)					cy6 = by_4;
            				}
HXLINE( 469)				Float s02 = ((ay3 * cx6) - (ax3 * cy6));
HXDLIN( 469)				Float sx2 = (cy6 - ay3);
HXDLIN( 469)				Float sy2 = (ax3 - cx6);
HXDLIN( 469)				Float t02 = ((ax3 * by6) - (ay3 * bx6));
HXDLIN( 469)				Float tx2 = (ay3 - by6);
HXDLIN( 469)				Float ty2 = (bx6 - ax3);
HXDLIN( 469)				Float A2 = ((((-(by6) * cx6) + (ay3 * (-(bx6) + cx6))) + (ax3 * (by6 - cy6))) + (bx6 * cy6));
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 469)				if ((ax3 > bx6)) {
HXDLIN( 469)					if ((ax3 > cx6)) {
HXDLIN( 469)						int min16;
HXDLIN( 469)						if ((bx6 > cx6)) {
HXDLIN( 469)							min16 = ::Math_obj::floor(cx6);
            						}
            						else {
HXDLIN( 469)							min16 = ::Math_obj::floor(bx6);
            						}
HXDLIN( 469)						int ii_min32 = min16;
HXDLIN( 469)						int ii_max32 = ::Math_obj::ceil(ax3);
HXDLIN( 469)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            					}
            					else {
HXDLIN( 469)						int ii_min33 = ::Math_obj::floor(bx6);
HXDLIN( 469)						int ii_max33 = ::Math_obj::ceil(cx6);
HXDLIN( 469)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            					}
            				}
            				else {
HXDLIN( 469)					if ((bx6 > cx6)) {
HXDLIN( 469)						int min17;
HXDLIN( 469)						if ((ax3 > cx6)) {
HXDLIN( 469)							min17 = ::Math_obj::floor(cx6);
            						}
            						else {
HXDLIN( 469)							min17 = ::Math_obj::ceil(ax3);
            						}
HXDLIN( 469)						int ii_min34 = min17;
HXDLIN( 469)						int ii_max34 = ::Math_obj::ceil(bx6);
HXDLIN( 469)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            					}
            					else {
HXDLIN( 469)						int ii_min35 = ::Math_obj::floor(ax3);
HXDLIN( 469)						int ii_max35 = ::Math_obj::ceil(cx6);
HXDLIN( 469)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            					}
            				}
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 469)				if ((ay3 > by6)) {
HXDLIN( 469)					if ((ay3 > cy6)) {
HXDLIN( 469)						int min18;
HXDLIN( 469)						if ((by6 > cy6)) {
HXDLIN( 469)							min18 = ::Math_obj::floor(cy6);
            						}
            						else {
HXDLIN( 469)							min18 = ::Math_obj::floor(by6);
            						}
HXDLIN( 469)						int ii_min36 = min18;
HXDLIN( 469)						int ii_max36 = ::Math_obj::ceil(ay3);
HXDLIN( 469)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            					}
            					else {
HXDLIN( 469)						int ii_min37 = ::Math_obj::floor(by6);
HXDLIN( 469)						int ii_max37 = ::Math_obj::ceil(cy6);
HXDLIN( 469)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            					}
            				}
            				else {
HXDLIN( 469)					if ((by6 > cy6)) {
HXDLIN( 469)						int min19;
HXDLIN( 469)						if ((ay3 > cy6)) {
HXDLIN( 469)							min19 = ::Math_obj::floor(cy6);
            						}
            						else {
HXDLIN( 469)							min19 = ::Math_obj::ceil(ay3);
            						}
HXDLIN( 469)						int ii_min38 = min19;
HXDLIN( 469)						int ii_max38 = ::Math_obj::ceil(by6);
HXDLIN( 469)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            					}
            					else {
HXDLIN( 469)						int ii_min39 = ::Math_obj::floor(ay3);
HXDLIN( 469)						int ii_max39 = ::Math_obj::ceil(cy6);
HXDLIN( 469)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            					}
            				}
HXDLIN( 469)				 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 469)				if (hasUndo2) {
HXDLIN( 469)					int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 469)					int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 469)					 ::Dynamic imageType2 = null();
HXDLIN( 469)					 ::pi_xy::ImageStruct this68 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 469)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 469)					::Dynamic undoImage7;
HXDLIN( 469)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXDLIN( 469)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::BytesImg b18 = byt2;
HXDLIN( 469)							{
HXDLIN( 469)								b18->width = width2;
HXDLIN( 469)								b18->height = height2;
HXDLIN( 469)								b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 469)								b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN( 469)								{
HXDLIN( 469)									int len4 = b18->length;
HXDLIN( 469)									int w2 = 0;
HXDLIN( 469)									{
HXDLIN( 469)										int _g40 = 0;
HXDLIN( 469)										int _g41 = b18->height;
HXDLIN( 469)										while((_g40 < _g41)){
HXDLIN( 469)											_g40 = (_g40 + 1);
HXDLIN( 469)											int y8 = (_g40 - 1);
HXDLIN( 469)											{
HXDLIN( 469)												int _g42 = 0;
HXDLIN( 469)												int _g43 = b18->width;
HXDLIN( 469)												while((_g42 < _g43)){
HXDLIN( 469)													_g42 = (_g42 + 1);
HXDLIN( 469)													int x8 = (_g42 - 1);
HXDLIN( 469)													{
HXDLIN( 469)														w2 = (w2 + 1);
HXDLIN( 469)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w2 = (w2 + 1);
HXDLIN( 469)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w2 = (w2 + 1);
HXDLIN( 469)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w2 = (w2 + 1);
HXDLIN( 469)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage7 = b18;
            						}
            						break;
            						case (int)1: {
HXDLIN( 469)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::ArrIntImg a17 = arrI2;
HXDLIN( 469)							{
HXDLIN( 469)								a17->width = width2;
HXDLIN( 469)								a17->height = height2;
HXDLIN( 469)								a17->data = ::Array_obj< int >::__new(0);
HXDLIN( 469)								a17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 469)								{
HXDLIN( 469)									int _g44 = 0;
HXDLIN( 469)									int _g45 = a17->length;
HXDLIN( 469)									while((_g44 < _g45)){
HXDLIN( 469)										_g44 = (_g44 + 1);
HXDLIN( 469)										int i12 = (_g44 - 1);
HXDLIN( 469)										a17->data[i12] = 0;
            									}
            								}
            							}
HXDLIN( 469)							undoImage7 = a17;
            						}
            						break;
            						case (int)2: {
HXDLIN( 469)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::U32ArrImg b19 = u32a2;
HXDLIN( 469)							{
HXDLIN( 469)								b19->width = width2;
HXDLIN( 469)								b19->height = height2;
HXDLIN( 469)								b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 469)								int size2 = (b19->length * 4);
HXDLIN( 469)								b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 469)								{
HXDLIN( 469)									int _g46 = 0;
HXDLIN( 469)									int _g47 = b19->length;
HXDLIN( 469)									while((_g46 < _g47)){
HXDLIN( 469)										_g46 = (_g46 + 1);
HXDLIN( 469)										int i13 = (_g46 - 1);
HXDLIN( 469)										{
HXDLIN( 469)											 ::haxe::io::ArrayBufferViewImpl this69 = b19->data;
HXDLIN( 469)											bool undoImage8;
HXDLIN( 469)											if ((i13 >= 0)) {
HXDLIN( 469)												undoImage8 = (i13 < (this69->byteLength >> 2));
            											}
            											else {
HXDLIN( 469)												undoImage8 = false;
            											}
HXDLIN( 469)											if (undoImage8) {
HXDLIN( 469)												 ::haxe::io::Bytes _this2 = this69->bytes;
HXDLIN( 469)												int pos2 = ((i13 << 2) + this69->byteOffset);
HXDLIN( 469)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 469)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 469)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 469)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage7 = b19;
            						}
            						break;
            						case (int)3: {
HXDLIN( 469)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN( 469)							{
HXDLIN( 469)								v5->width = width2;
HXDLIN( 469)								v5->height = height2;
HXDLIN( 469)								v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 469)								v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN( 469)								{
HXDLIN( 469)									int _g48 = 0;
HXDLIN( 469)									int _g49 = v5->length;
HXDLIN( 469)									while((_g48 < _g49)){
HXDLIN( 469)										_g48 = (_g48 + 1);
HXDLIN( 469)										int i14 = (_g48 - 1);
HXDLIN( 469)										v5->data->__unsafe_set(i14,0);
            									}
            								}
            							}
HXDLIN( 469)							undoImage7 = v5;
            						}
            						break;
            						case (int)4: {
HXDLIN( 469)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::StackIntImg b20 = sInt2;
HXDLIN( 469)							{
HXDLIN( 469)								b20->width = width2;
HXDLIN( 469)								b20->height = height2;
HXDLIN( 469)								b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 469)								b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 469)								{
HXDLIN( 469)									int len5 = b20->length;
HXDLIN( 469)									 ::haxe::ds::GenericStack_Int d2 = b20->data;
HXDLIN( 469)									if (::hx::IsNull( d2->head )) {
HXDLIN( 469)										int _g50 = 0;
HXDLIN( 469)										int _g51 = len5;
HXDLIN( 469)										while((_g50 < _g51)){
HXDLIN( 469)											_g50 = (_g50 + 1);
HXDLIN( 469)											int i15 = (_g50 - 1);
HXDLIN( 469)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXDLIN( 469)										int _g52 = 0;
HXDLIN( 469)										int _g53 = len5;
HXDLIN( 469)										while((_g52 < _g53)){
HXDLIN( 469)											_g52 = (_g52 + 1);
HXDLIN( 469)											int i16 = (_g52 - 1);
HXDLIN( 469)											{
HXDLIN( 469)												 ::haxe::ds::GenericCell_Int l2 = b20->data->head;
HXDLIN( 469)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 469)												{
HXDLIN( 469)													int _g54 = 0;
HXDLIN( 469)													int _g55 = i16;
HXDLIN( 469)													while((_g54 < _g55)){
HXDLIN( 469)														_g54 = (_g54 + 1);
HXDLIN( 469)														int i17 = (_g54 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE( 469)												if (::hx::IsNull( prev2 )) {
HXDLIN( 469)													b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 469)													l2 = null();
            												}
            												else {
HXDLIN( 469)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 469)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage7 = b20;
            						}
            						break;
            					}
HXDLIN( 469)					this68->image = undoImage7;
HXDLIN( 469)					this68->width = width2;
HXDLIN( 469)					this68->height = height2;
HXDLIN( 469)					this68->imageType = ( (int)(imageType2) );
HXDLIN( 469)					undoImage6 = this68;
HXDLIN( 469)					{
HXDLIN( 469)						int rectLeft2 = xIter32->start;
HXDLIN( 469)						int rectTop2 = yIter32->start;
HXDLIN( 469)						int rectRight2 = xIter32->max;
HXDLIN( 469)						bool forceClear2 = false;
HXDLIN( 469)						{
HXDLIN( 469)							int _g56 = rectTop2;
HXDLIN( 469)							int _g57 = yIter32->max;
HXDLIN( 469)							while((_g56 < _g57)){
HXDLIN( 469)								_g56 = (_g56 + 1);
HXDLIN( 469)								int dy4 = (_g56 - 1);
HXDLIN( 469)								{
HXDLIN( 469)									int _g58 = rectLeft2;
HXDLIN( 469)									int _g59 = rectRight2;
HXDLIN( 469)									while((_g58 < _g59)){
HXDLIN( 469)										_g58 = (_g58 + 1);
HXDLIN( 469)										int dx4 = (_g58 - 1);
HXDLIN( 469)										::Dynamic this70 = this1->image;
HXDLIN( 469)										int index10;
HXDLIN( 469)										if (this1->useVirtualPos) {
HXDLIN( 469)											index10 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx4) - this1->virtualX));
            										}
            										else {
HXDLIN( 469)											index10 = ::Std_obj::_hx_int(( (Float)(((dy4 * this1->width) + dx4)) ));
            										}
HXDLIN( 469)										int c12 = ::iterMagic::Iimg_obj::get(this70,index10);
HXDLIN( 469)										int col2;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											col2 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											col2 = c12;
            										}
HXDLIN( 469)										bool hitQuad17;
HXDLIN( 469)										if (this1->useMask) {
HXDLIN( 469)											hitQuad17 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 469)											hitQuad17 = false;
            										}
HXDLIN( 469)										if (hitQuad17) {
HXDLIN( 469)											 ::pi_xy::ImageStruct this71 = this1->mask;
HXDLIN( 469)											::Dynamic this72 = this71->image;
HXDLIN( 469)											int index11;
HXDLIN( 469)											if (this71->useVirtualPos) {
HXDLIN( 469)												index11 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this71->virtualY) * ( (Float)(this71->width) )) + dx4) - this71->virtualX));
            											}
            											else {
HXDLIN( 469)												index11 = ::Std_obj::_hx_int(( (Float)(((dy4 * this71->width) + dx4)) ));
            											}
HXDLIN( 469)											int c13 = ::iterMagic::Iimg_obj::get(this72,index11);
HXDLIN( 469)											int v6;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												v6 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												v6 = c13;
            											}
HXDLIN( 469)											int maskPixel2 = v6;
HXDLIN( 469)											int this73 = col2;
HXDLIN( 469)											if ((maskPixel2 == 0)) {
HXDLIN( 469)												col2 = this73;
            											}
            											else {
HXDLIN( 469)												Float m02;
HXDLIN( 469)												int this74 = ((maskPixel2 >> 24) & 255);
HXDLIN( 469)												if ((this74 == 0)) {
HXDLIN( 469)													m02 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m02 = (( (Float)(this74) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m12;
HXDLIN( 469)												int this75 = ((maskPixel2 >> 16) & 255);
HXDLIN( 469)												if ((this75 == 0)) {
HXDLIN( 469)													m12 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m12 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m22;
HXDLIN( 469)												int this76 = ((maskPixel2 >> 8) & 255);
HXDLIN( 469)												if ((this76 == 0)) {
HXDLIN( 469)													m22 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m22 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m32;
HXDLIN( 469)												int this77 = (maskPixel2 & 255);
HXDLIN( 469)												if ((this77 == 0)) {
HXDLIN( 469)													m32 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m32 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this73 >> 24) & 255)) )));
HXDLIN( 469)												int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this73 >> 16) & 255)) )));
HXDLIN( 469)												int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this73 >> 8) & 255)) )));
HXDLIN( 469)												int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this73 & 255)) )));
HXDLIN( 469)												col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 469)										if ((col2 != 0)) {
HXDLIN( 469)											int x9 = (dx4 - rectLeft2);
HXDLIN( 469)											int y9 = (dy4 - rectTop2);
HXDLIN( 469)											int c14 = col2;
HXDLIN( 469)											bool hitQuad18;
HXDLIN( 469)											if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 469)												hitQuad18 = undoImage6->transparent;
            											}
            											else {
HXDLIN( 469)												hitQuad18 = false;
            											}
HXDLIN( 469)											if (hitQuad18) {
HXDLIN( 469)												int location4;
HXDLIN( 469)												if (undoImage6->useVirtualPos) {
HXDLIN( 469)													location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            												}
            												else {
HXDLIN( 469)													location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            												}
HXDLIN( 469)												int this78 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 469)												int this79;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													this79 = ((((((this78 >> 24) & 255) << 24) | ((this78 & 255) << 16)) | (((this78 >> 8) & 255) << 8)) | ((this78 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													this79 = this78;
            												}
HXDLIN( 469)												Float a18;
HXDLIN( 469)												int this80 = ((this79 >> 24) & 255);
HXDLIN( 469)												if ((this80 == 0)) {
HXDLIN( 469)													a18 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a18 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r14;
HXDLIN( 469)												int this81 = ((this79 >> 16) & 255);
HXDLIN( 469)												if ((this81 == 0)) {
HXDLIN( 469)													r14 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r14 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g14;
HXDLIN( 469)												int this82 = ((this79 >> 8) & 255);
HXDLIN( 469)												if ((this82 == 0)) {
HXDLIN( 469)													g14 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g14 = (( (Float)(this82) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b110;
HXDLIN( 469)												int this83 = (this79 & 255);
HXDLIN( 469)												if ((this83 == 0)) {
HXDLIN( 469)													b110 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b110 = (( (Float)(this83) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a24;
HXDLIN( 469)												int this84 = ((col2 >> 24) & 255);
HXDLIN( 469)												if ((this84 == 0)) {
HXDLIN( 469)													a24 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a24 = (( (Float)(this84) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r24;
HXDLIN( 469)												int this85 = ((col2 >> 16) & 255);
HXDLIN( 469)												if ((this85 == 0)) {
HXDLIN( 469)													r24 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r24 = (( (Float)(this85) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g24;
HXDLIN( 469)												int this86 = ((col2 >> 8) & 255);
HXDLIN( 469)												if ((this86 == 0)) {
HXDLIN( 469)													g24 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g24 = (( (Float)(this86) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b25;
HXDLIN( 469)												int this87 = (col2 & 255);
HXDLIN( 469)												if ((this87 == 0)) {
HXDLIN( 469)													b25 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b25 = (( (Float)(this87) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a34 = (a18 * (( (Float)(1) ) - a24));
HXDLIN( 469)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 469)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 469)												int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN( 469)												int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 469)												int blended4 = ((((a19 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN( 469)												{
HXDLIN( 469)													int hitQuad19;
HXDLIN( 469)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)														hitQuad19 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXDLIN( 469)														hitQuad19 = blended4;
            													}
HXDLIN( 469)													::iterMagic::Iimg_obj::set(undoImage6->image,location4,hitQuad19);
            												}
            											}
            											else {
HXDLIN( 469)												::Dynamic this88 = undoImage6->image;
HXDLIN( 469)												int index12;
HXDLIN( 469)												if (undoImage6->useVirtualPos) {
HXDLIN( 469)													index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            												}
            												else {
HXDLIN( 469)													index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            												}
HXDLIN( 469)												int hitQuad20;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad20 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad20 = c14;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this88,index12,hitQuad20);
            											}
            										}
            										else {
HXDLIN( 469)											if (forceClear2) {
HXDLIN( 469)												::Dynamic this89 = undoImage6->image;
HXDLIN( 469)												int x10 = (dx4 - rectLeft2);
HXDLIN( 469)												int y10 = (dy4 - rectTop2);
HXDLIN( 469)												int index13;
HXDLIN( 469)												if (undoImage6->useVirtualPos) {
HXDLIN( 469)													index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            												}
            												else {
HXDLIN( 469)													index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this89,index13,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 469)				bool found2 = false;
HXDLIN( 469)				Float s2 = ((Float)0.);
HXDLIN( 469)				Float t2 = ((Float)0.);
HXDLIN( 469)				Float sxx2 = ((Float)0.);
HXDLIN( 469)				Float txx2 = ((Float)0.);
HXDLIN( 469)				{
HXDLIN( 469)					int _g_min4 = xIter32->start;
HXDLIN( 469)					int _g_max4 = xIter32->max;
HXDLIN( 469)					while((_g_min4 < _g_max4)){
HXDLIN( 469)						_g_min4 = (_g_min4 + 1);
HXDLIN( 469)						int x11 = (_g_min4 - 1);
HXLINE(  60)						sxx2 = (sx2 * ( (Float)(x11) ));
HXLINE(  61)						txx2 = (tx2 * ( (Float)(x11) ));
HXLINE(  62)						found2 = false;
HXLINE( 469)						{
HXDLIN( 469)							int _g_min5 = yIter32->start;
HXDLIN( 469)							int _g_max5 = yIter32->max;
HXDLIN( 469)							while((_g_min5 < _g_max5)){
HXDLIN( 469)								_g_min5 = (_g_min5 + 1);
HXDLIN( 469)								int y11 = (_g_min5 - 1);
HXLINE(  64)								s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y11) )));
HXLINE(  65)								t2 = ((t02 + txx2) + (ty2 * ( (Float)(y11) )));
HXLINE( 469)								bool hitQuad21;
HXDLIN( 469)								if (!((s2 <= 0))) {
HXDLIN( 469)									hitQuad21 = (t2 <= 0);
            								}
            								else {
HXDLIN( 469)									hitQuad21 = true;
            								}
HXDLIN( 469)								if (hitQuad21) {
HXDLIN( 469)									if (found2) {
HXDLIN( 469)										goto _hx_goto_811;
            									}
            								}
            								else {
HXDLIN( 469)									if (((s2 + t2) < A2)) {
HXDLIN( 469)										{
HXDLIN( 469)											int c15 = color;
HXDLIN( 469)											bool hitQuad22;
HXDLIN( 469)											if ((((c15 >> 24) & 255) < 254)) {
HXDLIN( 469)												hitQuad22 = this1->transparent;
            											}
            											else {
HXDLIN( 469)												hitQuad22 = false;
            											}
HXDLIN( 469)											if (hitQuad22) {
HXDLIN( 469)												int location5;
HXDLIN( 469)												if (this1->useVirtualPos) {
HXDLIN( 469)													location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            												}
            												else {
HXDLIN( 469)													location5 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            												}
HXDLIN( 469)												int this90 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 469)												int this91;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													this91 = this90;
            												}
HXDLIN( 469)												Float a110;
HXDLIN( 469)												int this92 = ((this91 >> 24) & 255);
HXDLIN( 469)												if ((this92 == 0)) {
HXDLIN( 469)													a110 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a110 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r15;
HXDLIN( 469)												int this93 = ((this91 >> 16) & 255);
HXDLIN( 469)												if ((this93 == 0)) {
HXDLIN( 469)													r15 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r15 = (( (Float)(this93) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g15;
HXDLIN( 469)												int this94 = ((this91 >> 8) & 255);
HXDLIN( 469)												if ((this94 == 0)) {
HXDLIN( 469)													g15 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g15 = (( (Float)(this94) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b111;
HXDLIN( 469)												int this95 = (this91 & 255);
HXDLIN( 469)												if ((this95 == 0)) {
HXDLIN( 469)													b111 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b111 = (( (Float)(this95) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a25;
HXDLIN( 469)												int this96 = ((color >> 24) & 255);
HXDLIN( 469)												if ((this96 == 0)) {
HXDLIN( 469)													a25 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a25 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r25;
HXDLIN( 469)												int this97 = ((color >> 16) & 255);
HXDLIN( 469)												if ((this97 == 0)) {
HXDLIN( 469)													r25 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r25 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g25;
HXDLIN( 469)												int this98 = ((color >> 8) & 255);
HXDLIN( 469)												if ((this98 == 0)) {
HXDLIN( 469)													g25 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g25 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b27;
HXDLIN( 469)												int this99 = (color & 255);
HXDLIN( 469)												if ((this99 == 0)) {
HXDLIN( 469)													b27 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b27 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 469)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 469)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 469)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b27 * a25))));
HXDLIN( 469)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 469)												int blended5 = ((((a20 << 24) | (r7 << 16)) | (g7 << 8)) | b28);
HXDLIN( 469)												{
HXDLIN( 469)													int hitQuad23;
HXDLIN( 469)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)														hitQuad23 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXDLIN( 469)														hitQuad23 = blended5;
            													}
HXDLIN( 469)													::iterMagic::Iimg_obj::set(this1->image,location5,hitQuad23);
            												}
            											}
            											else {
HXDLIN( 469)												::Dynamic this100 = this1->image;
HXDLIN( 469)												int index14;
HXDLIN( 469)												if (this1->useVirtualPos) {
HXDLIN( 469)													index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            												}
            												else {
HXDLIN( 469)													index14 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            												}
HXDLIN( 469)												int hitQuad24;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad24 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad24 = c15;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this100,index14,hitQuad24);
            											}
            										}
HXLINE(  73)										found2 = true;
            									}
            									else {
HXDLIN( 469)										if (found2) {
HXDLIN( 469)											goto _hx_goto_811;
            										}
            									}
            								}
            							}
            							_hx_goto_811:;
            						}
            					}
            				}
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart v_yIter32;
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart v_xIter32;
HXDLIN( 469)				int v_undoY2;
HXDLIN( 469)				int v_undoX2;
HXDLIN( 469)				Float v_ty2;
HXDLIN( 469)				Float v_tx2;
HXDLIN( 469)				Float v_t02;
HXDLIN( 469)				Float v_sy2;
HXDLIN( 469)				Float v_sx2;
HXDLIN( 469)				Float v_s02;
HXDLIN( 469)				Float v_A2;
HXDLIN( 469)				Float ax4 = ax3;
HXDLIN( 469)				Float ay4 = ay3;
HXDLIN( 469)				 ::pi_xy::ImageStruct v_undoImage2 = null();
HXDLIN( 469)				Float bx7 = bx6;
HXDLIN( 469)				Float by7 = by6;
HXDLIN( 469)				Float cx7 = cx6;
HXDLIN( 469)				Float cy7 = cy6;
HXDLIN( 469)				bool adjustWinding5 = (((((ax4 * by7) - (bx7 * ay4)) + ((bx7 * cy7) - (cx7 * by7))) + ((cx7 * ay4) - (ax4 * cy7))) > 0);
HXDLIN( 469)				if (!(adjustWinding5)) {
HXDLIN( 469)					Float bx_5 = bx7;
HXDLIN( 469)					Float by_5 = by7;
HXLINE(  24)					bx7 = cx7;
HXLINE(  25)					by7 = cy7;
HXLINE(  26)					cx7 = bx_5;
HXLINE(  27)					cy7 = by_5;
            				}
HXLINE( 469)				Float v_ax2 = ax4;
HXDLIN( 469)				Float v_ay2 = ay4;
HXDLIN( 469)				Float v_bx2 = bx7;
HXDLIN( 469)				Float v_by2 = by7;
HXDLIN( 469)				Float v_cx2 = cx7;
HXDLIN( 469)				Float v_cy2 = cy7;
HXDLIN( 469)				bool v_preCalculated2 = true;
HXDLIN( 469)				{
HXDLIN( 469)					v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN( 469)					v_sx2 = (v_cy2 - v_ay2);
HXDLIN( 469)					v_sy2 = (v_ax2 - v_cx2);
HXDLIN( 469)					v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN( 469)					v_tx2 = (v_ay2 - v_by2);
HXDLIN( 469)					v_ty2 = (v_bx2 - v_ax2);
HXDLIN( 469)					v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN( 469)					Float a26 = v_ax2;
HXDLIN( 469)					Float b29 = v_bx2;
HXDLIN( 469)					Float c16 = v_cx2;
HXDLIN( 469)					if ((a26 > b29)) {
HXDLIN( 469)						if ((a26 > c16)) {
HXDLIN( 469)							int min20;
HXDLIN( 469)							if ((b29 > c16)) {
HXDLIN( 469)								min20 = ::Math_obj::floor(c16);
            							}
            							else {
HXDLIN( 469)								min20 = ::Math_obj::floor(b29);
            							}
HXDLIN( 469)							int ii_min40 = min20;
HXDLIN( 469)							int ii_max40 = ::Math_obj::ceil(a26);
HXDLIN( 469)							v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            						}
            						else {
HXDLIN( 469)							int ii_min41 = ::Math_obj::floor(b29);
HXDLIN( 469)							int ii_max41 = ::Math_obj::ceil(c16);
HXDLIN( 469)							v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            						}
            					}
            					else {
HXDLIN( 469)						if ((b29 > c16)) {
HXDLIN( 469)							int min21;
HXDLIN( 469)							if ((a26 > c16)) {
HXDLIN( 469)								min21 = ::Math_obj::floor(c16);
            							}
            							else {
HXDLIN( 469)								min21 = ::Math_obj::ceil(a26);
            							}
HXDLIN( 469)							int ii_min42 = min21;
HXDLIN( 469)							int ii_max42 = ::Math_obj::ceil(b29);
HXDLIN( 469)							v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            						}
            						else {
HXDLIN( 469)							int ii_min43 = ::Math_obj::floor(a26);
HXDLIN( 469)							int ii_max43 = ::Math_obj::ceil(c16);
HXDLIN( 469)							v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            						}
            					}
HXDLIN( 469)					Float a27 = v_ay2;
HXDLIN( 469)					Float b30 = v_by2;
HXDLIN( 469)					Float c17 = v_cy2;
HXDLIN( 469)					if ((a27 > b30)) {
HXDLIN( 469)						if ((a27 > c17)) {
HXDLIN( 469)							int min22;
HXDLIN( 469)							if ((b30 > c17)) {
HXDLIN( 469)								min22 = ::Math_obj::floor(c17);
            							}
            							else {
HXDLIN( 469)								min22 = ::Math_obj::floor(b30);
            							}
HXDLIN( 469)							int ii_min44 = min22;
HXDLIN( 469)							int ii_max44 = ::Math_obj::ceil(a27);
HXDLIN( 469)							v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            						}
            						else {
HXDLIN( 469)							int ii_min45 = ::Math_obj::floor(b30);
HXDLIN( 469)							int ii_max45 = ::Math_obj::ceil(c17);
HXDLIN( 469)							v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            						}
            					}
            					else {
HXDLIN( 469)						if ((b30 > c17)) {
HXDLIN( 469)							int min23;
HXDLIN( 469)							if ((a27 > c17)) {
HXDLIN( 469)								min23 = ::Math_obj::floor(c17);
            							}
            							else {
HXDLIN( 469)								min23 = ::Math_obj::ceil(a27);
            							}
HXDLIN( 469)							int ii_min46 = min23;
HXDLIN( 469)							int ii_max46 = ::Math_obj::ceil(b30);
HXDLIN( 469)							v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            						}
            						else {
HXDLIN( 469)							int ii_min47 = ::Math_obj::floor(a27);
HXDLIN( 469)							int ii_max47 = ::Math_obj::ceil(c17);
HXDLIN( 469)							v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            						}
            					}
            				}
HXDLIN( 469)				if (hasUndo2) {
HXDLIN( 469)					v_undoImage2 = undoImage6;
HXDLIN( 469)					v_undoX2 = xIter32->start;
HXDLIN( 469)					v_undoY2 = yIter32->start;
            				}
HXDLIN( 469)				Float bx8 = cx5;
HXDLIN( 469)				Float by8 = cy5;
HXDLIN( 469)				Float cx8 = dx3;
HXDLIN( 469)				Float cy8 = dy3;
HXDLIN( 469)				bool hasUndo3 = false;
HXDLIN( 469)				bool adjustWinding6 = (((((bx5 * by8) - (bx8 * by5)) + ((bx8 * cy8) - (cx8 * by8))) + ((cx8 * by5) - (bx5 * cy8))) > 0);
HXDLIN( 469)				if (!(adjustWinding6)) {
HXDLIN( 469)					Float bx_6 = bx8;
HXDLIN( 469)					Float by_6 = by8;
HXLINE(  25)					bx8 = cx8;
HXLINE(  26)					by8 = cy8;
HXLINE(  27)					cx8 = bx_6;
HXLINE(  28)					cy8 = by_6;
            				}
HXLINE( 469)				Float s03 = ((by5 * cx8) - (bx5 * cy8));
HXDLIN( 469)				Float sx3 = (cy8 - by5);
HXDLIN( 469)				Float sy3 = (bx5 - cx8);
HXDLIN( 469)				Float t03 = ((bx5 * by8) - (by5 * bx8));
HXDLIN( 469)				Float tx3 = (by5 - by8);
HXDLIN( 469)				Float ty3 = (bx8 - bx5);
HXDLIN( 469)				Float A3 = ((((-(by8) * cx8) + (by5 * (-(bx8) + cx8))) + (bx5 * (by8 - cy8))) + (bx8 * cy8));
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 469)				if ((bx5 > bx8)) {
HXDLIN( 469)					if ((bx5 > cx8)) {
HXDLIN( 469)						int min24;
HXDLIN( 469)						if ((bx8 > cx8)) {
HXDLIN( 469)							min24 = ::Math_obj::floor(cx8);
            						}
            						else {
HXDLIN( 469)							min24 = ::Math_obj::floor(bx8);
            						}
HXDLIN( 469)						int ii_min48 = min24;
HXDLIN( 469)						int ii_max48 = ::Math_obj::ceil(bx5);
HXDLIN( 469)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            					}
            					else {
HXDLIN( 469)						int ii_min49 = ::Math_obj::floor(bx8);
HXDLIN( 469)						int ii_max49 = ::Math_obj::ceil(cx8);
HXDLIN( 469)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            					}
            				}
            				else {
HXDLIN( 469)					if ((bx8 > cx8)) {
HXDLIN( 469)						int min25;
HXDLIN( 469)						if ((bx5 > cx8)) {
HXDLIN( 469)							min25 = ::Math_obj::floor(cx8);
            						}
            						else {
HXDLIN( 469)							min25 = ::Math_obj::ceil(bx5);
            						}
HXDLIN( 469)						int ii_min50 = min25;
HXDLIN( 469)						int ii_max50 = ::Math_obj::ceil(bx8);
HXDLIN( 469)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            					}
            					else {
HXDLIN( 469)						int ii_min51 = ::Math_obj::floor(bx5);
HXDLIN( 469)						int ii_max51 = ::Math_obj::ceil(cx8);
HXDLIN( 469)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            					}
            				}
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 469)				if ((by5 > by8)) {
HXDLIN( 469)					if ((by5 > cy8)) {
HXDLIN( 469)						int min26;
HXDLIN( 469)						if ((by8 > cy8)) {
HXDLIN( 469)							min26 = ::Math_obj::floor(cy8);
            						}
            						else {
HXDLIN( 469)							min26 = ::Math_obj::floor(by8);
            						}
HXDLIN( 469)						int ii_min52 = min26;
HXDLIN( 469)						int ii_max52 = ::Math_obj::ceil(by5);
HXDLIN( 469)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            					}
            					else {
HXDLIN( 469)						int ii_min53 = ::Math_obj::floor(by8);
HXDLIN( 469)						int ii_max53 = ::Math_obj::ceil(cy8);
HXDLIN( 469)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            					}
            				}
            				else {
HXDLIN( 469)					if ((by8 > cy8)) {
HXDLIN( 469)						int min27;
HXDLIN( 469)						if ((by5 > cy8)) {
HXDLIN( 469)							min27 = ::Math_obj::floor(cy8);
            						}
            						else {
HXDLIN( 469)							min27 = ::Math_obj::ceil(by5);
            						}
HXDLIN( 469)						int ii_min54 = min27;
HXDLIN( 469)						int ii_max54 = ::Math_obj::ceil(by8);
HXDLIN( 469)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            					}
            					else {
HXDLIN( 469)						int ii_min55 = ::Math_obj::floor(by5);
HXDLIN( 469)						int ii_max55 = ::Math_obj::ceil(cy8);
HXDLIN( 469)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            					}
            				}
HXDLIN( 469)				 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 469)				if (hasUndo3) {
HXDLIN( 469)					int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 469)					int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 469)					 ::Dynamic imageType3 = null();
HXDLIN( 469)					 ::pi_xy::ImageStruct this101 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 469)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 469)					::Dynamic undoImage10;
HXDLIN( 469)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXDLIN( 469)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::BytesImg b31 = byt3;
HXDLIN( 469)							{
HXDLIN( 469)								b31->width = width3;
HXDLIN( 469)								b31->height = height3;
HXDLIN( 469)								b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 469)								b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 469)								{
HXDLIN( 469)									int len6 = b31->length;
HXDLIN( 469)									int w3 = 0;
HXDLIN( 469)									{
HXDLIN( 469)										int _g60 = 0;
HXDLIN( 469)										int _g61 = b31->height;
HXDLIN( 469)										while((_g60 < _g61)){
HXDLIN( 469)											_g60 = (_g60 + 1);
HXDLIN( 469)											int y12 = (_g60 - 1);
HXDLIN( 469)											{
HXDLIN( 469)												int _g62 = 0;
HXDLIN( 469)												int _g63 = b31->width;
HXDLIN( 469)												while((_g62 < _g63)){
HXDLIN( 469)													_g62 = (_g62 + 1);
HXDLIN( 469)													int x12 = (_g62 - 1);
HXDLIN( 469)													{
HXDLIN( 469)														w3 = (w3 + 1);
HXDLIN( 469)														b31->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w3 = (w3 + 1);
HXDLIN( 469)														b31->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w3 = (w3 + 1);
HXDLIN( 469)														b31->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 469)													{
HXDLIN( 469)														w3 = (w3 + 1);
HXDLIN( 469)														b31->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage10 = b31;
            						}
            						break;
            						case (int)1: {
HXDLIN( 469)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::ArrIntImg a28 = arrI3;
HXDLIN( 469)							{
HXDLIN( 469)								a28->width = width3;
HXDLIN( 469)								a28->height = height3;
HXDLIN( 469)								a28->data = ::Array_obj< int >::__new(0);
HXDLIN( 469)								a28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 469)								{
HXDLIN( 469)									int _g64 = 0;
HXDLIN( 469)									int _g65 = a28->length;
HXDLIN( 469)									while((_g64 < _g65)){
HXDLIN( 469)										_g64 = (_g64 + 1);
HXDLIN( 469)										int i18 = (_g64 - 1);
HXDLIN( 469)										a28->data[i18] = 0;
            									}
            								}
            							}
HXDLIN( 469)							undoImage10 = a28;
            						}
            						break;
            						case (int)2: {
HXDLIN( 469)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::U32ArrImg b32 = u32a3;
HXDLIN( 469)							{
HXDLIN( 469)								b32->width = width3;
HXDLIN( 469)								b32->height = height3;
HXDLIN( 469)								b32->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 469)								int size3 = (b32->length * 4);
HXDLIN( 469)								b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 469)								{
HXDLIN( 469)									int _g66 = 0;
HXDLIN( 469)									int _g67 = b32->length;
HXDLIN( 469)									while((_g66 < _g67)){
HXDLIN( 469)										_g66 = (_g66 + 1);
HXDLIN( 469)										int i19 = (_g66 - 1);
HXDLIN( 469)										{
HXDLIN( 469)											 ::haxe::io::ArrayBufferViewImpl this102 = b32->data;
HXDLIN( 469)											bool undoImage11;
HXDLIN( 469)											if ((i19 >= 0)) {
HXDLIN( 469)												undoImage11 = (i19 < (this102->byteLength >> 2));
            											}
            											else {
HXDLIN( 469)												undoImage11 = false;
            											}
HXDLIN( 469)											if (undoImage11) {
HXDLIN( 469)												 ::haxe::io::Bytes _this3 = this102->bytes;
HXDLIN( 469)												int pos3 = ((i19 << 2) + this102->byteOffset);
HXDLIN( 469)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 469)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 469)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 469)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage10 = b32;
            						}
            						break;
            						case (int)3: {
HXDLIN( 469)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::VecIntImg v7 = vec3;
HXDLIN( 469)							{
HXDLIN( 469)								v7->width = width3;
HXDLIN( 469)								v7->height = height3;
HXDLIN( 469)								v7->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 469)								v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN( 469)								{
HXDLIN( 469)									int _g68 = 0;
HXDLIN( 469)									int _g69 = v7->length;
HXDLIN( 469)									while((_g68 < _g69)){
HXDLIN( 469)										_g68 = (_g68 + 1);
HXDLIN( 469)										int i20 = (_g68 - 1);
HXDLIN( 469)										v7->data->__unsafe_set(i20,0);
            									}
            								}
            							}
HXDLIN( 469)							undoImage10 = v7;
            						}
            						break;
            						case (int)4: {
HXDLIN( 469)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)							 ::iterMagic::StackIntImg b33 = sInt3;
HXDLIN( 469)							{
HXDLIN( 469)								b33->width = width3;
HXDLIN( 469)								b33->height = height3;
HXDLIN( 469)								b33->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 469)								b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 469)								{
HXDLIN( 469)									int len7 = b33->length;
HXDLIN( 469)									 ::haxe::ds::GenericStack_Int d3 = b33->data;
HXDLIN( 469)									if (::hx::IsNull( d3->head )) {
HXDLIN( 469)										int _g70 = 0;
HXDLIN( 469)										int _g71 = len7;
HXDLIN( 469)										while((_g70 < _g71)){
HXDLIN( 469)											_g70 = (_g70 + 1);
HXDLIN( 469)											int i21 = (_g70 - 1);
HXDLIN( 469)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXDLIN( 469)										int _g72 = 0;
HXDLIN( 469)										int _g73 = len7;
HXDLIN( 469)										while((_g72 < _g73)){
HXDLIN( 469)											_g72 = (_g72 + 1);
HXDLIN( 469)											int i22 = (_g72 - 1);
HXDLIN( 469)											{
HXDLIN( 469)												 ::haxe::ds::GenericCell_Int l3 = b33->data->head;
HXDLIN( 469)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 469)												{
HXDLIN( 469)													int _g74 = 0;
HXDLIN( 469)													int _g75 = i22;
HXDLIN( 469)													while((_g74 < _g75)){
HXDLIN( 469)														_g74 = (_g74 + 1);
HXDLIN( 469)														int i23 = (_g74 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE( 469)												if (::hx::IsNull( prev3 )) {
HXDLIN( 469)													b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 469)													l3 = null();
            												}
            												else {
HXDLIN( 469)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 469)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 469)							undoImage10 = b33;
            						}
            						break;
            					}
HXDLIN( 469)					this101->image = undoImage10;
HXDLIN( 469)					this101->width = width3;
HXDLIN( 469)					this101->height = height3;
HXDLIN( 469)					this101->imageType = ( (int)(imageType3) );
HXDLIN( 469)					undoImage9 = this101;
HXDLIN( 469)					{
HXDLIN( 469)						int rectLeft3 = xIter33->start;
HXDLIN( 469)						int rectTop3 = yIter33->start;
HXDLIN( 469)						int rectRight3 = xIter33->max;
HXDLIN( 469)						bool forceClear3 = false;
HXDLIN( 469)						{
HXDLIN( 469)							int _g76 = rectTop3;
HXDLIN( 469)							int _g77 = yIter33->max;
HXDLIN( 469)							while((_g76 < _g77)){
HXDLIN( 469)								_g76 = (_g76 + 1);
HXDLIN( 469)								int dy5 = (_g76 - 1);
HXDLIN( 469)								{
HXDLIN( 469)									int _g78 = rectLeft3;
HXDLIN( 469)									int _g79 = rectRight3;
HXDLIN( 469)									while((_g78 < _g79)){
HXDLIN( 469)										_g78 = (_g78 + 1);
HXDLIN( 469)										int dx5 = (_g78 - 1);
HXDLIN( 469)										::Dynamic this103 = this1->image;
HXDLIN( 469)										int index15;
HXDLIN( 469)										if (this1->useVirtualPos) {
HXDLIN( 469)											index15 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx5) - this1->virtualX));
            										}
            										else {
HXDLIN( 469)											index15 = ::Std_obj::_hx_int(( (Float)(((dy5 * this1->width) + dx5)) ));
            										}
HXDLIN( 469)										int c18 = ::iterMagic::Iimg_obj::get(this103,index15);
HXDLIN( 469)										int col3;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											col3 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											col3 = c18;
            										}
HXDLIN( 469)										bool hitQuad25;
HXDLIN( 469)										if (this1->useMask) {
HXDLIN( 469)											hitQuad25 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 469)											hitQuad25 = false;
            										}
HXDLIN( 469)										if (hitQuad25) {
HXDLIN( 469)											 ::pi_xy::ImageStruct this104 = this1->mask;
HXDLIN( 469)											::Dynamic this105 = this104->image;
HXDLIN( 469)											int index16;
HXDLIN( 469)											if (this104->useVirtualPos) {
HXDLIN( 469)												index16 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this104->virtualY) * ( (Float)(this104->width) )) + dx5) - this104->virtualX));
            											}
            											else {
HXDLIN( 469)												index16 = ::Std_obj::_hx_int(( (Float)(((dy5 * this104->width) + dx5)) ));
            											}
HXDLIN( 469)											int c19 = ::iterMagic::Iimg_obj::get(this105,index16);
HXDLIN( 469)											int v8;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												v8 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												v8 = c19;
            											}
HXDLIN( 469)											int maskPixel3 = v8;
HXDLIN( 469)											int this106 = col3;
HXDLIN( 469)											if ((maskPixel3 == 0)) {
HXDLIN( 469)												col3 = this106;
            											}
            											else {
HXDLIN( 469)												Float m03;
HXDLIN( 469)												int this107 = ((maskPixel3 >> 24) & 255);
HXDLIN( 469)												if ((this107 == 0)) {
HXDLIN( 469)													m03 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m03 = (( (Float)(this107) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m13;
HXDLIN( 469)												int this108 = ((maskPixel3 >> 16) & 255);
HXDLIN( 469)												if ((this108 == 0)) {
HXDLIN( 469)													m13 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m13 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m23;
HXDLIN( 469)												int this109 = ((maskPixel3 >> 8) & 255);
HXDLIN( 469)												if ((this109 == 0)) {
HXDLIN( 469)													m23 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m23 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float m33;
HXDLIN( 469)												int this110 = (maskPixel3 & 255);
HXDLIN( 469)												if ((this110 == 0)) {
HXDLIN( 469)													m33 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													m33 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this106 >> 24) & 255)) )));
HXDLIN( 469)												int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this106 >> 16) & 255)) )));
HXDLIN( 469)												int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this106 >> 8) & 255)) )));
HXDLIN( 469)												int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this106 & 255)) )));
HXDLIN( 469)												col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 469)										if ((col3 != 0)) {
HXDLIN( 469)											int x13 = (dx5 - rectLeft3);
HXDLIN( 469)											int y13 = (dy5 - rectTop3);
HXDLIN( 469)											int c20 = col3;
HXDLIN( 469)											bool hitQuad26;
HXDLIN( 469)											if ((((c20 >> 24) & 255) < 254)) {
HXDLIN( 469)												hitQuad26 = undoImage9->transparent;
            											}
            											else {
HXDLIN( 469)												hitQuad26 = false;
            											}
HXDLIN( 469)											if (hitQuad26) {
HXDLIN( 469)												int location6;
HXDLIN( 469)												if (undoImage9->useVirtualPos) {
HXDLIN( 469)													location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            												}
            												else {
HXDLIN( 469)													location6 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            												}
HXDLIN( 469)												int this111 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 469)												int this112;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													this112 = ((((((this111 >> 24) & 255) << 24) | ((this111 & 255) << 16)) | (((this111 >> 8) & 255) << 8)) | ((this111 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													this112 = this111;
            												}
HXDLIN( 469)												Float a111;
HXDLIN( 469)												int this113 = ((this112 >> 24) & 255);
HXDLIN( 469)												if ((this113 == 0)) {
HXDLIN( 469)													a111 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a111 = (( (Float)(this113) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r16;
HXDLIN( 469)												int this114 = ((this112 >> 16) & 255);
HXDLIN( 469)												if ((this114 == 0)) {
HXDLIN( 469)													r16 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r16 = (( (Float)(this114) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g16;
HXDLIN( 469)												int this115 = ((this112 >> 8) & 255);
HXDLIN( 469)												if ((this115 == 0)) {
HXDLIN( 469)													g16 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g16 = (( (Float)(this115) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b112;
HXDLIN( 469)												int this116 = (this112 & 255);
HXDLIN( 469)												if ((this116 == 0)) {
HXDLIN( 469)													b112 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b112 = (( (Float)(this116) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a29;
HXDLIN( 469)												int this117 = ((col3 >> 24) & 255);
HXDLIN( 469)												if ((this117 == 0)) {
HXDLIN( 469)													a29 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a29 = (( (Float)(this117) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r26;
HXDLIN( 469)												int this118 = ((col3 >> 16) & 255);
HXDLIN( 469)												if ((this118 == 0)) {
HXDLIN( 469)													r26 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r26 = (( (Float)(this118) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g26;
HXDLIN( 469)												int this119 = ((col3 >> 8) & 255);
HXDLIN( 469)												if ((this119 == 0)) {
HXDLIN( 469)													g26 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g26 = (( (Float)(this119) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b210;
HXDLIN( 469)												int this120 = (col3 & 255);
HXDLIN( 469)												if ((this120 == 0)) {
HXDLIN( 469)													b210 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b210 = (( (Float)(this120) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a36 = (a111 * (( (Float)(1) ) - a29));
HXDLIN( 469)												int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a29))));
HXDLIN( 469)												int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a29))));
HXDLIN( 469)												int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a29))));
HXDLIN( 469)												int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a29)));
HXDLIN( 469)												int blended6 = ((((a30 << 24) | (r8 << 16)) | (g8 << 8)) | b34);
HXDLIN( 469)												{
HXDLIN( 469)													int hitQuad27;
HXDLIN( 469)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)														hitQuad27 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXDLIN( 469)														hitQuad27 = blended6;
            													}
HXDLIN( 469)													::iterMagic::Iimg_obj::set(undoImage9->image,location6,hitQuad27);
            												}
            											}
            											else {
HXDLIN( 469)												::Dynamic this121 = undoImage9->image;
HXDLIN( 469)												int index17;
HXDLIN( 469)												if (undoImage9->useVirtualPos) {
HXDLIN( 469)													index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            												}
            												else {
HXDLIN( 469)													index17 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            												}
HXDLIN( 469)												int hitQuad28;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad28 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad28 = c20;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this121,index17,hitQuad28);
            											}
            										}
            										else {
HXDLIN( 469)											if (forceClear3) {
HXDLIN( 469)												::Dynamic this122 = undoImage9->image;
HXDLIN( 469)												int x14 = (dx5 - rectLeft3);
HXDLIN( 469)												int y14 = (dy5 - rectTop3);
HXDLIN( 469)												int index18;
HXDLIN( 469)												if (undoImage9->useVirtualPos) {
HXDLIN( 469)													index18 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            												}
            												else {
HXDLIN( 469)													index18 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this122,index18,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 469)				bool found3 = false;
HXDLIN( 469)				Float s3 = ((Float)0.);
HXDLIN( 469)				Float t3 = ((Float)0.);
HXDLIN( 469)				Float sxx3 = ((Float)0.);
HXDLIN( 469)				Float txx3 = ((Float)0.);
HXDLIN( 469)				{
HXDLIN( 469)					int _g_min6 = xIter33->start;
HXDLIN( 469)					int _g_max6 = xIter33->max;
HXDLIN( 469)					while((_g_min6 < _g_max6)){
HXDLIN( 469)						_g_min6 = (_g_min6 + 1);
HXDLIN( 469)						int x15 = (_g_min6 - 1);
HXLINE(  60)						sxx3 = (sx3 * ( (Float)(x15) ));
HXLINE(  61)						txx3 = (tx3 * ( (Float)(x15) ));
HXLINE(  62)						found3 = false;
HXLINE( 469)						{
HXDLIN( 469)							int _g_min7 = yIter33->start;
HXDLIN( 469)							int _g_max7 = yIter33->max;
HXDLIN( 469)							while((_g_min7 < _g_max7)){
HXDLIN( 469)								_g_min7 = (_g_min7 + 1);
HXDLIN( 469)								int y15 = (_g_min7 - 1);
HXLINE(  64)								s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y15) )));
HXLINE(  65)								t3 = ((t03 + txx3) + (ty3 * ( (Float)(y15) )));
HXLINE( 469)								bool hitQuad29;
HXDLIN( 469)								if (!((s3 <= 0))) {
HXDLIN( 469)									hitQuad29 = (t3 <= 0);
            								}
            								else {
HXDLIN( 469)									hitQuad29 = true;
            								}
HXDLIN( 469)								if (hitQuad29) {
HXDLIN( 469)									if (found3) {
HXDLIN( 469)										goto _hx_goto_823;
            									}
            								}
            								else {
HXDLIN( 469)									if (((s3 + t3) < A3)) {
HXDLIN( 469)										{
HXDLIN( 469)											int c21 = color;
HXDLIN( 469)											bool hitQuad30;
HXDLIN( 469)											if ((((c21 >> 24) & 255) < 254)) {
HXDLIN( 469)												hitQuad30 = this1->transparent;
            											}
            											else {
HXDLIN( 469)												hitQuad30 = false;
            											}
HXDLIN( 469)											if (hitQuad30) {
HXDLIN( 469)												int location7;
HXDLIN( 469)												if (this1->useVirtualPos) {
HXDLIN( 469)													location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            												}
            												else {
HXDLIN( 469)													location7 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            												}
HXDLIN( 469)												int this123 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN( 469)												int this124;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													this124 = ((((((this123 >> 24) & 255) << 24) | ((this123 & 255) << 16)) | (((this123 >> 8) & 255) << 8)) | ((this123 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													this124 = this123;
            												}
HXDLIN( 469)												Float a112;
HXDLIN( 469)												int this125 = ((this124 >> 24) & 255);
HXDLIN( 469)												if ((this125 == 0)) {
HXDLIN( 469)													a112 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a112 = (( (Float)(this125) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r17;
HXDLIN( 469)												int this126 = ((this124 >> 16) & 255);
HXDLIN( 469)												if ((this126 == 0)) {
HXDLIN( 469)													r17 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r17 = (( (Float)(this126) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g17;
HXDLIN( 469)												int this127 = ((this124 >> 8) & 255);
HXDLIN( 469)												if ((this127 == 0)) {
HXDLIN( 469)													g17 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g17 = (( (Float)(this127) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b113;
HXDLIN( 469)												int this128 = (this124 & 255);
HXDLIN( 469)												if ((this128 == 0)) {
HXDLIN( 469)													b113 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b113 = (( (Float)(this128) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a210;
HXDLIN( 469)												int this129 = ((color >> 24) & 255);
HXDLIN( 469)												if ((this129 == 0)) {
HXDLIN( 469)													a210 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													a210 = (( (Float)(this129) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float r27;
HXDLIN( 469)												int this130 = ((color >> 16) & 255);
HXDLIN( 469)												if ((this130 == 0)) {
HXDLIN( 469)													r27 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													r27 = (( (Float)(this130) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float g27;
HXDLIN( 469)												int this131 = ((color >> 8) & 255);
HXDLIN( 469)												if ((this131 == 0)) {
HXDLIN( 469)													g27 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													g27 = (( (Float)(this131) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float b211;
HXDLIN( 469)												int this132 = (color & 255);
HXDLIN( 469)												if ((this132 == 0)) {
HXDLIN( 469)													b211 = ((Float)0.);
            												}
            												else {
HXDLIN( 469)													b211 = (( (Float)(this132) ) / ( (Float)(255) ));
            												}
HXDLIN( 469)												Float a37 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 469)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a210))));
HXDLIN( 469)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a210))));
HXDLIN( 469)												int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a210))));
HXDLIN( 469)												int a38 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a210)));
HXDLIN( 469)												int blended7 = ((((a38 << 24) | (r9 << 16)) | (g9 << 8)) | b35);
HXDLIN( 469)												{
HXDLIN( 469)													int hitQuad31;
HXDLIN( 469)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)														hitQuad31 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXDLIN( 469)														hitQuad31 = blended7;
            													}
HXDLIN( 469)													::iterMagic::Iimg_obj::set(this1->image,location7,hitQuad31);
            												}
            											}
            											else {
HXDLIN( 469)												::Dynamic this133 = this1->image;
HXDLIN( 469)												int index19;
HXDLIN( 469)												if (this1->useVirtualPos) {
HXDLIN( 469)													index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            												}
            												else {
HXDLIN( 469)													index19 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            												}
HXDLIN( 469)												int hitQuad32;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad32 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad32 = c21;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this133,index19,hitQuad32);
            											}
            										}
HXLINE(  73)										found3 = true;
            									}
            									else {
HXDLIN( 469)										if (found3) {
HXDLIN( 469)											goto _hx_goto_823;
            										}
            									}
            								}
            							}
            							_hx_goto_823:;
            						}
            					}
            				}
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart v_yIter33;
HXDLIN( 469)				 ::pi_xy::iter::IntIterStart v_xIter33;
HXDLIN( 469)				int v_undoY3;
HXDLIN( 469)				int v_undoX3;
HXDLIN( 469)				Float v_ty3;
HXDLIN( 469)				Float v_tx3;
HXDLIN( 469)				Float v_t03;
HXDLIN( 469)				Float v_sy3;
HXDLIN( 469)				Float v_sx3;
HXDLIN( 469)				Float v_s03;
HXDLIN( 469)				Float v_A3;
HXDLIN( 469)				Float ax5 = bx5;
HXDLIN( 469)				Float ay5 = by5;
HXDLIN( 469)				 ::pi_xy::ImageStruct v_undoImage3 = null();
HXDLIN( 469)				Float bx9 = bx8;
HXDLIN( 469)				Float by9 = by8;
HXDLIN( 469)				Float cx9 = cx8;
HXDLIN( 469)				Float cy9 = cy8;
HXDLIN( 469)				bool adjustWinding7 = (((((ax5 * by9) - (bx9 * ay5)) + ((bx9 * cy9) - (cx9 * by9))) + ((cx9 * ay5) - (ax5 * cy9))) > 0);
HXDLIN( 469)				if (!(adjustWinding7)) {
HXDLIN( 469)					Float bx_7 = bx9;
HXDLIN( 469)					Float by_7 = by9;
HXLINE(  24)					bx9 = cx9;
HXLINE(  25)					by9 = cy9;
HXLINE(  26)					cx9 = bx_7;
HXLINE(  27)					cy9 = by_7;
            				}
HXLINE( 469)				Float v_ax3 = ax5;
HXDLIN( 469)				Float v_ay3 = ay5;
HXDLIN( 469)				Float v_bx3 = bx9;
HXDLIN( 469)				Float v_by3 = by9;
HXDLIN( 469)				Float v_cx3 = cx9;
HXDLIN( 469)				Float v_cy3 = cy9;
HXDLIN( 469)				bool v_preCalculated3 = true;
HXDLIN( 469)				{
HXDLIN( 469)					v_s03 = ((v_ay3 * v_cx3) - (v_ax3 * v_cy3));
HXDLIN( 469)					v_sx3 = (v_cy3 - v_ay3);
HXDLIN( 469)					v_sy3 = (v_ax3 - v_cx3);
HXDLIN( 469)					v_t03 = ((v_ax3 * v_by3) - (v_ay3 * v_bx3));
HXDLIN( 469)					v_tx3 = (v_ay3 - v_by3);
HXDLIN( 469)					v_ty3 = (v_bx3 - v_ax3);
HXDLIN( 469)					v_A3 = ((((-(v_by3) * v_cx3) + (v_ay3 * (-(v_bx3) + v_cx3))) + (v_ax3 * (v_by3 - v_cy3))) + (v_bx3 * v_cy3));
HXDLIN( 469)					Float a39 = v_ax3;
HXDLIN( 469)					Float b36 = v_bx3;
HXDLIN( 469)					Float c22 = v_cx3;
HXDLIN( 469)					if ((a39 > b36)) {
HXDLIN( 469)						if ((a39 > c22)) {
HXDLIN( 469)							int min28;
HXDLIN( 469)							if ((b36 > c22)) {
HXDLIN( 469)								min28 = ::Math_obj::floor(c22);
            							}
            							else {
HXDLIN( 469)								min28 = ::Math_obj::floor(b36);
            							}
HXDLIN( 469)							int ii_min56 = min28;
HXDLIN( 469)							int ii_max56 = ::Math_obj::ceil(a39);
HXDLIN( 469)							v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            						}
            						else {
HXDLIN( 469)							int ii_min57 = ::Math_obj::floor(b36);
HXDLIN( 469)							int ii_max57 = ::Math_obj::ceil(c22);
HXDLIN( 469)							v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            						}
            					}
            					else {
HXDLIN( 469)						if ((b36 > c22)) {
HXDLIN( 469)							int min29;
HXDLIN( 469)							if ((a39 > c22)) {
HXDLIN( 469)								min29 = ::Math_obj::floor(c22);
            							}
            							else {
HXDLIN( 469)								min29 = ::Math_obj::ceil(a39);
            							}
HXDLIN( 469)							int ii_min58 = min29;
HXDLIN( 469)							int ii_max58 = ::Math_obj::ceil(b36);
HXDLIN( 469)							v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            						}
            						else {
HXDLIN( 469)							int ii_min59 = ::Math_obj::floor(a39);
HXDLIN( 469)							int ii_max59 = ::Math_obj::ceil(c22);
HXDLIN( 469)							v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            						}
            					}
HXDLIN( 469)					Float a40 = v_ay3;
HXDLIN( 469)					Float b37 = v_by3;
HXDLIN( 469)					Float c23 = v_cy3;
HXDLIN( 469)					if ((a40 > b37)) {
HXDLIN( 469)						if ((a40 > c23)) {
HXDLIN( 469)							int min30;
HXDLIN( 469)							if ((b37 > c23)) {
HXDLIN( 469)								min30 = ::Math_obj::floor(c23);
            							}
            							else {
HXDLIN( 469)								min30 = ::Math_obj::floor(b37);
            							}
HXDLIN( 469)							int ii_min60 = min30;
HXDLIN( 469)							int ii_max60 = ::Math_obj::ceil(a40);
HXDLIN( 469)							v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            						}
            						else {
HXDLIN( 469)							int ii_min61 = ::Math_obj::floor(b37);
HXDLIN( 469)							int ii_max61 = ::Math_obj::ceil(c23);
HXDLIN( 469)							v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            						}
            					}
            					else {
HXDLIN( 469)						if ((b37 > c23)) {
HXDLIN( 469)							int min31;
HXDLIN( 469)							if ((a40 > c23)) {
HXDLIN( 469)								min31 = ::Math_obj::floor(c23);
            							}
            							else {
HXDLIN( 469)								min31 = ::Math_obj::ceil(a40);
            							}
HXDLIN( 469)							int ii_min62 = min31;
HXDLIN( 469)							int ii_max62 = ::Math_obj::ceil(b37);
HXDLIN( 469)							v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            						}
            						else {
HXDLIN( 469)							int ii_min63 = ::Math_obj::floor(a40);
HXDLIN( 469)							int ii_max63 = ::Math_obj::ceil(c23);
HXDLIN( 469)							v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            						}
            					}
            				}
HXDLIN( 469)				if (hasUndo3) {
HXDLIN( 469)					v_undoImage3 = undoImage9;
HXDLIN( 469)					v_undoX3 = xIter33->start;
HXDLIN( 469)					v_undoY3 = yIter33->start;
            				}
HXDLIN( 469)				 ::pi_xy::algo::HitQuad v9 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax3,ay3,bx5,by5,cx5,cy5,dx3,dy3,true);
HXDLIN( 469)				hitQuad = v9;
            			}
            		}
            		else {
HXDLIN( 469)			Float sin3 = ::Math_obj::sin(theta);
HXDLIN( 469)			Float cos3 = ::Math_obj::cos(theta);
HXDLIN( 469)			Float radius3 = (thick / ( (Float)(2) ));
HXDLIN( 469)			Float dx6 = ((Float)0.1);
HXDLIN( 469)			Float dy6 = radius3;
HXDLIN( 469)			Float cx10 = h2;
HXDLIN( 469)			Float cy10 = radius3;
HXDLIN( 469)			Float bx10 = h2;
HXDLIN( 469)			Float by10 = -(radius3);
HXDLIN( 469)			Float ax6 = ((Float)0.1);
HXDLIN( 469)			Float ay6 = -(radius3);
HXDLIN( 469)			Float temp2 = ((Float)0.);
HXLINE(  28)			temp2 = (px + ((ax6 * cos3) - (ay6 * sin3)));
HXLINE(  29)			ay6 = (py + ((ay6 * cos3) + (ax6 * sin3)));
HXLINE(  30)			ax6 = temp2;
HXLINE(  32)			temp2 = (px + ((bx10 * cos3) - (by10 * sin3)));
HXLINE(  33)			by10 = (py + ((by10 * cos3) + (bx10 * sin3)));
HXLINE(  34)			bx10 = temp2;
HXLINE(  36)			temp2 = (px + ((cx10 * cos3) - (cy10 * sin3)));
HXLINE(  37)			cy10 = (py + ((cy10 * cos3) + (cx10 * sin3)));
HXLINE(  38)			cx10 = temp2;
HXLINE(  40)			temp2 = (px + ((dx6 * cos3) - (dy6 * sin3)));
HXLINE(  41)			dy6 = (py + ((dy6 * cos3) + (dx6 * sin3)));
HXLINE(  42)			dx6 = temp2;
HXLINE( 469)			Float bx11 = bx10;
HXDLIN( 469)			Float by11 = by10;
HXDLIN( 469)			Float cx11 = dx6;
HXDLIN( 469)			Float cy11 = dy6;
HXDLIN( 469)			bool hasUndo4 = false;
HXDLIN( 469)			bool adjustWinding8 = (((((ax6 * by11) - (bx11 * ay6)) + ((bx11 * cy11) - (cx11 * by11))) + ((cx11 * ay6) - (ax6 * cy11))) > 0);
HXDLIN( 469)			if (!(adjustWinding8)) {
HXDLIN( 469)				Float bx_8 = bx11;
HXDLIN( 469)				Float by_8 = by11;
HXLINE(  25)				bx11 = cx11;
HXLINE(  26)				by11 = cy11;
HXLINE(  27)				cx11 = bx_8;
HXLINE(  28)				cy11 = by_8;
            			}
HXLINE( 469)			Float s04 = ((ay6 * cx11) - (ax6 * cy11));
HXDLIN( 469)			Float sx4 = (cy11 - ay6);
HXDLIN( 469)			Float sy4 = (ax6 - cx11);
HXDLIN( 469)			Float t04 = ((ax6 * by11) - (ay6 * bx11));
HXDLIN( 469)			Float tx4 = (ay6 - by11);
HXDLIN( 469)			Float ty4 = (bx11 - ax6);
HXDLIN( 469)			Float A4 = ((((-(by11) * cx11) + (ay6 * (-(bx11) + cx11))) + (ax6 * (by11 - cy11))) + (bx11 * cy11));
HXDLIN( 469)			 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 469)			if ((ax6 > bx11)) {
HXDLIN( 469)				if ((ax6 > cx11)) {
HXDLIN( 469)					int min32;
HXDLIN( 469)					if ((bx11 > cx11)) {
HXDLIN( 469)						min32 = ::Math_obj::floor(cx11);
            					}
            					else {
HXDLIN( 469)						min32 = ::Math_obj::floor(bx11);
            					}
HXDLIN( 469)					int ii_min64 = min32;
HXDLIN( 469)					int ii_max64 = ::Math_obj::ceil(ax6);
HXDLIN( 469)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            				}
            				else {
HXDLIN( 469)					int ii_min65 = ::Math_obj::floor(bx11);
HXDLIN( 469)					int ii_max65 = ::Math_obj::ceil(cx11);
HXDLIN( 469)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            				}
            			}
            			else {
HXDLIN( 469)				if ((bx11 > cx11)) {
HXDLIN( 469)					int min33;
HXDLIN( 469)					if ((ax6 > cx11)) {
HXDLIN( 469)						min33 = ::Math_obj::floor(cx11);
            					}
            					else {
HXDLIN( 469)						min33 = ::Math_obj::ceil(ax6);
            					}
HXDLIN( 469)					int ii_min66 = min33;
HXDLIN( 469)					int ii_max66 = ::Math_obj::ceil(bx11);
HXDLIN( 469)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            				}
            				else {
HXDLIN( 469)					int ii_min67 = ::Math_obj::floor(ax6);
HXDLIN( 469)					int ii_max67 = ::Math_obj::ceil(cx11);
HXDLIN( 469)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            				}
            			}
HXDLIN( 469)			 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 469)			if ((ay6 > by11)) {
HXDLIN( 469)				if ((ay6 > cy11)) {
HXDLIN( 469)					int min34;
HXDLIN( 469)					if ((by11 > cy11)) {
HXDLIN( 469)						min34 = ::Math_obj::floor(cy11);
            					}
            					else {
HXDLIN( 469)						min34 = ::Math_obj::floor(by11);
            					}
HXDLIN( 469)					int ii_min68 = min34;
HXDLIN( 469)					int ii_max68 = ::Math_obj::ceil(ay6);
HXDLIN( 469)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            				}
            				else {
HXDLIN( 469)					int ii_min69 = ::Math_obj::floor(by11);
HXDLIN( 469)					int ii_max69 = ::Math_obj::ceil(cy11);
HXDLIN( 469)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            				}
            			}
            			else {
HXDLIN( 469)				if ((by11 > cy11)) {
HXDLIN( 469)					int min35;
HXDLIN( 469)					if ((ay6 > cy11)) {
HXDLIN( 469)						min35 = ::Math_obj::floor(cy11);
            					}
            					else {
HXDLIN( 469)						min35 = ::Math_obj::ceil(ay6);
            					}
HXDLIN( 469)					int ii_min70 = min35;
HXDLIN( 469)					int ii_max70 = ::Math_obj::ceil(by11);
HXDLIN( 469)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            				}
            				else {
HXDLIN( 469)					int ii_min71 = ::Math_obj::floor(ay6);
HXDLIN( 469)					int ii_max71 = ::Math_obj::ceil(cy11);
HXDLIN( 469)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            				}
            			}
HXDLIN( 469)			 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 469)			if (hasUndo4) {
HXDLIN( 469)				int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 469)				int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 469)				 ::Dynamic imageType4 = null();
HXDLIN( 469)				 ::pi_xy::ImageStruct this134 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 469)				if (::hx::IsNull( imageType4 )) {
HXLINE(  54)					imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 469)				::Dynamic undoImage13;
HXDLIN( 469)				switch((int)(( (int)(imageType4) ))){
            					case (int)0: {
HXDLIN( 469)						 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::BytesImg b38 = byt4;
HXDLIN( 469)						{
HXDLIN( 469)							b38->width = width4;
HXDLIN( 469)							b38->height = height4;
HXDLIN( 469)							b38->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 469)							b38->data = ::haxe::io::Bytes_obj::alloc((b38->length * 4));
HXDLIN( 469)							{
HXDLIN( 469)								int len8 = b38->length;
HXDLIN( 469)								int w4 = 0;
HXDLIN( 469)								{
HXDLIN( 469)									int _g80 = 0;
HXDLIN( 469)									int _g81 = b38->height;
HXDLIN( 469)									while((_g80 < _g81)){
HXDLIN( 469)										_g80 = (_g80 + 1);
HXDLIN( 469)										int y16 = (_g80 - 1);
HXDLIN( 469)										{
HXDLIN( 469)											int _g82 = 0;
HXDLIN( 469)											int _g83 = b38->width;
HXDLIN( 469)											while((_g82 < _g83)){
HXDLIN( 469)												_g82 = (_g82 + 1);
HXDLIN( 469)												int x16 = (_g82 - 1);
HXDLIN( 469)												{
HXDLIN( 469)													w4 = (w4 + 1);
HXDLIN( 469)													b38->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 469)												{
HXDLIN( 469)													w4 = (w4 + 1);
HXDLIN( 469)													b38->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 469)												{
HXDLIN( 469)													w4 = (w4 + 1);
HXDLIN( 469)													b38->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 469)												{
HXDLIN( 469)													w4 = (w4 + 1);
HXDLIN( 469)													b38->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 469)						undoImage13 = b38;
            					}
            					break;
            					case (int)1: {
HXDLIN( 469)						 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::ArrIntImg a41 = arrI4;
HXDLIN( 469)						{
HXDLIN( 469)							a41->width = width4;
HXDLIN( 469)							a41->height = height4;
HXDLIN( 469)							a41->data = ::Array_obj< int >::__new(0);
HXDLIN( 469)							a41->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 469)							{
HXDLIN( 469)								int _g84 = 0;
HXDLIN( 469)								int _g85 = a41->length;
HXDLIN( 469)								while((_g84 < _g85)){
HXDLIN( 469)									_g84 = (_g84 + 1);
HXDLIN( 469)									int i24 = (_g84 - 1);
HXDLIN( 469)									a41->data[i24] = 0;
            								}
            							}
            						}
HXDLIN( 469)						undoImage13 = a41;
            					}
            					break;
            					case (int)2: {
HXDLIN( 469)						 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::U32ArrImg b39 = u32a4;
HXDLIN( 469)						{
HXDLIN( 469)							b39->width = width4;
HXDLIN( 469)							b39->height = height4;
HXDLIN( 469)							b39->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 469)							int size4 = (b39->length * 4);
HXDLIN( 469)							b39->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 469)							{
HXDLIN( 469)								int _g86 = 0;
HXDLIN( 469)								int _g87 = b39->length;
HXDLIN( 469)								while((_g86 < _g87)){
HXDLIN( 469)									_g86 = (_g86 + 1);
HXDLIN( 469)									int i25 = (_g86 - 1);
HXDLIN( 469)									{
HXDLIN( 469)										 ::haxe::io::ArrayBufferViewImpl this135 = b39->data;
HXDLIN( 469)										bool undoImage14;
HXDLIN( 469)										if ((i25 >= 0)) {
HXDLIN( 469)											undoImage14 = (i25 < (this135->byteLength >> 2));
            										}
            										else {
HXDLIN( 469)											undoImage14 = false;
            										}
HXDLIN( 469)										if (undoImage14) {
HXDLIN( 469)											 ::haxe::io::Bytes _this4 = this135->bytes;
HXDLIN( 469)											int pos4 = ((i25 << 2) + this135->byteOffset);
HXDLIN( 469)											_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 469)											_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 469)											_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 469)											_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 469)						undoImage13 = b39;
            					}
            					break;
            					case (int)3: {
HXDLIN( 469)						 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::VecIntImg v10 = vec4;
HXDLIN( 469)						{
HXDLIN( 469)							v10->width = width4;
HXDLIN( 469)							v10->height = height4;
HXDLIN( 469)							v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 469)							v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN( 469)							{
HXDLIN( 469)								int _g88 = 0;
HXDLIN( 469)								int _g89 = v10->length;
HXDLIN( 469)								while((_g88 < _g89)){
HXDLIN( 469)									_g88 = (_g88 + 1);
HXDLIN( 469)									int i26 = (_g88 - 1);
HXDLIN( 469)									v10->data->__unsafe_set(i26,0);
            								}
            							}
            						}
HXDLIN( 469)						undoImage13 = v10;
            					}
            					break;
            					case (int)4: {
HXDLIN( 469)						 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::StackIntImg b40 = sInt4;
HXDLIN( 469)						{
HXDLIN( 469)							b40->width = width4;
HXDLIN( 469)							b40->height = height4;
HXDLIN( 469)							b40->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 469)							b40->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 469)							{
HXDLIN( 469)								int len9 = b40->length;
HXDLIN( 469)								 ::haxe::ds::GenericStack_Int d4 = b40->data;
HXDLIN( 469)								if (::hx::IsNull( d4->head )) {
HXDLIN( 469)									int _g90 = 0;
HXDLIN( 469)									int _g91 = len9;
HXDLIN( 469)									while((_g90 < _g91)){
HXDLIN( 469)										_g90 = (_g90 + 1);
HXDLIN( 469)										int i27 = (_g90 - 1);
HXDLIN( 469)										d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            									}
            								}
            								else {
HXDLIN( 469)									int _g92 = 0;
HXDLIN( 469)									int _g93 = len9;
HXDLIN( 469)									while((_g92 < _g93)){
HXDLIN( 469)										_g92 = (_g92 + 1);
HXDLIN( 469)										int i28 = (_g92 - 1);
HXDLIN( 469)										{
HXDLIN( 469)											 ::haxe::ds::GenericCell_Int l4 = b40->data->head;
HXDLIN( 469)											 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 469)											{
HXDLIN( 469)												int _g94 = 0;
HXDLIN( 469)												int _g95 = i28;
HXDLIN( 469)												while((_g94 < _g95)){
HXDLIN( 469)													_g94 = (_g94 + 1);
HXDLIN( 469)													int i29 = (_g94 - 1);
HXLINE( 345)													prev4 = l4;
HXLINE( 346)													l4 = l4->next;
            												}
            											}
HXLINE( 469)											if (::hx::IsNull( prev4 )) {
HXDLIN( 469)												b40->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 469)												l4 = null();
            											}
            											else {
HXDLIN( 469)												prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 469)												l4 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 469)						undoImage13 = b40;
            					}
            					break;
            				}
HXDLIN( 469)				this134->image = undoImage13;
HXDLIN( 469)				this134->width = width4;
HXDLIN( 469)				this134->height = height4;
HXDLIN( 469)				this134->imageType = ( (int)(imageType4) );
HXDLIN( 469)				undoImage12 = this134;
HXDLIN( 469)				{
HXDLIN( 469)					int rectLeft4 = xIter34->start;
HXDLIN( 469)					int rectTop4 = yIter34->start;
HXDLIN( 469)					int rectRight4 = xIter34->max;
HXDLIN( 469)					bool forceClear4 = false;
HXDLIN( 469)					{
HXDLIN( 469)						int _g96 = rectTop4;
HXDLIN( 469)						int _g97 = yIter34->max;
HXDLIN( 469)						while((_g96 < _g97)){
HXDLIN( 469)							_g96 = (_g96 + 1);
HXDLIN( 469)							int dy7 = (_g96 - 1);
HXDLIN( 469)							{
HXDLIN( 469)								int _g98 = rectLeft4;
HXDLIN( 469)								int _g99 = rectRight4;
HXDLIN( 469)								while((_g98 < _g99)){
HXDLIN( 469)									_g98 = (_g98 + 1);
HXDLIN( 469)									int dx7 = (_g98 - 1);
HXDLIN( 469)									::Dynamic this136 = this1->image;
HXDLIN( 469)									int index20;
HXDLIN( 469)									if (this1->useVirtualPos) {
HXDLIN( 469)										index20 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx7) - this1->virtualX));
            									}
            									else {
HXDLIN( 469)										index20 = ::Std_obj::_hx_int(( (Float)(((dy7 * this1->width) + dx7)) ));
            									}
HXDLIN( 469)									int c24 = ::iterMagic::Iimg_obj::get(this136,index20);
HXDLIN( 469)									int col4;
HXDLIN( 469)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)										col4 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            									}
            									else {
HXDLIN( 469)										col4 = c24;
            									}
HXDLIN( 469)									bool hitQuad33;
HXDLIN( 469)									if (this1->useMask) {
HXDLIN( 469)										hitQuad33 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN( 469)										hitQuad33 = false;
            									}
HXDLIN( 469)									if (hitQuad33) {
HXDLIN( 469)										 ::pi_xy::ImageStruct this137 = this1->mask;
HXDLIN( 469)										::Dynamic this138 = this137->image;
HXDLIN( 469)										int index21;
HXDLIN( 469)										if (this137->useVirtualPos) {
HXDLIN( 469)											index21 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this137->virtualY) * ( (Float)(this137->width) )) + dx7) - this137->virtualX));
            										}
            										else {
HXDLIN( 469)											index21 = ::Std_obj::_hx_int(( (Float)(((dy7 * this137->width) + dx7)) ));
            										}
HXDLIN( 469)										int c25 = ::iterMagic::Iimg_obj::get(this138,index21);
HXDLIN( 469)										int v11;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											v11 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											v11 = c25;
            										}
HXDLIN( 469)										int maskPixel4 = v11;
HXDLIN( 469)										int this139 = col4;
HXDLIN( 469)										if ((maskPixel4 == 0)) {
HXDLIN( 469)											col4 = this139;
            										}
            										else {
HXDLIN( 469)											Float m04;
HXDLIN( 469)											int this140 = ((maskPixel4 >> 24) & 255);
HXDLIN( 469)											if ((this140 == 0)) {
HXDLIN( 469)												m04 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												m04 = (( (Float)(this140) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float m14;
HXDLIN( 469)											int this141 = ((maskPixel4 >> 16) & 255);
HXDLIN( 469)											if ((this141 == 0)) {
HXDLIN( 469)												m14 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												m14 = (( (Float)(this141) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float m24;
HXDLIN( 469)											int this142 = ((maskPixel4 >> 8) & 255);
HXDLIN( 469)											if ((this142 == 0)) {
HXDLIN( 469)												m24 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												m24 = (( (Float)(this142) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float m34;
HXDLIN( 469)											int this143 = (maskPixel4 & 255);
HXDLIN( 469)											if ((this143 == 0)) {
HXDLIN( 469)												m34 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												m34 = (( (Float)(this143) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this139 >> 24) & 255)) )));
HXDLIN( 469)											int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this139 >> 16) & 255)) )));
HXDLIN( 469)											int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this139 >> 8) & 255)) )));
HXDLIN( 469)											int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this139 & 255)) )));
HXDLIN( 469)											col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 469)									if ((col4 != 0)) {
HXDLIN( 469)										int x17 = (dx7 - rectLeft4);
HXDLIN( 469)										int y17 = (dy7 - rectTop4);
HXDLIN( 469)										int c26 = col4;
HXDLIN( 469)										bool hitQuad34;
HXDLIN( 469)										if ((((c26 >> 24) & 255) < 254)) {
HXDLIN( 469)											hitQuad34 = undoImage12->transparent;
            										}
            										else {
HXDLIN( 469)											hitQuad34 = false;
            										}
HXDLIN( 469)										if (hitQuad34) {
HXDLIN( 469)											int location8;
HXDLIN( 469)											if (undoImage12->useVirtualPos) {
HXDLIN( 469)												location8 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x17) - undoImage12->virtualX));
            											}
            											else {
HXDLIN( 469)												location8 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage12->width) + x17)) ));
            											}
HXDLIN( 469)											int this144 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 469)											int this145;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												this145 = ((((((this144 >> 24) & 255) << 24) | ((this144 & 255) << 16)) | (((this144 >> 8) & 255) << 8)) | ((this144 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												this145 = this144;
            											}
HXDLIN( 469)											Float a113;
HXDLIN( 469)											int this146 = ((this145 >> 24) & 255);
HXDLIN( 469)											if ((this146 == 0)) {
HXDLIN( 469)												a113 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												a113 = (( (Float)(this146) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float r18;
HXDLIN( 469)											int this147 = ((this145 >> 16) & 255);
HXDLIN( 469)											if ((this147 == 0)) {
HXDLIN( 469)												r18 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												r18 = (( (Float)(this147) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float g18;
HXDLIN( 469)											int this148 = ((this145 >> 8) & 255);
HXDLIN( 469)											if ((this148 == 0)) {
HXDLIN( 469)												g18 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												g18 = (( (Float)(this148) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float b114;
HXDLIN( 469)											int this149 = (this145 & 255);
HXDLIN( 469)											if ((this149 == 0)) {
HXDLIN( 469)												b114 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												b114 = (( (Float)(this149) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float a211;
HXDLIN( 469)											int this150 = ((col4 >> 24) & 255);
HXDLIN( 469)											if ((this150 == 0)) {
HXDLIN( 469)												a211 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												a211 = (( (Float)(this150) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float r28;
HXDLIN( 469)											int this151 = ((col4 >> 16) & 255);
HXDLIN( 469)											if ((this151 == 0)) {
HXDLIN( 469)												r28 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												r28 = (( (Float)(this151) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float g28;
HXDLIN( 469)											int this152 = ((col4 >> 8) & 255);
HXDLIN( 469)											if ((this152 == 0)) {
HXDLIN( 469)												g28 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												g28 = (( (Float)(this152) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float b212;
HXDLIN( 469)											int this153 = (col4 & 255);
HXDLIN( 469)											if ((this153 == 0)) {
HXDLIN( 469)												b212 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												b212 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 469)											int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a310) + (r28 * a211))));
HXDLIN( 469)											int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a310) + (g28 * a211))));
HXDLIN( 469)											int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b212 * a211))));
HXDLIN( 469)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 469)											int blended8 = ((((a42 << 24) | (r10 << 16)) | (g10 << 8)) | b41);
HXDLIN( 469)											{
HXDLIN( 469)												int hitQuad35;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad35 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad35 = blended8;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(undoImage12->image,location8,hitQuad35);
            											}
            										}
            										else {
HXDLIN( 469)											::Dynamic this154 = undoImage12->image;
HXDLIN( 469)											int index22;
HXDLIN( 469)											if (undoImage12->useVirtualPos) {
HXDLIN( 469)												index22 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x17) - undoImage12->virtualX));
            											}
            											else {
HXDLIN( 469)												index22 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage12->width) + x17)) ));
            											}
HXDLIN( 469)											int hitQuad36;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												hitQuad36 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												hitQuad36 = c26;
            											}
HXDLIN( 469)											::iterMagic::Iimg_obj::set(this154,index22,hitQuad36);
            										}
            									}
            									else {
HXDLIN( 469)										if (forceClear4) {
HXDLIN( 469)											::Dynamic this155 = undoImage12->image;
HXDLIN( 469)											int x18 = (dx7 - rectLeft4);
HXDLIN( 469)											int y18 = (dy7 - rectTop4);
HXDLIN( 469)											int index23;
HXDLIN( 469)											if (undoImage12->useVirtualPos) {
HXDLIN( 469)												index23 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x18) - undoImage12->virtualX));
            											}
            											else {
HXDLIN( 469)												index23 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage12->width) + x18)) ));
            											}
HXDLIN( 469)											::iterMagic::Iimg_obj::set(this155,index23,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 469)			bool found4 = false;
HXDLIN( 469)			Float s4 = ((Float)0.);
HXDLIN( 469)			Float t4 = ((Float)0.);
HXDLIN( 469)			Float sxx4 = ((Float)0.);
HXDLIN( 469)			Float txx4 = ((Float)0.);
HXDLIN( 469)			{
HXDLIN( 469)				int _g_min8 = xIter34->start;
HXDLIN( 469)				int _g_max8 = xIter34->max;
HXDLIN( 469)				while((_g_min8 < _g_max8)){
HXDLIN( 469)					_g_min8 = (_g_min8 + 1);
HXDLIN( 469)					int x19 = (_g_min8 - 1);
HXLINE(  60)					sxx4 = (sx4 * ( (Float)(x19) ));
HXLINE(  61)					txx4 = (tx4 * ( (Float)(x19) ));
HXLINE(  62)					found4 = false;
HXLINE( 469)					{
HXDLIN( 469)						int _g_min9 = yIter34->start;
HXDLIN( 469)						int _g_max9 = yIter34->max;
HXDLIN( 469)						while((_g_min9 < _g_max9)){
HXDLIN( 469)							_g_min9 = (_g_min9 + 1);
HXDLIN( 469)							int y19 = (_g_min9 - 1);
HXLINE(  64)							s4 = ((s04 + sxx4) + (sy4 * ( (Float)(y19) )));
HXLINE(  65)							t4 = ((t04 + txx4) + (ty4 * ( (Float)(y19) )));
HXLINE( 469)							bool hitQuad37;
HXDLIN( 469)							if (!((s4 <= 0))) {
HXDLIN( 469)								hitQuad37 = (t4 <= 0);
            							}
            							else {
HXDLIN( 469)								hitQuad37 = true;
            							}
HXDLIN( 469)							if (hitQuad37) {
HXDLIN( 469)								if (found4) {
HXDLIN( 469)									goto _hx_goto_835;
            								}
            							}
            							else {
HXDLIN( 469)								if (((s4 + t4) < A4)) {
HXDLIN( 469)									{
HXDLIN( 469)										int c27 = color;
HXDLIN( 469)										bool hitQuad38;
HXDLIN( 469)										if ((((c27 >> 24) & 255) < 254)) {
HXDLIN( 469)											hitQuad38 = this1->transparent;
            										}
            										else {
HXDLIN( 469)											hitQuad38 = false;
            										}
HXDLIN( 469)										if (hitQuad38) {
HXDLIN( 469)											int location9;
HXDLIN( 469)											if (this1->useVirtualPos) {
HXDLIN( 469)												location9 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this1->virtualY) * ( (Float)(this1->width) )) + x19) - this1->virtualX));
            											}
            											else {
HXDLIN( 469)												location9 = ::Std_obj::_hx_int(( (Float)(((y19 * this1->width) + x19)) ));
            											}
HXDLIN( 469)											int this156 = ::iterMagic::Iimg_obj::get(this1->image,location9);
HXDLIN( 469)											int this157;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												this157 = ((((((this156 >> 24) & 255) << 24) | ((this156 & 255) << 16)) | (((this156 >> 8) & 255) << 8)) | ((this156 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												this157 = this156;
            											}
HXDLIN( 469)											Float a114;
HXDLIN( 469)											int this158 = ((this157 >> 24) & 255);
HXDLIN( 469)											if ((this158 == 0)) {
HXDLIN( 469)												a114 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												a114 = (( (Float)(this158) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float r19;
HXDLIN( 469)											int this159 = ((this157 >> 16) & 255);
HXDLIN( 469)											if ((this159 == 0)) {
HXDLIN( 469)												r19 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												r19 = (( (Float)(this159) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float g19;
HXDLIN( 469)											int this160 = ((this157 >> 8) & 255);
HXDLIN( 469)											if ((this160 == 0)) {
HXDLIN( 469)												g19 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												g19 = (( (Float)(this160) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float b115;
HXDLIN( 469)											int this161 = (this157 & 255);
HXDLIN( 469)											if ((this161 == 0)) {
HXDLIN( 469)												b115 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												b115 = (( (Float)(this161) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float a212;
HXDLIN( 469)											int this162 = ((color >> 24) & 255);
HXDLIN( 469)											if ((this162 == 0)) {
HXDLIN( 469)												a212 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												a212 = (( (Float)(this162) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float r29;
HXDLIN( 469)											int this163 = ((color >> 16) & 255);
HXDLIN( 469)											if ((this163 == 0)) {
HXDLIN( 469)												r29 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												r29 = (( (Float)(this163) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float g29;
HXDLIN( 469)											int this164 = ((color >> 8) & 255);
HXDLIN( 469)											if ((this164 == 0)) {
HXDLIN( 469)												g29 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												g29 = (( (Float)(this164) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float b213;
HXDLIN( 469)											int this165 = (color & 255);
HXDLIN( 469)											if ((this165 == 0)) {
HXDLIN( 469)												b213 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												b213 = (( (Float)(this165) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 469)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a311) + (r29 * a212))));
HXDLIN( 469)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a311) + (g29 * a212))));
HXDLIN( 469)											int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b213 * a212))));
HXDLIN( 469)											int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 469)											int blended9 = ((((a43 << 24) | (r20 << 16)) | (g20 << 8)) | b42);
HXDLIN( 469)											{
HXDLIN( 469)												int hitQuad39;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad39 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad39 = blended9;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this1->image,location9,hitQuad39);
            											}
            										}
            										else {
HXDLIN( 469)											::Dynamic this166 = this1->image;
HXDLIN( 469)											int index24;
HXDLIN( 469)											if (this1->useVirtualPos) {
HXDLIN( 469)												index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this1->virtualY) * ( (Float)(this1->width) )) + x19) - this1->virtualX));
            											}
            											else {
HXDLIN( 469)												index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this1->width) + x19)) ));
            											}
HXDLIN( 469)											int hitQuad40;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												hitQuad40 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												hitQuad40 = c27;
            											}
HXDLIN( 469)											::iterMagic::Iimg_obj::set(this166,index24,hitQuad40);
            										}
            									}
HXLINE(  73)									found4 = true;
            								}
            								else {
HXDLIN( 469)									if (found4) {
HXDLIN( 469)										goto _hx_goto_835;
            									}
            								}
            							}
            						}
            						_hx_goto_835:;
            					}
            				}
            			}
HXDLIN( 469)			 ::pi_xy::iter::IntIterStart v_yIter34;
HXDLIN( 469)			 ::pi_xy::iter::IntIterStart v_xIter34;
HXDLIN( 469)			int v_undoY4;
HXDLIN( 469)			int v_undoX4;
HXDLIN( 469)			Float v_ty4;
HXDLIN( 469)			Float v_tx4;
HXDLIN( 469)			Float v_t04;
HXDLIN( 469)			Float v_sy4;
HXDLIN( 469)			Float v_sx4;
HXDLIN( 469)			Float v_s04;
HXDLIN( 469)			Float v_A4;
HXDLIN( 469)			Float ax7 = ax6;
HXDLIN( 469)			Float ay7 = ay6;
HXDLIN( 469)			 ::pi_xy::ImageStruct v_undoImage4 = null();
HXDLIN( 469)			Float bx12 = bx11;
HXDLIN( 469)			Float by12 = by11;
HXDLIN( 469)			Float cx12 = cx11;
HXDLIN( 469)			Float cy12 = cy11;
HXDLIN( 469)			bool adjustWinding9 = (((((ax7 * by12) - (bx12 * ay7)) + ((bx12 * cy12) - (cx12 * by12))) + ((cx12 * ay7) - (ax7 * cy12))) > 0);
HXDLIN( 469)			if (!(adjustWinding9)) {
HXDLIN( 469)				Float bx_9 = bx12;
HXDLIN( 469)				Float by_9 = by12;
HXLINE(  24)				bx12 = cx12;
HXLINE(  25)				by12 = cy12;
HXLINE(  26)				cx12 = bx_9;
HXLINE(  27)				cy12 = by_9;
            			}
HXLINE( 469)			Float v_ax4 = ax7;
HXDLIN( 469)			Float v_ay4 = ay7;
HXDLIN( 469)			Float v_bx4 = bx12;
HXDLIN( 469)			Float v_by4 = by12;
HXDLIN( 469)			Float v_cx4 = cx12;
HXDLIN( 469)			Float v_cy4 = cy12;
HXDLIN( 469)			bool v_preCalculated4 = true;
HXDLIN( 469)			{
HXDLIN( 469)				v_s04 = ((v_ay4 * v_cx4) - (v_ax4 * v_cy4));
HXDLIN( 469)				v_sx4 = (v_cy4 - v_ay4);
HXDLIN( 469)				v_sy4 = (v_ax4 - v_cx4);
HXDLIN( 469)				v_t04 = ((v_ax4 * v_by4) - (v_ay4 * v_bx4));
HXDLIN( 469)				v_tx4 = (v_ay4 - v_by4);
HXDLIN( 469)				v_ty4 = (v_bx4 - v_ax4);
HXDLIN( 469)				v_A4 = ((((-(v_by4) * v_cx4) + (v_ay4 * (-(v_bx4) + v_cx4))) + (v_ax4 * (v_by4 - v_cy4))) + (v_bx4 * v_cy4));
HXDLIN( 469)				Float a44 = v_ax4;
HXDLIN( 469)				Float b43 = v_bx4;
HXDLIN( 469)				Float c28 = v_cx4;
HXDLIN( 469)				if ((a44 > b43)) {
HXDLIN( 469)					if ((a44 > c28)) {
HXDLIN( 469)						int min36;
HXDLIN( 469)						if ((b43 > c28)) {
HXDLIN( 469)							min36 = ::Math_obj::floor(c28);
            						}
            						else {
HXDLIN( 469)							min36 = ::Math_obj::floor(b43);
            						}
HXDLIN( 469)						int ii_min72 = min36;
HXDLIN( 469)						int ii_max72 = ::Math_obj::ceil(a44);
HXDLIN( 469)						v_xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            					}
            					else {
HXDLIN( 469)						int ii_min73 = ::Math_obj::floor(b43);
HXDLIN( 469)						int ii_max73 = ::Math_obj::ceil(c28);
HXDLIN( 469)						v_xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            					}
            				}
            				else {
HXDLIN( 469)					if ((b43 > c28)) {
HXDLIN( 469)						int min37;
HXDLIN( 469)						if ((a44 > c28)) {
HXDLIN( 469)							min37 = ::Math_obj::floor(c28);
            						}
            						else {
HXDLIN( 469)							min37 = ::Math_obj::ceil(a44);
            						}
HXDLIN( 469)						int ii_min74 = min37;
HXDLIN( 469)						int ii_max74 = ::Math_obj::ceil(b43);
HXDLIN( 469)						v_xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min74,ii_max74);
            					}
            					else {
HXDLIN( 469)						int ii_min75 = ::Math_obj::floor(a44);
HXDLIN( 469)						int ii_max75 = ::Math_obj::ceil(c28);
HXDLIN( 469)						v_xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min75,ii_max75);
            					}
            				}
HXDLIN( 469)				Float a45 = v_ay4;
HXDLIN( 469)				Float b44 = v_by4;
HXDLIN( 469)				Float c29 = v_cy4;
HXDLIN( 469)				if ((a45 > b44)) {
HXDLIN( 469)					if ((a45 > c29)) {
HXDLIN( 469)						int min38;
HXDLIN( 469)						if ((b44 > c29)) {
HXDLIN( 469)							min38 = ::Math_obj::floor(c29);
            						}
            						else {
HXDLIN( 469)							min38 = ::Math_obj::floor(b44);
            						}
HXDLIN( 469)						int ii_min76 = min38;
HXDLIN( 469)						int ii_max76 = ::Math_obj::ceil(a45);
HXDLIN( 469)						v_yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min76,ii_max76);
            					}
            					else {
HXDLIN( 469)						int ii_min77 = ::Math_obj::floor(b44);
HXDLIN( 469)						int ii_max77 = ::Math_obj::ceil(c29);
HXDLIN( 469)						v_yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min77,ii_max77);
            					}
            				}
            				else {
HXDLIN( 469)					if ((b44 > c29)) {
HXDLIN( 469)						int min39;
HXDLIN( 469)						if ((a45 > c29)) {
HXDLIN( 469)							min39 = ::Math_obj::floor(c29);
            						}
            						else {
HXDLIN( 469)							min39 = ::Math_obj::ceil(a45);
            						}
HXDLIN( 469)						int ii_min78 = min39;
HXDLIN( 469)						int ii_max78 = ::Math_obj::ceil(b44);
HXDLIN( 469)						v_yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min78,ii_max78);
            					}
            					else {
HXDLIN( 469)						int ii_min79 = ::Math_obj::floor(a45);
HXDLIN( 469)						int ii_max79 = ::Math_obj::ceil(c29);
HXDLIN( 469)						v_yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min79,ii_max79);
            					}
            				}
            			}
HXDLIN( 469)			if (hasUndo4) {
HXDLIN( 469)				v_undoImage4 = undoImage12;
HXDLIN( 469)				v_undoX4 = xIter34->start;
HXDLIN( 469)				v_undoY4 = yIter34->start;
            			}
HXDLIN( 469)			Float bx13 = cx10;
HXDLIN( 469)			Float by13 = cy10;
HXDLIN( 469)			Float cx13 = dx6;
HXDLIN( 469)			Float cy13 = dy6;
HXDLIN( 469)			bool hasUndo5 = false;
HXDLIN( 469)			bool adjustWinding10 = (((((bx10 * by13) - (bx13 * by10)) + ((bx13 * cy13) - (cx13 * by13))) + ((cx13 * by10) - (bx10 * cy13))) > 0);
HXDLIN( 469)			if (!(adjustWinding10)) {
HXDLIN( 469)				Float bx_10 = bx13;
HXDLIN( 469)				Float by_10 = by13;
HXLINE(  25)				bx13 = cx13;
HXLINE(  26)				by13 = cy13;
HXLINE(  27)				cx13 = bx_10;
HXLINE(  28)				cy13 = by_10;
            			}
HXLINE( 469)			Float s05 = ((by10 * cx13) - (bx10 * cy13));
HXDLIN( 469)			Float sx5 = (cy13 - by10);
HXDLIN( 469)			Float sy5 = (bx10 - cx13);
HXDLIN( 469)			Float t05 = ((bx10 * by13) - (by10 * bx13));
HXDLIN( 469)			Float tx5 = (by10 - by13);
HXDLIN( 469)			Float ty5 = (bx13 - bx10);
HXDLIN( 469)			Float A5 = ((((-(by13) * cx13) + (by10 * (-(bx13) + cx13))) + (bx10 * (by13 - cy13))) + (bx13 * cy13));
HXDLIN( 469)			 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 469)			if ((bx10 > bx13)) {
HXDLIN( 469)				if ((bx10 > cx13)) {
HXDLIN( 469)					int min40;
HXDLIN( 469)					if ((bx13 > cx13)) {
HXDLIN( 469)						min40 = ::Math_obj::floor(cx13);
            					}
            					else {
HXDLIN( 469)						min40 = ::Math_obj::floor(bx13);
            					}
HXDLIN( 469)					int ii_min80 = min40;
HXDLIN( 469)					int ii_max80 = ::Math_obj::ceil(bx10);
HXDLIN( 469)					xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min80,ii_max80);
            				}
            				else {
HXDLIN( 469)					int ii_min81 = ::Math_obj::floor(bx13);
HXDLIN( 469)					int ii_max81 = ::Math_obj::ceil(cx13);
HXDLIN( 469)					xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min81,ii_max81);
            				}
            			}
            			else {
HXDLIN( 469)				if ((bx13 > cx13)) {
HXDLIN( 469)					int min41;
HXDLIN( 469)					if ((bx10 > cx13)) {
HXDLIN( 469)						min41 = ::Math_obj::floor(cx13);
            					}
            					else {
HXDLIN( 469)						min41 = ::Math_obj::ceil(bx10);
            					}
HXDLIN( 469)					int ii_min82 = min41;
HXDLIN( 469)					int ii_max82 = ::Math_obj::ceil(bx13);
HXDLIN( 469)					xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min82,ii_max82);
            				}
            				else {
HXDLIN( 469)					int ii_min83 = ::Math_obj::floor(bx10);
HXDLIN( 469)					int ii_max83 = ::Math_obj::ceil(cx13);
HXDLIN( 469)					xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min83,ii_max83);
            				}
            			}
HXDLIN( 469)			 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 469)			if ((by10 > by13)) {
HXDLIN( 469)				if ((by10 > cy13)) {
HXDLIN( 469)					int min42;
HXDLIN( 469)					if ((by13 > cy13)) {
HXDLIN( 469)						min42 = ::Math_obj::floor(cy13);
            					}
            					else {
HXDLIN( 469)						min42 = ::Math_obj::floor(by13);
            					}
HXDLIN( 469)					int ii_min84 = min42;
HXDLIN( 469)					int ii_max84 = ::Math_obj::ceil(by10);
HXDLIN( 469)					yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min84,ii_max84);
            				}
            				else {
HXDLIN( 469)					int ii_min85 = ::Math_obj::floor(by13);
HXDLIN( 469)					int ii_max85 = ::Math_obj::ceil(cy13);
HXDLIN( 469)					yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min85,ii_max85);
            				}
            			}
            			else {
HXDLIN( 469)				if ((by13 > cy13)) {
HXDLIN( 469)					int min43;
HXDLIN( 469)					if ((by10 > cy13)) {
HXDLIN( 469)						min43 = ::Math_obj::floor(cy13);
            					}
            					else {
HXDLIN( 469)						min43 = ::Math_obj::ceil(by10);
            					}
HXDLIN( 469)					int ii_min86 = min43;
HXDLIN( 469)					int ii_max86 = ::Math_obj::ceil(by13);
HXDLIN( 469)					yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min86,ii_max86);
            				}
            				else {
HXDLIN( 469)					int ii_min87 = ::Math_obj::floor(by10);
HXDLIN( 469)					int ii_max87 = ::Math_obj::ceil(cy13);
HXDLIN( 469)					yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min87,ii_max87);
            				}
            			}
HXDLIN( 469)			 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 469)			if (hasUndo5) {
HXDLIN( 469)				int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 469)				int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 469)				 ::Dynamic imageType5 = null();
HXDLIN( 469)				 ::pi_xy::ImageStruct this167 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 469)				if (::hx::IsNull( imageType5 )) {
HXLINE(  54)					imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 469)				::Dynamic undoImage16;
HXDLIN( 469)				switch((int)(( (int)(imageType5) ))){
            					case (int)0: {
HXDLIN( 469)						 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::BytesImg b45 = byt5;
HXDLIN( 469)						{
HXDLIN( 469)							b45->width = width5;
HXDLIN( 469)							b45->height = height5;
HXDLIN( 469)							b45->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 469)							b45->data = ::haxe::io::Bytes_obj::alloc((b45->length * 4));
HXDLIN( 469)							{
HXDLIN( 469)								int len10 = b45->length;
HXDLIN( 469)								int w5 = 0;
HXDLIN( 469)								{
HXDLIN( 469)									int _g100 = 0;
HXDLIN( 469)									int _g101 = b45->height;
HXDLIN( 469)									while((_g100 < _g101)){
HXDLIN( 469)										_g100 = (_g100 + 1);
HXDLIN( 469)										int y20 = (_g100 - 1);
HXDLIN( 469)										{
HXDLIN( 469)											int _g102 = 0;
HXDLIN( 469)											int _g103 = b45->width;
HXDLIN( 469)											while((_g102 < _g103)){
HXDLIN( 469)												_g102 = (_g102 + 1);
HXDLIN( 469)												int x20 = (_g102 - 1);
HXDLIN( 469)												{
HXDLIN( 469)													w5 = (w5 + 1);
HXDLIN( 469)													b45->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 469)												{
HXDLIN( 469)													w5 = (w5 + 1);
HXDLIN( 469)													b45->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 469)												{
HXDLIN( 469)													w5 = (w5 + 1);
HXDLIN( 469)													b45->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 469)												{
HXDLIN( 469)													w5 = (w5 + 1);
HXDLIN( 469)													b45->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 469)						undoImage16 = b45;
            					}
            					break;
            					case (int)1: {
HXDLIN( 469)						 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::ArrIntImg a46 = arrI5;
HXDLIN( 469)						{
HXDLIN( 469)							a46->width = width5;
HXDLIN( 469)							a46->height = height5;
HXDLIN( 469)							a46->data = ::Array_obj< int >::__new(0);
HXDLIN( 469)							a46->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 469)							{
HXDLIN( 469)								int _g104 = 0;
HXDLIN( 469)								int _g105 = a46->length;
HXDLIN( 469)								while((_g104 < _g105)){
HXDLIN( 469)									_g104 = (_g104 + 1);
HXDLIN( 469)									int i30 = (_g104 - 1);
HXDLIN( 469)									a46->data[i30] = 0;
            								}
            							}
            						}
HXDLIN( 469)						undoImage16 = a46;
            					}
            					break;
            					case (int)2: {
HXDLIN( 469)						 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::U32ArrImg b46 = u32a5;
HXDLIN( 469)						{
HXDLIN( 469)							b46->width = width5;
HXDLIN( 469)							b46->height = height5;
HXDLIN( 469)							b46->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 469)							int size5 = (b46->length * 4);
HXDLIN( 469)							b46->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 469)							{
HXDLIN( 469)								int _g106 = 0;
HXDLIN( 469)								int _g107 = b46->length;
HXDLIN( 469)								while((_g106 < _g107)){
HXDLIN( 469)									_g106 = (_g106 + 1);
HXDLIN( 469)									int i31 = (_g106 - 1);
HXDLIN( 469)									{
HXDLIN( 469)										 ::haxe::io::ArrayBufferViewImpl this168 = b46->data;
HXDLIN( 469)										bool undoImage17;
HXDLIN( 469)										if ((i31 >= 0)) {
HXDLIN( 469)											undoImage17 = (i31 < (this168->byteLength >> 2));
            										}
            										else {
HXDLIN( 469)											undoImage17 = false;
            										}
HXDLIN( 469)										if (undoImage17) {
HXDLIN( 469)											 ::haxe::io::Bytes _this5 = this168->bytes;
HXDLIN( 469)											int pos5 = ((i31 << 2) + this168->byteOffset);
HXDLIN( 469)											_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 469)											_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 469)											_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 469)											_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 469)						undoImage16 = b46;
            					}
            					break;
            					case (int)3: {
HXDLIN( 469)						 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::VecIntImg v12 = vec5;
HXDLIN( 469)						{
HXDLIN( 469)							v12->width = width5;
HXDLIN( 469)							v12->height = height5;
HXDLIN( 469)							v12->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 469)							v12->data = ::Array_obj< int >::__new(v12->length);
HXDLIN( 469)							{
HXDLIN( 469)								int _g108 = 0;
HXDLIN( 469)								int _g109 = v12->length;
HXDLIN( 469)								while((_g108 < _g109)){
HXDLIN( 469)									_g108 = (_g108 + 1);
HXDLIN( 469)									int i32 = (_g108 - 1);
HXDLIN( 469)									v12->data->__unsafe_set(i32,0);
            								}
            							}
            						}
HXDLIN( 469)						undoImage16 = v12;
            					}
            					break;
            					case (int)4: {
HXDLIN( 469)						 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)						 ::iterMagic::StackIntImg b47 = sInt5;
HXDLIN( 469)						{
HXDLIN( 469)							b47->width = width5;
HXDLIN( 469)							b47->height = height5;
HXDLIN( 469)							b47->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 469)							b47->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 469)							{
HXDLIN( 469)								int len11 = b47->length;
HXDLIN( 469)								 ::haxe::ds::GenericStack_Int d5 = b47->data;
HXDLIN( 469)								if (::hx::IsNull( d5->head )) {
HXDLIN( 469)									int _g110 = 0;
HXDLIN( 469)									int _g111 = len11;
HXDLIN( 469)									while((_g110 < _g111)){
HXDLIN( 469)										_g110 = (_g110 + 1);
HXDLIN( 469)										int i33 = (_g110 - 1);
HXDLIN( 469)										d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            									}
            								}
            								else {
HXDLIN( 469)									int _g112 = 0;
HXDLIN( 469)									int _g113 = len11;
HXDLIN( 469)									while((_g112 < _g113)){
HXDLIN( 469)										_g112 = (_g112 + 1);
HXDLIN( 469)										int i34 = (_g112 - 1);
HXDLIN( 469)										{
HXDLIN( 469)											 ::haxe::ds::GenericCell_Int l5 = b47->data->head;
HXDLIN( 469)											 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 469)											{
HXDLIN( 469)												int _g114 = 0;
HXDLIN( 469)												int _g115 = i34;
HXDLIN( 469)												while((_g114 < _g115)){
HXDLIN( 469)													_g114 = (_g114 + 1);
HXDLIN( 469)													int i35 = (_g114 - 1);
HXLINE( 345)													prev5 = l5;
HXLINE( 346)													l5 = l5->next;
            												}
            											}
HXLINE( 469)											if (::hx::IsNull( prev5 )) {
HXDLIN( 469)												b47->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 469)												l5 = null();
            											}
            											else {
HXDLIN( 469)												prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 469)												l5 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 469)						undoImage16 = b47;
            					}
            					break;
            				}
HXDLIN( 469)				this167->image = undoImage16;
HXDLIN( 469)				this167->width = width5;
HXDLIN( 469)				this167->height = height5;
HXDLIN( 469)				this167->imageType = ( (int)(imageType5) );
HXDLIN( 469)				undoImage15 = this167;
HXDLIN( 469)				{
HXDLIN( 469)					int rectLeft5 = xIter35->start;
HXDLIN( 469)					int rectTop5 = yIter35->start;
HXDLIN( 469)					int rectRight5 = xIter35->max;
HXDLIN( 469)					bool forceClear5 = false;
HXDLIN( 469)					{
HXDLIN( 469)						int _g116 = rectTop5;
HXDLIN( 469)						int _g117 = yIter35->max;
HXDLIN( 469)						while((_g116 < _g117)){
HXDLIN( 469)							_g116 = (_g116 + 1);
HXDLIN( 469)							int dy8 = (_g116 - 1);
HXDLIN( 469)							{
HXDLIN( 469)								int _g118 = rectLeft5;
HXDLIN( 469)								int _g119 = rectRight5;
HXDLIN( 469)								while((_g118 < _g119)){
HXDLIN( 469)									_g118 = (_g118 + 1);
HXDLIN( 469)									int dx8 = (_g118 - 1);
HXDLIN( 469)									::Dynamic this169 = this1->image;
HXDLIN( 469)									int index25;
HXDLIN( 469)									if (this1->useVirtualPos) {
HXDLIN( 469)										index25 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx8) - this1->virtualX));
            									}
            									else {
HXDLIN( 469)										index25 = ::Std_obj::_hx_int(( (Float)(((dy8 * this1->width) + dx8)) ));
            									}
HXDLIN( 469)									int c30 = ::iterMagic::Iimg_obj::get(this169,index25);
HXDLIN( 469)									int col5;
HXDLIN( 469)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)										col5 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            									}
            									else {
HXDLIN( 469)										col5 = c30;
            									}
HXDLIN( 469)									bool hitQuad41;
HXDLIN( 469)									if (this1->useMask) {
HXDLIN( 469)										hitQuad41 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN( 469)										hitQuad41 = false;
            									}
HXDLIN( 469)									if (hitQuad41) {
HXDLIN( 469)										 ::pi_xy::ImageStruct this170 = this1->mask;
HXDLIN( 469)										::Dynamic this171 = this170->image;
HXDLIN( 469)										int index26;
HXDLIN( 469)										if (this170->useVirtualPos) {
HXDLIN( 469)											index26 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this170->virtualY) * ( (Float)(this170->width) )) + dx8) - this170->virtualX));
            										}
            										else {
HXDLIN( 469)											index26 = ::Std_obj::_hx_int(( (Float)(((dy8 * this170->width) + dx8)) ));
            										}
HXDLIN( 469)										int c31 = ::iterMagic::Iimg_obj::get(this171,index26);
HXDLIN( 469)										int v13;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											v13 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											v13 = c31;
            										}
HXDLIN( 469)										int maskPixel5 = v13;
HXDLIN( 469)										int this172 = col5;
HXDLIN( 469)										if ((maskPixel5 == 0)) {
HXDLIN( 469)											col5 = this172;
            										}
            										else {
HXDLIN( 469)											Float m05;
HXDLIN( 469)											int this173 = ((maskPixel5 >> 24) & 255);
HXDLIN( 469)											if ((this173 == 0)) {
HXDLIN( 469)												m05 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												m05 = (( (Float)(this173) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float m15;
HXDLIN( 469)											int this174 = ((maskPixel5 >> 16) & 255);
HXDLIN( 469)											if ((this174 == 0)) {
HXDLIN( 469)												m15 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												m15 = (( (Float)(this174) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float m25;
HXDLIN( 469)											int this175 = ((maskPixel5 >> 8) & 255);
HXDLIN( 469)											if ((this175 == 0)) {
HXDLIN( 469)												m25 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												m25 = (( (Float)(this175) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float m35;
HXDLIN( 469)											int this176 = (maskPixel5 & 255);
HXDLIN( 469)											if ((this176 == 0)) {
HXDLIN( 469)												m35 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												m35 = (( (Float)(this176) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this172 >> 24) & 255)) )));
HXDLIN( 469)											int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this172 >> 16) & 255)) )));
HXDLIN( 469)											int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this172 >> 8) & 255)) )));
HXDLIN( 469)											int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this172 & 255)) )));
HXDLIN( 469)											col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 469)									if ((col5 != 0)) {
HXDLIN( 469)										int x21 = (dx8 - rectLeft5);
HXDLIN( 469)										int y21 = (dy8 - rectTop5);
HXDLIN( 469)										int c32 = col5;
HXDLIN( 469)										bool hitQuad42;
HXDLIN( 469)										if ((((c32 >> 24) & 255) < 254)) {
HXDLIN( 469)											hitQuad42 = undoImage15->transparent;
            										}
            										else {
HXDLIN( 469)											hitQuad42 = false;
            										}
HXDLIN( 469)										if (hitQuad42) {
HXDLIN( 469)											int location10;
HXDLIN( 469)											if (undoImage15->useVirtualPos) {
HXDLIN( 469)												location10 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x21) - undoImage15->virtualX));
            											}
            											else {
HXDLIN( 469)												location10 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage15->width) + x21)) ));
            											}
HXDLIN( 469)											int this177 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 469)											int this178;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												this178 = ((((((this177 >> 24) & 255) << 24) | ((this177 & 255) << 16)) | (((this177 >> 8) & 255) << 8)) | ((this177 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												this178 = this177;
            											}
HXDLIN( 469)											Float a115;
HXDLIN( 469)											int this179 = ((this178 >> 24) & 255);
HXDLIN( 469)											if ((this179 == 0)) {
HXDLIN( 469)												a115 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												a115 = (( (Float)(this179) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float r110;
HXDLIN( 469)											int this180 = ((this178 >> 16) & 255);
HXDLIN( 469)											if ((this180 == 0)) {
HXDLIN( 469)												r110 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												r110 = (( (Float)(this180) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float g110;
HXDLIN( 469)											int this181 = ((this178 >> 8) & 255);
HXDLIN( 469)											if ((this181 == 0)) {
HXDLIN( 469)												g110 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												g110 = (( (Float)(this181) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float b116;
HXDLIN( 469)											int this182 = (this178 & 255);
HXDLIN( 469)											if ((this182 == 0)) {
HXDLIN( 469)												b116 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												b116 = (( (Float)(this182) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float a213;
HXDLIN( 469)											int this183 = ((col5 >> 24) & 255);
HXDLIN( 469)											if ((this183 == 0)) {
HXDLIN( 469)												a213 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												a213 = (( (Float)(this183) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float r210;
HXDLIN( 469)											int this184 = ((col5 >> 16) & 255);
HXDLIN( 469)											if ((this184 == 0)) {
HXDLIN( 469)												r210 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												r210 = (( (Float)(this184) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float g210;
HXDLIN( 469)											int this185 = ((col5 >> 8) & 255);
HXDLIN( 469)											if ((this185 == 0)) {
HXDLIN( 469)												g210 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												g210 = (( (Float)(this185) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float b214;
HXDLIN( 469)											int this186 = (col5 & 255);
HXDLIN( 469)											if ((this186 == 0)) {
HXDLIN( 469)												b214 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												b214 = (( (Float)(this186) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 469)											int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a312) + (r210 * a213))));
HXDLIN( 469)											int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a312) + (g210 * a213))));
HXDLIN( 469)											int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b214 * a213))));
HXDLIN( 469)											int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 469)											int blended10 = ((((a47 << 24) | (r30 << 16)) | (g30 << 8)) | b48);
HXDLIN( 469)											{
HXDLIN( 469)												int hitQuad43;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad43 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad43 = blended10;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(undoImage15->image,location10,hitQuad43);
            											}
            										}
            										else {
HXDLIN( 469)											::Dynamic this187 = undoImage15->image;
HXDLIN( 469)											int index27;
HXDLIN( 469)											if (undoImage15->useVirtualPos) {
HXDLIN( 469)												index27 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x21) - undoImage15->virtualX));
            											}
            											else {
HXDLIN( 469)												index27 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage15->width) + x21)) ));
            											}
HXDLIN( 469)											int hitQuad44;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												hitQuad44 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												hitQuad44 = c32;
            											}
HXDLIN( 469)											::iterMagic::Iimg_obj::set(this187,index27,hitQuad44);
            										}
            									}
            									else {
HXDLIN( 469)										if (forceClear5) {
HXDLIN( 469)											::Dynamic this188 = undoImage15->image;
HXDLIN( 469)											int x22 = (dx8 - rectLeft5);
HXDLIN( 469)											int y22 = (dy8 - rectTop5);
HXDLIN( 469)											int index28;
HXDLIN( 469)											if (undoImage15->useVirtualPos) {
HXDLIN( 469)												index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x22) - undoImage15->virtualX));
            											}
            											else {
HXDLIN( 469)												index28 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage15->width) + x22)) ));
            											}
HXDLIN( 469)											::iterMagic::Iimg_obj::set(this188,index28,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 469)			bool found5 = false;
HXDLIN( 469)			Float s5 = ((Float)0.);
HXDLIN( 469)			Float t5 = ((Float)0.);
HXDLIN( 469)			Float sxx5 = ((Float)0.);
HXDLIN( 469)			Float txx5 = ((Float)0.);
HXDLIN( 469)			{
HXDLIN( 469)				int _g_min10 = xIter35->start;
HXDLIN( 469)				int _g_max10 = xIter35->max;
HXDLIN( 469)				while((_g_min10 < _g_max10)){
HXDLIN( 469)					_g_min10 = (_g_min10 + 1);
HXDLIN( 469)					int x23 = (_g_min10 - 1);
HXLINE(  60)					sxx5 = (sx5 * ( (Float)(x23) ));
HXLINE(  61)					txx5 = (tx5 * ( (Float)(x23) ));
HXLINE(  62)					found5 = false;
HXLINE( 469)					{
HXDLIN( 469)						int _g_min11 = yIter35->start;
HXDLIN( 469)						int _g_max11 = yIter35->max;
HXDLIN( 469)						while((_g_min11 < _g_max11)){
HXDLIN( 469)							_g_min11 = (_g_min11 + 1);
HXDLIN( 469)							int y23 = (_g_min11 - 1);
HXLINE(  64)							s5 = ((s05 + sxx5) + (sy5 * ( (Float)(y23) )));
HXLINE(  65)							t5 = ((t05 + txx5) + (ty5 * ( (Float)(y23) )));
HXLINE( 469)							bool hitQuad45;
HXDLIN( 469)							if (!((s5 <= 0))) {
HXDLIN( 469)								hitQuad45 = (t5 <= 0);
            							}
            							else {
HXDLIN( 469)								hitQuad45 = true;
            							}
HXDLIN( 469)							if (hitQuad45) {
HXDLIN( 469)								if (found5) {
HXDLIN( 469)									goto _hx_goto_847;
            								}
            							}
            							else {
HXDLIN( 469)								if (((s5 + t5) < A5)) {
HXDLIN( 469)									{
HXDLIN( 469)										int c33 = color;
HXDLIN( 469)										bool hitQuad46;
HXDLIN( 469)										if ((((c33 >> 24) & 255) < 254)) {
HXDLIN( 469)											hitQuad46 = this1->transparent;
            										}
            										else {
HXDLIN( 469)											hitQuad46 = false;
            										}
HXDLIN( 469)										if (hitQuad46) {
HXDLIN( 469)											int location11;
HXDLIN( 469)											if (this1->useVirtualPos) {
HXDLIN( 469)												location11 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - this1->virtualY) * ( (Float)(this1->width) )) + x23) - this1->virtualX));
            											}
            											else {
HXDLIN( 469)												location11 = ::Std_obj::_hx_int(( (Float)(((y23 * this1->width) + x23)) ));
            											}
HXDLIN( 469)											int this189 = ::iterMagic::Iimg_obj::get(this1->image,location11);
HXDLIN( 469)											int this190;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												this190 = ((((((this189 >> 24) & 255) << 24) | ((this189 & 255) << 16)) | (((this189 >> 8) & 255) << 8)) | ((this189 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												this190 = this189;
            											}
HXDLIN( 469)											Float a116;
HXDLIN( 469)											int this191 = ((this190 >> 24) & 255);
HXDLIN( 469)											if ((this191 == 0)) {
HXDLIN( 469)												a116 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												a116 = (( (Float)(this191) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float r111;
HXDLIN( 469)											int this192 = ((this190 >> 16) & 255);
HXDLIN( 469)											if ((this192 == 0)) {
HXDLIN( 469)												r111 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												r111 = (( (Float)(this192) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float g111;
HXDLIN( 469)											int this193 = ((this190 >> 8) & 255);
HXDLIN( 469)											if ((this193 == 0)) {
HXDLIN( 469)												g111 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												g111 = (( (Float)(this193) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float b117;
HXDLIN( 469)											int this194 = (this190 & 255);
HXDLIN( 469)											if ((this194 == 0)) {
HXDLIN( 469)												b117 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												b117 = (( (Float)(this194) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float a214;
HXDLIN( 469)											int this195 = ((color >> 24) & 255);
HXDLIN( 469)											if ((this195 == 0)) {
HXDLIN( 469)												a214 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												a214 = (( (Float)(this195) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float r211;
HXDLIN( 469)											int this196 = ((color >> 16) & 255);
HXDLIN( 469)											if ((this196 == 0)) {
HXDLIN( 469)												r211 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												r211 = (( (Float)(this196) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float g211;
HXDLIN( 469)											int this197 = ((color >> 8) & 255);
HXDLIN( 469)											if ((this197 == 0)) {
HXDLIN( 469)												g211 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												g211 = (( (Float)(this197) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float b215;
HXDLIN( 469)											int this198 = (color & 255);
HXDLIN( 469)											if ((this198 == 0)) {
HXDLIN( 469)												b215 = ((Float)0.);
            											}
            											else {
HXDLIN( 469)												b215 = (( (Float)(this198) ) / ( (Float)(255) ));
            											}
HXDLIN( 469)											Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN( 469)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a313) + (r211 * a214))));
HXDLIN( 469)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a313) + (g211 * a214))));
HXDLIN( 469)											int b49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b215 * a214))));
HXDLIN( 469)											int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 469)											int blended11 = ((((a48 << 24) | (r31 << 16)) | (g31 << 8)) | b49);
HXDLIN( 469)											{
HXDLIN( 469)												int hitQuad47;
HXDLIN( 469)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)													hitQuad47 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXDLIN( 469)													hitQuad47 = blended11;
            												}
HXDLIN( 469)												::iterMagic::Iimg_obj::set(this1->image,location11,hitQuad47);
            											}
            										}
            										else {
HXDLIN( 469)											::Dynamic this199 = this1->image;
HXDLIN( 469)											int index29;
HXDLIN( 469)											if (this1->useVirtualPos) {
HXDLIN( 469)												index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - this1->virtualY) * ( (Float)(this1->width) )) + x23) - this1->virtualX));
            											}
            											else {
HXDLIN( 469)												index29 = ::Std_obj::_hx_int(( (Float)(((y23 * this1->width) + x23)) ));
            											}
HXDLIN( 469)											int hitQuad48;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												hitQuad48 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												hitQuad48 = c33;
            											}
HXDLIN( 469)											::iterMagic::Iimg_obj::set(this199,index29,hitQuad48);
            										}
            									}
HXLINE(  73)									found5 = true;
            								}
            								else {
HXDLIN( 469)									if (found5) {
HXDLIN( 469)										goto _hx_goto_847;
            									}
            								}
            							}
            						}
            						_hx_goto_847:;
            					}
            				}
            			}
HXDLIN( 469)			 ::pi_xy::iter::IntIterStart v_yIter35;
HXDLIN( 469)			 ::pi_xy::iter::IntIterStart v_xIter35;
HXDLIN( 469)			int v_undoY5;
HXDLIN( 469)			int v_undoX5;
HXDLIN( 469)			Float v_ty5;
HXDLIN( 469)			Float v_tx5;
HXDLIN( 469)			Float v_t05;
HXDLIN( 469)			Float v_sy5;
HXDLIN( 469)			Float v_sx5;
HXDLIN( 469)			Float v_s05;
HXDLIN( 469)			Float v_A5;
HXDLIN( 469)			Float ax8 = bx10;
HXDLIN( 469)			Float ay8 = by10;
HXDLIN( 469)			 ::pi_xy::ImageStruct v_undoImage5 = null();
HXDLIN( 469)			Float bx14 = bx13;
HXDLIN( 469)			Float by14 = by13;
HXDLIN( 469)			Float cx14 = cx13;
HXDLIN( 469)			Float cy14 = cy13;
HXDLIN( 469)			bool adjustWinding11 = (((((ax8 * by14) - (bx14 * ay8)) + ((bx14 * cy14) - (cx14 * by14))) + ((cx14 * ay8) - (ax8 * cy14))) > 0);
HXDLIN( 469)			if (!(adjustWinding11)) {
HXDLIN( 469)				Float bx_11 = bx14;
HXDLIN( 469)				Float by_11 = by14;
HXLINE(  24)				bx14 = cx14;
HXLINE(  25)				by14 = cy14;
HXLINE(  26)				cx14 = bx_11;
HXLINE(  27)				cy14 = by_11;
            			}
HXLINE( 469)			Float v_ax5 = ax8;
HXDLIN( 469)			Float v_ay5 = ay8;
HXDLIN( 469)			Float v_bx5 = bx14;
HXDLIN( 469)			Float v_by5 = by14;
HXDLIN( 469)			Float v_cx5 = cx14;
HXDLIN( 469)			Float v_cy5 = cy14;
HXDLIN( 469)			bool v_preCalculated5 = true;
HXDLIN( 469)			{
HXDLIN( 469)				v_s05 = ((v_ay5 * v_cx5) - (v_ax5 * v_cy5));
HXDLIN( 469)				v_sx5 = (v_cy5 - v_ay5);
HXDLIN( 469)				v_sy5 = (v_ax5 - v_cx5);
HXDLIN( 469)				v_t05 = ((v_ax5 * v_by5) - (v_ay5 * v_bx5));
HXDLIN( 469)				v_tx5 = (v_ay5 - v_by5);
HXDLIN( 469)				v_ty5 = (v_bx5 - v_ax5);
HXDLIN( 469)				v_A5 = ((((-(v_by5) * v_cx5) + (v_ay5 * (-(v_bx5) + v_cx5))) + (v_ax5 * (v_by5 - v_cy5))) + (v_bx5 * v_cy5));
HXDLIN( 469)				Float a49 = v_ax5;
HXDLIN( 469)				Float b50 = v_bx5;
HXDLIN( 469)				Float c34 = v_cx5;
HXDLIN( 469)				if ((a49 > b50)) {
HXDLIN( 469)					if ((a49 > c34)) {
HXDLIN( 469)						int min44;
HXDLIN( 469)						if ((b50 > c34)) {
HXDLIN( 469)							min44 = ::Math_obj::floor(c34);
            						}
            						else {
HXDLIN( 469)							min44 = ::Math_obj::floor(b50);
            						}
HXDLIN( 469)						int ii_min88 = min44;
HXDLIN( 469)						int ii_max88 = ::Math_obj::ceil(a49);
HXDLIN( 469)						v_xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min88,ii_max88);
            					}
            					else {
HXDLIN( 469)						int ii_min89 = ::Math_obj::floor(b50);
HXDLIN( 469)						int ii_max89 = ::Math_obj::ceil(c34);
HXDLIN( 469)						v_xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min89,ii_max89);
            					}
            				}
            				else {
HXDLIN( 469)					if ((b50 > c34)) {
HXDLIN( 469)						int min45;
HXDLIN( 469)						if ((a49 > c34)) {
HXDLIN( 469)							min45 = ::Math_obj::floor(c34);
            						}
            						else {
HXDLIN( 469)							min45 = ::Math_obj::ceil(a49);
            						}
HXDLIN( 469)						int ii_min90 = min45;
HXDLIN( 469)						int ii_max90 = ::Math_obj::ceil(b50);
HXDLIN( 469)						v_xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min90,ii_max90);
            					}
            					else {
HXDLIN( 469)						int ii_min91 = ::Math_obj::floor(a49);
HXDLIN( 469)						int ii_max91 = ::Math_obj::ceil(c34);
HXDLIN( 469)						v_xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min91,ii_max91);
            					}
            				}
HXDLIN( 469)				Float a50 = v_ay5;
HXDLIN( 469)				Float b51 = v_by5;
HXDLIN( 469)				Float c35 = v_cy5;
HXDLIN( 469)				if ((a50 > b51)) {
HXDLIN( 469)					if ((a50 > c35)) {
HXDLIN( 469)						int min46;
HXDLIN( 469)						if ((b51 > c35)) {
HXDLIN( 469)							min46 = ::Math_obj::floor(c35);
            						}
            						else {
HXDLIN( 469)							min46 = ::Math_obj::floor(b51);
            						}
HXDLIN( 469)						int ii_min92 = min46;
HXDLIN( 469)						int ii_max92 = ::Math_obj::ceil(a50);
HXDLIN( 469)						v_yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min92,ii_max92);
            					}
            					else {
HXDLIN( 469)						int ii_min93 = ::Math_obj::floor(b51);
HXDLIN( 469)						int ii_max93 = ::Math_obj::ceil(c35);
HXDLIN( 469)						v_yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min93,ii_max93);
            					}
            				}
            				else {
HXDLIN( 469)					if ((b51 > c35)) {
HXDLIN( 469)						int min47;
HXDLIN( 469)						if ((a50 > c35)) {
HXDLIN( 469)							min47 = ::Math_obj::floor(c35);
            						}
            						else {
HXDLIN( 469)							min47 = ::Math_obj::ceil(a50);
            						}
HXDLIN( 469)						int ii_min94 = min47;
HXDLIN( 469)						int ii_max94 = ::Math_obj::ceil(b51);
HXDLIN( 469)						v_yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min94,ii_max94);
            					}
            					else {
HXDLIN( 469)						int ii_min95 = ::Math_obj::floor(a50);
HXDLIN( 469)						int ii_max95 = ::Math_obj::ceil(c35);
HXDLIN( 469)						v_yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min95,ii_max95);
            					}
            				}
            			}
HXDLIN( 469)			if (hasUndo5) {
HXDLIN( 469)				v_undoImage5 = undoImage15;
HXDLIN( 469)				v_undoX5 = xIter35->start;
HXDLIN( 469)				v_undoY5 = yIter35->start;
            			}
HXDLIN( 469)			 ::pi_xy::algo::HitQuad v14 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax6,ay6,bx10,by10,cx10,cy10,dx6,dy6,true);
HXDLIN( 469)			hitQuad = v14;
            		}
HXDLIN( 469)		Float cx15 = h2;
HXDLIN( 469)		Float cy15 = radius2;
HXDLIN( 469)		Float bx15 = h2;
HXDLIN( 469)		Float by15 = -(radius2);
HXDLIN( 469)		Float temp3 = ((Float)0.);
HXLINE(  40)		temp3 = (px + ((bx15 * cos) - (by15 * sin)));
HXLINE(  41)		by15 = (py + ((by15 * cos) + (bx15 * sin)));
HXLINE(  42)		bx15 = temp3;
HXLINE(  43)		temp3 = (px + ((cx15 * cos) - (cy15 * sin)));
HXLINE(  44)		cy15 = (py + ((cy15 * cos) + (cx15 * sin)));
HXLINE(  45)		cx15 = temp3;
HXLINE( 469)		Float bx16 = bx15;
HXDLIN( 469)		Float by16 = by15;
HXDLIN( 469)		Float cx16 = cx15;
HXDLIN( 469)		Float cy16 = cy15;
HXDLIN( 469)		bool hasUndo6 = false;
HXDLIN( 469)		bool adjustWinding12 = (((((qx * by16) - (bx16 * qy)) + ((bx16 * cy16) - (cx16 * by16))) + ((cx16 * qy) - (qx * cy16))) > 0);
HXDLIN( 469)		if (!(adjustWinding12)) {
HXDLIN( 469)			Float bx_12 = bx16;
HXDLIN( 469)			Float by_12 = by16;
HXLINE(  25)			bx16 = cx16;
HXLINE(  26)			by16 = cy16;
HXLINE(  27)			cx16 = bx_12;
HXLINE(  28)			cy16 = by_12;
            		}
HXLINE( 469)		Float s06 = ((qy * cx16) - (qx * cy16));
HXDLIN( 469)		Float sx6 = (cy16 - qy);
HXDLIN( 469)		Float sy6 = (qx - cx16);
HXDLIN( 469)		Float t06 = ((qx * by16) - (qy * bx16));
HXDLIN( 469)		Float tx6 = (qy - by16);
HXDLIN( 469)		Float ty6 = (bx16 - qx);
HXDLIN( 469)		Float A6 = ((((-(by16) * cx16) + (qy * (-(bx16) + cx16))) + (qx * (by16 - cy16))) + (bx16 * cy16));
HXDLIN( 469)		 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 469)		if ((qx > bx16)) {
HXDLIN( 469)			if ((qx > cx16)) {
HXDLIN( 469)				int min48;
HXDLIN( 469)				if ((bx16 > cx16)) {
HXDLIN( 469)					min48 = ::Math_obj::floor(cx16);
            				}
            				else {
HXDLIN( 469)					min48 = ::Math_obj::floor(bx16);
            				}
HXDLIN( 469)				int ii_min96 = min48;
HXDLIN( 469)				int ii_max96 = ::Math_obj::ceil(qx);
HXDLIN( 469)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min96,ii_max96);
            			}
            			else {
HXDLIN( 469)				int ii_min97 = ::Math_obj::floor(bx16);
HXDLIN( 469)				int ii_max97 = ::Math_obj::ceil(cx16);
HXDLIN( 469)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min97,ii_max97);
            			}
            		}
            		else {
HXDLIN( 469)			if ((bx16 > cx16)) {
HXDLIN( 469)				int min49;
HXDLIN( 469)				if ((qx > cx16)) {
HXDLIN( 469)					min49 = ::Math_obj::floor(cx16);
            				}
            				else {
HXDLIN( 469)					min49 = ::Math_obj::ceil(qx);
            				}
HXDLIN( 469)				int ii_min98 = min49;
HXDLIN( 469)				int ii_max98 = ::Math_obj::ceil(bx16);
HXDLIN( 469)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min98,ii_max98);
            			}
            			else {
HXDLIN( 469)				int ii_min99 = ::Math_obj::floor(qx);
HXDLIN( 469)				int ii_max99 = ::Math_obj::ceil(cx16);
HXDLIN( 469)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min99,ii_max99);
            			}
            		}
HXDLIN( 469)		 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 469)		if ((qy > by16)) {
HXDLIN( 469)			if ((qy > cy16)) {
HXDLIN( 469)				int min50;
HXDLIN( 469)				if ((by16 > cy16)) {
HXDLIN( 469)					min50 = ::Math_obj::floor(cy16);
            				}
            				else {
HXDLIN( 469)					min50 = ::Math_obj::floor(by16);
            				}
HXDLIN( 469)				int ii_min100 = min50;
HXDLIN( 469)				int ii_max100 = ::Math_obj::ceil(qy);
HXDLIN( 469)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min100,ii_max100);
            			}
            			else {
HXDLIN( 469)				int ii_min101 = ::Math_obj::floor(by16);
HXDLIN( 469)				int ii_max101 = ::Math_obj::ceil(cy16);
HXDLIN( 469)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min101,ii_max101);
            			}
            		}
            		else {
HXDLIN( 469)			if ((by16 > cy16)) {
HXDLIN( 469)				int min51;
HXDLIN( 469)				if ((qy > cy16)) {
HXDLIN( 469)					min51 = ::Math_obj::floor(cy16);
            				}
            				else {
HXDLIN( 469)					min51 = ::Math_obj::ceil(qy);
            				}
HXDLIN( 469)				int ii_min102 = min51;
HXDLIN( 469)				int ii_max102 = ::Math_obj::ceil(by16);
HXDLIN( 469)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min102,ii_max102);
            			}
            			else {
HXDLIN( 469)				int ii_min103 = ::Math_obj::floor(qy);
HXDLIN( 469)				int ii_max103 = ::Math_obj::ceil(cy16);
HXDLIN( 469)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min103,ii_max103);
            			}
            		}
HXDLIN( 469)		 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 469)		if (hasUndo6) {
HXDLIN( 469)			int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 469)			int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 469)			 ::Dynamic imageType6 = null();
HXDLIN( 469)			 ::pi_xy::ImageStruct this200 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 469)			if (::hx::IsNull( imageType6 )) {
HXLINE(  54)				imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 469)			::Dynamic undoImage19;
HXDLIN( 469)			switch((int)(( (int)(imageType6) ))){
            				case (int)0: {
HXDLIN( 469)					 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 469)					 ::iterMagic::BytesImg b52 = byt6;
HXDLIN( 469)					{
HXDLIN( 469)						b52->width = width6;
HXDLIN( 469)						b52->height = height6;
HXDLIN( 469)						b52->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 469)						b52->data = ::haxe::io::Bytes_obj::alloc((b52->length * 4));
HXDLIN( 469)						{
HXDLIN( 469)							int len12 = b52->length;
HXDLIN( 469)							int w6 = 0;
HXDLIN( 469)							{
HXDLIN( 469)								int _g120 = 0;
HXDLIN( 469)								int _g121 = b52->height;
HXDLIN( 469)								while((_g120 < _g121)){
HXDLIN( 469)									_g120 = (_g120 + 1);
HXDLIN( 469)									int y24 = (_g120 - 1);
HXDLIN( 469)									{
HXDLIN( 469)										int _g122 = 0;
HXDLIN( 469)										int _g123 = b52->width;
HXDLIN( 469)										while((_g122 < _g123)){
HXDLIN( 469)											_g122 = (_g122 + 1);
HXDLIN( 469)											int x24 = (_g122 - 1);
HXDLIN( 469)											{
HXDLIN( 469)												w6 = (w6 + 1);
HXDLIN( 469)												b52->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 469)											{
HXDLIN( 469)												w6 = (w6 + 1);
HXDLIN( 469)												b52->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 469)											{
HXDLIN( 469)												w6 = (w6 + 1);
HXDLIN( 469)												b52->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 469)											{
HXDLIN( 469)												w6 = (w6 + 1);
HXDLIN( 469)												b52->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 469)					undoImage19 = b52;
            				}
            				break;
            				case (int)1: {
HXDLIN( 469)					 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)					 ::iterMagic::ArrIntImg a51 = arrI6;
HXDLIN( 469)					{
HXDLIN( 469)						a51->width = width6;
HXDLIN( 469)						a51->height = height6;
HXDLIN( 469)						a51->data = ::Array_obj< int >::__new(0);
HXDLIN( 469)						a51->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 469)						{
HXDLIN( 469)							int _g124 = 0;
HXDLIN( 469)							int _g125 = a51->length;
HXDLIN( 469)							while((_g124 < _g125)){
HXDLIN( 469)								_g124 = (_g124 + 1);
HXDLIN( 469)								int i36 = (_g124 - 1);
HXDLIN( 469)								a51->data[i36] = 0;
            							}
            						}
            					}
HXDLIN( 469)					undoImage19 = a51;
            				}
            				break;
            				case (int)2: {
HXDLIN( 469)					 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 469)					 ::iterMagic::U32ArrImg b53 = u32a6;
HXDLIN( 469)					{
HXDLIN( 469)						b53->width = width6;
HXDLIN( 469)						b53->height = height6;
HXDLIN( 469)						b53->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 469)						int size6 = (b53->length * 4);
HXDLIN( 469)						b53->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 469)						{
HXDLIN( 469)							int _g126 = 0;
HXDLIN( 469)							int _g127 = b53->length;
HXDLIN( 469)							while((_g126 < _g127)){
HXDLIN( 469)								_g126 = (_g126 + 1);
HXDLIN( 469)								int i37 = (_g126 - 1);
HXDLIN( 469)								{
HXDLIN( 469)									 ::haxe::io::ArrayBufferViewImpl this201 = b53->data;
HXDLIN( 469)									bool undoImage20;
HXDLIN( 469)									if ((i37 >= 0)) {
HXDLIN( 469)										undoImage20 = (i37 < (this201->byteLength >> 2));
            									}
            									else {
HXDLIN( 469)										undoImage20 = false;
            									}
HXDLIN( 469)									if (undoImage20) {
HXDLIN( 469)										 ::haxe::io::Bytes _this6 = this201->bytes;
HXDLIN( 469)										int pos6 = ((i37 << 2) + this201->byteOffset);
HXDLIN( 469)										_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 469)										_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 469)										_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 469)										_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 469)					undoImage19 = b53;
            				}
            				break;
            				case (int)3: {
HXDLIN( 469)					 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)					 ::iterMagic::VecIntImg v15 = vec6;
HXDLIN( 469)					{
HXDLIN( 469)						v15->width = width6;
HXDLIN( 469)						v15->height = height6;
HXDLIN( 469)						v15->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 469)						v15->data = ::Array_obj< int >::__new(v15->length);
HXDLIN( 469)						{
HXDLIN( 469)							int _g128 = 0;
HXDLIN( 469)							int _g129 = v15->length;
HXDLIN( 469)							while((_g128 < _g129)){
HXDLIN( 469)								_g128 = (_g128 + 1);
HXDLIN( 469)								int i38 = (_g128 - 1);
HXDLIN( 469)								v15->data->__unsafe_set(i38,0);
            							}
            						}
            					}
HXDLIN( 469)					undoImage19 = v15;
            				}
            				break;
            				case (int)4: {
HXDLIN( 469)					 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 469)					 ::iterMagic::StackIntImg b54 = sInt6;
HXDLIN( 469)					{
HXDLIN( 469)						b54->width = width6;
HXDLIN( 469)						b54->height = height6;
HXDLIN( 469)						b54->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 469)						b54->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 469)						{
HXDLIN( 469)							int len13 = b54->length;
HXDLIN( 469)							 ::haxe::ds::GenericStack_Int d6 = b54->data;
HXDLIN( 469)							if (::hx::IsNull( d6->head )) {
HXDLIN( 469)								int _g130 = 0;
HXDLIN( 469)								int _g131 = len13;
HXDLIN( 469)								while((_g130 < _g131)){
HXDLIN( 469)									_g130 = (_g130 + 1);
HXDLIN( 469)									int i39 = (_g130 - 1);
HXDLIN( 469)									d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            								}
            							}
            							else {
HXDLIN( 469)								int _g132 = 0;
HXDLIN( 469)								int _g133 = len13;
HXDLIN( 469)								while((_g132 < _g133)){
HXDLIN( 469)									_g132 = (_g132 + 1);
HXDLIN( 469)									int i40 = (_g132 - 1);
HXDLIN( 469)									{
HXDLIN( 469)										 ::haxe::ds::GenericCell_Int l6 = b54->data->head;
HXDLIN( 469)										 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 469)										{
HXDLIN( 469)											int _g134 = 0;
HXDLIN( 469)											int _g135 = i40;
HXDLIN( 469)											while((_g134 < _g135)){
HXDLIN( 469)												_g134 = (_g134 + 1);
HXDLIN( 469)												int i41 = (_g134 - 1);
HXLINE( 345)												prev6 = l6;
HXLINE( 346)												l6 = l6->next;
            											}
            										}
HXLINE( 469)										if (::hx::IsNull( prev6 )) {
HXDLIN( 469)											b54->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 469)											l6 = null();
            										}
            										else {
HXDLIN( 469)											prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 469)											l6 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 469)					undoImage19 = b54;
            				}
            				break;
            			}
HXDLIN( 469)			this200->image = undoImage19;
HXDLIN( 469)			this200->width = width6;
HXDLIN( 469)			this200->height = height6;
HXDLIN( 469)			this200->imageType = ( (int)(imageType6) );
HXDLIN( 469)			undoImage18 = this200;
HXDLIN( 469)			{
HXDLIN( 469)				int rectLeft6 = xIter36->start;
HXDLIN( 469)				int rectTop6 = yIter36->start;
HXDLIN( 469)				int rectRight6 = xIter36->max;
HXDLIN( 469)				bool forceClear6 = false;
HXDLIN( 469)				{
HXDLIN( 469)					int _g136 = rectTop6;
HXDLIN( 469)					int _g137 = yIter36->max;
HXDLIN( 469)					while((_g136 < _g137)){
HXDLIN( 469)						_g136 = (_g136 + 1);
HXDLIN( 469)						int dy9 = (_g136 - 1);
HXDLIN( 469)						{
HXDLIN( 469)							int _g138 = rectLeft6;
HXDLIN( 469)							int _g139 = rectRight6;
HXDLIN( 469)							while((_g138 < _g139)){
HXDLIN( 469)								_g138 = (_g138 + 1);
HXDLIN( 469)								int dx9 = (_g138 - 1);
HXDLIN( 469)								::Dynamic this202 = this1->image;
HXDLIN( 469)								int index30;
HXDLIN( 469)								if (this1->useVirtualPos) {
HXDLIN( 469)									index30 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx9) - this1->virtualX));
            								}
            								else {
HXDLIN( 469)									index30 = ::Std_obj::_hx_int(( (Float)(((dy9 * this1->width) + dx9)) ));
            								}
HXDLIN( 469)								int c36 = ::iterMagic::Iimg_obj::get(this202,index30);
HXDLIN( 469)								int col6;
HXDLIN( 469)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)									col6 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXDLIN( 469)									col6 = c36;
            								}
HXDLIN( 469)								bool _hx_tmp;
HXDLIN( 469)								if (this1->useMask) {
HXDLIN( 469)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 469)									_hx_tmp = false;
            								}
HXDLIN( 469)								if (_hx_tmp) {
HXDLIN( 469)									 ::pi_xy::ImageStruct this203 = this1->mask;
HXDLIN( 469)									::Dynamic this204 = this203->image;
HXDLIN( 469)									int index31;
HXDLIN( 469)									if (this203->useVirtualPos) {
HXDLIN( 469)										index31 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this203->virtualY) * ( (Float)(this203->width) )) + dx9) - this203->virtualX));
            									}
            									else {
HXDLIN( 469)										index31 = ::Std_obj::_hx_int(( (Float)(((dy9 * this203->width) + dx9)) ));
            									}
HXDLIN( 469)									int c37 = ::iterMagic::Iimg_obj::get(this204,index31);
HXDLIN( 469)									int v16;
HXDLIN( 469)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)										v16 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            									}
            									else {
HXDLIN( 469)										v16 = c37;
            									}
HXDLIN( 469)									int maskPixel6 = v16;
HXDLIN( 469)									int this205 = col6;
HXDLIN( 469)									if ((maskPixel6 == 0)) {
HXDLIN( 469)										col6 = this205;
            									}
            									else {
HXDLIN( 469)										Float m06;
HXDLIN( 469)										int this206 = ((maskPixel6 >> 24) & 255);
HXDLIN( 469)										if ((this206 == 0)) {
HXDLIN( 469)											m06 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											m06 = (( (Float)(this206) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float m16;
HXDLIN( 469)										int this207 = ((maskPixel6 >> 16) & 255);
HXDLIN( 469)										if ((this207 == 0)) {
HXDLIN( 469)											m16 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											m16 = (( (Float)(this207) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float m26;
HXDLIN( 469)										int this208 = ((maskPixel6 >> 8) & 255);
HXDLIN( 469)										if ((this208 == 0)) {
HXDLIN( 469)											m26 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											m26 = (( (Float)(this208) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float m36;
HXDLIN( 469)										int this209 = (maskPixel6 & 255);
HXDLIN( 469)										if ((this209 == 0)) {
HXDLIN( 469)											m36 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											m36 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this205 >> 24) & 255)) )));
HXDLIN( 469)										int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this205 >> 16) & 255)) )));
HXDLIN( 469)										int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this205 >> 8) & 255)) )));
HXDLIN( 469)										int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this205 & 255)) )));
HXDLIN( 469)										col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 469)								if ((col6 != 0)) {
HXDLIN( 469)									int x25 = (dx9 - rectLeft6);
HXDLIN( 469)									int y25 = (dy9 - rectTop6);
HXDLIN( 469)									int c38 = col6;
HXDLIN( 469)									bool _hx_tmp1;
HXDLIN( 469)									if ((((c38 >> 24) & 255) < 254)) {
HXDLIN( 469)										_hx_tmp1 = undoImage18->transparent;
            									}
            									else {
HXDLIN( 469)										_hx_tmp1 = false;
            									}
HXDLIN( 469)									if (_hx_tmp1) {
HXDLIN( 469)										int location12;
HXDLIN( 469)										if (undoImage18->useVirtualPos) {
HXDLIN( 469)											location12 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x25) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 469)											location12 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage18->width) + x25)) ));
            										}
HXDLIN( 469)										int this210 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 469)										int this211;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											this211 = ((((((this210 >> 24) & 255) << 24) | ((this210 & 255) << 16)) | (((this210 >> 8) & 255) << 8)) | ((this210 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											this211 = this210;
            										}
HXDLIN( 469)										Float a117;
HXDLIN( 469)										int this212 = ((this211 >> 24) & 255);
HXDLIN( 469)										if ((this212 == 0)) {
HXDLIN( 469)											a117 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											a117 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float r112;
HXDLIN( 469)										int this213 = ((this211 >> 16) & 255);
HXDLIN( 469)										if ((this213 == 0)) {
HXDLIN( 469)											r112 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											r112 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float g112;
HXDLIN( 469)										int this214 = ((this211 >> 8) & 255);
HXDLIN( 469)										if ((this214 == 0)) {
HXDLIN( 469)											g112 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											g112 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float b118;
HXDLIN( 469)										int this215 = (this211 & 255);
HXDLIN( 469)										if ((this215 == 0)) {
HXDLIN( 469)											b118 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											b118 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float a215;
HXDLIN( 469)										int this216 = ((col6 >> 24) & 255);
HXDLIN( 469)										if ((this216 == 0)) {
HXDLIN( 469)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											a215 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float r212;
HXDLIN( 469)										int this217 = ((col6 >> 16) & 255);
HXDLIN( 469)										if ((this217 == 0)) {
HXDLIN( 469)											r212 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											r212 = (( (Float)(this217) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float g212;
HXDLIN( 469)										int this218 = ((col6 >> 8) & 255);
HXDLIN( 469)										if ((this218 == 0)) {
HXDLIN( 469)											g212 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											g212 = (( (Float)(this218) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float b216;
HXDLIN( 469)										int this219 = (col6 & 255);
HXDLIN( 469)										if ((this219 == 0)) {
HXDLIN( 469)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											b216 = (( (Float)(this219) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN( 469)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a314) + (r212 * a215))));
HXDLIN( 469)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a314) + (g212 * a215))));
HXDLIN( 469)										int b55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b216 * a215))));
HXDLIN( 469)										int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 469)										int blended12 = ((((a52 << 24) | (r32 << 16)) | (g32 << 8)) | b55);
HXDLIN( 469)										{
HXDLIN( 469)											int _hx_tmp2;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												_hx_tmp2 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												_hx_tmp2 = blended12;
            											}
HXDLIN( 469)											::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 469)										::Dynamic this220 = undoImage18->image;
HXDLIN( 469)										int index32;
HXDLIN( 469)										if (undoImage18->useVirtualPos) {
HXDLIN( 469)											index32 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x25) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 469)											index32 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage18->width) + x25)) ));
            										}
HXDLIN( 469)										int _hx_tmp3;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											_hx_tmp3 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											_hx_tmp3 = c38;
            										}
HXDLIN( 469)										::iterMagic::Iimg_obj::set(this220,index32,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 469)									if (forceClear6) {
HXDLIN( 469)										::Dynamic this221 = undoImage18->image;
HXDLIN( 469)										int x26 = (dx9 - rectLeft6);
HXDLIN( 469)										int y26 = (dy9 - rectTop6);
HXDLIN( 469)										int index33;
HXDLIN( 469)										if (undoImage18->useVirtualPos) {
HXDLIN( 469)											index33 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x26) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 469)											index33 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage18->width) + x26)) ));
            										}
HXDLIN( 469)										::iterMagic::Iimg_obj::set(this221,index33,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 469)		bool found6 = false;
HXDLIN( 469)		Float s6 = ((Float)0.);
HXDLIN( 469)		Float t6 = ((Float)0.);
HXDLIN( 469)		Float sxx6 = ((Float)0.);
HXDLIN( 469)		Float txx6 = ((Float)0.);
HXDLIN( 469)		{
HXDLIN( 469)			int _g_min12 = xIter36->start;
HXDLIN( 469)			int _g_max12 = xIter36->max;
HXDLIN( 469)			while((_g_min12 < _g_max12)){
HXDLIN( 469)				_g_min12 = (_g_min12 + 1);
HXDLIN( 469)				int x27 = (_g_min12 - 1);
HXLINE(  60)				sxx6 = (sx6 * ( (Float)(x27) ));
HXLINE(  61)				txx6 = (tx6 * ( (Float)(x27) ));
HXLINE(  62)				found6 = false;
HXLINE( 469)				{
HXDLIN( 469)					int _g_min13 = yIter36->start;
HXDLIN( 469)					int _g_max13 = yIter36->max;
HXDLIN( 469)					while((_g_min13 < _g_max13)){
HXDLIN( 469)						_g_min13 = (_g_min13 + 1);
HXDLIN( 469)						int y27 = (_g_min13 - 1);
HXLINE(  64)						s6 = ((s06 + sxx6) + (sy6 * ( (Float)(y27) )));
HXLINE(  65)						t6 = ((t06 + txx6) + (ty6 * ( (Float)(y27) )));
HXLINE( 469)						bool _hx_tmp4;
HXDLIN( 469)						if (!((s6 <= 0))) {
HXDLIN( 469)							_hx_tmp4 = (t6 <= 0);
            						}
            						else {
HXDLIN( 469)							_hx_tmp4 = true;
            						}
HXDLIN( 469)						if (_hx_tmp4) {
HXDLIN( 469)							if (found6) {
HXDLIN( 469)								goto _hx_goto_859;
            							}
            						}
            						else {
HXDLIN( 469)							if (((s6 + t6) < A6)) {
HXDLIN( 469)								{
HXDLIN( 469)									int c39 = color;
HXDLIN( 469)									bool _hx_tmp5;
HXDLIN( 469)									if ((((c39 >> 24) & 255) < 254)) {
HXDLIN( 469)										_hx_tmp5 = this1->transparent;
            									}
            									else {
HXDLIN( 469)										_hx_tmp5 = false;
            									}
HXDLIN( 469)									if (_hx_tmp5) {
HXDLIN( 469)										int location13;
HXDLIN( 469)										if (this1->useVirtualPos) {
HXDLIN( 469)											location13 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this1->virtualY) * ( (Float)(this1->width) )) + x27) - this1->virtualX));
            										}
            										else {
HXDLIN( 469)											location13 = ::Std_obj::_hx_int(( (Float)(((y27 * this1->width) + x27)) ));
            										}
HXDLIN( 469)										int this222 = ::iterMagic::Iimg_obj::get(this1->image,location13);
HXDLIN( 469)										int this223;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											this223 = ((((((this222 >> 24) & 255) << 24) | ((this222 & 255) << 16)) | (((this222 >> 8) & 255) << 8)) | ((this222 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											this223 = this222;
            										}
HXDLIN( 469)										Float a118;
HXDLIN( 469)										int this224 = ((this223 >> 24) & 255);
HXDLIN( 469)										if ((this224 == 0)) {
HXDLIN( 469)											a118 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											a118 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float r113;
HXDLIN( 469)										int this225 = ((this223 >> 16) & 255);
HXDLIN( 469)										if ((this225 == 0)) {
HXDLIN( 469)											r113 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											r113 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float g113;
HXDLIN( 469)										int this226 = ((this223 >> 8) & 255);
HXDLIN( 469)										if ((this226 == 0)) {
HXDLIN( 469)											g113 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											g113 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float b119;
HXDLIN( 469)										int this227 = (this223 & 255);
HXDLIN( 469)										if ((this227 == 0)) {
HXDLIN( 469)											b119 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											b119 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float a216;
HXDLIN( 469)										int this228 = ((color >> 24) & 255);
HXDLIN( 469)										if ((this228 == 0)) {
HXDLIN( 469)											a216 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											a216 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float r213;
HXDLIN( 469)										int this229 = ((color >> 16) & 255);
HXDLIN( 469)										if ((this229 == 0)) {
HXDLIN( 469)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											r213 = (( (Float)(this229) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float g213;
HXDLIN( 469)										int this230 = ((color >> 8) & 255);
HXDLIN( 469)										if ((this230 == 0)) {
HXDLIN( 469)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											g213 = (( (Float)(this230) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float b217;
HXDLIN( 469)										int this231 = (color & 255);
HXDLIN( 469)										if ((this231 == 0)) {
HXDLIN( 469)											b217 = ((Float)0.);
            										}
            										else {
HXDLIN( 469)											b217 = (( (Float)(this231) ) / ( (Float)(255) ));
            										}
HXDLIN( 469)										Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN( 469)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a315) + (r213 * a216))));
HXDLIN( 469)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a315) + (g213 * a216))));
HXDLIN( 469)										int b56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a315) + (b217 * a216))));
HXDLIN( 469)										int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 469)										int blended13 = ((((a53 << 24) | (r33 << 16)) | (g33 << 8)) | b56);
HXDLIN( 469)										{
HXDLIN( 469)											int _hx_tmp6;
HXDLIN( 469)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)												_hx_tmp6 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXDLIN( 469)												_hx_tmp6 = blended13;
            											}
HXDLIN( 469)											::iterMagic::Iimg_obj::set(this1->image,location13,_hx_tmp6);
            										}
            									}
            									else {
HXDLIN( 469)										::Dynamic this232 = this1->image;
HXDLIN( 469)										int index34;
HXDLIN( 469)										if (this1->useVirtualPos) {
HXDLIN( 469)											index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this1->virtualY) * ( (Float)(this1->width) )) + x27) - this1->virtualX));
            										}
            										else {
HXDLIN( 469)											index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this1->width) + x27)) ));
            										}
HXDLIN( 469)										int _hx_tmp7;
HXDLIN( 469)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 469)											_hx_tmp7 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            										}
            										else {
HXDLIN( 469)											_hx_tmp7 = c39;
            										}
HXDLIN( 469)										::iterMagic::Iimg_obj::set(this232,index34,_hx_tmp7);
            									}
            								}
HXLINE(  73)								found6 = true;
            							}
            							else {
HXDLIN( 469)								if (found6) {
HXDLIN( 469)									goto _hx_goto_859;
            								}
            							}
            						}
            					}
            					_hx_goto_859:;
            				}
            			}
            		}
HXDLIN( 469)		 ::pi_xy::algo::HitTri hitTri;
HXDLIN( 469)		if ((hasHit == true)) {
HXDLIN( 469)			 ::pi_xy::algo::HitTri v17 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx16,by16,cx16,cy16,true);
HXDLIN( 469)			if (hasUndo6) {
HXDLIN( 469)				v17->undoImage = undoImage18;
HXDLIN( 469)				v17->undoX = xIter36->start;
HXDLIN( 469)				v17->undoY = yIter36->start;
            			}
HXDLIN( 469)			hitTri = v17;
            		}
            		else {
HXDLIN( 469)			hitTri = null();
            		}
HXDLIN( 469)		if (hasHit) {
HXDLIN( 469)			 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN( 469)			if (::hx::IsNotNull( hitQuad )) {
HXDLIN( 469)				hitArr->triArr->push(hitQuad->triABD);
            			}
HXDLIN( 469)			hitArr->triArr->push(hitQuad->triBCD);
HXDLIN( 469)			return hitArr;
            		}
            		else {
HXDLIN( 469)			return null();
            		}
HXDLIN( 469)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(FillShape_Impl__obj,arrow,return )

 ::pi_xy::algo::HitTriArray FillShape_Impl__obj::arrowBoth( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float thick,int color,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_482_arrowBoth)
HXDLIN( 482)		Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 482)		Float o = (qy - py);
HXDLIN( 482)		Float a = (qx - px);
HXDLIN( 482)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 482)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 482)		Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN( 482)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 482)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 482)		Float radius = (thick / ( (Float)(2) ));
HXDLIN( 482)		Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 482)		Float h2 = (h / goldenRatio);
HXDLIN( 482)		Float hSmall = (h - h2);
HXDLIN( 482)		Float px_ = hSmall;
HXDLIN( 482)		Float py_ = ((Float)0.);
HXDLIN( 482)		Float temp = ((Float)0.);
HXLINE( 188)		temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 189)		py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 190)		px_ = temp;
HXLINE( 482)		Float h1 = (h2 - hSmall);
HXDLIN( 482)		Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 482)		Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 482)		Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 482)		Float dx = ((Float)0.1);
HXDLIN( 482)		Float dy = radius1;
HXDLIN( 482)		Float cx = h1;
HXDLIN( 482)		Float cy = radius1;
HXDLIN( 482)		Float bx = h1;
HXDLIN( 482)		Float by = -(radius1);
HXDLIN( 482)		Float ax = ((Float)0.1);
HXDLIN( 482)		Float ay = -(radius1);
HXDLIN( 482)		Float temp1 = ((Float)0.);
HXLINE(  28)		temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE(  29)		ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE(  30)		ax = temp1;
HXLINE(  32)		temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE(  33)		by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE(  34)		bx = temp1;
HXLINE(  36)		temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE(  37)		cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE(  38)		cx = temp1;
HXLINE(  40)		temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE(  41)		dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE(  42)		dx = temp1;
HXLINE( 482)		Float bx1 = bx;
HXDLIN( 482)		Float by1 = by;
HXDLIN( 482)		Float cx1 = dx;
HXDLIN( 482)		Float cy1 = dy;
HXDLIN( 482)		bool hasUndo = false;
HXDLIN( 482)		bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 482)		if (!(adjustWinding)) {
HXDLIN( 482)			Float bx_ = bx1;
HXDLIN( 482)			Float by_ = by1;
HXLINE(  25)			bx1 = cx1;
HXLINE(  26)			by1 = cy1;
HXLINE(  27)			cx1 = bx_;
HXLINE(  28)			cy1 = by_;
            		}
HXLINE( 482)		Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 482)		Float sx = (cy1 - ay);
HXDLIN( 482)		Float sy = (ax - cx1);
HXDLIN( 482)		Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 482)		Float tx = (ay - by1);
HXDLIN( 482)		Float ty = (bx1 - ax);
HXDLIN( 482)		Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 482)		if ((ax > bx1)) {
HXDLIN( 482)			if ((ax > cx1)) {
HXDLIN( 482)				int min;
HXDLIN( 482)				if ((bx1 > cx1)) {
HXDLIN( 482)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN( 482)					min = ::Math_obj::floor(bx1);
            				}
HXDLIN( 482)				int ii_min = min;
HXDLIN( 482)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 482)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN( 482)				int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 482)				int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 482)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN( 482)			if ((bx1 > cx1)) {
HXDLIN( 482)				int min1;
HXDLIN( 482)				if ((ax > cx1)) {
HXDLIN( 482)					min1 = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN( 482)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 482)				int ii_min2 = min1;
HXDLIN( 482)				int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 482)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN( 482)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 482)				int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 482)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 482)		if ((ay > by1)) {
HXDLIN( 482)			if ((ay > cy1)) {
HXDLIN( 482)				int min2;
HXDLIN( 482)				if ((by1 > cy1)) {
HXDLIN( 482)					min2 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN( 482)					min2 = ::Math_obj::floor(by1);
            				}
HXDLIN( 482)				int ii_min4 = min2;
HXDLIN( 482)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 482)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN( 482)				int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 482)				int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 482)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN( 482)			if ((by1 > cy1)) {
HXDLIN( 482)				int min3;
HXDLIN( 482)				if ((ay > cy1)) {
HXDLIN( 482)					min3 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN( 482)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 482)				int ii_min6 = min3;
HXDLIN( 482)				int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 482)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN( 482)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 482)				int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 482)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 482)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 482)		if (hasUndo) {
HXDLIN( 482)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 482)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 482)			 ::Dynamic imageType = null();
HXDLIN( 482)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 482)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 482)			::Dynamic undoImage1;
HXDLIN( 482)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN( 482)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 482)					{
HXDLIN( 482)						b->width = width;
HXDLIN( 482)						b->height = height;
HXDLIN( 482)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 482)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 482)						{
HXDLIN( 482)							int len = b->length;
HXDLIN( 482)							int w = 0;
HXDLIN( 482)							{
HXDLIN( 482)								int _g = 0;
HXDLIN( 482)								int _g1 = b->height;
HXDLIN( 482)								while((_g < _g1)){
HXDLIN( 482)									_g = (_g + 1);
HXDLIN( 482)									int y = (_g - 1);
HXDLIN( 482)									{
HXDLIN( 482)										int _g2 = 0;
HXDLIN( 482)										int _g3 = b->width;
HXDLIN( 482)										while((_g2 < _g3)){
HXDLIN( 482)											_g2 = (_g2 + 1);
HXDLIN( 482)											int x = (_g2 - 1);
HXDLIN( 482)											{
HXDLIN( 482)												w = (w + 1);
HXDLIN( 482)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w = (w + 1);
HXDLIN( 482)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w = (w + 1);
HXDLIN( 482)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w = (w + 1);
HXDLIN( 482)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN( 482)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 482)					{
HXDLIN( 482)						a1->width = width;
HXDLIN( 482)						a1->height = height;
HXDLIN( 482)						a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 482)						a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 482)						{
HXDLIN( 482)							int _g4 = 0;
HXDLIN( 482)							int _g5 = a1->length;
HXDLIN( 482)							while((_g4 < _g5)){
HXDLIN( 482)								_g4 = (_g4 + 1);
HXDLIN( 482)								int i = (_g4 - 1);
HXDLIN( 482)								a1->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 482)					undoImage1 = a1;
            				}
            				break;
            				case (int)2: {
HXDLIN( 482)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 482)					{
HXDLIN( 482)						b1->width = width;
HXDLIN( 482)						b1->height = height;
HXDLIN( 482)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 482)						int size = (b1->length * 4);
HXDLIN( 482)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 482)						{
HXDLIN( 482)							int _g6 = 0;
HXDLIN( 482)							int _g7 = b1->length;
HXDLIN( 482)							while((_g6 < _g7)){
HXDLIN( 482)								_g6 = (_g6 + 1);
HXDLIN( 482)								int i1 = (_g6 - 1);
HXDLIN( 482)								{
HXDLIN( 482)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 482)									bool undoImage2;
HXDLIN( 482)									if ((i1 >= 0)) {
HXDLIN( 482)										undoImage2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXDLIN( 482)										undoImage2 = false;
            									}
HXDLIN( 482)									if (undoImage2) {
HXDLIN( 482)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 482)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 482)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 482)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 482)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 482)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN( 482)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 482)					{
HXDLIN( 482)						v->width = width;
HXDLIN( 482)						v->height = height;
HXDLIN( 482)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 482)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 482)						{
HXDLIN( 482)							int _g8 = 0;
HXDLIN( 482)							int _g9 = v->length;
HXDLIN( 482)							while((_g8 < _g9)){
HXDLIN( 482)								_g8 = (_g8 + 1);
HXDLIN( 482)								int i2 = (_g8 - 1);
HXDLIN( 482)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 482)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN( 482)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 482)					{
HXDLIN( 482)						b2->width = width;
HXDLIN( 482)						b2->height = height;
HXDLIN( 482)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 482)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 482)						{
HXDLIN( 482)							int len1 = b2->length;
HXDLIN( 482)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 482)							if (::hx::IsNull( d->head )) {
HXDLIN( 482)								int _g10 = 0;
HXDLIN( 482)								int _g11 = len1;
HXDLIN( 482)								while((_g10 < _g11)){
HXDLIN( 482)									_g10 = (_g10 + 1);
HXDLIN( 482)									int i3 = (_g10 - 1);
HXDLIN( 482)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN( 482)								int _g12 = 0;
HXDLIN( 482)								int _g13 = len1;
HXDLIN( 482)								while((_g12 < _g13)){
HXDLIN( 482)									_g12 = (_g12 + 1);
HXDLIN( 482)									int i4 = (_g12 - 1);
HXDLIN( 482)									{
HXDLIN( 482)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 482)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 482)										{
HXDLIN( 482)											int _g14 = 0;
HXDLIN( 482)											int _g15 = i4;
HXDLIN( 482)											while((_g14 < _g15)){
HXDLIN( 482)												_g14 = (_g14 + 1);
HXDLIN( 482)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 482)										if (::hx::IsNull( prev )) {
HXDLIN( 482)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 482)											l = null();
            										}
            										else {
HXDLIN( 482)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 482)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 482)			this2->image = undoImage1;
HXDLIN( 482)			this2->width = width;
HXDLIN( 482)			this2->height = height;
HXDLIN( 482)			this2->imageType = ( (int)(imageType) );
HXDLIN( 482)			undoImage = this2;
HXDLIN( 482)			{
HXDLIN( 482)				int rectLeft = xIter3->start;
HXDLIN( 482)				int rectTop = yIter3->start;
HXDLIN( 482)				int rectRight = xIter3->max;
HXDLIN( 482)				bool forceClear = false;
HXDLIN( 482)				{
HXDLIN( 482)					int _g16 = rectTop;
HXDLIN( 482)					int _g17 = yIter3->max;
HXDLIN( 482)					while((_g16 < _g17)){
HXDLIN( 482)						_g16 = (_g16 + 1);
HXDLIN( 482)						int dy1 = (_g16 - 1);
HXDLIN( 482)						{
HXDLIN( 482)							int _g18 = rectLeft;
HXDLIN( 482)							int _g19 = rectRight;
HXDLIN( 482)							while((_g18 < _g19)){
HXDLIN( 482)								_g18 = (_g18 + 1);
HXDLIN( 482)								int dx1 = (_g18 - 1);
HXDLIN( 482)								::Dynamic this4 = this1->image;
HXDLIN( 482)								int index;
HXDLIN( 482)								if (this1->useVirtualPos) {
HXDLIN( 482)									index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            								}
            								else {
HXDLIN( 482)									index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            								}
HXDLIN( 482)								int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 482)								int col;
HXDLIN( 482)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN( 482)									col = c;
            								}
HXDLIN( 482)								bool _hx_tmp;
HXDLIN( 482)								if (this1->useMask) {
HXDLIN( 482)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 482)									_hx_tmp = false;
            								}
HXDLIN( 482)								if (_hx_tmp) {
HXDLIN( 482)									 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 482)									::Dynamic this6 = this5->image;
HXDLIN( 482)									int index1;
HXDLIN( 482)									if (this5->useVirtualPos) {
HXDLIN( 482)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            									}
            									else {
HXDLIN( 482)										index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            									}
HXDLIN( 482)									int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 482)									int v1;
HXDLIN( 482)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN( 482)										v1 = c1;
            									}
HXDLIN( 482)									int maskPixel = v1;
HXDLIN( 482)									int this7 = col;
HXDLIN( 482)									if ((maskPixel == 0)) {
HXDLIN( 482)										col = this7;
            									}
            									else {
HXDLIN( 482)										Float m0;
HXDLIN( 482)										int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 482)										if ((this8 == 0)) {
HXDLIN( 482)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m1;
HXDLIN( 482)										int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 482)										if ((this9 == 0)) {
HXDLIN( 482)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m2;
HXDLIN( 482)										int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 482)										if ((this10 == 0)) {
HXDLIN( 482)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m3;
HXDLIN( 482)										int this11 = (maskPixel & 255);
HXDLIN( 482)										if ((this11 == 0)) {
HXDLIN( 482)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 482)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 482)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 482)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 482)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 482)								if ((col != 0)) {
HXDLIN( 482)									int x1 = (dx1 - rectLeft);
HXDLIN( 482)									int y1 = (dy1 - rectTop);
HXDLIN( 482)									int c2 = col;
HXDLIN( 482)									bool _hx_tmp1;
HXDLIN( 482)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 482)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN( 482)										_hx_tmp1 = false;
            									}
HXDLIN( 482)									if (_hx_tmp1) {
HXDLIN( 482)										int location;
HXDLIN( 482)										if (undoImage->useVirtualPos) {
HXDLIN( 482)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 482)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 482)										int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 482)										int this13;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											this13 = this12;
            										}
HXDLIN( 482)										Float a11;
HXDLIN( 482)										int this14 = ((this13 >> 24) & 255);
HXDLIN( 482)										if ((this14 == 0)) {
HXDLIN( 482)											a11 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r1;
HXDLIN( 482)										int this15 = ((this13 >> 16) & 255);
HXDLIN( 482)										if ((this15 == 0)) {
HXDLIN( 482)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g1;
HXDLIN( 482)										int this16 = ((this13 >> 8) & 255);
HXDLIN( 482)										if ((this16 == 0)) {
HXDLIN( 482)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b11;
HXDLIN( 482)										int this17 = (this13 & 255);
HXDLIN( 482)										if ((this17 == 0)) {
HXDLIN( 482)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a2;
HXDLIN( 482)										int this18 = ((col >> 24) & 255);
HXDLIN( 482)										if ((this18 == 0)) {
HXDLIN( 482)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r2;
HXDLIN( 482)										int this19 = ((col >> 16) & 255);
HXDLIN( 482)										if ((this19 == 0)) {
HXDLIN( 482)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g2;
HXDLIN( 482)										int this20 = ((col >> 8) & 255);
HXDLIN( 482)										if ((this20 == 0)) {
HXDLIN( 482)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b21;
HXDLIN( 482)										int this21 = (col & 255);
HXDLIN( 482)										if ((this21 == 0)) {
HXDLIN( 482)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 482)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 482)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 482)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 482)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 482)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 482)										{
HXDLIN( 482)											int _hx_tmp2;
HXDLIN( 482)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN( 482)												_hx_tmp2 = blended;
            											}
HXDLIN( 482)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 482)										::Dynamic this22 = undoImage->image;
HXDLIN( 482)										int index2;
HXDLIN( 482)										if (undoImage->useVirtualPos) {
HXDLIN( 482)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 482)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 482)										int _hx_tmp3;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											_hx_tmp3 = c2;
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 482)									if (forceClear) {
HXDLIN( 482)										::Dynamic this23 = undoImage->image;
HXDLIN( 482)										int x2 = (dx1 - rectLeft);
HXDLIN( 482)										int y2 = (dy1 - rectTop);
HXDLIN( 482)										int index3;
HXDLIN( 482)										if (undoImage->useVirtualPos) {
HXDLIN( 482)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 482)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this23,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 482)		bool found = false;
HXDLIN( 482)		Float s = ((Float)0.);
HXDLIN( 482)		Float t = ((Float)0.);
HXDLIN( 482)		Float sxx = ((Float)0.);
HXDLIN( 482)		Float txx = ((Float)0.);
HXDLIN( 482)		{
HXDLIN( 482)			int _g_min = xIter3->start;
HXDLIN( 482)			int _g_max = xIter3->max;
HXDLIN( 482)			while((_g_min < _g_max)){
HXDLIN( 482)				_g_min = (_g_min + 1);
HXDLIN( 482)				int x3 = (_g_min - 1);
HXLINE(  60)				sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)				txx = (tx * ( (Float)(x3) ));
HXLINE(  62)				found = false;
HXLINE( 482)				{
HXDLIN( 482)					int _g_min1 = yIter3->start;
HXDLIN( 482)					int _g_max1 = yIter3->max;
HXDLIN( 482)					while((_g_min1 < _g_max1)){
HXDLIN( 482)						_g_min1 = (_g_min1 + 1);
HXDLIN( 482)						int y3 = (_g_min1 - 1);
HXLINE(  64)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 482)						bool _hx_tmp4;
HXDLIN( 482)						if (!((s <= 0))) {
HXDLIN( 482)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXDLIN( 482)							_hx_tmp4 = true;
            						}
HXDLIN( 482)						if (_hx_tmp4) {
HXDLIN( 482)							if (found) {
HXDLIN( 482)								goto _hx_goto_872;
            							}
            						}
            						else {
HXDLIN( 482)							if (((s + t) < A)) {
HXDLIN( 482)								{
HXDLIN( 482)									int c3 = color;
HXDLIN( 482)									bool _hx_tmp5;
HXDLIN( 482)									if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 482)										_hx_tmp5 = this1->transparent;
            									}
            									else {
HXDLIN( 482)										_hx_tmp5 = false;
            									}
HXDLIN( 482)									if (_hx_tmp5) {
HXDLIN( 482)										int location1;
HXDLIN( 482)										if (this1->useVirtualPos) {
HXDLIN( 482)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXDLIN( 482)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN( 482)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 482)										int this25;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											this25 = this24;
            										}
HXDLIN( 482)										Float a12;
HXDLIN( 482)										int this26 = ((this25 >> 24) & 255);
HXDLIN( 482)										if ((this26 == 0)) {
HXDLIN( 482)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a12 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r11;
HXDLIN( 482)										int this27 = ((this25 >> 16) & 255);
HXDLIN( 482)										if ((this27 == 0)) {
HXDLIN( 482)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g11;
HXDLIN( 482)										int this28 = ((this25 >> 8) & 255);
HXDLIN( 482)										if ((this28 == 0)) {
HXDLIN( 482)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b12;
HXDLIN( 482)										int this29 = (this25 & 255);
HXDLIN( 482)										if ((this29 == 0)) {
HXDLIN( 482)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a21;
HXDLIN( 482)										int this30 = ((color >> 24) & 255);
HXDLIN( 482)										if ((this30 == 0)) {
HXDLIN( 482)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r21;
HXDLIN( 482)										int this31 = ((color >> 16) & 255);
HXDLIN( 482)										if ((this31 == 0)) {
HXDLIN( 482)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g21;
HXDLIN( 482)										int this32 = ((color >> 8) & 255);
HXDLIN( 482)										if ((this32 == 0)) {
HXDLIN( 482)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b22;
HXDLIN( 482)										int this33 = (color & 255);
HXDLIN( 482)										if ((this33 == 0)) {
HXDLIN( 482)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 482)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 482)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 482)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 482)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 482)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 482)										{
HXDLIN( 482)											int _hx_tmp6;
HXDLIN( 482)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 482)												_hx_tmp6 = blended1;
            											}
HXDLIN( 482)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXDLIN( 482)										::Dynamic this34 = this1->image;
HXDLIN( 482)										int index4;
HXDLIN( 482)										if (this1->useVirtualPos) {
HXDLIN( 482)											index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXDLIN( 482)											index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN( 482)										int _hx_tmp7;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											_hx_tmp7 = c3;
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            									}
            								}
HXLINE(  73)								found = true;
            							}
            							else {
HXDLIN( 482)								if (found) {
HXDLIN( 482)									goto _hx_goto_872;
            								}
            							}
            						}
            					}
            					_hx_goto_872:;
            				}
            			}
            		}
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 482)		int v_undoY;
HXDLIN( 482)		int v_undoX;
HXDLIN( 482)		Float v_ty;
HXDLIN( 482)		Float v_tx;
HXDLIN( 482)		Float v_t0;
HXDLIN( 482)		Float v_sy;
HXDLIN( 482)		Float v_sx;
HXDLIN( 482)		Float v_s0;
HXDLIN( 482)		Float v_A;
HXDLIN( 482)		Float ax1 = ax;
HXDLIN( 482)		Float ay1 = ay;
HXDLIN( 482)		 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 482)		Float bx2 = bx1;
HXDLIN( 482)		Float by2 = by1;
HXDLIN( 482)		Float cx2 = cx1;
HXDLIN( 482)		Float cy2 = cy1;
HXDLIN( 482)		bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN( 482)		if (!(adjustWinding1)) {
HXDLIN( 482)			Float bx_1 = bx2;
HXDLIN( 482)			Float by_1 = by2;
HXLINE(  24)			bx2 = cx2;
HXLINE(  25)			by2 = cy2;
HXLINE(  26)			cx2 = bx_1;
HXLINE(  27)			cy2 = by_1;
            		}
HXLINE( 482)		Float v_ax = ax1;
HXDLIN( 482)		Float v_ay = ay1;
HXDLIN( 482)		Float v_bx = bx2;
HXDLIN( 482)		Float v_by = by2;
HXDLIN( 482)		Float v_cx = cx2;
HXDLIN( 482)		Float v_cy = cy2;
HXDLIN( 482)		bool v_preCalculated = true;
HXDLIN( 482)		{
HXDLIN( 482)			v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 482)			v_sx = (v_cy - v_ay);
HXDLIN( 482)			v_sy = (v_ax - v_cx);
HXDLIN( 482)			v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 482)			v_tx = (v_ay - v_by);
HXDLIN( 482)			v_ty = (v_bx - v_ax);
HXDLIN( 482)			v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 482)			Float a6 = v_ax;
HXDLIN( 482)			Float b5 = v_bx;
HXDLIN( 482)			Float c4 = v_cx;
HXDLIN( 482)			if ((a6 > b5)) {
HXDLIN( 482)				if ((a6 > c4)) {
HXDLIN( 482)					int min4;
HXDLIN( 482)					if ((b5 > c4)) {
HXDLIN( 482)						min4 = ::Math_obj::floor(c4);
            					}
            					else {
HXDLIN( 482)						min4 = ::Math_obj::floor(b5);
            					}
HXDLIN( 482)					int ii_min8 = min4;
HXDLIN( 482)					int ii_max8 = ::Math_obj::ceil(a6);
HXDLIN( 482)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXDLIN( 482)					int ii_min9 = ::Math_obj::floor(b5);
HXDLIN( 482)					int ii_max9 = ::Math_obj::ceil(c4);
HXDLIN( 482)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXDLIN( 482)				if ((b5 > c4)) {
HXDLIN( 482)					int min5;
HXDLIN( 482)					if ((a6 > c4)) {
HXDLIN( 482)						min5 = ::Math_obj::floor(c4);
            					}
            					else {
HXDLIN( 482)						min5 = ::Math_obj::ceil(a6);
            					}
HXDLIN( 482)					int ii_min10 = min5;
HXDLIN( 482)					int ii_max10 = ::Math_obj::ceil(b5);
HXDLIN( 482)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXDLIN( 482)					int ii_min11 = ::Math_obj::floor(a6);
HXDLIN( 482)					int ii_max11 = ::Math_obj::ceil(c4);
HXDLIN( 482)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 482)			Float a7 = v_ay;
HXDLIN( 482)			Float b6 = v_by;
HXDLIN( 482)			Float c5 = v_cy;
HXDLIN( 482)			if ((a7 > b6)) {
HXDLIN( 482)				if ((a7 > c5)) {
HXDLIN( 482)					int min6;
HXDLIN( 482)					if ((b6 > c5)) {
HXDLIN( 482)						min6 = ::Math_obj::floor(c5);
            					}
            					else {
HXDLIN( 482)						min6 = ::Math_obj::floor(b6);
            					}
HXDLIN( 482)					int ii_min12 = min6;
HXDLIN( 482)					int ii_max12 = ::Math_obj::ceil(a7);
HXDLIN( 482)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXDLIN( 482)					int ii_min13 = ::Math_obj::floor(b6);
HXDLIN( 482)					int ii_max13 = ::Math_obj::ceil(c5);
HXDLIN( 482)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXDLIN( 482)				if ((b6 > c5)) {
HXDLIN( 482)					int min7;
HXDLIN( 482)					if ((a7 > c5)) {
HXDLIN( 482)						min7 = ::Math_obj::floor(c5);
            					}
            					else {
HXDLIN( 482)						min7 = ::Math_obj::ceil(a7);
            					}
HXDLIN( 482)					int ii_min14 = min7;
HXDLIN( 482)					int ii_max14 = ::Math_obj::ceil(b6);
HXDLIN( 482)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXDLIN( 482)					int ii_min15 = ::Math_obj::floor(a7);
HXDLIN( 482)					int ii_max15 = ::Math_obj::ceil(c5);
HXDLIN( 482)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
            		}
HXDLIN( 482)		if (hasUndo) {
HXDLIN( 482)			v_undoImage = undoImage;
HXDLIN( 482)			v_undoX = xIter3->start;
HXDLIN( 482)			v_undoY = yIter3->start;
            		}
HXDLIN( 482)		Float bx3 = cx;
HXDLIN( 482)		Float by3 = cy;
HXDLIN( 482)		Float cx3 = dx;
HXDLIN( 482)		Float cy3 = dy;
HXDLIN( 482)		bool hasUndo1 = false;
HXDLIN( 482)		bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN( 482)		if (!(adjustWinding2)) {
HXDLIN( 482)			Float bx_2 = bx3;
HXDLIN( 482)			Float by_2 = by3;
HXLINE(  25)			bx3 = cx3;
HXLINE(  26)			by3 = cy3;
HXLINE(  27)			cx3 = bx_2;
HXLINE(  28)			cy3 = by_2;
            		}
HXLINE( 482)		Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN( 482)		Float sx1 = (cy3 - by);
HXDLIN( 482)		Float sy1 = (bx - cx3);
HXDLIN( 482)		Float t01 = ((bx * by3) - (by * bx3));
HXDLIN( 482)		Float tx1 = (by - by3);
HXDLIN( 482)		Float ty1 = (bx3 - bx);
HXDLIN( 482)		Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 482)		if ((bx > bx3)) {
HXDLIN( 482)			if ((bx > cx3)) {
HXDLIN( 482)				int min8;
HXDLIN( 482)				if ((bx3 > cx3)) {
HXDLIN( 482)					min8 = ::Math_obj::floor(cx3);
            				}
            				else {
HXDLIN( 482)					min8 = ::Math_obj::floor(bx3);
            				}
HXDLIN( 482)				int ii_min16 = min8;
HXDLIN( 482)				int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN( 482)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            			}
            			else {
HXDLIN( 482)				int ii_min17 = ::Math_obj::floor(bx3);
HXDLIN( 482)				int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN( 482)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            			}
            		}
            		else {
HXDLIN( 482)			if ((bx3 > cx3)) {
HXDLIN( 482)				int min9;
HXDLIN( 482)				if ((bx > cx3)) {
HXDLIN( 482)					min9 = ::Math_obj::floor(cx3);
            				}
            				else {
HXDLIN( 482)					min9 = ::Math_obj::ceil(bx);
            				}
HXDLIN( 482)				int ii_min18 = min9;
HXDLIN( 482)				int ii_max18 = ::Math_obj::ceil(bx3);
HXDLIN( 482)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            			}
            			else {
HXDLIN( 482)				int ii_min19 = ::Math_obj::floor(bx);
HXDLIN( 482)				int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN( 482)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            			}
            		}
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 482)		if ((by > by3)) {
HXDLIN( 482)			if ((by > cy3)) {
HXDLIN( 482)				int min10;
HXDLIN( 482)				if ((by3 > cy3)) {
HXDLIN( 482)					min10 = ::Math_obj::floor(cy3);
            				}
            				else {
HXDLIN( 482)					min10 = ::Math_obj::floor(by3);
            				}
HXDLIN( 482)				int ii_min20 = min10;
HXDLIN( 482)				int ii_max20 = ::Math_obj::ceil(by);
HXDLIN( 482)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            			}
            			else {
HXDLIN( 482)				int ii_min21 = ::Math_obj::floor(by3);
HXDLIN( 482)				int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN( 482)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            			}
            		}
            		else {
HXDLIN( 482)			if ((by3 > cy3)) {
HXDLIN( 482)				int min11;
HXDLIN( 482)				if ((by > cy3)) {
HXDLIN( 482)					min11 = ::Math_obj::floor(cy3);
            				}
            				else {
HXDLIN( 482)					min11 = ::Math_obj::ceil(by);
            				}
HXDLIN( 482)				int ii_min22 = min11;
HXDLIN( 482)				int ii_max22 = ::Math_obj::ceil(by3);
HXDLIN( 482)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            			}
            			else {
HXDLIN( 482)				int ii_min23 = ::Math_obj::floor(by);
HXDLIN( 482)				int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN( 482)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            			}
            		}
HXDLIN( 482)		 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 482)		if (hasUndo1) {
HXDLIN( 482)			int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 482)			int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 482)			 ::Dynamic imageType1 = null();
HXDLIN( 482)			 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 482)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 482)			::Dynamic undoImage4;
HXDLIN( 482)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXDLIN( 482)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::BytesImg b7 = byt1;
HXDLIN( 482)					{
HXDLIN( 482)						b7->width = width1;
HXDLIN( 482)						b7->height = height1;
HXDLIN( 482)						b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 482)						b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN( 482)						{
HXDLIN( 482)							int len2 = b7->length;
HXDLIN( 482)							int w1 = 0;
HXDLIN( 482)							{
HXDLIN( 482)								int _g20 = 0;
HXDLIN( 482)								int _g21 = b7->height;
HXDLIN( 482)								while((_g20 < _g21)){
HXDLIN( 482)									_g20 = (_g20 + 1);
HXDLIN( 482)									int y4 = (_g20 - 1);
HXDLIN( 482)									{
HXDLIN( 482)										int _g22 = 0;
HXDLIN( 482)										int _g23 = b7->width;
HXDLIN( 482)										while((_g22 < _g23)){
HXDLIN( 482)											_g22 = (_g22 + 1);
HXDLIN( 482)											int x4 = (_g22 - 1);
HXDLIN( 482)											{
HXDLIN( 482)												w1 = (w1 + 1);
HXDLIN( 482)												b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w1 = (w1 + 1);
HXDLIN( 482)												b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w1 = (w1 + 1);
HXDLIN( 482)												b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w1 = (w1 + 1);
HXDLIN( 482)												b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage4 = b7;
            				}
            				break;
            				case (int)1: {
HXDLIN( 482)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::ArrIntImg a8 = arrI1;
HXDLIN( 482)					{
HXDLIN( 482)						a8->width = width1;
HXDLIN( 482)						a8->height = height1;
HXDLIN( 482)						a8->data = ::Array_obj< int >::__new(0);
HXDLIN( 482)						a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 482)						{
HXDLIN( 482)							int _g24 = 0;
HXDLIN( 482)							int _g25 = a8->length;
HXDLIN( 482)							while((_g24 < _g25)){
HXDLIN( 482)								_g24 = (_g24 + 1);
HXDLIN( 482)								int i6 = (_g24 - 1);
HXDLIN( 482)								a8->data[i6] = 0;
            							}
            						}
            					}
HXDLIN( 482)					undoImage4 = a8;
            				}
            				break;
            				case (int)2: {
HXDLIN( 482)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::U32ArrImg b8 = u32a1;
HXDLIN( 482)					{
HXDLIN( 482)						b8->width = width1;
HXDLIN( 482)						b8->height = height1;
HXDLIN( 482)						b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 482)						int size1 = (b8->length * 4);
HXDLIN( 482)						b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 482)						{
HXDLIN( 482)							int _g26 = 0;
HXDLIN( 482)							int _g27 = b8->length;
HXDLIN( 482)							while((_g26 < _g27)){
HXDLIN( 482)								_g26 = (_g26 + 1);
HXDLIN( 482)								int i7 = (_g26 - 1);
HXDLIN( 482)								{
HXDLIN( 482)									 ::haxe::io::ArrayBufferViewImpl this36 = b8->data;
HXDLIN( 482)									bool undoImage5;
HXDLIN( 482)									if ((i7 >= 0)) {
HXDLIN( 482)										undoImage5 = (i7 < (this36->byteLength >> 2));
            									}
            									else {
HXDLIN( 482)										undoImage5 = false;
            									}
HXDLIN( 482)									if (undoImage5) {
HXDLIN( 482)										 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 482)										int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 482)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 482)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 482)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 482)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage4 = b8;
            				}
            				break;
            				case (int)3: {
HXDLIN( 482)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 482)					{
HXDLIN( 482)						v2->width = width1;
HXDLIN( 482)						v2->height = height1;
HXDLIN( 482)						v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 482)						v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 482)						{
HXDLIN( 482)							int _g28 = 0;
HXDLIN( 482)							int _g29 = v2->length;
HXDLIN( 482)							while((_g28 < _g29)){
HXDLIN( 482)								_g28 = (_g28 + 1);
HXDLIN( 482)								int i8 = (_g28 - 1);
HXDLIN( 482)								v2->data->__unsafe_set(i8,0);
            							}
            						}
            					}
HXDLIN( 482)					undoImage4 = v2;
            				}
            				break;
            				case (int)4: {
HXDLIN( 482)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::StackIntImg b9 = sInt1;
HXDLIN( 482)					{
HXDLIN( 482)						b9->width = width1;
HXDLIN( 482)						b9->height = height1;
HXDLIN( 482)						b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 482)						b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 482)						{
HXDLIN( 482)							int len3 = b9->length;
HXDLIN( 482)							 ::haxe::ds::GenericStack_Int d1 = b9->data;
HXDLIN( 482)							if (::hx::IsNull( d1->head )) {
HXDLIN( 482)								int _g30 = 0;
HXDLIN( 482)								int _g31 = len3;
HXDLIN( 482)								while((_g30 < _g31)){
HXDLIN( 482)									_g30 = (_g30 + 1);
HXDLIN( 482)									int i9 = (_g30 - 1);
HXDLIN( 482)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXDLIN( 482)								int _g32 = 0;
HXDLIN( 482)								int _g33 = len3;
HXDLIN( 482)								while((_g32 < _g33)){
HXDLIN( 482)									_g32 = (_g32 + 1);
HXDLIN( 482)									int i10 = (_g32 - 1);
HXDLIN( 482)									{
HXDLIN( 482)										 ::haxe::ds::GenericCell_Int l1 = b9->data->head;
HXDLIN( 482)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 482)										{
HXDLIN( 482)											int _g34 = 0;
HXDLIN( 482)											int _g35 = i10;
HXDLIN( 482)											while((_g34 < _g35)){
HXDLIN( 482)												_g34 = (_g34 + 1);
HXDLIN( 482)												int i11 = (_g34 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE( 482)										if (::hx::IsNull( prev1 )) {
HXDLIN( 482)											b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 482)											l1 = null();
            										}
            										else {
HXDLIN( 482)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 482)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage4 = b9;
            				}
            				break;
            			}
HXDLIN( 482)			this35->image = undoImage4;
HXDLIN( 482)			this35->width = width1;
HXDLIN( 482)			this35->height = height1;
HXDLIN( 482)			this35->imageType = ( (int)(imageType1) );
HXDLIN( 482)			undoImage3 = this35;
HXDLIN( 482)			{
HXDLIN( 482)				int rectLeft1 = xIter31->start;
HXDLIN( 482)				int rectTop1 = yIter31->start;
HXDLIN( 482)				int rectRight1 = xIter31->max;
HXDLIN( 482)				bool forceClear1 = false;
HXDLIN( 482)				{
HXDLIN( 482)					int _g36 = rectTop1;
HXDLIN( 482)					int _g37 = yIter31->max;
HXDLIN( 482)					while((_g36 < _g37)){
HXDLIN( 482)						_g36 = (_g36 + 1);
HXDLIN( 482)						int dy2 = (_g36 - 1);
HXDLIN( 482)						{
HXDLIN( 482)							int _g38 = rectLeft1;
HXDLIN( 482)							int _g39 = rectRight1;
HXDLIN( 482)							while((_g38 < _g39)){
HXDLIN( 482)								_g38 = (_g38 + 1);
HXDLIN( 482)								int dx2 = (_g38 - 1);
HXDLIN( 482)								::Dynamic this37 = this1->image;
HXDLIN( 482)								int index5;
HXDLIN( 482)								if (this1->useVirtualPos) {
HXDLIN( 482)									index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            								}
            								else {
HXDLIN( 482)									index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            								}
HXDLIN( 482)								int c6 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 482)								int col1;
HXDLIN( 482)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)									col1 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            								}
            								else {
HXDLIN( 482)									col1 = c6;
            								}
HXDLIN( 482)								bool _hx_tmp8;
HXDLIN( 482)								if (this1->useMask) {
HXDLIN( 482)									_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 482)									_hx_tmp8 = false;
            								}
HXDLIN( 482)								if (_hx_tmp8) {
HXDLIN( 482)									 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN( 482)									::Dynamic this39 = this38->image;
HXDLIN( 482)									int index6;
HXDLIN( 482)									if (this38->useVirtualPos) {
HXDLIN( 482)										index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            									}
            									else {
HXDLIN( 482)										index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            									}
HXDLIN( 482)									int c7 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 482)									int v3;
HXDLIN( 482)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)										v3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXDLIN( 482)										v3 = c7;
            									}
HXDLIN( 482)									int maskPixel1 = v3;
HXDLIN( 482)									int this40 = col1;
HXDLIN( 482)									if ((maskPixel1 == 0)) {
HXDLIN( 482)										col1 = this40;
            									}
            									else {
HXDLIN( 482)										Float m01;
HXDLIN( 482)										int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 482)										if ((this41 == 0)) {
HXDLIN( 482)											m01 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m11;
HXDLIN( 482)										int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 482)										if ((this42 == 0)) {
HXDLIN( 482)											m11 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m21;
HXDLIN( 482)										int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 482)										if ((this43 == 0)) {
HXDLIN( 482)											m21 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m31;
HXDLIN( 482)										int this44 = (maskPixel1 & 255);
HXDLIN( 482)										if ((this44 == 0)) {
HXDLIN( 482)											m31 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 482)										int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 482)										int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 482)										int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 482)										col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 482)								if ((col1 != 0)) {
HXDLIN( 482)									int x5 = (dx2 - rectLeft1);
HXDLIN( 482)									int y5 = (dy2 - rectTop1);
HXDLIN( 482)									int c8 = col1;
HXDLIN( 482)									bool _hx_tmp9;
HXDLIN( 482)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 482)										_hx_tmp9 = undoImage3->transparent;
            									}
            									else {
HXDLIN( 482)										_hx_tmp9 = false;
            									}
HXDLIN( 482)									if (_hx_tmp9) {
HXDLIN( 482)										int location2;
HXDLIN( 482)										if (undoImage3->useVirtualPos) {
HXDLIN( 482)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            										}
            										else {
HXDLIN( 482)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            										}
HXDLIN( 482)										int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 482)										int this46;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											this46 = this45;
            										}
HXDLIN( 482)										Float a13;
HXDLIN( 482)										int this47 = ((this46 >> 24) & 255);
HXDLIN( 482)										if ((this47 == 0)) {
HXDLIN( 482)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a13 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r12;
HXDLIN( 482)										int this48 = ((this46 >> 16) & 255);
HXDLIN( 482)										if ((this48 == 0)) {
HXDLIN( 482)											r12 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g12;
HXDLIN( 482)										int this49 = ((this46 >> 8) & 255);
HXDLIN( 482)										if ((this49 == 0)) {
HXDLIN( 482)											g12 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b13;
HXDLIN( 482)										int this50 = (this46 & 255);
HXDLIN( 482)										if ((this50 == 0)) {
HXDLIN( 482)											b13 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a22;
HXDLIN( 482)										int this51 = ((col1 >> 24) & 255);
HXDLIN( 482)										if ((this51 == 0)) {
HXDLIN( 482)											a22 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r22;
HXDLIN( 482)										int this52 = ((col1 >> 16) & 255);
HXDLIN( 482)										if ((this52 == 0)) {
HXDLIN( 482)											r22 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g22;
HXDLIN( 482)										int this53 = ((col1 >> 8) & 255);
HXDLIN( 482)										if ((this53 == 0)) {
HXDLIN( 482)											g22 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b23;
HXDLIN( 482)										int this54 = (col1 & 255);
HXDLIN( 482)										if ((this54 == 0)) {
HXDLIN( 482)											b23 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 482)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 482)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 482)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 482)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 482)										int blended2 = ((((a9 << 24) | (r4 << 16)) | (g4 << 8)) | b10);
HXDLIN( 482)										{
HXDLIN( 482)											int _hx_tmp10;
HXDLIN( 482)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)												_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXDLIN( 482)												_hx_tmp10 = blended2;
            											}
HXDLIN( 482)											::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            										}
            									}
            									else {
HXDLIN( 482)										::Dynamic this55 = undoImage3->image;
HXDLIN( 482)										int index7;
HXDLIN( 482)										if (undoImage3->useVirtualPos) {
HXDLIN( 482)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            										}
            										else {
HXDLIN( 482)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            										}
HXDLIN( 482)										int _hx_tmp11;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											_hx_tmp11 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											_hx_tmp11 = c8;
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this55,index7,_hx_tmp11);
            									}
            								}
            								else {
HXDLIN( 482)									if (forceClear1) {
HXDLIN( 482)										::Dynamic this56 = undoImage3->image;
HXDLIN( 482)										int x6 = (dx2 - rectLeft1);
HXDLIN( 482)										int y6 = (dy2 - rectTop1);
HXDLIN( 482)										int index8;
HXDLIN( 482)										if (undoImage3->useVirtualPos) {
HXDLIN( 482)											index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            										}
            										else {
HXDLIN( 482)											index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this56,index8,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 482)		bool found1 = false;
HXDLIN( 482)		Float s1 = ((Float)0.);
HXDLIN( 482)		Float t1 = ((Float)0.);
HXDLIN( 482)		Float sxx1 = ((Float)0.);
HXDLIN( 482)		Float txx1 = ((Float)0.);
HXDLIN( 482)		{
HXDLIN( 482)			int _g_min2 = xIter31->start;
HXDLIN( 482)			int _g_max2 = xIter31->max;
HXDLIN( 482)			while((_g_min2 < _g_max2)){
HXDLIN( 482)				_g_min2 = (_g_min2 + 1);
HXDLIN( 482)				int x7 = (_g_min2 - 1);
HXLINE(  60)				sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)				txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)				found1 = false;
HXLINE( 482)				{
HXDLIN( 482)					int _g_min3 = yIter31->start;
HXDLIN( 482)					int _g_max3 = yIter31->max;
HXDLIN( 482)					while((_g_min3 < _g_max3)){
HXDLIN( 482)						_g_min3 = (_g_min3 + 1);
HXDLIN( 482)						int y7 = (_g_min3 - 1);
HXLINE(  64)						s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)						t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 482)						bool _hx_tmp12;
HXDLIN( 482)						if (!((s1 <= 0))) {
HXDLIN( 482)							_hx_tmp12 = (t1 <= 0);
            						}
            						else {
HXDLIN( 482)							_hx_tmp12 = true;
            						}
HXDLIN( 482)						if (_hx_tmp12) {
HXDLIN( 482)							if (found1) {
HXDLIN( 482)								goto _hx_goto_884;
            							}
            						}
            						else {
HXDLIN( 482)							if (((s1 + t1) < A1)) {
HXDLIN( 482)								{
HXDLIN( 482)									int c9 = color;
HXDLIN( 482)									bool _hx_tmp13;
HXDLIN( 482)									if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 482)										_hx_tmp13 = this1->transparent;
            									}
            									else {
HXDLIN( 482)										_hx_tmp13 = false;
            									}
HXDLIN( 482)									if (_hx_tmp13) {
HXDLIN( 482)										int location3;
HXDLIN( 482)										if (this1->useVirtualPos) {
HXDLIN( 482)											location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            										}
            										else {
HXDLIN( 482)											location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            										}
HXDLIN( 482)										int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 482)										int this58;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											this58 = this57;
            										}
HXDLIN( 482)										Float a14;
HXDLIN( 482)										int this59 = ((this58 >> 24) & 255);
HXDLIN( 482)										if ((this59 == 0)) {
HXDLIN( 482)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a14 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r13;
HXDLIN( 482)										int this60 = ((this58 >> 16) & 255);
HXDLIN( 482)										if ((this60 == 0)) {
HXDLIN( 482)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g13;
HXDLIN( 482)										int this61 = ((this58 >> 8) & 255);
HXDLIN( 482)										if ((this61 == 0)) {
HXDLIN( 482)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b14;
HXDLIN( 482)										int this62 = (this58 & 255);
HXDLIN( 482)										if ((this62 == 0)) {
HXDLIN( 482)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a23;
HXDLIN( 482)										int this63 = ((color >> 24) & 255);
HXDLIN( 482)										if ((this63 == 0)) {
HXDLIN( 482)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r23;
HXDLIN( 482)										int this64 = ((color >> 16) & 255);
HXDLIN( 482)										if ((this64 == 0)) {
HXDLIN( 482)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g23;
HXDLIN( 482)										int this65 = ((color >> 8) & 255);
HXDLIN( 482)										if ((this65 == 0)) {
HXDLIN( 482)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b24;
HXDLIN( 482)										int this66 = (color & 255);
HXDLIN( 482)										if ((this66 == 0)) {
HXDLIN( 482)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 482)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 482)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 482)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 482)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 482)										int blended3 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b15);
HXDLIN( 482)										{
HXDLIN( 482)											int _hx_tmp14;
HXDLIN( 482)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)												_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 482)												_hx_tmp14 = blended3;
            											}
HXDLIN( 482)											::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            										}
            									}
            									else {
HXDLIN( 482)										::Dynamic this67 = this1->image;
HXDLIN( 482)										int index9;
HXDLIN( 482)										if (this1->useVirtualPos) {
HXDLIN( 482)											index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            										}
            										else {
HXDLIN( 482)											index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            										}
HXDLIN( 482)										int _hx_tmp15;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											_hx_tmp15 = c9;
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this67,index9,_hx_tmp15);
            									}
            								}
HXLINE(  73)								found1 = true;
            							}
            							else {
HXDLIN( 482)								if (found1) {
HXDLIN( 482)									goto _hx_goto_884;
            								}
            							}
            						}
            					}
            					_hx_goto_884:;
            				}
            			}
            		}
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 482)		int v_undoY1;
HXDLIN( 482)		int v_undoX1;
HXDLIN( 482)		Float v_ty1;
HXDLIN( 482)		Float v_tx1;
HXDLIN( 482)		Float v_t01;
HXDLIN( 482)		Float v_sy1;
HXDLIN( 482)		Float v_sx1;
HXDLIN( 482)		Float v_s01;
HXDLIN( 482)		Float v_A1;
HXDLIN( 482)		Float ax2 = bx;
HXDLIN( 482)		Float ay2 = by;
HXDLIN( 482)		 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 482)		Float bx4 = bx3;
HXDLIN( 482)		Float by4 = by3;
HXDLIN( 482)		Float cx4 = cx3;
HXDLIN( 482)		Float cy4 = cy3;
HXDLIN( 482)		bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN( 482)		if (!(adjustWinding3)) {
HXDLIN( 482)			Float bx_3 = bx4;
HXDLIN( 482)			Float by_3 = by4;
HXLINE(  24)			bx4 = cx4;
HXLINE(  25)			by4 = cy4;
HXLINE(  26)			cx4 = bx_3;
HXLINE(  27)			cy4 = by_3;
            		}
HXLINE( 482)		Float v_ax1 = ax2;
HXDLIN( 482)		Float v_ay1 = ay2;
HXDLIN( 482)		Float v_bx1 = bx4;
HXDLIN( 482)		Float v_by1 = by4;
HXDLIN( 482)		Float v_cx1 = cx4;
HXDLIN( 482)		Float v_cy1 = cy4;
HXDLIN( 482)		bool v_preCalculated1 = true;
HXDLIN( 482)		{
HXDLIN( 482)			v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 482)			v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 482)			v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 482)			v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 482)			v_tx1 = (v_ay1 - v_by1);
HXDLIN( 482)			v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 482)			v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 482)			Float a15 = v_ax1;
HXDLIN( 482)			Float b16 = v_bx1;
HXDLIN( 482)			Float c10 = v_cx1;
HXDLIN( 482)			if ((a15 > b16)) {
HXDLIN( 482)				if ((a15 > c10)) {
HXDLIN( 482)					int min12;
HXDLIN( 482)					if ((b16 > c10)) {
HXDLIN( 482)						min12 = ::Math_obj::floor(c10);
            					}
            					else {
HXDLIN( 482)						min12 = ::Math_obj::floor(b16);
            					}
HXDLIN( 482)					int ii_min24 = min12;
HXDLIN( 482)					int ii_max24 = ::Math_obj::ceil(a15);
HXDLIN( 482)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            				}
            				else {
HXDLIN( 482)					int ii_min25 = ::Math_obj::floor(b16);
HXDLIN( 482)					int ii_max25 = ::Math_obj::ceil(c10);
HXDLIN( 482)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            				}
            			}
            			else {
HXDLIN( 482)				if ((b16 > c10)) {
HXDLIN( 482)					int min13;
HXDLIN( 482)					if ((a15 > c10)) {
HXDLIN( 482)						min13 = ::Math_obj::floor(c10);
            					}
            					else {
HXDLIN( 482)						min13 = ::Math_obj::ceil(a15);
            					}
HXDLIN( 482)					int ii_min26 = min13;
HXDLIN( 482)					int ii_max26 = ::Math_obj::ceil(b16);
HXDLIN( 482)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            				}
            				else {
HXDLIN( 482)					int ii_min27 = ::Math_obj::floor(a15);
HXDLIN( 482)					int ii_max27 = ::Math_obj::ceil(c10);
HXDLIN( 482)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            				}
            			}
HXDLIN( 482)			Float a16 = v_ay1;
HXDLIN( 482)			Float b17 = v_by1;
HXDLIN( 482)			Float c11 = v_cy1;
HXDLIN( 482)			if ((a16 > b17)) {
HXDLIN( 482)				if ((a16 > c11)) {
HXDLIN( 482)					int min14;
HXDLIN( 482)					if ((b17 > c11)) {
HXDLIN( 482)						min14 = ::Math_obj::floor(c11);
            					}
            					else {
HXDLIN( 482)						min14 = ::Math_obj::floor(b17);
            					}
HXDLIN( 482)					int ii_min28 = min14;
HXDLIN( 482)					int ii_max28 = ::Math_obj::ceil(a16);
HXDLIN( 482)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            				}
            				else {
HXDLIN( 482)					int ii_min29 = ::Math_obj::floor(b17);
HXDLIN( 482)					int ii_max29 = ::Math_obj::ceil(c11);
HXDLIN( 482)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            				}
            			}
            			else {
HXDLIN( 482)				if ((b17 > c11)) {
HXDLIN( 482)					int min15;
HXDLIN( 482)					if ((a16 > c11)) {
HXDLIN( 482)						min15 = ::Math_obj::floor(c11);
            					}
            					else {
HXDLIN( 482)						min15 = ::Math_obj::ceil(a16);
            					}
HXDLIN( 482)					int ii_min30 = min15;
HXDLIN( 482)					int ii_max30 = ::Math_obj::ceil(b17);
HXDLIN( 482)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            				}
            				else {
HXDLIN( 482)					int ii_min31 = ::Math_obj::floor(a16);
HXDLIN( 482)					int ii_max31 = ::Math_obj::ceil(c11);
HXDLIN( 482)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            				}
            			}
            		}
HXDLIN( 482)		if (hasUndo1) {
HXDLIN( 482)			v_undoImage1 = undoImage3;
HXDLIN( 482)			v_undoX1 = xIter31->start;
HXDLIN( 482)			v_undoY1 = yIter31->start;
            		}
HXDLIN( 482)		 ::pi_xy::algo::HitQuad v4 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 482)		 ::pi_xy::algo::HitQuad hitQuad = v4;
HXDLIN( 482)		Float cx5 = h2;
HXDLIN( 482)		Float cy5 = radius2;
HXDLIN( 482)		Float bx5 = h2;
HXDLIN( 482)		Float by5 = -(radius2);
HXDLIN( 482)		Float dx3 = hSmall;
HXDLIN( 482)		Float dy3 = radius2;
HXDLIN( 482)		Float ax3 = hSmall;
HXDLIN( 482)		Float ay3 = -(radius2);
HXLINE( 203)		temp = (px + ((bx5 * cos) - (by5 * sin)));
HXLINE( 204)		by5 = (py + ((by5 * cos) + (bx5 * sin)));
HXLINE( 205)		bx5 = temp;
HXLINE( 206)		temp = (px + ((cx5 * cos) - (cy5 * sin)));
HXLINE( 207)		cy5 = (py + ((cy5 * cos) + (cx5 * sin)));
HXLINE( 208)		cx5 = temp;
HXLINE( 210)		temp = (px + ((ax3 * cos) - (ay3 * sin)));
HXLINE( 211)		ay3 = (py + ((ay3 * cos) + (ax3 * sin)));
HXLINE( 212)		ax3 = temp;
HXLINE( 214)		temp = (px + ((dx3 * cos) - (dy3 * sin)));
HXLINE( 215)		dy3 = (py + ((dy3 * cos) + (dx3 * sin)));
HXLINE( 216)		dx3 = temp;
HXLINE( 482)		Float bx6 = bx5;
HXDLIN( 482)		Float by6 = by5;
HXDLIN( 482)		Float cx6 = cx5;
HXDLIN( 482)		Float cy6 = cy5;
HXDLIN( 482)		bool hasUndo2 = false;
HXDLIN( 482)		bool adjustWinding4 = (((((qx * by6) - (bx6 * qy)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * qy) - (qx * cy6))) > 0);
HXDLIN( 482)		if (!(adjustWinding4)) {
HXDLIN( 482)			Float bx_4 = bx6;
HXDLIN( 482)			Float by_4 = by6;
HXLINE(  25)			bx6 = cx6;
HXLINE(  26)			by6 = cy6;
HXLINE(  27)			cx6 = bx_4;
HXLINE(  28)			cy6 = by_4;
            		}
HXLINE( 482)		Float s02 = ((qy * cx6) - (qx * cy6));
HXDLIN( 482)		Float sx2 = (cy6 - qy);
HXDLIN( 482)		Float sy2 = (qx - cx6);
HXDLIN( 482)		Float t02 = ((qx * by6) - (qy * bx6));
HXDLIN( 482)		Float tx2 = (qy - by6);
HXDLIN( 482)		Float ty2 = (bx6 - qx);
HXDLIN( 482)		Float A2 = ((((-(by6) * cx6) + (qy * (-(bx6) + cx6))) + (qx * (by6 - cy6))) + (bx6 * cy6));
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 482)		if ((qx > bx6)) {
HXDLIN( 482)			if ((qx > cx6)) {
HXDLIN( 482)				int min16;
HXDLIN( 482)				if ((bx6 > cx6)) {
HXDLIN( 482)					min16 = ::Math_obj::floor(cx6);
            				}
            				else {
HXDLIN( 482)					min16 = ::Math_obj::floor(bx6);
            				}
HXDLIN( 482)				int ii_min32 = min16;
HXDLIN( 482)				int ii_max32 = ::Math_obj::ceil(qx);
HXDLIN( 482)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            			}
            			else {
HXDLIN( 482)				int ii_min33 = ::Math_obj::floor(bx6);
HXDLIN( 482)				int ii_max33 = ::Math_obj::ceil(cx6);
HXDLIN( 482)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            			}
            		}
            		else {
HXDLIN( 482)			if ((bx6 > cx6)) {
HXDLIN( 482)				int min17;
HXDLIN( 482)				if ((qx > cx6)) {
HXDLIN( 482)					min17 = ::Math_obj::floor(cx6);
            				}
            				else {
HXDLIN( 482)					min17 = ::Math_obj::ceil(qx);
            				}
HXDLIN( 482)				int ii_min34 = min17;
HXDLIN( 482)				int ii_max34 = ::Math_obj::ceil(bx6);
HXDLIN( 482)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            			}
            			else {
HXDLIN( 482)				int ii_min35 = ::Math_obj::floor(qx);
HXDLIN( 482)				int ii_max35 = ::Math_obj::ceil(cx6);
HXDLIN( 482)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            			}
            		}
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 482)		if ((qy > by6)) {
HXDLIN( 482)			if ((qy > cy6)) {
HXDLIN( 482)				int min18;
HXDLIN( 482)				if ((by6 > cy6)) {
HXDLIN( 482)					min18 = ::Math_obj::floor(cy6);
            				}
            				else {
HXDLIN( 482)					min18 = ::Math_obj::floor(by6);
            				}
HXDLIN( 482)				int ii_min36 = min18;
HXDLIN( 482)				int ii_max36 = ::Math_obj::ceil(qy);
HXDLIN( 482)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            			}
            			else {
HXDLIN( 482)				int ii_min37 = ::Math_obj::floor(by6);
HXDLIN( 482)				int ii_max37 = ::Math_obj::ceil(cy6);
HXDLIN( 482)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            			}
            		}
            		else {
HXDLIN( 482)			if ((by6 > cy6)) {
HXDLIN( 482)				int min19;
HXDLIN( 482)				if ((qy > cy6)) {
HXDLIN( 482)					min19 = ::Math_obj::floor(cy6);
            				}
            				else {
HXDLIN( 482)					min19 = ::Math_obj::ceil(qy);
            				}
HXDLIN( 482)				int ii_min38 = min19;
HXDLIN( 482)				int ii_max38 = ::Math_obj::ceil(by6);
HXDLIN( 482)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            			}
            			else {
HXDLIN( 482)				int ii_min39 = ::Math_obj::floor(qy);
HXDLIN( 482)				int ii_max39 = ::Math_obj::ceil(cy6);
HXDLIN( 482)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            			}
            		}
HXDLIN( 482)		 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 482)		if (hasUndo2) {
HXDLIN( 482)			int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 482)			int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 482)			 ::Dynamic imageType2 = null();
HXDLIN( 482)			 ::pi_xy::ImageStruct this68 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 482)			if (::hx::IsNull( imageType2 )) {
HXLINE(  54)				imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 482)			::Dynamic undoImage7;
HXDLIN( 482)			switch((int)(( (int)(imageType2) ))){
            				case (int)0: {
HXDLIN( 482)					 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::BytesImg b18 = byt2;
HXDLIN( 482)					{
HXDLIN( 482)						b18->width = width2;
HXDLIN( 482)						b18->height = height2;
HXDLIN( 482)						b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 482)						b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN( 482)						{
HXDLIN( 482)							int len4 = b18->length;
HXDLIN( 482)							int w2 = 0;
HXDLIN( 482)							{
HXDLIN( 482)								int _g40 = 0;
HXDLIN( 482)								int _g41 = b18->height;
HXDLIN( 482)								while((_g40 < _g41)){
HXDLIN( 482)									_g40 = (_g40 + 1);
HXDLIN( 482)									int y8 = (_g40 - 1);
HXDLIN( 482)									{
HXDLIN( 482)										int _g42 = 0;
HXDLIN( 482)										int _g43 = b18->width;
HXDLIN( 482)										while((_g42 < _g43)){
HXDLIN( 482)											_g42 = (_g42 + 1);
HXDLIN( 482)											int x8 = (_g42 - 1);
HXDLIN( 482)											{
HXDLIN( 482)												w2 = (w2 + 1);
HXDLIN( 482)												b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w2 = (w2 + 1);
HXDLIN( 482)												b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w2 = (w2 + 1);
HXDLIN( 482)												b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w2 = (w2 + 1);
HXDLIN( 482)												b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage7 = b18;
            				}
            				break;
            				case (int)1: {
HXDLIN( 482)					 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::ArrIntImg a17 = arrI2;
HXDLIN( 482)					{
HXDLIN( 482)						a17->width = width2;
HXDLIN( 482)						a17->height = height2;
HXDLIN( 482)						a17->data = ::Array_obj< int >::__new(0);
HXDLIN( 482)						a17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 482)						{
HXDLIN( 482)							int _g44 = 0;
HXDLIN( 482)							int _g45 = a17->length;
HXDLIN( 482)							while((_g44 < _g45)){
HXDLIN( 482)								_g44 = (_g44 + 1);
HXDLIN( 482)								int i12 = (_g44 - 1);
HXDLIN( 482)								a17->data[i12] = 0;
            							}
            						}
            					}
HXDLIN( 482)					undoImage7 = a17;
            				}
            				break;
            				case (int)2: {
HXDLIN( 482)					 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::U32ArrImg b19 = u32a2;
HXDLIN( 482)					{
HXDLIN( 482)						b19->width = width2;
HXDLIN( 482)						b19->height = height2;
HXDLIN( 482)						b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 482)						int size2 = (b19->length * 4);
HXDLIN( 482)						b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 482)						{
HXDLIN( 482)							int _g46 = 0;
HXDLIN( 482)							int _g47 = b19->length;
HXDLIN( 482)							while((_g46 < _g47)){
HXDLIN( 482)								_g46 = (_g46 + 1);
HXDLIN( 482)								int i13 = (_g46 - 1);
HXDLIN( 482)								{
HXDLIN( 482)									 ::haxe::io::ArrayBufferViewImpl this69 = b19->data;
HXDLIN( 482)									bool undoImage8;
HXDLIN( 482)									if ((i13 >= 0)) {
HXDLIN( 482)										undoImage8 = (i13 < (this69->byteLength >> 2));
            									}
            									else {
HXDLIN( 482)										undoImage8 = false;
            									}
HXDLIN( 482)									if (undoImage8) {
HXDLIN( 482)										 ::haxe::io::Bytes _this2 = this69->bytes;
HXDLIN( 482)										int pos2 = ((i13 << 2) + this69->byteOffset);
HXDLIN( 482)										_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 482)										_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 482)										_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 482)										_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage7 = b19;
            				}
            				break;
            				case (int)3: {
HXDLIN( 482)					 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN( 482)					{
HXDLIN( 482)						v5->width = width2;
HXDLIN( 482)						v5->height = height2;
HXDLIN( 482)						v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 482)						v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN( 482)						{
HXDLIN( 482)							int _g48 = 0;
HXDLIN( 482)							int _g49 = v5->length;
HXDLIN( 482)							while((_g48 < _g49)){
HXDLIN( 482)								_g48 = (_g48 + 1);
HXDLIN( 482)								int i14 = (_g48 - 1);
HXDLIN( 482)								v5->data->__unsafe_set(i14,0);
            							}
            						}
            					}
HXDLIN( 482)					undoImage7 = v5;
            				}
            				break;
            				case (int)4: {
HXDLIN( 482)					 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::StackIntImg b20 = sInt2;
HXDLIN( 482)					{
HXDLIN( 482)						b20->width = width2;
HXDLIN( 482)						b20->height = height2;
HXDLIN( 482)						b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 482)						b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 482)						{
HXDLIN( 482)							int len5 = b20->length;
HXDLIN( 482)							 ::haxe::ds::GenericStack_Int d2 = b20->data;
HXDLIN( 482)							if (::hx::IsNull( d2->head )) {
HXDLIN( 482)								int _g50 = 0;
HXDLIN( 482)								int _g51 = len5;
HXDLIN( 482)								while((_g50 < _g51)){
HXDLIN( 482)									_g50 = (_g50 + 1);
HXDLIN( 482)									int i15 = (_g50 - 1);
HXDLIN( 482)									d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            								}
            							}
            							else {
HXDLIN( 482)								int _g52 = 0;
HXDLIN( 482)								int _g53 = len5;
HXDLIN( 482)								while((_g52 < _g53)){
HXDLIN( 482)									_g52 = (_g52 + 1);
HXDLIN( 482)									int i16 = (_g52 - 1);
HXDLIN( 482)									{
HXDLIN( 482)										 ::haxe::ds::GenericCell_Int l2 = b20->data->head;
HXDLIN( 482)										 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 482)										{
HXDLIN( 482)											int _g54 = 0;
HXDLIN( 482)											int _g55 = i16;
HXDLIN( 482)											while((_g54 < _g55)){
HXDLIN( 482)												_g54 = (_g54 + 1);
HXDLIN( 482)												int i17 = (_g54 - 1);
HXLINE( 345)												prev2 = l2;
HXLINE( 346)												l2 = l2->next;
            											}
            										}
HXLINE( 482)										if (::hx::IsNull( prev2 )) {
HXDLIN( 482)											b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 482)											l2 = null();
            										}
            										else {
HXDLIN( 482)											prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 482)											l2 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage7 = b20;
            				}
            				break;
            			}
HXDLIN( 482)			this68->image = undoImage7;
HXDLIN( 482)			this68->width = width2;
HXDLIN( 482)			this68->height = height2;
HXDLIN( 482)			this68->imageType = ( (int)(imageType2) );
HXDLIN( 482)			undoImage6 = this68;
HXDLIN( 482)			{
HXDLIN( 482)				int rectLeft2 = xIter32->start;
HXDLIN( 482)				int rectTop2 = yIter32->start;
HXDLIN( 482)				int rectRight2 = xIter32->max;
HXDLIN( 482)				bool forceClear2 = false;
HXDLIN( 482)				{
HXDLIN( 482)					int _g56 = rectTop2;
HXDLIN( 482)					int _g57 = yIter32->max;
HXDLIN( 482)					while((_g56 < _g57)){
HXDLIN( 482)						_g56 = (_g56 + 1);
HXDLIN( 482)						int dy4 = (_g56 - 1);
HXDLIN( 482)						{
HXDLIN( 482)							int _g58 = rectLeft2;
HXDLIN( 482)							int _g59 = rectRight2;
HXDLIN( 482)							while((_g58 < _g59)){
HXDLIN( 482)								_g58 = (_g58 + 1);
HXDLIN( 482)								int dx4 = (_g58 - 1);
HXDLIN( 482)								::Dynamic this70 = this1->image;
HXDLIN( 482)								int index10;
HXDLIN( 482)								if (this1->useVirtualPos) {
HXDLIN( 482)									index10 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx4) - this1->virtualX));
            								}
            								else {
HXDLIN( 482)									index10 = ::Std_obj::_hx_int(( (Float)(((dy4 * this1->width) + dx4)) ));
            								}
HXDLIN( 482)								int c12 = ::iterMagic::Iimg_obj::get(this70,index10);
HXDLIN( 482)								int col2;
HXDLIN( 482)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)									col2 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            								}
            								else {
HXDLIN( 482)									col2 = c12;
            								}
HXDLIN( 482)								bool _hx_tmp16;
HXDLIN( 482)								if (this1->useMask) {
HXDLIN( 482)									_hx_tmp16 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 482)									_hx_tmp16 = false;
            								}
HXDLIN( 482)								if (_hx_tmp16) {
HXDLIN( 482)									 ::pi_xy::ImageStruct this71 = this1->mask;
HXDLIN( 482)									::Dynamic this72 = this71->image;
HXDLIN( 482)									int index11;
HXDLIN( 482)									if (this71->useVirtualPos) {
HXDLIN( 482)										index11 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this71->virtualY) * ( (Float)(this71->width) )) + dx4) - this71->virtualX));
            									}
            									else {
HXDLIN( 482)										index11 = ::Std_obj::_hx_int(( (Float)(((dy4 * this71->width) + dx4)) ));
            									}
HXDLIN( 482)									int c13 = ::iterMagic::Iimg_obj::get(this72,index11);
HXDLIN( 482)									int v6;
HXDLIN( 482)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)										v6 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            									}
            									else {
HXDLIN( 482)										v6 = c13;
            									}
HXDLIN( 482)									int maskPixel2 = v6;
HXDLIN( 482)									int this73 = col2;
HXDLIN( 482)									if ((maskPixel2 == 0)) {
HXDLIN( 482)										col2 = this73;
            									}
            									else {
HXDLIN( 482)										Float m02;
HXDLIN( 482)										int this74 = ((maskPixel2 >> 24) & 255);
HXDLIN( 482)										if ((this74 == 0)) {
HXDLIN( 482)											m02 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m02 = (( (Float)(this74) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m12;
HXDLIN( 482)										int this75 = ((maskPixel2 >> 16) & 255);
HXDLIN( 482)										if ((this75 == 0)) {
HXDLIN( 482)											m12 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m12 = (( (Float)(this75) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m22;
HXDLIN( 482)										int this76 = ((maskPixel2 >> 8) & 255);
HXDLIN( 482)										if ((this76 == 0)) {
HXDLIN( 482)											m22 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m22 = (( (Float)(this76) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m32;
HXDLIN( 482)										int this77 = (maskPixel2 & 255);
HXDLIN( 482)										if ((this77 == 0)) {
HXDLIN( 482)											m32 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m32 = (( (Float)(this77) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this73 >> 24) & 255)) )));
HXDLIN( 482)										int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this73 >> 16) & 255)) )));
HXDLIN( 482)										int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this73 >> 8) & 255)) )));
HXDLIN( 482)										int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this73 & 255)) )));
HXDLIN( 482)										col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 482)								if ((col2 != 0)) {
HXDLIN( 482)									int x9 = (dx4 - rectLeft2);
HXDLIN( 482)									int y9 = (dy4 - rectTop2);
HXDLIN( 482)									int c14 = col2;
HXDLIN( 482)									bool _hx_tmp17;
HXDLIN( 482)									if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 482)										_hx_tmp17 = undoImage6->transparent;
            									}
            									else {
HXDLIN( 482)										_hx_tmp17 = false;
            									}
HXDLIN( 482)									if (_hx_tmp17) {
HXDLIN( 482)										int location4;
HXDLIN( 482)										if (undoImage6->useVirtualPos) {
HXDLIN( 482)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 482)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            										}
HXDLIN( 482)										int this78 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 482)										int this79;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											this79 = ((((((this78 >> 24) & 255) << 24) | ((this78 & 255) << 16)) | (((this78 >> 8) & 255) << 8)) | ((this78 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											this79 = this78;
            										}
HXDLIN( 482)										Float a18;
HXDLIN( 482)										int this80 = ((this79 >> 24) & 255);
HXDLIN( 482)										if ((this80 == 0)) {
HXDLIN( 482)											a18 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a18 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r14;
HXDLIN( 482)										int this81 = ((this79 >> 16) & 255);
HXDLIN( 482)										if ((this81 == 0)) {
HXDLIN( 482)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r14 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g14;
HXDLIN( 482)										int this82 = ((this79 >> 8) & 255);
HXDLIN( 482)										if ((this82 == 0)) {
HXDLIN( 482)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g14 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b110;
HXDLIN( 482)										int this83 = (this79 & 255);
HXDLIN( 482)										if ((this83 == 0)) {
HXDLIN( 482)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b110 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a24;
HXDLIN( 482)										int this84 = ((col2 >> 24) & 255);
HXDLIN( 482)										if ((this84 == 0)) {
HXDLIN( 482)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a24 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r24;
HXDLIN( 482)										int this85 = ((col2 >> 16) & 255);
HXDLIN( 482)										if ((this85 == 0)) {
HXDLIN( 482)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r24 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g24;
HXDLIN( 482)										int this86 = ((col2 >> 8) & 255);
HXDLIN( 482)										if ((this86 == 0)) {
HXDLIN( 482)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g24 = (( (Float)(this86) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b25;
HXDLIN( 482)										int this87 = (col2 & 255);
HXDLIN( 482)										if ((this87 == 0)) {
HXDLIN( 482)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b25 = (( (Float)(this87) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a34 = (a18 * (( (Float)(1) ) - a24));
HXDLIN( 482)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 482)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 482)										int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN( 482)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 482)										int blended4 = ((((a19 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN( 482)										{
HXDLIN( 482)											int _hx_tmp18;
HXDLIN( 482)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)												_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 482)												_hx_tmp18 = blended4;
            											}
HXDLIN( 482)											::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            										}
            									}
            									else {
HXDLIN( 482)										::Dynamic this88 = undoImage6->image;
HXDLIN( 482)										int index12;
HXDLIN( 482)										if (undoImage6->useVirtualPos) {
HXDLIN( 482)											index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 482)											index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            										}
HXDLIN( 482)										int _hx_tmp19;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											_hx_tmp19 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											_hx_tmp19 = c14;
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this88,index12,_hx_tmp19);
            									}
            								}
            								else {
HXDLIN( 482)									if (forceClear2) {
HXDLIN( 482)										::Dynamic this89 = undoImage6->image;
HXDLIN( 482)										int x10 = (dx4 - rectLeft2);
HXDLIN( 482)										int y10 = (dy4 - rectTop2);
HXDLIN( 482)										int index13;
HXDLIN( 482)										if (undoImage6->useVirtualPos) {
HXDLIN( 482)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 482)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this89,index13,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 482)		bool found2 = false;
HXDLIN( 482)		Float s2 = ((Float)0.);
HXDLIN( 482)		Float t2 = ((Float)0.);
HXDLIN( 482)		Float sxx2 = ((Float)0.);
HXDLIN( 482)		Float txx2 = ((Float)0.);
HXDLIN( 482)		{
HXDLIN( 482)			int _g_min4 = xIter32->start;
HXDLIN( 482)			int _g_max4 = xIter32->max;
HXDLIN( 482)			while((_g_min4 < _g_max4)){
HXDLIN( 482)				_g_min4 = (_g_min4 + 1);
HXDLIN( 482)				int x11 = (_g_min4 - 1);
HXLINE(  60)				sxx2 = (sx2 * ( (Float)(x11) ));
HXLINE(  61)				txx2 = (tx2 * ( (Float)(x11) ));
HXLINE(  62)				found2 = false;
HXLINE( 482)				{
HXDLIN( 482)					int _g_min5 = yIter32->start;
HXDLIN( 482)					int _g_max5 = yIter32->max;
HXDLIN( 482)					while((_g_min5 < _g_max5)){
HXDLIN( 482)						_g_min5 = (_g_min5 + 1);
HXDLIN( 482)						int y11 = (_g_min5 - 1);
HXLINE(  64)						s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y11) )));
HXLINE(  65)						t2 = ((t02 + txx2) + (ty2 * ( (Float)(y11) )));
HXLINE( 482)						bool _hx_tmp20;
HXDLIN( 482)						if (!((s2 <= 0))) {
HXDLIN( 482)							_hx_tmp20 = (t2 <= 0);
            						}
            						else {
HXDLIN( 482)							_hx_tmp20 = true;
            						}
HXDLIN( 482)						if (_hx_tmp20) {
HXDLIN( 482)							if (found2) {
HXDLIN( 482)								goto _hx_goto_896;
            							}
            						}
            						else {
HXDLIN( 482)							if (((s2 + t2) < A2)) {
HXDLIN( 482)								{
HXDLIN( 482)									int c15 = color;
HXDLIN( 482)									bool _hx_tmp21;
HXDLIN( 482)									if ((((c15 >> 24) & 255) < 254)) {
HXDLIN( 482)										_hx_tmp21 = this1->transparent;
            									}
            									else {
HXDLIN( 482)										_hx_tmp21 = false;
            									}
HXDLIN( 482)									if (_hx_tmp21) {
HXDLIN( 482)										int location5;
HXDLIN( 482)										if (this1->useVirtualPos) {
HXDLIN( 482)											location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            										}
            										else {
HXDLIN( 482)											location5 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            										}
HXDLIN( 482)										int this90 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 482)										int this91;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											this91 = this90;
            										}
HXDLIN( 482)										Float a110;
HXDLIN( 482)										int this92 = ((this91 >> 24) & 255);
HXDLIN( 482)										if ((this92 == 0)) {
HXDLIN( 482)											a110 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a110 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r15;
HXDLIN( 482)										int this93 = ((this91 >> 16) & 255);
HXDLIN( 482)										if ((this93 == 0)) {
HXDLIN( 482)											r15 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r15 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g15;
HXDLIN( 482)										int this94 = ((this91 >> 8) & 255);
HXDLIN( 482)										if ((this94 == 0)) {
HXDLIN( 482)											g15 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g15 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b111;
HXDLIN( 482)										int this95 = (this91 & 255);
HXDLIN( 482)										if ((this95 == 0)) {
HXDLIN( 482)											b111 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b111 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a25;
HXDLIN( 482)										int this96 = ((color >> 24) & 255);
HXDLIN( 482)										if ((this96 == 0)) {
HXDLIN( 482)											a25 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a25 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r25;
HXDLIN( 482)										int this97 = ((color >> 16) & 255);
HXDLIN( 482)										if ((this97 == 0)) {
HXDLIN( 482)											r25 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r25 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g25;
HXDLIN( 482)										int this98 = ((color >> 8) & 255);
HXDLIN( 482)										if ((this98 == 0)) {
HXDLIN( 482)											g25 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g25 = (( (Float)(this98) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b27;
HXDLIN( 482)										int this99 = (color & 255);
HXDLIN( 482)										if ((this99 == 0)) {
HXDLIN( 482)											b27 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b27 = (( (Float)(this99) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 482)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 482)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 482)										int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b27 * a25))));
HXDLIN( 482)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 482)										int blended5 = ((((a20 << 24) | (r7 << 16)) | (g7 << 8)) | b28);
HXDLIN( 482)										{
HXDLIN( 482)											int _hx_tmp22;
HXDLIN( 482)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)												_hx_tmp22 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXDLIN( 482)												_hx_tmp22 = blended5;
            											}
HXDLIN( 482)											::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp22);
            										}
            									}
            									else {
HXDLIN( 482)										::Dynamic this100 = this1->image;
HXDLIN( 482)										int index14;
HXDLIN( 482)										if (this1->useVirtualPos) {
HXDLIN( 482)											index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            										}
            										else {
HXDLIN( 482)											index14 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            										}
HXDLIN( 482)										int _hx_tmp23;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											_hx_tmp23 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											_hx_tmp23 = c15;
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this100,index14,_hx_tmp23);
            									}
            								}
HXLINE(  73)								found2 = true;
            							}
            							else {
HXDLIN( 482)								if (found2) {
HXDLIN( 482)									goto _hx_goto_896;
            								}
            							}
            						}
            					}
            					_hx_goto_896:;
            				}
            			}
            		}
HXDLIN( 482)		 ::pi_xy::algo::HitTri hitTriTop;
HXDLIN( 482)		if ((hasHit == true)) {
HXDLIN( 482)			 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx6,by6,cx6,cy6,true);
HXDLIN( 482)			if (hasUndo2) {
HXDLIN( 482)				v7->undoImage = undoImage6;
HXDLIN( 482)				v7->undoX = xIter32->start;
HXDLIN( 482)				v7->undoY = yIter32->start;
            			}
HXDLIN( 482)			hitTriTop = v7;
            		}
            		else {
HXDLIN( 482)			hitTriTop = null();
            		}
HXDLIN( 482)		Float bx7 = ax3;
HXDLIN( 482)		Float by7 = ay3;
HXDLIN( 482)		Float cx7 = dx3;
HXDLIN( 482)		Float cy7 = dy3;
HXDLIN( 482)		bool hasUndo3 = false;
HXDLIN( 482)		bool adjustWinding5 = (((((px * by7) - (bx7 * py)) + ((bx7 * cy7) - (cx7 * by7))) + ((cx7 * py) - (px * cy7))) > 0);
HXDLIN( 482)		if (!(adjustWinding5)) {
HXDLIN( 482)			Float bx_5 = bx7;
HXDLIN( 482)			Float by_5 = by7;
HXLINE(  25)			bx7 = cx7;
HXLINE(  26)			by7 = cy7;
HXLINE(  27)			cx7 = bx_5;
HXLINE(  28)			cy7 = by_5;
            		}
HXLINE( 482)		Float s03 = ((py * cx7) - (px * cy7));
HXDLIN( 482)		Float sx3 = (cy7 - py);
HXDLIN( 482)		Float sy3 = (px - cx7);
HXDLIN( 482)		Float t03 = ((px * by7) - (py * bx7));
HXDLIN( 482)		Float tx3 = (py - by7);
HXDLIN( 482)		Float ty3 = (bx7 - px);
HXDLIN( 482)		Float A3 = ((((-(by7) * cx7) + (py * (-(bx7) + cx7))) + (px * (by7 - cy7))) + (bx7 * cy7));
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 482)		if ((px > bx7)) {
HXDLIN( 482)			if ((px > cx7)) {
HXDLIN( 482)				int min20;
HXDLIN( 482)				if ((bx7 > cx7)) {
HXDLIN( 482)					min20 = ::Math_obj::floor(cx7);
            				}
            				else {
HXDLIN( 482)					min20 = ::Math_obj::floor(bx7);
            				}
HXDLIN( 482)				int ii_min40 = min20;
HXDLIN( 482)				int ii_max40 = ::Math_obj::ceil(px);
HXDLIN( 482)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            			}
            			else {
HXDLIN( 482)				int ii_min41 = ::Math_obj::floor(bx7);
HXDLIN( 482)				int ii_max41 = ::Math_obj::ceil(cx7);
HXDLIN( 482)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            			}
            		}
            		else {
HXDLIN( 482)			if ((bx7 > cx7)) {
HXDLIN( 482)				int min21;
HXDLIN( 482)				if ((px > cx7)) {
HXDLIN( 482)					min21 = ::Math_obj::floor(cx7);
            				}
            				else {
HXDLIN( 482)					min21 = ::Math_obj::ceil(px);
            				}
HXDLIN( 482)				int ii_min42 = min21;
HXDLIN( 482)				int ii_max42 = ::Math_obj::ceil(bx7);
HXDLIN( 482)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            			}
            			else {
HXDLIN( 482)				int ii_min43 = ::Math_obj::floor(px);
HXDLIN( 482)				int ii_max43 = ::Math_obj::ceil(cx7);
HXDLIN( 482)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            			}
            		}
HXDLIN( 482)		 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 482)		if ((py > by7)) {
HXDLIN( 482)			if ((py > cy7)) {
HXDLIN( 482)				int min22;
HXDLIN( 482)				if ((by7 > cy7)) {
HXDLIN( 482)					min22 = ::Math_obj::floor(cy7);
            				}
            				else {
HXDLIN( 482)					min22 = ::Math_obj::floor(by7);
            				}
HXDLIN( 482)				int ii_min44 = min22;
HXDLIN( 482)				int ii_max44 = ::Math_obj::ceil(py);
HXDLIN( 482)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            			}
            			else {
HXDLIN( 482)				int ii_min45 = ::Math_obj::floor(by7);
HXDLIN( 482)				int ii_max45 = ::Math_obj::ceil(cy7);
HXDLIN( 482)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            			}
            		}
            		else {
HXDLIN( 482)			if ((by7 > cy7)) {
HXDLIN( 482)				int min23;
HXDLIN( 482)				if ((py > cy7)) {
HXDLIN( 482)					min23 = ::Math_obj::floor(cy7);
            				}
            				else {
HXDLIN( 482)					min23 = ::Math_obj::ceil(py);
            				}
HXDLIN( 482)				int ii_min46 = min23;
HXDLIN( 482)				int ii_max46 = ::Math_obj::ceil(by7);
HXDLIN( 482)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            			}
            			else {
HXDLIN( 482)				int ii_min47 = ::Math_obj::floor(py);
HXDLIN( 482)				int ii_max47 = ::Math_obj::ceil(cy7);
HXDLIN( 482)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            			}
            		}
HXDLIN( 482)		 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 482)		if (hasUndo3) {
HXDLIN( 482)			int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 482)			int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 482)			 ::Dynamic imageType3 = null();
HXDLIN( 482)			 ::pi_xy::ImageStruct this101 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 482)			if (::hx::IsNull( imageType3 )) {
HXLINE(  54)				imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 482)			::Dynamic undoImage10;
HXDLIN( 482)			switch((int)(( (int)(imageType3) ))){
            				case (int)0: {
HXDLIN( 482)					 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::BytesImg b29 = byt3;
HXDLIN( 482)					{
HXDLIN( 482)						b29->width = width3;
HXDLIN( 482)						b29->height = height3;
HXDLIN( 482)						b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 482)						b29->data = ::haxe::io::Bytes_obj::alloc((b29->length * 4));
HXDLIN( 482)						{
HXDLIN( 482)							int len6 = b29->length;
HXDLIN( 482)							int w3 = 0;
HXDLIN( 482)							{
HXDLIN( 482)								int _g60 = 0;
HXDLIN( 482)								int _g61 = b29->height;
HXDLIN( 482)								while((_g60 < _g61)){
HXDLIN( 482)									_g60 = (_g60 + 1);
HXDLIN( 482)									int y12 = (_g60 - 1);
HXDLIN( 482)									{
HXDLIN( 482)										int _g62 = 0;
HXDLIN( 482)										int _g63 = b29->width;
HXDLIN( 482)										while((_g62 < _g63)){
HXDLIN( 482)											_g62 = (_g62 + 1);
HXDLIN( 482)											int x12 = (_g62 - 1);
HXDLIN( 482)											{
HXDLIN( 482)												w3 = (w3 + 1);
HXDLIN( 482)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w3 = (w3 + 1);
HXDLIN( 482)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w3 = (w3 + 1);
HXDLIN( 482)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 482)											{
HXDLIN( 482)												w3 = (w3 + 1);
HXDLIN( 482)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage10 = b29;
            				}
            				break;
            				case (int)1: {
HXDLIN( 482)					 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::ArrIntImg a26 = arrI3;
HXDLIN( 482)					{
HXDLIN( 482)						a26->width = width3;
HXDLIN( 482)						a26->height = height3;
HXDLIN( 482)						a26->data = ::Array_obj< int >::__new(0);
HXDLIN( 482)						a26->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 482)						{
HXDLIN( 482)							int _g64 = 0;
HXDLIN( 482)							int _g65 = a26->length;
HXDLIN( 482)							while((_g64 < _g65)){
HXDLIN( 482)								_g64 = (_g64 + 1);
HXDLIN( 482)								int i18 = (_g64 - 1);
HXDLIN( 482)								a26->data[i18] = 0;
            							}
            						}
            					}
HXDLIN( 482)					undoImage10 = a26;
            				}
            				break;
            				case (int)2: {
HXDLIN( 482)					 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::U32ArrImg b30 = u32a3;
HXDLIN( 482)					{
HXDLIN( 482)						b30->width = width3;
HXDLIN( 482)						b30->height = height3;
HXDLIN( 482)						b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 482)						int size3 = (b30->length * 4);
HXDLIN( 482)						b30->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 482)						{
HXDLIN( 482)							int _g66 = 0;
HXDLIN( 482)							int _g67 = b30->length;
HXDLIN( 482)							while((_g66 < _g67)){
HXDLIN( 482)								_g66 = (_g66 + 1);
HXDLIN( 482)								int i19 = (_g66 - 1);
HXDLIN( 482)								{
HXDLIN( 482)									 ::haxe::io::ArrayBufferViewImpl this102 = b30->data;
HXDLIN( 482)									bool undoImage11;
HXDLIN( 482)									if ((i19 >= 0)) {
HXDLIN( 482)										undoImage11 = (i19 < (this102->byteLength >> 2));
            									}
            									else {
HXDLIN( 482)										undoImage11 = false;
            									}
HXDLIN( 482)									if (undoImage11) {
HXDLIN( 482)										 ::haxe::io::Bytes _this3 = this102->bytes;
HXDLIN( 482)										int pos3 = ((i19 << 2) + this102->byteOffset);
HXDLIN( 482)										_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 482)										_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 482)										_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 482)										_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage10 = b30;
            				}
            				break;
            				case (int)3: {
HXDLIN( 482)					 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::VecIntImg v8 = vec3;
HXDLIN( 482)					{
HXDLIN( 482)						v8->width = width3;
HXDLIN( 482)						v8->height = height3;
HXDLIN( 482)						v8->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 482)						v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN( 482)						{
HXDLIN( 482)							int _g68 = 0;
HXDLIN( 482)							int _g69 = v8->length;
HXDLIN( 482)							while((_g68 < _g69)){
HXDLIN( 482)								_g68 = (_g68 + 1);
HXDLIN( 482)								int i20 = (_g68 - 1);
HXDLIN( 482)								v8->data->__unsafe_set(i20,0);
            							}
            						}
            					}
HXDLIN( 482)					undoImage10 = v8;
            				}
            				break;
            				case (int)4: {
HXDLIN( 482)					 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 482)					 ::iterMagic::StackIntImg b31 = sInt3;
HXDLIN( 482)					{
HXDLIN( 482)						b31->width = width3;
HXDLIN( 482)						b31->height = height3;
HXDLIN( 482)						b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 482)						b31->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 482)						{
HXDLIN( 482)							int len7 = b31->length;
HXDLIN( 482)							 ::haxe::ds::GenericStack_Int d3 = b31->data;
HXDLIN( 482)							if (::hx::IsNull( d3->head )) {
HXDLIN( 482)								int _g70 = 0;
HXDLIN( 482)								int _g71 = len7;
HXDLIN( 482)								while((_g70 < _g71)){
HXDLIN( 482)									_g70 = (_g70 + 1);
HXDLIN( 482)									int i21 = (_g70 - 1);
HXDLIN( 482)									d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            								}
            							}
            							else {
HXDLIN( 482)								int _g72 = 0;
HXDLIN( 482)								int _g73 = len7;
HXDLIN( 482)								while((_g72 < _g73)){
HXDLIN( 482)									_g72 = (_g72 + 1);
HXDLIN( 482)									int i22 = (_g72 - 1);
HXDLIN( 482)									{
HXDLIN( 482)										 ::haxe::ds::GenericCell_Int l3 = b31->data->head;
HXDLIN( 482)										 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 482)										{
HXDLIN( 482)											int _g74 = 0;
HXDLIN( 482)											int _g75 = i22;
HXDLIN( 482)											while((_g74 < _g75)){
HXDLIN( 482)												_g74 = (_g74 + 1);
HXDLIN( 482)												int i23 = (_g74 - 1);
HXLINE( 345)												prev3 = l3;
HXLINE( 346)												l3 = l3->next;
            											}
            										}
HXLINE( 482)										if (::hx::IsNull( prev3 )) {
HXDLIN( 482)											b31->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 482)											l3 = null();
            										}
            										else {
HXDLIN( 482)											prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 482)											l3 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 482)					undoImage10 = b31;
            				}
            				break;
            			}
HXDLIN( 482)			this101->image = undoImage10;
HXDLIN( 482)			this101->width = width3;
HXDLIN( 482)			this101->height = height3;
HXDLIN( 482)			this101->imageType = ( (int)(imageType3) );
HXDLIN( 482)			undoImage9 = this101;
HXDLIN( 482)			{
HXDLIN( 482)				int rectLeft3 = xIter33->start;
HXDLIN( 482)				int rectTop3 = yIter33->start;
HXDLIN( 482)				int rectRight3 = xIter33->max;
HXDLIN( 482)				bool forceClear3 = false;
HXDLIN( 482)				{
HXDLIN( 482)					int _g76 = rectTop3;
HXDLIN( 482)					int _g77 = yIter33->max;
HXDLIN( 482)					while((_g76 < _g77)){
HXDLIN( 482)						_g76 = (_g76 + 1);
HXDLIN( 482)						int dy5 = (_g76 - 1);
HXDLIN( 482)						{
HXDLIN( 482)							int _g78 = rectLeft3;
HXDLIN( 482)							int _g79 = rectRight3;
HXDLIN( 482)							while((_g78 < _g79)){
HXDLIN( 482)								_g78 = (_g78 + 1);
HXDLIN( 482)								int dx5 = (_g78 - 1);
HXDLIN( 482)								::Dynamic this103 = this1->image;
HXDLIN( 482)								int index15;
HXDLIN( 482)								if (this1->useVirtualPos) {
HXDLIN( 482)									index15 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx5) - this1->virtualX));
            								}
            								else {
HXDLIN( 482)									index15 = ::Std_obj::_hx_int(( (Float)(((dy5 * this1->width) + dx5)) ));
            								}
HXDLIN( 482)								int c16 = ::iterMagic::Iimg_obj::get(this103,index15);
HXDLIN( 482)								int col3;
HXDLIN( 482)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)									col3 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            								}
            								else {
HXDLIN( 482)									col3 = c16;
            								}
HXDLIN( 482)								bool _hx_tmp24;
HXDLIN( 482)								if (this1->useMask) {
HXDLIN( 482)									_hx_tmp24 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 482)									_hx_tmp24 = false;
            								}
HXDLIN( 482)								if (_hx_tmp24) {
HXDLIN( 482)									 ::pi_xy::ImageStruct this104 = this1->mask;
HXDLIN( 482)									::Dynamic this105 = this104->image;
HXDLIN( 482)									int index16;
HXDLIN( 482)									if (this104->useVirtualPos) {
HXDLIN( 482)										index16 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this104->virtualY) * ( (Float)(this104->width) )) + dx5) - this104->virtualX));
            									}
            									else {
HXDLIN( 482)										index16 = ::Std_obj::_hx_int(( (Float)(((dy5 * this104->width) + dx5)) ));
            									}
HXDLIN( 482)									int c17 = ::iterMagic::Iimg_obj::get(this105,index16);
HXDLIN( 482)									int v9;
HXDLIN( 482)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)										v9 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            									}
            									else {
HXDLIN( 482)										v9 = c17;
            									}
HXDLIN( 482)									int maskPixel3 = v9;
HXDLIN( 482)									int this106 = col3;
HXDLIN( 482)									if ((maskPixel3 == 0)) {
HXDLIN( 482)										col3 = this106;
            									}
            									else {
HXDLIN( 482)										Float m03;
HXDLIN( 482)										int this107 = ((maskPixel3 >> 24) & 255);
HXDLIN( 482)										if ((this107 == 0)) {
HXDLIN( 482)											m03 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m03 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m13;
HXDLIN( 482)										int this108 = ((maskPixel3 >> 16) & 255);
HXDLIN( 482)										if ((this108 == 0)) {
HXDLIN( 482)											m13 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m13 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m23;
HXDLIN( 482)										int this109 = ((maskPixel3 >> 8) & 255);
HXDLIN( 482)										if ((this109 == 0)) {
HXDLIN( 482)											m23 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m23 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float m33;
HXDLIN( 482)										int this110 = (maskPixel3 & 255);
HXDLIN( 482)										if ((this110 == 0)) {
HXDLIN( 482)											m33 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											m33 = (( (Float)(this110) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this106 >> 24) & 255)) )));
HXDLIN( 482)										int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this106 >> 16) & 255)) )));
HXDLIN( 482)										int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this106 >> 8) & 255)) )));
HXDLIN( 482)										int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this106 & 255)) )));
HXDLIN( 482)										col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 482)								if ((col3 != 0)) {
HXDLIN( 482)									int x13 = (dx5 - rectLeft3);
HXDLIN( 482)									int y13 = (dy5 - rectTop3);
HXDLIN( 482)									int c18 = col3;
HXDLIN( 482)									bool _hx_tmp25;
HXDLIN( 482)									if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 482)										_hx_tmp25 = undoImage9->transparent;
            									}
            									else {
HXDLIN( 482)										_hx_tmp25 = false;
            									}
HXDLIN( 482)									if (_hx_tmp25) {
HXDLIN( 482)										int location6;
HXDLIN( 482)										if (undoImage9->useVirtualPos) {
HXDLIN( 482)											location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 482)											location6 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            										}
HXDLIN( 482)										int this111 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 482)										int this112;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											this112 = ((((((this111 >> 24) & 255) << 24) | ((this111 & 255) << 16)) | (((this111 >> 8) & 255) << 8)) | ((this111 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											this112 = this111;
            										}
HXDLIN( 482)										Float a111;
HXDLIN( 482)										int this113 = ((this112 >> 24) & 255);
HXDLIN( 482)										if ((this113 == 0)) {
HXDLIN( 482)											a111 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a111 = (( (Float)(this113) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r16;
HXDLIN( 482)										int this114 = ((this112 >> 16) & 255);
HXDLIN( 482)										if ((this114 == 0)) {
HXDLIN( 482)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r16 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g16;
HXDLIN( 482)										int this115 = ((this112 >> 8) & 255);
HXDLIN( 482)										if ((this115 == 0)) {
HXDLIN( 482)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g16 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b112;
HXDLIN( 482)										int this116 = (this112 & 255);
HXDLIN( 482)										if ((this116 == 0)) {
HXDLIN( 482)											b112 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b112 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a27;
HXDLIN( 482)										int this117 = ((col3 >> 24) & 255);
HXDLIN( 482)										if ((this117 == 0)) {
HXDLIN( 482)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a27 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r26;
HXDLIN( 482)										int this118 = ((col3 >> 16) & 255);
HXDLIN( 482)										if ((this118 == 0)) {
HXDLIN( 482)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r26 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g26;
HXDLIN( 482)										int this119 = ((col3 >> 8) & 255);
HXDLIN( 482)										if ((this119 == 0)) {
HXDLIN( 482)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g26 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b210;
HXDLIN( 482)										int this120 = (col3 & 255);
HXDLIN( 482)										if ((this120 == 0)) {
HXDLIN( 482)											b210 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b210 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a36 = (a111 * (( (Float)(1) ) - a27));
HXDLIN( 482)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a27))));
HXDLIN( 482)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a27))));
HXDLIN( 482)										int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a27))));
HXDLIN( 482)										int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a27)));
HXDLIN( 482)										int blended6 = ((((a28 << 24) | (r8 << 16)) | (g8 << 8)) | b32);
HXDLIN( 482)										{
HXDLIN( 482)											int _hx_tmp26;
HXDLIN( 482)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)												_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 482)												_hx_tmp26 = blended6;
            											}
HXDLIN( 482)											::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            										}
            									}
            									else {
HXDLIN( 482)										::Dynamic this121 = undoImage9->image;
HXDLIN( 482)										int index17;
HXDLIN( 482)										if (undoImage9->useVirtualPos) {
HXDLIN( 482)											index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 482)											index17 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            										}
HXDLIN( 482)										int _hx_tmp27;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											_hx_tmp27 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											_hx_tmp27 = c18;
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this121,index17,_hx_tmp27);
            									}
            								}
            								else {
HXDLIN( 482)									if (forceClear3) {
HXDLIN( 482)										::Dynamic this122 = undoImage9->image;
HXDLIN( 482)										int x14 = (dx5 - rectLeft3);
HXDLIN( 482)										int y14 = (dy5 - rectTop3);
HXDLIN( 482)										int index18;
HXDLIN( 482)										if (undoImage9->useVirtualPos) {
HXDLIN( 482)											index18 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 482)											index18 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this122,index18,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 482)		bool found3 = false;
HXDLIN( 482)		Float s3 = ((Float)0.);
HXDLIN( 482)		Float t3 = ((Float)0.);
HXDLIN( 482)		Float sxx3 = ((Float)0.);
HXDLIN( 482)		Float txx3 = ((Float)0.);
HXDLIN( 482)		{
HXDLIN( 482)			int _g_min6 = xIter33->start;
HXDLIN( 482)			int _g_max6 = xIter33->max;
HXDLIN( 482)			while((_g_min6 < _g_max6)){
HXDLIN( 482)				_g_min6 = (_g_min6 + 1);
HXDLIN( 482)				int x15 = (_g_min6 - 1);
HXLINE(  60)				sxx3 = (sx3 * ( (Float)(x15) ));
HXLINE(  61)				txx3 = (tx3 * ( (Float)(x15) ));
HXLINE(  62)				found3 = false;
HXLINE( 482)				{
HXDLIN( 482)					int _g_min7 = yIter33->start;
HXDLIN( 482)					int _g_max7 = yIter33->max;
HXDLIN( 482)					while((_g_min7 < _g_max7)){
HXDLIN( 482)						_g_min7 = (_g_min7 + 1);
HXDLIN( 482)						int y15 = (_g_min7 - 1);
HXLINE(  64)						s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y15) )));
HXLINE(  65)						t3 = ((t03 + txx3) + (ty3 * ( (Float)(y15) )));
HXLINE( 482)						bool _hx_tmp28;
HXDLIN( 482)						if (!((s3 <= 0))) {
HXDLIN( 482)							_hx_tmp28 = (t3 <= 0);
            						}
            						else {
HXDLIN( 482)							_hx_tmp28 = true;
            						}
HXDLIN( 482)						if (_hx_tmp28) {
HXDLIN( 482)							if (found3) {
HXDLIN( 482)								goto _hx_goto_908;
            							}
            						}
            						else {
HXDLIN( 482)							if (((s3 + t3) < A3)) {
HXDLIN( 482)								{
HXDLIN( 482)									int c19 = color;
HXDLIN( 482)									bool _hx_tmp29;
HXDLIN( 482)									if ((((c19 >> 24) & 255) < 254)) {
HXDLIN( 482)										_hx_tmp29 = this1->transparent;
            									}
            									else {
HXDLIN( 482)										_hx_tmp29 = false;
            									}
HXDLIN( 482)									if (_hx_tmp29) {
HXDLIN( 482)										int location7;
HXDLIN( 482)										if (this1->useVirtualPos) {
HXDLIN( 482)											location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            										}
            										else {
HXDLIN( 482)											location7 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            										}
HXDLIN( 482)										int this123 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN( 482)										int this124;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											this124 = ((((((this123 >> 24) & 255) << 24) | ((this123 & 255) << 16)) | (((this123 >> 8) & 255) << 8)) | ((this123 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											this124 = this123;
            										}
HXDLIN( 482)										Float a112;
HXDLIN( 482)										int this125 = ((this124 >> 24) & 255);
HXDLIN( 482)										if ((this125 == 0)) {
HXDLIN( 482)											a112 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a112 = (( (Float)(this125) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r17;
HXDLIN( 482)										int this126 = ((this124 >> 16) & 255);
HXDLIN( 482)										if ((this126 == 0)) {
HXDLIN( 482)											r17 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r17 = (( (Float)(this126) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g17;
HXDLIN( 482)										int this127 = ((this124 >> 8) & 255);
HXDLIN( 482)										if ((this127 == 0)) {
HXDLIN( 482)											g17 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g17 = (( (Float)(this127) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b113;
HXDLIN( 482)										int this128 = (this124 & 255);
HXDLIN( 482)										if ((this128 == 0)) {
HXDLIN( 482)											b113 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b113 = (( (Float)(this128) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a29;
HXDLIN( 482)										int this129 = ((color >> 24) & 255);
HXDLIN( 482)										if ((this129 == 0)) {
HXDLIN( 482)											a29 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											a29 = (( (Float)(this129) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float r27;
HXDLIN( 482)										int this130 = ((color >> 16) & 255);
HXDLIN( 482)										if ((this130 == 0)) {
HXDLIN( 482)											r27 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											r27 = (( (Float)(this130) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float g27;
HXDLIN( 482)										int this131 = ((color >> 8) & 255);
HXDLIN( 482)										if ((this131 == 0)) {
HXDLIN( 482)											g27 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											g27 = (( (Float)(this131) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float b211;
HXDLIN( 482)										int this132 = (color & 255);
HXDLIN( 482)										if ((this132 == 0)) {
HXDLIN( 482)											b211 = ((Float)0.);
            										}
            										else {
HXDLIN( 482)											b211 = (( (Float)(this132) ) / ( (Float)(255) ));
            										}
HXDLIN( 482)										Float a37 = (a112 * (( (Float)(1) ) - a29));
HXDLIN( 482)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a29))));
HXDLIN( 482)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a29))));
HXDLIN( 482)										int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a29))));
HXDLIN( 482)										int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a29)));
HXDLIN( 482)										int blended7 = ((((a30 << 24) | (r9 << 16)) | (g9 << 8)) | b33);
HXDLIN( 482)										{
HXDLIN( 482)											int _hx_tmp30;
HXDLIN( 482)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)												_hx_tmp30 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXDLIN( 482)												_hx_tmp30 = blended7;
            											}
HXDLIN( 482)											::iterMagic::Iimg_obj::set(this1->image,location7,_hx_tmp30);
            										}
            									}
            									else {
HXDLIN( 482)										::Dynamic this133 = this1->image;
HXDLIN( 482)										int index19;
HXDLIN( 482)										if (this1->useVirtualPos) {
HXDLIN( 482)											index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            										}
            										else {
HXDLIN( 482)											index19 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            										}
HXDLIN( 482)										int _hx_tmp31;
HXDLIN( 482)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 482)											_hx_tmp31 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            										}
            										else {
HXDLIN( 482)											_hx_tmp31 = c19;
            										}
HXDLIN( 482)										::iterMagic::Iimg_obj::set(this133,index19,_hx_tmp31);
            									}
            								}
HXLINE(  73)								found3 = true;
            							}
            							else {
HXDLIN( 482)								if (found3) {
HXDLIN( 482)									goto _hx_goto_908;
            								}
            							}
            						}
            					}
            					_hx_goto_908:;
            				}
            			}
            		}
HXDLIN( 482)		 ::pi_xy::algo::HitTri hitTriBottom;
HXDLIN( 482)		if ((hasHit == true)) {
HXDLIN( 482)			 ::pi_xy::algo::HitTri v10 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx7,by7,cx7,cy7,true);
HXDLIN( 482)			if (hasUndo3) {
HXDLIN( 482)				v10->undoImage = undoImage9;
HXDLIN( 482)				v10->undoX = xIter33->start;
HXDLIN( 482)				v10->undoY = yIter33->start;
            			}
HXDLIN( 482)			hitTriBottom = v10;
            		}
            		else {
HXDLIN( 482)			hitTriBottom = null();
            		}
HXDLIN( 482)		if (hasHit) {
HXDLIN( 482)			 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN( 482)			if (::hx::IsNotNull( hitQuad )) {
HXDLIN( 482)				hitArr->triArr->push(hitQuad->triABD);
            			}
HXDLIN( 482)			hitArr->triArr->push(hitQuad->triBCD);
HXDLIN( 482)			return hitArr;
            		}
            		else {
HXDLIN( 482)			return null();
            		}
HXDLIN( 482)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(FillShape_Impl__obj,arrowBoth,return )

 ::pi_xy::algo::HitTriArray FillShape_Impl__obj::fixArrow( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float arrowWidth,Float arrowHeight,Float thick,int color,::hx::Null< bool >  __o_flare,::hx::Null< bool >  __o_reverseFlare,::hx::Null< bool >  __o_hasHit){
            		bool flare = __o_flare.Default(false);
            		bool reverseFlare = __o_reverseFlare.Default(false);
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_497_fixArrow)
HXDLIN( 497)		Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 497)		::haxe::Log_obj::trace(HX_("fillLineFixedArrow",ac,e2,1f,71),::hx::SourceInfo(HX_("src/pi_xy/algo/ArrowPixel.hx",98,bf,a1,a5),373,HX_("pi_xy.algo._ArrowPixel.ArrowPixel_Fields_",4a,11,04,b2),HX_("fillLineFixedArrow",ac,e2,1f,71)));
HXDLIN( 497)		Float o = (qy - py);
HXDLIN( 497)		Float a = (qx - px);
HXDLIN( 497)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 497)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 497)		Float thicker;
HXDLIN( 497)		if ((arrowWidth > (thick * ((Float)1.1)))) {
HXDLIN( 497)			thicker = arrowWidth;
            		}
            		else {
HXDLIN( 497)			thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            		}
HXDLIN( 497)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 497)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 497)		Float radius = (thick / ( (Float)(2) ));
HXDLIN( 497)		Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 497)		Float h2;
HXDLIN( 497)		if ((arrowHeight < (h * ((Float)1.1)))) {
HXDLIN( 497)			h2 = (h - arrowHeight);
            		}
            		else {
HXDLIN( 497)			h2 = (h / goldenRatio);
            		}
HXDLIN( 497)		 ::pi_xy::algo::HitQuad hitQuad;
HXDLIN( 497)		if (flare) {
HXDLIN( 497)			if (reverseFlare) {
HXDLIN( 497)				Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 497)				Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 497)				Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 497)				Float radius21 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN( 497)				Float dx = ((Float)0.1);
HXDLIN( 497)				Float dy = radius1;
HXDLIN( 497)				Float cx = h2;
HXDLIN( 497)				Float cy = radius21;
HXDLIN( 497)				Float bx = h2;
HXDLIN( 497)				Float by = -(radius21);
HXDLIN( 497)				Float ax = ((Float)0.1);
HXDLIN( 497)				Float ay = -(radius1);
HXDLIN( 497)				Float temp = ((Float)0.);
HXLINE( 240)				temp = (px + ((ax * cos1) - (ay * sin1)));
HXLINE( 241)				ay = (py + ((ay * cos1) + (ax * sin1)));
HXLINE( 242)				ax = temp;
HXLINE( 244)				temp = (px + ((bx * cos1) - (by * sin1)));
HXLINE( 245)				by = (py + ((by * cos1) + (bx * sin1)));
HXLINE( 246)				bx = temp;
HXLINE( 248)				temp = (px + ((cx * cos1) - (cy * sin1)));
HXLINE( 249)				cy = (py + ((cy * cos1) + (cx * sin1)));
HXLINE( 250)				cx = temp;
HXLINE( 252)				temp = (px + ((dx * cos1) - (dy * sin1)));
HXLINE( 253)				dy = (py + ((dy * cos1) + (dx * sin1)));
HXLINE( 254)				dx = temp;
HXLINE( 497)				Float bx1 = bx;
HXDLIN( 497)				Float by1 = by;
HXDLIN( 497)				Float cx1 = dx;
HXDLIN( 497)				Float cy1 = dy;
HXDLIN( 497)				bool hasUndo = false;
HXDLIN( 497)				bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 497)				if (!(adjustWinding)) {
HXDLIN( 497)					Float bx_ = bx1;
HXDLIN( 497)					Float by_ = by1;
HXLINE(  25)					bx1 = cx1;
HXLINE(  26)					by1 = cy1;
HXLINE(  27)					cx1 = bx_;
HXLINE(  28)					cy1 = by_;
            				}
HXLINE( 497)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 497)				Float sx = (cy1 - ay);
HXDLIN( 497)				Float sy = (ax - cx1);
HXDLIN( 497)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 497)				Float tx = (ay - by1);
HXDLIN( 497)				Float ty = (bx1 - ax);
HXDLIN( 497)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 497)				if ((ax > bx1)) {
HXDLIN( 497)					if ((ax > cx1)) {
HXDLIN( 497)						int min;
HXDLIN( 497)						if ((bx1 > cx1)) {
HXDLIN( 497)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXDLIN( 497)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN( 497)						int ii_min = min;
HXDLIN( 497)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 497)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXDLIN( 497)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 497)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 497)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXDLIN( 497)					if ((bx1 > cx1)) {
HXDLIN( 497)						int min1;
HXDLIN( 497)						if ((ax > cx1)) {
HXDLIN( 497)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXDLIN( 497)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 497)						int ii_min2 = min1;
HXDLIN( 497)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 497)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXDLIN( 497)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 497)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 497)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 497)				if ((ay > by1)) {
HXDLIN( 497)					if ((ay > cy1)) {
HXDLIN( 497)						int min2;
HXDLIN( 497)						if ((by1 > cy1)) {
HXDLIN( 497)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXDLIN( 497)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN( 497)						int ii_min4 = min2;
HXDLIN( 497)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 497)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXDLIN( 497)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 497)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 497)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXDLIN( 497)					if ((by1 > cy1)) {
HXDLIN( 497)						int min3;
HXDLIN( 497)						if ((ay > cy1)) {
HXDLIN( 497)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXDLIN( 497)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 497)						int ii_min6 = min3;
HXDLIN( 497)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 497)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXDLIN( 497)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 497)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 497)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 497)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 497)				if (hasUndo) {
HXDLIN( 497)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 497)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 497)					 ::Dynamic imageType = null();
HXDLIN( 497)					 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 497)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 497)					::Dynamic undoImage1;
HXDLIN( 497)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXDLIN( 497)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 497)							{
HXDLIN( 497)								b->width = width;
HXDLIN( 497)								b->height = height;
HXDLIN( 497)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 497)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 497)								{
HXDLIN( 497)									int len = b->length;
HXDLIN( 497)									int w = 0;
HXDLIN( 497)									{
HXDLIN( 497)										int _g = 0;
HXDLIN( 497)										int _g1 = b->height;
HXDLIN( 497)										while((_g < _g1)){
HXDLIN( 497)											_g = (_g + 1);
HXDLIN( 497)											int y = (_g - 1);
HXDLIN( 497)											{
HXDLIN( 497)												int _g2 = 0;
HXDLIN( 497)												int _g3 = b->width;
HXDLIN( 497)												while((_g2 < _g3)){
HXDLIN( 497)													_g2 = (_g2 + 1);
HXDLIN( 497)													int x = (_g2 - 1);
HXDLIN( 497)													{
HXDLIN( 497)														w = (w + 1);
HXDLIN( 497)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w = (w + 1);
HXDLIN( 497)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w = (w + 1);
HXDLIN( 497)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w = (w + 1);
HXDLIN( 497)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXDLIN( 497)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 497)							{
HXDLIN( 497)								a1->width = width;
HXDLIN( 497)								a1->height = height;
HXDLIN( 497)								a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 497)								a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 497)								{
HXDLIN( 497)									int _g4 = 0;
HXDLIN( 497)									int _g5 = a1->length;
HXDLIN( 497)									while((_g4 < _g5)){
HXDLIN( 497)										_g4 = (_g4 + 1);
HXDLIN( 497)										int i = (_g4 - 1);
HXDLIN( 497)										a1->data[i] = 0;
            									}
            								}
            							}
HXDLIN( 497)							undoImage1 = a1;
            						}
            						break;
            						case (int)2: {
HXDLIN( 497)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 497)							{
HXDLIN( 497)								b1->width = width;
HXDLIN( 497)								b1->height = height;
HXDLIN( 497)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 497)								int size = (b1->length * 4);
HXDLIN( 497)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 497)								{
HXDLIN( 497)									int _g6 = 0;
HXDLIN( 497)									int _g7 = b1->length;
HXDLIN( 497)									while((_g6 < _g7)){
HXDLIN( 497)										_g6 = (_g6 + 1);
HXDLIN( 497)										int i1 = (_g6 - 1);
HXDLIN( 497)										{
HXDLIN( 497)											 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 497)											bool undoImage2;
HXDLIN( 497)											if ((i1 >= 0)) {
HXDLIN( 497)												undoImage2 = (i1 < (this3->byteLength >> 2));
            											}
            											else {
HXDLIN( 497)												undoImage2 = false;
            											}
HXDLIN( 497)											if (undoImage2) {
HXDLIN( 497)												 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 497)												int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 497)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 497)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 497)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 497)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXDLIN( 497)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 497)							{
HXDLIN( 497)								v->width = width;
HXDLIN( 497)								v->height = height;
HXDLIN( 497)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 497)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 497)								{
HXDLIN( 497)									int _g8 = 0;
HXDLIN( 497)									int _g9 = v->length;
HXDLIN( 497)									while((_g8 < _g9)){
HXDLIN( 497)										_g8 = (_g8 + 1);
HXDLIN( 497)										int i2 = (_g8 - 1);
HXDLIN( 497)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN( 497)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXDLIN( 497)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 497)							{
HXDLIN( 497)								b2->width = width;
HXDLIN( 497)								b2->height = height;
HXDLIN( 497)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 497)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 497)								{
HXDLIN( 497)									int len1 = b2->length;
HXDLIN( 497)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 497)									if (::hx::IsNull( d->head )) {
HXDLIN( 497)										int _g10 = 0;
HXDLIN( 497)										int _g11 = len1;
HXDLIN( 497)										while((_g10 < _g11)){
HXDLIN( 497)											_g10 = (_g10 + 1);
HXDLIN( 497)											int i3 = (_g10 - 1);
HXDLIN( 497)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXDLIN( 497)										int _g12 = 0;
HXDLIN( 497)										int _g13 = len1;
HXDLIN( 497)										while((_g12 < _g13)){
HXDLIN( 497)											_g12 = (_g12 + 1);
HXDLIN( 497)											int i4 = (_g12 - 1);
HXDLIN( 497)											{
HXDLIN( 497)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 497)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 497)												{
HXDLIN( 497)													int _g14 = 0;
HXDLIN( 497)													int _g15 = i4;
HXDLIN( 497)													while((_g14 < _g15)){
HXDLIN( 497)														_g14 = (_g14 + 1);
HXDLIN( 497)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 497)												if (::hx::IsNull( prev )) {
HXDLIN( 497)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 497)													l = null();
            												}
            												else {
HXDLIN( 497)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 497)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 497)					this2->image = undoImage1;
HXDLIN( 497)					this2->width = width;
HXDLIN( 497)					this2->height = height;
HXDLIN( 497)					this2->imageType = ( (int)(imageType) );
HXDLIN( 497)					undoImage = this2;
HXDLIN( 497)					{
HXDLIN( 497)						int rectLeft = xIter3->start;
HXDLIN( 497)						int rectTop = yIter3->start;
HXDLIN( 497)						int rectRight = xIter3->max;
HXDLIN( 497)						bool forceClear = false;
HXDLIN( 497)						{
HXDLIN( 497)							int _g16 = rectTop;
HXDLIN( 497)							int _g17 = yIter3->max;
HXDLIN( 497)							while((_g16 < _g17)){
HXDLIN( 497)								_g16 = (_g16 + 1);
HXDLIN( 497)								int dy1 = (_g16 - 1);
HXDLIN( 497)								{
HXDLIN( 497)									int _g18 = rectLeft;
HXDLIN( 497)									int _g19 = rectRight;
HXDLIN( 497)									while((_g18 < _g19)){
HXDLIN( 497)										_g18 = (_g18 + 1);
HXDLIN( 497)										int dx1 = (_g18 - 1);
HXDLIN( 497)										::Dynamic this4 = this1->image;
HXDLIN( 497)										int index;
HXDLIN( 497)										if (this1->useVirtualPos) {
HXDLIN( 497)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            										}
            										else {
HXDLIN( 497)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            										}
HXDLIN( 497)										int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 497)										int col;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											col = c;
            										}
HXDLIN( 497)										bool hitQuad1;
HXDLIN( 497)										if (this1->useMask) {
HXDLIN( 497)											hitQuad1 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 497)											hitQuad1 = false;
            										}
HXDLIN( 497)										if (hitQuad1) {
HXDLIN( 497)											 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 497)											::Dynamic this6 = this5->image;
HXDLIN( 497)											int index1;
HXDLIN( 497)											if (this5->useVirtualPos) {
HXDLIN( 497)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            											}
            											else {
HXDLIN( 497)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            											}
HXDLIN( 497)											int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 497)											int v1;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												v1 = c1;
            											}
HXDLIN( 497)											int maskPixel = v1;
HXDLIN( 497)											int this7 = col;
HXDLIN( 497)											if ((maskPixel == 0)) {
HXDLIN( 497)												col = this7;
            											}
            											else {
HXDLIN( 497)												Float m0;
HXDLIN( 497)												int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 497)												if ((this8 == 0)) {
HXDLIN( 497)													m0 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m1;
HXDLIN( 497)												int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 497)												if ((this9 == 0)) {
HXDLIN( 497)													m1 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m2;
HXDLIN( 497)												int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 497)												if ((this10 == 0)) {
HXDLIN( 497)													m2 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m3;
HXDLIN( 497)												int this11 = (maskPixel & 255);
HXDLIN( 497)												if ((this11 == 0)) {
HXDLIN( 497)													m3 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 497)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 497)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 497)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 497)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 497)										if ((col != 0)) {
HXDLIN( 497)											int x1 = (dx1 - rectLeft);
HXDLIN( 497)											int y1 = (dy1 - rectTop);
HXDLIN( 497)											int c2 = col;
HXDLIN( 497)											bool hitQuad2;
HXDLIN( 497)											if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 497)												hitQuad2 = undoImage->transparent;
            											}
            											else {
HXDLIN( 497)												hitQuad2 = false;
            											}
HXDLIN( 497)											if (hitQuad2) {
HXDLIN( 497)												int location;
HXDLIN( 497)												if (undoImage->useVirtualPos) {
HXDLIN( 497)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXDLIN( 497)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 497)												int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 497)												int this13;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													this13 = this12;
            												}
HXDLIN( 497)												Float a11;
HXDLIN( 497)												int this14 = ((this13 >> 24) & 255);
HXDLIN( 497)												if ((this14 == 0)) {
HXDLIN( 497)													a11 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r1;
HXDLIN( 497)												int this15 = ((this13 >> 16) & 255);
HXDLIN( 497)												if ((this15 == 0)) {
HXDLIN( 497)													r1 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g1;
HXDLIN( 497)												int this16 = ((this13 >> 8) & 255);
HXDLIN( 497)												if ((this16 == 0)) {
HXDLIN( 497)													g1 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b11;
HXDLIN( 497)												int this17 = (this13 & 255);
HXDLIN( 497)												if ((this17 == 0)) {
HXDLIN( 497)													b11 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a2;
HXDLIN( 497)												int this18 = ((col >> 24) & 255);
HXDLIN( 497)												if ((this18 == 0)) {
HXDLIN( 497)													a2 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r2;
HXDLIN( 497)												int this19 = ((col >> 16) & 255);
HXDLIN( 497)												if ((this19 == 0)) {
HXDLIN( 497)													r2 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g2;
HXDLIN( 497)												int this20 = ((col >> 8) & 255);
HXDLIN( 497)												if ((this20 == 0)) {
HXDLIN( 497)													g2 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b21;
HXDLIN( 497)												int this21 = (col & 255);
HXDLIN( 497)												if ((this21 == 0)) {
HXDLIN( 497)													b21 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 497)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 497)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 497)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 497)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 497)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 497)												{
HXDLIN( 497)													int hitQuad3;
HXDLIN( 497)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)														hitQuad3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXDLIN( 497)														hitQuad3 = blended;
            													}
HXDLIN( 497)													::iterMagic::Iimg_obj::set(undoImage->image,location,hitQuad3);
            												}
            											}
            											else {
HXDLIN( 497)												::Dynamic this22 = undoImage->image;
HXDLIN( 497)												int index2;
HXDLIN( 497)												if (undoImage->useVirtualPos) {
HXDLIN( 497)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXDLIN( 497)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 497)												int hitQuad4;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad4 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad4 = c2;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this22,index2,hitQuad4);
            											}
            										}
            										else {
HXDLIN( 497)											if (forceClear) {
HXDLIN( 497)												::Dynamic this23 = undoImage->image;
HXDLIN( 497)												int x2 = (dx1 - rectLeft);
HXDLIN( 497)												int y2 = (dy1 - rectTop);
HXDLIN( 497)												int index3;
HXDLIN( 497)												if (undoImage->useVirtualPos) {
HXDLIN( 497)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXDLIN( 497)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this23,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 497)				bool found = false;
HXDLIN( 497)				Float s = ((Float)0.);
HXDLIN( 497)				Float t = ((Float)0.);
HXDLIN( 497)				Float sxx = ((Float)0.);
HXDLIN( 497)				Float txx = ((Float)0.);
HXDLIN( 497)				{
HXDLIN( 497)					int _g_min = xIter3->start;
HXDLIN( 497)					int _g_max = xIter3->max;
HXDLIN( 497)					while((_g_min < _g_max)){
HXDLIN( 497)						_g_min = (_g_min + 1);
HXDLIN( 497)						int x3 = (_g_min - 1);
HXLINE(  60)						sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)						txx = (tx * ( (Float)(x3) ));
HXLINE(  62)						found = false;
HXLINE( 497)						{
HXDLIN( 497)							int _g_min1 = yIter3->start;
HXDLIN( 497)							int _g_max1 = yIter3->max;
HXDLIN( 497)							while((_g_min1 < _g_max1)){
HXDLIN( 497)								_g_min1 = (_g_min1 + 1);
HXDLIN( 497)								int y3 = (_g_min1 - 1);
HXLINE(  64)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 497)								bool hitQuad5;
HXDLIN( 497)								if (!((s <= 0))) {
HXDLIN( 497)									hitQuad5 = (t <= 0);
            								}
            								else {
HXDLIN( 497)									hitQuad5 = true;
            								}
HXDLIN( 497)								if (hitQuad5) {
HXDLIN( 497)									if (found) {
HXDLIN( 497)										goto _hx_goto_921;
            									}
            								}
            								else {
HXDLIN( 497)									if (((s + t) < A)) {
HXDLIN( 497)										{
HXDLIN( 497)											int c3 = color;
HXDLIN( 497)											bool hitQuad6;
HXDLIN( 497)											if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 497)												hitQuad6 = this1->transparent;
            											}
            											else {
HXDLIN( 497)												hitQuad6 = false;
            											}
HXDLIN( 497)											if (hitQuad6) {
HXDLIN( 497)												int location1;
HXDLIN( 497)												if (this1->useVirtualPos) {
HXDLIN( 497)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXDLIN( 497)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN( 497)												int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 497)												int this25;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													this25 = this24;
            												}
HXDLIN( 497)												Float a12;
HXDLIN( 497)												int this26 = ((this25 >> 24) & 255);
HXDLIN( 497)												if ((this26 == 0)) {
HXDLIN( 497)													a12 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a12 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r11;
HXDLIN( 497)												int this27 = ((this25 >> 16) & 255);
HXDLIN( 497)												if ((this27 == 0)) {
HXDLIN( 497)													r11 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g11;
HXDLIN( 497)												int this28 = ((this25 >> 8) & 255);
HXDLIN( 497)												if ((this28 == 0)) {
HXDLIN( 497)													g11 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b12;
HXDLIN( 497)												int this29 = (this25 & 255);
HXDLIN( 497)												if ((this29 == 0)) {
HXDLIN( 497)													b12 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a21;
HXDLIN( 497)												int this30 = ((color >> 24) & 255);
HXDLIN( 497)												if ((this30 == 0)) {
HXDLIN( 497)													a21 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r21;
HXDLIN( 497)												int this31 = ((color >> 16) & 255);
HXDLIN( 497)												if ((this31 == 0)) {
HXDLIN( 497)													r21 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g21;
HXDLIN( 497)												int this32 = ((color >> 8) & 255);
HXDLIN( 497)												if ((this32 == 0)) {
HXDLIN( 497)													g21 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b22;
HXDLIN( 497)												int this33 = (color & 255);
HXDLIN( 497)												if ((this33 == 0)) {
HXDLIN( 497)													b22 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 497)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 497)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 497)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 497)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 497)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 497)												{
HXDLIN( 497)													int hitQuad7;
HXDLIN( 497)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)														hitQuad7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXDLIN( 497)														hitQuad7 = blended1;
            													}
HXDLIN( 497)													::iterMagic::Iimg_obj::set(this1->image,location1,hitQuad7);
            												}
            											}
            											else {
HXDLIN( 497)												::Dynamic this34 = this1->image;
HXDLIN( 497)												int index4;
HXDLIN( 497)												if (this1->useVirtualPos) {
HXDLIN( 497)													index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXDLIN( 497)													index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN( 497)												int hitQuad8;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad8 = c3;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this34,index4,hitQuad8);
            											}
            										}
HXLINE(  73)										found = true;
            									}
            									else {
HXDLIN( 497)										if (found) {
HXDLIN( 497)											goto _hx_goto_921;
            										}
            									}
            								}
            							}
            							_hx_goto_921:;
            						}
            					}
            				}
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 497)				int v_undoY;
HXDLIN( 497)				int v_undoX;
HXDLIN( 497)				Float v_ty;
HXDLIN( 497)				Float v_tx;
HXDLIN( 497)				Float v_t0;
HXDLIN( 497)				Float v_sy;
HXDLIN( 497)				Float v_sx;
HXDLIN( 497)				Float v_s0;
HXDLIN( 497)				Float v_A;
HXDLIN( 497)				Float ax1 = ax;
HXDLIN( 497)				Float ay1 = ay;
HXDLIN( 497)				 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 497)				Float bx2 = bx1;
HXDLIN( 497)				Float by2 = by1;
HXDLIN( 497)				Float cx2 = cx1;
HXDLIN( 497)				Float cy2 = cy1;
HXDLIN( 497)				bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN( 497)				if (!(adjustWinding1)) {
HXDLIN( 497)					Float bx_1 = bx2;
HXDLIN( 497)					Float by_1 = by2;
HXLINE(  24)					bx2 = cx2;
HXLINE(  25)					by2 = cy2;
HXLINE(  26)					cx2 = bx_1;
HXLINE(  27)					cy2 = by_1;
            				}
HXLINE( 497)				Float v_ax = ax1;
HXDLIN( 497)				Float v_ay = ay1;
HXDLIN( 497)				Float v_bx = bx2;
HXDLIN( 497)				Float v_by = by2;
HXDLIN( 497)				Float v_cx = cx2;
HXDLIN( 497)				Float v_cy = cy2;
HXDLIN( 497)				bool v_preCalculated = true;
HXDLIN( 497)				{
HXDLIN( 497)					v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 497)					v_sx = (v_cy - v_ay);
HXDLIN( 497)					v_sy = (v_ax - v_cx);
HXDLIN( 497)					v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 497)					v_tx = (v_ay - v_by);
HXDLIN( 497)					v_ty = (v_bx - v_ax);
HXDLIN( 497)					v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 497)					Float a6 = v_ax;
HXDLIN( 497)					Float b5 = v_bx;
HXDLIN( 497)					Float c4 = v_cx;
HXDLIN( 497)					if ((a6 > b5)) {
HXDLIN( 497)						if ((a6 > c4)) {
HXDLIN( 497)							int min4;
HXDLIN( 497)							if ((b5 > c4)) {
HXDLIN( 497)								min4 = ::Math_obj::floor(c4);
            							}
            							else {
HXDLIN( 497)								min4 = ::Math_obj::floor(b5);
            							}
HXDLIN( 497)							int ii_min8 = min4;
HXDLIN( 497)							int ii_max8 = ::Math_obj::ceil(a6);
HXDLIN( 497)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            						}
            						else {
HXDLIN( 497)							int ii_min9 = ::Math_obj::floor(b5);
HXDLIN( 497)							int ii_max9 = ::Math_obj::ceil(c4);
HXDLIN( 497)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            						}
            					}
            					else {
HXDLIN( 497)						if ((b5 > c4)) {
HXDLIN( 497)							int min5;
HXDLIN( 497)							if ((a6 > c4)) {
HXDLIN( 497)								min5 = ::Math_obj::floor(c4);
            							}
            							else {
HXDLIN( 497)								min5 = ::Math_obj::ceil(a6);
            							}
HXDLIN( 497)							int ii_min10 = min5;
HXDLIN( 497)							int ii_max10 = ::Math_obj::ceil(b5);
HXDLIN( 497)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXDLIN( 497)							int ii_min11 = ::Math_obj::floor(a6);
HXDLIN( 497)							int ii_max11 = ::Math_obj::ceil(c4);
HXDLIN( 497)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
HXDLIN( 497)					Float a7 = v_ay;
HXDLIN( 497)					Float b6 = v_by;
HXDLIN( 497)					Float c5 = v_cy;
HXDLIN( 497)					if ((a7 > b6)) {
HXDLIN( 497)						if ((a7 > c5)) {
HXDLIN( 497)							int min6;
HXDLIN( 497)							if ((b6 > c5)) {
HXDLIN( 497)								min6 = ::Math_obj::floor(c5);
            							}
            							else {
HXDLIN( 497)								min6 = ::Math_obj::floor(b6);
            							}
HXDLIN( 497)							int ii_min12 = min6;
HXDLIN( 497)							int ii_max12 = ::Math_obj::ceil(a7);
HXDLIN( 497)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXDLIN( 497)							int ii_min13 = ::Math_obj::floor(b6);
HXDLIN( 497)							int ii_max13 = ::Math_obj::ceil(c5);
HXDLIN( 497)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
            					else {
HXDLIN( 497)						if ((b6 > c5)) {
HXDLIN( 497)							int min7;
HXDLIN( 497)							if ((a7 > c5)) {
HXDLIN( 497)								min7 = ::Math_obj::floor(c5);
            							}
            							else {
HXDLIN( 497)								min7 = ::Math_obj::ceil(a7);
            							}
HXDLIN( 497)							int ii_min14 = min7;
HXDLIN( 497)							int ii_max14 = ::Math_obj::ceil(b6);
HXDLIN( 497)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXDLIN( 497)							int ii_min15 = ::Math_obj::floor(a7);
HXDLIN( 497)							int ii_max15 = ::Math_obj::ceil(c5);
HXDLIN( 497)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
            				}
HXDLIN( 497)				if (hasUndo) {
HXDLIN( 497)					v_undoImage = undoImage;
HXDLIN( 497)					v_undoX = xIter3->start;
HXDLIN( 497)					v_undoY = yIter3->start;
            				}
HXDLIN( 497)				Float bx3 = cx;
HXDLIN( 497)				Float by3 = cy;
HXDLIN( 497)				Float cx3 = dx;
HXDLIN( 497)				Float cy3 = dy;
HXDLIN( 497)				bool hasUndo1 = false;
HXDLIN( 497)				bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN( 497)				if (!(adjustWinding2)) {
HXDLIN( 497)					Float bx_2 = bx3;
HXDLIN( 497)					Float by_2 = by3;
HXLINE(  25)					bx3 = cx3;
HXLINE(  26)					by3 = cy3;
HXLINE(  27)					cx3 = bx_2;
HXLINE(  28)					cy3 = by_2;
            				}
HXLINE( 497)				Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN( 497)				Float sx1 = (cy3 - by);
HXDLIN( 497)				Float sy1 = (bx - cx3);
HXDLIN( 497)				Float t01 = ((bx * by3) - (by * bx3));
HXDLIN( 497)				Float tx1 = (by - by3);
HXDLIN( 497)				Float ty1 = (bx3 - bx);
HXDLIN( 497)				Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 497)				if ((bx > bx3)) {
HXDLIN( 497)					if ((bx > cx3)) {
HXDLIN( 497)						int min8;
HXDLIN( 497)						if ((bx3 > cx3)) {
HXDLIN( 497)							min8 = ::Math_obj::floor(cx3);
            						}
            						else {
HXDLIN( 497)							min8 = ::Math_obj::floor(bx3);
            						}
HXDLIN( 497)						int ii_min16 = min8;
HXDLIN( 497)						int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN( 497)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            					}
            					else {
HXDLIN( 497)						int ii_min17 = ::Math_obj::floor(bx3);
HXDLIN( 497)						int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN( 497)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            					}
            				}
            				else {
HXDLIN( 497)					if ((bx3 > cx3)) {
HXDLIN( 497)						int min9;
HXDLIN( 497)						if ((bx > cx3)) {
HXDLIN( 497)							min9 = ::Math_obj::floor(cx3);
            						}
            						else {
HXDLIN( 497)							min9 = ::Math_obj::ceil(bx);
            						}
HXDLIN( 497)						int ii_min18 = min9;
HXDLIN( 497)						int ii_max18 = ::Math_obj::ceil(bx3);
HXDLIN( 497)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXDLIN( 497)						int ii_min19 = ::Math_obj::floor(bx);
HXDLIN( 497)						int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN( 497)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 497)				if ((by > by3)) {
HXDLIN( 497)					if ((by > cy3)) {
HXDLIN( 497)						int min10;
HXDLIN( 497)						if ((by3 > cy3)) {
HXDLIN( 497)							min10 = ::Math_obj::floor(cy3);
            						}
            						else {
HXDLIN( 497)							min10 = ::Math_obj::floor(by3);
            						}
HXDLIN( 497)						int ii_min20 = min10;
HXDLIN( 497)						int ii_max20 = ::Math_obj::ceil(by);
HXDLIN( 497)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXDLIN( 497)						int ii_min21 = ::Math_obj::floor(by3);
HXDLIN( 497)						int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN( 497)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
            				else {
HXDLIN( 497)					if ((by3 > cy3)) {
HXDLIN( 497)						int min11;
HXDLIN( 497)						if ((by > cy3)) {
HXDLIN( 497)							min11 = ::Math_obj::floor(cy3);
            						}
            						else {
HXDLIN( 497)							min11 = ::Math_obj::ceil(by);
            						}
HXDLIN( 497)						int ii_min22 = min11;
HXDLIN( 497)						int ii_max22 = ::Math_obj::ceil(by3);
HXDLIN( 497)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXDLIN( 497)						int ii_min23 = ::Math_obj::floor(by);
HXDLIN( 497)						int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN( 497)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
HXDLIN( 497)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 497)				if (hasUndo1) {
HXDLIN( 497)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 497)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 497)					 ::Dynamic imageType1 = null();
HXDLIN( 497)					 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 497)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 497)					::Dynamic undoImage4;
HXDLIN( 497)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXDLIN( 497)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::BytesImg b7 = byt1;
HXDLIN( 497)							{
HXDLIN( 497)								b7->width = width1;
HXDLIN( 497)								b7->height = height1;
HXDLIN( 497)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 497)								b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN( 497)								{
HXDLIN( 497)									int len2 = b7->length;
HXDLIN( 497)									int w1 = 0;
HXDLIN( 497)									{
HXDLIN( 497)										int _g20 = 0;
HXDLIN( 497)										int _g21 = b7->height;
HXDLIN( 497)										while((_g20 < _g21)){
HXDLIN( 497)											_g20 = (_g20 + 1);
HXDLIN( 497)											int y4 = (_g20 - 1);
HXDLIN( 497)											{
HXDLIN( 497)												int _g22 = 0;
HXDLIN( 497)												int _g23 = b7->width;
HXDLIN( 497)												while((_g22 < _g23)){
HXDLIN( 497)													_g22 = (_g22 + 1);
HXDLIN( 497)													int x4 = (_g22 - 1);
HXDLIN( 497)													{
HXDLIN( 497)														w1 = (w1 + 1);
HXDLIN( 497)														b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w1 = (w1 + 1);
HXDLIN( 497)														b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w1 = (w1 + 1);
HXDLIN( 497)														b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w1 = (w1 + 1);
HXDLIN( 497)														b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage4 = b7;
            						}
            						break;
            						case (int)1: {
HXDLIN( 497)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::ArrIntImg a8 = arrI1;
HXDLIN( 497)							{
HXDLIN( 497)								a8->width = width1;
HXDLIN( 497)								a8->height = height1;
HXDLIN( 497)								a8->data = ::Array_obj< int >::__new(0);
HXDLIN( 497)								a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 497)								{
HXDLIN( 497)									int _g24 = 0;
HXDLIN( 497)									int _g25 = a8->length;
HXDLIN( 497)									while((_g24 < _g25)){
HXDLIN( 497)										_g24 = (_g24 + 1);
HXDLIN( 497)										int i6 = (_g24 - 1);
HXDLIN( 497)										a8->data[i6] = 0;
            									}
            								}
            							}
HXDLIN( 497)							undoImage4 = a8;
            						}
            						break;
            						case (int)2: {
HXDLIN( 497)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::U32ArrImg b8 = u32a1;
HXDLIN( 497)							{
HXDLIN( 497)								b8->width = width1;
HXDLIN( 497)								b8->height = height1;
HXDLIN( 497)								b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 497)								int size1 = (b8->length * 4);
HXDLIN( 497)								b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 497)								{
HXDLIN( 497)									int _g26 = 0;
HXDLIN( 497)									int _g27 = b8->length;
HXDLIN( 497)									while((_g26 < _g27)){
HXDLIN( 497)										_g26 = (_g26 + 1);
HXDLIN( 497)										int i7 = (_g26 - 1);
HXDLIN( 497)										{
HXDLIN( 497)											 ::haxe::io::ArrayBufferViewImpl this36 = b8->data;
HXDLIN( 497)											bool undoImage5;
HXDLIN( 497)											if ((i7 >= 0)) {
HXDLIN( 497)												undoImage5 = (i7 < (this36->byteLength >> 2));
            											}
            											else {
HXDLIN( 497)												undoImage5 = false;
            											}
HXDLIN( 497)											if (undoImage5) {
HXDLIN( 497)												 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 497)												int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 497)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 497)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 497)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 497)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage4 = b8;
            						}
            						break;
            						case (int)3: {
HXDLIN( 497)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 497)							{
HXDLIN( 497)								v2->width = width1;
HXDLIN( 497)								v2->height = height1;
HXDLIN( 497)								v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 497)								v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 497)								{
HXDLIN( 497)									int _g28 = 0;
HXDLIN( 497)									int _g29 = v2->length;
HXDLIN( 497)									while((_g28 < _g29)){
HXDLIN( 497)										_g28 = (_g28 + 1);
HXDLIN( 497)										int i8 = (_g28 - 1);
HXDLIN( 497)										v2->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN( 497)							undoImage4 = v2;
            						}
            						break;
            						case (int)4: {
HXDLIN( 497)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::StackIntImg b9 = sInt1;
HXDLIN( 497)							{
HXDLIN( 497)								b9->width = width1;
HXDLIN( 497)								b9->height = height1;
HXDLIN( 497)								b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 497)								b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 497)								{
HXDLIN( 497)									int len3 = b9->length;
HXDLIN( 497)									 ::haxe::ds::GenericStack_Int d1 = b9->data;
HXDLIN( 497)									if (::hx::IsNull( d1->head )) {
HXDLIN( 497)										int _g30 = 0;
HXDLIN( 497)										int _g31 = len3;
HXDLIN( 497)										while((_g30 < _g31)){
HXDLIN( 497)											_g30 = (_g30 + 1);
HXDLIN( 497)											int i9 = (_g30 - 1);
HXDLIN( 497)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXDLIN( 497)										int _g32 = 0;
HXDLIN( 497)										int _g33 = len3;
HXDLIN( 497)										while((_g32 < _g33)){
HXDLIN( 497)											_g32 = (_g32 + 1);
HXDLIN( 497)											int i10 = (_g32 - 1);
HXDLIN( 497)											{
HXDLIN( 497)												 ::haxe::ds::GenericCell_Int l1 = b9->data->head;
HXDLIN( 497)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 497)												{
HXDLIN( 497)													int _g34 = 0;
HXDLIN( 497)													int _g35 = i10;
HXDLIN( 497)													while((_g34 < _g35)){
HXDLIN( 497)														_g34 = (_g34 + 1);
HXDLIN( 497)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE( 497)												if (::hx::IsNull( prev1 )) {
HXDLIN( 497)													b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 497)													l1 = null();
            												}
            												else {
HXDLIN( 497)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 497)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage4 = b9;
            						}
            						break;
            					}
HXDLIN( 497)					this35->image = undoImage4;
HXDLIN( 497)					this35->width = width1;
HXDLIN( 497)					this35->height = height1;
HXDLIN( 497)					this35->imageType = ( (int)(imageType1) );
HXDLIN( 497)					undoImage3 = this35;
HXDLIN( 497)					{
HXDLIN( 497)						int rectLeft1 = xIter31->start;
HXDLIN( 497)						int rectTop1 = yIter31->start;
HXDLIN( 497)						int rectRight1 = xIter31->max;
HXDLIN( 497)						bool forceClear1 = false;
HXDLIN( 497)						{
HXDLIN( 497)							int _g36 = rectTop1;
HXDLIN( 497)							int _g37 = yIter31->max;
HXDLIN( 497)							while((_g36 < _g37)){
HXDLIN( 497)								_g36 = (_g36 + 1);
HXDLIN( 497)								int dy2 = (_g36 - 1);
HXDLIN( 497)								{
HXDLIN( 497)									int _g38 = rectLeft1;
HXDLIN( 497)									int _g39 = rectRight1;
HXDLIN( 497)									while((_g38 < _g39)){
HXDLIN( 497)										_g38 = (_g38 + 1);
HXDLIN( 497)										int dx2 = (_g38 - 1);
HXDLIN( 497)										::Dynamic this37 = this1->image;
HXDLIN( 497)										int index5;
HXDLIN( 497)										if (this1->useVirtualPos) {
HXDLIN( 497)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            										}
            										else {
HXDLIN( 497)											index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            										}
HXDLIN( 497)										int c6 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 497)										int col1;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											col1 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											col1 = c6;
            										}
HXDLIN( 497)										bool hitQuad9;
HXDLIN( 497)										if (this1->useMask) {
HXDLIN( 497)											hitQuad9 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 497)											hitQuad9 = false;
            										}
HXDLIN( 497)										if (hitQuad9) {
HXDLIN( 497)											 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN( 497)											::Dynamic this39 = this38->image;
HXDLIN( 497)											int index6;
HXDLIN( 497)											if (this38->useVirtualPos) {
HXDLIN( 497)												index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            											}
            											else {
HXDLIN( 497)												index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            											}
HXDLIN( 497)											int c7 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 497)											int v3;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												v3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												v3 = c7;
            											}
HXDLIN( 497)											int maskPixel1 = v3;
HXDLIN( 497)											int this40 = col1;
HXDLIN( 497)											if ((maskPixel1 == 0)) {
HXDLIN( 497)												col1 = this40;
            											}
            											else {
HXDLIN( 497)												Float m01;
HXDLIN( 497)												int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 497)												if ((this41 == 0)) {
HXDLIN( 497)													m01 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m11;
HXDLIN( 497)												int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 497)												if ((this42 == 0)) {
HXDLIN( 497)													m11 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m21;
HXDLIN( 497)												int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 497)												if ((this43 == 0)) {
HXDLIN( 497)													m21 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m31;
HXDLIN( 497)												int this44 = (maskPixel1 & 255);
HXDLIN( 497)												if ((this44 == 0)) {
HXDLIN( 497)													m31 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 497)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 497)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 497)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 497)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 497)										if ((col1 != 0)) {
HXDLIN( 497)											int x5 = (dx2 - rectLeft1);
HXDLIN( 497)											int y5 = (dy2 - rectTop1);
HXDLIN( 497)											int c8 = col1;
HXDLIN( 497)											bool hitQuad10;
HXDLIN( 497)											if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 497)												hitQuad10 = undoImage3->transparent;
            											}
            											else {
HXDLIN( 497)												hitQuad10 = false;
            											}
HXDLIN( 497)											if (hitQuad10) {
HXDLIN( 497)												int location2;
HXDLIN( 497)												if (undoImage3->useVirtualPos) {
HXDLIN( 497)													location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXDLIN( 497)													location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 497)												int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 497)												int this46;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													this46 = this45;
            												}
HXDLIN( 497)												Float a13;
HXDLIN( 497)												int this47 = ((this46 >> 24) & 255);
HXDLIN( 497)												if ((this47 == 0)) {
HXDLIN( 497)													a13 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a13 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r12;
HXDLIN( 497)												int this48 = ((this46 >> 16) & 255);
HXDLIN( 497)												if ((this48 == 0)) {
HXDLIN( 497)													r12 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g12;
HXDLIN( 497)												int this49 = ((this46 >> 8) & 255);
HXDLIN( 497)												if ((this49 == 0)) {
HXDLIN( 497)													g12 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b13;
HXDLIN( 497)												int this50 = (this46 & 255);
HXDLIN( 497)												if ((this50 == 0)) {
HXDLIN( 497)													b13 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a22;
HXDLIN( 497)												int this51 = ((col1 >> 24) & 255);
HXDLIN( 497)												if ((this51 == 0)) {
HXDLIN( 497)													a22 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r22;
HXDLIN( 497)												int this52 = ((col1 >> 16) & 255);
HXDLIN( 497)												if ((this52 == 0)) {
HXDLIN( 497)													r22 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g22;
HXDLIN( 497)												int this53 = ((col1 >> 8) & 255);
HXDLIN( 497)												if ((this53 == 0)) {
HXDLIN( 497)													g22 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b23;
HXDLIN( 497)												int this54 = (col1 & 255);
HXDLIN( 497)												if ((this54 == 0)) {
HXDLIN( 497)													b23 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 497)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 497)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 497)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 497)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 497)												int blended2 = ((((a9 << 24) | (r4 << 16)) | (g4 << 8)) | b10);
HXDLIN( 497)												{
HXDLIN( 497)													int hitQuad11;
HXDLIN( 497)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)														hitQuad11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXDLIN( 497)														hitQuad11 = blended2;
            													}
HXDLIN( 497)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,hitQuad11);
            												}
            											}
            											else {
HXDLIN( 497)												::Dynamic this55 = undoImage3->image;
HXDLIN( 497)												int index7;
HXDLIN( 497)												if (undoImage3->useVirtualPos) {
HXDLIN( 497)													index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            												}
            												else {
HXDLIN( 497)													index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            												}
HXDLIN( 497)												int hitQuad12;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad12 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad12 = c8;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this55,index7,hitQuad12);
            											}
            										}
            										else {
HXDLIN( 497)											if (forceClear1) {
HXDLIN( 497)												::Dynamic this56 = undoImage3->image;
HXDLIN( 497)												int x6 = (dx2 - rectLeft1);
HXDLIN( 497)												int y6 = (dy2 - rectTop1);
HXDLIN( 497)												int index8;
HXDLIN( 497)												if (undoImage3->useVirtualPos) {
HXDLIN( 497)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXDLIN( 497)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this56,index8,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 497)				bool found1 = false;
HXDLIN( 497)				Float s1 = ((Float)0.);
HXDLIN( 497)				Float t1 = ((Float)0.);
HXDLIN( 497)				Float sxx1 = ((Float)0.);
HXDLIN( 497)				Float txx1 = ((Float)0.);
HXDLIN( 497)				{
HXDLIN( 497)					int _g_min2 = xIter31->start;
HXDLIN( 497)					int _g_max2 = xIter31->max;
HXDLIN( 497)					while((_g_min2 < _g_max2)){
HXDLIN( 497)						_g_min2 = (_g_min2 + 1);
HXDLIN( 497)						int x7 = (_g_min2 - 1);
HXLINE(  60)						sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)						txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)						found1 = false;
HXLINE( 497)						{
HXDLIN( 497)							int _g_min3 = yIter31->start;
HXDLIN( 497)							int _g_max3 = yIter31->max;
HXDLIN( 497)							while((_g_min3 < _g_max3)){
HXDLIN( 497)								_g_min3 = (_g_min3 + 1);
HXDLIN( 497)								int y7 = (_g_min3 - 1);
HXLINE(  64)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 497)								bool hitQuad13;
HXDLIN( 497)								if (!((s1 <= 0))) {
HXDLIN( 497)									hitQuad13 = (t1 <= 0);
            								}
            								else {
HXDLIN( 497)									hitQuad13 = true;
            								}
HXDLIN( 497)								if (hitQuad13) {
HXDLIN( 497)									if (found1) {
HXDLIN( 497)										goto _hx_goto_933;
            									}
            								}
            								else {
HXDLIN( 497)									if (((s1 + t1) < A1)) {
HXDLIN( 497)										{
HXDLIN( 497)											int c9 = color;
HXDLIN( 497)											bool hitQuad14;
HXDLIN( 497)											if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 497)												hitQuad14 = this1->transparent;
            											}
            											else {
HXDLIN( 497)												hitQuad14 = false;
            											}
HXDLIN( 497)											if (hitQuad14) {
HXDLIN( 497)												int location3;
HXDLIN( 497)												if (this1->useVirtualPos) {
HXDLIN( 497)													location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXDLIN( 497)													location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN( 497)												int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 497)												int this58;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													this58 = this57;
            												}
HXDLIN( 497)												Float a14;
HXDLIN( 497)												int this59 = ((this58 >> 24) & 255);
HXDLIN( 497)												if ((this59 == 0)) {
HXDLIN( 497)													a14 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a14 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r13;
HXDLIN( 497)												int this60 = ((this58 >> 16) & 255);
HXDLIN( 497)												if ((this60 == 0)) {
HXDLIN( 497)													r13 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g13;
HXDLIN( 497)												int this61 = ((this58 >> 8) & 255);
HXDLIN( 497)												if ((this61 == 0)) {
HXDLIN( 497)													g13 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b14;
HXDLIN( 497)												int this62 = (this58 & 255);
HXDLIN( 497)												if ((this62 == 0)) {
HXDLIN( 497)													b14 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a23;
HXDLIN( 497)												int this63 = ((color >> 24) & 255);
HXDLIN( 497)												if ((this63 == 0)) {
HXDLIN( 497)													a23 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r23;
HXDLIN( 497)												int this64 = ((color >> 16) & 255);
HXDLIN( 497)												if ((this64 == 0)) {
HXDLIN( 497)													r23 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g23;
HXDLIN( 497)												int this65 = ((color >> 8) & 255);
HXDLIN( 497)												if ((this65 == 0)) {
HXDLIN( 497)													g23 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b24;
HXDLIN( 497)												int this66 = (color & 255);
HXDLIN( 497)												if ((this66 == 0)) {
HXDLIN( 497)													b24 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 497)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 497)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 497)												int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 497)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 497)												int blended3 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b15);
HXDLIN( 497)												{
HXDLIN( 497)													int hitQuad15;
HXDLIN( 497)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)														hitQuad15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXDLIN( 497)														hitQuad15 = blended3;
            													}
HXDLIN( 497)													::iterMagic::Iimg_obj::set(this1->image,location3,hitQuad15);
            												}
            											}
            											else {
HXDLIN( 497)												::Dynamic this67 = this1->image;
HXDLIN( 497)												int index9;
HXDLIN( 497)												if (this1->useVirtualPos) {
HXDLIN( 497)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXDLIN( 497)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN( 497)												int hitQuad16;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad16 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad16 = c9;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this67,index9,hitQuad16);
            											}
            										}
HXLINE(  73)										found1 = true;
            									}
            									else {
HXDLIN( 497)										if (found1) {
HXDLIN( 497)											goto _hx_goto_933;
            										}
            									}
            								}
            							}
            							_hx_goto_933:;
            						}
            					}
            				}
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 497)				int v_undoY1;
HXDLIN( 497)				int v_undoX1;
HXDLIN( 497)				Float v_ty1;
HXDLIN( 497)				Float v_tx1;
HXDLIN( 497)				Float v_t01;
HXDLIN( 497)				Float v_sy1;
HXDLIN( 497)				Float v_sx1;
HXDLIN( 497)				Float v_s01;
HXDLIN( 497)				Float v_A1;
HXDLIN( 497)				Float ax2 = bx;
HXDLIN( 497)				Float ay2 = by;
HXDLIN( 497)				 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 497)				Float bx4 = bx3;
HXDLIN( 497)				Float by4 = by3;
HXDLIN( 497)				Float cx4 = cx3;
HXDLIN( 497)				Float cy4 = cy3;
HXDLIN( 497)				bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN( 497)				if (!(adjustWinding3)) {
HXDLIN( 497)					Float bx_3 = bx4;
HXDLIN( 497)					Float by_3 = by4;
HXLINE(  24)					bx4 = cx4;
HXLINE(  25)					by4 = cy4;
HXLINE(  26)					cx4 = bx_3;
HXLINE(  27)					cy4 = by_3;
            				}
HXLINE( 497)				Float v_ax1 = ax2;
HXDLIN( 497)				Float v_ay1 = ay2;
HXDLIN( 497)				Float v_bx1 = bx4;
HXDLIN( 497)				Float v_by1 = by4;
HXDLIN( 497)				Float v_cx1 = cx4;
HXDLIN( 497)				Float v_cy1 = cy4;
HXDLIN( 497)				bool v_preCalculated1 = true;
HXDLIN( 497)				{
HXDLIN( 497)					v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 497)					v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 497)					v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 497)					v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 497)					v_tx1 = (v_ay1 - v_by1);
HXDLIN( 497)					v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 497)					v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 497)					Float a15 = v_ax1;
HXDLIN( 497)					Float b16 = v_bx1;
HXDLIN( 497)					Float c10 = v_cx1;
HXDLIN( 497)					if ((a15 > b16)) {
HXDLIN( 497)						if ((a15 > c10)) {
HXDLIN( 497)							int min12;
HXDLIN( 497)							if ((b16 > c10)) {
HXDLIN( 497)								min12 = ::Math_obj::floor(c10);
            							}
            							else {
HXDLIN( 497)								min12 = ::Math_obj::floor(b16);
            							}
HXDLIN( 497)							int ii_min24 = min12;
HXDLIN( 497)							int ii_max24 = ::Math_obj::ceil(a15);
HXDLIN( 497)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            						}
            						else {
HXDLIN( 497)							int ii_min25 = ::Math_obj::floor(b16);
HXDLIN( 497)							int ii_max25 = ::Math_obj::ceil(c10);
HXDLIN( 497)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            						}
            					}
            					else {
HXDLIN( 497)						if ((b16 > c10)) {
HXDLIN( 497)							int min13;
HXDLIN( 497)							if ((a15 > c10)) {
HXDLIN( 497)								min13 = ::Math_obj::floor(c10);
            							}
            							else {
HXDLIN( 497)								min13 = ::Math_obj::ceil(a15);
            							}
HXDLIN( 497)							int ii_min26 = min13;
HXDLIN( 497)							int ii_max26 = ::Math_obj::ceil(b16);
HXDLIN( 497)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            						}
            						else {
HXDLIN( 497)							int ii_min27 = ::Math_obj::floor(a15);
HXDLIN( 497)							int ii_max27 = ::Math_obj::ceil(c10);
HXDLIN( 497)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            						}
            					}
HXDLIN( 497)					Float a16 = v_ay1;
HXDLIN( 497)					Float b17 = v_by1;
HXDLIN( 497)					Float c11 = v_cy1;
HXDLIN( 497)					if ((a16 > b17)) {
HXDLIN( 497)						if ((a16 > c11)) {
HXDLIN( 497)							int min14;
HXDLIN( 497)							if ((b17 > c11)) {
HXDLIN( 497)								min14 = ::Math_obj::floor(c11);
            							}
            							else {
HXDLIN( 497)								min14 = ::Math_obj::floor(b17);
            							}
HXDLIN( 497)							int ii_min28 = min14;
HXDLIN( 497)							int ii_max28 = ::Math_obj::ceil(a16);
HXDLIN( 497)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            						}
            						else {
HXDLIN( 497)							int ii_min29 = ::Math_obj::floor(b17);
HXDLIN( 497)							int ii_max29 = ::Math_obj::ceil(c11);
HXDLIN( 497)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            						}
            					}
            					else {
HXDLIN( 497)						if ((b17 > c11)) {
HXDLIN( 497)							int min15;
HXDLIN( 497)							if ((a16 > c11)) {
HXDLIN( 497)								min15 = ::Math_obj::floor(c11);
            							}
            							else {
HXDLIN( 497)								min15 = ::Math_obj::ceil(a16);
            							}
HXDLIN( 497)							int ii_min30 = min15;
HXDLIN( 497)							int ii_max30 = ::Math_obj::ceil(b17);
HXDLIN( 497)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            						}
            						else {
HXDLIN( 497)							int ii_min31 = ::Math_obj::floor(a16);
HXDLIN( 497)							int ii_max31 = ::Math_obj::ceil(c11);
HXDLIN( 497)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            						}
            					}
            				}
HXDLIN( 497)				if (hasUndo1) {
HXDLIN( 497)					v_undoImage1 = undoImage3;
HXDLIN( 497)					v_undoX1 = xIter31->start;
HXDLIN( 497)					v_undoY1 = yIter31->start;
            				}
HXDLIN( 497)				 ::pi_xy::algo::HitQuad v4 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 497)				hitQuad = v4;
            			}
            			else {
HXDLIN( 497)				Float sin2 = ::Math_obj::sin(theta);
HXDLIN( 497)				Float cos2 = ::Math_obj::cos(theta);
HXDLIN( 497)				Float radius11 = ((thicker - ((thicker - thick) / goldenRatio)) / ( (Float)(2) ));
HXDLIN( 497)				Float radius22 = (thick / ( (Float)(2) ));
HXDLIN( 497)				Float dx3 = ((Float)0.1);
HXDLIN( 497)				Float dy3 = radius11;
HXDLIN( 497)				Float cx5 = h2;
HXDLIN( 497)				Float cy5 = radius22;
HXDLIN( 497)				Float bx5 = h2;
HXDLIN( 497)				Float by5 = -(radius22);
HXDLIN( 497)				Float ax3 = ((Float)0.1);
HXDLIN( 497)				Float ay3 = -(radius11);
HXDLIN( 497)				Float temp1 = ((Float)0.);
HXLINE( 240)				temp1 = (px + ((ax3 * cos2) - (ay3 * sin2)));
HXLINE( 241)				ay3 = (py + ((ay3 * cos2) + (ax3 * sin2)));
HXLINE( 242)				ax3 = temp1;
HXLINE( 244)				temp1 = (px + ((bx5 * cos2) - (by5 * sin2)));
HXLINE( 245)				by5 = (py + ((by5 * cos2) + (bx5 * sin2)));
HXLINE( 246)				bx5 = temp1;
HXLINE( 248)				temp1 = (px + ((cx5 * cos2) - (cy5 * sin2)));
HXLINE( 249)				cy5 = (py + ((cy5 * cos2) + (cx5 * sin2)));
HXLINE( 250)				cx5 = temp1;
HXLINE( 252)				temp1 = (px + ((dx3 * cos2) - (dy3 * sin2)));
HXLINE( 253)				dy3 = (py + ((dy3 * cos2) + (dx3 * sin2)));
HXLINE( 254)				dx3 = temp1;
HXLINE( 497)				Float bx6 = bx5;
HXDLIN( 497)				Float by6 = by5;
HXDLIN( 497)				Float cx6 = dx3;
HXDLIN( 497)				Float cy6 = dy3;
HXDLIN( 497)				bool hasUndo2 = false;
HXDLIN( 497)				bool adjustWinding4 = (((((ax3 * by6) - (bx6 * ay3)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * ay3) - (ax3 * cy6))) > 0);
HXDLIN( 497)				if (!(adjustWinding4)) {
HXDLIN( 497)					Float bx_4 = bx6;
HXDLIN( 497)					Float by_4 = by6;
HXLINE(  25)					bx6 = cx6;
HXLINE(  26)					by6 = cy6;
HXLINE(  27)					cx6 = bx_4;
HXLINE(  28)					cy6 = by_4;
            				}
HXLINE( 497)				Float s02 = ((ay3 * cx6) - (ax3 * cy6));
HXDLIN( 497)				Float sx2 = (cy6 - ay3);
HXDLIN( 497)				Float sy2 = (ax3 - cx6);
HXDLIN( 497)				Float t02 = ((ax3 * by6) - (ay3 * bx6));
HXDLIN( 497)				Float tx2 = (ay3 - by6);
HXDLIN( 497)				Float ty2 = (bx6 - ax3);
HXDLIN( 497)				Float A2 = ((((-(by6) * cx6) + (ay3 * (-(bx6) + cx6))) + (ax3 * (by6 - cy6))) + (bx6 * cy6));
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 497)				if ((ax3 > bx6)) {
HXDLIN( 497)					if ((ax3 > cx6)) {
HXDLIN( 497)						int min16;
HXDLIN( 497)						if ((bx6 > cx6)) {
HXDLIN( 497)							min16 = ::Math_obj::floor(cx6);
            						}
            						else {
HXDLIN( 497)							min16 = ::Math_obj::floor(bx6);
            						}
HXDLIN( 497)						int ii_min32 = min16;
HXDLIN( 497)						int ii_max32 = ::Math_obj::ceil(ax3);
HXDLIN( 497)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            					}
            					else {
HXDLIN( 497)						int ii_min33 = ::Math_obj::floor(bx6);
HXDLIN( 497)						int ii_max33 = ::Math_obj::ceil(cx6);
HXDLIN( 497)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            					}
            				}
            				else {
HXDLIN( 497)					if ((bx6 > cx6)) {
HXDLIN( 497)						int min17;
HXDLIN( 497)						if ((ax3 > cx6)) {
HXDLIN( 497)							min17 = ::Math_obj::floor(cx6);
            						}
            						else {
HXDLIN( 497)							min17 = ::Math_obj::ceil(ax3);
            						}
HXDLIN( 497)						int ii_min34 = min17;
HXDLIN( 497)						int ii_max34 = ::Math_obj::ceil(bx6);
HXDLIN( 497)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            					}
            					else {
HXDLIN( 497)						int ii_min35 = ::Math_obj::floor(ax3);
HXDLIN( 497)						int ii_max35 = ::Math_obj::ceil(cx6);
HXDLIN( 497)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            					}
            				}
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 497)				if ((ay3 > by6)) {
HXDLIN( 497)					if ((ay3 > cy6)) {
HXDLIN( 497)						int min18;
HXDLIN( 497)						if ((by6 > cy6)) {
HXDLIN( 497)							min18 = ::Math_obj::floor(cy6);
            						}
            						else {
HXDLIN( 497)							min18 = ::Math_obj::floor(by6);
            						}
HXDLIN( 497)						int ii_min36 = min18;
HXDLIN( 497)						int ii_max36 = ::Math_obj::ceil(ay3);
HXDLIN( 497)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            					}
            					else {
HXDLIN( 497)						int ii_min37 = ::Math_obj::floor(by6);
HXDLIN( 497)						int ii_max37 = ::Math_obj::ceil(cy6);
HXDLIN( 497)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            					}
            				}
            				else {
HXDLIN( 497)					if ((by6 > cy6)) {
HXDLIN( 497)						int min19;
HXDLIN( 497)						if ((ay3 > cy6)) {
HXDLIN( 497)							min19 = ::Math_obj::floor(cy6);
            						}
            						else {
HXDLIN( 497)							min19 = ::Math_obj::ceil(ay3);
            						}
HXDLIN( 497)						int ii_min38 = min19;
HXDLIN( 497)						int ii_max38 = ::Math_obj::ceil(by6);
HXDLIN( 497)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            					}
            					else {
HXDLIN( 497)						int ii_min39 = ::Math_obj::floor(ay3);
HXDLIN( 497)						int ii_max39 = ::Math_obj::ceil(cy6);
HXDLIN( 497)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            					}
            				}
HXDLIN( 497)				 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 497)				if (hasUndo2) {
HXDLIN( 497)					int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 497)					int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 497)					 ::Dynamic imageType2 = null();
HXDLIN( 497)					 ::pi_xy::ImageStruct this68 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 497)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 497)					::Dynamic undoImage7;
HXDLIN( 497)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXDLIN( 497)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::BytesImg b18 = byt2;
HXDLIN( 497)							{
HXDLIN( 497)								b18->width = width2;
HXDLIN( 497)								b18->height = height2;
HXDLIN( 497)								b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 497)								b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN( 497)								{
HXDLIN( 497)									int len4 = b18->length;
HXDLIN( 497)									int w2 = 0;
HXDLIN( 497)									{
HXDLIN( 497)										int _g40 = 0;
HXDLIN( 497)										int _g41 = b18->height;
HXDLIN( 497)										while((_g40 < _g41)){
HXDLIN( 497)											_g40 = (_g40 + 1);
HXDLIN( 497)											int y8 = (_g40 - 1);
HXDLIN( 497)											{
HXDLIN( 497)												int _g42 = 0;
HXDLIN( 497)												int _g43 = b18->width;
HXDLIN( 497)												while((_g42 < _g43)){
HXDLIN( 497)													_g42 = (_g42 + 1);
HXDLIN( 497)													int x8 = (_g42 - 1);
HXDLIN( 497)													{
HXDLIN( 497)														w2 = (w2 + 1);
HXDLIN( 497)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w2 = (w2 + 1);
HXDLIN( 497)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w2 = (w2 + 1);
HXDLIN( 497)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w2 = (w2 + 1);
HXDLIN( 497)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage7 = b18;
            						}
            						break;
            						case (int)1: {
HXDLIN( 497)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::ArrIntImg a17 = arrI2;
HXDLIN( 497)							{
HXDLIN( 497)								a17->width = width2;
HXDLIN( 497)								a17->height = height2;
HXDLIN( 497)								a17->data = ::Array_obj< int >::__new(0);
HXDLIN( 497)								a17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 497)								{
HXDLIN( 497)									int _g44 = 0;
HXDLIN( 497)									int _g45 = a17->length;
HXDLIN( 497)									while((_g44 < _g45)){
HXDLIN( 497)										_g44 = (_g44 + 1);
HXDLIN( 497)										int i12 = (_g44 - 1);
HXDLIN( 497)										a17->data[i12] = 0;
            									}
            								}
            							}
HXDLIN( 497)							undoImage7 = a17;
            						}
            						break;
            						case (int)2: {
HXDLIN( 497)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::U32ArrImg b19 = u32a2;
HXDLIN( 497)							{
HXDLIN( 497)								b19->width = width2;
HXDLIN( 497)								b19->height = height2;
HXDLIN( 497)								b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 497)								int size2 = (b19->length * 4);
HXDLIN( 497)								b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 497)								{
HXDLIN( 497)									int _g46 = 0;
HXDLIN( 497)									int _g47 = b19->length;
HXDLIN( 497)									while((_g46 < _g47)){
HXDLIN( 497)										_g46 = (_g46 + 1);
HXDLIN( 497)										int i13 = (_g46 - 1);
HXDLIN( 497)										{
HXDLIN( 497)											 ::haxe::io::ArrayBufferViewImpl this69 = b19->data;
HXDLIN( 497)											bool undoImage8;
HXDLIN( 497)											if ((i13 >= 0)) {
HXDLIN( 497)												undoImage8 = (i13 < (this69->byteLength >> 2));
            											}
            											else {
HXDLIN( 497)												undoImage8 = false;
            											}
HXDLIN( 497)											if (undoImage8) {
HXDLIN( 497)												 ::haxe::io::Bytes _this2 = this69->bytes;
HXDLIN( 497)												int pos2 = ((i13 << 2) + this69->byteOffset);
HXDLIN( 497)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 497)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 497)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 497)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage7 = b19;
            						}
            						break;
            						case (int)3: {
HXDLIN( 497)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN( 497)							{
HXDLIN( 497)								v5->width = width2;
HXDLIN( 497)								v5->height = height2;
HXDLIN( 497)								v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 497)								v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN( 497)								{
HXDLIN( 497)									int _g48 = 0;
HXDLIN( 497)									int _g49 = v5->length;
HXDLIN( 497)									while((_g48 < _g49)){
HXDLIN( 497)										_g48 = (_g48 + 1);
HXDLIN( 497)										int i14 = (_g48 - 1);
HXDLIN( 497)										v5->data->__unsafe_set(i14,0);
            									}
            								}
            							}
HXDLIN( 497)							undoImage7 = v5;
            						}
            						break;
            						case (int)4: {
HXDLIN( 497)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::StackIntImg b20 = sInt2;
HXDLIN( 497)							{
HXDLIN( 497)								b20->width = width2;
HXDLIN( 497)								b20->height = height2;
HXDLIN( 497)								b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 497)								b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 497)								{
HXDLIN( 497)									int len5 = b20->length;
HXDLIN( 497)									 ::haxe::ds::GenericStack_Int d2 = b20->data;
HXDLIN( 497)									if (::hx::IsNull( d2->head )) {
HXDLIN( 497)										int _g50 = 0;
HXDLIN( 497)										int _g51 = len5;
HXDLIN( 497)										while((_g50 < _g51)){
HXDLIN( 497)											_g50 = (_g50 + 1);
HXDLIN( 497)											int i15 = (_g50 - 1);
HXDLIN( 497)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXDLIN( 497)										int _g52 = 0;
HXDLIN( 497)										int _g53 = len5;
HXDLIN( 497)										while((_g52 < _g53)){
HXDLIN( 497)											_g52 = (_g52 + 1);
HXDLIN( 497)											int i16 = (_g52 - 1);
HXDLIN( 497)											{
HXDLIN( 497)												 ::haxe::ds::GenericCell_Int l2 = b20->data->head;
HXDLIN( 497)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 497)												{
HXDLIN( 497)													int _g54 = 0;
HXDLIN( 497)													int _g55 = i16;
HXDLIN( 497)													while((_g54 < _g55)){
HXDLIN( 497)														_g54 = (_g54 + 1);
HXDLIN( 497)														int i17 = (_g54 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE( 497)												if (::hx::IsNull( prev2 )) {
HXDLIN( 497)													b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 497)													l2 = null();
            												}
            												else {
HXDLIN( 497)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 497)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage7 = b20;
            						}
            						break;
            					}
HXDLIN( 497)					this68->image = undoImage7;
HXDLIN( 497)					this68->width = width2;
HXDLIN( 497)					this68->height = height2;
HXDLIN( 497)					this68->imageType = ( (int)(imageType2) );
HXDLIN( 497)					undoImage6 = this68;
HXDLIN( 497)					{
HXDLIN( 497)						int rectLeft2 = xIter32->start;
HXDLIN( 497)						int rectTop2 = yIter32->start;
HXDLIN( 497)						int rectRight2 = xIter32->max;
HXDLIN( 497)						bool forceClear2 = false;
HXDLIN( 497)						{
HXDLIN( 497)							int _g56 = rectTop2;
HXDLIN( 497)							int _g57 = yIter32->max;
HXDLIN( 497)							while((_g56 < _g57)){
HXDLIN( 497)								_g56 = (_g56 + 1);
HXDLIN( 497)								int dy4 = (_g56 - 1);
HXDLIN( 497)								{
HXDLIN( 497)									int _g58 = rectLeft2;
HXDLIN( 497)									int _g59 = rectRight2;
HXDLIN( 497)									while((_g58 < _g59)){
HXDLIN( 497)										_g58 = (_g58 + 1);
HXDLIN( 497)										int dx4 = (_g58 - 1);
HXDLIN( 497)										::Dynamic this70 = this1->image;
HXDLIN( 497)										int index10;
HXDLIN( 497)										if (this1->useVirtualPos) {
HXDLIN( 497)											index10 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx4) - this1->virtualX));
            										}
            										else {
HXDLIN( 497)											index10 = ::Std_obj::_hx_int(( (Float)(((dy4 * this1->width) + dx4)) ));
            										}
HXDLIN( 497)										int c12 = ::iterMagic::Iimg_obj::get(this70,index10);
HXDLIN( 497)										int col2;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											col2 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											col2 = c12;
            										}
HXDLIN( 497)										bool hitQuad17;
HXDLIN( 497)										if (this1->useMask) {
HXDLIN( 497)											hitQuad17 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 497)											hitQuad17 = false;
            										}
HXDLIN( 497)										if (hitQuad17) {
HXDLIN( 497)											 ::pi_xy::ImageStruct this71 = this1->mask;
HXDLIN( 497)											::Dynamic this72 = this71->image;
HXDLIN( 497)											int index11;
HXDLIN( 497)											if (this71->useVirtualPos) {
HXDLIN( 497)												index11 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this71->virtualY) * ( (Float)(this71->width) )) + dx4) - this71->virtualX));
            											}
            											else {
HXDLIN( 497)												index11 = ::Std_obj::_hx_int(( (Float)(((dy4 * this71->width) + dx4)) ));
            											}
HXDLIN( 497)											int c13 = ::iterMagic::Iimg_obj::get(this72,index11);
HXDLIN( 497)											int v6;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												v6 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												v6 = c13;
            											}
HXDLIN( 497)											int maskPixel2 = v6;
HXDLIN( 497)											int this73 = col2;
HXDLIN( 497)											if ((maskPixel2 == 0)) {
HXDLIN( 497)												col2 = this73;
            											}
            											else {
HXDLIN( 497)												Float m02;
HXDLIN( 497)												int this74 = ((maskPixel2 >> 24) & 255);
HXDLIN( 497)												if ((this74 == 0)) {
HXDLIN( 497)													m02 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m02 = (( (Float)(this74) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m12;
HXDLIN( 497)												int this75 = ((maskPixel2 >> 16) & 255);
HXDLIN( 497)												if ((this75 == 0)) {
HXDLIN( 497)													m12 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m12 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m22;
HXDLIN( 497)												int this76 = ((maskPixel2 >> 8) & 255);
HXDLIN( 497)												if ((this76 == 0)) {
HXDLIN( 497)													m22 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m22 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m32;
HXDLIN( 497)												int this77 = (maskPixel2 & 255);
HXDLIN( 497)												if ((this77 == 0)) {
HXDLIN( 497)													m32 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m32 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this73 >> 24) & 255)) )));
HXDLIN( 497)												int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this73 >> 16) & 255)) )));
HXDLIN( 497)												int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this73 >> 8) & 255)) )));
HXDLIN( 497)												int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this73 & 255)) )));
HXDLIN( 497)												col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 497)										if ((col2 != 0)) {
HXDLIN( 497)											int x9 = (dx4 - rectLeft2);
HXDLIN( 497)											int y9 = (dy4 - rectTop2);
HXDLIN( 497)											int c14 = col2;
HXDLIN( 497)											bool hitQuad18;
HXDLIN( 497)											if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 497)												hitQuad18 = undoImage6->transparent;
            											}
            											else {
HXDLIN( 497)												hitQuad18 = false;
            											}
HXDLIN( 497)											if (hitQuad18) {
HXDLIN( 497)												int location4;
HXDLIN( 497)												if (undoImage6->useVirtualPos) {
HXDLIN( 497)													location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            												}
            												else {
HXDLIN( 497)													location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            												}
HXDLIN( 497)												int this78 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 497)												int this79;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													this79 = ((((((this78 >> 24) & 255) << 24) | ((this78 & 255) << 16)) | (((this78 >> 8) & 255) << 8)) | ((this78 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													this79 = this78;
            												}
HXDLIN( 497)												Float a18;
HXDLIN( 497)												int this80 = ((this79 >> 24) & 255);
HXDLIN( 497)												if ((this80 == 0)) {
HXDLIN( 497)													a18 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a18 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r14;
HXDLIN( 497)												int this81 = ((this79 >> 16) & 255);
HXDLIN( 497)												if ((this81 == 0)) {
HXDLIN( 497)													r14 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r14 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g14;
HXDLIN( 497)												int this82 = ((this79 >> 8) & 255);
HXDLIN( 497)												if ((this82 == 0)) {
HXDLIN( 497)													g14 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g14 = (( (Float)(this82) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b110;
HXDLIN( 497)												int this83 = (this79 & 255);
HXDLIN( 497)												if ((this83 == 0)) {
HXDLIN( 497)													b110 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b110 = (( (Float)(this83) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a24;
HXDLIN( 497)												int this84 = ((col2 >> 24) & 255);
HXDLIN( 497)												if ((this84 == 0)) {
HXDLIN( 497)													a24 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a24 = (( (Float)(this84) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r24;
HXDLIN( 497)												int this85 = ((col2 >> 16) & 255);
HXDLIN( 497)												if ((this85 == 0)) {
HXDLIN( 497)													r24 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r24 = (( (Float)(this85) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g24;
HXDLIN( 497)												int this86 = ((col2 >> 8) & 255);
HXDLIN( 497)												if ((this86 == 0)) {
HXDLIN( 497)													g24 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g24 = (( (Float)(this86) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b25;
HXDLIN( 497)												int this87 = (col2 & 255);
HXDLIN( 497)												if ((this87 == 0)) {
HXDLIN( 497)													b25 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b25 = (( (Float)(this87) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a34 = (a18 * (( (Float)(1) ) - a24));
HXDLIN( 497)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 497)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 497)												int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN( 497)												int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 497)												int blended4 = ((((a19 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN( 497)												{
HXDLIN( 497)													int hitQuad19;
HXDLIN( 497)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)														hitQuad19 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXDLIN( 497)														hitQuad19 = blended4;
            													}
HXDLIN( 497)													::iterMagic::Iimg_obj::set(undoImage6->image,location4,hitQuad19);
            												}
            											}
            											else {
HXDLIN( 497)												::Dynamic this88 = undoImage6->image;
HXDLIN( 497)												int index12;
HXDLIN( 497)												if (undoImage6->useVirtualPos) {
HXDLIN( 497)													index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            												}
            												else {
HXDLIN( 497)													index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            												}
HXDLIN( 497)												int hitQuad20;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad20 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad20 = c14;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this88,index12,hitQuad20);
            											}
            										}
            										else {
HXDLIN( 497)											if (forceClear2) {
HXDLIN( 497)												::Dynamic this89 = undoImage6->image;
HXDLIN( 497)												int x10 = (dx4 - rectLeft2);
HXDLIN( 497)												int y10 = (dy4 - rectTop2);
HXDLIN( 497)												int index13;
HXDLIN( 497)												if (undoImage6->useVirtualPos) {
HXDLIN( 497)													index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            												}
            												else {
HXDLIN( 497)													index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this89,index13,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 497)				bool found2 = false;
HXDLIN( 497)				Float s2 = ((Float)0.);
HXDLIN( 497)				Float t2 = ((Float)0.);
HXDLIN( 497)				Float sxx2 = ((Float)0.);
HXDLIN( 497)				Float txx2 = ((Float)0.);
HXDLIN( 497)				{
HXDLIN( 497)					int _g_min4 = xIter32->start;
HXDLIN( 497)					int _g_max4 = xIter32->max;
HXDLIN( 497)					while((_g_min4 < _g_max4)){
HXDLIN( 497)						_g_min4 = (_g_min4 + 1);
HXDLIN( 497)						int x11 = (_g_min4 - 1);
HXLINE(  60)						sxx2 = (sx2 * ( (Float)(x11) ));
HXLINE(  61)						txx2 = (tx2 * ( (Float)(x11) ));
HXLINE(  62)						found2 = false;
HXLINE( 497)						{
HXDLIN( 497)							int _g_min5 = yIter32->start;
HXDLIN( 497)							int _g_max5 = yIter32->max;
HXDLIN( 497)							while((_g_min5 < _g_max5)){
HXDLIN( 497)								_g_min5 = (_g_min5 + 1);
HXDLIN( 497)								int y11 = (_g_min5 - 1);
HXLINE(  64)								s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y11) )));
HXLINE(  65)								t2 = ((t02 + txx2) + (ty2 * ( (Float)(y11) )));
HXLINE( 497)								bool hitQuad21;
HXDLIN( 497)								if (!((s2 <= 0))) {
HXDLIN( 497)									hitQuad21 = (t2 <= 0);
            								}
            								else {
HXDLIN( 497)									hitQuad21 = true;
            								}
HXDLIN( 497)								if (hitQuad21) {
HXDLIN( 497)									if (found2) {
HXDLIN( 497)										goto _hx_goto_945;
            									}
            								}
            								else {
HXDLIN( 497)									if (((s2 + t2) < A2)) {
HXDLIN( 497)										{
HXDLIN( 497)											int c15 = color;
HXDLIN( 497)											bool hitQuad22;
HXDLIN( 497)											if ((((c15 >> 24) & 255) < 254)) {
HXDLIN( 497)												hitQuad22 = this1->transparent;
            											}
            											else {
HXDLIN( 497)												hitQuad22 = false;
            											}
HXDLIN( 497)											if (hitQuad22) {
HXDLIN( 497)												int location5;
HXDLIN( 497)												if (this1->useVirtualPos) {
HXDLIN( 497)													location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            												}
            												else {
HXDLIN( 497)													location5 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            												}
HXDLIN( 497)												int this90 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 497)												int this91;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													this91 = this90;
            												}
HXDLIN( 497)												Float a110;
HXDLIN( 497)												int this92 = ((this91 >> 24) & 255);
HXDLIN( 497)												if ((this92 == 0)) {
HXDLIN( 497)													a110 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a110 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r15;
HXDLIN( 497)												int this93 = ((this91 >> 16) & 255);
HXDLIN( 497)												if ((this93 == 0)) {
HXDLIN( 497)													r15 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r15 = (( (Float)(this93) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g15;
HXDLIN( 497)												int this94 = ((this91 >> 8) & 255);
HXDLIN( 497)												if ((this94 == 0)) {
HXDLIN( 497)													g15 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g15 = (( (Float)(this94) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b111;
HXDLIN( 497)												int this95 = (this91 & 255);
HXDLIN( 497)												if ((this95 == 0)) {
HXDLIN( 497)													b111 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b111 = (( (Float)(this95) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a25;
HXDLIN( 497)												int this96 = ((color >> 24) & 255);
HXDLIN( 497)												if ((this96 == 0)) {
HXDLIN( 497)													a25 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a25 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r25;
HXDLIN( 497)												int this97 = ((color >> 16) & 255);
HXDLIN( 497)												if ((this97 == 0)) {
HXDLIN( 497)													r25 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r25 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g25;
HXDLIN( 497)												int this98 = ((color >> 8) & 255);
HXDLIN( 497)												if ((this98 == 0)) {
HXDLIN( 497)													g25 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g25 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b27;
HXDLIN( 497)												int this99 = (color & 255);
HXDLIN( 497)												if ((this99 == 0)) {
HXDLIN( 497)													b27 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b27 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 497)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 497)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 497)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b27 * a25))));
HXDLIN( 497)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 497)												int blended5 = ((((a20 << 24) | (r7 << 16)) | (g7 << 8)) | b28);
HXDLIN( 497)												{
HXDLIN( 497)													int hitQuad23;
HXDLIN( 497)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)														hitQuad23 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXDLIN( 497)														hitQuad23 = blended5;
            													}
HXDLIN( 497)													::iterMagic::Iimg_obj::set(this1->image,location5,hitQuad23);
            												}
            											}
            											else {
HXDLIN( 497)												::Dynamic this100 = this1->image;
HXDLIN( 497)												int index14;
HXDLIN( 497)												if (this1->useVirtualPos) {
HXDLIN( 497)													index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            												}
            												else {
HXDLIN( 497)													index14 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            												}
HXDLIN( 497)												int hitQuad24;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad24 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad24 = c15;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this100,index14,hitQuad24);
            											}
            										}
HXLINE(  73)										found2 = true;
            									}
            									else {
HXDLIN( 497)										if (found2) {
HXDLIN( 497)											goto _hx_goto_945;
            										}
            									}
            								}
            							}
            							_hx_goto_945:;
            						}
            					}
            				}
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart v_yIter32;
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart v_xIter32;
HXDLIN( 497)				int v_undoY2;
HXDLIN( 497)				int v_undoX2;
HXDLIN( 497)				Float v_ty2;
HXDLIN( 497)				Float v_tx2;
HXDLIN( 497)				Float v_t02;
HXDLIN( 497)				Float v_sy2;
HXDLIN( 497)				Float v_sx2;
HXDLIN( 497)				Float v_s02;
HXDLIN( 497)				Float v_A2;
HXDLIN( 497)				Float ax4 = ax3;
HXDLIN( 497)				Float ay4 = ay3;
HXDLIN( 497)				 ::pi_xy::ImageStruct v_undoImage2 = null();
HXDLIN( 497)				Float bx7 = bx6;
HXDLIN( 497)				Float by7 = by6;
HXDLIN( 497)				Float cx7 = cx6;
HXDLIN( 497)				Float cy7 = cy6;
HXDLIN( 497)				bool adjustWinding5 = (((((ax4 * by7) - (bx7 * ay4)) + ((bx7 * cy7) - (cx7 * by7))) + ((cx7 * ay4) - (ax4 * cy7))) > 0);
HXDLIN( 497)				if (!(adjustWinding5)) {
HXDLIN( 497)					Float bx_5 = bx7;
HXDLIN( 497)					Float by_5 = by7;
HXLINE(  24)					bx7 = cx7;
HXLINE(  25)					by7 = cy7;
HXLINE(  26)					cx7 = bx_5;
HXLINE(  27)					cy7 = by_5;
            				}
HXLINE( 497)				Float v_ax2 = ax4;
HXDLIN( 497)				Float v_ay2 = ay4;
HXDLIN( 497)				Float v_bx2 = bx7;
HXDLIN( 497)				Float v_by2 = by7;
HXDLIN( 497)				Float v_cx2 = cx7;
HXDLIN( 497)				Float v_cy2 = cy7;
HXDLIN( 497)				bool v_preCalculated2 = true;
HXDLIN( 497)				{
HXDLIN( 497)					v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN( 497)					v_sx2 = (v_cy2 - v_ay2);
HXDLIN( 497)					v_sy2 = (v_ax2 - v_cx2);
HXDLIN( 497)					v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN( 497)					v_tx2 = (v_ay2 - v_by2);
HXDLIN( 497)					v_ty2 = (v_bx2 - v_ax2);
HXDLIN( 497)					v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN( 497)					Float a26 = v_ax2;
HXDLIN( 497)					Float b29 = v_bx2;
HXDLIN( 497)					Float c16 = v_cx2;
HXDLIN( 497)					if ((a26 > b29)) {
HXDLIN( 497)						if ((a26 > c16)) {
HXDLIN( 497)							int min20;
HXDLIN( 497)							if ((b29 > c16)) {
HXDLIN( 497)								min20 = ::Math_obj::floor(c16);
            							}
            							else {
HXDLIN( 497)								min20 = ::Math_obj::floor(b29);
            							}
HXDLIN( 497)							int ii_min40 = min20;
HXDLIN( 497)							int ii_max40 = ::Math_obj::ceil(a26);
HXDLIN( 497)							v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            						}
            						else {
HXDLIN( 497)							int ii_min41 = ::Math_obj::floor(b29);
HXDLIN( 497)							int ii_max41 = ::Math_obj::ceil(c16);
HXDLIN( 497)							v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            						}
            					}
            					else {
HXDLIN( 497)						if ((b29 > c16)) {
HXDLIN( 497)							int min21;
HXDLIN( 497)							if ((a26 > c16)) {
HXDLIN( 497)								min21 = ::Math_obj::floor(c16);
            							}
            							else {
HXDLIN( 497)								min21 = ::Math_obj::ceil(a26);
            							}
HXDLIN( 497)							int ii_min42 = min21;
HXDLIN( 497)							int ii_max42 = ::Math_obj::ceil(b29);
HXDLIN( 497)							v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            						}
            						else {
HXDLIN( 497)							int ii_min43 = ::Math_obj::floor(a26);
HXDLIN( 497)							int ii_max43 = ::Math_obj::ceil(c16);
HXDLIN( 497)							v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            						}
            					}
HXDLIN( 497)					Float a27 = v_ay2;
HXDLIN( 497)					Float b30 = v_by2;
HXDLIN( 497)					Float c17 = v_cy2;
HXDLIN( 497)					if ((a27 > b30)) {
HXDLIN( 497)						if ((a27 > c17)) {
HXDLIN( 497)							int min22;
HXDLIN( 497)							if ((b30 > c17)) {
HXDLIN( 497)								min22 = ::Math_obj::floor(c17);
            							}
            							else {
HXDLIN( 497)								min22 = ::Math_obj::floor(b30);
            							}
HXDLIN( 497)							int ii_min44 = min22;
HXDLIN( 497)							int ii_max44 = ::Math_obj::ceil(a27);
HXDLIN( 497)							v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            						}
            						else {
HXDLIN( 497)							int ii_min45 = ::Math_obj::floor(b30);
HXDLIN( 497)							int ii_max45 = ::Math_obj::ceil(c17);
HXDLIN( 497)							v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            						}
            					}
            					else {
HXDLIN( 497)						if ((b30 > c17)) {
HXDLIN( 497)							int min23;
HXDLIN( 497)							if ((a27 > c17)) {
HXDLIN( 497)								min23 = ::Math_obj::floor(c17);
            							}
            							else {
HXDLIN( 497)								min23 = ::Math_obj::ceil(a27);
            							}
HXDLIN( 497)							int ii_min46 = min23;
HXDLIN( 497)							int ii_max46 = ::Math_obj::ceil(b30);
HXDLIN( 497)							v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            						}
            						else {
HXDLIN( 497)							int ii_min47 = ::Math_obj::floor(a27);
HXDLIN( 497)							int ii_max47 = ::Math_obj::ceil(c17);
HXDLIN( 497)							v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            						}
            					}
            				}
HXDLIN( 497)				if (hasUndo2) {
HXDLIN( 497)					v_undoImage2 = undoImage6;
HXDLIN( 497)					v_undoX2 = xIter32->start;
HXDLIN( 497)					v_undoY2 = yIter32->start;
            				}
HXDLIN( 497)				Float bx8 = cx5;
HXDLIN( 497)				Float by8 = cy5;
HXDLIN( 497)				Float cx8 = dx3;
HXDLIN( 497)				Float cy8 = dy3;
HXDLIN( 497)				bool hasUndo3 = false;
HXDLIN( 497)				bool adjustWinding6 = (((((bx5 * by8) - (bx8 * by5)) + ((bx8 * cy8) - (cx8 * by8))) + ((cx8 * by5) - (bx5 * cy8))) > 0);
HXDLIN( 497)				if (!(adjustWinding6)) {
HXDLIN( 497)					Float bx_6 = bx8;
HXDLIN( 497)					Float by_6 = by8;
HXLINE(  25)					bx8 = cx8;
HXLINE(  26)					by8 = cy8;
HXLINE(  27)					cx8 = bx_6;
HXLINE(  28)					cy8 = by_6;
            				}
HXLINE( 497)				Float s03 = ((by5 * cx8) - (bx5 * cy8));
HXDLIN( 497)				Float sx3 = (cy8 - by5);
HXDLIN( 497)				Float sy3 = (bx5 - cx8);
HXDLIN( 497)				Float t03 = ((bx5 * by8) - (by5 * bx8));
HXDLIN( 497)				Float tx3 = (by5 - by8);
HXDLIN( 497)				Float ty3 = (bx8 - bx5);
HXDLIN( 497)				Float A3 = ((((-(by8) * cx8) + (by5 * (-(bx8) + cx8))) + (bx5 * (by8 - cy8))) + (bx8 * cy8));
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 497)				if ((bx5 > bx8)) {
HXDLIN( 497)					if ((bx5 > cx8)) {
HXDLIN( 497)						int min24;
HXDLIN( 497)						if ((bx8 > cx8)) {
HXDLIN( 497)							min24 = ::Math_obj::floor(cx8);
            						}
            						else {
HXDLIN( 497)							min24 = ::Math_obj::floor(bx8);
            						}
HXDLIN( 497)						int ii_min48 = min24;
HXDLIN( 497)						int ii_max48 = ::Math_obj::ceil(bx5);
HXDLIN( 497)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            					}
            					else {
HXDLIN( 497)						int ii_min49 = ::Math_obj::floor(bx8);
HXDLIN( 497)						int ii_max49 = ::Math_obj::ceil(cx8);
HXDLIN( 497)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            					}
            				}
            				else {
HXDLIN( 497)					if ((bx8 > cx8)) {
HXDLIN( 497)						int min25;
HXDLIN( 497)						if ((bx5 > cx8)) {
HXDLIN( 497)							min25 = ::Math_obj::floor(cx8);
            						}
            						else {
HXDLIN( 497)							min25 = ::Math_obj::ceil(bx5);
            						}
HXDLIN( 497)						int ii_min50 = min25;
HXDLIN( 497)						int ii_max50 = ::Math_obj::ceil(bx8);
HXDLIN( 497)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            					}
            					else {
HXDLIN( 497)						int ii_min51 = ::Math_obj::floor(bx5);
HXDLIN( 497)						int ii_max51 = ::Math_obj::ceil(cx8);
HXDLIN( 497)						xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            					}
            				}
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 497)				if ((by5 > by8)) {
HXDLIN( 497)					if ((by5 > cy8)) {
HXDLIN( 497)						int min26;
HXDLIN( 497)						if ((by8 > cy8)) {
HXDLIN( 497)							min26 = ::Math_obj::floor(cy8);
            						}
            						else {
HXDLIN( 497)							min26 = ::Math_obj::floor(by8);
            						}
HXDLIN( 497)						int ii_min52 = min26;
HXDLIN( 497)						int ii_max52 = ::Math_obj::ceil(by5);
HXDLIN( 497)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            					}
            					else {
HXDLIN( 497)						int ii_min53 = ::Math_obj::floor(by8);
HXDLIN( 497)						int ii_max53 = ::Math_obj::ceil(cy8);
HXDLIN( 497)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            					}
            				}
            				else {
HXDLIN( 497)					if ((by8 > cy8)) {
HXDLIN( 497)						int min27;
HXDLIN( 497)						if ((by5 > cy8)) {
HXDLIN( 497)							min27 = ::Math_obj::floor(cy8);
            						}
            						else {
HXDLIN( 497)							min27 = ::Math_obj::ceil(by5);
            						}
HXDLIN( 497)						int ii_min54 = min27;
HXDLIN( 497)						int ii_max54 = ::Math_obj::ceil(by8);
HXDLIN( 497)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            					}
            					else {
HXDLIN( 497)						int ii_min55 = ::Math_obj::floor(by5);
HXDLIN( 497)						int ii_max55 = ::Math_obj::ceil(cy8);
HXDLIN( 497)						yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            					}
            				}
HXDLIN( 497)				 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 497)				if (hasUndo3) {
HXDLIN( 497)					int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 497)					int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 497)					 ::Dynamic imageType3 = null();
HXDLIN( 497)					 ::pi_xy::ImageStruct this101 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 497)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 497)					::Dynamic undoImage10;
HXDLIN( 497)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXDLIN( 497)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::BytesImg b31 = byt3;
HXDLIN( 497)							{
HXDLIN( 497)								b31->width = width3;
HXDLIN( 497)								b31->height = height3;
HXDLIN( 497)								b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 497)								b31->data = ::haxe::io::Bytes_obj::alloc((b31->length * 4));
HXDLIN( 497)								{
HXDLIN( 497)									int len6 = b31->length;
HXDLIN( 497)									int w3 = 0;
HXDLIN( 497)									{
HXDLIN( 497)										int _g60 = 0;
HXDLIN( 497)										int _g61 = b31->height;
HXDLIN( 497)										while((_g60 < _g61)){
HXDLIN( 497)											_g60 = (_g60 + 1);
HXDLIN( 497)											int y12 = (_g60 - 1);
HXDLIN( 497)											{
HXDLIN( 497)												int _g62 = 0;
HXDLIN( 497)												int _g63 = b31->width;
HXDLIN( 497)												while((_g62 < _g63)){
HXDLIN( 497)													_g62 = (_g62 + 1);
HXDLIN( 497)													int x12 = (_g62 - 1);
HXDLIN( 497)													{
HXDLIN( 497)														w3 = (w3 + 1);
HXDLIN( 497)														b31->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w3 = (w3 + 1);
HXDLIN( 497)														b31->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w3 = (w3 + 1);
HXDLIN( 497)														b31->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 497)													{
HXDLIN( 497)														w3 = (w3 + 1);
HXDLIN( 497)														b31->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage10 = b31;
            						}
            						break;
            						case (int)1: {
HXDLIN( 497)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::ArrIntImg a28 = arrI3;
HXDLIN( 497)							{
HXDLIN( 497)								a28->width = width3;
HXDLIN( 497)								a28->height = height3;
HXDLIN( 497)								a28->data = ::Array_obj< int >::__new(0);
HXDLIN( 497)								a28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 497)								{
HXDLIN( 497)									int _g64 = 0;
HXDLIN( 497)									int _g65 = a28->length;
HXDLIN( 497)									while((_g64 < _g65)){
HXDLIN( 497)										_g64 = (_g64 + 1);
HXDLIN( 497)										int i18 = (_g64 - 1);
HXDLIN( 497)										a28->data[i18] = 0;
            									}
            								}
            							}
HXDLIN( 497)							undoImage10 = a28;
            						}
            						break;
            						case (int)2: {
HXDLIN( 497)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::U32ArrImg b32 = u32a3;
HXDLIN( 497)							{
HXDLIN( 497)								b32->width = width3;
HXDLIN( 497)								b32->height = height3;
HXDLIN( 497)								b32->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 497)								int size3 = (b32->length * 4);
HXDLIN( 497)								b32->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 497)								{
HXDLIN( 497)									int _g66 = 0;
HXDLIN( 497)									int _g67 = b32->length;
HXDLIN( 497)									while((_g66 < _g67)){
HXDLIN( 497)										_g66 = (_g66 + 1);
HXDLIN( 497)										int i19 = (_g66 - 1);
HXDLIN( 497)										{
HXDLIN( 497)											 ::haxe::io::ArrayBufferViewImpl this102 = b32->data;
HXDLIN( 497)											bool undoImage11;
HXDLIN( 497)											if ((i19 >= 0)) {
HXDLIN( 497)												undoImage11 = (i19 < (this102->byteLength >> 2));
            											}
            											else {
HXDLIN( 497)												undoImage11 = false;
            											}
HXDLIN( 497)											if (undoImage11) {
HXDLIN( 497)												 ::haxe::io::Bytes _this3 = this102->bytes;
HXDLIN( 497)												int pos3 = ((i19 << 2) + this102->byteOffset);
HXDLIN( 497)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 497)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 497)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 497)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage10 = b32;
            						}
            						break;
            						case (int)3: {
HXDLIN( 497)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::VecIntImg v7 = vec3;
HXDLIN( 497)							{
HXDLIN( 497)								v7->width = width3;
HXDLIN( 497)								v7->height = height3;
HXDLIN( 497)								v7->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 497)								v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN( 497)								{
HXDLIN( 497)									int _g68 = 0;
HXDLIN( 497)									int _g69 = v7->length;
HXDLIN( 497)									while((_g68 < _g69)){
HXDLIN( 497)										_g68 = (_g68 + 1);
HXDLIN( 497)										int i20 = (_g68 - 1);
HXDLIN( 497)										v7->data->__unsafe_set(i20,0);
            									}
            								}
            							}
HXDLIN( 497)							undoImage10 = v7;
            						}
            						break;
            						case (int)4: {
HXDLIN( 497)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)							 ::iterMagic::StackIntImg b33 = sInt3;
HXDLIN( 497)							{
HXDLIN( 497)								b33->width = width3;
HXDLIN( 497)								b33->height = height3;
HXDLIN( 497)								b33->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 497)								b33->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 497)								{
HXDLIN( 497)									int len7 = b33->length;
HXDLIN( 497)									 ::haxe::ds::GenericStack_Int d3 = b33->data;
HXDLIN( 497)									if (::hx::IsNull( d3->head )) {
HXDLIN( 497)										int _g70 = 0;
HXDLIN( 497)										int _g71 = len7;
HXDLIN( 497)										while((_g70 < _g71)){
HXDLIN( 497)											_g70 = (_g70 + 1);
HXDLIN( 497)											int i21 = (_g70 - 1);
HXDLIN( 497)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXDLIN( 497)										int _g72 = 0;
HXDLIN( 497)										int _g73 = len7;
HXDLIN( 497)										while((_g72 < _g73)){
HXDLIN( 497)											_g72 = (_g72 + 1);
HXDLIN( 497)											int i22 = (_g72 - 1);
HXDLIN( 497)											{
HXDLIN( 497)												 ::haxe::ds::GenericCell_Int l3 = b33->data->head;
HXDLIN( 497)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 497)												{
HXDLIN( 497)													int _g74 = 0;
HXDLIN( 497)													int _g75 = i22;
HXDLIN( 497)													while((_g74 < _g75)){
HXDLIN( 497)														_g74 = (_g74 + 1);
HXDLIN( 497)														int i23 = (_g74 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE( 497)												if (::hx::IsNull( prev3 )) {
HXDLIN( 497)													b33->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 497)													l3 = null();
            												}
            												else {
HXDLIN( 497)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 497)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 497)							undoImage10 = b33;
            						}
            						break;
            					}
HXDLIN( 497)					this101->image = undoImage10;
HXDLIN( 497)					this101->width = width3;
HXDLIN( 497)					this101->height = height3;
HXDLIN( 497)					this101->imageType = ( (int)(imageType3) );
HXDLIN( 497)					undoImage9 = this101;
HXDLIN( 497)					{
HXDLIN( 497)						int rectLeft3 = xIter33->start;
HXDLIN( 497)						int rectTop3 = yIter33->start;
HXDLIN( 497)						int rectRight3 = xIter33->max;
HXDLIN( 497)						bool forceClear3 = false;
HXDLIN( 497)						{
HXDLIN( 497)							int _g76 = rectTop3;
HXDLIN( 497)							int _g77 = yIter33->max;
HXDLIN( 497)							while((_g76 < _g77)){
HXDLIN( 497)								_g76 = (_g76 + 1);
HXDLIN( 497)								int dy5 = (_g76 - 1);
HXDLIN( 497)								{
HXDLIN( 497)									int _g78 = rectLeft3;
HXDLIN( 497)									int _g79 = rectRight3;
HXDLIN( 497)									while((_g78 < _g79)){
HXDLIN( 497)										_g78 = (_g78 + 1);
HXDLIN( 497)										int dx5 = (_g78 - 1);
HXDLIN( 497)										::Dynamic this103 = this1->image;
HXDLIN( 497)										int index15;
HXDLIN( 497)										if (this1->useVirtualPos) {
HXDLIN( 497)											index15 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx5) - this1->virtualX));
            										}
            										else {
HXDLIN( 497)											index15 = ::Std_obj::_hx_int(( (Float)(((dy5 * this1->width) + dx5)) ));
            										}
HXDLIN( 497)										int c18 = ::iterMagic::Iimg_obj::get(this103,index15);
HXDLIN( 497)										int col3;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											col3 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											col3 = c18;
            										}
HXDLIN( 497)										bool hitQuad25;
HXDLIN( 497)										if (this1->useMask) {
HXDLIN( 497)											hitQuad25 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN( 497)											hitQuad25 = false;
            										}
HXDLIN( 497)										if (hitQuad25) {
HXDLIN( 497)											 ::pi_xy::ImageStruct this104 = this1->mask;
HXDLIN( 497)											::Dynamic this105 = this104->image;
HXDLIN( 497)											int index16;
HXDLIN( 497)											if (this104->useVirtualPos) {
HXDLIN( 497)												index16 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this104->virtualY) * ( (Float)(this104->width) )) + dx5) - this104->virtualX));
            											}
            											else {
HXDLIN( 497)												index16 = ::Std_obj::_hx_int(( (Float)(((dy5 * this104->width) + dx5)) ));
            											}
HXDLIN( 497)											int c19 = ::iterMagic::Iimg_obj::get(this105,index16);
HXDLIN( 497)											int v8;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												v8 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												v8 = c19;
            											}
HXDLIN( 497)											int maskPixel3 = v8;
HXDLIN( 497)											int this106 = col3;
HXDLIN( 497)											if ((maskPixel3 == 0)) {
HXDLIN( 497)												col3 = this106;
            											}
            											else {
HXDLIN( 497)												Float m03;
HXDLIN( 497)												int this107 = ((maskPixel3 >> 24) & 255);
HXDLIN( 497)												if ((this107 == 0)) {
HXDLIN( 497)													m03 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m03 = (( (Float)(this107) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m13;
HXDLIN( 497)												int this108 = ((maskPixel3 >> 16) & 255);
HXDLIN( 497)												if ((this108 == 0)) {
HXDLIN( 497)													m13 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m13 = (( (Float)(this108) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m23;
HXDLIN( 497)												int this109 = ((maskPixel3 >> 8) & 255);
HXDLIN( 497)												if ((this109 == 0)) {
HXDLIN( 497)													m23 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m23 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float m33;
HXDLIN( 497)												int this110 = (maskPixel3 & 255);
HXDLIN( 497)												if ((this110 == 0)) {
HXDLIN( 497)													m33 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													m33 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this106 >> 24) & 255)) )));
HXDLIN( 497)												int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this106 >> 16) & 255)) )));
HXDLIN( 497)												int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this106 >> 8) & 255)) )));
HXDLIN( 497)												int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this106 & 255)) )));
HXDLIN( 497)												col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 497)										if ((col3 != 0)) {
HXDLIN( 497)											int x13 = (dx5 - rectLeft3);
HXDLIN( 497)											int y13 = (dy5 - rectTop3);
HXDLIN( 497)											int c20 = col3;
HXDLIN( 497)											bool hitQuad26;
HXDLIN( 497)											if ((((c20 >> 24) & 255) < 254)) {
HXDLIN( 497)												hitQuad26 = undoImage9->transparent;
            											}
            											else {
HXDLIN( 497)												hitQuad26 = false;
            											}
HXDLIN( 497)											if (hitQuad26) {
HXDLIN( 497)												int location6;
HXDLIN( 497)												if (undoImage9->useVirtualPos) {
HXDLIN( 497)													location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            												}
            												else {
HXDLIN( 497)													location6 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            												}
HXDLIN( 497)												int this111 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 497)												int this112;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													this112 = ((((((this111 >> 24) & 255) << 24) | ((this111 & 255) << 16)) | (((this111 >> 8) & 255) << 8)) | ((this111 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													this112 = this111;
            												}
HXDLIN( 497)												Float a111;
HXDLIN( 497)												int this113 = ((this112 >> 24) & 255);
HXDLIN( 497)												if ((this113 == 0)) {
HXDLIN( 497)													a111 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a111 = (( (Float)(this113) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r16;
HXDLIN( 497)												int this114 = ((this112 >> 16) & 255);
HXDLIN( 497)												if ((this114 == 0)) {
HXDLIN( 497)													r16 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r16 = (( (Float)(this114) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g16;
HXDLIN( 497)												int this115 = ((this112 >> 8) & 255);
HXDLIN( 497)												if ((this115 == 0)) {
HXDLIN( 497)													g16 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g16 = (( (Float)(this115) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b112;
HXDLIN( 497)												int this116 = (this112 & 255);
HXDLIN( 497)												if ((this116 == 0)) {
HXDLIN( 497)													b112 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b112 = (( (Float)(this116) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a29;
HXDLIN( 497)												int this117 = ((col3 >> 24) & 255);
HXDLIN( 497)												if ((this117 == 0)) {
HXDLIN( 497)													a29 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a29 = (( (Float)(this117) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r26;
HXDLIN( 497)												int this118 = ((col3 >> 16) & 255);
HXDLIN( 497)												if ((this118 == 0)) {
HXDLIN( 497)													r26 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r26 = (( (Float)(this118) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g26;
HXDLIN( 497)												int this119 = ((col3 >> 8) & 255);
HXDLIN( 497)												if ((this119 == 0)) {
HXDLIN( 497)													g26 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g26 = (( (Float)(this119) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b210;
HXDLIN( 497)												int this120 = (col3 & 255);
HXDLIN( 497)												if ((this120 == 0)) {
HXDLIN( 497)													b210 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b210 = (( (Float)(this120) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a36 = (a111 * (( (Float)(1) ) - a29));
HXDLIN( 497)												int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a29))));
HXDLIN( 497)												int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a29))));
HXDLIN( 497)												int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a29))));
HXDLIN( 497)												int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a29)));
HXDLIN( 497)												int blended6 = ((((a30 << 24) | (r8 << 16)) | (g8 << 8)) | b34);
HXDLIN( 497)												{
HXDLIN( 497)													int hitQuad27;
HXDLIN( 497)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)														hitQuad27 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXDLIN( 497)														hitQuad27 = blended6;
            													}
HXDLIN( 497)													::iterMagic::Iimg_obj::set(undoImage9->image,location6,hitQuad27);
            												}
            											}
            											else {
HXDLIN( 497)												::Dynamic this121 = undoImage9->image;
HXDLIN( 497)												int index17;
HXDLIN( 497)												if (undoImage9->useVirtualPos) {
HXDLIN( 497)													index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            												}
            												else {
HXDLIN( 497)													index17 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            												}
HXDLIN( 497)												int hitQuad28;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad28 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad28 = c20;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this121,index17,hitQuad28);
            											}
            										}
            										else {
HXDLIN( 497)											if (forceClear3) {
HXDLIN( 497)												::Dynamic this122 = undoImage9->image;
HXDLIN( 497)												int x14 = (dx5 - rectLeft3);
HXDLIN( 497)												int y14 = (dy5 - rectTop3);
HXDLIN( 497)												int index18;
HXDLIN( 497)												if (undoImage9->useVirtualPos) {
HXDLIN( 497)													index18 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            												}
            												else {
HXDLIN( 497)													index18 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this122,index18,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 497)				bool found3 = false;
HXDLIN( 497)				Float s3 = ((Float)0.);
HXDLIN( 497)				Float t3 = ((Float)0.);
HXDLIN( 497)				Float sxx3 = ((Float)0.);
HXDLIN( 497)				Float txx3 = ((Float)0.);
HXDLIN( 497)				{
HXDLIN( 497)					int _g_min6 = xIter33->start;
HXDLIN( 497)					int _g_max6 = xIter33->max;
HXDLIN( 497)					while((_g_min6 < _g_max6)){
HXDLIN( 497)						_g_min6 = (_g_min6 + 1);
HXDLIN( 497)						int x15 = (_g_min6 - 1);
HXLINE(  60)						sxx3 = (sx3 * ( (Float)(x15) ));
HXLINE(  61)						txx3 = (tx3 * ( (Float)(x15) ));
HXLINE(  62)						found3 = false;
HXLINE( 497)						{
HXDLIN( 497)							int _g_min7 = yIter33->start;
HXDLIN( 497)							int _g_max7 = yIter33->max;
HXDLIN( 497)							while((_g_min7 < _g_max7)){
HXDLIN( 497)								_g_min7 = (_g_min7 + 1);
HXDLIN( 497)								int y15 = (_g_min7 - 1);
HXLINE(  64)								s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y15) )));
HXLINE(  65)								t3 = ((t03 + txx3) + (ty3 * ( (Float)(y15) )));
HXLINE( 497)								bool hitQuad29;
HXDLIN( 497)								if (!((s3 <= 0))) {
HXDLIN( 497)									hitQuad29 = (t3 <= 0);
            								}
            								else {
HXDLIN( 497)									hitQuad29 = true;
            								}
HXDLIN( 497)								if (hitQuad29) {
HXDLIN( 497)									if (found3) {
HXDLIN( 497)										goto _hx_goto_957;
            									}
            								}
            								else {
HXDLIN( 497)									if (((s3 + t3) < A3)) {
HXDLIN( 497)										{
HXDLIN( 497)											int c21 = color;
HXDLIN( 497)											bool hitQuad30;
HXDLIN( 497)											if ((((c21 >> 24) & 255) < 254)) {
HXDLIN( 497)												hitQuad30 = this1->transparent;
            											}
            											else {
HXDLIN( 497)												hitQuad30 = false;
            											}
HXDLIN( 497)											if (hitQuad30) {
HXDLIN( 497)												int location7;
HXDLIN( 497)												if (this1->useVirtualPos) {
HXDLIN( 497)													location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            												}
            												else {
HXDLIN( 497)													location7 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            												}
HXDLIN( 497)												int this123 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN( 497)												int this124;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													this124 = ((((((this123 >> 24) & 255) << 24) | ((this123 & 255) << 16)) | (((this123 >> 8) & 255) << 8)) | ((this123 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													this124 = this123;
            												}
HXDLIN( 497)												Float a112;
HXDLIN( 497)												int this125 = ((this124 >> 24) & 255);
HXDLIN( 497)												if ((this125 == 0)) {
HXDLIN( 497)													a112 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a112 = (( (Float)(this125) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r17;
HXDLIN( 497)												int this126 = ((this124 >> 16) & 255);
HXDLIN( 497)												if ((this126 == 0)) {
HXDLIN( 497)													r17 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r17 = (( (Float)(this126) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g17;
HXDLIN( 497)												int this127 = ((this124 >> 8) & 255);
HXDLIN( 497)												if ((this127 == 0)) {
HXDLIN( 497)													g17 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g17 = (( (Float)(this127) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b113;
HXDLIN( 497)												int this128 = (this124 & 255);
HXDLIN( 497)												if ((this128 == 0)) {
HXDLIN( 497)													b113 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b113 = (( (Float)(this128) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a210;
HXDLIN( 497)												int this129 = ((color >> 24) & 255);
HXDLIN( 497)												if ((this129 == 0)) {
HXDLIN( 497)													a210 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													a210 = (( (Float)(this129) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float r27;
HXDLIN( 497)												int this130 = ((color >> 16) & 255);
HXDLIN( 497)												if ((this130 == 0)) {
HXDLIN( 497)													r27 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													r27 = (( (Float)(this130) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float g27;
HXDLIN( 497)												int this131 = ((color >> 8) & 255);
HXDLIN( 497)												if ((this131 == 0)) {
HXDLIN( 497)													g27 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													g27 = (( (Float)(this131) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float b211;
HXDLIN( 497)												int this132 = (color & 255);
HXDLIN( 497)												if ((this132 == 0)) {
HXDLIN( 497)													b211 = ((Float)0.);
            												}
            												else {
HXDLIN( 497)													b211 = (( (Float)(this132) ) / ( (Float)(255) ));
            												}
HXDLIN( 497)												Float a37 = (a112 * (( (Float)(1) ) - a210));
HXDLIN( 497)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a210))));
HXDLIN( 497)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a210))));
HXDLIN( 497)												int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a210))));
HXDLIN( 497)												int a38 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a210)));
HXDLIN( 497)												int blended7 = ((((a38 << 24) | (r9 << 16)) | (g9 << 8)) | b35);
HXDLIN( 497)												{
HXDLIN( 497)													int hitQuad31;
HXDLIN( 497)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)														hitQuad31 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXDLIN( 497)														hitQuad31 = blended7;
            													}
HXDLIN( 497)													::iterMagic::Iimg_obj::set(this1->image,location7,hitQuad31);
            												}
            											}
            											else {
HXDLIN( 497)												::Dynamic this133 = this1->image;
HXDLIN( 497)												int index19;
HXDLIN( 497)												if (this1->useVirtualPos) {
HXDLIN( 497)													index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            												}
            												else {
HXDLIN( 497)													index19 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            												}
HXDLIN( 497)												int hitQuad32;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad32 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad32 = c21;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this133,index19,hitQuad32);
            											}
            										}
HXLINE(  73)										found3 = true;
            									}
            									else {
HXDLIN( 497)										if (found3) {
HXDLIN( 497)											goto _hx_goto_957;
            										}
            									}
            								}
            							}
            							_hx_goto_957:;
            						}
            					}
            				}
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart v_yIter33;
HXDLIN( 497)				 ::pi_xy::iter::IntIterStart v_xIter33;
HXDLIN( 497)				int v_undoY3;
HXDLIN( 497)				int v_undoX3;
HXDLIN( 497)				Float v_ty3;
HXDLIN( 497)				Float v_tx3;
HXDLIN( 497)				Float v_t03;
HXDLIN( 497)				Float v_sy3;
HXDLIN( 497)				Float v_sx3;
HXDLIN( 497)				Float v_s03;
HXDLIN( 497)				Float v_A3;
HXDLIN( 497)				Float ax5 = bx5;
HXDLIN( 497)				Float ay5 = by5;
HXDLIN( 497)				 ::pi_xy::ImageStruct v_undoImage3 = null();
HXDLIN( 497)				Float bx9 = bx8;
HXDLIN( 497)				Float by9 = by8;
HXDLIN( 497)				Float cx9 = cx8;
HXDLIN( 497)				Float cy9 = cy8;
HXDLIN( 497)				bool adjustWinding7 = (((((ax5 * by9) - (bx9 * ay5)) + ((bx9 * cy9) - (cx9 * by9))) + ((cx9 * ay5) - (ax5 * cy9))) > 0);
HXDLIN( 497)				if (!(adjustWinding7)) {
HXDLIN( 497)					Float bx_7 = bx9;
HXDLIN( 497)					Float by_7 = by9;
HXLINE(  24)					bx9 = cx9;
HXLINE(  25)					by9 = cy9;
HXLINE(  26)					cx9 = bx_7;
HXLINE(  27)					cy9 = by_7;
            				}
HXLINE( 497)				Float v_ax3 = ax5;
HXDLIN( 497)				Float v_ay3 = ay5;
HXDLIN( 497)				Float v_bx3 = bx9;
HXDLIN( 497)				Float v_by3 = by9;
HXDLIN( 497)				Float v_cx3 = cx9;
HXDLIN( 497)				Float v_cy3 = cy9;
HXDLIN( 497)				bool v_preCalculated3 = true;
HXDLIN( 497)				{
HXDLIN( 497)					v_s03 = ((v_ay3 * v_cx3) - (v_ax3 * v_cy3));
HXDLIN( 497)					v_sx3 = (v_cy3 - v_ay3);
HXDLIN( 497)					v_sy3 = (v_ax3 - v_cx3);
HXDLIN( 497)					v_t03 = ((v_ax3 * v_by3) - (v_ay3 * v_bx3));
HXDLIN( 497)					v_tx3 = (v_ay3 - v_by3);
HXDLIN( 497)					v_ty3 = (v_bx3 - v_ax3);
HXDLIN( 497)					v_A3 = ((((-(v_by3) * v_cx3) + (v_ay3 * (-(v_bx3) + v_cx3))) + (v_ax3 * (v_by3 - v_cy3))) + (v_bx3 * v_cy3));
HXDLIN( 497)					Float a39 = v_ax3;
HXDLIN( 497)					Float b36 = v_bx3;
HXDLIN( 497)					Float c22 = v_cx3;
HXDLIN( 497)					if ((a39 > b36)) {
HXDLIN( 497)						if ((a39 > c22)) {
HXDLIN( 497)							int min28;
HXDLIN( 497)							if ((b36 > c22)) {
HXDLIN( 497)								min28 = ::Math_obj::floor(c22);
            							}
            							else {
HXDLIN( 497)								min28 = ::Math_obj::floor(b36);
            							}
HXDLIN( 497)							int ii_min56 = min28;
HXDLIN( 497)							int ii_max56 = ::Math_obj::ceil(a39);
HXDLIN( 497)							v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            						}
            						else {
HXDLIN( 497)							int ii_min57 = ::Math_obj::floor(b36);
HXDLIN( 497)							int ii_max57 = ::Math_obj::ceil(c22);
HXDLIN( 497)							v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            						}
            					}
            					else {
HXDLIN( 497)						if ((b36 > c22)) {
HXDLIN( 497)							int min29;
HXDLIN( 497)							if ((a39 > c22)) {
HXDLIN( 497)								min29 = ::Math_obj::floor(c22);
            							}
            							else {
HXDLIN( 497)								min29 = ::Math_obj::ceil(a39);
            							}
HXDLIN( 497)							int ii_min58 = min29;
HXDLIN( 497)							int ii_max58 = ::Math_obj::ceil(b36);
HXDLIN( 497)							v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            						}
            						else {
HXDLIN( 497)							int ii_min59 = ::Math_obj::floor(a39);
HXDLIN( 497)							int ii_max59 = ::Math_obj::ceil(c22);
HXDLIN( 497)							v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            						}
            					}
HXDLIN( 497)					Float a40 = v_ay3;
HXDLIN( 497)					Float b37 = v_by3;
HXDLIN( 497)					Float c23 = v_cy3;
HXDLIN( 497)					if ((a40 > b37)) {
HXDLIN( 497)						if ((a40 > c23)) {
HXDLIN( 497)							int min30;
HXDLIN( 497)							if ((b37 > c23)) {
HXDLIN( 497)								min30 = ::Math_obj::floor(c23);
            							}
            							else {
HXDLIN( 497)								min30 = ::Math_obj::floor(b37);
            							}
HXDLIN( 497)							int ii_min60 = min30;
HXDLIN( 497)							int ii_max60 = ::Math_obj::ceil(a40);
HXDLIN( 497)							v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            						}
            						else {
HXDLIN( 497)							int ii_min61 = ::Math_obj::floor(b37);
HXDLIN( 497)							int ii_max61 = ::Math_obj::ceil(c23);
HXDLIN( 497)							v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            						}
            					}
            					else {
HXDLIN( 497)						if ((b37 > c23)) {
HXDLIN( 497)							int min31;
HXDLIN( 497)							if ((a40 > c23)) {
HXDLIN( 497)								min31 = ::Math_obj::floor(c23);
            							}
            							else {
HXDLIN( 497)								min31 = ::Math_obj::ceil(a40);
            							}
HXDLIN( 497)							int ii_min62 = min31;
HXDLIN( 497)							int ii_max62 = ::Math_obj::ceil(b37);
HXDLIN( 497)							v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            						}
            						else {
HXDLIN( 497)							int ii_min63 = ::Math_obj::floor(a40);
HXDLIN( 497)							int ii_max63 = ::Math_obj::ceil(c23);
HXDLIN( 497)							v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            						}
            					}
            				}
HXDLIN( 497)				if (hasUndo3) {
HXDLIN( 497)					v_undoImage3 = undoImage9;
HXDLIN( 497)					v_undoX3 = xIter33->start;
HXDLIN( 497)					v_undoY3 = yIter33->start;
            				}
HXDLIN( 497)				 ::pi_xy::algo::HitQuad v9 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax3,ay3,bx5,by5,cx5,cy5,dx3,dy3,true);
HXDLIN( 497)				hitQuad = v9;
            			}
            		}
            		else {
HXDLIN( 497)			Float sin3 = ::Math_obj::sin(theta);
HXDLIN( 497)			Float cos3 = ::Math_obj::cos(theta);
HXDLIN( 497)			Float radius3 = (thick / ( (Float)(2) ));
HXDLIN( 497)			Float dx6 = ((Float)0.1);
HXDLIN( 497)			Float dy6 = radius3;
HXDLIN( 497)			Float cx10 = h2;
HXDLIN( 497)			Float cy10 = radius3;
HXDLIN( 497)			Float bx10 = h2;
HXDLIN( 497)			Float by10 = -(radius3);
HXDLIN( 497)			Float ax6 = ((Float)0.1);
HXDLIN( 497)			Float ay6 = -(radius3);
HXDLIN( 497)			Float temp2 = ((Float)0.);
HXLINE(  28)			temp2 = (px + ((ax6 * cos3) - (ay6 * sin3)));
HXLINE(  29)			ay6 = (py + ((ay6 * cos3) + (ax6 * sin3)));
HXLINE(  30)			ax6 = temp2;
HXLINE(  32)			temp2 = (px + ((bx10 * cos3) - (by10 * sin3)));
HXLINE(  33)			by10 = (py + ((by10 * cos3) + (bx10 * sin3)));
HXLINE(  34)			bx10 = temp2;
HXLINE(  36)			temp2 = (px + ((cx10 * cos3) - (cy10 * sin3)));
HXLINE(  37)			cy10 = (py + ((cy10 * cos3) + (cx10 * sin3)));
HXLINE(  38)			cx10 = temp2;
HXLINE(  40)			temp2 = (px + ((dx6 * cos3) - (dy6 * sin3)));
HXLINE(  41)			dy6 = (py + ((dy6 * cos3) + (dx6 * sin3)));
HXLINE(  42)			dx6 = temp2;
HXLINE( 497)			Float bx11 = bx10;
HXDLIN( 497)			Float by11 = by10;
HXDLIN( 497)			Float cx11 = dx6;
HXDLIN( 497)			Float cy11 = dy6;
HXDLIN( 497)			bool hasUndo4 = false;
HXDLIN( 497)			bool adjustWinding8 = (((((ax6 * by11) - (bx11 * ay6)) + ((bx11 * cy11) - (cx11 * by11))) + ((cx11 * ay6) - (ax6 * cy11))) > 0);
HXDLIN( 497)			if (!(adjustWinding8)) {
HXDLIN( 497)				Float bx_8 = bx11;
HXDLIN( 497)				Float by_8 = by11;
HXLINE(  25)				bx11 = cx11;
HXLINE(  26)				by11 = cy11;
HXLINE(  27)				cx11 = bx_8;
HXLINE(  28)				cy11 = by_8;
            			}
HXLINE( 497)			Float s04 = ((ay6 * cx11) - (ax6 * cy11));
HXDLIN( 497)			Float sx4 = (cy11 - ay6);
HXDLIN( 497)			Float sy4 = (ax6 - cx11);
HXDLIN( 497)			Float t04 = ((ax6 * by11) - (ay6 * bx11));
HXDLIN( 497)			Float tx4 = (ay6 - by11);
HXDLIN( 497)			Float ty4 = (bx11 - ax6);
HXDLIN( 497)			Float A4 = ((((-(by11) * cx11) + (ay6 * (-(bx11) + cx11))) + (ax6 * (by11 - cy11))) + (bx11 * cy11));
HXDLIN( 497)			 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN( 497)			if ((ax6 > bx11)) {
HXDLIN( 497)				if ((ax6 > cx11)) {
HXDLIN( 497)					int min32;
HXDLIN( 497)					if ((bx11 > cx11)) {
HXDLIN( 497)						min32 = ::Math_obj::floor(cx11);
            					}
            					else {
HXDLIN( 497)						min32 = ::Math_obj::floor(bx11);
            					}
HXDLIN( 497)					int ii_min64 = min32;
HXDLIN( 497)					int ii_max64 = ::Math_obj::ceil(ax6);
HXDLIN( 497)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            				}
            				else {
HXDLIN( 497)					int ii_min65 = ::Math_obj::floor(bx11);
HXDLIN( 497)					int ii_max65 = ::Math_obj::ceil(cx11);
HXDLIN( 497)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            				}
            			}
            			else {
HXDLIN( 497)				if ((bx11 > cx11)) {
HXDLIN( 497)					int min33;
HXDLIN( 497)					if ((ax6 > cx11)) {
HXDLIN( 497)						min33 = ::Math_obj::floor(cx11);
            					}
            					else {
HXDLIN( 497)						min33 = ::Math_obj::ceil(ax6);
            					}
HXDLIN( 497)					int ii_min66 = min33;
HXDLIN( 497)					int ii_max66 = ::Math_obj::ceil(bx11);
HXDLIN( 497)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            				}
            				else {
HXDLIN( 497)					int ii_min67 = ::Math_obj::floor(ax6);
HXDLIN( 497)					int ii_max67 = ::Math_obj::ceil(cx11);
HXDLIN( 497)					xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            				}
            			}
HXDLIN( 497)			 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN( 497)			if ((ay6 > by11)) {
HXDLIN( 497)				if ((ay6 > cy11)) {
HXDLIN( 497)					int min34;
HXDLIN( 497)					if ((by11 > cy11)) {
HXDLIN( 497)						min34 = ::Math_obj::floor(cy11);
            					}
            					else {
HXDLIN( 497)						min34 = ::Math_obj::floor(by11);
            					}
HXDLIN( 497)					int ii_min68 = min34;
HXDLIN( 497)					int ii_max68 = ::Math_obj::ceil(ay6);
HXDLIN( 497)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            				}
            				else {
HXDLIN( 497)					int ii_min69 = ::Math_obj::floor(by11);
HXDLIN( 497)					int ii_max69 = ::Math_obj::ceil(cy11);
HXDLIN( 497)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            				}
            			}
            			else {
HXDLIN( 497)				if ((by11 > cy11)) {
HXDLIN( 497)					int min35;
HXDLIN( 497)					if ((ay6 > cy11)) {
HXDLIN( 497)						min35 = ::Math_obj::floor(cy11);
            					}
            					else {
HXDLIN( 497)						min35 = ::Math_obj::ceil(ay6);
            					}
HXDLIN( 497)					int ii_min70 = min35;
HXDLIN( 497)					int ii_max70 = ::Math_obj::ceil(by11);
HXDLIN( 497)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            				}
            				else {
HXDLIN( 497)					int ii_min71 = ::Math_obj::floor(ay6);
HXDLIN( 497)					int ii_max71 = ::Math_obj::ceil(cy11);
HXDLIN( 497)					yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            				}
            			}
HXDLIN( 497)			 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN( 497)			if (hasUndo4) {
HXDLIN( 497)				int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN( 497)				int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN( 497)				 ::Dynamic imageType4 = null();
HXDLIN( 497)				 ::pi_xy::ImageStruct this134 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 497)				if (::hx::IsNull( imageType4 )) {
HXLINE(  54)					imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 497)				::Dynamic undoImage13;
HXDLIN( 497)				switch((int)(( (int)(imageType4) ))){
            					case (int)0: {
HXDLIN( 497)						 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::BytesImg b38 = byt4;
HXDLIN( 497)						{
HXDLIN( 497)							b38->width = width4;
HXDLIN( 497)							b38->height = height4;
HXDLIN( 497)							b38->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 497)							b38->data = ::haxe::io::Bytes_obj::alloc((b38->length * 4));
HXDLIN( 497)							{
HXDLIN( 497)								int len8 = b38->length;
HXDLIN( 497)								int w4 = 0;
HXDLIN( 497)								{
HXDLIN( 497)									int _g80 = 0;
HXDLIN( 497)									int _g81 = b38->height;
HXDLIN( 497)									while((_g80 < _g81)){
HXDLIN( 497)										_g80 = (_g80 + 1);
HXDLIN( 497)										int y16 = (_g80 - 1);
HXDLIN( 497)										{
HXDLIN( 497)											int _g82 = 0;
HXDLIN( 497)											int _g83 = b38->width;
HXDLIN( 497)											while((_g82 < _g83)){
HXDLIN( 497)												_g82 = (_g82 + 1);
HXDLIN( 497)												int x16 = (_g82 - 1);
HXDLIN( 497)												{
HXDLIN( 497)													w4 = (w4 + 1);
HXDLIN( 497)													b38->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 497)												{
HXDLIN( 497)													w4 = (w4 + 1);
HXDLIN( 497)													b38->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 497)												{
HXDLIN( 497)													w4 = (w4 + 1);
HXDLIN( 497)													b38->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 497)												{
HXDLIN( 497)													w4 = (w4 + 1);
HXDLIN( 497)													b38->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 497)						undoImage13 = b38;
            					}
            					break;
            					case (int)1: {
HXDLIN( 497)						 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::ArrIntImg a41 = arrI4;
HXDLIN( 497)						{
HXDLIN( 497)							a41->width = width4;
HXDLIN( 497)							a41->height = height4;
HXDLIN( 497)							a41->data = ::Array_obj< int >::__new(0);
HXDLIN( 497)							a41->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 497)							{
HXDLIN( 497)								int _g84 = 0;
HXDLIN( 497)								int _g85 = a41->length;
HXDLIN( 497)								while((_g84 < _g85)){
HXDLIN( 497)									_g84 = (_g84 + 1);
HXDLIN( 497)									int i24 = (_g84 - 1);
HXDLIN( 497)									a41->data[i24] = 0;
            								}
            							}
            						}
HXDLIN( 497)						undoImage13 = a41;
            					}
            					break;
            					case (int)2: {
HXDLIN( 497)						 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::U32ArrImg b39 = u32a4;
HXDLIN( 497)						{
HXDLIN( 497)							b39->width = width4;
HXDLIN( 497)							b39->height = height4;
HXDLIN( 497)							b39->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 497)							int size4 = (b39->length * 4);
HXDLIN( 497)							b39->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN( 497)							{
HXDLIN( 497)								int _g86 = 0;
HXDLIN( 497)								int _g87 = b39->length;
HXDLIN( 497)								while((_g86 < _g87)){
HXDLIN( 497)									_g86 = (_g86 + 1);
HXDLIN( 497)									int i25 = (_g86 - 1);
HXDLIN( 497)									{
HXDLIN( 497)										 ::haxe::io::ArrayBufferViewImpl this135 = b39->data;
HXDLIN( 497)										bool undoImage14;
HXDLIN( 497)										if ((i25 >= 0)) {
HXDLIN( 497)											undoImage14 = (i25 < (this135->byteLength >> 2));
            										}
            										else {
HXDLIN( 497)											undoImage14 = false;
            										}
HXDLIN( 497)										if (undoImage14) {
HXDLIN( 497)											 ::haxe::io::Bytes _this4 = this135->bytes;
HXDLIN( 497)											int pos4 = ((i25 << 2) + this135->byteOffset);
HXDLIN( 497)											_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN( 497)											_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN( 497)											_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN( 497)											_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 497)						undoImage13 = b39;
            					}
            					break;
            					case (int)3: {
HXDLIN( 497)						 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::VecIntImg v10 = vec4;
HXDLIN( 497)						{
HXDLIN( 497)							v10->width = width4;
HXDLIN( 497)							v10->height = height4;
HXDLIN( 497)							v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 497)							v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN( 497)							{
HXDLIN( 497)								int _g88 = 0;
HXDLIN( 497)								int _g89 = v10->length;
HXDLIN( 497)								while((_g88 < _g89)){
HXDLIN( 497)									_g88 = (_g88 + 1);
HXDLIN( 497)									int i26 = (_g88 - 1);
HXDLIN( 497)									v10->data->__unsafe_set(i26,0);
            								}
            							}
            						}
HXDLIN( 497)						undoImage13 = v10;
            					}
            					break;
            					case (int)4: {
HXDLIN( 497)						 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::StackIntImg b40 = sInt4;
HXDLIN( 497)						{
HXDLIN( 497)							b40->width = width4;
HXDLIN( 497)							b40->height = height4;
HXDLIN( 497)							b40->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN( 497)							b40->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 497)							{
HXDLIN( 497)								int len9 = b40->length;
HXDLIN( 497)								 ::haxe::ds::GenericStack_Int d4 = b40->data;
HXDLIN( 497)								if (::hx::IsNull( d4->head )) {
HXDLIN( 497)									int _g90 = 0;
HXDLIN( 497)									int _g91 = len9;
HXDLIN( 497)									while((_g90 < _g91)){
HXDLIN( 497)										_g90 = (_g90 + 1);
HXDLIN( 497)										int i27 = (_g90 - 1);
HXDLIN( 497)										d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            									}
            								}
            								else {
HXDLIN( 497)									int _g92 = 0;
HXDLIN( 497)									int _g93 = len9;
HXDLIN( 497)									while((_g92 < _g93)){
HXDLIN( 497)										_g92 = (_g92 + 1);
HXDLIN( 497)										int i28 = (_g92 - 1);
HXDLIN( 497)										{
HXDLIN( 497)											 ::haxe::ds::GenericCell_Int l4 = b40->data->head;
HXDLIN( 497)											 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN( 497)											{
HXDLIN( 497)												int _g94 = 0;
HXDLIN( 497)												int _g95 = i28;
HXDLIN( 497)												while((_g94 < _g95)){
HXDLIN( 497)													_g94 = (_g94 + 1);
HXDLIN( 497)													int i29 = (_g94 - 1);
HXLINE( 345)													prev4 = l4;
HXLINE( 346)													l4 = l4->next;
            												}
            											}
HXLINE( 497)											if (::hx::IsNull( prev4 )) {
HXDLIN( 497)												b40->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 497)												l4 = null();
            											}
            											else {
HXDLIN( 497)												prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN( 497)												l4 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 497)						undoImage13 = b40;
            					}
            					break;
            				}
HXDLIN( 497)				this134->image = undoImage13;
HXDLIN( 497)				this134->width = width4;
HXDLIN( 497)				this134->height = height4;
HXDLIN( 497)				this134->imageType = ( (int)(imageType4) );
HXDLIN( 497)				undoImage12 = this134;
HXDLIN( 497)				{
HXDLIN( 497)					int rectLeft4 = xIter34->start;
HXDLIN( 497)					int rectTop4 = yIter34->start;
HXDLIN( 497)					int rectRight4 = xIter34->max;
HXDLIN( 497)					bool forceClear4 = false;
HXDLIN( 497)					{
HXDLIN( 497)						int _g96 = rectTop4;
HXDLIN( 497)						int _g97 = yIter34->max;
HXDLIN( 497)						while((_g96 < _g97)){
HXDLIN( 497)							_g96 = (_g96 + 1);
HXDLIN( 497)							int dy7 = (_g96 - 1);
HXDLIN( 497)							{
HXDLIN( 497)								int _g98 = rectLeft4;
HXDLIN( 497)								int _g99 = rectRight4;
HXDLIN( 497)								while((_g98 < _g99)){
HXDLIN( 497)									_g98 = (_g98 + 1);
HXDLIN( 497)									int dx7 = (_g98 - 1);
HXDLIN( 497)									::Dynamic this136 = this1->image;
HXDLIN( 497)									int index20;
HXDLIN( 497)									if (this1->useVirtualPos) {
HXDLIN( 497)										index20 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx7) - this1->virtualX));
            									}
            									else {
HXDLIN( 497)										index20 = ::Std_obj::_hx_int(( (Float)(((dy7 * this1->width) + dx7)) ));
            									}
HXDLIN( 497)									int c24 = ::iterMagic::Iimg_obj::get(this136,index20);
HXDLIN( 497)									int col4;
HXDLIN( 497)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)										col4 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            									}
            									else {
HXDLIN( 497)										col4 = c24;
            									}
HXDLIN( 497)									bool hitQuad33;
HXDLIN( 497)									if (this1->useMask) {
HXDLIN( 497)										hitQuad33 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN( 497)										hitQuad33 = false;
            									}
HXDLIN( 497)									if (hitQuad33) {
HXDLIN( 497)										 ::pi_xy::ImageStruct this137 = this1->mask;
HXDLIN( 497)										::Dynamic this138 = this137->image;
HXDLIN( 497)										int index21;
HXDLIN( 497)										if (this137->useVirtualPos) {
HXDLIN( 497)											index21 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this137->virtualY) * ( (Float)(this137->width) )) + dx7) - this137->virtualX));
            										}
            										else {
HXDLIN( 497)											index21 = ::Std_obj::_hx_int(( (Float)(((dy7 * this137->width) + dx7)) ));
            										}
HXDLIN( 497)										int c25 = ::iterMagic::Iimg_obj::get(this138,index21);
HXDLIN( 497)										int v11;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											v11 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											v11 = c25;
            										}
HXDLIN( 497)										int maskPixel4 = v11;
HXDLIN( 497)										int this139 = col4;
HXDLIN( 497)										if ((maskPixel4 == 0)) {
HXDLIN( 497)											col4 = this139;
            										}
            										else {
HXDLIN( 497)											Float m04;
HXDLIN( 497)											int this140 = ((maskPixel4 >> 24) & 255);
HXDLIN( 497)											if ((this140 == 0)) {
HXDLIN( 497)												m04 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												m04 = (( (Float)(this140) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float m14;
HXDLIN( 497)											int this141 = ((maskPixel4 >> 16) & 255);
HXDLIN( 497)											if ((this141 == 0)) {
HXDLIN( 497)												m14 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												m14 = (( (Float)(this141) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float m24;
HXDLIN( 497)											int this142 = ((maskPixel4 >> 8) & 255);
HXDLIN( 497)											if ((this142 == 0)) {
HXDLIN( 497)												m24 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												m24 = (( (Float)(this142) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float m34;
HXDLIN( 497)											int this143 = (maskPixel4 & 255);
HXDLIN( 497)											if ((this143 == 0)) {
HXDLIN( 497)												m34 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												m34 = (( (Float)(this143) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this139 >> 24) & 255)) )));
HXDLIN( 497)											int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this139 >> 16) & 255)) )));
HXDLIN( 497)											int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this139 >> 8) & 255)) )));
HXDLIN( 497)											int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this139 & 255)) )));
HXDLIN( 497)											col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 497)									if ((col4 != 0)) {
HXDLIN( 497)										int x17 = (dx7 - rectLeft4);
HXDLIN( 497)										int y17 = (dy7 - rectTop4);
HXDLIN( 497)										int c26 = col4;
HXDLIN( 497)										bool hitQuad34;
HXDLIN( 497)										if ((((c26 >> 24) & 255) < 254)) {
HXDLIN( 497)											hitQuad34 = undoImage12->transparent;
            										}
            										else {
HXDLIN( 497)											hitQuad34 = false;
            										}
HXDLIN( 497)										if (hitQuad34) {
HXDLIN( 497)											int location8;
HXDLIN( 497)											if (undoImage12->useVirtualPos) {
HXDLIN( 497)												location8 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x17) - undoImage12->virtualX));
            											}
            											else {
HXDLIN( 497)												location8 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage12->width) + x17)) ));
            											}
HXDLIN( 497)											int this144 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN( 497)											int this145;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												this145 = ((((((this144 >> 24) & 255) << 24) | ((this144 & 255) << 16)) | (((this144 >> 8) & 255) << 8)) | ((this144 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												this145 = this144;
            											}
HXDLIN( 497)											Float a113;
HXDLIN( 497)											int this146 = ((this145 >> 24) & 255);
HXDLIN( 497)											if ((this146 == 0)) {
HXDLIN( 497)												a113 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												a113 = (( (Float)(this146) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float r18;
HXDLIN( 497)											int this147 = ((this145 >> 16) & 255);
HXDLIN( 497)											if ((this147 == 0)) {
HXDLIN( 497)												r18 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												r18 = (( (Float)(this147) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float g18;
HXDLIN( 497)											int this148 = ((this145 >> 8) & 255);
HXDLIN( 497)											if ((this148 == 0)) {
HXDLIN( 497)												g18 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												g18 = (( (Float)(this148) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float b114;
HXDLIN( 497)											int this149 = (this145 & 255);
HXDLIN( 497)											if ((this149 == 0)) {
HXDLIN( 497)												b114 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												b114 = (( (Float)(this149) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float a211;
HXDLIN( 497)											int this150 = ((col4 >> 24) & 255);
HXDLIN( 497)											if ((this150 == 0)) {
HXDLIN( 497)												a211 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												a211 = (( (Float)(this150) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float r28;
HXDLIN( 497)											int this151 = ((col4 >> 16) & 255);
HXDLIN( 497)											if ((this151 == 0)) {
HXDLIN( 497)												r28 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												r28 = (( (Float)(this151) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float g28;
HXDLIN( 497)											int this152 = ((col4 >> 8) & 255);
HXDLIN( 497)											if ((this152 == 0)) {
HXDLIN( 497)												g28 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												g28 = (( (Float)(this152) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float b212;
HXDLIN( 497)											int this153 = (col4 & 255);
HXDLIN( 497)											if ((this153 == 0)) {
HXDLIN( 497)												b212 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												b212 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN( 497)											int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a310) + (r28 * a211))));
HXDLIN( 497)											int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a310) + (g28 * a211))));
HXDLIN( 497)											int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b212 * a211))));
HXDLIN( 497)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN( 497)											int blended8 = ((((a42 << 24) | (r10 << 16)) | (g10 << 8)) | b41);
HXDLIN( 497)											{
HXDLIN( 497)												int hitQuad35;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad35 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad35 = blended8;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(undoImage12->image,location8,hitQuad35);
            											}
            										}
            										else {
HXDLIN( 497)											::Dynamic this154 = undoImage12->image;
HXDLIN( 497)											int index22;
HXDLIN( 497)											if (undoImage12->useVirtualPos) {
HXDLIN( 497)												index22 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x17) - undoImage12->virtualX));
            											}
            											else {
HXDLIN( 497)												index22 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage12->width) + x17)) ));
            											}
HXDLIN( 497)											int hitQuad36;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												hitQuad36 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												hitQuad36 = c26;
            											}
HXDLIN( 497)											::iterMagic::Iimg_obj::set(this154,index22,hitQuad36);
            										}
            									}
            									else {
HXDLIN( 497)										if (forceClear4) {
HXDLIN( 497)											::Dynamic this155 = undoImage12->image;
HXDLIN( 497)											int x18 = (dx7 - rectLeft4);
HXDLIN( 497)											int y18 = (dy7 - rectTop4);
HXDLIN( 497)											int index23;
HXDLIN( 497)											if (undoImage12->useVirtualPos) {
HXDLIN( 497)												index23 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x18) - undoImage12->virtualX));
            											}
            											else {
HXDLIN( 497)												index23 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage12->width) + x18)) ));
            											}
HXDLIN( 497)											::iterMagic::Iimg_obj::set(this155,index23,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 497)			bool found4 = false;
HXDLIN( 497)			Float s4 = ((Float)0.);
HXDLIN( 497)			Float t4 = ((Float)0.);
HXDLIN( 497)			Float sxx4 = ((Float)0.);
HXDLIN( 497)			Float txx4 = ((Float)0.);
HXDLIN( 497)			{
HXDLIN( 497)				int _g_min8 = xIter34->start;
HXDLIN( 497)				int _g_max8 = xIter34->max;
HXDLIN( 497)				while((_g_min8 < _g_max8)){
HXDLIN( 497)					_g_min8 = (_g_min8 + 1);
HXDLIN( 497)					int x19 = (_g_min8 - 1);
HXLINE(  60)					sxx4 = (sx4 * ( (Float)(x19) ));
HXLINE(  61)					txx4 = (tx4 * ( (Float)(x19) ));
HXLINE(  62)					found4 = false;
HXLINE( 497)					{
HXDLIN( 497)						int _g_min9 = yIter34->start;
HXDLIN( 497)						int _g_max9 = yIter34->max;
HXDLIN( 497)						while((_g_min9 < _g_max9)){
HXDLIN( 497)							_g_min9 = (_g_min9 + 1);
HXDLIN( 497)							int y19 = (_g_min9 - 1);
HXLINE(  64)							s4 = ((s04 + sxx4) + (sy4 * ( (Float)(y19) )));
HXLINE(  65)							t4 = ((t04 + txx4) + (ty4 * ( (Float)(y19) )));
HXLINE( 497)							bool hitQuad37;
HXDLIN( 497)							if (!((s4 <= 0))) {
HXDLIN( 497)								hitQuad37 = (t4 <= 0);
            							}
            							else {
HXDLIN( 497)								hitQuad37 = true;
            							}
HXDLIN( 497)							if (hitQuad37) {
HXDLIN( 497)								if (found4) {
HXDLIN( 497)									goto _hx_goto_969;
            								}
            							}
            							else {
HXDLIN( 497)								if (((s4 + t4) < A4)) {
HXDLIN( 497)									{
HXDLIN( 497)										int c27 = color;
HXDLIN( 497)										bool hitQuad38;
HXDLIN( 497)										if ((((c27 >> 24) & 255) < 254)) {
HXDLIN( 497)											hitQuad38 = this1->transparent;
            										}
            										else {
HXDLIN( 497)											hitQuad38 = false;
            										}
HXDLIN( 497)										if (hitQuad38) {
HXDLIN( 497)											int location9;
HXDLIN( 497)											if (this1->useVirtualPos) {
HXDLIN( 497)												location9 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this1->virtualY) * ( (Float)(this1->width) )) + x19) - this1->virtualX));
            											}
            											else {
HXDLIN( 497)												location9 = ::Std_obj::_hx_int(( (Float)(((y19 * this1->width) + x19)) ));
            											}
HXDLIN( 497)											int this156 = ::iterMagic::Iimg_obj::get(this1->image,location9);
HXDLIN( 497)											int this157;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												this157 = ((((((this156 >> 24) & 255) << 24) | ((this156 & 255) << 16)) | (((this156 >> 8) & 255) << 8)) | ((this156 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												this157 = this156;
            											}
HXDLIN( 497)											Float a114;
HXDLIN( 497)											int this158 = ((this157 >> 24) & 255);
HXDLIN( 497)											if ((this158 == 0)) {
HXDLIN( 497)												a114 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												a114 = (( (Float)(this158) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float r19;
HXDLIN( 497)											int this159 = ((this157 >> 16) & 255);
HXDLIN( 497)											if ((this159 == 0)) {
HXDLIN( 497)												r19 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												r19 = (( (Float)(this159) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float g19;
HXDLIN( 497)											int this160 = ((this157 >> 8) & 255);
HXDLIN( 497)											if ((this160 == 0)) {
HXDLIN( 497)												g19 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												g19 = (( (Float)(this160) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float b115;
HXDLIN( 497)											int this161 = (this157 & 255);
HXDLIN( 497)											if ((this161 == 0)) {
HXDLIN( 497)												b115 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												b115 = (( (Float)(this161) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float a212;
HXDLIN( 497)											int this162 = ((color >> 24) & 255);
HXDLIN( 497)											if ((this162 == 0)) {
HXDLIN( 497)												a212 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												a212 = (( (Float)(this162) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float r29;
HXDLIN( 497)											int this163 = ((color >> 16) & 255);
HXDLIN( 497)											if ((this163 == 0)) {
HXDLIN( 497)												r29 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												r29 = (( (Float)(this163) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float g29;
HXDLIN( 497)											int this164 = ((color >> 8) & 255);
HXDLIN( 497)											if ((this164 == 0)) {
HXDLIN( 497)												g29 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												g29 = (( (Float)(this164) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float b213;
HXDLIN( 497)											int this165 = (color & 255);
HXDLIN( 497)											if ((this165 == 0)) {
HXDLIN( 497)												b213 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												b213 = (( (Float)(this165) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN( 497)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a311) + (r29 * a212))));
HXDLIN( 497)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a311) + (g29 * a212))));
HXDLIN( 497)											int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b213 * a212))));
HXDLIN( 497)											int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN( 497)											int blended9 = ((((a43 << 24) | (r20 << 16)) | (g20 << 8)) | b42);
HXDLIN( 497)											{
HXDLIN( 497)												int hitQuad39;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad39 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad39 = blended9;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this1->image,location9,hitQuad39);
            											}
            										}
            										else {
HXDLIN( 497)											::Dynamic this166 = this1->image;
HXDLIN( 497)											int index24;
HXDLIN( 497)											if (this1->useVirtualPos) {
HXDLIN( 497)												index24 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this1->virtualY) * ( (Float)(this1->width) )) + x19) - this1->virtualX));
            											}
            											else {
HXDLIN( 497)												index24 = ::Std_obj::_hx_int(( (Float)(((y19 * this1->width) + x19)) ));
            											}
HXDLIN( 497)											int hitQuad40;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												hitQuad40 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												hitQuad40 = c27;
            											}
HXDLIN( 497)											::iterMagic::Iimg_obj::set(this166,index24,hitQuad40);
            										}
            									}
HXLINE(  73)									found4 = true;
            								}
            								else {
HXDLIN( 497)									if (found4) {
HXDLIN( 497)										goto _hx_goto_969;
            									}
            								}
            							}
            						}
            						_hx_goto_969:;
            					}
            				}
            			}
HXDLIN( 497)			 ::pi_xy::iter::IntIterStart v_yIter34;
HXDLIN( 497)			 ::pi_xy::iter::IntIterStart v_xIter34;
HXDLIN( 497)			int v_undoY4;
HXDLIN( 497)			int v_undoX4;
HXDLIN( 497)			Float v_ty4;
HXDLIN( 497)			Float v_tx4;
HXDLIN( 497)			Float v_t04;
HXDLIN( 497)			Float v_sy4;
HXDLIN( 497)			Float v_sx4;
HXDLIN( 497)			Float v_s04;
HXDLIN( 497)			Float v_A4;
HXDLIN( 497)			Float ax7 = ax6;
HXDLIN( 497)			Float ay7 = ay6;
HXDLIN( 497)			 ::pi_xy::ImageStruct v_undoImage4 = null();
HXDLIN( 497)			Float bx12 = bx11;
HXDLIN( 497)			Float by12 = by11;
HXDLIN( 497)			Float cx12 = cx11;
HXDLIN( 497)			Float cy12 = cy11;
HXDLIN( 497)			bool adjustWinding9 = (((((ax7 * by12) - (bx12 * ay7)) + ((bx12 * cy12) - (cx12 * by12))) + ((cx12 * ay7) - (ax7 * cy12))) > 0);
HXDLIN( 497)			if (!(adjustWinding9)) {
HXDLIN( 497)				Float bx_9 = bx12;
HXDLIN( 497)				Float by_9 = by12;
HXLINE(  24)				bx12 = cx12;
HXLINE(  25)				by12 = cy12;
HXLINE(  26)				cx12 = bx_9;
HXLINE(  27)				cy12 = by_9;
            			}
HXLINE( 497)			Float v_ax4 = ax7;
HXDLIN( 497)			Float v_ay4 = ay7;
HXDLIN( 497)			Float v_bx4 = bx12;
HXDLIN( 497)			Float v_by4 = by12;
HXDLIN( 497)			Float v_cx4 = cx12;
HXDLIN( 497)			Float v_cy4 = cy12;
HXDLIN( 497)			bool v_preCalculated4 = true;
HXDLIN( 497)			{
HXDLIN( 497)				v_s04 = ((v_ay4 * v_cx4) - (v_ax4 * v_cy4));
HXDLIN( 497)				v_sx4 = (v_cy4 - v_ay4);
HXDLIN( 497)				v_sy4 = (v_ax4 - v_cx4);
HXDLIN( 497)				v_t04 = ((v_ax4 * v_by4) - (v_ay4 * v_bx4));
HXDLIN( 497)				v_tx4 = (v_ay4 - v_by4);
HXDLIN( 497)				v_ty4 = (v_bx4 - v_ax4);
HXDLIN( 497)				v_A4 = ((((-(v_by4) * v_cx4) + (v_ay4 * (-(v_bx4) + v_cx4))) + (v_ax4 * (v_by4 - v_cy4))) + (v_bx4 * v_cy4));
HXDLIN( 497)				Float a44 = v_ax4;
HXDLIN( 497)				Float b43 = v_bx4;
HXDLIN( 497)				Float c28 = v_cx4;
HXDLIN( 497)				if ((a44 > b43)) {
HXDLIN( 497)					if ((a44 > c28)) {
HXDLIN( 497)						int min36;
HXDLIN( 497)						if ((b43 > c28)) {
HXDLIN( 497)							min36 = ::Math_obj::floor(c28);
            						}
            						else {
HXDLIN( 497)							min36 = ::Math_obj::floor(b43);
            						}
HXDLIN( 497)						int ii_min72 = min36;
HXDLIN( 497)						int ii_max72 = ::Math_obj::ceil(a44);
HXDLIN( 497)						v_xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            					}
            					else {
HXDLIN( 497)						int ii_min73 = ::Math_obj::floor(b43);
HXDLIN( 497)						int ii_max73 = ::Math_obj::ceil(c28);
HXDLIN( 497)						v_xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            					}
            				}
            				else {
HXDLIN( 497)					if ((b43 > c28)) {
HXDLIN( 497)						int min37;
HXDLIN( 497)						if ((a44 > c28)) {
HXDLIN( 497)							min37 = ::Math_obj::floor(c28);
            						}
            						else {
HXDLIN( 497)							min37 = ::Math_obj::ceil(a44);
            						}
HXDLIN( 497)						int ii_min74 = min37;
HXDLIN( 497)						int ii_max74 = ::Math_obj::ceil(b43);
HXDLIN( 497)						v_xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min74,ii_max74);
            					}
            					else {
HXDLIN( 497)						int ii_min75 = ::Math_obj::floor(a44);
HXDLIN( 497)						int ii_max75 = ::Math_obj::ceil(c28);
HXDLIN( 497)						v_xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min75,ii_max75);
            					}
            				}
HXDLIN( 497)				Float a45 = v_ay4;
HXDLIN( 497)				Float b44 = v_by4;
HXDLIN( 497)				Float c29 = v_cy4;
HXDLIN( 497)				if ((a45 > b44)) {
HXDLIN( 497)					if ((a45 > c29)) {
HXDLIN( 497)						int min38;
HXDLIN( 497)						if ((b44 > c29)) {
HXDLIN( 497)							min38 = ::Math_obj::floor(c29);
            						}
            						else {
HXDLIN( 497)							min38 = ::Math_obj::floor(b44);
            						}
HXDLIN( 497)						int ii_min76 = min38;
HXDLIN( 497)						int ii_max76 = ::Math_obj::ceil(a45);
HXDLIN( 497)						v_yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min76,ii_max76);
            					}
            					else {
HXDLIN( 497)						int ii_min77 = ::Math_obj::floor(b44);
HXDLIN( 497)						int ii_max77 = ::Math_obj::ceil(c29);
HXDLIN( 497)						v_yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min77,ii_max77);
            					}
            				}
            				else {
HXDLIN( 497)					if ((b44 > c29)) {
HXDLIN( 497)						int min39;
HXDLIN( 497)						if ((a45 > c29)) {
HXDLIN( 497)							min39 = ::Math_obj::floor(c29);
            						}
            						else {
HXDLIN( 497)							min39 = ::Math_obj::ceil(a45);
            						}
HXDLIN( 497)						int ii_min78 = min39;
HXDLIN( 497)						int ii_max78 = ::Math_obj::ceil(b44);
HXDLIN( 497)						v_yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min78,ii_max78);
            					}
            					else {
HXDLIN( 497)						int ii_min79 = ::Math_obj::floor(a45);
HXDLIN( 497)						int ii_max79 = ::Math_obj::ceil(c29);
HXDLIN( 497)						v_yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min79,ii_max79);
            					}
            				}
            			}
HXDLIN( 497)			if (hasUndo4) {
HXDLIN( 497)				v_undoImage4 = undoImage12;
HXDLIN( 497)				v_undoX4 = xIter34->start;
HXDLIN( 497)				v_undoY4 = yIter34->start;
            			}
HXDLIN( 497)			Float bx13 = cx10;
HXDLIN( 497)			Float by13 = cy10;
HXDLIN( 497)			Float cx13 = dx6;
HXDLIN( 497)			Float cy13 = dy6;
HXDLIN( 497)			bool hasUndo5 = false;
HXDLIN( 497)			bool adjustWinding10 = (((((bx10 * by13) - (bx13 * by10)) + ((bx13 * cy13) - (cx13 * by13))) + ((cx13 * by10) - (bx10 * cy13))) > 0);
HXDLIN( 497)			if (!(adjustWinding10)) {
HXDLIN( 497)				Float bx_10 = bx13;
HXDLIN( 497)				Float by_10 = by13;
HXLINE(  25)				bx13 = cx13;
HXLINE(  26)				by13 = cy13;
HXLINE(  27)				cx13 = bx_10;
HXLINE(  28)				cy13 = by_10;
            			}
HXLINE( 497)			Float s05 = ((by10 * cx13) - (bx10 * cy13));
HXDLIN( 497)			Float sx5 = (cy13 - by10);
HXDLIN( 497)			Float sy5 = (bx10 - cx13);
HXDLIN( 497)			Float t05 = ((bx10 * by13) - (by10 * bx13));
HXDLIN( 497)			Float tx5 = (by10 - by13);
HXDLIN( 497)			Float ty5 = (bx13 - bx10);
HXDLIN( 497)			Float A5 = ((((-(by13) * cx13) + (by10 * (-(bx13) + cx13))) + (bx10 * (by13 - cy13))) + (bx13 * cy13));
HXDLIN( 497)			 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN( 497)			if ((bx10 > bx13)) {
HXDLIN( 497)				if ((bx10 > cx13)) {
HXDLIN( 497)					int min40;
HXDLIN( 497)					if ((bx13 > cx13)) {
HXDLIN( 497)						min40 = ::Math_obj::floor(cx13);
            					}
            					else {
HXDLIN( 497)						min40 = ::Math_obj::floor(bx13);
            					}
HXDLIN( 497)					int ii_min80 = min40;
HXDLIN( 497)					int ii_max80 = ::Math_obj::ceil(bx10);
HXDLIN( 497)					xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min80,ii_max80);
            				}
            				else {
HXDLIN( 497)					int ii_min81 = ::Math_obj::floor(bx13);
HXDLIN( 497)					int ii_max81 = ::Math_obj::ceil(cx13);
HXDLIN( 497)					xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min81,ii_max81);
            				}
            			}
            			else {
HXDLIN( 497)				if ((bx13 > cx13)) {
HXDLIN( 497)					int min41;
HXDLIN( 497)					if ((bx10 > cx13)) {
HXDLIN( 497)						min41 = ::Math_obj::floor(cx13);
            					}
            					else {
HXDLIN( 497)						min41 = ::Math_obj::ceil(bx10);
            					}
HXDLIN( 497)					int ii_min82 = min41;
HXDLIN( 497)					int ii_max82 = ::Math_obj::ceil(bx13);
HXDLIN( 497)					xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min82,ii_max82);
            				}
            				else {
HXDLIN( 497)					int ii_min83 = ::Math_obj::floor(bx10);
HXDLIN( 497)					int ii_max83 = ::Math_obj::ceil(cx13);
HXDLIN( 497)					xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min83,ii_max83);
            				}
            			}
HXDLIN( 497)			 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN( 497)			if ((by10 > by13)) {
HXDLIN( 497)				if ((by10 > cy13)) {
HXDLIN( 497)					int min42;
HXDLIN( 497)					if ((by13 > cy13)) {
HXDLIN( 497)						min42 = ::Math_obj::floor(cy13);
            					}
            					else {
HXDLIN( 497)						min42 = ::Math_obj::floor(by13);
            					}
HXDLIN( 497)					int ii_min84 = min42;
HXDLIN( 497)					int ii_max84 = ::Math_obj::ceil(by10);
HXDLIN( 497)					yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min84,ii_max84);
            				}
            				else {
HXDLIN( 497)					int ii_min85 = ::Math_obj::floor(by13);
HXDLIN( 497)					int ii_max85 = ::Math_obj::ceil(cy13);
HXDLIN( 497)					yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min85,ii_max85);
            				}
            			}
            			else {
HXDLIN( 497)				if ((by13 > cy13)) {
HXDLIN( 497)					int min43;
HXDLIN( 497)					if ((by10 > cy13)) {
HXDLIN( 497)						min43 = ::Math_obj::floor(cy13);
            					}
            					else {
HXDLIN( 497)						min43 = ::Math_obj::ceil(by10);
            					}
HXDLIN( 497)					int ii_min86 = min43;
HXDLIN( 497)					int ii_max86 = ::Math_obj::ceil(by13);
HXDLIN( 497)					yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min86,ii_max86);
            				}
            				else {
HXDLIN( 497)					int ii_min87 = ::Math_obj::floor(by10);
HXDLIN( 497)					int ii_max87 = ::Math_obj::ceil(cy13);
HXDLIN( 497)					yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min87,ii_max87);
            				}
            			}
HXDLIN( 497)			 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN( 497)			if (hasUndo5) {
HXDLIN( 497)				int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN( 497)				int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN( 497)				 ::Dynamic imageType5 = null();
HXDLIN( 497)				 ::pi_xy::ImageStruct this167 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 497)				if (::hx::IsNull( imageType5 )) {
HXLINE(  54)					imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 497)				::Dynamic undoImage16;
HXDLIN( 497)				switch((int)(( (int)(imageType5) ))){
            					case (int)0: {
HXDLIN( 497)						 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::BytesImg b45 = byt5;
HXDLIN( 497)						{
HXDLIN( 497)							b45->width = width5;
HXDLIN( 497)							b45->height = height5;
HXDLIN( 497)							b45->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 497)							b45->data = ::haxe::io::Bytes_obj::alloc((b45->length * 4));
HXDLIN( 497)							{
HXDLIN( 497)								int len10 = b45->length;
HXDLIN( 497)								int w5 = 0;
HXDLIN( 497)								{
HXDLIN( 497)									int _g100 = 0;
HXDLIN( 497)									int _g101 = b45->height;
HXDLIN( 497)									while((_g100 < _g101)){
HXDLIN( 497)										_g100 = (_g100 + 1);
HXDLIN( 497)										int y20 = (_g100 - 1);
HXDLIN( 497)										{
HXDLIN( 497)											int _g102 = 0;
HXDLIN( 497)											int _g103 = b45->width;
HXDLIN( 497)											while((_g102 < _g103)){
HXDLIN( 497)												_g102 = (_g102 + 1);
HXDLIN( 497)												int x20 = (_g102 - 1);
HXDLIN( 497)												{
HXDLIN( 497)													w5 = (w5 + 1);
HXDLIN( 497)													b45->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 497)												{
HXDLIN( 497)													w5 = (w5 + 1);
HXDLIN( 497)													b45->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 497)												{
HXDLIN( 497)													w5 = (w5 + 1);
HXDLIN( 497)													b45->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 497)												{
HXDLIN( 497)													w5 = (w5 + 1);
HXDLIN( 497)													b45->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 497)						undoImage16 = b45;
            					}
            					break;
            					case (int)1: {
HXDLIN( 497)						 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::ArrIntImg a46 = arrI5;
HXDLIN( 497)						{
HXDLIN( 497)							a46->width = width5;
HXDLIN( 497)							a46->height = height5;
HXDLIN( 497)							a46->data = ::Array_obj< int >::__new(0);
HXDLIN( 497)							a46->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 497)							{
HXDLIN( 497)								int _g104 = 0;
HXDLIN( 497)								int _g105 = a46->length;
HXDLIN( 497)								while((_g104 < _g105)){
HXDLIN( 497)									_g104 = (_g104 + 1);
HXDLIN( 497)									int i30 = (_g104 - 1);
HXDLIN( 497)									a46->data[i30] = 0;
            								}
            							}
            						}
HXDLIN( 497)						undoImage16 = a46;
            					}
            					break;
            					case (int)2: {
HXDLIN( 497)						 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::U32ArrImg b46 = u32a5;
HXDLIN( 497)						{
HXDLIN( 497)							b46->width = width5;
HXDLIN( 497)							b46->height = height5;
HXDLIN( 497)							b46->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 497)							int size5 = (b46->length * 4);
HXDLIN( 497)							b46->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN( 497)							{
HXDLIN( 497)								int _g106 = 0;
HXDLIN( 497)								int _g107 = b46->length;
HXDLIN( 497)								while((_g106 < _g107)){
HXDLIN( 497)									_g106 = (_g106 + 1);
HXDLIN( 497)									int i31 = (_g106 - 1);
HXDLIN( 497)									{
HXDLIN( 497)										 ::haxe::io::ArrayBufferViewImpl this168 = b46->data;
HXDLIN( 497)										bool undoImage17;
HXDLIN( 497)										if ((i31 >= 0)) {
HXDLIN( 497)											undoImage17 = (i31 < (this168->byteLength >> 2));
            										}
            										else {
HXDLIN( 497)											undoImage17 = false;
            										}
HXDLIN( 497)										if (undoImage17) {
HXDLIN( 497)											 ::haxe::io::Bytes _this5 = this168->bytes;
HXDLIN( 497)											int pos5 = ((i31 << 2) + this168->byteOffset);
HXDLIN( 497)											_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN( 497)											_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN( 497)											_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN( 497)											_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 497)						undoImage16 = b46;
            					}
            					break;
            					case (int)3: {
HXDLIN( 497)						 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::VecIntImg v12 = vec5;
HXDLIN( 497)						{
HXDLIN( 497)							v12->width = width5;
HXDLIN( 497)							v12->height = height5;
HXDLIN( 497)							v12->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 497)							v12->data = ::Array_obj< int >::__new(v12->length);
HXDLIN( 497)							{
HXDLIN( 497)								int _g108 = 0;
HXDLIN( 497)								int _g109 = v12->length;
HXDLIN( 497)								while((_g108 < _g109)){
HXDLIN( 497)									_g108 = (_g108 + 1);
HXDLIN( 497)									int i32 = (_g108 - 1);
HXDLIN( 497)									v12->data->__unsafe_set(i32,0);
            								}
            							}
            						}
HXDLIN( 497)						undoImage16 = v12;
            					}
            					break;
            					case (int)4: {
HXDLIN( 497)						 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)						 ::iterMagic::StackIntImg b47 = sInt5;
HXDLIN( 497)						{
HXDLIN( 497)							b47->width = width5;
HXDLIN( 497)							b47->height = height5;
HXDLIN( 497)							b47->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN( 497)							b47->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 497)							{
HXDLIN( 497)								int len11 = b47->length;
HXDLIN( 497)								 ::haxe::ds::GenericStack_Int d5 = b47->data;
HXDLIN( 497)								if (::hx::IsNull( d5->head )) {
HXDLIN( 497)									int _g110 = 0;
HXDLIN( 497)									int _g111 = len11;
HXDLIN( 497)									while((_g110 < _g111)){
HXDLIN( 497)										_g110 = (_g110 + 1);
HXDLIN( 497)										int i33 = (_g110 - 1);
HXDLIN( 497)										d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            									}
            								}
            								else {
HXDLIN( 497)									int _g112 = 0;
HXDLIN( 497)									int _g113 = len11;
HXDLIN( 497)									while((_g112 < _g113)){
HXDLIN( 497)										_g112 = (_g112 + 1);
HXDLIN( 497)										int i34 = (_g112 - 1);
HXDLIN( 497)										{
HXDLIN( 497)											 ::haxe::ds::GenericCell_Int l5 = b47->data->head;
HXDLIN( 497)											 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN( 497)											{
HXDLIN( 497)												int _g114 = 0;
HXDLIN( 497)												int _g115 = i34;
HXDLIN( 497)												while((_g114 < _g115)){
HXDLIN( 497)													_g114 = (_g114 + 1);
HXDLIN( 497)													int i35 = (_g114 - 1);
HXLINE( 345)													prev5 = l5;
HXLINE( 346)													l5 = l5->next;
            												}
            											}
HXLINE( 497)											if (::hx::IsNull( prev5 )) {
HXDLIN( 497)												b47->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 497)												l5 = null();
            											}
            											else {
HXDLIN( 497)												prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN( 497)												l5 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 497)						undoImage16 = b47;
            					}
            					break;
            				}
HXDLIN( 497)				this167->image = undoImage16;
HXDLIN( 497)				this167->width = width5;
HXDLIN( 497)				this167->height = height5;
HXDLIN( 497)				this167->imageType = ( (int)(imageType5) );
HXDLIN( 497)				undoImage15 = this167;
HXDLIN( 497)				{
HXDLIN( 497)					int rectLeft5 = xIter35->start;
HXDLIN( 497)					int rectTop5 = yIter35->start;
HXDLIN( 497)					int rectRight5 = xIter35->max;
HXDLIN( 497)					bool forceClear5 = false;
HXDLIN( 497)					{
HXDLIN( 497)						int _g116 = rectTop5;
HXDLIN( 497)						int _g117 = yIter35->max;
HXDLIN( 497)						while((_g116 < _g117)){
HXDLIN( 497)							_g116 = (_g116 + 1);
HXDLIN( 497)							int dy8 = (_g116 - 1);
HXDLIN( 497)							{
HXDLIN( 497)								int _g118 = rectLeft5;
HXDLIN( 497)								int _g119 = rectRight5;
HXDLIN( 497)								while((_g118 < _g119)){
HXDLIN( 497)									_g118 = (_g118 + 1);
HXDLIN( 497)									int dx8 = (_g118 - 1);
HXDLIN( 497)									::Dynamic this169 = this1->image;
HXDLIN( 497)									int index25;
HXDLIN( 497)									if (this1->useVirtualPos) {
HXDLIN( 497)										index25 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx8) - this1->virtualX));
            									}
            									else {
HXDLIN( 497)										index25 = ::Std_obj::_hx_int(( (Float)(((dy8 * this1->width) + dx8)) ));
            									}
HXDLIN( 497)									int c30 = ::iterMagic::Iimg_obj::get(this169,index25);
HXDLIN( 497)									int col5;
HXDLIN( 497)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)										col5 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            									}
            									else {
HXDLIN( 497)										col5 = c30;
            									}
HXDLIN( 497)									bool hitQuad41;
HXDLIN( 497)									if (this1->useMask) {
HXDLIN( 497)										hitQuad41 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXDLIN( 497)										hitQuad41 = false;
            									}
HXDLIN( 497)									if (hitQuad41) {
HXDLIN( 497)										 ::pi_xy::ImageStruct this170 = this1->mask;
HXDLIN( 497)										::Dynamic this171 = this170->image;
HXDLIN( 497)										int index26;
HXDLIN( 497)										if (this170->useVirtualPos) {
HXDLIN( 497)											index26 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this170->virtualY) * ( (Float)(this170->width) )) + dx8) - this170->virtualX));
            										}
            										else {
HXDLIN( 497)											index26 = ::Std_obj::_hx_int(( (Float)(((dy8 * this170->width) + dx8)) ));
            										}
HXDLIN( 497)										int c31 = ::iterMagic::Iimg_obj::get(this171,index26);
HXDLIN( 497)										int v13;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											v13 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											v13 = c31;
            										}
HXDLIN( 497)										int maskPixel5 = v13;
HXDLIN( 497)										int this172 = col5;
HXDLIN( 497)										if ((maskPixel5 == 0)) {
HXDLIN( 497)											col5 = this172;
            										}
            										else {
HXDLIN( 497)											Float m05;
HXDLIN( 497)											int this173 = ((maskPixel5 >> 24) & 255);
HXDLIN( 497)											if ((this173 == 0)) {
HXDLIN( 497)												m05 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												m05 = (( (Float)(this173) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float m15;
HXDLIN( 497)											int this174 = ((maskPixel5 >> 16) & 255);
HXDLIN( 497)											if ((this174 == 0)) {
HXDLIN( 497)												m15 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												m15 = (( (Float)(this174) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float m25;
HXDLIN( 497)											int this175 = ((maskPixel5 >> 8) & 255);
HXDLIN( 497)											if ((this175 == 0)) {
HXDLIN( 497)												m25 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												m25 = (( (Float)(this175) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float m35;
HXDLIN( 497)											int this176 = (maskPixel5 & 255);
HXDLIN( 497)											if ((this176 == 0)) {
HXDLIN( 497)												m35 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												m35 = (( (Float)(this176) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this172 >> 24) & 255)) )));
HXDLIN( 497)											int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this172 >> 16) & 255)) )));
HXDLIN( 497)											int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this172 >> 8) & 255)) )));
HXDLIN( 497)											int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this172 & 255)) )));
HXDLIN( 497)											col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN( 497)									if ((col5 != 0)) {
HXDLIN( 497)										int x21 = (dx8 - rectLeft5);
HXDLIN( 497)										int y21 = (dy8 - rectTop5);
HXDLIN( 497)										int c32 = col5;
HXDLIN( 497)										bool hitQuad42;
HXDLIN( 497)										if ((((c32 >> 24) & 255) < 254)) {
HXDLIN( 497)											hitQuad42 = undoImage15->transparent;
            										}
            										else {
HXDLIN( 497)											hitQuad42 = false;
            										}
HXDLIN( 497)										if (hitQuad42) {
HXDLIN( 497)											int location10;
HXDLIN( 497)											if (undoImage15->useVirtualPos) {
HXDLIN( 497)												location10 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x21) - undoImage15->virtualX));
            											}
            											else {
HXDLIN( 497)												location10 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage15->width) + x21)) ));
            											}
HXDLIN( 497)											int this177 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN( 497)											int this178;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												this178 = ((((((this177 >> 24) & 255) << 24) | ((this177 & 255) << 16)) | (((this177 >> 8) & 255) << 8)) | ((this177 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												this178 = this177;
            											}
HXDLIN( 497)											Float a115;
HXDLIN( 497)											int this179 = ((this178 >> 24) & 255);
HXDLIN( 497)											if ((this179 == 0)) {
HXDLIN( 497)												a115 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												a115 = (( (Float)(this179) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float r110;
HXDLIN( 497)											int this180 = ((this178 >> 16) & 255);
HXDLIN( 497)											if ((this180 == 0)) {
HXDLIN( 497)												r110 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												r110 = (( (Float)(this180) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float g110;
HXDLIN( 497)											int this181 = ((this178 >> 8) & 255);
HXDLIN( 497)											if ((this181 == 0)) {
HXDLIN( 497)												g110 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												g110 = (( (Float)(this181) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float b116;
HXDLIN( 497)											int this182 = (this178 & 255);
HXDLIN( 497)											if ((this182 == 0)) {
HXDLIN( 497)												b116 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												b116 = (( (Float)(this182) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float a213;
HXDLIN( 497)											int this183 = ((col5 >> 24) & 255);
HXDLIN( 497)											if ((this183 == 0)) {
HXDLIN( 497)												a213 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												a213 = (( (Float)(this183) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float r210;
HXDLIN( 497)											int this184 = ((col5 >> 16) & 255);
HXDLIN( 497)											if ((this184 == 0)) {
HXDLIN( 497)												r210 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												r210 = (( (Float)(this184) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float g210;
HXDLIN( 497)											int this185 = ((col5 >> 8) & 255);
HXDLIN( 497)											if ((this185 == 0)) {
HXDLIN( 497)												g210 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												g210 = (( (Float)(this185) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float b214;
HXDLIN( 497)											int this186 = (col5 & 255);
HXDLIN( 497)											if ((this186 == 0)) {
HXDLIN( 497)												b214 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												b214 = (( (Float)(this186) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN( 497)											int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a312) + (r210 * a213))));
HXDLIN( 497)											int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a312) + (g210 * a213))));
HXDLIN( 497)											int b48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b214 * a213))));
HXDLIN( 497)											int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN( 497)											int blended10 = ((((a47 << 24) | (r30 << 16)) | (g30 << 8)) | b48);
HXDLIN( 497)											{
HXDLIN( 497)												int hitQuad43;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad43 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad43 = blended10;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(undoImage15->image,location10,hitQuad43);
            											}
            										}
            										else {
HXDLIN( 497)											::Dynamic this187 = undoImage15->image;
HXDLIN( 497)											int index27;
HXDLIN( 497)											if (undoImage15->useVirtualPos) {
HXDLIN( 497)												index27 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x21) - undoImage15->virtualX));
            											}
            											else {
HXDLIN( 497)												index27 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage15->width) + x21)) ));
            											}
HXDLIN( 497)											int hitQuad44;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												hitQuad44 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												hitQuad44 = c32;
            											}
HXDLIN( 497)											::iterMagic::Iimg_obj::set(this187,index27,hitQuad44);
            										}
            									}
            									else {
HXDLIN( 497)										if (forceClear5) {
HXDLIN( 497)											::Dynamic this188 = undoImage15->image;
HXDLIN( 497)											int x22 = (dx8 - rectLeft5);
HXDLIN( 497)											int y22 = (dy8 - rectTop5);
HXDLIN( 497)											int index28;
HXDLIN( 497)											if (undoImage15->useVirtualPos) {
HXDLIN( 497)												index28 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x22) - undoImage15->virtualX));
            											}
            											else {
HXDLIN( 497)												index28 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage15->width) + x22)) ));
            											}
HXDLIN( 497)											::iterMagic::Iimg_obj::set(this188,index28,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 497)			bool found5 = false;
HXDLIN( 497)			Float s5 = ((Float)0.);
HXDLIN( 497)			Float t5 = ((Float)0.);
HXDLIN( 497)			Float sxx5 = ((Float)0.);
HXDLIN( 497)			Float txx5 = ((Float)0.);
HXDLIN( 497)			{
HXDLIN( 497)				int _g_min10 = xIter35->start;
HXDLIN( 497)				int _g_max10 = xIter35->max;
HXDLIN( 497)				while((_g_min10 < _g_max10)){
HXDLIN( 497)					_g_min10 = (_g_min10 + 1);
HXDLIN( 497)					int x23 = (_g_min10 - 1);
HXLINE(  60)					sxx5 = (sx5 * ( (Float)(x23) ));
HXLINE(  61)					txx5 = (tx5 * ( (Float)(x23) ));
HXLINE(  62)					found5 = false;
HXLINE( 497)					{
HXDLIN( 497)						int _g_min11 = yIter35->start;
HXDLIN( 497)						int _g_max11 = yIter35->max;
HXDLIN( 497)						while((_g_min11 < _g_max11)){
HXDLIN( 497)							_g_min11 = (_g_min11 + 1);
HXDLIN( 497)							int y23 = (_g_min11 - 1);
HXLINE(  64)							s5 = ((s05 + sxx5) + (sy5 * ( (Float)(y23) )));
HXLINE(  65)							t5 = ((t05 + txx5) + (ty5 * ( (Float)(y23) )));
HXLINE( 497)							bool hitQuad45;
HXDLIN( 497)							if (!((s5 <= 0))) {
HXDLIN( 497)								hitQuad45 = (t5 <= 0);
            							}
            							else {
HXDLIN( 497)								hitQuad45 = true;
            							}
HXDLIN( 497)							if (hitQuad45) {
HXDLIN( 497)								if (found5) {
HXDLIN( 497)									goto _hx_goto_981;
            								}
            							}
            							else {
HXDLIN( 497)								if (((s5 + t5) < A5)) {
HXDLIN( 497)									{
HXDLIN( 497)										int c33 = color;
HXDLIN( 497)										bool hitQuad46;
HXDLIN( 497)										if ((((c33 >> 24) & 255) < 254)) {
HXDLIN( 497)											hitQuad46 = this1->transparent;
            										}
            										else {
HXDLIN( 497)											hitQuad46 = false;
            										}
HXDLIN( 497)										if (hitQuad46) {
HXDLIN( 497)											int location11;
HXDLIN( 497)											if (this1->useVirtualPos) {
HXDLIN( 497)												location11 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - this1->virtualY) * ( (Float)(this1->width) )) + x23) - this1->virtualX));
            											}
            											else {
HXDLIN( 497)												location11 = ::Std_obj::_hx_int(( (Float)(((y23 * this1->width) + x23)) ));
            											}
HXDLIN( 497)											int this189 = ::iterMagic::Iimg_obj::get(this1->image,location11);
HXDLIN( 497)											int this190;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												this190 = ((((((this189 >> 24) & 255) << 24) | ((this189 & 255) << 16)) | (((this189 >> 8) & 255) << 8)) | ((this189 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												this190 = this189;
            											}
HXDLIN( 497)											Float a116;
HXDLIN( 497)											int this191 = ((this190 >> 24) & 255);
HXDLIN( 497)											if ((this191 == 0)) {
HXDLIN( 497)												a116 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												a116 = (( (Float)(this191) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float r111;
HXDLIN( 497)											int this192 = ((this190 >> 16) & 255);
HXDLIN( 497)											if ((this192 == 0)) {
HXDLIN( 497)												r111 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												r111 = (( (Float)(this192) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float g111;
HXDLIN( 497)											int this193 = ((this190 >> 8) & 255);
HXDLIN( 497)											if ((this193 == 0)) {
HXDLIN( 497)												g111 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												g111 = (( (Float)(this193) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float b117;
HXDLIN( 497)											int this194 = (this190 & 255);
HXDLIN( 497)											if ((this194 == 0)) {
HXDLIN( 497)												b117 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												b117 = (( (Float)(this194) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float a214;
HXDLIN( 497)											int this195 = ((color >> 24) & 255);
HXDLIN( 497)											if ((this195 == 0)) {
HXDLIN( 497)												a214 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												a214 = (( (Float)(this195) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float r211;
HXDLIN( 497)											int this196 = ((color >> 16) & 255);
HXDLIN( 497)											if ((this196 == 0)) {
HXDLIN( 497)												r211 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												r211 = (( (Float)(this196) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float g211;
HXDLIN( 497)											int this197 = ((color >> 8) & 255);
HXDLIN( 497)											if ((this197 == 0)) {
HXDLIN( 497)												g211 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												g211 = (( (Float)(this197) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float b215;
HXDLIN( 497)											int this198 = (color & 255);
HXDLIN( 497)											if ((this198 == 0)) {
HXDLIN( 497)												b215 = ((Float)0.);
            											}
            											else {
HXDLIN( 497)												b215 = (( (Float)(this198) ) / ( (Float)(255) ));
            											}
HXDLIN( 497)											Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN( 497)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a313) + (r211 * a214))));
HXDLIN( 497)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a313) + (g211 * a214))));
HXDLIN( 497)											int b49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b215 * a214))));
HXDLIN( 497)											int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN( 497)											int blended11 = ((((a48 << 24) | (r31 << 16)) | (g31 << 8)) | b49);
HXDLIN( 497)											{
HXDLIN( 497)												int hitQuad47;
HXDLIN( 497)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)													hitQuad47 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXDLIN( 497)													hitQuad47 = blended11;
            												}
HXDLIN( 497)												::iterMagic::Iimg_obj::set(this1->image,location11,hitQuad47);
            											}
            										}
            										else {
HXDLIN( 497)											::Dynamic this199 = this1->image;
HXDLIN( 497)											int index29;
HXDLIN( 497)											if (this1->useVirtualPos) {
HXDLIN( 497)												index29 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - this1->virtualY) * ( (Float)(this1->width) )) + x23) - this1->virtualX));
            											}
            											else {
HXDLIN( 497)												index29 = ::Std_obj::_hx_int(( (Float)(((y23 * this1->width) + x23)) ));
            											}
HXDLIN( 497)											int hitQuad48;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												hitQuad48 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												hitQuad48 = c33;
            											}
HXDLIN( 497)											::iterMagic::Iimg_obj::set(this199,index29,hitQuad48);
            										}
            									}
HXLINE(  73)									found5 = true;
            								}
            								else {
HXDLIN( 497)									if (found5) {
HXDLIN( 497)										goto _hx_goto_981;
            									}
            								}
            							}
            						}
            						_hx_goto_981:;
            					}
            				}
            			}
HXDLIN( 497)			 ::pi_xy::iter::IntIterStart v_yIter35;
HXDLIN( 497)			 ::pi_xy::iter::IntIterStart v_xIter35;
HXDLIN( 497)			int v_undoY5;
HXDLIN( 497)			int v_undoX5;
HXDLIN( 497)			Float v_ty5;
HXDLIN( 497)			Float v_tx5;
HXDLIN( 497)			Float v_t05;
HXDLIN( 497)			Float v_sy5;
HXDLIN( 497)			Float v_sx5;
HXDLIN( 497)			Float v_s05;
HXDLIN( 497)			Float v_A5;
HXDLIN( 497)			Float ax8 = bx10;
HXDLIN( 497)			Float ay8 = by10;
HXDLIN( 497)			 ::pi_xy::ImageStruct v_undoImage5 = null();
HXDLIN( 497)			Float bx14 = bx13;
HXDLIN( 497)			Float by14 = by13;
HXDLIN( 497)			Float cx14 = cx13;
HXDLIN( 497)			Float cy14 = cy13;
HXDLIN( 497)			bool adjustWinding11 = (((((ax8 * by14) - (bx14 * ay8)) + ((bx14 * cy14) - (cx14 * by14))) + ((cx14 * ay8) - (ax8 * cy14))) > 0);
HXDLIN( 497)			if (!(adjustWinding11)) {
HXDLIN( 497)				Float bx_11 = bx14;
HXDLIN( 497)				Float by_11 = by14;
HXLINE(  24)				bx14 = cx14;
HXLINE(  25)				by14 = cy14;
HXLINE(  26)				cx14 = bx_11;
HXLINE(  27)				cy14 = by_11;
            			}
HXLINE( 497)			Float v_ax5 = ax8;
HXDLIN( 497)			Float v_ay5 = ay8;
HXDLIN( 497)			Float v_bx5 = bx14;
HXDLIN( 497)			Float v_by5 = by14;
HXDLIN( 497)			Float v_cx5 = cx14;
HXDLIN( 497)			Float v_cy5 = cy14;
HXDLIN( 497)			bool v_preCalculated5 = true;
HXDLIN( 497)			{
HXDLIN( 497)				v_s05 = ((v_ay5 * v_cx5) - (v_ax5 * v_cy5));
HXDLIN( 497)				v_sx5 = (v_cy5 - v_ay5);
HXDLIN( 497)				v_sy5 = (v_ax5 - v_cx5);
HXDLIN( 497)				v_t05 = ((v_ax5 * v_by5) - (v_ay5 * v_bx5));
HXDLIN( 497)				v_tx5 = (v_ay5 - v_by5);
HXDLIN( 497)				v_ty5 = (v_bx5 - v_ax5);
HXDLIN( 497)				v_A5 = ((((-(v_by5) * v_cx5) + (v_ay5 * (-(v_bx5) + v_cx5))) + (v_ax5 * (v_by5 - v_cy5))) + (v_bx5 * v_cy5));
HXDLIN( 497)				Float a49 = v_ax5;
HXDLIN( 497)				Float b50 = v_bx5;
HXDLIN( 497)				Float c34 = v_cx5;
HXDLIN( 497)				if ((a49 > b50)) {
HXDLIN( 497)					if ((a49 > c34)) {
HXDLIN( 497)						int min44;
HXDLIN( 497)						if ((b50 > c34)) {
HXDLIN( 497)							min44 = ::Math_obj::floor(c34);
            						}
            						else {
HXDLIN( 497)							min44 = ::Math_obj::floor(b50);
            						}
HXDLIN( 497)						int ii_min88 = min44;
HXDLIN( 497)						int ii_max88 = ::Math_obj::ceil(a49);
HXDLIN( 497)						v_xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min88,ii_max88);
            					}
            					else {
HXDLIN( 497)						int ii_min89 = ::Math_obj::floor(b50);
HXDLIN( 497)						int ii_max89 = ::Math_obj::ceil(c34);
HXDLIN( 497)						v_xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min89,ii_max89);
            					}
            				}
            				else {
HXDLIN( 497)					if ((b50 > c34)) {
HXDLIN( 497)						int min45;
HXDLIN( 497)						if ((a49 > c34)) {
HXDLIN( 497)							min45 = ::Math_obj::floor(c34);
            						}
            						else {
HXDLIN( 497)							min45 = ::Math_obj::ceil(a49);
            						}
HXDLIN( 497)						int ii_min90 = min45;
HXDLIN( 497)						int ii_max90 = ::Math_obj::ceil(b50);
HXDLIN( 497)						v_xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min90,ii_max90);
            					}
            					else {
HXDLIN( 497)						int ii_min91 = ::Math_obj::floor(a49);
HXDLIN( 497)						int ii_max91 = ::Math_obj::ceil(c34);
HXDLIN( 497)						v_xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min91,ii_max91);
            					}
            				}
HXDLIN( 497)				Float a50 = v_ay5;
HXDLIN( 497)				Float b51 = v_by5;
HXDLIN( 497)				Float c35 = v_cy5;
HXDLIN( 497)				if ((a50 > b51)) {
HXDLIN( 497)					if ((a50 > c35)) {
HXDLIN( 497)						int min46;
HXDLIN( 497)						if ((b51 > c35)) {
HXDLIN( 497)							min46 = ::Math_obj::floor(c35);
            						}
            						else {
HXDLIN( 497)							min46 = ::Math_obj::floor(b51);
            						}
HXDLIN( 497)						int ii_min92 = min46;
HXDLIN( 497)						int ii_max92 = ::Math_obj::ceil(a50);
HXDLIN( 497)						v_yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min92,ii_max92);
            					}
            					else {
HXDLIN( 497)						int ii_min93 = ::Math_obj::floor(b51);
HXDLIN( 497)						int ii_max93 = ::Math_obj::ceil(c35);
HXDLIN( 497)						v_yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min93,ii_max93);
            					}
            				}
            				else {
HXDLIN( 497)					if ((b51 > c35)) {
HXDLIN( 497)						int min47;
HXDLIN( 497)						if ((a50 > c35)) {
HXDLIN( 497)							min47 = ::Math_obj::floor(c35);
            						}
            						else {
HXDLIN( 497)							min47 = ::Math_obj::ceil(a50);
            						}
HXDLIN( 497)						int ii_min94 = min47;
HXDLIN( 497)						int ii_max94 = ::Math_obj::ceil(b51);
HXDLIN( 497)						v_yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min94,ii_max94);
            					}
            					else {
HXDLIN( 497)						int ii_min95 = ::Math_obj::floor(a50);
HXDLIN( 497)						int ii_max95 = ::Math_obj::ceil(c35);
HXDLIN( 497)						v_yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min95,ii_max95);
            					}
            				}
            			}
HXDLIN( 497)			if (hasUndo5) {
HXDLIN( 497)				v_undoImage5 = undoImage15;
HXDLIN( 497)				v_undoX5 = xIter35->start;
HXDLIN( 497)				v_undoY5 = yIter35->start;
            			}
HXDLIN( 497)			 ::pi_xy::algo::HitQuad v14 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax6,ay6,bx10,by10,cx10,cy10,dx6,dy6,true);
HXDLIN( 497)			hitQuad = v14;
            		}
HXDLIN( 497)		Float cx15 = h2;
HXDLIN( 497)		Float cy15 = radius2;
HXDLIN( 497)		Float bx15 = h2;
HXDLIN( 497)		Float by15 = -(radius2);
HXDLIN( 497)		Float temp3 = ((Float)0.);
HXLINE( 408)		temp3 = (px + ((bx15 * cos) - (by15 * sin)));
HXLINE( 409)		by15 = (py + ((by15 * cos) + (bx15 * sin)));
HXLINE( 410)		bx15 = temp3;
HXLINE( 411)		temp3 = (px + ((cx15 * cos) - (cy15 * sin)));
HXLINE( 412)		cy15 = (py + ((cy15 * cos) + (cx15 * sin)));
HXLINE( 413)		cx15 = temp3;
HXLINE( 497)		Float bx16 = bx15;
HXDLIN( 497)		Float by16 = by15;
HXDLIN( 497)		Float cx16 = cx15;
HXDLIN( 497)		Float cy16 = cy15;
HXDLIN( 497)		bool hasUndo6 = false;
HXDLIN( 497)		bool adjustWinding12 = (((((qx * by16) - (bx16 * qy)) + ((bx16 * cy16) - (cx16 * by16))) + ((cx16 * qy) - (qx * cy16))) > 0);
HXDLIN( 497)		if (!(adjustWinding12)) {
HXDLIN( 497)			Float bx_12 = bx16;
HXDLIN( 497)			Float by_12 = by16;
HXLINE(  25)			bx16 = cx16;
HXLINE(  26)			by16 = cy16;
HXLINE(  27)			cx16 = bx_12;
HXLINE(  28)			cy16 = by_12;
            		}
HXLINE( 497)		Float s06 = ((qy * cx16) - (qx * cy16));
HXDLIN( 497)		Float sx6 = (cy16 - qy);
HXDLIN( 497)		Float sy6 = (qx - cx16);
HXDLIN( 497)		Float t06 = ((qx * by16) - (qy * bx16));
HXDLIN( 497)		Float tx6 = (qy - by16);
HXDLIN( 497)		Float ty6 = (bx16 - qx);
HXDLIN( 497)		Float A6 = ((((-(by16) * cx16) + (qy * (-(bx16) + cx16))) + (qx * (by16 - cy16))) + (bx16 * cy16));
HXDLIN( 497)		 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN( 497)		if ((qx > bx16)) {
HXDLIN( 497)			if ((qx > cx16)) {
HXDLIN( 497)				int min48;
HXDLIN( 497)				if ((bx16 > cx16)) {
HXDLIN( 497)					min48 = ::Math_obj::floor(cx16);
            				}
            				else {
HXDLIN( 497)					min48 = ::Math_obj::floor(bx16);
            				}
HXDLIN( 497)				int ii_min96 = min48;
HXDLIN( 497)				int ii_max96 = ::Math_obj::ceil(qx);
HXDLIN( 497)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min96,ii_max96);
            			}
            			else {
HXDLIN( 497)				int ii_min97 = ::Math_obj::floor(bx16);
HXDLIN( 497)				int ii_max97 = ::Math_obj::ceil(cx16);
HXDLIN( 497)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min97,ii_max97);
            			}
            		}
            		else {
HXDLIN( 497)			if ((bx16 > cx16)) {
HXDLIN( 497)				int min49;
HXDLIN( 497)				if ((qx > cx16)) {
HXDLIN( 497)					min49 = ::Math_obj::floor(cx16);
            				}
            				else {
HXDLIN( 497)					min49 = ::Math_obj::ceil(qx);
            				}
HXDLIN( 497)				int ii_min98 = min49;
HXDLIN( 497)				int ii_max98 = ::Math_obj::ceil(bx16);
HXDLIN( 497)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min98,ii_max98);
            			}
            			else {
HXDLIN( 497)				int ii_min99 = ::Math_obj::floor(qx);
HXDLIN( 497)				int ii_max99 = ::Math_obj::ceil(cx16);
HXDLIN( 497)				xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min99,ii_max99);
            			}
            		}
HXDLIN( 497)		 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN( 497)		if ((qy > by16)) {
HXDLIN( 497)			if ((qy > cy16)) {
HXDLIN( 497)				int min50;
HXDLIN( 497)				if ((by16 > cy16)) {
HXDLIN( 497)					min50 = ::Math_obj::floor(cy16);
            				}
            				else {
HXDLIN( 497)					min50 = ::Math_obj::floor(by16);
            				}
HXDLIN( 497)				int ii_min100 = min50;
HXDLIN( 497)				int ii_max100 = ::Math_obj::ceil(qy);
HXDLIN( 497)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min100,ii_max100);
            			}
            			else {
HXDLIN( 497)				int ii_min101 = ::Math_obj::floor(by16);
HXDLIN( 497)				int ii_max101 = ::Math_obj::ceil(cy16);
HXDLIN( 497)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min101,ii_max101);
            			}
            		}
            		else {
HXDLIN( 497)			if ((by16 > cy16)) {
HXDLIN( 497)				int min51;
HXDLIN( 497)				if ((qy > cy16)) {
HXDLIN( 497)					min51 = ::Math_obj::floor(cy16);
            				}
            				else {
HXDLIN( 497)					min51 = ::Math_obj::ceil(qy);
            				}
HXDLIN( 497)				int ii_min102 = min51;
HXDLIN( 497)				int ii_max102 = ::Math_obj::ceil(by16);
HXDLIN( 497)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min102,ii_max102);
            			}
            			else {
HXDLIN( 497)				int ii_min103 = ::Math_obj::floor(qy);
HXDLIN( 497)				int ii_max103 = ::Math_obj::ceil(cy16);
HXDLIN( 497)				yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min103,ii_max103);
            			}
            		}
HXDLIN( 497)		 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN( 497)		if (hasUndo6) {
HXDLIN( 497)			int width6 = ((xIter36->max - xIter36->start) + 1);
HXDLIN( 497)			int height6 = ((yIter36->max - yIter36->start) + 1);
HXDLIN( 497)			 ::Dynamic imageType6 = null();
HXDLIN( 497)			 ::pi_xy::ImageStruct this200 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 497)			if (::hx::IsNull( imageType6 )) {
HXLINE(  54)				imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 497)			::Dynamic undoImage19;
HXDLIN( 497)			switch((int)(( (int)(imageType6) ))){
            				case (int)0: {
HXDLIN( 497)					 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 497)					 ::iterMagic::BytesImg b52 = byt6;
HXDLIN( 497)					{
HXDLIN( 497)						b52->width = width6;
HXDLIN( 497)						b52->height = height6;
HXDLIN( 497)						b52->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 497)						b52->data = ::haxe::io::Bytes_obj::alloc((b52->length * 4));
HXDLIN( 497)						{
HXDLIN( 497)							int len12 = b52->length;
HXDLIN( 497)							int w6 = 0;
HXDLIN( 497)							{
HXDLIN( 497)								int _g120 = 0;
HXDLIN( 497)								int _g121 = b52->height;
HXDLIN( 497)								while((_g120 < _g121)){
HXDLIN( 497)									_g120 = (_g120 + 1);
HXDLIN( 497)									int y24 = (_g120 - 1);
HXDLIN( 497)									{
HXDLIN( 497)										int _g122 = 0;
HXDLIN( 497)										int _g123 = b52->width;
HXDLIN( 497)										while((_g122 < _g123)){
HXDLIN( 497)											_g122 = (_g122 + 1);
HXDLIN( 497)											int x24 = (_g122 - 1);
HXDLIN( 497)											{
HXDLIN( 497)												w6 = (w6 + 1);
HXDLIN( 497)												b52->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 497)											{
HXDLIN( 497)												w6 = (w6 + 1);
HXDLIN( 497)												b52->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 497)											{
HXDLIN( 497)												w6 = (w6 + 1);
HXDLIN( 497)												b52->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 497)											{
HXDLIN( 497)												w6 = (w6 + 1);
HXDLIN( 497)												b52->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 497)					undoImage19 = b52;
            				}
            				break;
            				case (int)1: {
HXDLIN( 497)					 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)					 ::iterMagic::ArrIntImg a51 = arrI6;
HXDLIN( 497)					{
HXDLIN( 497)						a51->width = width6;
HXDLIN( 497)						a51->height = height6;
HXDLIN( 497)						a51->data = ::Array_obj< int >::__new(0);
HXDLIN( 497)						a51->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 497)						{
HXDLIN( 497)							int _g124 = 0;
HXDLIN( 497)							int _g125 = a51->length;
HXDLIN( 497)							while((_g124 < _g125)){
HXDLIN( 497)								_g124 = (_g124 + 1);
HXDLIN( 497)								int i36 = (_g124 - 1);
HXDLIN( 497)								a51->data[i36] = 0;
            							}
            						}
            					}
HXDLIN( 497)					undoImage19 = a51;
            				}
            				break;
            				case (int)2: {
HXDLIN( 497)					 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 497)					 ::iterMagic::U32ArrImg b53 = u32a6;
HXDLIN( 497)					{
HXDLIN( 497)						b53->width = width6;
HXDLIN( 497)						b53->height = height6;
HXDLIN( 497)						b53->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 497)						int size6 = (b53->length * 4);
HXDLIN( 497)						b53->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN( 497)						{
HXDLIN( 497)							int _g126 = 0;
HXDLIN( 497)							int _g127 = b53->length;
HXDLIN( 497)							while((_g126 < _g127)){
HXDLIN( 497)								_g126 = (_g126 + 1);
HXDLIN( 497)								int i37 = (_g126 - 1);
HXDLIN( 497)								{
HXDLIN( 497)									 ::haxe::io::ArrayBufferViewImpl this201 = b53->data;
HXDLIN( 497)									bool undoImage20;
HXDLIN( 497)									if ((i37 >= 0)) {
HXDLIN( 497)										undoImage20 = (i37 < (this201->byteLength >> 2));
            									}
            									else {
HXDLIN( 497)										undoImage20 = false;
            									}
HXDLIN( 497)									if (undoImage20) {
HXDLIN( 497)										 ::haxe::io::Bytes _this6 = this201->bytes;
HXDLIN( 497)										int pos6 = ((i37 << 2) + this201->byteOffset);
HXDLIN( 497)										_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN( 497)										_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN( 497)										_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN( 497)										_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 497)					undoImage19 = b53;
            				}
            				break;
            				case (int)3: {
HXDLIN( 497)					 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)					 ::iterMagic::VecIntImg v15 = vec6;
HXDLIN( 497)					{
HXDLIN( 497)						v15->width = width6;
HXDLIN( 497)						v15->height = height6;
HXDLIN( 497)						v15->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 497)						v15->data = ::Array_obj< int >::__new(v15->length);
HXDLIN( 497)						{
HXDLIN( 497)							int _g128 = 0;
HXDLIN( 497)							int _g129 = v15->length;
HXDLIN( 497)							while((_g128 < _g129)){
HXDLIN( 497)								_g128 = (_g128 + 1);
HXDLIN( 497)								int i38 = (_g128 - 1);
HXDLIN( 497)								v15->data->__unsafe_set(i38,0);
            							}
            						}
            					}
HXDLIN( 497)					undoImage19 = v15;
            				}
            				break;
            				case (int)4: {
HXDLIN( 497)					 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 497)					 ::iterMagic::StackIntImg b54 = sInt6;
HXDLIN( 497)					{
HXDLIN( 497)						b54->width = width6;
HXDLIN( 497)						b54->height = height6;
HXDLIN( 497)						b54->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN( 497)						b54->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 497)						{
HXDLIN( 497)							int len13 = b54->length;
HXDLIN( 497)							 ::haxe::ds::GenericStack_Int d6 = b54->data;
HXDLIN( 497)							if (::hx::IsNull( d6->head )) {
HXDLIN( 497)								int _g130 = 0;
HXDLIN( 497)								int _g131 = len13;
HXDLIN( 497)								while((_g130 < _g131)){
HXDLIN( 497)									_g130 = (_g130 + 1);
HXDLIN( 497)									int i39 = (_g130 - 1);
HXDLIN( 497)									d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            								}
            							}
            							else {
HXDLIN( 497)								int _g132 = 0;
HXDLIN( 497)								int _g133 = len13;
HXDLIN( 497)								while((_g132 < _g133)){
HXDLIN( 497)									_g132 = (_g132 + 1);
HXDLIN( 497)									int i40 = (_g132 - 1);
HXDLIN( 497)									{
HXDLIN( 497)										 ::haxe::ds::GenericCell_Int l6 = b54->data->head;
HXDLIN( 497)										 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN( 497)										{
HXDLIN( 497)											int _g134 = 0;
HXDLIN( 497)											int _g135 = i40;
HXDLIN( 497)											while((_g134 < _g135)){
HXDLIN( 497)												_g134 = (_g134 + 1);
HXDLIN( 497)												int i41 = (_g134 - 1);
HXLINE( 345)												prev6 = l6;
HXLINE( 346)												l6 = l6->next;
            											}
            										}
HXLINE( 497)										if (::hx::IsNull( prev6 )) {
HXDLIN( 497)											b54->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 497)											l6 = null();
            										}
            										else {
HXDLIN( 497)											prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN( 497)											l6 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 497)					undoImage19 = b54;
            				}
            				break;
            			}
HXDLIN( 497)			this200->image = undoImage19;
HXDLIN( 497)			this200->width = width6;
HXDLIN( 497)			this200->height = height6;
HXDLIN( 497)			this200->imageType = ( (int)(imageType6) );
HXDLIN( 497)			undoImage18 = this200;
HXDLIN( 497)			{
HXDLIN( 497)				int rectLeft6 = xIter36->start;
HXDLIN( 497)				int rectTop6 = yIter36->start;
HXDLIN( 497)				int rectRight6 = xIter36->max;
HXDLIN( 497)				bool forceClear6 = false;
HXDLIN( 497)				{
HXDLIN( 497)					int _g136 = rectTop6;
HXDLIN( 497)					int _g137 = yIter36->max;
HXDLIN( 497)					while((_g136 < _g137)){
HXDLIN( 497)						_g136 = (_g136 + 1);
HXDLIN( 497)						int dy9 = (_g136 - 1);
HXDLIN( 497)						{
HXDLIN( 497)							int _g138 = rectLeft6;
HXDLIN( 497)							int _g139 = rectRight6;
HXDLIN( 497)							while((_g138 < _g139)){
HXDLIN( 497)								_g138 = (_g138 + 1);
HXDLIN( 497)								int dx9 = (_g138 - 1);
HXDLIN( 497)								::Dynamic this202 = this1->image;
HXDLIN( 497)								int index30;
HXDLIN( 497)								if (this1->useVirtualPos) {
HXDLIN( 497)									index30 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx9) - this1->virtualX));
            								}
            								else {
HXDLIN( 497)									index30 = ::Std_obj::_hx_int(( (Float)(((dy9 * this1->width) + dx9)) ));
            								}
HXDLIN( 497)								int c36 = ::iterMagic::Iimg_obj::get(this202,index30);
HXDLIN( 497)								int col6;
HXDLIN( 497)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)									col6 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            								}
            								else {
HXDLIN( 497)									col6 = c36;
            								}
HXDLIN( 497)								bool _hx_tmp;
HXDLIN( 497)								if (this1->useMask) {
HXDLIN( 497)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 497)									_hx_tmp = false;
            								}
HXDLIN( 497)								if (_hx_tmp) {
HXDLIN( 497)									 ::pi_xy::ImageStruct this203 = this1->mask;
HXDLIN( 497)									::Dynamic this204 = this203->image;
HXDLIN( 497)									int index31;
HXDLIN( 497)									if (this203->useVirtualPos) {
HXDLIN( 497)										index31 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this203->virtualY) * ( (Float)(this203->width) )) + dx9) - this203->virtualX));
            									}
            									else {
HXDLIN( 497)										index31 = ::Std_obj::_hx_int(( (Float)(((dy9 * this203->width) + dx9)) ));
            									}
HXDLIN( 497)									int c37 = ::iterMagic::Iimg_obj::get(this204,index31);
HXDLIN( 497)									int v16;
HXDLIN( 497)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)										v16 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            									}
            									else {
HXDLIN( 497)										v16 = c37;
            									}
HXDLIN( 497)									int maskPixel6 = v16;
HXDLIN( 497)									int this205 = col6;
HXDLIN( 497)									if ((maskPixel6 == 0)) {
HXDLIN( 497)										col6 = this205;
            									}
            									else {
HXDLIN( 497)										Float m06;
HXDLIN( 497)										int this206 = ((maskPixel6 >> 24) & 255);
HXDLIN( 497)										if ((this206 == 0)) {
HXDLIN( 497)											m06 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											m06 = (( (Float)(this206) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float m16;
HXDLIN( 497)										int this207 = ((maskPixel6 >> 16) & 255);
HXDLIN( 497)										if ((this207 == 0)) {
HXDLIN( 497)											m16 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											m16 = (( (Float)(this207) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float m26;
HXDLIN( 497)										int this208 = ((maskPixel6 >> 8) & 255);
HXDLIN( 497)										if ((this208 == 0)) {
HXDLIN( 497)											m26 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											m26 = (( (Float)(this208) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float m36;
HXDLIN( 497)										int this209 = (maskPixel6 & 255);
HXDLIN( 497)										if ((this209 == 0)) {
HXDLIN( 497)											m36 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											m36 = (( (Float)(this209) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this205 >> 24) & 255)) )));
HXDLIN( 497)										int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this205 >> 16) & 255)) )));
HXDLIN( 497)										int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this205 >> 8) & 255)) )));
HXDLIN( 497)										int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this205 & 255)) )));
HXDLIN( 497)										col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 497)								if ((col6 != 0)) {
HXDLIN( 497)									int x25 = (dx9 - rectLeft6);
HXDLIN( 497)									int y25 = (dy9 - rectTop6);
HXDLIN( 497)									int c38 = col6;
HXDLIN( 497)									bool _hx_tmp1;
HXDLIN( 497)									if ((((c38 >> 24) & 255) < 254)) {
HXDLIN( 497)										_hx_tmp1 = undoImage18->transparent;
            									}
            									else {
HXDLIN( 497)										_hx_tmp1 = false;
            									}
HXDLIN( 497)									if (_hx_tmp1) {
HXDLIN( 497)										int location12;
HXDLIN( 497)										if (undoImage18->useVirtualPos) {
HXDLIN( 497)											location12 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x25) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 497)											location12 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage18->width) + x25)) ));
            										}
HXDLIN( 497)										int this210 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN( 497)										int this211;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											this211 = ((((((this210 >> 24) & 255) << 24) | ((this210 & 255) << 16)) | (((this210 >> 8) & 255) << 8)) | ((this210 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											this211 = this210;
            										}
HXDLIN( 497)										Float a117;
HXDLIN( 497)										int this212 = ((this211 >> 24) & 255);
HXDLIN( 497)										if ((this212 == 0)) {
HXDLIN( 497)											a117 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											a117 = (( (Float)(this212) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float r112;
HXDLIN( 497)										int this213 = ((this211 >> 16) & 255);
HXDLIN( 497)										if ((this213 == 0)) {
HXDLIN( 497)											r112 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											r112 = (( (Float)(this213) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float g112;
HXDLIN( 497)										int this214 = ((this211 >> 8) & 255);
HXDLIN( 497)										if ((this214 == 0)) {
HXDLIN( 497)											g112 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											g112 = (( (Float)(this214) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float b118;
HXDLIN( 497)										int this215 = (this211 & 255);
HXDLIN( 497)										if ((this215 == 0)) {
HXDLIN( 497)											b118 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											b118 = (( (Float)(this215) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float a215;
HXDLIN( 497)										int this216 = ((col6 >> 24) & 255);
HXDLIN( 497)										if ((this216 == 0)) {
HXDLIN( 497)											a215 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											a215 = (( (Float)(this216) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float r212;
HXDLIN( 497)										int this217 = ((col6 >> 16) & 255);
HXDLIN( 497)										if ((this217 == 0)) {
HXDLIN( 497)											r212 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											r212 = (( (Float)(this217) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float g212;
HXDLIN( 497)										int this218 = ((col6 >> 8) & 255);
HXDLIN( 497)										if ((this218 == 0)) {
HXDLIN( 497)											g212 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											g212 = (( (Float)(this218) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float b216;
HXDLIN( 497)										int this219 = (col6 & 255);
HXDLIN( 497)										if ((this219 == 0)) {
HXDLIN( 497)											b216 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											b216 = (( (Float)(this219) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN( 497)										int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a314) + (r212 * a215))));
HXDLIN( 497)										int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a314) + (g212 * a215))));
HXDLIN( 497)										int b55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b216 * a215))));
HXDLIN( 497)										int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN( 497)										int blended12 = ((((a52 << 24) | (r32 << 16)) | (g32 << 8)) | b55);
HXDLIN( 497)										{
HXDLIN( 497)											int _hx_tmp2;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												_hx_tmp2 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												_hx_tmp2 = blended12;
            											}
HXDLIN( 497)											::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 497)										::Dynamic this220 = undoImage18->image;
HXDLIN( 497)										int index32;
HXDLIN( 497)										if (undoImage18->useVirtualPos) {
HXDLIN( 497)											index32 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x25) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 497)											index32 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage18->width) + x25)) ));
            										}
HXDLIN( 497)										int _hx_tmp3;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											_hx_tmp3 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											_hx_tmp3 = c38;
            										}
HXDLIN( 497)										::iterMagic::Iimg_obj::set(this220,index32,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 497)									if (forceClear6) {
HXDLIN( 497)										::Dynamic this221 = undoImage18->image;
HXDLIN( 497)										int x26 = (dx9 - rectLeft6);
HXDLIN( 497)										int y26 = (dy9 - rectTop6);
HXDLIN( 497)										int index33;
HXDLIN( 497)										if (undoImage18->useVirtualPos) {
HXDLIN( 497)											index33 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x26) - undoImage18->virtualX));
            										}
            										else {
HXDLIN( 497)											index33 = ::Std_obj::_hx_int(( (Float)(((y26 * undoImage18->width) + x26)) ));
            										}
HXDLIN( 497)										::iterMagic::Iimg_obj::set(this221,index33,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 497)		bool found6 = false;
HXDLIN( 497)		Float s6 = ((Float)0.);
HXDLIN( 497)		Float t6 = ((Float)0.);
HXDLIN( 497)		Float sxx6 = ((Float)0.);
HXDLIN( 497)		Float txx6 = ((Float)0.);
HXDLIN( 497)		{
HXDLIN( 497)			int _g_min12 = xIter36->start;
HXDLIN( 497)			int _g_max12 = xIter36->max;
HXDLIN( 497)			while((_g_min12 < _g_max12)){
HXDLIN( 497)				_g_min12 = (_g_min12 + 1);
HXDLIN( 497)				int x27 = (_g_min12 - 1);
HXLINE(  60)				sxx6 = (sx6 * ( (Float)(x27) ));
HXLINE(  61)				txx6 = (tx6 * ( (Float)(x27) ));
HXLINE(  62)				found6 = false;
HXLINE( 497)				{
HXDLIN( 497)					int _g_min13 = yIter36->start;
HXDLIN( 497)					int _g_max13 = yIter36->max;
HXDLIN( 497)					while((_g_min13 < _g_max13)){
HXDLIN( 497)						_g_min13 = (_g_min13 + 1);
HXDLIN( 497)						int y27 = (_g_min13 - 1);
HXLINE(  64)						s6 = ((s06 + sxx6) + (sy6 * ( (Float)(y27) )));
HXLINE(  65)						t6 = ((t06 + txx6) + (ty6 * ( (Float)(y27) )));
HXLINE( 497)						bool _hx_tmp4;
HXDLIN( 497)						if (!((s6 <= 0))) {
HXDLIN( 497)							_hx_tmp4 = (t6 <= 0);
            						}
            						else {
HXDLIN( 497)							_hx_tmp4 = true;
            						}
HXDLIN( 497)						if (_hx_tmp4) {
HXDLIN( 497)							if (found6) {
HXDLIN( 497)								goto _hx_goto_993;
            							}
            						}
            						else {
HXDLIN( 497)							if (((s6 + t6) < A6)) {
HXDLIN( 497)								{
HXDLIN( 497)									int c39 = color;
HXDLIN( 497)									bool _hx_tmp5;
HXDLIN( 497)									if ((((c39 >> 24) & 255) < 254)) {
HXDLIN( 497)										_hx_tmp5 = this1->transparent;
            									}
            									else {
HXDLIN( 497)										_hx_tmp5 = false;
            									}
HXDLIN( 497)									if (_hx_tmp5) {
HXDLIN( 497)										int location13;
HXDLIN( 497)										if (this1->useVirtualPos) {
HXDLIN( 497)											location13 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this1->virtualY) * ( (Float)(this1->width) )) + x27) - this1->virtualX));
            										}
            										else {
HXDLIN( 497)											location13 = ::Std_obj::_hx_int(( (Float)(((y27 * this1->width) + x27)) ));
            										}
HXDLIN( 497)										int this222 = ::iterMagic::Iimg_obj::get(this1->image,location13);
HXDLIN( 497)										int this223;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											this223 = ((((((this222 >> 24) & 255) << 24) | ((this222 & 255) << 16)) | (((this222 >> 8) & 255) << 8)) | ((this222 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											this223 = this222;
            										}
HXDLIN( 497)										Float a118;
HXDLIN( 497)										int this224 = ((this223 >> 24) & 255);
HXDLIN( 497)										if ((this224 == 0)) {
HXDLIN( 497)											a118 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											a118 = (( (Float)(this224) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float r113;
HXDLIN( 497)										int this225 = ((this223 >> 16) & 255);
HXDLIN( 497)										if ((this225 == 0)) {
HXDLIN( 497)											r113 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											r113 = (( (Float)(this225) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float g113;
HXDLIN( 497)										int this226 = ((this223 >> 8) & 255);
HXDLIN( 497)										if ((this226 == 0)) {
HXDLIN( 497)											g113 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											g113 = (( (Float)(this226) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float b119;
HXDLIN( 497)										int this227 = (this223 & 255);
HXDLIN( 497)										if ((this227 == 0)) {
HXDLIN( 497)											b119 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											b119 = (( (Float)(this227) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float a216;
HXDLIN( 497)										int this228 = ((color >> 24) & 255);
HXDLIN( 497)										if ((this228 == 0)) {
HXDLIN( 497)											a216 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											a216 = (( (Float)(this228) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float r213;
HXDLIN( 497)										int this229 = ((color >> 16) & 255);
HXDLIN( 497)										if ((this229 == 0)) {
HXDLIN( 497)											r213 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											r213 = (( (Float)(this229) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float g213;
HXDLIN( 497)										int this230 = ((color >> 8) & 255);
HXDLIN( 497)										if ((this230 == 0)) {
HXDLIN( 497)											g213 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											g213 = (( (Float)(this230) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float b217;
HXDLIN( 497)										int this231 = (color & 255);
HXDLIN( 497)										if ((this231 == 0)) {
HXDLIN( 497)											b217 = ((Float)0.);
            										}
            										else {
HXDLIN( 497)											b217 = (( (Float)(this231) ) / ( (Float)(255) ));
            										}
HXDLIN( 497)										Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN( 497)										int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a315) + (r213 * a216))));
HXDLIN( 497)										int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a315) + (g213 * a216))));
HXDLIN( 497)										int b56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a315) + (b217 * a216))));
HXDLIN( 497)										int a53 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN( 497)										int blended13 = ((((a53 << 24) | (r33 << 16)) | (g33 << 8)) | b56);
HXDLIN( 497)										{
HXDLIN( 497)											int _hx_tmp6;
HXDLIN( 497)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)												_hx_tmp6 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            											}
            											else {
HXDLIN( 497)												_hx_tmp6 = blended13;
            											}
HXDLIN( 497)											::iterMagic::Iimg_obj::set(this1->image,location13,_hx_tmp6);
            										}
            									}
            									else {
HXDLIN( 497)										::Dynamic this232 = this1->image;
HXDLIN( 497)										int index34;
HXDLIN( 497)										if (this1->useVirtualPos) {
HXDLIN( 497)											index34 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this1->virtualY) * ( (Float)(this1->width) )) + x27) - this1->virtualX));
            										}
            										else {
HXDLIN( 497)											index34 = ::Std_obj::_hx_int(( (Float)(((y27 * this1->width) + x27)) ));
            										}
HXDLIN( 497)										int _hx_tmp7;
HXDLIN( 497)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 497)											_hx_tmp7 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            										}
            										else {
HXDLIN( 497)											_hx_tmp7 = c39;
            										}
HXDLIN( 497)										::iterMagic::Iimg_obj::set(this232,index34,_hx_tmp7);
            									}
            								}
HXLINE(  73)								found6 = true;
            							}
            							else {
HXDLIN( 497)								if (found6) {
HXDLIN( 497)									goto _hx_goto_993;
            								}
            							}
            						}
            					}
            					_hx_goto_993:;
            				}
            			}
            		}
HXDLIN( 497)		 ::pi_xy::algo::HitTri hitTri;
HXDLIN( 497)		if ((hasHit == true)) {
HXDLIN( 497)			 ::pi_xy::algo::HitTri v17 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx16,by16,cx16,cy16,true);
HXDLIN( 497)			if (hasUndo6) {
HXDLIN( 497)				v17->undoImage = undoImage18;
HXDLIN( 497)				v17->undoX = xIter36->start;
HXDLIN( 497)				v17->undoY = yIter36->start;
            			}
HXDLIN( 497)			hitTri = v17;
            		}
            		else {
HXDLIN( 497)			hitTri = null();
            		}
HXDLIN( 497)		if (hasHit) {
HXDLIN( 497)			 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN( 497)			if (::hx::IsNotNull( hitQuad )) {
HXDLIN( 497)				hitArr->triArr->push(hitQuad->triABD);
            			}
HXDLIN( 497)			hitArr->triArr->push(hitQuad->triBCD);
HXDLIN( 497)			return hitArr;
            		}
            		else {
HXDLIN( 497)			return null();
            		}
HXDLIN( 497)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC12(FillShape_Impl__obj,fixArrow,return )

 ::pi_xy::algo::HitTriArray FillShape_Impl__obj::fixArrowBoth( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float arrowWidth,Float arrowHeight,Float thick,int color,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_513_fixArrowBoth)
HXDLIN( 513)		Float goldenRatio = ((Float)1.61803398875);
HXDLIN( 513)		Float o = (qy - py);
HXDLIN( 513)		Float a = (qx - px);
HXDLIN( 513)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN( 513)		Float theta = ::Math_obj::atan2(o,a);
HXDLIN( 513)		Float thicker;
HXDLIN( 513)		if ((arrowWidth > (thick * ((Float)1.1)))) {
HXDLIN( 513)			thicker = arrowWidth;
            		}
            		else {
HXDLIN( 513)			thicker = ((( (Float)(2) ) * thick) * goldenRatio);
            		}
HXDLIN( 513)		Float sin = ::Math_obj::sin(theta);
HXDLIN( 513)		Float cos = ::Math_obj::cos(theta);
HXDLIN( 513)		Float radius = (thick / ( (Float)(2) ));
HXDLIN( 513)		Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN( 513)		Float h2;
HXDLIN( 513)		if ((arrowHeight < (h * ((Float)1.1)))) {
HXDLIN( 513)			h2 = (h - arrowHeight);
            		}
            		else {
HXDLIN( 513)			h2 = (h / goldenRatio);
            		}
HXDLIN( 513)		Float hSmall = (h - h2);
HXDLIN( 513)		Float px_ = hSmall;
HXDLIN( 513)		Float py_ = ((Float)0.);
HXDLIN( 513)		Float temp = ((Float)0.);
HXLINE( 577)		temp = (px + ((px_ * cos) - (py_ * sin)));
HXLINE( 578)		py_ = (py + ((py_ * cos) + (px_ * sin)));
HXLINE( 579)		px_ = temp;
HXLINE( 513)		Float h1 = (h2 - hSmall);
HXDLIN( 513)		Float sin1 = ::Math_obj::sin(theta);
HXDLIN( 513)		Float cos1 = ::Math_obj::cos(theta);
HXDLIN( 513)		Float radius1 = (thick / ( (Float)(2) ));
HXDLIN( 513)		Float dx = ((Float)0.1);
HXDLIN( 513)		Float dy = radius1;
HXDLIN( 513)		Float cx = h1;
HXDLIN( 513)		Float cy = radius1;
HXDLIN( 513)		Float bx = h1;
HXDLIN( 513)		Float by = -(radius1);
HXDLIN( 513)		Float ax = ((Float)0.1);
HXDLIN( 513)		Float ay = -(radius1);
HXDLIN( 513)		Float temp1 = ((Float)0.);
HXLINE(  28)		temp1 = (px_ + ((ax * cos1) - (ay * sin1)));
HXLINE(  29)		ay = (py_ + ((ay * cos1) + (ax * sin1)));
HXLINE(  30)		ax = temp1;
HXLINE(  32)		temp1 = (px_ + ((bx * cos1) - (by * sin1)));
HXLINE(  33)		by = (py_ + ((by * cos1) + (bx * sin1)));
HXLINE(  34)		bx = temp1;
HXLINE(  36)		temp1 = (px_ + ((cx * cos1) - (cy * sin1)));
HXLINE(  37)		cy = (py_ + ((cy * cos1) + (cx * sin1)));
HXLINE(  38)		cx = temp1;
HXLINE(  40)		temp1 = (px_ + ((dx * cos1) - (dy * sin1)));
HXLINE(  41)		dy = (py_ + ((dy * cos1) + (dx * sin1)));
HXLINE(  42)		dx = temp1;
HXLINE( 513)		Float bx1 = bx;
HXDLIN( 513)		Float by1 = by;
HXDLIN( 513)		Float cx1 = dx;
HXDLIN( 513)		Float cy1 = dy;
HXDLIN( 513)		bool hasUndo = false;
HXDLIN( 513)		bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 513)		if (!(adjustWinding)) {
HXDLIN( 513)			Float bx_ = bx1;
HXDLIN( 513)			Float by_ = by1;
HXLINE(  25)			bx1 = cx1;
HXLINE(  26)			by1 = cy1;
HXLINE(  27)			cx1 = bx_;
HXLINE(  28)			cy1 = by_;
            		}
HXLINE( 513)		Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 513)		Float sx = (cy1 - ay);
HXDLIN( 513)		Float sy = (ax - cx1);
HXDLIN( 513)		Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 513)		Float tx = (ay - by1);
HXDLIN( 513)		Float ty = (bx1 - ax);
HXDLIN( 513)		Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 513)		if ((ax > bx1)) {
HXDLIN( 513)			if ((ax > cx1)) {
HXDLIN( 513)				int min;
HXDLIN( 513)				if ((bx1 > cx1)) {
HXDLIN( 513)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN( 513)					min = ::Math_obj::floor(bx1);
            				}
HXDLIN( 513)				int ii_min = min;
HXDLIN( 513)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 513)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN( 513)				int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 513)				int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 513)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN( 513)			if ((bx1 > cx1)) {
HXDLIN( 513)				int min1;
HXDLIN( 513)				if ((ax > cx1)) {
HXDLIN( 513)					min1 = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN( 513)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 513)				int ii_min2 = min1;
HXDLIN( 513)				int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 513)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN( 513)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 513)				int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 513)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 513)		if ((ay > by1)) {
HXDLIN( 513)			if ((ay > cy1)) {
HXDLIN( 513)				int min2;
HXDLIN( 513)				if ((by1 > cy1)) {
HXDLIN( 513)					min2 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN( 513)					min2 = ::Math_obj::floor(by1);
            				}
HXDLIN( 513)				int ii_min4 = min2;
HXDLIN( 513)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 513)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN( 513)				int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 513)				int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 513)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN( 513)			if ((by1 > cy1)) {
HXDLIN( 513)				int min3;
HXDLIN( 513)				if ((ay > cy1)) {
HXDLIN( 513)					min3 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN( 513)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 513)				int ii_min6 = min3;
HXDLIN( 513)				int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 513)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN( 513)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 513)				int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 513)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 513)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 513)		if (hasUndo) {
HXDLIN( 513)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 513)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 513)			 ::Dynamic imageType = null();
HXDLIN( 513)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 513)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 513)			::Dynamic undoImage1;
HXDLIN( 513)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN( 513)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 513)					{
HXDLIN( 513)						b->width = width;
HXDLIN( 513)						b->height = height;
HXDLIN( 513)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 513)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 513)						{
HXDLIN( 513)							int len = b->length;
HXDLIN( 513)							int w = 0;
HXDLIN( 513)							{
HXDLIN( 513)								int _g = 0;
HXDLIN( 513)								int _g1 = b->height;
HXDLIN( 513)								while((_g < _g1)){
HXDLIN( 513)									_g = (_g + 1);
HXDLIN( 513)									int y = (_g - 1);
HXDLIN( 513)									{
HXDLIN( 513)										int _g2 = 0;
HXDLIN( 513)										int _g3 = b->width;
HXDLIN( 513)										while((_g2 < _g3)){
HXDLIN( 513)											_g2 = (_g2 + 1);
HXDLIN( 513)											int x = (_g2 - 1);
HXDLIN( 513)											{
HXDLIN( 513)												w = (w + 1);
HXDLIN( 513)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w = (w + 1);
HXDLIN( 513)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w = (w + 1);
HXDLIN( 513)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w = (w + 1);
HXDLIN( 513)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN( 513)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN( 513)					{
HXDLIN( 513)						a1->width = width;
HXDLIN( 513)						a1->height = height;
HXDLIN( 513)						a1->data = ::Array_obj< int >::__new(0);
HXDLIN( 513)						a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 513)						{
HXDLIN( 513)							int _g4 = 0;
HXDLIN( 513)							int _g5 = a1->length;
HXDLIN( 513)							while((_g4 < _g5)){
HXDLIN( 513)								_g4 = (_g4 + 1);
HXDLIN( 513)								int i = (_g4 - 1);
HXDLIN( 513)								a1->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 513)					undoImage1 = a1;
            				}
            				break;
            				case (int)2: {
HXDLIN( 513)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 513)					{
HXDLIN( 513)						b1->width = width;
HXDLIN( 513)						b1->height = height;
HXDLIN( 513)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 513)						int size = (b1->length * 4);
HXDLIN( 513)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 513)						{
HXDLIN( 513)							int _g6 = 0;
HXDLIN( 513)							int _g7 = b1->length;
HXDLIN( 513)							while((_g6 < _g7)){
HXDLIN( 513)								_g6 = (_g6 + 1);
HXDLIN( 513)								int i1 = (_g6 - 1);
HXDLIN( 513)								{
HXDLIN( 513)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 513)									bool undoImage2;
HXDLIN( 513)									if ((i1 >= 0)) {
HXDLIN( 513)										undoImage2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXDLIN( 513)										undoImage2 = false;
            									}
HXDLIN( 513)									if (undoImage2) {
HXDLIN( 513)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 513)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 513)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 513)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 513)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 513)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN( 513)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 513)					{
HXDLIN( 513)						v->width = width;
HXDLIN( 513)						v->height = height;
HXDLIN( 513)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 513)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 513)						{
HXDLIN( 513)							int _g8 = 0;
HXDLIN( 513)							int _g9 = v->length;
HXDLIN( 513)							while((_g8 < _g9)){
HXDLIN( 513)								_g8 = (_g8 + 1);
HXDLIN( 513)								int i2 = (_g8 - 1);
HXDLIN( 513)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 513)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN( 513)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 513)					{
HXDLIN( 513)						b2->width = width;
HXDLIN( 513)						b2->height = height;
HXDLIN( 513)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 513)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 513)						{
HXDLIN( 513)							int len1 = b2->length;
HXDLIN( 513)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 513)							if (::hx::IsNull( d->head )) {
HXDLIN( 513)								int _g10 = 0;
HXDLIN( 513)								int _g11 = len1;
HXDLIN( 513)								while((_g10 < _g11)){
HXDLIN( 513)									_g10 = (_g10 + 1);
HXDLIN( 513)									int i3 = (_g10 - 1);
HXDLIN( 513)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN( 513)								int _g12 = 0;
HXDLIN( 513)								int _g13 = len1;
HXDLIN( 513)								while((_g12 < _g13)){
HXDLIN( 513)									_g12 = (_g12 + 1);
HXDLIN( 513)									int i4 = (_g12 - 1);
HXDLIN( 513)									{
HXDLIN( 513)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 513)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 513)										{
HXDLIN( 513)											int _g14 = 0;
HXDLIN( 513)											int _g15 = i4;
HXDLIN( 513)											while((_g14 < _g15)){
HXDLIN( 513)												_g14 = (_g14 + 1);
HXDLIN( 513)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 513)										if (::hx::IsNull( prev )) {
HXDLIN( 513)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 513)											l = null();
            										}
            										else {
HXDLIN( 513)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 513)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 513)			this2->image = undoImage1;
HXDLIN( 513)			this2->width = width;
HXDLIN( 513)			this2->height = height;
HXDLIN( 513)			this2->imageType = ( (int)(imageType) );
HXDLIN( 513)			undoImage = this2;
HXDLIN( 513)			{
HXDLIN( 513)				int rectLeft = xIter3->start;
HXDLIN( 513)				int rectTop = yIter3->start;
HXDLIN( 513)				int rectRight = xIter3->max;
HXDLIN( 513)				bool forceClear = false;
HXDLIN( 513)				{
HXDLIN( 513)					int _g16 = rectTop;
HXDLIN( 513)					int _g17 = yIter3->max;
HXDLIN( 513)					while((_g16 < _g17)){
HXDLIN( 513)						_g16 = (_g16 + 1);
HXDLIN( 513)						int dy1 = (_g16 - 1);
HXDLIN( 513)						{
HXDLIN( 513)							int _g18 = rectLeft;
HXDLIN( 513)							int _g19 = rectRight;
HXDLIN( 513)							while((_g18 < _g19)){
HXDLIN( 513)								_g18 = (_g18 + 1);
HXDLIN( 513)								int dx1 = (_g18 - 1);
HXDLIN( 513)								::Dynamic this4 = this1->image;
HXDLIN( 513)								int index;
HXDLIN( 513)								if (this1->useVirtualPos) {
HXDLIN( 513)									index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            								}
            								else {
HXDLIN( 513)									index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            								}
HXDLIN( 513)								int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 513)								int col;
HXDLIN( 513)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN( 513)									col = c;
            								}
HXDLIN( 513)								bool _hx_tmp;
HXDLIN( 513)								if (this1->useMask) {
HXDLIN( 513)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 513)									_hx_tmp = false;
            								}
HXDLIN( 513)								if (_hx_tmp) {
HXDLIN( 513)									 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 513)									::Dynamic this6 = this5->image;
HXDLIN( 513)									int index1;
HXDLIN( 513)									if (this5->useVirtualPos) {
HXDLIN( 513)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            									}
            									else {
HXDLIN( 513)										index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            									}
HXDLIN( 513)									int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 513)									int v1;
HXDLIN( 513)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN( 513)										v1 = c1;
            									}
HXDLIN( 513)									int maskPixel = v1;
HXDLIN( 513)									int this7 = col;
HXDLIN( 513)									if ((maskPixel == 0)) {
HXDLIN( 513)										col = this7;
            									}
            									else {
HXDLIN( 513)										Float m0;
HXDLIN( 513)										int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 513)										if ((this8 == 0)) {
HXDLIN( 513)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m1;
HXDLIN( 513)										int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 513)										if ((this9 == 0)) {
HXDLIN( 513)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m2;
HXDLIN( 513)										int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 513)										if ((this10 == 0)) {
HXDLIN( 513)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m3;
HXDLIN( 513)										int this11 = (maskPixel & 255);
HXDLIN( 513)										if ((this11 == 0)) {
HXDLIN( 513)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 513)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 513)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 513)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 513)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 513)								if ((col != 0)) {
HXDLIN( 513)									int x1 = (dx1 - rectLeft);
HXDLIN( 513)									int y1 = (dy1 - rectTop);
HXDLIN( 513)									int c2 = col;
HXDLIN( 513)									bool _hx_tmp1;
HXDLIN( 513)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 513)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN( 513)										_hx_tmp1 = false;
            									}
HXDLIN( 513)									if (_hx_tmp1) {
HXDLIN( 513)										int location;
HXDLIN( 513)										if (undoImage->useVirtualPos) {
HXDLIN( 513)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 513)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 513)										int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 513)										int this13;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											this13 = this12;
            										}
HXDLIN( 513)										Float a11;
HXDLIN( 513)										int this14 = ((this13 >> 24) & 255);
HXDLIN( 513)										if ((this14 == 0)) {
HXDLIN( 513)											a11 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r1;
HXDLIN( 513)										int this15 = ((this13 >> 16) & 255);
HXDLIN( 513)										if ((this15 == 0)) {
HXDLIN( 513)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g1;
HXDLIN( 513)										int this16 = ((this13 >> 8) & 255);
HXDLIN( 513)										if ((this16 == 0)) {
HXDLIN( 513)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b11;
HXDLIN( 513)										int this17 = (this13 & 255);
HXDLIN( 513)										if ((this17 == 0)) {
HXDLIN( 513)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a2;
HXDLIN( 513)										int this18 = ((col >> 24) & 255);
HXDLIN( 513)										if ((this18 == 0)) {
HXDLIN( 513)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r2;
HXDLIN( 513)										int this19 = ((col >> 16) & 255);
HXDLIN( 513)										if ((this19 == 0)) {
HXDLIN( 513)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g2;
HXDLIN( 513)										int this20 = ((col >> 8) & 255);
HXDLIN( 513)										if ((this20 == 0)) {
HXDLIN( 513)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b21;
HXDLIN( 513)										int this21 = (col & 255);
HXDLIN( 513)										if ((this21 == 0)) {
HXDLIN( 513)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN( 513)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 513)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 513)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 513)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 513)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 513)										{
HXDLIN( 513)											int _hx_tmp2;
HXDLIN( 513)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN( 513)												_hx_tmp2 = blended;
            											}
HXDLIN( 513)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN( 513)										::Dynamic this22 = undoImage->image;
HXDLIN( 513)										int index2;
HXDLIN( 513)										if (undoImage->useVirtualPos) {
HXDLIN( 513)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 513)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 513)										int _hx_tmp3;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											_hx_tmp3 = c2;
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN( 513)									if (forceClear) {
HXDLIN( 513)										::Dynamic this23 = undoImage->image;
HXDLIN( 513)										int x2 = (dx1 - rectLeft);
HXDLIN( 513)										int y2 = (dy1 - rectTop);
HXDLIN( 513)										int index3;
HXDLIN( 513)										if (undoImage->useVirtualPos) {
HXDLIN( 513)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN( 513)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this23,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 513)		bool found = false;
HXDLIN( 513)		Float s = ((Float)0.);
HXDLIN( 513)		Float t = ((Float)0.);
HXDLIN( 513)		Float sxx = ((Float)0.);
HXDLIN( 513)		Float txx = ((Float)0.);
HXDLIN( 513)		{
HXDLIN( 513)			int _g_min = xIter3->start;
HXDLIN( 513)			int _g_max = xIter3->max;
HXDLIN( 513)			while((_g_min < _g_max)){
HXDLIN( 513)				_g_min = (_g_min + 1);
HXDLIN( 513)				int x3 = (_g_min - 1);
HXLINE(  60)				sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)				txx = (tx * ( (Float)(x3) ));
HXLINE(  62)				found = false;
HXLINE( 513)				{
HXDLIN( 513)					int _g_min1 = yIter3->start;
HXDLIN( 513)					int _g_max1 = yIter3->max;
HXDLIN( 513)					while((_g_min1 < _g_max1)){
HXDLIN( 513)						_g_min1 = (_g_min1 + 1);
HXDLIN( 513)						int y3 = (_g_min1 - 1);
HXLINE(  64)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 513)						bool _hx_tmp4;
HXDLIN( 513)						if (!((s <= 0))) {
HXDLIN( 513)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXDLIN( 513)							_hx_tmp4 = true;
            						}
HXDLIN( 513)						if (_hx_tmp4) {
HXDLIN( 513)							if (found) {
HXDLIN( 513)								goto _hx_goto_1006;
            							}
            						}
            						else {
HXDLIN( 513)							if (((s + t) < A)) {
HXDLIN( 513)								{
HXDLIN( 513)									int c3 = color;
HXDLIN( 513)									bool _hx_tmp5;
HXDLIN( 513)									if ((((c3 >> 24) & 255) < 254)) {
HXDLIN( 513)										_hx_tmp5 = this1->transparent;
            									}
            									else {
HXDLIN( 513)										_hx_tmp5 = false;
            									}
HXDLIN( 513)									if (_hx_tmp5) {
HXDLIN( 513)										int location1;
HXDLIN( 513)										if (this1->useVirtualPos) {
HXDLIN( 513)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXDLIN( 513)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN( 513)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 513)										int this25;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											this25 = this24;
            										}
HXDLIN( 513)										Float a12;
HXDLIN( 513)										int this26 = ((this25 >> 24) & 255);
HXDLIN( 513)										if ((this26 == 0)) {
HXDLIN( 513)											a12 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a12 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r11;
HXDLIN( 513)										int this27 = ((this25 >> 16) & 255);
HXDLIN( 513)										if ((this27 == 0)) {
HXDLIN( 513)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g11;
HXDLIN( 513)										int this28 = ((this25 >> 8) & 255);
HXDLIN( 513)										if ((this28 == 0)) {
HXDLIN( 513)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b12;
HXDLIN( 513)										int this29 = (this25 & 255);
HXDLIN( 513)										if ((this29 == 0)) {
HXDLIN( 513)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a21;
HXDLIN( 513)										int this30 = ((color >> 24) & 255);
HXDLIN( 513)										if ((this30 == 0)) {
HXDLIN( 513)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r21;
HXDLIN( 513)										int this31 = ((color >> 16) & 255);
HXDLIN( 513)										if ((this31 == 0)) {
HXDLIN( 513)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g21;
HXDLIN( 513)										int this32 = ((color >> 8) & 255);
HXDLIN( 513)										if ((this32 == 0)) {
HXDLIN( 513)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b22;
HXDLIN( 513)										int this33 = (color & 255);
HXDLIN( 513)										if ((this33 == 0)) {
HXDLIN( 513)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN( 513)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 513)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 513)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 513)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 513)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 513)										{
HXDLIN( 513)											int _hx_tmp6;
HXDLIN( 513)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN( 513)												_hx_tmp6 = blended1;
            											}
HXDLIN( 513)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXDLIN( 513)										::Dynamic this34 = this1->image;
HXDLIN( 513)										int index4;
HXDLIN( 513)										if (this1->useVirtualPos) {
HXDLIN( 513)											index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXDLIN( 513)											index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN( 513)										int _hx_tmp7;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											_hx_tmp7 = c3;
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            									}
            								}
HXLINE(  73)								found = true;
            							}
            							else {
HXDLIN( 513)								if (found) {
HXDLIN( 513)									goto _hx_goto_1006;
            								}
            							}
            						}
            					}
            					_hx_goto_1006:;
            				}
            			}
            		}
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 513)		int v_undoY;
HXDLIN( 513)		int v_undoX;
HXDLIN( 513)		Float v_ty;
HXDLIN( 513)		Float v_tx;
HXDLIN( 513)		Float v_t0;
HXDLIN( 513)		Float v_sy;
HXDLIN( 513)		Float v_sx;
HXDLIN( 513)		Float v_s0;
HXDLIN( 513)		Float v_A;
HXDLIN( 513)		Float ax1 = ax;
HXDLIN( 513)		Float ay1 = ay;
HXDLIN( 513)		 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 513)		Float bx2 = bx1;
HXDLIN( 513)		Float by2 = by1;
HXDLIN( 513)		Float cx2 = cx1;
HXDLIN( 513)		Float cy2 = cy1;
HXDLIN( 513)		bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN( 513)		if (!(adjustWinding1)) {
HXDLIN( 513)			Float bx_1 = bx2;
HXDLIN( 513)			Float by_1 = by2;
HXLINE(  24)			bx2 = cx2;
HXLINE(  25)			by2 = cy2;
HXLINE(  26)			cx2 = bx_1;
HXLINE(  27)			cy2 = by_1;
            		}
HXLINE( 513)		Float v_ax = ax1;
HXDLIN( 513)		Float v_ay = ay1;
HXDLIN( 513)		Float v_bx = bx2;
HXDLIN( 513)		Float v_by = by2;
HXDLIN( 513)		Float v_cx = cx2;
HXDLIN( 513)		Float v_cy = cy2;
HXDLIN( 513)		bool v_preCalculated = true;
HXDLIN( 513)		{
HXDLIN( 513)			v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 513)			v_sx = (v_cy - v_ay);
HXDLIN( 513)			v_sy = (v_ax - v_cx);
HXDLIN( 513)			v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 513)			v_tx = (v_ay - v_by);
HXDLIN( 513)			v_ty = (v_bx - v_ax);
HXDLIN( 513)			v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 513)			Float a6 = v_ax;
HXDLIN( 513)			Float b5 = v_bx;
HXDLIN( 513)			Float c4 = v_cx;
HXDLIN( 513)			if ((a6 > b5)) {
HXDLIN( 513)				if ((a6 > c4)) {
HXDLIN( 513)					int min4;
HXDLIN( 513)					if ((b5 > c4)) {
HXDLIN( 513)						min4 = ::Math_obj::floor(c4);
            					}
            					else {
HXDLIN( 513)						min4 = ::Math_obj::floor(b5);
            					}
HXDLIN( 513)					int ii_min8 = min4;
HXDLIN( 513)					int ii_max8 = ::Math_obj::ceil(a6);
HXDLIN( 513)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXDLIN( 513)					int ii_min9 = ::Math_obj::floor(b5);
HXDLIN( 513)					int ii_max9 = ::Math_obj::ceil(c4);
HXDLIN( 513)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXDLIN( 513)				if ((b5 > c4)) {
HXDLIN( 513)					int min5;
HXDLIN( 513)					if ((a6 > c4)) {
HXDLIN( 513)						min5 = ::Math_obj::floor(c4);
            					}
            					else {
HXDLIN( 513)						min5 = ::Math_obj::ceil(a6);
            					}
HXDLIN( 513)					int ii_min10 = min5;
HXDLIN( 513)					int ii_max10 = ::Math_obj::ceil(b5);
HXDLIN( 513)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXDLIN( 513)					int ii_min11 = ::Math_obj::floor(a6);
HXDLIN( 513)					int ii_max11 = ::Math_obj::ceil(c4);
HXDLIN( 513)					v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN( 513)			Float a7 = v_ay;
HXDLIN( 513)			Float b6 = v_by;
HXDLIN( 513)			Float c5 = v_cy;
HXDLIN( 513)			if ((a7 > b6)) {
HXDLIN( 513)				if ((a7 > c5)) {
HXDLIN( 513)					int min6;
HXDLIN( 513)					if ((b6 > c5)) {
HXDLIN( 513)						min6 = ::Math_obj::floor(c5);
            					}
            					else {
HXDLIN( 513)						min6 = ::Math_obj::floor(b6);
            					}
HXDLIN( 513)					int ii_min12 = min6;
HXDLIN( 513)					int ii_max12 = ::Math_obj::ceil(a7);
HXDLIN( 513)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXDLIN( 513)					int ii_min13 = ::Math_obj::floor(b6);
HXDLIN( 513)					int ii_max13 = ::Math_obj::ceil(c5);
HXDLIN( 513)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXDLIN( 513)				if ((b6 > c5)) {
HXDLIN( 513)					int min7;
HXDLIN( 513)					if ((a7 > c5)) {
HXDLIN( 513)						min7 = ::Math_obj::floor(c5);
            					}
            					else {
HXDLIN( 513)						min7 = ::Math_obj::ceil(a7);
            					}
HXDLIN( 513)					int ii_min14 = min7;
HXDLIN( 513)					int ii_max14 = ::Math_obj::ceil(b6);
HXDLIN( 513)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXDLIN( 513)					int ii_min15 = ::Math_obj::floor(a7);
HXDLIN( 513)					int ii_max15 = ::Math_obj::ceil(c5);
HXDLIN( 513)					v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
            		}
HXDLIN( 513)		if (hasUndo) {
HXDLIN( 513)			v_undoImage = undoImage;
HXDLIN( 513)			v_undoX = xIter3->start;
HXDLIN( 513)			v_undoY = yIter3->start;
            		}
HXDLIN( 513)		Float bx3 = cx;
HXDLIN( 513)		Float by3 = cy;
HXDLIN( 513)		Float cx3 = dx;
HXDLIN( 513)		Float cy3 = dy;
HXDLIN( 513)		bool hasUndo1 = false;
HXDLIN( 513)		bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN( 513)		if (!(adjustWinding2)) {
HXDLIN( 513)			Float bx_2 = bx3;
HXDLIN( 513)			Float by_2 = by3;
HXLINE(  25)			bx3 = cx3;
HXLINE(  26)			by3 = cy3;
HXLINE(  27)			cx3 = bx_2;
HXLINE(  28)			cy3 = by_2;
            		}
HXLINE( 513)		Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN( 513)		Float sx1 = (cy3 - by);
HXDLIN( 513)		Float sy1 = (bx - cx3);
HXDLIN( 513)		Float t01 = ((bx * by3) - (by * bx3));
HXDLIN( 513)		Float tx1 = (by - by3);
HXDLIN( 513)		Float ty1 = (bx3 - bx);
HXDLIN( 513)		Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 513)		if ((bx > bx3)) {
HXDLIN( 513)			if ((bx > cx3)) {
HXDLIN( 513)				int min8;
HXDLIN( 513)				if ((bx3 > cx3)) {
HXDLIN( 513)					min8 = ::Math_obj::floor(cx3);
            				}
            				else {
HXDLIN( 513)					min8 = ::Math_obj::floor(bx3);
            				}
HXDLIN( 513)				int ii_min16 = min8;
HXDLIN( 513)				int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN( 513)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            			}
            			else {
HXDLIN( 513)				int ii_min17 = ::Math_obj::floor(bx3);
HXDLIN( 513)				int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN( 513)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            			}
            		}
            		else {
HXDLIN( 513)			if ((bx3 > cx3)) {
HXDLIN( 513)				int min9;
HXDLIN( 513)				if ((bx > cx3)) {
HXDLIN( 513)					min9 = ::Math_obj::floor(cx3);
            				}
            				else {
HXDLIN( 513)					min9 = ::Math_obj::ceil(bx);
            				}
HXDLIN( 513)				int ii_min18 = min9;
HXDLIN( 513)				int ii_max18 = ::Math_obj::ceil(bx3);
HXDLIN( 513)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            			}
            			else {
HXDLIN( 513)				int ii_min19 = ::Math_obj::floor(bx);
HXDLIN( 513)				int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN( 513)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            			}
            		}
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 513)		if ((by > by3)) {
HXDLIN( 513)			if ((by > cy3)) {
HXDLIN( 513)				int min10;
HXDLIN( 513)				if ((by3 > cy3)) {
HXDLIN( 513)					min10 = ::Math_obj::floor(cy3);
            				}
            				else {
HXDLIN( 513)					min10 = ::Math_obj::floor(by3);
            				}
HXDLIN( 513)				int ii_min20 = min10;
HXDLIN( 513)				int ii_max20 = ::Math_obj::ceil(by);
HXDLIN( 513)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            			}
            			else {
HXDLIN( 513)				int ii_min21 = ::Math_obj::floor(by3);
HXDLIN( 513)				int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN( 513)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            			}
            		}
            		else {
HXDLIN( 513)			if ((by3 > cy3)) {
HXDLIN( 513)				int min11;
HXDLIN( 513)				if ((by > cy3)) {
HXDLIN( 513)					min11 = ::Math_obj::floor(cy3);
            				}
            				else {
HXDLIN( 513)					min11 = ::Math_obj::ceil(by);
            				}
HXDLIN( 513)				int ii_min22 = min11;
HXDLIN( 513)				int ii_max22 = ::Math_obj::ceil(by3);
HXDLIN( 513)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            			}
            			else {
HXDLIN( 513)				int ii_min23 = ::Math_obj::floor(by);
HXDLIN( 513)				int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN( 513)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            			}
            		}
HXDLIN( 513)		 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 513)		if (hasUndo1) {
HXDLIN( 513)			int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 513)			int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 513)			 ::Dynamic imageType1 = null();
HXDLIN( 513)			 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 513)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 513)			::Dynamic undoImage4;
HXDLIN( 513)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXDLIN( 513)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::BytesImg b7 = byt1;
HXDLIN( 513)					{
HXDLIN( 513)						b7->width = width1;
HXDLIN( 513)						b7->height = height1;
HXDLIN( 513)						b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 513)						b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN( 513)						{
HXDLIN( 513)							int len2 = b7->length;
HXDLIN( 513)							int w1 = 0;
HXDLIN( 513)							{
HXDLIN( 513)								int _g20 = 0;
HXDLIN( 513)								int _g21 = b7->height;
HXDLIN( 513)								while((_g20 < _g21)){
HXDLIN( 513)									_g20 = (_g20 + 1);
HXDLIN( 513)									int y4 = (_g20 - 1);
HXDLIN( 513)									{
HXDLIN( 513)										int _g22 = 0;
HXDLIN( 513)										int _g23 = b7->width;
HXDLIN( 513)										while((_g22 < _g23)){
HXDLIN( 513)											_g22 = (_g22 + 1);
HXDLIN( 513)											int x4 = (_g22 - 1);
HXDLIN( 513)											{
HXDLIN( 513)												w1 = (w1 + 1);
HXDLIN( 513)												b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w1 = (w1 + 1);
HXDLIN( 513)												b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w1 = (w1 + 1);
HXDLIN( 513)												b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w1 = (w1 + 1);
HXDLIN( 513)												b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage4 = b7;
            				}
            				break;
            				case (int)1: {
HXDLIN( 513)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::ArrIntImg a8 = arrI1;
HXDLIN( 513)					{
HXDLIN( 513)						a8->width = width1;
HXDLIN( 513)						a8->height = height1;
HXDLIN( 513)						a8->data = ::Array_obj< int >::__new(0);
HXDLIN( 513)						a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 513)						{
HXDLIN( 513)							int _g24 = 0;
HXDLIN( 513)							int _g25 = a8->length;
HXDLIN( 513)							while((_g24 < _g25)){
HXDLIN( 513)								_g24 = (_g24 + 1);
HXDLIN( 513)								int i6 = (_g24 - 1);
HXDLIN( 513)								a8->data[i6] = 0;
            							}
            						}
            					}
HXDLIN( 513)					undoImage4 = a8;
            				}
            				break;
            				case (int)2: {
HXDLIN( 513)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::U32ArrImg b8 = u32a1;
HXDLIN( 513)					{
HXDLIN( 513)						b8->width = width1;
HXDLIN( 513)						b8->height = height1;
HXDLIN( 513)						b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 513)						int size1 = (b8->length * 4);
HXDLIN( 513)						b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 513)						{
HXDLIN( 513)							int _g26 = 0;
HXDLIN( 513)							int _g27 = b8->length;
HXDLIN( 513)							while((_g26 < _g27)){
HXDLIN( 513)								_g26 = (_g26 + 1);
HXDLIN( 513)								int i7 = (_g26 - 1);
HXDLIN( 513)								{
HXDLIN( 513)									 ::haxe::io::ArrayBufferViewImpl this36 = b8->data;
HXDLIN( 513)									bool undoImage5;
HXDLIN( 513)									if ((i7 >= 0)) {
HXDLIN( 513)										undoImage5 = (i7 < (this36->byteLength >> 2));
            									}
            									else {
HXDLIN( 513)										undoImage5 = false;
            									}
HXDLIN( 513)									if (undoImage5) {
HXDLIN( 513)										 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN( 513)										int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN( 513)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 513)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 513)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 513)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage4 = b8;
            				}
            				break;
            				case (int)3: {
HXDLIN( 513)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 513)					{
HXDLIN( 513)						v2->width = width1;
HXDLIN( 513)						v2->height = height1;
HXDLIN( 513)						v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 513)						v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 513)						{
HXDLIN( 513)							int _g28 = 0;
HXDLIN( 513)							int _g29 = v2->length;
HXDLIN( 513)							while((_g28 < _g29)){
HXDLIN( 513)								_g28 = (_g28 + 1);
HXDLIN( 513)								int i8 = (_g28 - 1);
HXDLIN( 513)								v2->data->__unsafe_set(i8,0);
            							}
            						}
            					}
HXDLIN( 513)					undoImage4 = v2;
            				}
            				break;
            				case (int)4: {
HXDLIN( 513)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::StackIntImg b9 = sInt1;
HXDLIN( 513)					{
HXDLIN( 513)						b9->width = width1;
HXDLIN( 513)						b9->height = height1;
HXDLIN( 513)						b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 513)						b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 513)						{
HXDLIN( 513)							int len3 = b9->length;
HXDLIN( 513)							 ::haxe::ds::GenericStack_Int d1 = b9->data;
HXDLIN( 513)							if (::hx::IsNull( d1->head )) {
HXDLIN( 513)								int _g30 = 0;
HXDLIN( 513)								int _g31 = len3;
HXDLIN( 513)								while((_g30 < _g31)){
HXDLIN( 513)									_g30 = (_g30 + 1);
HXDLIN( 513)									int i9 = (_g30 - 1);
HXDLIN( 513)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXDLIN( 513)								int _g32 = 0;
HXDLIN( 513)								int _g33 = len3;
HXDLIN( 513)								while((_g32 < _g33)){
HXDLIN( 513)									_g32 = (_g32 + 1);
HXDLIN( 513)									int i10 = (_g32 - 1);
HXDLIN( 513)									{
HXDLIN( 513)										 ::haxe::ds::GenericCell_Int l1 = b9->data->head;
HXDLIN( 513)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 513)										{
HXDLIN( 513)											int _g34 = 0;
HXDLIN( 513)											int _g35 = i10;
HXDLIN( 513)											while((_g34 < _g35)){
HXDLIN( 513)												_g34 = (_g34 + 1);
HXDLIN( 513)												int i11 = (_g34 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE( 513)										if (::hx::IsNull( prev1 )) {
HXDLIN( 513)											b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 513)											l1 = null();
            										}
            										else {
HXDLIN( 513)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 513)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage4 = b9;
            				}
            				break;
            			}
HXDLIN( 513)			this35->image = undoImage4;
HXDLIN( 513)			this35->width = width1;
HXDLIN( 513)			this35->height = height1;
HXDLIN( 513)			this35->imageType = ( (int)(imageType1) );
HXDLIN( 513)			undoImage3 = this35;
HXDLIN( 513)			{
HXDLIN( 513)				int rectLeft1 = xIter31->start;
HXDLIN( 513)				int rectTop1 = yIter31->start;
HXDLIN( 513)				int rectRight1 = xIter31->max;
HXDLIN( 513)				bool forceClear1 = false;
HXDLIN( 513)				{
HXDLIN( 513)					int _g36 = rectTop1;
HXDLIN( 513)					int _g37 = yIter31->max;
HXDLIN( 513)					while((_g36 < _g37)){
HXDLIN( 513)						_g36 = (_g36 + 1);
HXDLIN( 513)						int dy2 = (_g36 - 1);
HXDLIN( 513)						{
HXDLIN( 513)							int _g38 = rectLeft1;
HXDLIN( 513)							int _g39 = rectRight1;
HXDLIN( 513)							while((_g38 < _g39)){
HXDLIN( 513)								_g38 = (_g38 + 1);
HXDLIN( 513)								int dx2 = (_g38 - 1);
HXDLIN( 513)								::Dynamic this37 = this1->image;
HXDLIN( 513)								int index5;
HXDLIN( 513)								if (this1->useVirtualPos) {
HXDLIN( 513)									index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            								}
            								else {
HXDLIN( 513)									index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            								}
HXDLIN( 513)								int c6 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN( 513)								int col1;
HXDLIN( 513)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)									col1 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            								}
            								else {
HXDLIN( 513)									col1 = c6;
            								}
HXDLIN( 513)								bool _hx_tmp8;
HXDLIN( 513)								if (this1->useMask) {
HXDLIN( 513)									_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 513)									_hx_tmp8 = false;
            								}
HXDLIN( 513)								if (_hx_tmp8) {
HXDLIN( 513)									 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN( 513)									::Dynamic this39 = this38->image;
HXDLIN( 513)									int index6;
HXDLIN( 513)									if (this38->useVirtualPos) {
HXDLIN( 513)										index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            									}
            									else {
HXDLIN( 513)										index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            									}
HXDLIN( 513)									int c7 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN( 513)									int v3;
HXDLIN( 513)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)										v3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            									}
            									else {
HXDLIN( 513)										v3 = c7;
            									}
HXDLIN( 513)									int maskPixel1 = v3;
HXDLIN( 513)									int this40 = col1;
HXDLIN( 513)									if ((maskPixel1 == 0)) {
HXDLIN( 513)										col1 = this40;
            									}
            									else {
HXDLIN( 513)										Float m01;
HXDLIN( 513)										int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN( 513)										if ((this41 == 0)) {
HXDLIN( 513)											m01 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m11;
HXDLIN( 513)										int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN( 513)										if ((this42 == 0)) {
HXDLIN( 513)											m11 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m21;
HXDLIN( 513)										int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN( 513)										if ((this43 == 0)) {
HXDLIN( 513)											m21 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m31;
HXDLIN( 513)										int this44 = (maskPixel1 & 255);
HXDLIN( 513)										if ((this44 == 0)) {
HXDLIN( 513)											m31 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN( 513)										int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN( 513)										int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN( 513)										int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN( 513)										col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 513)								if ((col1 != 0)) {
HXDLIN( 513)									int x5 = (dx2 - rectLeft1);
HXDLIN( 513)									int y5 = (dy2 - rectTop1);
HXDLIN( 513)									int c8 = col1;
HXDLIN( 513)									bool _hx_tmp9;
HXDLIN( 513)									if ((((c8 >> 24) & 255) < 254)) {
HXDLIN( 513)										_hx_tmp9 = undoImage3->transparent;
            									}
            									else {
HXDLIN( 513)										_hx_tmp9 = false;
            									}
HXDLIN( 513)									if (_hx_tmp9) {
HXDLIN( 513)										int location2;
HXDLIN( 513)										if (undoImage3->useVirtualPos) {
HXDLIN( 513)											location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            										}
            										else {
HXDLIN( 513)											location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            										}
HXDLIN( 513)										int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 513)										int this46;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											this46 = this45;
            										}
HXDLIN( 513)										Float a13;
HXDLIN( 513)										int this47 = ((this46 >> 24) & 255);
HXDLIN( 513)										if ((this47 == 0)) {
HXDLIN( 513)											a13 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a13 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r12;
HXDLIN( 513)										int this48 = ((this46 >> 16) & 255);
HXDLIN( 513)										if ((this48 == 0)) {
HXDLIN( 513)											r12 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g12;
HXDLIN( 513)										int this49 = ((this46 >> 8) & 255);
HXDLIN( 513)										if ((this49 == 0)) {
HXDLIN( 513)											g12 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b13;
HXDLIN( 513)										int this50 = (this46 & 255);
HXDLIN( 513)										if ((this50 == 0)) {
HXDLIN( 513)											b13 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a22;
HXDLIN( 513)										int this51 = ((col1 >> 24) & 255);
HXDLIN( 513)										if ((this51 == 0)) {
HXDLIN( 513)											a22 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r22;
HXDLIN( 513)										int this52 = ((col1 >> 16) & 255);
HXDLIN( 513)										if ((this52 == 0)) {
HXDLIN( 513)											r22 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g22;
HXDLIN( 513)										int this53 = ((col1 >> 8) & 255);
HXDLIN( 513)										if ((this53 == 0)) {
HXDLIN( 513)											g22 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b23;
HXDLIN( 513)										int this54 = (col1 & 255);
HXDLIN( 513)										if ((this54 == 0)) {
HXDLIN( 513)											b23 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN( 513)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 513)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 513)										int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 513)										int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 513)										int blended2 = ((((a9 << 24) | (r4 << 16)) | (g4 << 8)) | b10);
HXDLIN( 513)										{
HXDLIN( 513)											int _hx_tmp10;
HXDLIN( 513)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)												_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXDLIN( 513)												_hx_tmp10 = blended2;
            											}
HXDLIN( 513)											::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            										}
            									}
            									else {
HXDLIN( 513)										::Dynamic this55 = undoImage3->image;
HXDLIN( 513)										int index7;
HXDLIN( 513)										if (undoImage3->useVirtualPos) {
HXDLIN( 513)											index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            										}
            										else {
HXDLIN( 513)											index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            										}
HXDLIN( 513)										int _hx_tmp11;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											_hx_tmp11 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											_hx_tmp11 = c8;
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this55,index7,_hx_tmp11);
            									}
            								}
            								else {
HXDLIN( 513)									if (forceClear1) {
HXDLIN( 513)										::Dynamic this56 = undoImage3->image;
HXDLIN( 513)										int x6 = (dx2 - rectLeft1);
HXDLIN( 513)										int y6 = (dy2 - rectTop1);
HXDLIN( 513)										int index8;
HXDLIN( 513)										if (undoImage3->useVirtualPos) {
HXDLIN( 513)											index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            										}
            										else {
HXDLIN( 513)											index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this56,index8,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 513)		bool found1 = false;
HXDLIN( 513)		Float s1 = ((Float)0.);
HXDLIN( 513)		Float t1 = ((Float)0.);
HXDLIN( 513)		Float sxx1 = ((Float)0.);
HXDLIN( 513)		Float txx1 = ((Float)0.);
HXDLIN( 513)		{
HXDLIN( 513)			int _g_min2 = xIter31->start;
HXDLIN( 513)			int _g_max2 = xIter31->max;
HXDLIN( 513)			while((_g_min2 < _g_max2)){
HXDLIN( 513)				_g_min2 = (_g_min2 + 1);
HXDLIN( 513)				int x7 = (_g_min2 - 1);
HXLINE(  60)				sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)				txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)				found1 = false;
HXLINE( 513)				{
HXDLIN( 513)					int _g_min3 = yIter31->start;
HXDLIN( 513)					int _g_max3 = yIter31->max;
HXDLIN( 513)					while((_g_min3 < _g_max3)){
HXDLIN( 513)						_g_min3 = (_g_min3 + 1);
HXDLIN( 513)						int y7 = (_g_min3 - 1);
HXLINE(  64)						s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)						t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 513)						bool _hx_tmp12;
HXDLIN( 513)						if (!((s1 <= 0))) {
HXDLIN( 513)							_hx_tmp12 = (t1 <= 0);
            						}
            						else {
HXDLIN( 513)							_hx_tmp12 = true;
            						}
HXDLIN( 513)						if (_hx_tmp12) {
HXDLIN( 513)							if (found1) {
HXDLIN( 513)								goto _hx_goto_1018;
            							}
            						}
            						else {
HXDLIN( 513)							if (((s1 + t1) < A1)) {
HXDLIN( 513)								{
HXDLIN( 513)									int c9 = color;
HXDLIN( 513)									bool _hx_tmp13;
HXDLIN( 513)									if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 513)										_hx_tmp13 = this1->transparent;
            									}
            									else {
HXDLIN( 513)										_hx_tmp13 = false;
            									}
HXDLIN( 513)									if (_hx_tmp13) {
HXDLIN( 513)										int location3;
HXDLIN( 513)										if (this1->useVirtualPos) {
HXDLIN( 513)											location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            										}
            										else {
HXDLIN( 513)											location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            										}
HXDLIN( 513)										int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 513)										int this58;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											this58 = this57;
            										}
HXDLIN( 513)										Float a14;
HXDLIN( 513)										int this59 = ((this58 >> 24) & 255);
HXDLIN( 513)										if ((this59 == 0)) {
HXDLIN( 513)											a14 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a14 = (( (Float)(this59) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r13;
HXDLIN( 513)										int this60 = ((this58 >> 16) & 255);
HXDLIN( 513)										if ((this60 == 0)) {
HXDLIN( 513)											r13 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g13;
HXDLIN( 513)										int this61 = ((this58 >> 8) & 255);
HXDLIN( 513)										if ((this61 == 0)) {
HXDLIN( 513)											g13 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b14;
HXDLIN( 513)										int this62 = (this58 & 255);
HXDLIN( 513)										if ((this62 == 0)) {
HXDLIN( 513)											b14 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a23;
HXDLIN( 513)										int this63 = ((color >> 24) & 255);
HXDLIN( 513)										if ((this63 == 0)) {
HXDLIN( 513)											a23 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r23;
HXDLIN( 513)										int this64 = ((color >> 16) & 255);
HXDLIN( 513)										if ((this64 == 0)) {
HXDLIN( 513)											r23 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g23;
HXDLIN( 513)										int this65 = ((color >> 8) & 255);
HXDLIN( 513)										if ((this65 == 0)) {
HXDLIN( 513)											g23 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b24;
HXDLIN( 513)										int this66 = (color & 255);
HXDLIN( 513)										if ((this66 == 0)) {
HXDLIN( 513)											b24 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 513)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 513)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 513)										int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 513)										int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 513)										int blended3 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b15);
HXDLIN( 513)										{
HXDLIN( 513)											int _hx_tmp14;
HXDLIN( 513)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)												_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXDLIN( 513)												_hx_tmp14 = blended3;
            											}
HXDLIN( 513)											::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            										}
            									}
            									else {
HXDLIN( 513)										::Dynamic this67 = this1->image;
HXDLIN( 513)										int index9;
HXDLIN( 513)										if (this1->useVirtualPos) {
HXDLIN( 513)											index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            										}
            										else {
HXDLIN( 513)											index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            										}
HXDLIN( 513)										int _hx_tmp15;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											_hx_tmp15 = c9;
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this67,index9,_hx_tmp15);
            									}
            								}
HXLINE(  73)								found1 = true;
            							}
            							else {
HXDLIN( 513)								if (found1) {
HXDLIN( 513)									goto _hx_goto_1018;
            								}
            							}
            						}
            					}
            					_hx_goto_1018:;
            				}
            			}
            		}
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 513)		int v_undoY1;
HXDLIN( 513)		int v_undoX1;
HXDLIN( 513)		Float v_ty1;
HXDLIN( 513)		Float v_tx1;
HXDLIN( 513)		Float v_t01;
HXDLIN( 513)		Float v_sy1;
HXDLIN( 513)		Float v_sx1;
HXDLIN( 513)		Float v_s01;
HXDLIN( 513)		Float v_A1;
HXDLIN( 513)		Float ax2 = bx;
HXDLIN( 513)		Float ay2 = by;
HXDLIN( 513)		 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 513)		Float bx4 = bx3;
HXDLIN( 513)		Float by4 = by3;
HXDLIN( 513)		Float cx4 = cx3;
HXDLIN( 513)		Float cy4 = cy3;
HXDLIN( 513)		bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN( 513)		if (!(adjustWinding3)) {
HXDLIN( 513)			Float bx_3 = bx4;
HXDLIN( 513)			Float by_3 = by4;
HXLINE(  24)			bx4 = cx4;
HXLINE(  25)			by4 = cy4;
HXLINE(  26)			cx4 = bx_3;
HXLINE(  27)			cy4 = by_3;
            		}
HXLINE( 513)		Float v_ax1 = ax2;
HXDLIN( 513)		Float v_ay1 = ay2;
HXDLIN( 513)		Float v_bx1 = bx4;
HXDLIN( 513)		Float v_by1 = by4;
HXDLIN( 513)		Float v_cx1 = cx4;
HXDLIN( 513)		Float v_cy1 = cy4;
HXDLIN( 513)		bool v_preCalculated1 = true;
HXDLIN( 513)		{
HXDLIN( 513)			v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 513)			v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 513)			v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 513)			v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 513)			v_tx1 = (v_ay1 - v_by1);
HXDLIN( 513)			v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 513)			v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 513)			Float a15 = v_ax1;
HXDLIN( 513)			Float b16 = v_bx1;
HXDLIN( 513)			Float c10 = v_cx1;
HXDLIN( 513)			if ((a15 > b16)) {
HXDLIN( 513)				if ((a15 > c10)) {
HXDLIN( 513)					int min12;
HXDLIN( 513)					if ((b16 > c10)) {
HXDLIN( 513)						min12 = ::Math_obj::floor(c10);
            					}
            					else {
HXDLIN( 513)						min12 = ::Math_obj::floor(b16);
            					}
HXDLIN( 513)					int ii_min24 = min12;
HXDLIN( 513)					int ii_max24 = ::Math_obj::ceil(a15);
HXDLIN( 513)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            				}
            				else {
HXDLIN( 513)					int ii_min25 = ::Math_obj::floor(b16);
HXDLIN( 513)					int ii_max25 = ::Math_obj::ceil(c10);
HXDLIN( 513)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            				}
            			}
            			else {
HXDLIN( 513)				if ((b16 > c10)) {
HXDLIN( 513)					int min13;
HXDLIN( 513)					if ((a15 > c10)) {
HXDLIN( 513)						min13 = ::Math_obj::floor(c10);
            					}
            					else {
HXDLIN( 513)						min13 = ::Math_obj::ceil(a15);
            					}
HXDLIN( 513)					int ii_min26 = min13;
HXDLIN( 513)					int ii_max26 = ::Math_obj::ceil(b16);
HXDLIN( 513)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            				}
            				else {
HXDLIN( 513)					int ii_min27 = ::Math_obj::floor(a15);
HXDLIN( 513)					int ii_max27 = ::Math_obj::ceil(c10);
HXDLIN( 513)					v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            				}
            			}
HXDLIN( 513)			Float a16 = v_ay1;
HXDLIN( 513)			Float b17 = v_by1;
HXDLIN( 513)			Float c11 = v_cy1;
HXDLIN( 513)			if ((a16 > b17)) {
HXDLIN( 513)				if ((a16 > c11)) {
HXDLIN( 513)					int min14;
HXDLIN( 513)					if ((b17 > c11)) {
HXDLIN( 513)						min14 = ::Math_obj::floor(c11);
            					}
            					else {
HXDLIN( 513)						min14 = ::Math_obj::floor(b17);
            					}
HXDLIN( 513)					int ii_min28 = min14;
HXDLIN( 513)					int ii_max28 = ::Math_obj::ceil(a16);
HXDLIN( 513)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            				}
            				else {
HXDLIN( 513)					int ii_min29 = ::Math_obj::floor(b17);
HXDLIN( 513)					int ii_max29 = ::Math_obj::ceil(c11);
HXDLIN( 513)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            				}
            			}
            			else {
HXDLIN( 513)				if ((b17 > c11)) {
HXDLIN( 513)					int min15;
HXDLIN( 513)					if ((a16 > c11)) {
HXDLIN( 513)						min15 = ::Math_obj::floor(c11);
            					}
            					else {
HXDLIN( 513)						min15 = ::Math_obj::ceil(a16);
            					}
HXDLIN( 513)					int ii_min30 = min15;
HXDLIN( 513)					int ii_max30 = ::Math_obj::ceil(b17);
HXDLIN( 513)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            				}
            				else {
HXDLIN( 513)					int ii_min31 = ::Math_obj::floor(a16);
HXDLIN( 513)					int ii_max31 = ::Math_obj::ceil(c11);
HXDLIN( 513)					v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            				}
            			}
            		}
HXDLIN( 513)		if (hasUndo1) {
HXDLIN( 513)			v_undoImage1 = undoImage3;
HXDLIN( 513)			v_undoX1 = xIter31->start;
HXDLIN( 513)			v_undoY1 = yIter31->start;
            		}
HXDLIN( 513)		 ::pi_xy::algo::HitQuad v4 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN( 513)		 ::pi_xy::algo::HitQuad hitQuad = v4;
HXDLIN( 513)		Float cx5 = h2;
HXDLIN( 513)		Float cy5 = radius2;
HXDLIN( 513)		Float bx5 = h2;
HXDLIN( 513)		Float by5 = -(radius2);
HXDLIN( 513)		Float dx3 = hSmall;
HXDLIN( 513)		Float dy3 = radius2;
HXDLIN( 513)		Float ax3 = hSmall;
HXDLIN( 513)		Float ay3 = -(radius2);
HXLINE( 592)		temp = (px + ((bx5 * cos) - (by5 * sin)));
HXLINE( 593)		by5 = (py + ((by5 * cos) + (bx5 * sin)));
HXLINE( 594)		bx5 = temp;
HXLINE( 595)		temp = (px + ((cx5 * cos) - (cy5 * sin)));
HXLINE( 596)		cy5 = (py + ((cy5 * cos) + (cx5 * sin)));
HXLINE( 597)		cx5 = temp;
HXLINE( 599)		temp = (px + ((ax3 * cos) - (ay3 * sin)));
HXLINE( 600)		ay3 = (py + ((ay3 * cos) + (ax3 * sin)));
HXLINE( 601)		ax3 = temp;
HXLINE( 603)		temp = (px + ((dx3 * cos) - (dy3 * sin)));
HXLINE( 604)		dy3 = (py + ((dy3 * cos) + (dx3 * sin)));
HXLINE( 605)		dx3 = temp;
HXLINE( 513)		Float bx6 = bx5;
HXDLIN( 513)		Float by6 = by5;
HXDLIN( 513)		Float cx6 = cx5;
HXDLIN( 513)		Float cy6 = cy5;
HXDLIN( 513)		bool hasUndo2 = false;
HXDLIN( 513)		bool adjustWinding4 = (((((qx * by6) - (bx6 * qy)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * qy) - (qx * cy6))) > 0);
HXDLIN( 513)		if (!(adjustWinding4)) {
HXDLIN( 513)			Float bx_4 = bx6;
HXDLIN( 513)			Float by_4 = by6;
HXLINE(  25)			bx6 = cx6;
HXLINE(  26)			by6 = cy6;
HXLINE(  27)			cx6 = bx_4;
HXLINE(  28)			cy6 = by_4;
            		}
HXLINE( 513)		Float s02 = ((qy * cx6) - (qx * cy6));
HXDLIN( 513)		Float sx2 = (cy6 - qy);
HXDLIN( 513)		Float sy2 = (qx - cx6);
HXDLIN( 513)		Float t02 = ((qx * by6) - (qy * bx6));
HXDLIN( 513)		Float tx2 = (qy - by6);
HXDLIN( 513)		Float ty2 = (bx6 - qx);
HXDLIN( 513)		Float A2 = ((((-(by6) * cx6) + (qy * (-(bx6) + cx6))) + (qx * (by6 - cy6))) + (bx6 * cy6));
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN( 513)		if ((qx > bx6)) {
HXDLIN( 513)			if ((qx > cx6)) {
HXDLIN( 513)				int min16;
HXDLIN( 513)				if ((bx6 > cx6)) {
HXDLIN( 513)					min16 = ::Math_obj::floor(cx6);
            				}
            				else {
HXDLIN( 513)					min16 = ::Math_obj::floor(bx6);
            				}
HXDLIN( 513)				int ii_min32 = min16;
HXDLIN( 513)				int ii_max32 = ::Math_obj::ceil(qx);
HXDLIN( 513)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            			}
            			else {
HXDLIN( 513)				int ii_min33 = ::Math_obj::floor(bx6);
HXDLIN( 513)				int ii_max33 = ::Math_obj::ceil(cx6);
HXDLIN( 513)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            			}
            		}
            		else {
HXDLIN( 513)			if ((bx6 > cx6)) {
HXDLIN( 513)				int min17;
HXDLIN( 513)				if ((qx > cx6)) {
HXDLIN( 513)					min17 = ::Math_obj::floor(cx6);
            				}
            				else {
HXDLIN( 513)					min17 = ::Math_obj::ceil(qx);
            				}
HXDLIN( 513)				int ii_min34 = min17;
HXDLIN( 513)				int ii_max34 = ::Math_obj::ceil(bx6);
HXDLIN( 513)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            			}
            			else {
HXDLIN( 513)				int ii_min35 = ::Math_obj::floor(qx);
HXDLIN( 513)				int ii_max35 = ::Math_obj::ceil(cx6);
HXDLIN( 513)				xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            			}
            		}
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN( 513)		if ((qy > by6)) {
HXDLIN( 513)			if ((qy > cy6)) {
HXDLIN( 513)				int min18;
HXDLIN( 513)				if ((by6 > cy6)) {
HXDLIN( 513)					min18 = ::Math_obj::floor(cy6);
            				}
            				else {
HXDLIN( 513)					min18 = ::Math_obj::floor(by6);
            				}
HXDLIN( 513)				int ii_min36 = min18;
HXDLIN( 513)				int ii_max36 = ::Math_obj::ceil(qy);
HXDLIN( 513)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            			}
            			else {
HXDLIN( 513)				int ii_min37 = ::Math_obj::floor(by6);
HXDLIN( 513)				int ii_max37 = ::Math_obj::ceil(cy6);
HXDLIN( 513)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            			}
            		}
            		else {
HXDLIN( 513)			if ((by6 > cy6)) {
HXDLIN( 513)				int min19;
HXDLIN( 513)				if ((qy > cy6)) {
HXDLIN( 513)					min19 = ::Math_obj::floor(cy6);
            				}
            				else {
HXDLIN( 513)					min19 = ::Math_obj::ceil(qy);
            				}
HXDLIN( 513)				int ii_min38 = min19;
HXDLIN( 513)				int ii_max38 = ::Math_obj::ceil(by6);
HXDLIN( 513)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            			}
            			else {
HXDLIN( 513)				int ii_min39 = ::Math_obj::floor(qy);
HXDLIN( 513)				int ii_max39 = ::Math_obj::ceil(cy6);
HXDLIN( 513)				yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            			}
            		}
HXDLIN( 513)		 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN( 513)		if (hasUndo2) {
HXDLIN( 513)			int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN( 513)			int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN( 513)			 ::Dynamic imageType2 = null();
HXDLIN( 513)			 ::pi_xy::ImageStruct this68 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 513)			if (::hx::IsNull( imageType2 )) {
HXLINE(  54)				imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 513)			::Dynamic undoImage7;
HXDLIN( 513)			switch((int)(( (int)(imageType2) ))){
            				case (int)0: {
HXDLIN( 513)					 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::BytesImg b18 = byt2;
HXDLIN( 513)					{
HXDLIN( 513)						b18->width = width2;
HXDLIN( 513)						b18->height = height2;
HXDLIN( 513)						b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 513)						b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN( 513)						{
HXDLIN( 513)							int len4 = b18->length;
HXDLIN( 513)							int w2 = 0;
HXDLIN( 513)							{
HXDLIN( 513)								int _g40 = 0;
HXDLIN( 513)								int _g41 = b18->height;
HXDLIN( 513)								while((_g40 < _g41)){
HXDLIN( 513)									_g40 = (_g40 + 1);
HXDLIN( 513)									int y8 = (_g40 - 1);
HXDLIN( 513)									{
HXDLIN( 513)										int _g42 = 0;
HXDLIN( 513)										int _g43 = b18->width;
HXDLIN( 513)										while((_g42 < _g43)){
HXDLIN( 513)											_g42 = (_g42 + 1);
HXDLIN( 513)											int x8 = (_g42 - 1);
HXDLIN( 513)											{
HXDLIN( 513)												w2 = (w2 + 1);
HXDLIN( 513)												b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w2 = (w2 + 1);
HXDLIN( 513)												b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w2 = (w2 + 1);
HXDLIN( 513)												b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w2 = (w2 + 1);
HXDLIN( 513)												b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage7 = b18;
            				}
            				break;
            				case (int)1: {
HXDLIN( 513)					 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::ArrIntImg a17 = arrI2;
HXDLIN( 513)					{
HXDLIN( 513)						a17->width = width2;
HXDLIN( 513)						a17->height = height2;
HXDLIN( 513)						a17->data = ::Array_obj< int >::__new(0);
HXDLIN( 513)						a17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 513)						{
HXDLIN( 513)							int _g44 = 0;
HXDLIN( 513)							int _g45 = a17->length;
HXDLIN( 513)							while((_g44 < _g45)){
HXDLIN( 513)								_g44 = (_g44 + 1);
HXDLIN( 513)								int i12 = (_g44 - 1);
HXDLIN( 513)								a17->data[i12] = 0;
            							}
            						}
            					}
HXDLIN( 513)					undoImage7 = a17;
            				}
            				break;
            				case (int)2: {
HXDLIN( 513)					 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::U32ArrImg b19 = u32a2;
HXDLIN( 513)					{
HXDLIN( 513)						b19->width = width2;
HXDLIN( 513)						b19->height = height2;
HXDLIN( 513)						b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 513)						int size2 = (b19->length * 4);
HXDLIN( 513)						b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 513)						{
HXDLIN( 513)							int _g46 = 0;
HXDLIN( 513)							int _g47 = b19->length;
HXDLIN( 513)							while((_g46 < _g47)){
HXDLIN( 513)								_g46 = (_g46 + 1);
HXDLIN( 513)								int i13 = (_g46 - 1);
HXDLIN( 513)								{
HXDLIN( 513)									 ::haxe::io::ArrayBufferViewImpl this69 = b19->data;
HXDLIN( 513)									bool undoImage8;
HXDLIN( 513)									if ((i13 >= 0)) {
HXDLIN( 513)										undoImage8 = (i13 < (this69->byteLength >> 2));
            									}
            									else {
HXDLIN( 513)										undoImage8 = false;
            									}
HXDLIN( 513)									if (undoImage8) {
HXDLIN( 513)										 ::haxe::io::Bytes _this2 = this69->bytes;
HXDLIN( 513)										int pos2 = ((i13 << 2) + this69->byteOffset);
HXDLIN( 513)										_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 513)										_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 513)										_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 513)										_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage7 = b19;
            				}
            				break;
            				case (int)3: {
HXDLIN( 513)					 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN( 513)					{
HXDLIN( 513)						v5->width = width2;
HXDLIN( 513)						v5->height = height2;
HXDLIN( 513)						v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 513)						v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN( 513)						{
HXDLIN( 513)							int _g48 = 0;
HXDLIN( 513)							int _g49 = v5->length;
HXDLIN( 513)							while((_g48 < _g49)){
HXDLIN( 513)								_g48 = (_g48 + 1);
HXDLIN( 513)								int i14 = (_g48 - 1);
HXDLIN( 513)								v5->data->__unsafe_set(i14,0);
            							}
            						}
            					}
HXDLIN( 513)					undoImage7 = v5;
            				}
            				break;
            				case (int)4: {
HXDLIN( 513)					 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::StackIntImg b20 = sInt2;
HXDLIN( 513)					{
HXDLIN( 513)						b20->width = width2;
HXDLIN( 513)						b20->height = height2;
HXDLIN( 513)						b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN( 513)						b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 513)						{
HXDLIN( 513)							int len5 = b20->length;
HXDLIN( 513)							 ::haxe::ds::GenericStack_Int d2 = b20->data;
HXDLIN( 513)							if (::hx::IsNull( d2->head )) {
HXDLIN( 513)								int _g50 = 0;
HXDLIN( 513)								int _g51 = len5;
HXDLIN( 513)								while((_g50 < _g51)){
HXDLIN( 513)									_g50 = (_g50 + 1);
HXDLIN( 513)									int i15 = (_g50 - 1);
HXDLIN( 513)									d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            								}
            							}
            							else {
HXDLIN( 513)								int _g52 = 0;
HXDLIN( 513)								int _g53 = len5;
HXDLIN( 513)								while((_g52 < _g53)){
HXDLIN( 513)									_g52 = (_g52 + 1);
HXDLIN( 513)									int i16 = (_g52 - 1);
HXDLIN( 513)									{
HXDLIN( 513)										 ::haxe::ds::GenericCell_Int l2 = b20->data->head;
HXDLIN( 513)										 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 513)										{
HXDLIN( 513)											int _g54 = 0;
HXDLIN( 513)											int _g55 = i16;
HXDLIN( 513)											while((_g54 < _g55)){
HXDLIN( 513)												_g54 = (_g54 + 1);
HXDLIN( 513)												int i17 = (_g54 - 1);
HXLINE( 345)												prev2 = l2;
HXLINE( 346)												l2 = l2->next;
            											}
            										}
HXLINE( 513)										if (::hx::IsNull( prev2 )) {
HXDLIN( 513)											b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 513)											l2 = null();
            										}
            										else {
HXDLIN( 513)											prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 513)											l2 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage7 = b20;
            				}
            				break;
            			}
HXDLIN( 513)			this68->image = undoImage7;
HXDLIN( 513)			this68->width = width2;
HXDLIN( 513)			this68->height = height2;
HXDLIN( 513)			this68->imageType = ( (int)(imageType2) );
HXDLIN( 513)			undoImage6 = this68;
HXDLIN( 513)			{
HXDLIN( 513)				int rectLeft2 = xIter32->start;
HXDLIN( 513)				int rectTop2 = yIter32->start;
HXDLIN( 513)				int rectRight2 = xIter32->max;
HXDLIN( 513)				bool forceClear2 = false;
HXDLIN( 513)				{
HXDLIN( 513)					int _g56 = rectTop2;
HXDLIN( 513)					int _g57 = yIter32->max;
HXDLIN( 513)					while((_g56 < _g57)){
HXDLIN( 513)						_g56 = (_g56 + 1);
HXDLIN( 513)						int dy4 = (_g56 - 1);
HXDLIN( 513)						{
HXDLIN( 513)							int _g58 = rectLeft2;
HXDLIN( 513)							int _g59 = rectRight2;
HXDLIN( 513)							while((_g58 < _g59)){
HXDLIN( 513)								_g58 = (_g58 + 1);
HXDLIN( 513)								int dx4 = (_g58 - 1);
HXDLIN( 513)								::Dynamic this70 = this1->image;
HXDLIN( 513)								int index10;
HXDLIN( 513)								if (this1->useVirtualPos) {
HXDLIN( 513)									index10 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx4) - this1->virtualX));
            								}
            								else {
HXDLIN( 513)									index10 = ::Std_obj::_hx_int(( (Float)(((dy4 * this1->width) + dx4)) ));
            								}
HXDLIN( 513)								int c12 = ::iterMagic::Iimg_obj::get(this70,index10);
HXDLIN( 513)								int col2;
HXDLIN( 513)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)									col2 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            								}
            								else {
HXDLIN( 513)									col2 = c12;
            								}
HXDLIN( 513)								bool _hx_tmp16;
HXDLIN( 513)								if (this1->useMask) {
HXDLIN( 513)									_hx_tmp16 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 513)									_hx_tmp16 = false;
            								}
HXDLIN( 513)								if (_hx_tmp16) {
HXDLIN( 513)									 ::pi_xy::ImageStruct this71 = this1->mask;
HXDLIN( 513)									::Dynamic this72 = this71->image;
HXDLIN( 513)									int index11;
HXDLIN( 513)									if (this71->useVirtualPos) {
HXDLIN( 513)										index11 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this71->virtualY) * ( (Float)(this71->width) )) + dx4) - this71->virtualX));
            									}
            									else {
HXDLIN( 513)										index11 = ::Std_obj::_hx_int(( (Float)(((dy4 * this71->width) + dx4)) ));
            									}
HXDLIN( 513)									int c13 = ::iterMagic::Iimg_obj::get(this72,index11);
HXDLIN( 513)									int v6;
HXDLIN( 513)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)										v6 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            									}
            									else {
HXDLIN( 513)										v6 = c13;
            									}
HXDLIN( 513)									int maskPixel2 = v6;
HXDLIN( 513)									int this73 = col2;
HXDLIN( 513)									if ((maskPixel2 == 0)) {
HXDLIN( 513)										col2 = this73;
            									}
            									else {
HXDLIN( 513)										Float m02;
HXDLIN( 513)										int this74 = ((maskPixel2 >> 24) & 255);
HXDLIN( 513)										if ((this74 == 0)) {
HXDLIN( 513)											m02 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m02 = (( (Float)(this74) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m12;
HXDLIN( 513)										int this75 = ((maskPixel2 >> 16) & 255);
HXDLIN( 513)										if ((this75 == 0)) {
HXDLIN( 513)											m12 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m12 = (( (Float)(this75) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m22;
HXDLIN( 513)										int this76 = ((maskPixel2 >> 8) & 255);
HXDLIN( 513)										if ((this76 == 0)) {
HXDLIN( 513)											m22 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m22 = (( (Float)(this76) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m32;
HXDLIN( 513)										int this77 = (maskPixel2 & 255);
HXDLIN( 513)										if ((this77 == 0)) {
HXDLIN( 513)											m32 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m32 = (( (Float)(this77) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this73 >> 24) & 255)) )));
HXDLIN( 513)										int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this73 >> 16) & 255)) )));
HXDLIN( 513)										int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this73 >> 8) & 255)) )));
HXDLIN( 513)										int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this73 & 255)) )));
HXDLIN( 513)										col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 513)								if ((col2 != 0)) {
HXDLIN( 513)									int x9 = (dx4 - rectLeft2);
HXDLIN( 513)									int y9 = (dy4 - rectTop2);
HXDLIN( 513)									int c14 = col2;
HXDLIN( 513)									bool _hx_tmp17;
HXDLIN( 513)									if ((((c14 >> 24) & 255) < 254)) {
HXDLIN( 513)										_hx_tmp17 = undoImage6->transparent;
            									}
            									else {
HXDLIN( 513)										_hx_tmp17 = false;
            									}
HXDLIN( 513)									if (_hx_tmp17) {
HXDLIN( 513)										int location4;
HXDLIN( 513)										if (undoImage6->useVirtualPos) {
HXDLIN( 513)											location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 513)											location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            										}
HXDLIN( 513)										int this78 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN( 513)										int this79;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											this79 = ((((((this78 >> 24) & 255) << 24) | ((this78 & 255) << 16)) | (((this78 >> 8) & 255) << 8)) | ((this78 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											this79 = this78;
            										}
HXDLIN( 513)										Float a18;
HXDLIN( 513)										int this80 = ((this79 >> 24) & 255);
HXDLIN( 513)										if ((this80 == 0)) {
HXDLIN( 513)											a18 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a18 = (( (Float)(this80) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r14;
HXDLIN( 513)										int this81 = ((this79 >> 16) & 255);
HXDLIN( 513)										if ((this81 == 0)) {
HXDLIN( 513)											r14 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r14 = (( (Float)(this81) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g14;
HXDLIN( 513)										int this82 = ((this79 >> 8) & 255);
HXDLIN( 513)										if ((this82 == 0)) {
HXDLIN( 513)											g14 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g14 = (( (Float)(this82) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b110;
HXDLIN( 513)										int this83 = (this79 & 255);
HXDLIN( 513)										if ((this83 == 0)) {
HXDLIN( 513)											b110 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b110 = (( (Float)(this83) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a24;
HXDLIN( 513)										int this84 = ((col2 >> 24) & 255);
HXDLIN( 513)										if ((this84 == 0)) {
HXDLIN( 513)											a24 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a24 = (( (Float)(this84) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r24;
HXDLIN( 513)										int this85 = ((col2 >> 16) & 255);
HXDLIN( 513)										if ((this85 == 0)) {
HXDLIN( 513)											r24 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r24 = (( (Float)(this85) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g24;
HXDLIN( 513)										int this86 = ((col2 >> 8) & 255);
HXDLIN( 513)										if ((this86 == 0)) {
HXDLIN( 513)											g24 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g24 = (( (Float)(this86) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b25;
HXDLIN( 513)										int this87 = (col2 & 255);
HXDLIN( 513)										if ((this87 == 0)) {
HXDLIN( 513)											b25 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b25 = (( (Float)(this87) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a34 = (a18 * (( (Float)(1) ) - a24));
HXDLIN( 513)										int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 513)										int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 513)										int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN( 513)										int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 513)										int blended4 = ((((a19 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN( 513)										{
HXDLIN( 513)											int _hx_tmp18;
HXDLIN( 513)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)												_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            											}
            											else {
HXDLIN( 513)												_hx_tmp18 = blended4;
            											}
HXDLIN( 513)											::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            										}
            									}
            									else {
HXDLIN( 513)										::Dynamic this88 = undoImage6->image;
HXDLIN( 513)										int index12;
HXDLIN( 513)										if (undoImage6->useVirtualPos) {
HXDLIN( 513)											index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 513)											index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            										}
HXDLIN( 513)										int _hx_tmp19;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											_hx_tmp19 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											_hx_tmp19 = c14;
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this88,index12,_hx_tmp19);
            									}
            								}
            								else {
HXDLIN( 513)									if (forceClear2) {
HXDLIN( 513)										::Dynamic this89 = undoImage6->image;
HXDLIN( 513)										int x10 = (dx4 - rectLeft2);
HXDLIN( 513)										int y10 = (dy4 - rectTop2);
HXDLIN( 513)										int index13;
HXDLIN( 513)										if (undoImage6->useVirtualPos) {
HXDLIN( 513)											index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            										}
            										else {
HXDLIN( 513)											index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this89,index13,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 513)		bool found2 = false;
HXDLIN( 513)		Float s2 = ((Float)0.);
HXDLIN( 513)		Float t2 = ((Float)0.);
HXDLIN( 513)		Float sxx2 = ((Float)0.);
HXDLIN( 513)		Float txx2 = ((Float)0.);
HXDLIN( 513)		{
HXDLIN( 513)			int _g_min4 = xIter32->start;
HXDLIN( 513)			int _g_max4 = xIter32->max;
HXDLIN( 513)			while((_g_min4 < _g_max4)){
HXDLIN( 513)				_g_min4 = (_g_min4 + 1);
HXDLIN( 513)				int x11 = (_g_min4 - 1);
HXLINE(  60)				sxx2 = (sx2 * ( (Float)(x11) ));
HXLINE(  61)				txx2 = (tx2 * ( (Float)(x11) ));
HXLINE(  62)				found2 = false;
HXLINE( 513)				{
HXDLIN( 513)					int _g_min5 = yIter32->start;
HXDLIN( 513)					int _g_max5 = yIter32->max;
HXDLIN( 513)					while((_g_min5 < _g_max5)){
HXDLIN( 513)						_g_min5 = (_g_min5 + 1);
HXDLIN( 513)						int y11 = (_g_min5 - 1);
HXLINE(  64)						s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y11) )));
HXLINE(  65)						t2 = ((t02 + txx2) + (ty2 * ( (Float)(y11) )));
HXLINE( 513)						bool _hx_tmp20;
HXDLIN( 513)						if (!((s2 <= 0))) {
HXDLIN( 513)							_hx_tmp20 = (t2 <= 0);
            						}
            						else {
HXDLIN( 513)							_hx_tmp20 = true;
            						}
HXDLIN( 513)						if (_hx_tmp20) {
HXDLIN( 513)							if (found2) {
HXDLIN( 513)								goto _hx_goto_1030;
            							}
            						}
            						else {
HXDLIN( 513)							if (((s2 + t2) < A2)) {
HXDLIN( 513)								{
HXDLIN( 513)									int c15 = color;
HXDLIN( 513)									bool _hx_tmp21;
HXDLIN( 513)									if ((((c15 >> 24) & 255) < 254)) {
HXDLIN( 513)										_hx_tmp21 = this1->transparent;
            									}
            									else {
HXDLIN( 513)										_hx_tmp21 = false;
            									}
HXDLIN( 513)									if (_hx_tmp21) {
HXDLIN( 513)										int location5;
HXDLIN( 513)										if (this1->useVirtualPos) {
HXDLIN( 513)											location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            										}
            										else {
HXDLIN( 513)											location5 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            										}
HXDLIN( 513)										int this90 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN( 513)										int this91;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											this91 = this90;
            										}
HXDLIN( 513)										Float a110;
HXDLIN( 513)										int this92 = ((this91 >> 24) & 255);
HXDLIN( 513)										if ((this92 == 0)) {
HXDLIN( 513)											a110 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a110 = (( (Float)(this92) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r15;
HXDLIN( 513)										int this93 = ((this91 >> 16) & 255);
HXDLIN( 513)										if ((this93 == 0)) {
HXDLIN( 513)											r15 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r15 = (( (Float)(this93) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g15;
HXDLIN( 513)										int this94 = ((this91 >> 8) & 255);
HXDLIN( 513)										if ((this94 == 0)) {
HXDLIN( 513)											g15 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g15 = (( (Float)(this94) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b111;
HXDLIN( 513)										int this95 = (this91 & 255);
HXDLIN( 513)										if ((this95 == 0)) {
HXDLIN( 513)											b111 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b111 = (( (Float)(this95) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a25;
HXDLIN( 513)										int this96 = ((color >> 24) & 255);
HXDLIN( 513)										if ((this96 == 0)) {
HXDLIN( 513)											a25 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a25 = (( (Float)(this96) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r25;
HXDLIN( 513)										int this97 = ((color >> 16) & 255);
HXDLIN( 513)										if ((this97 == 0)) {
HXDLIN( 513)											r25 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r25 = (( (Float)(this97) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g25;
HXDLIN( 513)										int this98 = ((color >> 8) & 255);
HXDLIN( 513)										if ((this98 == 0)) {
HXDLIN( 513)											g25 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g25 = (( (Float)(this98) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b27;
HXDLIN( 513)										int this99 = (color & 255);
HXDLIN( 513)										if ((this99 == 0)) {
HXDLIN( 513)											b27 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b27 = (( (Float)(this99) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN( 513)										int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN( 513)										int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN( 513)										int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b27 * a25))));
HXDLIN( 513)										int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN( 513)										int blended5 = ((((a20 << 24) | (r7 << 16)) | (g7 << 8)) | b28);
HXDLIN( 513)										{
HXDLIN( 513)											int _hx_tmp22;
HXDLIN( 513)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)												_hx_tmp22 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            											}
            											else {
HXDLIN( 513)												_hx_tmp22 = blended5;
            											}
HXDLIN( 513)											::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp22);
            										}
            									}
            									else {
HXDLIN( 513)										::Dynamic this100 = this1->image;
HXDLIN( 513)										int index14;
HXDLIN( 513)										if (this1->useVirtualPos) {
HXDLIN( 513)											index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            										}
            										else {
HXDLIN( 513)											index14 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            										}
HXDLIN( 513)										int _hx_tmp23;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											_hx_tmp23 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											_hx_tmp23 = c15;
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this100,index14,_hx_tmp23);
            									}
            								}
HXLINE(  73)								found2 = true;
            							}
            							else {
HXDLIN( 513)								if (found2) {
HXDLIN( 513)									goto _hx_goto_1030;
            								}
            							}
            						}
            					}
            					_hx_goto_1030:;
            				}
            			}
            		}
HXDLIN( 513)		 ::pi_xy::algo::HitTri hitTriTop;
HXDLIN( 513)		if ((hasHit == true)) {
HXDLIN( 513)			 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx,qy,bx6,by6,cx6,cy6,true);
HXDLIN( 513)			if (hasUndo2) {
HXDLIN( 513)				v7->undoImage = undoImage6;
HXDLIN( 513)				v7->undoX = xIter32->start;
HXDLIN( 513)				v7->undoY = yIter32->start;
            			}
HXDLIN( 513)			hitTriTop = v7;
            		}
            		else {
HXDLIN( 513)			hitTriTop = null();
            		}
HXDLIN( 513)		Float bx7 = ax3;
HXDLIN( 513)		Float by7 = ay3;
HXDLIN( 513)		Float cx7 = dx3;
HXDLIN( 513)		Float cy7 = dy3;
HXDLIN( 513)		bool hasUndo3 = false;
HXDLIN( 513)		bool adjustWinding5 = (((((px * by7) - (bx7 * py)) + ((bx7 * cy7) - (cx7 * by7))) + ((cx7 * py) - (px * cy7))) > 0);
HXDLIN( 513)		if (!(adjustWinding5)) {
HXDLIN( 513)			Float bx_5 = bx7;
HXDLIN( 513)			Float by_5 = by7;
HXLINE(  25)			bx7 = cx7;
HXLINE(  26)			by7 = cy7;
HXLINE(  27)			cx7 = bx_5;
HXLINE(  28)			cy7 = by_5;
            		}
HXLINE( 513)		Float s03 = ((py * cx7) - (px * cy7));
HXDLIN( 513)		Float sx3 = (cy7 - py);
HXDLIN( 513)		Float sy3 = (px - cx7);
HXDLIN( 513)		Float t03 = ((px * by7) - (py * bx7));
HXDLIN( 513)		Float tx3 = (py - by7);
HXDLIN( 513)		Float ty3 = (bx7 - px);
HXDLIN( 513)		Float A3 = ((((-(by7) * cx7) + (py * (-(bx7) + cx7))) + (px * (by7 - cy7))) + (bx7 * cy7));
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN( 513)		if ((px > bx7)) {
HXDLIN( 513)			if ((px > cx7)) {
HXDLIN( 513)				int min20;
HXDLIN( 513)				if ((bx7 > cx7)) {
HXDLIN( 513)					min20 = ::Math_obj::floor(cx7);
            				}
            				else {
HXDLIN( 513)					min20 = ::Math_obj::floor(bx7);
            				}
HXDLIN( 513)				int ii_min40 = min20;
HXDLIN( 513)				int ii_max40 = ::Math_obj::ceil(px);
HXDLIN( 513)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            			}
            			else {
HXDLIN( 513)				int ii_min41 = ::Math_obj::floor(bx7);
HXDLIN( 513)				int ii_max41 = ::Math_obj::ceil(cx7);
HXDLIN( 513)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            			}
            		}
            		else {
HXDLIN( 513)			if ((bx7 > cx7)) {
HXDLIN( 513)				int min21;
HXDLIN( 513)				if ((px > cx7)) {
HXDLIN( 513)					min21 = ::Math_obj::floor(cx7);
            				}
            				else {
HXDLIN( 513)					min21 = ::Math_obj::ceil(px);
            				}
HXDLIN( 513)				int ii_min42 = min21;
HXDLIN( 513)				int ii_max42 = ::Math_obj::ceil(bx7);
HXDLIN( 513)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            			}
            			else {
HXDLIN( 513)				int ii_min43 = ::Math_obj::floor(px);
HXDLIN( 513)				int ii_max43 = ::Math_obj::ceil(cx7);
HXDLIN( 513)				xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            			}
            		}
HXDLIN( 513)		 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN( 513)		if ((py > by7)) {
HXDLIN( 513)			if ((py > cy7)) {
HXDLIN( 513)				int min22;
HXDLIN( 513)				if ((by7 > cy7)) {
HXDLIN( 513)					min22 = ::Math_obj::floor(cy7);
            				}
            				else {
HXDLIN( 513)					min22 = ::Math_obj::floor(by7);
            				}
HXDLIN( 513)				int ii_min44 = min22;
HXDLIN( 513)				int ii_max44 = ::Math_obj::ceil(py);
HXDLIN( 513)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            			}
            			else {
HXDLIN( 513)				int ii_min45 = ::Math_obj::floor(by7);
HXDLIN( 513)				int ii_max45 = ::Math_obj::ceil(cy7);
HXDLIN( 513)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            			}
            		}
            		else {
HXDLIN( 513)			if ((by7 > cy7)) {
HXDLIN( 513)				int min23;
HXDLIN( 513)				if ((py > cy7)) {
HXDLIN( 513)					min23 = ::Math_obj::floor(cy7);
            				}
            				else {
HXDLIN( 513)					min23 = ::Math_obj::ceil(py);
            				}
HXDLIN( 513)				int ii_min46 = min23;
HXDLIN( 513)				int ii_max46 = ::Math_obj::ceil(by7);
HXDLIN( 513)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            			}
            			else {
HXDLIN( 513)				int ii_min47 = ::Math_obj::floor(py);
HXDLIN( 513)				int ii_max47 = ::Math_obj::ceil(cy7);
HXDLIN( 513)				yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            			}
            		}
HXDLIN( 513)		 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN( 513)		if (hasUndo3) {
HXDLIN( 513)			int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN( 513)			int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN( 513)			 ::Dynamic imageType3 = null();
HXDLIN( 513)			 ::pi_xy::ImageStruct this101 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 513)			if (::hx::IsNull( imageType3 )) {
HXLINE(  54)				imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 513)			::Dynamic undoImage10;
HXDLIN( 513)			switch((int)(( (int)(imageType3) ))){
            				case (int)0: {
HXDLIN( 513)					 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::BytesImg b29 = byt3;
HXDLIN( 513)					{
HXDLIN( 513)						b29->width = width3;
HXDLIN( 513)						b29->height = height3;
HXDLIN( 513)						b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 513)						b29->data = ::haxe::io::Bytes_obj::alloc((b29->length * 4));
HXDLIN( 513)						{
HXDLIN( 513)							int len6 = b29->length;
HXDLIN( 513)							int w3 = 0;
HXDLIN( 513)							{
HXDLIN( 513)								int _g60 = 0;
HXDLIN( 513)								int _g61 = b29->height;
HXDLIN( 513)								while((_g60 < _g61)){
HXDLIN( 513)									_g60 = (_g60 + 1);
HXDLIN( 513)									int y12 = (_g60 - 1);
HXDLIN( 513)									{
HXDLIN( 513)										int _g62 = 0;
HXDLIN( 513)										int _g63 = b29->width;
HXDLIN( 513)										while((_g62 < _g63)){
HXDLIN( 513)											_g62 = (_g62 + 1);
HXDLIN( 513)											int x12 = (_g62 - 1);
HXDLIN( 513)											{
HXDLIN( 513)												w3 = (w3 + 1);
HXDLIN( 513)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w3 = (w3 + 1);
HXDLIN( 513)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w3 = (w3 + 1);
HXDLIN( 513)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 513)											{
HXDLIN( 513)												w3 = (w3 + 1);
HXDLIN( 513)												b29->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage10 = b29;
            				}
            				break;
            				case (int)1: {
HXDLIN( 513)					 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::ArrIntImg a26 = arrI3;
HXDLIN( 513)					{
HXDLIN( 513)						a26->width = width3;
HXDLIN( 513)						a26->height = height3;
HXDLIN( 513)						a26->data = ::Array_obj< int >::__new(0);
HXDLIN( 513)						a26->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 513)						{
HXDLIN( 513)							int _g64 = 0;
HXDLIN( 513)							int _g65 = a26->length;
HXDLIN( 513)							while((_g64 < _g65)){
HXDLIN( 513)								_g64 = (_g64 + 1);
HXDLIN( 513)								int i18 = (_g64 - 1);
HXDLIN( 513)								a26->data[i18] = 0;
            							}
            						}
            					}
HXDLIN( 513)					undoImage10 = a26;
            				}
            				break;
            				case (int)2: {
HXDLIN( 513)					 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::U32ArrImg b30 = u32a3;
HXDLIN( 513)					{
HXDLIN( 513)						b30->width = width3;
HXDLIN( 513)						b30->height = height3;
HXDLIN( 513)						b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 513)						int size3 = (b30->length * 4);
HXDLIN( 513)						b30->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 513)						{
HXDLIN( 513)							int _g66 = 0;
HXDLIN( 513)							int _g67 = b30->length;
HXDLIN( 513)							while((_g66 < _g67)){
HXDLIN( 513)								_g66 = (_g66 + 1);
HXDLIN( 513)								int i19 = (_g66 - 1);
HXDLIN( 513)								{
HXDLIN( 513)									 ::haxe::io::ArrayBufferViewImpl this102 = b30->data;
HXDLIN( 513)									bool undoImage11;
HXDLIN( 513)									if ((i19 >= 0)) {
HXDLIN( 513)										undoImage11 = (i19 < (this102->byteLength >> 2));
            									}
            									else {
HXDLIN( 513)										undoImage11 = false;
            									}
HXDLIN( 513)									if (undoImage11) {
HXDLIN( 513)										 ::haxe::io::Bytes _this3 = this102->bytes;
HXDLIN( 513)										int pos3 = ((i19 << 2) + this102->byteOffset);
HXDLIN( 513)										_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 513)										_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 513)										_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 513)										_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage10 = b30;
            				}
            				break;
            				case (int)3: {
HXDLIN( 513)					 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::VecIntImg v8 = vec3;
HXDLIN( 513)					{
HXDLIN( 513)						v8->width = width3;
HXDLIN( 513)						v8->height = height3;
HXDLIN( 513)						v8->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 513)						v8->data = ::Array_obj< int >::__new(v8->length);
HXDLIN( 513)						{
HXDLIN( 513)							int _g68 = 0;
HXDLIN( 513)							int _g69 = v8->length;
HXDLIN( 513)							while((_g68 < _g69)){
HXDLIN( 513)								_g68 = (_g68 + 1);
HXDLIN( 513)								int i20 = (_g68 - 1);
HXDLIN( 513)								v8->data->__unsafe_set(i20,0);
            							}
            						}
            					}
HXDLIN( 513)					undoImage10 = v8;
            				}
            				break;
            				case (int)4: {
HXDLIN( 513)					 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 513)					 ::iterMagic::StackIntImg b31 = sInt3;
HXDLIN( 513)					{
HXDLIN( 513)						b31->width = width3;
HXDLIN( 513)						b31->height = height3;
HXDLIN( 513)						b31->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN( 513)						b31->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 513)						{
HXDLIN( 513)							int len7 = b31->length;
HXDLIN( 513)							 ::haxe::ds::GenericStack_Int d3 = b31->data;
HXDLIN( 513)							if (::hx::IsNull( d3->head )) {
HXDLIN( 513)								int _g70 = 0;
HXDLIN( 513)								int _g71 = len7;
HXDLIN( 513)								while((_g70 < _g71)){
HXDLIN( 513)									_g70 = (_g70 + 1);
HXDLIN( 513)									int i21 = (_g70 - 1);
HXDLIN( 513)									d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            								}
            							}
            							else {
HXDLIN( 513)								int _g72 = 0;
HXDLIN( 513)								int _g73 = len7;
HXDLIN( 513)								while((_g72 < _g73)){
HXDLIN( 513)									_g72 = (_g72 + 1);
HXDLIN( 513)									int i22 = (_g72 - 1);
HXDLIN( 513)									{
HXDLIN( 513)										 ::haxe::ds::GenericCell_Int l3 = b31->data->head;
HXDLIN( 513)										 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 513)										{
HXDLIN( 513)											int _g74 = 0;
HXDLIN( 513)											int _g75 = i22;
HXDLIN( 513)											while((_g74 < _g75)){
HXDLIN( 513)												_g74 = (_g74 + 1);
HXDLIN( 513)												int i23 = (_g74 - 1);
HXLINE( 345)												prev3 = l3;
HXLINE( 346)												l3 = l3->next;
            											}
            										}
HXLINE( 513)										if (::hx::IsNull( prev3 )) {
HXDLIN( 513)											b31->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 513)											l3 = null();
            										}
            										else {
HXDLIN( 513)											prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 513)											l3 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 513)					undoImage10 = b31;
            				}
            				break;
            			}
HXDLIN( 513)			this101->image = undoImage10;
HXDLIN( 513)			this101->width = width3;
HXDLIN( 513)			this101->height = height3;
HXDLIN( 513)			this101->imageType = ( (int)(imageType3) );
HXDLIN( 513)			undoImage9 = this101;
HXDLIN( 513)			{
HXDLIN( 513)				int rectLeft3 = xIter33->start;
HXDLIN( 513)				int rectTop3 = yIter33->start;
HXDLIN( 513)				int rectRight3 = xIter33->max;
HXDLIN( 513)				bool forceClear3 = false;
HXDLIN( 513)				{
HXDLIN( 513)					int _g76 = rectTop3;
HXDLIN( 513)					int _g77 = yIter33->max;
HXDLIN( 513)					while((_g76 < _g77)){
HXDLIN( 513)						_g76 = (_g76 + 1);
HXDLIN( 513)						int dy5 = (_g76 - 1);
HXDLIN( 513)						{
HXDLIN( 513)							int _g78 = rectLeft3;
HXDLIN( 513)							int _g79 = rectRight3;
HXDLIN( 513)							while((_g78 < _g79)){
HXDLIN( 513)								_g78 = (_g78 + 1);
HXDLIN( 513)								int dx5 = (_g78 - 1);
HXDLIN( 513)								::Dynamic this103 = this1->image;
HXDLIN( 513)								int index15;
HXDLIN( 513)								if (this1->useVirtualPos) {
HXDLIN( 513)									index15 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx5) - this1->virtualX));
            								}
            								else {
HXDLIN( 513)									index15 = ::Std_obj::_hx_int(( (Float)(((dy5 * this1->width) + dx5)) ));
            								}
HXDLIN( 513)								int c16 = ::iterMagic::Iimg_obj::get(this103,index15);
HXDLIN( 513)								int col3;
HXDLIN( 513)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)									col3 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            								}
            								else {
HXDLIN( 513)									col3 = c16;
            								}
HXDLIN( 513)								bool _hx_tmp24;
HXDLIN( 513)								if (this1->useMask) {
HXDLIN( 513)									_hx_tmp24 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN( 513)									_hx_tmp24 = false;
            								}
HXDLIN( 513)								if (_hx_tmp24) {
HXDLIN( 513)									 ::pi_xy::ImageStruct this104 = this1->mask;
HXDLIN( 513)									::Dynamic this105 = this104->image;
HXDLIN( 513)									int index16;
HXDLIN( 513)									if (this104->useVirtualPos) {
HXDLIN( 513)										index16 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this104->virtualY) * ( (Float)(this104->width) )) + dx5) - this104->virtualX));
            									}
            									else {
HXDLIN( 513)										index16 = ::Std_obj::_hx_int(( (Float)(((dy5 * this104->width) + dx5)) ));
            									}
HXDLIN( 513)									int c17 = ::iterMagic::Iimg_obj::get(this105,index16);
HXDLIN( 513)									int v9;
HXDLIN( 513)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)										v9 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            									}
            									else {
HXDLIN( 513)										v9 = c17;
            									}
HXDLIN( 513)									int maskPixel3 = v9;
HXDLIN( 513)									int this106 = col3;
HXDLIN( 513)									if ((maskPixel3 == 0)) {
HXDLIN( 513)										col3 = this106;
            									}
            									else {
HXDLIN( 513)										Float m03;
HXDLIN( 513)										int this107 = ((maskPixel3 >> 24) & 255);
HXDLIN( 513)										if ((this107 == 0)) {
HXDLIN( 513)											m03 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m03 = (( (Float)(this107) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m13;
HXDLIN( 513)										int this108 = ((maskPixel3 >> 16) & 255);
HXDLIN( 513)										if ((this108 == 0)) {
HXDLIN( 513)											m13 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m13 = (( (Float)(this108) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m23;
HXDLIN( 513)										int this109 = ((maskPixel3 >> 8) & 255);
HXDLIN( 513)										if ((this109 == 0)) {
HXDLIN( 513)											m23 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m23 = (( (Float)(this109) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float m33;
HXDLIN( 513)										int this110 = (maskPixel3 & 255);
HXDLIN( 513)										if ((this110 == 0)) {
HXDLIN( 513)											m33 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											m33 = (( (Float)(this110) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this106 >> 24) & 255)) )));
HXDLIN( 513)										int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this106 >> 16) & 255)) )));
HXDLIN( 513)										int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this106 >> 8) & 255)) )));
HXDLIN( 513)										int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this106 & 255)) )));
HXDLIN( 513)										col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 513)								if ((col3 != 0)) {
HXDLIN( 513)									int x13 = (dx5 - rectLeft3);
HXDLIN( 513)									int y13 = (dy5 - rectTop3);
HXDLIN( 513)									int c18 = col3;
HXDLIN( 513)									bool _hx_tmp25;
HXDLIN( 513)									if ((((c18 >> 24) & 255) < 254)) {
HXDLIN( 513)										_hx_tmp25 = undoImage9->transparent;
            									}
            									else {
HXDLIN( 513)										_hx_tmp25 = false;
            									}
HXDLIN( 513)									if (_hx_tmp25) {
HXDLIN( 513)										int location6;
HXDLIN( 513)										if (undoImage9->useVirtualPos) {
HXDLIN( 513)											location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 513)											location6 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            										}
HXDLIN( 513)										int this111 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN( 513)										int this112;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											this112 = ((((((this111 >> 24) & 255) << 24) | ((this111 & 255) << 16)) | (((this111 >> 8) & 255) << 8)) | ((this111 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											this112 = this111;
            										}
HXDLIN( 513)										Float a111;
HXDLIN( 513)										int this113 = ((this112 >> 24) & 255);
HXDLIN( 513)										if ((this113 == 0)) {
HXDLIN( 513)											a111 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a111 = (( (Float)(this113) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r16;
HXDLIN( 513)										int this114 = ((this112 >> 16) & 255);
HXDLIN( 513)										if ((this114 == 0)) {
HXDLIN( 513)											r16 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r16 = (( (Float)(this114) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g16;
HXDLIN( 513)										int this115 = ((this112 >> 8) & 255);
HXDLIN( 513)										if ((this115 == 0)) {
HXDLIN( 513)											g16 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g16 = (( (Float)(this115) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b112;
HXDLIN( 513)										int this116 = (this112 & 255);
HXDLIN( 513)										if ((this116 == 0)) {
HXDLIN( 513)											b112 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b112 = (( (Float)(this116) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a27;
HXDLIN( 513)										int this117 = ((col3 >> 24) & 255);
HXDLIN( 513)										if ((this117 == 0)) {
HXDLIN( 513)											a27 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a27 = (( (Float)(this117) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r26;
HXDLIN( 513)										int this118 = ((col3 >> 16) & 255);
HXDLIN( 513)										if ((this118 == 0)) {
HXDLIN( 513)											r26 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r26 = (( (Float)(this118) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g26;
HXDLIN( 513)										int this119 = ((col3 >> 8) & 255);
HXDLIN( 513)										if ((this119 == 0)) {
HXDLIN( 513)											g26 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g26 = (( (Float)(this119) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b210;
HXDLIN( 513)										int this120 = (col3 & 255);
HXDLIN( 513)										if ((this120 == 0)) {
HXDLIN( 513)											b210 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b210 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a36 = (a111 * (( (Float)(1) ) - a27));
HXDLIN( 513)										int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a27))));
HXDLIN( 513)										int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a27))));
HXDLIN( 513)										int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a27))));
HXDLIN( 513)										int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a27)));
HXDLIN( 513)										int blended6 = ((((a28 << 24) | (r8 << 16)) | (g8 << 8)) | b32);
HXDLIN( 513)										{
HXDLIN( 513)											int _hx_tmp26;
HXDLIN( 513)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)												_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            											}
            											else {
HXDLIN( 513)												_hx_tmp26 = blended6;
            											}
HXDLIN( 513)											::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            										}
            									}
            									else {
HXDLIN( 513)										::Dynamic this121 = undoImage9->image;
HXDLIN( 513)										int index17;
HXDLIN( 513)										if (undoImage9->useVirtualPos) {
HXDLIN( 513)											index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 513)											index17 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            										}
HXDLIN( 513)										int _hx_tmp27;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											_hx_tmp27 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											_hx_tmp27 = c18;
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this121,index17,_hx_tmp27);
            									}
            								}
            								else {
HXDLIN( 513)									if (forceClear3) {
HXDLIN( 513)										::Dynamic this122 = undoImage9->image;
HXDLIN( 513)										int x14 = (dx5 - rectLeft3);
HXDLIN( 513)										int y14 = (dy5 - rectTop3);
HXDLIN( 513)										int index18;
HXDLIN( 513)										if (undoImage9->useVirtualPos) {
HXDLIN( 513)											index18 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            										}
            										else {
HXDLIN( 513)											index18 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this122,index18,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 513)		bool found3 = false;
HXDLIN( 513)		Float s3 = ((Float)0.);
HXDLIN( 513)		Float t3 = ((Float)0.);
HXDLIN( 513)		Float sxx3 = ((Float)0.);
HXDLIN( 513)		Float txx3 = ((Float)0.);
HXDLIN( 513)		{
HXDLIN( 513)			int _g_min6 = xIter33->start;
HXDLIN( 513)			int _g_max6 = xIter33->max;
HXDLIN( 513)			while((_g_min6 < _g_max6)){
HXDLIN( 513)				_g_min6 = (_g_min6 + 1);
HXDLIN( 513)				int x15 = (_g_min6 - 1);
HXLINE(  60)				sxx3 = (sx3 * ( (Float)(x15) ));
HXLINE(  61)				txx3 = (tx3 * ( (Float)(x15) ));
HXLINE(  62)				found3 = false;
HXLINE( 513)				{
HXDLIN( 513)					int _g_min7 = yIter33->start;
HXDLIN( 513)					int _g_max7 = yIter33->max;
HXDLIN( 513)					while((_g_min7 < _g_max7)){
HXDLIN( 513)						_g_min7 = (_g_min7 + 1);
HXDLIN( 513)						int y15 = (_g_min7 - 1);
HXLINE(  64)						s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y15) )));
HXLINE(  65)						t3 = ((t03 + txx3) + (ty3 * ( (Float)(y15) )));
HXLINE( 513)						bool _hx_tmp28;
HXDLIN( 513)						if (!((s3 <= 0))) {
HXDLIN( 513)							_hx_tmp28 = (t3 <= 0);
            						}
            						else {
HXDLIN( 513)							_hx_tmp28 = true;
            						}
HXDLIN( 513)						if (_hx_tmp28) {
HXDLIN( 513)							if (found3) {
HXDLIN( 513)								goto _hx_goto_1042;
            							}
            						}
            						else {
HXDLIN( 513)							if (((s3 + t3) < A3)) {
HXDLIN( 513)								{
HXDLIN( 513)									int c19 = color;
HXDLIN( 513)									bool _hx_tmp29;
HXDLIN( 513)									if ((((c19 >> 24) & 255) < 254)) {
HXDLIN( 513)										_hx_tmp29 = this1->transparent;
            									}
            									else {
HXDLIN( 513)										_hx_tmp29 = false;
            									}
HXDLIN( 513)									if (_hx_tmp29) {
HXDLIN( 513)										int location7;
HXDLIN( 513)										if (this1->useVirtualPos) {
HXDLIN( 513)											location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            										}
            										else {
HXDLIN( 513)											location7 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            										}
HXDLIN( 513)										int this123 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN( 513)										int this124;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											this124 = ((((((this123 >> 24) & 255) << 24) | ((this123 & 255) << 16)) | (((this123 >> 8) & 255) << 8)) | ((this123 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											this124 = this123;
            										}
HXDLIN( 513)										Float a112;
HXDLIN( 513)										int this125 = ((this124 >> 24) & 255);
HXDLIN( 513)										if ((this125 == 0)) {
HXDLIN( 513)											a112 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a112 = (( (Float)(this125) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r17;
HXDLIN( 513)										int this126 = ((this124 >> 16) & 255);
HXDLIN( 513)										if ((this126 == 0)) {
HXDLIN( 513)											r17 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r17 = (( (Float)(this126) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g17;
HXDLIN( 513)										int this127 = ((this124 >> 8) & 255);
HXDLIN( 513)										if ((this127 == 0)) {
HXDLIN( 513)											g17 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g17 = (( (Float)(this127) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b113;
HXDLIN( 513)										int this128 = (this124 & 255);
HXDLIN( 513)										if ((this128 == 0)) {
HXDLIN( 513)											b113 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b113 = (( (Float)(this128) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a29;
HXDLIN( 513)										int this129 = ((color >> 24) & 255);
HXDLIN( 513)										if ((this129 == 0)) {
HXDLIN( 513)											a29 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											a29 = (( (Float)(this129) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float r27;
HXDLIN( 513)										int this130 = ((color >> 16) & 255);
HXDLIN( 513)										if ((this130 == 0)) {
HXDLIN( 513)											r27 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											r27 = (( (Float)(this130) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float g27;
HXDLIN( 513)										int this131 = ((color >> 8) & 255);
HXDLIN( 513)										if ((this131 == 0)) {
HXDLIN( 513)											g27 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											g27 = (( (Float)(this131) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float b211;
HXDLIN( 513)										int this132 = (color & 255);
HXDLIN( 513)										if ((this132 == 0)) {
HXDLIN( 513)											b211 = ((Float)0.);
            										}
            										else {
HXDLIN( 513)											b211 = (( (Float)(this132) ) / ( (Float)(255) ));
            										}
HXDLIN( 513)										Float a37 = (a112 * (( (Float)(1) ) - a29));
HXDLIN( 513)										int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a29))));
HXDLIN( 513)										int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a29))));
HXDLIN( 513)										int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a29))));
HXDLIN( 513)										int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a29)));
HXDLIN( 513)										int blended7 = ((((a30 << 24) | (r9 << 16)) | (g9 << 8)) | b33);
HXDLIN( 513)										{
HXDLIN( 513)											int _hx_tmp30;
HXDLIN( 513)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)												_hx_tmp30 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            											}
            											else {
HXDLIN( 513)												_hx_tmp30 = blended7;
            											}
HXDLIN( 513)											::iterMagic::Iimg_obj::set(this1->image,location7,_hx_tmp30);
            										}
            									}
            									else {
HXDLIN( 513)										::Dynamic this133 = this1->image;
HXDLIN( 513)										int index19;
HXDLIN( 513)										if (this1->useVirtualPos) {
HXDLIN( 513)											index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this1->virtualY) * ( (Float)(this1->width) )) + x15) - this1->virtualX));
            										}
            										else {
HXDLIN( 513)											index19 = ::Std_obj::_hx_int(( (Float)(((y15 * this1->width) + x15)) ));
            										}
HXDLIN( 513)										int _hx_tmp31;
HXDLIN( 513)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 513)											_hx_tmp31 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            										}
            										else {
HXDLIN( 513)											_hx_tmp31 = c19;
            										}
HXDLIN( 513)										::iterMagic::Iimg_obj::set(this133,index19,_hx_tmp31);
            									}
            								}
HXLINE(  73)								found3 = true;
            							}
            							else {
HXDLIN( 513)								if (found3) {
HXDLIN( 513)									goto _hx_goto_1042;
            								}
            							}
            						}
            					}
            					_hx_goto_1042:;
            				}
            			}
            		}
HXDLIN( 513)		 ::pi_xy::algo::HitTri hitTriBottom;
HXDLIN( 513)		if ((hasHit == true)) {
HXDLIN( 513)			 ::pi_xy::algo::HitTri v10 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,px,py,bx7,by7,cx7,cy7,true);
HXDLIN( 513)			if (hasUndo3) {
HXDLIN( 513)				v10->undoImage = undoImage9;
HXDLIN( 513)				v10->undoX = xIter33->start;
HXDLIN( 513)				v10->undoY = yIter33->start;
            			}
HXDLIN( 513)			hitTriBottom = v10;
            		}
            		else {
HXDLIN( 513)			hitTriBottom = null();
            		}
HXDLIN( 513)		if (hasHit) {
HXDLIN( 513)			 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(2)->init(0,hitTriTop)->init(1,hitTriBottom));
HXDLIN( 513)			if (::hx::IsNotNull( hitQuad )) {
HXDLIN( 513)				hitArr->triArr->push(hitQuad->triABD);
            			}
HXDLIN( 513)			hitArr->triArr->push(hitQuad->triBCD);
HXDLIN( 513)			return hitArr;
            		}
            		else {
HXDLIN( 513)			return null();
            		}
HXDLIN( 513)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(FillShape_Impl__obj,fixArrowBoth,return )

void FillShape_Impl__obj::ellipseTri( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,int color, ::Dynamic __o_phi, ::Dynamic __o_printSides, ::Dynamic __o_targetError){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = 0;
            		 ::Dynamic printSides = __o_printSides;
            		if (::hx::IsNull(__o_printSides)) printSides = false;
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_2dbda5e369a0ff2f_532_ellipseTri)
HXLINE( 533)		Float rSmall;
HXDLIN( 533)		if ((rx > ry)) {
HXLINE( 533)			rSmall = ry;
            		}
            		else {
HXLINE( 533)			rSmall = rx;
            		}
HXLINE( 534)		 ::Dynamic targetE = targetError;
HXDLIN( 534)		if (::hx::IsNull( targetE )) {
HXLINE( 534)			targetE = ((Float)1.05);
            		}
HXDLIN( 534)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 534)		int noSides;
HXDLIN( 534)		if ((result < 12)) {
HXLINE( 534)			noSides = 12;
            		}
            		else {
HXLINE( 534)			if ((result > 500)) {
HXLINE( 534)				noSides = 500;
            			}
            			else {
HXLINE( 534)				noSides = result;
            			}
            		}
HXLINE( 535)		if (( (bool)(printSides) )) {
HXLINE( 535)			::haxe::Log_obj::trace(noSides,::hx::SourceInfo(HX_("src/pi_xy/imageAbstracts/FillShape.hx",c6,54,99,b6),535,HX_("pi_xy.imageAbstracts._FillShape.FillShape_Impl_",00,16,01,24),HX_("ellipseTri",ed,3e,df,4c)));
            		}
HXLINE( 536)		{
HXLINE( 536)			 ::Dynamic phi1 = phi;
HXDLIN( 536)			 ::Dynamic sides = noSides;
HXLINE( 540)			if (::hx::IsNull( sides )) {
HXLINE( 540)				sides = 36;
            			}
HXLINE( 539)			if (::hx::IsNull( phi1 )) {
HXLINE( 539)				phi1 = ((Float)0.);
            			}
HXLINE( 536)			{
HXLINE( 536)				 ::Dynamic phi2 = phi1;
HXDLIN( 536)				 ::Dynamic sides1 = sides;
HXDLIN( 536)				if (::hx::IsNull( sides1 )) {
HXLINE( 212)					sides1 = 36;
            				}
HXLINE( 536)				if (::hx::IsNull( phi2 )) {
HXLINE( 211)					phi2 = ((Float)0.);
            				}
HXLINE( 536)				Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 536)				Float omega;
HXDLIN( 536)				omega = ((Float)0.);
HXDLIN( 536)				Float lastX = ((Float)0.);
HXDLIN( 536)				Float lastY = ((Float)0.);
HXDLIN( 536)				if (::hx::IsNotEq( phi2,0 )) {
HXLINE(  35)					lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE(  36)					lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            				}
            				else {
HXLINE(  38)					lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)					lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            				}
HXLINE( 536)				if (::hx::IsNotEq( phi2,0 )) {
HXLINE( 536)					Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 536)					Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 536)					{
HXLINE( 536)						int _g = 0;
HXDLIN( 536)						int _g1 = (sides1 + 1);
HXDLIN( 536)						while((_g < _g1)){
HXLINE( 536)							_g = (_g + 1);
HXDLIN( 536)							int i = (_g - 1);
HXDLIN( 536)							Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 536)							Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 536)							Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 536)							Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 536)							{
HXLINE( 536)								 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 536)								bool hasHit = false;
HXDLIN( 536)								bool hasUndo = false;
HXDLIN( 536)								{
HXLINE( 536)									Float bx = lastX;
HXDLIN( 536)									Float by = lastY;
HXDLIN( 536)									Float cx1 = nextX;
HXDLIN( 536)									Float cy1 = nextY;
HXDLIN( 536)									bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 536)									if (!(adjustWinding)) {
HXLINE( 536)										Float bx_ = bx;
HXDLIN( 536)										Float by_ = by;
HXLINE(  25)										bx = cx1;
HXLINE(  26)										by = cy1;
HXLINE(  27)										cx1 = bx_;
HXLINE(  28)										cy1 = by_;
            									}
HXLINE( 536)									{
HXLINE( 536)										Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 536)										Float sx = (cy1 - cy);
HXDLIN( 536)										Float sy = (cx - cx1);
HXDLIN( 536)										Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 536)										Float tx = (cy - by);
HXDLIN( 536)										Float ty = (bx - cx);
HXDLIN( 536)										Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 536)										 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 536)										if ((cx > bx)) {
HXLINE( 536)											if ((cx > cx1)) {
HXLINE( 536)												int min;
HXDLIN( 536)												if ((bx > cx1)) {
HXLINE( 536)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE( 536)													min = ::Math_obj::floor(bx);
            												}
HXDLIN( 536)												int ii_min = min;
HXDLIN( 536)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 536)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            											}
            											else {
HXLINE( 536)												int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 536)												int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 536)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            											}
            										}
            										else {
HXLINE( 536)											if ((bx > cx1)) {
HXLINE( 536)												int min1;
HXDLIN( 536)												if ((cx > cx1)) {
HXLINE( 536)													min1 = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE( 536)													min1 = ::Math_obj::ceil(cx);
            												}
HXDLIN( 536)												int ii_min2 = min1;
HXDLIN( 536)												int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 536)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            											}
            											else {
HXLINE( 536)												int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 536)												int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 536)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            											}
            										}
HXDLIN( 536)										 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 536)										if ((cy > by)) {
HXLINE( 536)											if ((cy > cy1)) {
HXLINE( 536)												int min2;
HXDLIN( 536)												if ((by > cy1)) {
HXLINE( 536)													min2 = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE( 536)													min2 = ::Math_obj::floor(by);
            												}
HXDLIN( 536)												int ii_min4 = min2;
HXDLIN( 536)												int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 536)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            											}
            											else {
HXLINE( 536)												int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 536)												int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 536)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            											}
            										}
            										else {
HXLINE( 536)											if ((by > cy1)) {
HXLINE( 536)												int min3;
HXDLIN( 536)												if ((cy > cy1)) {
HXLINE( 536)													min3 = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE( 536)													min3 = ::Math_obj::ceil(cy);
            												}
HXDLIN( 536)												int ii_min6 = min3;
HXDLIN( 536)												int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 536)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            											}
            											else {
HXLINE( 536)												int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 536)												int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 536)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            											}
            										}
HXDLIN( 536)										 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 536)										if (hasUndo) {
HXLINE( 536)											int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 536)											int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 536)											 ::Dynamic imageType = null();
HXDLIN( 536)											 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 536)											if (::hx::IsNull( imageType )) {
HXLINE(  54)												imageType = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 536)											::Dynamic undoImage1;
HXDLIN( 536)											switch((int)(( (int)(imageType) ))){
            												case (int)0: {
HXLINE( 536)													 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 536)													 ::iterMagic::BytesImg b = byt;
HXDLIN( 536)													{
HXLINE( 536)														b->width = width;
HXDLIN( 536)														b->height = height;
HXDLIN( 536)														b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 536)														b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 536)														{
HXLINE( 536)															int len = b->length;
HXDLIN( 536)															int w = 0;
HXDLIN( 536)															{
HXLINE( 536)																int _g2 = 0;
HXDLIN( 536)																int _g3 = b->height;
HXDLIN( 536)																while((_g2 < _g3)){
HXLINE( 536)																	_g2 = (_g2 + 1);
HXDLIN( 536)																	int y = (_g2 - 1);
HXDLIN( 536)																	{
HXLINE( 536)																		int _g4 = 0;
HXDLIN( 536)																		int _g5 = b->width;
HXDLIN( 536)																		while((_g4 < _g5)){
HXLINE( 536)																			_g4 = (_g4 + 1);
HXDLIN( 536)																			int x = (_g4 - 1);
HXDLIN( 536)																			{
HXLINE( 536)																				w = (w + 1);
HXDLIN( 536)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 536)																			{
HXLINE( 536)																				w = (w + 1);
HXDLIN( 536)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 536)																			{
HXLINE( 536)																				w = (w + 1);
HXDLIN( 536)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 536)																			{
HXLINE( 536)																				w = (w + 1);
HXDLIN( 536)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 536)													undoImage1 = b;
            												}
            												break;
            												case (int)1: {
HXLINE( 536)													 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 536)													 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 536)													{
HXLINE( 536)														a->width = width;
HXDLIN( 536)														a->height = height;
HXDLIN( 536)														a->data = ::Array_obj< int >::__new(0);
HXDLIN( 536)														a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 536)														{
HXLINE( 536)															int _g6 = 0;
HXDLIN( 536)															int _g7 = a->length;
HXDLIN( 536)															while((_g6 < _g7)){
HXLINE( 536)																_g6 = (_g6 + 1);
HXDLIN( 536)																int i1 = (_g6 - 1);
HXDLIN( 536)																a->data[i1] = 0;
            															}
            														}
            													}
HXDLIN( 536)													undoImage1 = a;
            												}
            												break;
            												case (int)2: {
HXLINE( 536)													 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 536)													 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 536)													{
HXLINE( 536)														b1->width = width;
HXDLIN( 536)														b1->height = height;
HXDLIN( 536)														b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 536)														int size = (b1->length * 4);
HXDLIN( 536)														b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 536)														{
HXLINE( 536)															int _g8 = 0;
HXDLIN( 536)															int _g9 = b1->length;
HXDLIN( 536)															while((_g8 < _g9)){
HXLINE( 536)																_g8 = (_g8 + 1);
HXDLIN( 536)																int i2 = (_g8 - 1);
HXDLIN( 536)																{
HXLINE( 536)																	 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 536)																	bool undoImage2;
HXDLIN( 536)																	if ((i2 >= 0)) {
HXLINE( 536)																		undoImage2 = (i2 < (this4->byteLength >> 2));
            																	}
            																	else {
HXLINE( 536)																		undoImage2 = false;
            																	}
HXDLIN( 536)																	if (undoImage2) {
HXLINE( 536)																		 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 536)																		int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 536)																		_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 536)																		_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 536)																		_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 536)																		_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 536)													undoImage1 = b1;
            												}
            												break;
            												case (int)3: {
HXLINE( 536)													 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 536)													 ::iterMagic::VecIntImg v = vec;
HXDLIN( 536)													{
HXLINE( 536)														v->width = width;
HXDLIN( 536)														v->height = height;
HXDLIN( 536)														v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 536)														v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 536)														{
HXLINE( 536)															int _g10 = 0;
HXDLIN( 536)															int _g11 = v->length;
HXDLIN( 536)															while((_g10 < _g11)){
HXLINE( 536)																_g10 = (_g10 + 1);
HXDLIN( 536)																int i3 = (_g10 - 1);
HXDLIN( 536)																v->data->__unsafe_set(i3,0);
            															}
            														}
            													}
HXDLIN( 536)													undoImage1 = v;
            												}
            												break;
            												case (int)4: {
HXLINE( 536)													 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 536)													 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 536)													{
HXLINE( 536)														b2->width = width;
HXDLIN( 536)														b2->height = height;
HXDLIN( 536)														b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 536)														b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 536)														{
HXLINE( 536)															int len1 = b2->length;
HXDLIN( 536)															 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 536)															if (::hx::IsNull( d->head )) {
HXLINE( 536)																int _g12 = 0;
HXDLIN( 536)																int _g13 = len1;
HXDLIN( 536)																while((_g12 < _g13)){
HXLINE( 536)																	_g12 = (_g12 + 1);
HXDLIN( 536)																	int i4 = (_g12 - 1);
HXDLIN( 536)																	d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            																}
            															}
            															else {
HXLINE( 536)																int _g14 = 0;
HXDLIN( 536)																int _g15 = len1;
HXDLIN( 536)																while((_g14 < _g15)){
HXLINE( 536)																	_g14 = (_g14 + 1);
HXDLIN( 536)																	int i5 = (_g14 - 1);
HXDLIN( 536)																	{
HXLINE( 536)																		 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 536)																		 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 536)																		{
HXLINE( 536)																			int _g16 = 0;
HXDLIN( 536)																			int _g17 = i5;
HXDLIN( 536)																			while((_g16 < _g17)){
HXLINE( 536)																				_g16 = (_g16 + 1);
HXDLIN( 536)																				int i6 = (_g16 - 1);
HXLINE( 345)																				prev = l;
HXLINE( 346)																				l = l->next;
            																			}
            																		}
HXLINE( 536)																		if (::hx::IsNull( prev )) {
HXLINE( 536)																			b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 536)																			l = null();
            																		}
            																		else {
HXLINE( 536)																			prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 536)																			l = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 536)													undoImage1 = b2;
            												}
            												break;
            											}
HXDLIN( 536)											this3->image = undoImage1;
HXDLIN( 536)											this3->width = width;
HXDLIN( 536)											this3->height = height;
HXDLIN( 536)											this3->imageType = ( (int)(imageType) );
HXDLIN( 536)											undoImage = this3;
HXDLIN( 536)											{
HXLINE( 536)												int rectLeft = xIter3->start;
HXDLIN( 536)												int rectTop = yIter3->start;
HXDLIN( 536)												int rectRight = xIter3->max;
HXDLIN( 536)												bool forceClear = false;
HXDLIN( 536)												{
HXLINE( 536)													int _g18 = rectTop;
HXDLIN( 536)													int _g19 = yIter3->max;
HXDLIN( 536)													while((_g18 < _g19)){
HXLINE( 536)														_g18 = (_g18 + 1);
HXDLIN( 536)														int dy = (_g18 - 1);
HXDLIN( 536)														{
HXLINE( 536)															int _g20 = rectLeft;
HXDLIN( 536)															int _g21 = rectRight;
HXDLIN( 536)															while((_g20 < _g21)){
HXLINE( 536)																_g20 = (_g20 + 1);
HXDLIN( 536)																int dx = (_g20 - 1);
HXDLIN( 536)																::Dynamic this5 = this2->image;
HXDLIN( 536)																int index;
HXDLIN( 536)																if (this2->useVirtualPos) {
HXLINE( 536)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            																}
            																else {
HXLINE( 536)																	index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            																}
HXDLIN( 536)																int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 536)																int col;
HXDLIN( 536)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE( 536)																	col = c;
            																}
HXDLIN( 536)																bool _hx_tmp;
HXDLIN( 536)																if (this2->useMask) {
HXLINE( 536)																	_hx_tmp = ::hx::IsNotNull( this2->mask );
            																}
            																else {
HXLINE( 536)																	_hx_tmp = false;
            																}
HXDLIN( 536)																if (_hx_tmp) {
HXLINE( 536)																	 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 536)																	::Dynamic this7 = this6->image;
HXDLIN( 536)																	int index1;
HXDLIN( 536)																	if (this6->useVirtualPos) {
HXLINE( 536)																		index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																	}
            																	else {
HXLINE( 536)																		index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																	}
HXDLIN( 536)																	int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 536)																	int v1;
HXDLIN( 536)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																		v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																	}
            																	else {
HXLINE( 536)																		v1 = c1;
            																	}
HXDLIN( 536)																	int maskPixel = v1;
HXDLIN( 536)																	int this8 = col;
HXDLIN( 536)																	if ((maskPixel == 0)) {
HXLINE( 536)																		col = this8;
            																	}
            																	else {
HXLINE( 536)																		Float m0;
HXDLIN( 536)																		int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 536)																		if ((this9 == 0)) {
HXLINE( 536)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float m1;
HXDLIN( 536)																		int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 536)																		if ((this10 == 0)) {
HXLINE( 536)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float m2;
HXDLIN( 536)																		int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 536)																		if ((this11 == 0)) {
HXLINE( 536)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float m3;
HXDLIN( 536)																		int this12 = (maskPixel & 255);
HXDLIN( 536)																		if ((this12 == 0)) {
HXLINE( 536)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 536)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 536)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 536)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 536)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 536)																if ((col != 0)) {
HXLINE( 536)																	int x1 = (dx - rectLeft);
HXDLIN( 536)																	int y1 = (dy - rectTop);
HXDLIN( 536)																	int c2 = col;
HXDLIN( 536)																	bool _hx_tmp1;
HXDLIN( 536)																	if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 536)																		_hx_tmp1 = undoImage->transparent;
            																	}
            																	else {
HXLINE( 536)																		_hx_tmp1 = false;
            																	}
HXDLIN( 536)																	if (_hx_tmp1) {
HXLINE( 536)																		int location;
HXDLIN( 536)																		if (undoImage->useVirtualPos) {
HXLINE( 536)																			location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 536)																			location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																		}
HXDLIN( 536)																		int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 536)																		int this14;
HXDLIN( 536)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																			this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																		}
            																		else {
HXLINE( 536)																			this14 = this13;
            																		}
HXDLIN( 536)																		Float a1;
HXDLIN( 536)																		int this15 = ((this14 >> 24) & 255);
HXDLIN( 536)																		if ((this15 == 0)) {
HXLINE( 536)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float r1;
HXDLIN( 536)																		int this16 = ((this14 >> 16) & 255);
HXDLIN( 536)																		if ((this16 == 0)) {
HXLINE( 536)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float g1;
HXDLIN( 536)																		int this17 = ((this14 >> 8) & 255);
HXDLIN( 536)																		if ((this17 == 0)) {
HXLINE( 536)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float b11;
HXDLIN( 536)																		int this18 = (this14 & 255);
HXDLIN( 536)																		if ((this18 == 0)) {
HXLINE( 536)																			b11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float a2;
HXDLIN( 536)																		int this19 = ((col >> 24) & 255);
HXDLIN( 536)																		if ((this19 == 0)) {
HXLINE( 536)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float r2;
HXDLIN( 536)																		int this20 = ((col >> 16) & 255);
HXDLIN( 536)																		if ((this20 == 0)) {
HXLINE( 536)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float g2;
HXDLIN( 536)																		int this21 = ((col >> 8) & 255);
HXDLIN( 536)																		if ((this21 == 0)) {
HXLINE( 536)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float b21;
HXDLIN( 536)																		int this22 = (col & 255);
HXDLIN( 536)																		if ((this22 == 0)) {
HXLINE( 536)																			b21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 536)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 536)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 536)																		int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 536)																		int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 536)																		int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 536)																		{
HXLINE( 536)																			int _hx_tmp2;
HXDLIN( 536)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																				_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE( 536)																				_hx_tmp2 = blended;
            																			}
HXDLIN( 536)																			::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																		}
            																	}
            																	else {
HXLINE( 536)																		::Dynamic this23 = undoImage->image;
HXDLIN( 536)																		int index2;
HXDLIN( 536)																		if (undoImage->useVirtualPos) {
HXLINE( 536)																			index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 536)																			index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																		}
HXDLIN( 536)																		int _hx_tmp3;
HXDLIN( 536)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																			_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																		}
            																		else {
HXLINE( 536)																			_hx_tmp3 = c2;
            																		}
HXDLIN( 536)																		::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																	}
            																}
            																else {
HXLINE( 536)																	if (forceClear) {
HXLINE( 536)																		::Dynamic this24 = undoImage->image;
HXDLIN( 536)																		int x2 = (dx - rectLeft);
HXDLIN( 536)																		int y2 = (dy - rectTop);
HXDLIN( 536)																		int index3;
HXDLIN( 536)																		if (undoImage->useVirtualPos) {
HXLINE( 536)																			index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 536)																			index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																		}
HXDLIN( 536)																		::iterMagic::Iimg_obj::set(this24,index3,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 536)										bool found = false;
HXDLIN( 536)										Float s = ((Float)0.);
HXDLIN( 536)										Float t = ((Float)0.);
HXDLIN( 536)										Float sxx = ((Float)0.);
HXDLIN( 536)										Float txx = ((Float)0.);
HXDLIN( 536)										{
HXLINE( 536)											int _g_min = xIter3->start;
HXDLIN( 536)											int _g_max = xIter3->max;
HXDLIN( 536)											while((_g_min < _g_max)){
HXLINE( 536)												_g_min = (_g_min + 1);
HXDLIN( 536)												int x3 = (_g_min - 1);
HXLINE(  60)												sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)												txx = (tx * ( (Float)(x3) ));
HXLINE(  62)												found = false;
HXLINE( 536)												{
HXLINE( 536)													int _g_min1 = yIter3->start;
HXDLIN( 536)													int _g_max1 = yIter3->max;
HXDLIN( 536)													while((_g_min1 < _g_max1)){
HXLINE( 536)														_g_min1 = (_g_min1 + 1);
HXDLIN( 536)														int y3 = (_g_min1 - 1);
HXLINE(  64)														s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)														t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 536)														bool _hx_tmp4;
HXDLIN( 536)														if (!((s <= 0))) {
HXLINE( 536)															_hx_tmp4 = (t <= 0);
            														}
            														else {
HXLINE( 536)															_hx_tmp4 = true;
            														}
HXDLIN( 536)														if (_hx_tmp4) {
HXLINE( 536)															if (found) {
HXLINE( 536)																goto _hx_goto_1056;
            															}
            														}
            														else {
HXLINE( 536)															if (((s + t) < A)) {
HXLINE( 536)																{
HXLINE( 536)																	int c3 = color;
HXDLIN( 536)																	bool _hx_tmp5;
HXDLIN( 536)																	if ((((c3 >> 24) & 255) < 254)) {
HXLINE( 536)																		_hx_tmp5 = this2->transparent;
            																	}
            																	else {
HXLINE( 536)																		_hx_tmp5 = false;
            																	}
HXDLIN( 536)																	if (_hx_tmp5) {
HXLINE( 536)																		int location1;
HXDLIN( 536)																		if (this2->useVirtualPos) {
HXLINE( 536)																			location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																		}
            																		else {
HXLINE( 536)																			location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																		}
HXDLIN( 536)																		int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 536)																		int this26;
HXDLIN( 536)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																			this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																		}
            																		else {
HXLINE( 536)																			this26 = this25;
            																		}
HXDLIN( 536)																		Float a11;
HXDLIN( 536)																		int this27 = ((this26 >> 24) & 255);
HXDLIN( 536)																		if ((this27 == 0)) {
HXLINE( 536)																			a11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float r11;
HXDLIN( 536)																		int this28 = ((this26 >> 16) & 255);
HXDLIN( 536)																		if ((this28 == 0)) {
HXLINE( 536)																			r11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float g11;
HXDLIN( 536)																		int this29 = ((this26 >> 8) & 255);
HXDLIN( 536)																		if ((this29 == 0)) {
HXLINE( 536)																			g11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float b12;
HXDLIN( 536)																		int this30 = (this26 & 255);
HXDLIN( 536)																		if ((this30 == 0)) {
HXLINE( 536)																			b12 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float a21;
HXDLIN( 536)																		int this31 = ((color >> 24) & 255);
HXDLIN( 536)																		if ((this31 == 0)) {
HXLINE( 536)																			a21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float r21;
HXDLIN( 536)																		int this32 = ((color >> 16) & 255);
HXDLIN( 536)																		if ((this32 == 0)) {
HXLINE( 536)																			r21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float g21;
HXDLIN( 536)																		int this33 = ((color >> 8) & 255);
HXDLIN( 536)																		if ((this33 == 0)) {
HXLINE( 536)																			g21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float b22;
HXDLIN( 536)																		int this34 = (color & 255);
HXDLIN( 536)																		if ((this34 == 0)) {
HXLINE( 536)																			b22 = ((Float)0.);
            																		}
            																		else {
HXLINE( 536)																			b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																		}
HXDLIN( 536)																		Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 536)																		int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 536)																		int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 536)																		int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 536)																		int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 536)																		int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 536)																		{
HXLINE( 536)																			int _hx_tmp6;
HXDLIN( 536)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																				_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																			}
            																			else {
HXLINE( 536)																				_hx_tmp6 = blended1;
            																			}
HXDLIN( 536)																			::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																		}
            																	}
            																	else {
HXLINE( 536)																		::Dynamic this35 = this2->image;
HXDLIN( 536)																		int index4;
HXDLIN( 536)																		if (this2->useVirtualPos) {
HXLINE( 536)																			index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																		}
            																		else {
HXLINE( 536)																			index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																		}
HXDLIN( 536)																		int _hx_tmp7;
HXDLIN( 536)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																			_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																		}
            																		else {
HXLINE( 536)																			_hx_tmp7 = c3;
            																		}
HXDLIN( 536)																		::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																	}
            																}
HXLINE(  73)																found = true;
            															}
            															else {
HXLINE( 536)																if (found) {
HXLINE( 536)																	goto _hx_goto_1056;
            																}
            															}
            														}
            													}
            													_hx_goto_1056:;
            												}
            											}
            										}
HXDLIN( 536)										if ((hasHit == true)) {
HXLINE( 536)											 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 536)											if (hasUndo) {
HXLINE( 536)												v2->undoImage = undoImage;
HXDLIN( 536)												v2->undoX = xIter3->start;
HXDLIN( 536)												v2->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  51)							lastX = nextX;
HXLINE(  52)							lastY = nextY;
            						}
            					}
            				}
            				else {
HXLINE( 536)					int _g22 = 0;
HXDLIN( 536)					int _g23 = (sides1 + 1);
HXDLIN( 536)					while((_g22 < _g23)){
HXLINE( 536)						_g22 = (_g22 + 1);
HXDLIN( 536)						int i7 = (_g22 - 1);
HXDLIN( 536)						Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 536)						Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 536)						{
HXLINE( 536)							 ::pi_xy::ImageStruct this36 = this1;
HXDLIN( 536)							bool hasHit1 = false;
HXDLIN( 536)							bool hasUndo1 = false;
HXDLIN( 536)							{
HXLINE( 536)								Float bx1 = lastX;
HXDLIN( 536)								Float by1 = lastY;
HXDLIN( 536)								Float cx2 = nextX1;
HXDLIN( 536)								Float cy2 = nextY1;
HXDLIN( 536)								bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 536)								if (!(adjustWinding1)) {
HXLINE( 536)									Float bx_1 = bx1;
HXDLIN( 536)									Float by_1 = by1;
HXLINE(  25)									bx1 = cx2;
HXLINE(  26)									by1 = cy2;
HXLINE(  27)									cx2 = bx_1;
HXLINE(  28)									cy2 = by_1;
            								}
HXLINE( 536)								{
HXLINE( 536)									Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 536)									Float sx1 = (cy2 - cy);
HXDLIN( 536)									Float sy1 = (cx - cx2);
HXDLIN( 536)									Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 536)									Float tx1 = (cy - by1);
HXDLIN( 536)									Float ty1 = (bx1 - cx);
HXDLIN( 536)									Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 536)									 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 536)									if ((cx > bx1)) {
HXLINE( 536)										if ((cx > cx2)) {
HXLINE( 536)											int min4;
HXDLIN( 536)											if ((bx1 > cx2)) {
HXLINE( 536)												min4 = ::Math_obj::floor(cx2);
            											}
            											else {
HXLINE( 536)												min4 = ::Math_obj::floor(bx1);
            											}
HXDLIN( 536)											int ii_min8 = min4;
HXDLIN( 536)											int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 536)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            										}
            										else {
HXLINE( 536)											int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 536)											int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 536)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            										}
            									}
            									else {
HXLINE( 536)										if ((bx1 > cx2)) {
HXLINE( 536)											int min5;
HXDLIN( 536)											if ((cx > cx2)) {
HXLINE( 536)												min5 = ::Math_obj::floor(cx2);
            											}
            											else {
HXLINE( 536)												min5 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 536)											int ii_min10 = min5;
HXDLIN( 536)											int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 536)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            										}
            										else {
HXLINE( 536)											int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 536)											int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 536)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            										}
            									}
HXDLIN( 536)									 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 536)									if ((cy > by1)) {
HXLINE( 536)										if ((cy > cy2)) {
HXLINE( 536)											int min6;
HXDLIN( 536)											if ((by1 > cy2)) {
HXLINE( 536)												min6 = ::Math_obj::floor(cy2);
            											}
            											else {
HXLINE( 536)												min6 = ::Math_obj::floor(by1);
            											}
HXDLIN( 536)											int ii_min12 = min6;
HXDLIN( 536)											int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 536)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            										}
            										else {
HXLINE( 536)											int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 536)											int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 536)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            										}
            									}
            									else {
HXLINE( 536)										if ((by1 > cy2)) {
HXLINE( 536)											int min7;
HXDLIN( 536)											if ((cy > cy2)) {
HXLINE( 536)												min7 = ::Math_obj::floor(cy2);
            											}
            											else {
HXLINE( 536)												min7 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 536)											int ii_min14 = min7;
HXDLIN( 536)											int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 536)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            										}
            										else {
HXLINE( 536)											int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 536)											int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 536)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            										}
            									}
HXDLIN( 536)									 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 536)									if (hasUndo1) {
HXLINE( 536)										int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 536)										int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 536)										 ::Dynamic imageType1 = null();
HXDLIN( 536)										 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 536)										if (::hx::IsNull( imageType1 )) {
HXLINE(  54)											imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 536)										::Dynamic undoImage4;
HXDLIN( 536)										switch((int)(( (int)(imageType1) ))){
            											case (int)0: {
HXLINE( 536)												 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 536)												 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 536)												{
HXLINE( 536)													b5->width = width1;
HXDLIN( 536)													b5->height = height1;
HXDLIN( 536)													b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 536)													b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 536)													{
HXLINE( 536)														int len2 = b5->length;
HXDLIN( 536)														int w1 = 0;
HXDLIN( 536)														{
HXLINE( 536)															int _g24 = 0;
HXDLIN( 536)															int _g25 = b5->height;
HXDLIN( 536)															while((_g24 < _g25)){
HXLINE( 536)																_g24 = (_g24 + 1);
HXDLIN( 536)																int y4 = (_g24 - 1);
HXDLIN( 536)																{
HXLINE( 536)																	int _g26 = 0;
HXDLIN( 536)																	int _g27 = b5->width;
HXDLIN( 536)																	while((_g26 < _g27)){
HXLINE( 536)																		_g26 = (_g26 + 1);
HXDLIN( 536)																		int x4 = (_g26 - 1);
HXDLIN( 536)																		{
HXLINE( 536)																			w1 = (w1 + 1);
HXDLIN( 536)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 536)																		{
HXLINE( 536)																			w1 = (w1 + 1);
HXDLIN( 536)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 536)																		{
HXLINE( 536)																			w1 = (w1 + 1);
HXDLIN( 536)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 536)																		{
HXLINE( 536)																			w1 = (w1 + 1);
HXDLIN( 536)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 536)												undoImage4 = b5;
            											}
            											break;
            											case (int)1: {
HXLINE( 536)												 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 536)												 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 536)												{
HXLINE( 536)													a6->width = width1;
HXDLIN( 536)													a6->height = height1;
HXDLIN( 536)													a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 536)													a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 536)													{
HXLINE( 536)														int _g28 = 0;
HXDLIN( 536)														int _g29 = a6->length;
HXDLIN( 536)														while((_g28 < _g29)){
HXLINE( 536)															_g28 = (_g28 + 1);
HXDLIN( 536)															int i8 = (_g28 - 1);
HXDLIN( 536)															a6->data[i8] = 0;
            														}
            													}
            												}
HXDLIN( 536)												undoImage4 = a6;
            											}
            											break;
            											case (int)2: {
HXLINE( 536)												 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 536)												 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 536)												{
HXLINE( 536)													b6->width = width1;
HXDLIN( 536)													b6->height = height1;
HXDLIN( 536)													b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 536)													int size1 = (b6->length * 4);
HXDLIN( 536)													b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 536)													{
HXLINE( 536)														int _g30 = 0;
HXDLIN( 536)														int _g31 = b6->length;
HXDLIN( 536)														while((_g30 < _g31)){
HXLINE( 536)															_g30 = (_g30 + 1);
HXDLIN( 536)															int i9 = (_g30 - 1);
HXDLIN( 536)															{
HXLINE( 536)																 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN( 536)																bool undoImage5;
HXDLIN( 536)																if ((i9 >= 0)) {
HXLINE( 536)																	undoImage5 = (i9 < (this38->byteLength >> 2));
            																}
            																else {
HXLINE( 536)																	undoImage5 = false;
            																}
HXDLIN( 536)																if (undoImage5) {
HXLINE( 536)																	 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN( 536)																	int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN( 536)																	_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 536)																	_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 536)																	_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 536)																	_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 536)												undoImage4 = b6;
            											}
            											break;
            											case (int)3: {
HXLINE( 536)												 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 536)												 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 536)												{
HXLINE( 536)													v3->width = width1;
HXDLIN( 536)													v3->height = height1;
HXDLIN( 536)													v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 536)													v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 536)													{
HXLINE( 536)														int _g32 = 0;
HXDLIN( 536)														int _g33 = v3->length;
HXDLIN( 536)														while((_g32 < _g33)){
HXLINE( 536)															_g32 = (_g32 + 1);
HXDLIN( 536)															int i10 = (_g32 - 1);
HXDLIN( 536)															v3->data->__unsafe_set(i10,0);
            														}
            													}
            												}
HXDLIN( 536)												undoImage4 = v3;
            											}
            											break;
            											case (int)4: {
HXLINE( 536)												 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 536)												 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 536)												{
HXLINE( 536)													b7->width = width1;
HXDLIN( 536)													b7->height = height1;
HXDLIN( 536)													b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 536)													b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 536)													{
HXLINE( 536)														int len3 = b7->length;
HXDLIN( 536)														 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 536)														if (::hx::IsNull( d1->head )) {
HXLINE( 536)															int _g34 = 0;
HXDLIN( 536)															int _g35 = len3;
HXDLIN( 536)															while((_g34 < _g35)){
HXLINE( 536)																_g34 = (_g34 + 1);
HXDLIN( 536)																int i11 = (_g34 - 1);
HXDLIN( 536)																d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            															}
            														}
            														else {
HXLINE( 536)															int _g36 = 0;
HXDLIN( 536)															int _g37 = len3;
HXDLIN( 536)															while((_g36 < _g37)){
HXLINE( 536)																_g36 = (_g36 + 1);
HXDLIN( 536)																int i12 = (_g36 - 1);
HXDLIN( 536)																{
HXLINE( 536)																	 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 536)																	 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 536)																	{
HXLINE( 536)																		int _g38 = 0;
HXDLIN( 536)																		int _g39 = i12;
HXDLIN( 536)																		while((_g38 < _g39)){
HXLINE( 536)																			_g38 = (_g38 + 1);
HXDLIN( 536)																			int i13 = (_g38 - 1);
HXLINE( 345)																			prev1 = l1;
HXLINE( 346)																			l1 = l1->next;
            																		}
            																	}
HXLINE( 536)																	if (::hx::IsNull( prev1 )) {
HXLINE( 536)																		b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 536)																		l1 = null();
            																	}
            																	else {
HXLINE( 536)																		prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 536)																		l1 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 536)												undoImage4 = b7;
            											}
            											break;
            										}
HXDLIN( 536)										this37->image = undoImage4;
HXDLIN( 536)										this37->width = width1;
HXDLIN( 536)										this37->height = height1;
HXDLIN( 536)										this37->imageType = ( (int)(imageType1) );
HXDLIN( 536)										undoImage3 = this37;
HXDLIN( 536)										{
HXLINE( 536)											int rectLeft1 = xIter31->start;
HXDLIN( 536)											int rectTop1 = yIter31->start;
HXDLIN( 536)											int rectRight1 = xIter31->max;
HXDLIN( 536)											bool forceClear1 = false;
HXDLIN( 536)											{
HXLINE( 536)												int _g40 = rectTop1;
HXDLIN( 536)												int _g41 = yIter31->max;
HXDLIN( 536)												while((_g40 < _g41)){
HXLINE( 536)													_g40 = (_g40 + 1);
HXDLIN( 536)													int dy1 = (_g40 - 1);
HXDLIN( 536)													{
HXLINE( 536)														int _g42 = rectLeft1;
HXDLIN( 536)														int _g43 = rectRight1;
HXDLIN( 536)														while((_g42 < _g43)){
HXLINE( 536)															_g42 = (_g42 + 1);
HXDLIN( 536)															int dx1 = (_g42 - 1);
HXDLIN( 536)															::Dynamic this39 = this36->image;
HXDLIN( 536)															int index5;
HXDLIN( 536)															if (this36->useVirtualPos) {
HXLINE( 536)																index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            															}
            															else {
HXLINE( 536)																index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            															}
HXDLIN( 536)															int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN( 536)															int col1;
HXDLIN( 536)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            															}
            															else {
HXLINE( 536)																col1 = c4;
            															}
HXDLIN( 536)															bool _hx_tmp8;
HXDLIN( 536)															if (this36->useMask) {
HXLINE( 536)																_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            															}
            															else {
HXLINE( 536)																_hx_tmp8 = false;
            															}
HXDLIN( 536)															if (_hx_tmp8) {
HXLINE( 536)																 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN( 536)																::Dynamic this41 = this40->image;
HXDLIN( 536)																int index6;
HXDLIN( 536)																if (this40->useVirtualPos) {
HXLINE( 536)																	index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            																}
            																else {
HXLINE( 536)																	index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            																}
HXDLIN( 536)																int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 536)																int v4;
HXDLIN( 536)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																	v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            																}
            																else {
HXLINE( 536)																	v4 = c5;
            																}
HXDLIN( 536)																int maskPixel1 = v4;
HXDLIN( 536)																int this42 = col1;
HXDLIN( 536)																if ((maskPixel1 == 0)) {
HXLINE( 536)																	col1 = this42;
            																}
            																else {
HXLINE( 536)																	Float m01;
HXDLIN( 536)																	int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN( 536)																	if ((this43 == 0)) {
HXLINE( 536)																		m01 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float m11;
HXDLIN( 536)																	int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN( 536)																	if ((this44 == 0)) {
HXLINE( 536)																		m11 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float m21;
HXDLIN( 536)																	int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN( 536)																	if ((this45 == 0)) {
HXLINE( 536)																		m21 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float m31;
HXDLIN( 536)																	int this46 = (maskPixel1 & 255);
HXDLIN( 536)																	if ((this46 == 0)) {
HXLINE( 536)																		m31 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN( 536)																	int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN( 536)																	int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN( 536)																	int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN( 536)																	col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 536)															if ((col1 != 0)) {
HXLINE( 536)																int x5 = (dx1 - rectLeft1);
HXDLIN( 536)																int y5 = (dy1 - rectTop1);
HXDLIN( 536)																int c6 = col1;
HXDLIN( 536)																bool _hx_tmp9;
HXDLIN( 536)																if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 536)																	_hx_tmp9 = undoImage3->transparent;
            																}
            																else {
HXLINE( 536)																	_hx_tmp9 = false;
            																}
HXDLIN( 536)																if (_hx_tmp9) {
HXLINE( 536)																	int location2;
HXDLIN( 536)																	if (undoImage3->useVirtualPos) {
HXLINE( 536)																		location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																	}
            																	else {
HXLINE( 536)																		location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																	}
HXDLIN( 536)																	int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 536)																	int this48;
HXDLIN( 536)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																		this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																	}
            																	else {
HXLINE( 536)																		this48 = this47;
            																	}
HXDLIN( 536)																	Float a12;
HXDLIN( 536)																	int this49 = ((this48 >> 24) & 255);
HXDLIN( 536)																	if ((this49 == 0)) {
HXLINE( 536)																		a12 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float r12;
HXDLIN( 536)																	int this50 = ((this48 >> 16) & 255);
HXDLIN( 536)																	if ((this50 == 0)) {
HXLINE( 536)																		r12 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float g12;
HXDLIN( 536)																	int this51 = ((this48 >> 8) & 255);
HXDLIN( 536)																	if ((this51 == 0)) {
HXLINE( 536)																		g12 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float b13;
HXDLIN( 536)																	int this52 = (this48 & 255);
HXDLIN( 536)																	if ((this52 == 0)) {
HXLINE( 536)																		b13 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float a22;
HXDLIN( 536)																	int this53 = ((col1 >> 24) & 255);
HXDLIN( 536)																	if ((this53 == 0)) {
HXLINE( 536)																		a22 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float r22;
HXDLIN( 536)																	int this54 = ((col1 >> 16) & 255);
HXDLIN( 536)																	if ((this54 == 0)) {
HXLINE( 536)																		r22 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float g22;
HXDLIN( 536)																	int this55 = ((col1 >> 8) & 255);
HXDLIN( 536)																	if ((this55 == 0)) {
HXLINE( 536)																		g22 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float b23;
HXDLIN( 536)																	int this56 = (col1 & 255);
HXDLIN( 536)																	if ((this56 == 0)) {
HXLINE( 536)																		b23 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 536)																	int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 536)																	int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 536)																	int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 536)																	int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 536)																	int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 536)																	{
HXLINE( 536)																		int _hx_tmp10;
HXDLIN( 536)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																			_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																		}
            																		else {
HXLINE( 536)																			_hx_tmp10 = blended2;
            																		}
HXDLIN( 536)																		::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																	}
            																}
            																else {
HXLINE( 536)																	::Dynamic this57 = undoImage3->image;
HXDLIN( 536)																	int index7;
HXDLIN( 536)																	if (undoImage3->useVirtualPos) {
HXLINE( 536)																		index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																	}
            																	else {
HXLINE( 536)																		index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																	}
HXDLIN( 536)																	int _hx_tmp11;
HXDLIN( 536)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																		_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																	}
            																	else {
HXLINE( 536)																		_hx_tmp11 = c6;
            																	}
HXDLIN( 536)																	::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            																}
            															}
            															else {
HXLINE( 536)																if (forceClear1) {
HXLINE( 536)																	::Dynamic this58 = undoImage3->image;
HXDLIN( 536)																	int x6 = (dx1 - rectLeft1);
HXDLIN( 536)																	int y6 = (dy1 - rectTop1);
HXDLIN( 536)																	int index8;
HXDLIN( 536)																	if (undoImage3->useVirtualPos) {
HXLINE( 536)																		index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																	}
            																	else {
HXLINE( 536)																		index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																	}
HXDLIN( 536)																	::iterMagic::Iimg_obj::set(this58,index8,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 536)									bool found1 = false;
HXDLIN( 536)									Float s1 = ((Float)0.);
HXDLIN( 536)									Float t1 = ((Float)0.);
HXDLIN( 536)									Float sxx1 = ((Float)0.);
HXDLIN( 536)									Float txx1 = ((Float)0.);
HXDLIN( 536)									{
HXLINE( 536)										int _g_min2 = xIter31->start;
HXDLIN( 536)										int _g_max2 = xIter31->max;
HXDLIN( 536)										while((_g_min2 < _g_max2)){
HXLINE( 536)											_g_min2 = (_g_min2 + 1);
HXDLIN( 536)											int x7 = (_g_min2 - 1);
HXLINE(  60)											sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)											txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)											found1 = false;
HXLINE( 536)											{
HXLINE( 536)												int _g_min3 = yIter31->start;
HXDLIN( 536)												int _g_max3 = yIter31->max;
HXDLIN( 536)												while((_g_min3 < _g_max3)){
HXLINE( 536)													_g_min3 = (_g_min3 + 1);
HXDLIN( 536)													int y7 = (_g_min3 - 1);
HXLINE(  64)													s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)													t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE( 536)													bool _hx_tmp12;
HXDLIN( 536)													if (!((s1 <= 0))) {
HXLINE( 536)														_hx_tmp12 = (t1 <= 0);
            													}
            													else {
HXLINE( 536)														_hx_tmp12 = true;
            													}
HXDLIN( 536)													if (_hx_tmp12) {
HXLINE( 536)														if (found1) {
HXLINE( 536)															goto _hx_goto_1069;
            														}
            													}
            													else {
HXLINE( 536)														if (((s1 + t1) < A1)) {
HXLINE( 536)															{
HXLINE( 536)																int c7 = color;
HXDLIN( 536)																bool _hx_tmp13;
HXDLIN( 536)																if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 536)																	_hx_tmp13 = this36->transparent;
            																}
            																else {
HXLINE( 536)																	_hx_tmp13 = false;
            																}
HXDLIN( 536)																if (_hx_tmp13) {
HXLINE( 536)																	int location3;
HXDLIN( 536)																	if (this36->useVirtualPos) {
HXLINE( 536)																		location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																	}
            																	else {
HXLINE( 536)																		location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																	}
HXDLIN( 536)																	int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN( 536)																	int this60;
HXDLIN( 536)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																		this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																	}
            																	else {
HXLINE( 536)																		this60 = this59;
            																	}
HXDLIN( 536)																	Float a13;
HXDLIN( 536)																	int this61 = ((this60 >> 24) & 255);
HXDLIN( 536)																	if ((this61 == 0)) {
HXLINE( 536)																		a13 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float r13;
HXDLIN( 536)																	int this62 = ((this60 >> 16) & 255);
HXDLIN( 536)																	if ((this62 == 0)) {
HXLINE( 536)																		r13 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float g13;
HXDLIN( 536)																	int this63 = ((this60 >> 8) & 255);
HXDLIN( 536)																	if ((this63 == 0)) {
HXLINE( 536)																		g13 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float b14;
HXDLIN( 536)																	int this64 = (this60 & 255);
HXDLIN( 536)																	if ((this64 == 0)) {
HXLINE( 536)																		b14 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float a23;
HXDLIN( 536)																	int this65 = ((color >> 24) & 255);
HXDLIN( 536)																	if ((this65 == 0)) {
HXLINE( 536)																		a23 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float r23;
HXDLIN( 536)																	int this66 = ((color >> 16) & 255);
HXDLIN( 536)																	if ((this66 == 0)) {
HXLINE( 536)																		r23 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float g23;
HXDLIN( 536)																	int this67 = ((color >> 8) & 255);
HXDLIN( 536)																	if ((this67 == 0)) {
HXLINE( 536)																		g23 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float b24;
HXDLIN( 536)																	int this68 = (color & 255);
HXDLIN( 536)																	if ((this68 == 0)) {
HXLINE( 536)																		b24 = ((Float)0.);
            																	}
            																	else {
HXLINE( 536)																		b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																	}
HXDLIN( 536)																	Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 536)																	int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 536)																	int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 536)																	int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 536)																	int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 536)																	int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 536)																	{
HXLINE( 536)																		int _hx_tmp14;
HXDLIN( 536)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																			_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																		}
            																		else {
HXLINE( 536)																			_hx_tmp14 = blended3;
            																		}
HXDLIN( 536)																		::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																	}
            																}
            																else {
HXLINE( 536)																	::Dynamic this69 = this36->image;
HXDLIN( 536)																	int index9;
HXDLIN( 536)																	if (this36->useVirtualPos) {
HXLINE( 536)																		index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																	}
            																	else {
HXLINE( 536)																		index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																	}
HXDLIN( 536)																	int _hx_tmp15;
HXDLIN( 536)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 536)																		_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																	}
            																	else {
HXLINE( 536)																		_hx_tmp15 = c7;
            																	}
HXDLIN( 536)																	::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            																}
            															}
HXLINE(  73)															found1 = true;
            														}
            														else {
HXLINE( 536)															if (found1) {
HXLINE( 536)																goto _hx_goto_1069;
            															}
            														}
            													}
            												}
            												_hx_goto_1069:;
            											}
            										}
            									}
HXDLIN( 536)									if ((hasHit1 == true)) {
HXLINE( 536)										 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 536)										if (hasUndo1) {
HXLINE( 536)											v5->undoImage = undoImage3;
HXDLIN( 536)											v5->undoX = xIter31->start;
HXDLIN( 536)											v5->undoY = yIter31->start;
            										}
            									}
            								}
            							}
            						}
HXLINE(  59)						lastX = nextX1;
HXLINE(  60)						lastY = nextY1;
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FillShape_Impl__obj,ellipseTri,(void))


FillShape_Impl__obj::FillShape_Impl__obj()
{
}

bool FillShape_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pie") ) { outValue = pie_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"quad") ) { outValue = quad_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"line") ) { outValue = line_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"arrow") ) { outValue = arrow_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"square") ) { outValue = square_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"circle") ) { outValue = circle_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"ellipse") ) { outValue = ellipse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"hexagon") ) { outValue = hexagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"octagon") ) { outValue = octagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"nonagon") ) { outValue = nonagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"decagon") ) { outValue = decagon_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"triangle") ) { outValue = triangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"quadrant") ) { outValue = quadrant_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"pentagon") ) { outValue = pentagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"heptagon") ) { outValue = heptagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"septagon") ) { outValue = septagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"enneagon") ) { outValue = enneagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sweepTri") ) { outValue = sweepTri_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"lineGrid") ) { outValue = lineGrid_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fixArrow") ) { outValue = fixArrow_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"quadrantI") ) { outValue = quadrantI_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"simonSays") ) { outValue = simonSays_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"polyBuild") ) { outValue = polyBuild_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"arrowHead") ) { outValue = arrowHead_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"undecagon") ) { outValue = undecagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"dodecagon") ) { outValue = dodecagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"arrowBoth") ) { outValue = arrowBoth_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"quadrantII") ) { outValue = quadrantII_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"quadrantIV") ) { outValue = quadrantIV_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"hendecagon") ) { outValue = hendecagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"lineGridWH") ) { outValue = lineGridWH_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"ellipseTri") ) { outValue = ellipseTri_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"quadrantIII") ) { outValue = quadrantIII_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fixArrowBoth") ) { outValue = fixArrowBoth_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"roundRectangle") ) { outValue = roundRectangle_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *FillShape_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *FillShape_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class FillShape_Impl__obj::__mClass;

static ::String FillShape_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("square",9d,00,f2,58),
	HX_("triangle",c8,be,c5,8d),
	HX_("quad",c7,38,0a,4b),
	HX_("line",f4,17,b3,47),
	HX_("roundRectangle",01,42,1b,34),
	HX_("quadrant",fc,f5,e7,e8),
	HX_("quadrantI",cd,46,0f,e2),
	HX_("quadrantII",dc,ac,4e,eb),
	HX_("quadrantIII",ed,93,88,f9),
	HX_("quadrantIV",e9,ac,4e,eb),
	HX_("simonSays",fe,20,9e,db),
	HX_("circle",10,72,0d,56),
	HX_("ellipse",de,40,86,0b),
	HX_("polyBuild",42,79,d2,50),
	HX_("arrowHead",89,e7,ae,00),
	HX_("pentagon",80,fe,32,74),
	HX_("hexagon",e0,87,45,9f),
	HX_("heptagon",46,26,56,77),
	HX_("septagon",9b,0d,81,ec),
	HX_("octagon",65,bc,0a,a8),
	HX_("nonagon",12,1f,56,d6),
	HX_("enneagon",65,90,46,d2),
	HX_("decagon",47,7e,85,e1),
	HX_("hendecagon",96,a7,b1,cc),
	HX_("undecagon",0e,85,87,dd),
	HX_("dodecagon",1c,fe,b1,14),
	HX_("pie",4c,58,55,00),
	HX_("sweepTri",9f,86,ef,d9),
	HX_("lineGrid",da,24,95,81),
	HX_("lineGridWH",6b,db,cb,ec),
	HX_("arrow",c9,79,8f,25),
	HX_("arrowBoth",ea,46,bf,fc),
	HX_("fixArrow",b4,63,f7,8b),
	HX_("fixArrowBoth",55,02,fa,ce),
	HX_("ellipseTri",ed,3e,df,4c),
	::String(null())
};

void FillShape_Impl__obj::__register()
{
	FillShape_Impl__obj _hx_dummy;
	FillShape_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._FillShape.FillShape_Impl_",00,16,01,24);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FillShape_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FillShape_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< FillShape_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FillShape_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FillShape_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _FillShape
